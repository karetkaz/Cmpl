// test the functions from Math

float64 testMathFloor_1 = Math.floor(3.2);
float64 testMathFloor_2 = Math.floor(3.5);
float64 testMathFloor_3 = Math.floor(3.6);
float64 testMathFloor_4 = Math.floor(-3.2);
float64 testMathFloor_5 = Math.floor(-3.5);
float64 testMathFloor_6 = Math.floor(-3.6);

float64 testMathSign_1F = Math.sign(0.2F);
float64 testMathSign_2F = Math.sign(0.0F);
float64 testMathSign_3F = Math.sign(-.9F);
float64 testMathSign_1f = Math.sign(0.2f);
float64 testMathSign_2f = Math.sign(0.0f);
float64 testMathSign_3f = Math.sign(-.9f);

float64 testMathAbs_1F = Math.abs(0.2F);
float64 testMathAbs_2F = Math.abs(0.0F);
float64 testMathAbs_3F = Math.abs(-.9F);
float64 testMathAbs_1f = Math.abs(0.2f);
float64 testMathAbs_2f = Math.abs(0.0f);
float64 testMathAbs_3f = Math.abs(-.9f);

float64 testMathMin_1f = Math.min(1f, 2f);
float64 testMathMax_2f = Math.max(1f, 2f);
float64 testMathMin_1F = Math.min(1F, 2F);
float64 testMathMax_2F = Math.max(1F, 2F);

float64 testMathClamp_1f = Math.clamp(10f, 0f, 1f);
float64 testMathClamp_1F = Math.clamp(10F, 0F, 1F);

float64 testMathLerp_1f = Math.lerp(.5f, 0f, 2f);
float64 testMathLerp_1F = Math.lerp(.5F, 0F, 2F);

float64 testMathSmooth_0f = Math.smooth(0f);
float64 testMathSmooth_0F = Math.smooth(0F);
float64 testMathSmooth_1f = Math.smooth(1f, 0f, 1f);
float64 testMathSmooth_1F = Math.smooth(1F, 0F, 1F);

float64 testMathMin_nan = Math.min();
float64 testMathMin_1 = Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6);
float64 testMathMax_nan = Math.max();
float64 testMathMax_9 = Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6);

float64 testMathSum_0 = Math.sum();
float64 testMathSum_1 = Math.sum(1);
float64 testMathSum_3 = Math.sum(1, 2);
float64 testMathSum_55 = Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

float64 testMathEval_x = 10;
float64 testMathEval_0 = Math.eval(testMathEval_x);
float64 testMathEval_1 = Math.eval(testMathEval_x, 1.);
float64 testMathEval_2 = Math.eval(testMathEval_x, 1., 1.);
float64 testMathEval_3 = Math.eval(testMathEval_x, 1., 1., 1.);
float64 testMathEval_4 = Math.eval(testMathEval_x, 1., 1., 1., 1.);
float64 testMathEval_5 = Math.eval(testMathEval_x, 1., 1., 1., 1., 1.);
float64 testMathEval_6 = Math.eval(testMathEval_x, 1., 1., 1., 1., 1., 1.);

static void assertEq(char func[*], float64 x, float64 returned, float64 expected) {
	inline epsilon = 1e-15;
	if (Math.cmp(returned, expected, epsilon) == 0) {
		return;
	}

	NotEquals details = {
		expected: expected;
		returned: returned;
		argument: x;
		message: func;
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}

static void assertEq(char func[*], float32 x, float32 returned, float32 expected) {
	inline epsilon = 1e-6f;
	if (Math.cmp(returned, expected, epsilon) == 0) {
		return;
	}

	NotEquals details = {
		expected: expected;
		returned: returned;
		argument: x;
		message: func;
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}

for (float64 t = 0; t < Math.pi; t += 1. / 1000) {
	assertEq("Sin", t, Math.sin(t), float64.sin(t));
	assertEq("Cos", t, Math.cos(t), float64.cos(t));
	assertEq("Sin", float32(t), float32(Math.sin(t)), float32.sin(t));
	assertEq("Cos", float32(t), float32(Math.cos(t)), float32.cos(t));
}

// TODO: improve aqquaricy remove padding of 0.4
for (float64 t = -Math.pi / 2 + .4; t < Math.pi / 2 - .4; t += 1. / 1000) {
	assertEq("Tan", t, Math.tan(t), float64.tan(t));
	assertEq("Tan", float32(t), float32(Math.tan(t)), float32.tan(t));
}


// TODO: add tests also these functions
//lib/std/math.ci:386:[.03dbb0, .03dca1): exec(0), time(0 / 0.000 ms): Math.sinh(x: float64): float64
//lib/std/math.ci:425:[.03dca8, .03dcf3): exec(0), time(0 / 0.000 ms): Math.cosh(x: float64): float64
//lib/std/math.ci:441:[.03dcf8, .03dd9e): exec(0), time(0 / 0.000 ms): Math.asin(x: float64): float64
//lib/std/math.Complex.ci:20:[.03dda0, .03dda7): exec(0), time(0 / 0.000 ms): Complex(re: float64): Complex
//lib/std/math.Complex.ci:25:[.03dda8, .03ddaf): exec(0), time(0 / 0.000 ms): Complex(re: float64, im: float64): Complex
//lib/std/math.Complex.ci:66:[.03ddb0, .03de2b): exec(0), time(0 / 0.000 ms): div(a: Complex, b: Complex): Complex
//lib/std/math.Complex.ci:93:[.03de30, .03de4f): exec(0), time(0 / 0.000 ms): inv(a: Complex): Complex
//lib/std/math.Complex.ci:107:[.03de50, .03deb4): exec(0), time(0 / 0.000 ms): pow(a: Complex, b: Complex): Complex
