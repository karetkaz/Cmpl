// requires `-X+glob` option to generate non static global variables

static if (typename(integer) == null) {
inline integer = int32;
}

static integer globalCounter = 33;

static integer globalInitCounter1 = globalCounter += 1;

struct Record {
	// member variable
	// compiler: WARN if not initialized when instantiated.
	int32 member;

	// member variable with default value
	// compiler: use default value if not initialized when instantiated.
	int32 memberInit = 42;

	// constant member variable
	// compiler: ERROR if not initialized when instantiated.
	// compiler: ERROR if assigned after initialization.
	const int32 memberConstant;

	// constant member variable with default value
	// compiler: use default value if not initialized when instantiated.
	// compiler: ERROR if assigned after initialization.
	const int32 memberConstantInit = 43;

	// global variable(hidden in class)
	// compiler: WARN if not initialized when declared.
	static int32 global = globalCounter += 1;

	// constant global variable(hidden in class)
	// compiler: ERROR if not initialized when declared.
	// compiler: ERROR if assigned after initialized.
	static const int32 globalConstant = globalCounter += 1;

	// static method (can not be overridden)
	static int staticMethod(int x, int y) {
		return x + y;
	}

	// static forward method
	static int forwardMethod(int x, int y);

	// virtual method (may be overridden when instantiated)
	int virtualMethod(int x, int y);

	// virtual method default implementation.
	int virtualMethod(int x, int y) {
		return x * y;
	}

	// abstract method (must be overridden when instantiated)
	// compiler: ERROR if not initialized/overridden when instantiated.
	int abstractMethod(int x, int y);

	// virtual method (may be overridden when instantiated)
	int methodReference(int x, int y) = staticMethod;

	// forward method implementation
	int forwardMethod(int x, int y) {
		return x * y;
	}
}

static integer globalInitCounter2 = globalCounter += 1;

integer initMethod(bool getRecord) {
	// function `initInner` must be generated before `initMethod`
	integer initInner(bool getRecord) {
		// global variable
		// compiler: WARN if not initialized when declared.
		static int32 global = globalCounter += 1;

		static struct Record {
			// global variable
			// compiler: WARN if not initialized when declared.
			static int32 global = globalCounter += 1;
		}

		return getRecord ? Record.global : global;
	}
	return initInner(getRecord);
}

integer localNoInit;
integer localInitGlobal = globalCounter;
integer localInitCounter = globalCounter += 1;
integer localInitLocal = localInitCounter;

static integer globalNoInit;
static integer globalInitCounter = globalCounter += 1;
static integer globalInitGlobal = globalCounter;
//static integer globalInitLocal = localInitCounter;     // compilation error: can not initialize static variable with local variable

integer localInitMethodGlobal = initMethod(false);
integer localInitMethodRecordGlobal = initMethod(true);

Record localObject;                   // TODO: object must be initialized
static Record globalObject;           // TODO: object must be initialized

int localStaticCallStaticMethod = Record.staticMethod(2, 5);
int localStaticCallForwardMethod = Record.forwardMethod(2, 6);
//int localStaticCallVirtualMethod = Record.virtualMethod(2, 7);              // FIXME: this should work
//int localStaticCallAbstractMethod = Record.abstractMethod(2, 8);            // compilation error: object reference required to access member
//int localStaticCallMethodReference = Record.methodReference(2, 9);          // compilation error: object reference required to access member

//int localLocalCallStaticMethod = localObject.staticMethod(2, 5);            // FIXME: this should work
//int localLocalCallForwardMethod = localObject.forwardMethod(2, 6);          // FIXME: this should work
//int localLocalCallVirtualMethod = localObject.virtualMethod(2, 7);          // FIXME: this should work
//int localLocalCallAbstractMethod = localObject.abstractMethod(2, 8);        // FIXME: this should work
//int localLocalCallMethodReference = localObject.methodReference(2, 9);      // FIXME: this should work
//int localGlobalCallStaticMethod = globalObject.staticMethod(2, 5);          // FIXME: this should work
//int localGlobalCallForwardMethod = globalObject.forwardMethod(2, 6);        // FIXME: this should work
//int localGlobalCallVirtualMethod = globalObject.virtualMethod(2, 7);        // FIXME: this should work
//int localGlobalCallAbstractMethod = globalObject.abstractMethod(2, 8);      // FIXME: this should work
//int localGlobalCallMethodReference = globalObject.methodReference(2, 9);    // FIXME: this should work

assert(globalCounter == 33 + 8);              // 8 increments
