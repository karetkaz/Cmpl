// simple ray-tracer

struct Camera {
	vec4f right;
	vec4f up;
	vec4f forward;
	vec4f position;

	Camera lookAt(vec4f position, vec4f target, vec4f up) {
	// TODO: Camera lookAt({vec4f position; vec4f target; vec4f up;}) {
		result.forward = normalize(target - position);
		result.right = normalize(cross(up, result.forward));
		result.up = cross(result.forward, result.right);
		result.position = position;
	}
}

struct Light {
	const vec4f position;
	const vec4f color;
	const float intensity = 10;
}

struct Ray {
	const vec4f position;
	const vec4f direction;
}


struct Shape: object {
	// abstract(uninitialized/unimplemented) method must be overridden
	bool intersect(Shape this, Ray &ray, float &outDistance);
}

struct Plane: Shape {
	const vec4f normal;
	const float offset;

	// override intersection method
	bool intersect(const Plane &this, const Ray &ray, float &outDistance) {
		float denom = dp3(ray.direction, this.normal);
		if (denom == 0) {
			return false;
		}
		outDistance = -(dp3(this.normal, ray.position) + this.offset) / denom;
		//~ vec4f outPosition = ray.position + (ray.direction * outDistance);
		//~ vec4f outNormal = this.normal;
		return true;
	}
}

struct Sphere: Shape {
	const vec4f position;
	const float radius;

	// override intersection method
	bool intersect(const Sphere &this, const Ray &ray, float &outDistance) {
		var dst = ray.position - this.position;
		var B = dp3(dst, ray.direction);
		var C = dp3(dst, dst) - (this.radius * this.radius);
		var D = B * B - C;

		if (D <= 0) {
			return false;
		}
		outDistance = -B - Math.sqrt(D);
		//~ vec4f outPosition = add(ray.position, mul(ray.direction, outDistance));
		//~ vec4f outNormal = normalize(sub(outPosition, this.position));
		return true;
	}
}

struct Scene {
	Camera camera;
	Light lights[];
	Shape things[];

	Shape intersect(const Scene &this, const Ray &ray) {
		result = null;
		float closest = Math.inf;
		for (Shape shape: this.things) {
			float distance;
			if (shape.intersect(ray, &distance)) {
				if (closest > distance) {
					closest = distance;
					result = shape;
				}
			}
		}
		return result;
	}

	void render(const Scene &this, int width, int height, void action(int x, int y, int color)) {
		for (int y = 0; y < height; y += 1) {
			for (int x = 0; x < width; x += 1) {
				// TODO: shade
				action(x, y, x ^ y);
			}
		}
	}
}

Scene scene = {
	camera: Camera.lookAt(vec4f(0, 0, -15), vec4f(-0.2, 0, 5), vec4f(0, 1, 0));
	/*TODO: camera: Camera.lookAt({
		position: vec4f(0, 0, -15);
		target: vec4f(-0.2, 0, 5);
		up: vec4f(0, 1, 0);
	});*/
	lights: [{
		position: vec4f(5, 10, -1);
		color: vec4f(0.8, 0.8, 0.8);
	}, {
		position: vec4f(-3, 5, -15);
		color: vec4f(0.8, 0.8, 0.8);
		intensity: 100;
	}];
	things: [
		Sphere {
			position: vec4f(-1.5, 1.5, 2);
			radius: 1.5;
		};
		Sphere {
			position: vec4f(1, 0.25, 1);
			radius: .5;
		};
		Plane {
			normal: normalize(vec4f(0.1, 0.9, -0.5));
			offset: 1.2;
		};
	];
};

Bitmap bitmap = Bitmap(1024, 1024);
scene.render(bitmap.width, bitmap.height, bitmap.setPixel);
