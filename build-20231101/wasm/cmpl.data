/// extension method to read a single byte from a file
int read(File file) {
	uint8 buff[1] = {0};
	if (file.read(buff) <= 0) {
		return -1;
	}
	return buff[0] & 0xff;
}

/// extension method to write a single byte into a file
int write(File file, int value) {
	uint8 buff[1] = {value};
	return file.write(buff);
}

static if (typename(Closeable) == object) {
inline "lib/FileStream.ci";
}

/* TODO: uncomment
static struct File {
	bool exists(char path[]);
	bool isFile(char path[]);
	bool isDirectory(char path[]);
	bool isAbsolute(char path[]);
	bool isReadable(char path[]);
	bool isWriteable(char path[]);
	bool isExecutable(char path[]);

	Path parent();
}*/
///@public
struct FileReader: ByteReader {
	const File file;

	int read(FileReader this, uint8 bytes[]) {
		return File.read(this.file, bytes);
	}

	void close(FileReader this) {
		File.close(this.file);
	}
}

///@public
struct FileWriter: ByteWriter {
	///@public
	const File file;

	void write(FileWriter this, byte bytes[]) {
		int wrote = File.write(this.file, bytes);
		assert(wrote == bytes.length);
	}

	void flush(FileWriter this) {
		File.flush(this.file);
	}

	void close(FileWriter this) {
		File.close(this.file);
	}
}

///@public
struct BufferedFileWriter: FileWriter {
	byte buffer[1024];
	int bufferSize = 0;

	static void flushBuffer(BufferedFileWriter this) {
		int wrote = File.write(this.file, this.buffer[... this.bufferSize]);
		assert(wrote == this.bufferSize);
		this.bufferSize = 0;
	}

	void write(BufferedFileWriter this, byte bytes[]) {
		if (this.bufferSize + bytes.length > this.buffer.length) {
			if (this.bufferSize > 0) {
				this.flushBuffer();
			}
			if (bytes.length > this.buffer.length / 2) {
				// writing more than buffer half size, make the write
				FileWriter.write(this, bytes);
				return;
			}
		}
		// accumulate into buffer
		byte buffer[*] = this.buffer;
		int bufferSize = this.bufferSize;
		for (int i = 0; i < bytes.length; i += 1) {
			buffer[bufferSize + i] = bytes[i];
		}
		this.bufferSize += bytes.length;
	}

	void flush(BufferedFileWriter this) {
		this.flushBuffer();
		FileWriter.flush(this);
	}

	void close(BufferedFileWriter this) {
		this.flushBuffer();
		FileWriter.close(this);
	}
}

///@public
FileReader FileReader(const char path[*]) {
	return FileReader {
		file: File.open(path);
	};
}

///@public
FileWriter FileWriter(const char path[*], bool append) {
	return FileWriter {
		file: append ? File.append(path) : File.create(path);
	};
}

///@public
BufferedFileWriter BufferedFileWriter(const char path[*], bool append) {
	return BufferedFileWriter {
		buffer: null;
		file: append ? File.append(path) : File.create(path);
	};
}
// graphics library extension

inline "lib/rect.ci";
inline "lib/color.ci";
inline "lib/image.ci";
inline "lib/image.draw.ci";
inline "lib/image.blend.ci";
inline "lib/image.transform.ci";

inline "lib/image.blur.ci";

inline "lib/color.lookup.ci";
inline "lib/color.matrix.ci";

inline "lib/mesh.ci";
inline "lib/camera.ci";

inline "lib/window.ci";

inline "lib/micro.ui.ci";
/// Simple camera for 3d transformations and projection.
struct Camera {
	///@public
	vec4f position = vec4f(0, 0, 0, 1);
	///@public
	vec4f forward = vec4f(0, 0, 0, 1);
	///@public
	vec4f right = vec4f(0, 0, 0, 1);
	///@public
	vec4f up = vec4f(0, 1, 0, 1);

	/// Create an orthographic(`fov` == 0) or perspective projection matrix
	static mat4f projection(float32 fov, float32 asp, float32 n, float32 f) {
		float32 bot = 1;
		float32 nf = n - f;

		if (fov == 0) {
			// orthographic
			return {
				x: vec4f(1 / asp, 0,       0,      0);
				y: vec4f(0,       1 / bot, 0,      0);
				z: vec4f(0,       0,       2 / nf, -(f+n) / nf);
				w: vec4f(0,       0,       0,      1);
			};
		}

		// perspective
		bot = Math.tan(Math.radians(fov));
		asp *= bot;

		return {
			x: vec4f(n / asp, 0,       0,          0);
			y: vec4f(0,       n / bot, 0,          0);
			z: vec4f(0,       0,       (n+f) / nf, -2 * n * f / nf);
			w: vec4f(0,       0,       1,          0);
		};
	}

	/// Create a camera at the given `position` looking at the given `target`
	static Camera lookAt(vec4f position, vec4f target, vec4f up) {
		vec4f forward = normalize(sub(target, position));
		vec4f right = normalize(cross(up, forward));
		return {
			position: position;
			forward: forward;
			right: right;
			up: cross(forward, right);
		};
	}

	/// get the matrix of the camera, which can be multiplied with the projection matrix
	static mat4f matrix(const Camera camera&) {
		return {
			x: vec4f(camera.right, -camera.right.dp3(camera.position));
			y: vec4f(camera.up, -camera.up.dp3(camera.position));
			z: vec4f(camera.forward, -camera.forward.dp3(camera.position));
			w: vec4f(0, 0, 0, 1);
		};
	}

	/// get the matrix of the camera multiplied with the projection matrix
	static mat4f matrix(const Camera camera&, float32 fov, float32 asp, float32 n, float32 f) {
		return projection(fov, asp, n, f).mul(camera.matrix());
	}

	/// Move the camera in the given `direction` with the given `amount`
	static void move(Camera camera&, vec4f direction, float32 amount) {
		camera.position = add(camera.position, mul(direction, amount));
	}

	/// Rotate the camera around `orbit` in the given `direction` with the given `amount`
	static void rotate(Camera camera&, vec4f orbit, vec4f direction, float32 amount) {
		if (amount == 0) {
			return;
		}

		// rotate the camera
		mat4f matrix = rotation(orbit, direction, amount);
		camera.forward = normalize(dp3(matrix, camera.forward));
		camera.right = normalize(dp3(matrix, camera.right));
		camera.up = cross(camera.forward, camera.right);
		camera.position = dph(matrix, camera.position);
	}
}
/// an 32 bit argb color
struct argb: 0 {
	/// value of color
	uint32 v;
	struct: 1 {
		/// blue component
		uint8 b;

		/// green component
		uint8 g;

		/// red component
		uint8 r;

		/// alpha component
		uint8 a;
	}
}

/// cast unsigned integer to argb value
inline argb(uint32 argb) = argb(emit(struct(argb)));
/// cast argb value to unsigned integer
inline uint32(argb value) = uint32(emit(struct(value)));


/// clamp signed gray or color component to fit in 8 bits (0 ... 255)
inline sat_s8(int32 c) = uint32(c > 255 ? 255 : c < 0 ? 0 : c);
/// clamp unsigned gray or color component to fit in 8 bits (0 ... 255)
inline sat_u8(uint32 c) = uint32(c > 255 ? 255 : c);

/// pack an argb color from the given component
inline pack(uint32 c) = argb((((c << 8) | c) << 8) | c);
/// pack an argb color from the given components
inline pack(uint32 r, uint32 g, uint32 b) = argb((((r << 8) | g) << 8) | b);
/// pack an argb color from the given components
inline pack(uint32 a, uint32 r, uint32 g, uint32 b) = argb((((((a << 8) | r) << 8) | g) << 8) | b);

/// construct a rgb8 color from the given gray value, clamp the input
inline gray(int32 c) = pack(sat_s8(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(uint32 c) = pack(sat_s8(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float32 c) = gray(int32(c * 255));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float64 c) = gray(int32(c * 255));


/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 r, int32 g, int32 b) = pack(sat_s8(r), sat_s8(g), sat_s8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 r, uint32 g, uint32 b) = pack(sat_u8(r), sat_u8(g), sat_u8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 r, float32 g, float32 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 r, float64 g, float64 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 a, int32 r, int32 g, int32 b) = pack(sat_s8(a), sat_s8(r), sat_s8(g), sat_s8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 a, uint32 r, uint32 g, uint32 b) = pack(sat_u8(a), sat_u8(r), sat_u8(g), sat_u8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 a, float32 r, float32 g, float32 b) = argb(int32(a * 255), int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 a, float64 r, float64 g, float64 b) = argb(int32(a * 255), int32(r * 255), int32(g * 255), int32(b * 255));


/// get the Alpha channel of the color
inline ach(argb color) = int32((uint32(color) >> 24));
/// get the Red channel of the color
inline rch(argb color) = int32(uint32(color) >> 16 & 0xff);
/// get the Green channel of the color
inline gch(argb color) = int32(uint32(color) >> 8 & 0xff);
/// get the Blue channel of the color
inline bch(argb color) = int32(uint32(color) & 0xff);

/// get the luminosity of the color (0.299 * color.r + 0.587 * color.g + 0.114 * color.b)
inline lum(argb color) = int32((19595 * rch(color) + 38470 * gch(color) + 7471 * bch(color)) >> 16);

/// get the hue of the color
// adapted from: https://gist.github.com/mity/6034000
uint32 hue(argb rgb) {
	int r = rch(rgb);
	int g = gch(rgb);
	int b = bch(rgb);
	int min = r;
	int max = r;

	if (min > g) {
		min = g;
	}
	if (min > b) {
		min = b;
	}
	if (max < g) {
		max = g;
	}
	if (max < b) {
		max = b;
	}

	if (max == min) {
		return 0;
	}

	int hue = 0;
	if (max == r) {
		hue = ((g - b) * 60) / (max - min);
	}
	else if (max == g) {
		hue = ((b - r) * 60) / (max - min) + 120;
	}
	else if (max == b) {
		hue = ((r - g) * 60) / (max - min) + 240;
	}
	if (hue < 0) {
		hue += 360;
	}
	return hue;
}

/// compute the linear interpolation of the values `a` and `b` by `t` in range 0...255
inline mix_s8(int32 t, uint32 a, uint32 b) = int32(a + (t * (b - a + 1) >> 8));
/// compute the linear interpolation of the values `a` and `b` by `t` in range 0...65535
inline mix_s16(int32 t, uint32 a, uint32 b) = int32(a + (t * (b - a + 1) >> 16));
/// compute the linear interpolation of the colors `a` and `b` by `t` in range 0...255
inline mix_rgb8(int32 t, argb a, argb b) = argb(mix_s8(t, rch(a), rch(b)), mix_s8(t, gch(a), gch(b)), mix_s8(t, bch(a), bch(b)));

/// linear interpolate a lookup-table with the given colors
void lerpLut(argb lut[], argb colors...) {
	int dt = (colors.length - 1 << 16) / (lut.length - 1);
	for (int i = 0; i < lut.length; i += 1) {
		int t = i * dt;
		argb c1 = colors[t >> 16];
		argb c2 = colors[(t >> 16) + 1];
		int32 a = mix_s16(t & 0xffff, ach(c1), ach(c2));
		int32 r = mix_s16(t & 0xffff, rch(c1), rch(c2));
		int32 g = mix_s16(t & 0xffff, gch(c1), gch(c2));
		int32 b = mix_s16(t & 0xffff, bch(c1), bch(c2));
		lut[i].v = a << 24 | r << 16 | g << 8 | b;
	}
}

/// linear interpolate a alpha lookup-table with the given colors
void alphaLut(uint32 lut[], int hardness, int alpha, bool reflect) {
	int mid = hardness <= 0 ? -1 : 255;
	int div = 256 - sat_u8(hardness < 0 ? -hardness : hardness);
	for (int i = 0; i < lut.length; i += 1) {
		int t = i * 255 / (lut.length - 1);
		lut[i] = sat_s8((t - mid) * 255 / div + mid);
		if (alpha < 0) {
			lut[i] = 255 - (255 - lut[i]) * -alpha / 255;
		} else {
			lut[i] = 255 - lut[i] * alpha / 255;
		}
	}
	if (reflect) {
		int end = lut.length - 1;
		int mid = lut.length / 2;
		for (int i = end; i >= mid; i -= 1) {
			lut[i] = lut[end];
			end -= 2;
		}
		for (int i = 0; i < mid; i += 1) {
			lut[i] = lut[lut.length - i - 1];
		}
	}
}

static if (typename(vec4f) != null) {

/// convert an argb color to a floating point vector
inline vec4f(argb rgb) = vec4f(rch(rgb) / 255f, gch(rgb) / 255f, bch(rgb) / 255f, ach(rgb) / 255f);

/// convert a floating point vector to an argb color
inline argb(const vec4f vec&) = argb(vec.w, vec.x, vec.y, vec.z);

/// calculate the luminosity of a color
inline lum(const vec4f vec&) = 0.299f * vec.x + 0.587f * vec.y + 0.114f * vec.z;

inline "color.hsl.ci";
}
/// Convert color from Rgb color space to Hsl color space
// adapted from: https://gitlab.bestminr.com/bestminr/FrontShaders/-/blob/master/shaders/hsl.glsl
vec4f rgb2hsl(vec4f rgb) {
	inline min(float32 x, float32 y) = x < y ? x : y;
	inline max(float32 x, float32 y) = x > y ? x : y;
	inline clamp(float32 value, float32 min, float32 max) = min(max(value, min), max);
	float fmin = min(min(rgb.x, rgb.y), rgb.z);    //Min. value of RGB
	float fmax = max(max(rgb.x, rgb.y), rgb.z);    //Max. value of RGB
	float delta = fmax - fmin;             //Delta RGB value

	// Luminance
	float lum = (fmax + fmin) / 2;

	if (delta == 0) {
		//This is a gray, no chroma...
		return {
			x: 0;   // Hue
			y: 0;   // Saturation
			z: lum; // Luminance
		};
	}

	// Chromatic data...
	float sat;
	if (lum < 0.5f) {
		sat = delta / (fmax + fmin);
	} else {
		sat = delta / (2 - fmax - fmin);
	}

	float deltaR = (((fmax - rgb.x) / 6) + (delta / 2)) / delta;
	float deltaG = (((fmax - rgb.y) / 6) + (delta / 2)) / delta;
	float deltaB = (((fmax - rgb.z) / 6) + (delta / 2)) / delta;

	float hue;
	if (rgb.x == fmax) {
		hue = deltaB - deltaG;
	}
	else if (rgb.y == fmax) {
		hue = (1 / 3f) + deltaR - deltaB;
	}
	else if (rgb.z == fmax) {
		hue = (2 / 3f) + deltaG - deltaR;
	}

	if (hue < 0) {
		hue += 1;
	}
	else if (hue > 1) {
		hue -= 1;
	}

	return {
		x: clamp(hue, 0, 1); // Hue
		y: clamp(sat, 0, 1); // Saturation
		z: clamp(lum, 0, 1); // Luminance
	};
}

/// Convert color from Hsl color space to Rgb color space
vec4f hsl2rgb(vec4f hsl) {
float hue2rgb(float f1, float f2, float hue) {
	if (hue < 0) {
		hue += 1;
	}
	else if (hue > 1) {
		hue -= 1;
	}

	if (hue < 1f / 6) {
		return f1 + (f2 - f1) * 6 * hue;
	}
	if (hue < 1f / 2) {
		return f2;
	}
	if (hue < 2f / 3) {
		return f1 + (f2 - f1) * ((2 / 3f) - hue) * 6;
	}
	return f1;
}

	if (hsl.y == 0) {
		return vec4f(hsl.z); // Luminance
	}

	float f2;
	if (hsl.z < .5f) {
		f2 = hsl.z * (1 + hsl.y);
	}
	else {
		f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);
	}

	float f1 = 2 * hsl.z - f2;
	return {
		x: hue2rgb(f1, f2, hsl.x + (1 / 3f));
		y: hue2rgb(f1, f2, hsl.x);
		z: hue2rgb(f1, f2, hsl.x - (1 / 3f));
	};
}
/// convert from hsv color space to rgb color space
vec4f hsv2rgb(vec4f hsv) {
	float32 h = hsv.x;
	float32 s = hsv.y;
	float32 v = hsv.z;

	if (s == 0) {
		return vec4f(v);
	}

	h *= 360 / 60;

	int i = int(h);		// round
	float32 f = h - i;	// fraction

	float32 u = v;
	float32 p = v * (1 - s);
	float32 q = v * (1 - s * f);
	float32 t = v * (1 - s * (1 - f));

	if (i == 0) {
		return vec4f(u, t, p);
	}
	if (i == 1) {
		return vec4f(q, u, p);
	}
	if (i == 2) {
		return vec4f(p, u, t);
	}
	if (i == 3) {
		return vec4f(p, q, u);
	}
	if (i == 4) {
		return vec4f(t, p, u);
	}
	return vec4f(u, p, q);
}
/// apply a color lookup table to each pixel defined by the `roi` on the `image`
void colorMap(Image image, const Rect roi&, const argb lut[256]) {
	static if (preferNativeCalls && typename(Image.colorMap) != null) {
		return Image.colorMap(image, roi, pointer(lut));
	}

	assert(image.depth() == 32);

	// clip roi with source image
	Rect r = {
		x0: roi != null ? roi.x0 : 0;
		y0: roi != null ? roi.y0 : 0;
		x1: roi != null ? roi.x1 : image.width();
		y1: roi != null ? roi.y1 : image.height();
	};
	if (!image.clip(&r)) {
		// nothing to set
		return;
	}

	bool useLuminosity = false;
	for (int i = 0; i < 256; i += 1) {
		if (ach(lut[i]) != i) {
			useLuminosity = true;
			break;
		}
	}

	if (!useLuminosity) {
		// fast version, r, g, b lookup only
		for (int y = r.y0; y < r.y1; y += 1) {
			for (int x = r.x0; x < r.x1; x += 1) {
				argb col = argb(image.get(x, y));
				col.r = lut[rch(col)].r;
				col.g = lut[gch(col)].g;
				col.b = lut[bch(col)].b;
				image.set(x, y, col);
			}
		}
		return;
	}

	// lookup also luminosity using the alpha channel:
	// convert the color from `rgb` to `luv` color space,
	// lookup luminosity, then convert back and store the new color
	inline fxpBits = 16;
	inline fxp(float64 v) = int32(v * (1 << fxpBits));
	static const int32 rgb2luv[] = {
		fxp( 0.299), fxp( 0.587), fxp( 0.114), 0,
		fxp(-0.147), fxp(-0.289), fxp( 0.437), 0,
		fxp( 0.615), fxp(-0.515), fxp(-0.100), 0,
	};
	static const int32 luv2rgb[] = {
		fxp(1), fxp( 0.000), fxp( 1.140), 0,
		fxp(1), fxp(-0.394), fxp(-0.581), 0,
		fxp(1), fxp( 2.028), fxp( 0.000), 0,
	};

	for (int y = r.y0; y < r.y1; y += 1) {
		for (int x = r.x0; x < r.x1; x += 1) {
			argb col = argb(image.get(x, y));
			int32 r = rch(lut[rch(col)]);
			int32 g = gch(lut[gch(col)]);
			int32 b = bch(lut[bch(col)]);

			int32 l = (r * rgb2luv[0x0] + g * rgb2luv[0x1] + b * rgb2luv[0x2]) >> fxpBits;
			int32 u = (r * rgb2luv[0x4] + g * rgb2luv[0x5] + b * rgb2luv[0x6]) >> fxpBits;
			int32 v = (r * rgb2luv[0x8] + g * rgb2luv[0x9] + b * rgb2luv[0xa]) >> fxpBits;

			l = ach(lut[sat_s8(l)]);

			col.r = sat_s8((l * luv2rgb[0x0] + u * luv2rgb[0x1] + v * luv2rgb[0x2]) >> fxpBits);
			col.g = sat_s8((l * luv2rgb[0x4] + u * luv2rgb[0x5] + v * luv2rgb[0x6]) >> fxpBits);
			col.b = sat_s8((l * luv2rgb[0x8] + u * luv2rgb[0x9] + v * luv2rgb[0xa]) >> fxpBits);
			image.set(x, y, col);
		}
	}
}
/// apply a color matrix to each pixel defined by the `roi` on the `image`
void colorMat(Image image, const Rect roi&, const mat4f mat&) {
	static if (preferNativeCalls && typename(Image.colorMat) != null) {
		return Image.colorMat(image, roi, mat.data);
	}
	assert(image.depth() == 32);

	// clip roi with source image
	Rect r = {
		x0: roi != null ? roi.x0 : 0;
		y0: roi != null ? roi.y0 : 0;
		x1: roi != null ? roi.x1 : image.width();
		y1: roi != null ? roi.y1 : image.height();
	};
	if (!image.clip(&r)) {
		// nothing to set
		return;
	}

	int m00 = 65536 * mat.xx;
	int m01 = 65536 * mat.xy;
	int m02 = 65536 * mat.xz;
	int m03 = 256 * 65536 * mat.xw;

	int m10 = 65536 * mat.yx;
	int m11 = 65536 * mat.yy;
	int m12 = 65536 * mat.yz;
	int m13 = 256 * 65536 * mat.yw;

	int m20 = 65536 * mat.zx;
	int m21 = 65536 * mat.zy;
	int m22 = 65536 * mat.zz;
	int m23 = 256 * 65536 * mat.zw;

	for (int y = r.y0; y < r.y1; y += 1) {
		for (int x = r.x0; x < r.x1; x += 1) {
			argb col = argb(image.get(x, y));
			int r = rch(col);
			int g = gch(col);
			int b = bch(col);
			col.r = sat_s8((r * m00 + g * m01 + b * m02 + m03) >> 16);
			col.g = sat_s8((r * m10 + g * m11 + b * m12 + m13) >> 16);
			col.b = sat_s8((r * m20 + g * m21 + b * m22 + m23) >> 16);
			image.set(x, y, col);
		}
	}
}
/// copy the `src` image to the destination with an optional blend method
void blend(Image image, int32 x0, int32 y0, const Image src, const Rect roi&, pointer extra, argb blend(pointer extra, argb base, argb with)) {
	static if (preferNativeCalls && typename(Image.blend) != null) {
		return Image.blend(image, x0, y0, src, roi, extra, pointer(blend));
	}

	// clip roi with source image
	Rect rect = {
		x0: roi != null ? roi.x0 : 0;
		y0: roi != null ? roi.y0 : 0;
		x1: roi != null ? roi.x1 : src.width();
		y1: roi != null ? roi.y1 : src.height();
	};
	if (x0 < 0) {
		rect.x0 -= x0;
	}
	if (y0 < 0) {
		rect.y0 -= y0;
	}
	if (!src.clip(&rect)) {
		// nothing to get
		return;
	}

	// clip also destination
	rect.positionX(x0 < 0 ? 0 : x0);
	rect.positionY(y0 < 0 ? 0 : y0);
	if (!image.clip(&rect)) {
		// nothing to set
		return;
	}

	assert(image.depth() == 32 && src.depth() == 32);
	if (blend == null) {
		for (int y = rect.y0; y < rect.y1; y += 1) {
			for (int x = rect.x0; x < rect.x1; x += 1) {
				image.set(x, y, src.get(x - x0, y - y0));
			}
		}
		return;
	}

	for (int y = rect.y0; y < rect.y1; y += 1) {
		for (int x = rect.x0; x < rect.x1; x += 1) {
			argb base = argb(image.get(x, y));
			argb with = argb(src.get(x - x0, y - y0));
			image.set(x, y, blend(extra, base, with));
		}
	}
}

/// copy the `src` image to the destination with an optional blend method
void blend(Image image, int32 x0, int32 y0, const Image src, const Rect roi&, vec4f blend(vec4f base, vec4f with)) {
	static if (preferNativeCalls && typename(Image.blend.blendVec4f) != null) {
		return Image.blend(image, x0, y0, src, roi, blend, Image.blend.blendVec4f);
	}
	static argb blendVec4f(vec4f blend(vec4f base, vec4f with), argb base, argb with) {
		return argb(blend(vec4f(base), vec4f(with)));
	}
	if (blend == null) {
		return blend(image, x0, y0, src, roi, null, null);
	}
	return blend(image, x0, y0, src, roi, blend, blendVec4f);
}

/// fill the destination with the given `col` (alpha channel is used)
void blend(Image image, const Rect roi&, argb col) {
	static if (preferNativeCalls && typename(Image.blend.color) != null) {
		return image.blend(roi != null ? roi.x0 : 0, roi != null ? roi.y0 : 0, image, roi, col, Image.blend.color);
	}
	argb blender(const argb color&, argb base, argb with) {
		int alpha = ach(color);
		return {
			b: mix_s8(alpha, bch(color), bch(base));
			g: mix_s8(alpha, gch(color), gch(base));
			r: mix_s8(alpha, rch(color), rch(base));
			a: alpha;
		};
	}
	return image.blend(roi != null ? roi.x0 : 0, roi != null ? roi.y0 : 0, image, roi, col, blender);
}

/// copy the `src` image to the destination with the given transparency
void blendAlpha(Image image, int32 x, int32 y, const Image src, const Rect roi&, int32 alpha) {
	static if (preferNativeCalls && typename(Image.blend.alpha) != null) {
		return Image.blend(image, x, y, src, roi, alpha, Image.blend.alpha);
	}

	argb blender(const int32 alpha&, argb base, argb with) {
		return {
			b: sat_s8(mix_s8(alpha, bch(base), bch(with)));
			g: sat_s8(mix_s8(alpha, gch(base), gch(with)));
			r: sat_s8(mix_s8(alpha, rch(base), rch(with)));
			a: alpha;
		};
	}
	return image.blend(x, y, src, roi, alpha, blender);
}

/// copy the `src` image to the destination masked with destination alpha
void blendDstAlpha(Image image, int32 x, int32 y, const Image src, const Rect roi&) {
	static if (preferNativeCalls && typename(Image.blend.dstAlpha) != null) {
		return Image.blend(image, x, y, src, roi, null, Image.blend.dstAlpha);
	}

	argb blender(pointer null, argb base, argb with) {
		int alpha = ach(base);
		return {
			b: mix_s8(alpha, bch(base), bch(with));
			g: mix_s8(alpha, gch(base), gch(with));
			r: mix_s8(alpha, rch(base), rch(with));
			a: alpha;
		};
	}
	return image.blend(x, y, src, roi, null, blender);
}

/// copy or convert `src` image to the destination `image`
void copy(Image image, int32 x, int32 y, Image src, const Rect roi&) {
	return blend(image, x, y, src, roi, null, null);
}

/// Create an image by copying another one
Image Image(Image copy) {
	Image result = Image.create(copy.width(), copy.height(), copy.depth());
	result.copy(0, 0, copy, null);
	return result;
}

/// copy the `src` image multiple times so it fills the whole `image`
void tile(Image image, int x, int y, Image src, const Rect roi&) {
	Rect rect = {
		x0: roi != null ? roi.x0 : 0;
		y0: roi != null ? roi.y0 : 0;
		x1: roi != null ? roi.x1 : src.width();
		y1: roi != null ? roi.y1 : src.height();
	};

	if (!src.clip(&rect)) {
		return;
	}

	if (x < 0) {
		x = -(-x % rect.width());
	}
	if (y < 0) {
		y = -(-y % rect.height());
	}
	int width = image.width();
	int height = image.height();
	for (int j = y; j < height; j += rect.height()) {
		for (int i = x; i < width; i += rect.width()) {
			image.copy(i, j, src, rect);
		}
	}
}

/// Fill the surface by evaluating the given function for each pixel
void eval(Image image, const Rect roi&, float32 aspect, float32 time, vec4f eval(vec4f in)) {
	Rect rect = {
		x0: roi != null ? roi.x0 : 0;
		y0: roi != null ? roi.y0 : 0;
		x1: roi != null ? roi.x1 : image.width();
		y1: roi != null ? roi.y1 : image.height();
	};

	if (!image.clip(&rect)) {
		return;
	}

	float32 w = image.width();
	float32 h = image.height();
	if (aspect == 0) {
		aspect = w / h;
	}
	h *= aspect;

	vec4f in = vec4f(0, 0, 0, time);
	for (int y = rect.y0; y < rect.y1; y += 1) {
		in.y = y / h;
		for (int x = rect.x0; x < rect.x1; x += 1) {
			in.x = x / w;
			image.set(x, y, argb(eval(in)));
		}
	}
}
/// emulated implementation of blur function
void blur(Image image, int radius, float64 sigma) {
	static if (preferNativeCalls && typename(Image.blur) != null) {
		return Image.blur(image, radius, sigma);
	}
	static double gauss(double x, double sigma) {
		inline SQRT_2_PI_INV = 0.398942280401432677939946059935;
		double t = x / sigma;
		/*switch (dx) {
			default:
				break;
			case -1:
				return 1;
			case 0:
				return SQRT_2_PI_INV * exp(-0.5*t*t) / sigma;
			case 1:
				return -x * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma);
			case 2:
				return (x * x - sigma * sigma) * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma * sigma * sigma);
		}*/
		return SQRT_2_PI_INV * Math.exp(-0.5 * t * t) / sigma;
	}

	int32 kernel[1024] = {};
	int size = radius * 2 + 1;
	assert(size < kernel.length);

	float64 kernelSum = 0;
	float64 kernelFlt[kernel.length] = {};
	for (int i = 0; i < size; i += 1) {
		kernelFlt[i] = gauss(radius - i, sigma);
		kernelSum += kernelFlt[i];
	}

	for (int i = 0; i < size; i += 1) {
		kernel[i] = 65536 * (kernelFlt[i] / kernelSum);
	}

	int width = image.width();
	int height = image.height();
	Image tmp = Image.create(width, height, image.depth());

	// x direction: inout -> temp
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			int32 r = 0;
			int32 g = 0;
			int32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _x = x + i - radius;
				if (_x >= 0 && _x < width) {
					argb col = argb(image.get(_x, y));
					int32 _k = kernel[i];
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			tmp.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}

	// y direction: temp -> inout
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			int32 r = 0;
			int32 g = 0;
			int32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _y = y + i - radius;
				if (_y >= 0 && _y < height) {
					argb col = argb(tmp.get(x, _y));
					int32 _k = kernel[i];
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			image.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}

	tmp.destroy();
}
/// Create an image with the given with, height and depth
inline Image(int width, int height, int depth) = Image.create(width, height, depth);

/// Create an image by opening an image file
Image Image(const char fileName[*], int depth) {
	static if (typename(Image.openPng) != null) {
		if (fileName.endsWith(".png", ignCaseCmp)) {
			return Image.openPng(fileName, depth);
		}
	}
	static if (typename(Image.openJpg) != null) {
		if (fileName.endsWith(".jpeg", ignCaseCmp)) {
			return Image.openJpg(fileName, depth);
		}
		if (fileName.endsWith(".jpg", ignCaseCmp)) {
			return Image.openJpg(fileName, depth);
		}
	}
	static if (typename(Image.openBmp) != null) {
		if (fileName.endsWith(".bmp", ignCaseCmp)) {
			return Image.openBmp(fileName, depth);
		}
	}
	return Image.openImg(fileName, depth);
}

/// Create an image by opening an image file
inline Image(const char fileName[*]) = Image(fileName, 32);

/// Clip the rectangle against the given image boundaries
bool clip(Image image, Rect roi&) {
	if (roi.x0 < 0) {
		roi.x0 = 0;
	}

	if (roi.y0 < 0) {
		roi.y0 = 0;
	}

	int width = image.width();
	if (roi.x1 > width) {
		roi.x1 = width;
	}

	int height = image.height();
	if (roi.y1 > height) {
		roi.y1 = height;
	}

	return !roi.empty();
}

/// Set the the color of a pixel at the given position
inline set(Image image, int32 x, int32 y, argb color) = Image.set(image, x, y, uint32(color));
static if (typename(drawAntiAliased) == null) {
	// by default draw without antialiasing
	inline drawAntiAliased = true;
}
inline "image.draw.rect.ci";
inline "image.draw.rrect.ci";
inline "image.draw.oval.ci";
inline "image.draw.line.ci";

// todo: https://rreusser.github.io/regl-gpu-lines/docs/debug.html
// todo: void fillTriangle(Image image, int x0, int y0, int x1, int y1, int x1, int y1, bool smooth, uint32 color);

/// Fill the entire image with the given color
Image fill(Image image, uint32 color) {
	image.fillRect(0, 0, image.width(), image.height(), color);
	return image;
}

/// Draw the given ASCII `text` to the `image` at the given `x`, `y` coordinate, with the given `font` and `color`
void drawText(Image image, int32 x, int32 y, Image font, const char text[*], int32 color) {
	Rect rect = {x0: x, y0: y, x1: image.width(), y1: image.height()};
	return image.drawText(rect, font, text, color);
}
/// Draw a line, including ending pixel
void drawLineIncl(Image image, int x0, int y0, int x1, int y1, uint32 color) {
	inline mix(Image image, int x0, int y0, int alpha, uint32 color) = image.set(x0, y0, mix_rgb8(alpha, argb(uint32(image.get(x0, y0))), argb(color)));

	if (x0 == x1 || y0 == y1) {
		// horizontal or vertical line && avoid division by zero
		return image.fillRect(x0, y0, x1, y1, 1, color);
	}

	int dx = x1 - x0;
	int dy = y1 - y0;

	if (Math.abs(dx) > Math.abs(dy)) {
		if (x0 > x1) {
			int x = x0;
			x0 = x1;
			x1 = x;
			y0 = y1;
		}
		int y = y0 << 16;
		dy = (dy << 16) / dx;
		if (x1 > image.width()) {
			x1 = image.width();
		}
		if (x0 < 0) {
			y -= dy * x0;
			x0 = 0;
		}

		static if (drawAntiAliased) {
			for (int x = x0; x <= x1; x += 1) {
				uint32 alpha = (~y >> 8) & 255;
				image.mix(x, y >> 16, alpha, color);
				image.mix(x, (y >> 16) + 1, 255 - alpha, color);
				y += dy;
			}
		} else {
			y += 0x8000;
			for (int x = x0; x <= x1; x += 1) {
				image.set(x, y >> 16, color);
				y += dy;
			}
		}
	} else {
		if (y0 > y1) {
			int y = y0;
			y0 = y1;
			y1 = y;
			x0 = x1;
		}
		int x = x0 << 16;
		dx = (dx << 16) / dy;
		if (y1 > image.height()) {
			y1 = image.height();
		}
		if (y0 < 0) {
			x -= dx * y0;
			y0 = 0;
		}

		static if (drawAntiAliased) {
			for (int y = y0; y <= y1; y += 1) {
				int alpha = (~x >> 8) & 255;
				image.mix(x >> 16, y, alpha, color);
				image.mix((x >> 16) + 1, y, 255 - alpha, color);
				x += dx;
			}
		} else {
			x += 0x8000;
			for (int y = y0; y <= y1; y += 1) {
				image.set(x >> 16, y, color);
				x += dx;
			}
		}
	}
}

/// Draw a line between the given coordinates(excluding the rightmost bottom pixel)
void drawLine(Image image, int x0, int y0, int x1, int y1, uint32 color) {
	inline p(int a, int b) = a - int(b < a);
	return drawLineIncl(image, p(x0 , x1), p(y0, y1), p(x1, x0), p(y1, y0), color);
}

/// Draw a quadratic bezier curve
void drawBezier(Image image, int x0, int y0, int x1, int y1, int x2, int y2, uint32 color) {
	int px_0 = x0;
	int py_0 = y0;
	int px_1 = 2 * (x1 - x0);
	int py_1 = 2 * (y1 - y0);
	int px_2 = x2 - 2 * x1 + x0;
	int py_2 = y2 - 2 * y1 + y0;

	double dt = 1. / 128;
	for (double t = dt; t < 1; t += dt) {
		x1 = (px_2 * t + px_1) * t + px_0;
		y1 = (py_2 * t + py_1) * t + py_0;
		drawLineIncl(image, x0, y0, x1, y1, color);
		x0 = x1;
		y0 = y1;
	}
	drawLine(image, x0, y0, x2, y2, color);
}

/// Draw a cubic bezier curve
void drawBezier(Image image, int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3, uint32 color) {
	int px_0 = x0;
	int py_0 = y0;
	int px_1 = 3 * (x1 - x0);
	int py_1 = 3 * (y1 - y0);
	int px_2 = 3 * (x2 - x1) - px_1;
	int py_2 = 3 * (y2 - y1) - py_1;
	int px_3 = x3 - px_2 - px_1 - px_0;
	int py_3 = y3 - py_2 - py_1 - py_0;

	double dt = 1. / 128;
	for (double t = dt; t < 1; t += dt) {
		x1 = ((px_3 * t + px_2) * t + px_1) * t + px_0;
		y1 = ((py_3 * t + py_2) * t + py_1) * t + py_0;
		drawLineIncl(image, x0, y0, x1, y1, color);
		x0 = x1;
		y0 = y1;
	}
	drawLine(image, x0, y0, x3, y3, color);
}
/// Fill an ellipse on the `image` specified by the given coordinates and the given `color`
inline fillOval(Image image, int x0, int y0, int x1, int y1, uint32 color) = image.fillRRect(x0, y0, x1, y1, Math.abs(x0 - x1), Math.abs(y0 - y1), color);

/// Draw an ellipse on the `image` specified by the given coordinates and the given `color`
inline drawOval(Image image, int x0, int y0, int x1, int y1, uint32 color) = image.drawRRect(x0, y0, x1, y1, Math.abs(x0 - x1), Math.abs(y0 - y1), color);

/// Fill an ellipse on the `image` specified by `roi` with the given `color`
void fillOval(Image image, const Rect roi&, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.fillOval(roi.x0, roi.y0, roi.x1, roi.y1, color);
}

/// Draw an ellipse on the `image` specified by `roi` with the given `color`
void drawOval(Image image, const Rect roi&, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.drawOval(roi.x0, roi.y0, roi.x1, roi.y1, color);
}
/// Fill a rectangle on the `image` specified by the coordinates with the given `color`
void fillRect(Image image, int x0, int y0, int x1, int y1, int incl, uint32 color) {
	static if (preferNativeCalls && typename(Image.fillRect) != null) {
		return Image.fillRect(image, x0, y0, x1, y1, incl, color);
	}

	if (x0 > x1) {
		int t = x0;
		x0 = x1;
		x1 = t;
	}
	if (y0 > y1) {
		int t = y0;
		y0 = y1;
		y1 = t;
	}
	x1 += incl;
	y1 += incl;

	for (int y = y0; y < y1; y += 1) {
		for (int x = x0; x < x1; x += 1) {
			image.set(x, y, color);
		}
	}
}

/// Fill a rectangle on the `image` specified by the coordinates with the given `color`
inline fillRect(Image image, int x0, int y0, int x1, int y1, uint32 color) = image.fillRect(x0, y0, x1, y1, 0, color);

/// Draw a rectangle on the `image` specified by the coordinates with the given `width` and `color`
void drawRect(Image image, int x0, int y0, int x1, int y1, int width, uint32 color) {
	if (y0 > y1) {
		int t = y1;
		y1 = y0;
		y0 = t;
	}
	if (x0 > x1) {
		int t = x1;
		x1 = x0;
		x0 = t;
	}

	int half1 = (width - 0) / 2;
	int half2 = (width - 1) / 2;
	x0 -= half1;
	y0 -= half1;
	x1 += half2;
	y1 += half2;

	if (x1 - x0 <= 2 * width || y1 - y0 <= 2 * width) {
		// no gap between top and bottom or left and right; draw all at once
		return image.fillRect(x0, y0, x1, y1, color);
	}

	image.fillRect(x0, y0, x1, y0 + width, color);					// top
	image.fillRect(x0, y0 + width, x0 + width, y1 - width, color);	// left
	image.fillRect(x1 - width, y0 + width, x1, y1 - width, color);	// right
	image.fillRect(x0, y1 - width, x1, y1, color);					// bottom
}

/// Draw a rectangle on the `image` specified by the coordinates with the given `color`
inline drawRect(Image image, int x0, int y0, int x1, int y1, uint32 color) = image.drawRect(x0, y0, x1, y1, 1, color);

/// Fill a rectangle on the `image` specified by `roi` with the given `color`
void fillRect(Image image, const Rect roi&, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.fillRect(roi.x0, roi.y0, roi.x1, roi.y1, color);
}

/// Draw a rectangle on the `image` specified by `roi` with the given `color`
void drawRect(Image image, const Rect roi&, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.drawRect(roi.x0, roi.y0, roi.x1, roi.y1, 1, color);
}
/// Fill a rounded rectangle on `image` specified by the coordinates and rounding, with the given `color`
void fillRRect(Image image, int x0, int y0, int x1, int y1, int rx, int ry, uint32 color) {
	if (x0 > x1) {
		int t = x0;
		x0 = x1;
		x1 = t;
	}
	if (y0 > y1) {
		int t = y0;
		y0 = y1;
		y1 = t;
	}
	x1 -= int(x1 > x0);
	y1 -= int(y1 > y0);

	int dx = x1 - x0;
	int dy = y1 - y0;
	if (dx < 3 || dy < 3) {
		// no rounding is needed
		return image.fillRect(x0, y0, x1, y1, 1, color);
	}

	ry = Math.min(ry, (dy - int(dx > 16)) / 2);
	rx = Math.min(rx, (dx - int(dy > 16)) / 2);
	if (rx < 8 || ry < 8) {
		if (rx < 1 || ry < 1) {
			// no rounding is needed
			return image.fillRect(x0, y0, x1, y1, 1, color);
		}
		// apply some visual fixes
		rx += int(rx == 7) - int(rx == 6);
		ry += int(ry == 7) - int(ry == 6);
	}

	int64 sx = rx * rx;
	int64 sy = ry * ry;
	int64 rdy = sx * ry;
	int64 rdx = 0;
	int64 r = rdy / 2;

	x0 += rx;
	x1 -= rx;
	for (;y0 < y1;) {
		image.fillRect(x0, y0, x1, y0, 1, color);
		image.fillRect(x0, y1, x1, y1, 1, color);
		if (r >= 0) {
			x0 -= 1;
			x1 += 1;
			r -= rdx += sy;
		}
		if (r < 0) {
			y0 += 1;
			y1 -= 1;
			r += rdy -= sx;
		}
	}
	image.fillRect(x0, y0, x1, y1, 1, color);
}

/// Draw a rounded rectangle on `image` specified by the coordinates and rounding, with the given `color`
void drawRRect(Image image, int x0, int y0, int x1, int y1, int rx, int ry, uint32 color) {
	if (x0 > x1) {
		int t = x0;
		x0 = x1;
		x1 = t;
	}
	if (y0 > y1) {
		int t = y0;
		y0 = y1;
		y1 = t;
	}
	x1 -= int(x1 > x0);
	y1 -= int(y1 > y0);

	int dx = x1 - x0;
	int dy = y1 - y0;
	if (dx < 2 || dy < 2) {
		// no gap between top and bottom or left and right; draw all at once
		return image.fillRect(x0, y0, x1, y1, 1, color);
	}

	ry = Math.min(ry, (dy - int(dx > 16)) / 2);
	rx = Math.min(rx, (dx - int(dy > 16)) / 2);
	if (rx < 8 || ry < 8) {
		if (rx < 1 || ry < 1) {
			// no rounding is needed
			return image.drawRect(x0, y0, x1 + 1, y1 + 1, 1, color);
		}
		// apply some visual fixes
		rx += int(rx == 7) - int(rx == 6);
		ry += int(ry == 7) - int(ry == 6);
	}

	int64 sx = rx * rx;
	int64 sy = ry * ry;
	int64 rdy = sx * ry;
	int64 rdx = 0;
	int64 r = rdy / 2;

	x0 += rx;
	x1 -= rx;
	image.fillRect(x0, y0, x1, y0, 1, color);
	image.fillRect(x0, y1, x1, y1, 1, color);
	for (;y0 < y1;) {
		image.set(x0, y0, color);
		image.set(x1, y0, color);
		image.set(x0, y1, color);
		image.set(x1, y1, color);
		if (r >= 0) {
			x0 -= 1;
			x1 += 1;
			r -= rdx += sy;
		}
		if (r < 0) {
			y0 += 1;
			y1 -= 1;
			r += rdy -= sx;
		}
	}
	image.fillRect(x0, y0, x0, y1, 1, color);
	image.fillRect(x1, y0, x1, y1, 1, color);
}

/// Fill the given rectangle rounding the corners using the given radius
inline fillRRect(Image image, int x1, int y1, int x2, int y2, int r, uint32 color) = fillRRect(image, x1, y1, x2, y2, r, r, color);

/// Draw the given rectangle rounding the corners using the given radius
inline drawRRect(Image image, int x1, int y1, int x2, int y2, int r, uint32 color) = drawRRect(image, x1, y1, x2, y2, r, r, color);

/// Fill the given rectangle rounding the corners using the given radius
void fillRRect(Image image, const Rect roi&, int rx, int ry, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.fillRRect(roi.x0, roi.y0, roi.x1, roi.y1, rx, ry, color);
}

/// Fill the given rectangle rounding the corners using the given radius
inline fillRRect(Image image, const Rect roi&, int r, uint32 color) = fillRRect(image, roi, r, r, color);
/// Copy one image to another using a transformation matrix [scale, rotate, translate, shear, perspective, etc]
void transform(Image image, const Rect rect&, Image src, const Rect roi&, int32 interpolate, const mat4f mat&) {
	static if (preferNativeCalls && typename(Image.transform) != null) {
		return Image.transform(image, rect, src, roi, interpolate, pointer(mat.data));
	}

	assert(image.depth() == 32);
	assert(src.depth() == 32);

	Rect dRec = {
		x0: rect != null ? rect.x0 : 0;
		y0: rect != null ? rect.y0 : 0;
		x1: rect != null ? rect.x1 : image.width();
		y1: rect != null ? rect.y1 : image.height();
	};
	Rect sRec = {
		x0: roi != null ? roi.x0 : 0;
		y0: roi != null ? roi.y0 : 0;
		x1: roi != null ? roi.x1 : src.width();
		y1: roi != null ? roi.y1 : src.height();
	};
	if (mat == null) {
		mat4f scale = {
			x: vec4f(float32(sRec.width()) / dRec.width(), 0, 0, sRec.x0);
			y: vec4f(0, float32(sRec.height()) / dRec.height(), 0, sRec.y0);
			z: vec4f(0, 0, 1, 0);
			w: vec4f(0, 0, 0, 1);
		};
		scale = scale.mul(translation(vec4f(dRec.x0, dRec.y0, 0, 0), -1));
		return transform(image, rect, src, roi, interpolate, scale);
	}

	if (!image.clip(&dRec)) {
		// nothing to set
		return;
	}

	if (!src.clip(&sRec)) {
		// nothing to get
		return;
	}

	if (interpolate == 0) {
		for (int y = dRec.y0; y < dRec.y1; y += 1) {
			for (int x = dRec.x0; x < dRec.x1; x += 1) {
				vec4f t = mat.dph(vec4f(x, y, 0, 1));
				image.set(x, y, src.get(t.x, t.y));
			}
		}
		return;
	}

	// fixme: src.tex(x, y) does not center, do: transform.xw += .5; transform.yw += .5;
	mat4f transform = scale(vec4f(src.width(), src.height(), 0, 0), 1).mul(mat);
	for (int y = dRec.y0; y < dRec.y1; y += 1) {
		for (int x = dRec.x0; x < dRec.x1; x += 1) {
			vec4f t = transform.dph(vec4f(x, y, 0, 1));
			image.set(x, y, argb(src.tex(t.x, t.y)));
		}
	}
}

/// Resize the given `region` of the `source` image into the `destination` image using the `interpolation`.
inline resize(Image destination, const Rect rect&, const Image source, const Rect region&, int interpolation) = destination.transform(rect, source, region, interpolation, null);

/// Create an image by copying another one using a custom width and height
Image Image(Image image, int width, int height, int align, float64 maxScale) {
	// todo: merge with align from micro.ui.ci
	enum: int {
		center: 0;
		left: 1;
		right: 2;
		top: 4;
		bottom: 8;
		fitVertical: left + right;
		fitHorizontal: top + bottom;
		fill: 0x10;
		highRes: 0x20;
	}

	int alignVertical = align & fitVertical;
	int alignHorizontal = align & fitHorizontal;
	bool fitWidth = alignVertical == fitVertical;
	bool fitHeight = alignHorizontal == fitHorizontal;

	float64 scale = 1;
	if (fitWidth && fitHeight) {
		float64 widthScale = width / float64(image.width());
		float64 heightScale = height / float64(image.height());
		if (align & fill) {
			scale = Math.max(widthScale, heightScale);
		} else {
			scale = Math.min(widthScale, heightScale);
		}
	}
	else if (fitWidth) {
		scale = width / float64(image.width());
	}
	else if (fitHeight) {
		scale = height / float64(image.height());
	}
	if (scale > maxScale) {
		scale = maxScale;
	}

	// calculate translation
	float64 tx = 0;
	if (fitWidth || alignVertical == center) {
		tx = (width - image.width() * scale) / 2;
	}
	else if (alignVertical == right) {
		tx = (width - image.width() * scale);
	}

	float64 ty = 0;
	if (fitHeight || alignHorizontal == center) {
		ty = (height - image.height() * scale) / 2;
	}
	else if (alignHorizontal == bottom) {
		ty = (height - image.height() * scale);
	}

	mat4f mat = {
		x: {x: 1 / scale, y: 0, z: 0, w: -tx / scale};
		y: {x: 0, y: 1 / scale, z: 0, w: -ty / scale};
		z: {x: 0, y: 0, z: 1 / scale, w: 0};
		w: {x: 0, y: 0, z: 0, w: 1};
	};

	Image result = Image(width, height, image.depth());
	result.transform(null, image, null, align & highRes ? 1 : 0, mat);
	return result;
}

/// Create an image by opening an image file with custom width and height
Image Image(const char fileName[*], int width, int height, int depth, int align, float64 maxScale) {
	Image image = Image(fileName, depth);
	Image result = Image(image, width, height, align, maxScale);
	image.destroy();
	return result;
}

/// Create an image by opening an image file with custom width and height
inline Image(const char fileName[*], int width, int height, int depth, int align) = Image(fileName, width, height, depth, align, Math.inf);

/// Create an image by opening an image file with custom width and height
inline Image(const char fileName[*], int width, int height, int depth) = Image(fileName, width, height, depth, -1, Math.inf);
/// Create a mesh by opening a file
Mesh Mesh(const char fileName[*]) {
	if (fileName.endsWith(".obj", ignCaseCmp)) {
		return Mesh.openObj(fileName);
	}
	if (fileName.endsWith(".3ds", ignCaseCmp)) {
		return Mesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}
inline "micro.ui.core.ci";

///@public
struct Button: View {
	///@public
	const char text[*];

	bool onMeasure(Button this, Rect rect&) {
		Style style& = this.style;
		style.measure(&rect, this.text);
		return View.onMeasure(this, &rect);
	}

	void onDraw(Button this, Image offs, Rect rect) {
		View.onDraw(this, offs, rect, null, this.text);
	}
}

///@public
struct Switch: View {
	static const char onOff[*][] = {
		"off",
		"on"
	};

	///@public
	const char text[*];
	///@public
	const char states[*][] = onOff;

	///@public
	int selected = 0;
	const int resetValue = 0;//TODO: selected;

	/// clicking on a non focused view will not update the value, it will just focus it.
	const bool clickToFocus = true;

	///@public
	static bool checked(Switch this) {
		return this.selected != 0;
	}

	///@public
	bool onUpdate(Switch this, int selected) {
		int maxValue = this.states.length;
		if (maxValue == 0) {
			// graphical switch
			maxValue = 2;
		}
		if (selected >= maxValue) {
			selected = maxValue - 1;
		}
		else if (selected < 0) {
			selected = 0;
		}

		if (this.selected == selected) {
			return this.isDirty();
		}

		this.selected = selected;
		return true;
	}

	bool onReset(Switch this) {
		return this.onUpdate(this, this.resetValue);
	}

	bool onClick(Switch this) {
		if (this.focusable && this.clickToFocus) {
			if (!this.isFocused()) {
				return true;
			}
		}
		int maxValue = this.states.length;
		int value = this.selected + 1;
		if (maxValue == 0) {
			// graphical switch
			maxValue = 2;
		}
		if (value >= maxValue) {
			value = 0;
		}
		return this.onUpdate(this, value);
	}

	void onCreate(Switch this, View parent) {
		View.onCreate(this, parent);
		// clamp to initial value and force update with a reset
		int resetValue& = pointer(this.resetValue);
		Switch.onUpdate(this, this.selected);
		resetValue = this.selected;
		this.onReset(this);
	}

	bool onKeyEvent(Switch this, const KeyEvent event&) {
		if (!this.enabled || event.release) {
			return View.onKeyEvent(this, event);
		}
		if (event.key == '+' || event.key == '=') {
			int value = this.selected + 1;
			return this.onUpdate(this, value);
		}
		if (event.key == '-' || event.key == '_') {
			int value = this.selected - 1;
			return this.onUpdate(this, value);
		}
		return View.onKeyEvent(this, event);
	}

	bool onTouchEvent(Switch this, const Rect rect&, const TouchEvent event&) {
		if (!this.enabled || !event.release) {
			return View.onTouchEvent(this, rect, event);
		}
		if (event.isShift && event.clicks >= 0) {
			int value = this.selected - 1;
			return this.onUpdate(this, value);
		}
		return View.onTouchEvent(this, rect, event);
	}

	bool onMeasure(Switch this, Rect rect&) {
		int maxWidth = 0;
		Style style& = this.style;
		for (int i = 0; i < this.states.length; i += 1) {
			Rect measured = {};
			style.measure(&measured, this.states[i]);
			if (maxWidth < measured.width()) {
				maxWidth = measured.width();
			}
		}
		style.measure(&rect, this.text);
		if (this.states.length == 0) {
			rect.width(rect.width() + rect.height() * 3 / 2);
		} else {
			rect.width(rect.width() + maxWidth);
		}
		return View.onMeasure(this, &rect);
	}

	void onDraw(Switch this, Image offs, Rect rect) {
		char value[*] = null;
		Style style& = this.style;
		if (this.states.length == 0) {
			Rect onOffRect = {
				x0: rect.x0;
				y0: rect.y0;
				x1: rect.x0 + rect.height() * 3 / 2;
				y1: rect.y1;
			};
			Style.align(rect, &onOffRect, Style.right);
			rect.x1 = onOffRect.x0;

			onOffRect.padded(-style.padding);
			uint32 color = style.focusedColor;
			if (this.checked()) {
				color = style.valueColor;
			}
			else if (this.isFocused()) {
				color = style.hoveredColor;
			}
			offs.fillRRect(onOffRect, onOffRect.height() / 2, color);

			if (this.checked()) {
				onOffRect.x0 = onOffRect.x1 - onOffRect.height();
			} else {
				onOffRect.x1 = onOffRect.x0 + onOffRect.height();
			}

			onOffRect.padded(-style.padding / 3);
			offs.fillOval(onOffRect, style.textColor);
		} else {
			value = this.states[this.selected];
		}
		View.onDraw(this, offs, rect, this.text, value);
	}
}

///@public
struct Slider: View {
	///@public
	const char text[*];

	///@public
	float64 value = 0;
	float64 _value = 0;
	///@public
	const float64 minimum = 0;
	///@public
	const float64 maximum = 1;
	///@public
	const float64 stepSize = 0;
	const float64 resetValue = 0; // TODO: resetValue = value;

	/// clicking on a non focused view will not update the value, it will just focus it.
	const bool clickToFocus = true;

	///@public
	bool onUpdate(Slider this, float64 value) {
		if (value > this.maximum) {
			value = this.maximum;
		}
		if (value < this.minimum) {
			value = this.minimum;
		}
		this._value = value;
		if (this.stepSize != 0) {
			value = Math.round(value / this.stepSize) * this.stepSize;
		}
		if (this.value == value) {
			return this.isDirty();
		}
		this.value = value;
		return true;
	}

	bool onReset(Slider this) {
		return this.onUpdate(this, this.resetValue);
	}

	void onCreate(Slider this, View parent) {
		View.onCreate(this, parent);
		// clamp to initial value and force update with a reset
		float64 resetValue& = pointer(this.resetValue);
		Slider.onUpdate(this, this.value);
		resetValue = this.value;
		this.onReset(this);
	}

	bool onKeyEvent(Slider this, const KeyEvent event&) {
		if (event.release) {
			return View.onKeyEvent(this, event);
		}
		if (event.key == ' ') {
			return this.onReset(this);
		}
		if (event.key == '+' || event.key == '=') {
			return this.onUpdate(this, this._value + (event.isShift ? 1 : 10));
		}
		if (event.key == '-' || event.key == '_') {
			return this.onUpdate(this, this._value - (event.isShift ? 1 : 10));
		}
		return View.onKeyEvent(this, event);
	}

	bool onTouchEvent(Slider this, const Rect rect&, const TouchEvent event&) {
		if (event.button == 0) {
			return false;
		}
		if (event.release && (event.clicks < 0 || event.clicks > 1)) {
			return this.onReset(this);
		}

		if (event.clicks < 1) {
			float64 value = event.dx;
			if (!event.isShift && value != 0) {
				value *= float64(this.maximum - this.minimum) / rect.width();
			}
			value += this._value;
			if (value > this.maximum) {
				value = this.maximum;
			}
			if (value < this.minimum) {
				value = this.minimum;
			}

			return this.onUpdate(this, value);
		}
		if (event.release) {
			if (this.focusable && this.clickToFocus) {
				if (!this.isFocused()) {
					return true;
				}
			}
			float64 value = event.x - rect.x0;
			value *= float64(this.maximum - this.minimum) / rect.width();
			return this.onUpdate(this, this.minimum + value);
		}
		return View.onTouchEvent(this, rect, event);
	}

	bool onMeasure(Slider this, Rect rect&) {
		char value[64] = {0};
		Style style& = this.style;
		if (this.stepSize != 0 && this.stepSize % 1 == 0) {
			value.append(0, int64(this.value), style.format);
		} else {
			value.append(0, this.value, style.format);
		}
		Rect valueRect = {};
		style.measure(&valueRect, value);
		style.measure(&rect, this.text);
		rect.width(rect.width() + valueRect.width());
		return View.onMeasure(this, &rect);
	}

	///@public
	void onDrawSlider(Slider this, Image offs, Rect rect) {
		if (this.maximum == this.minimum) {
			return;
		}
		Style style& = this.style;
		const int y1 = rect.y1;
		const int y0 = y1 - style.padding / 4;
		const int x0 = rect.x0;
		const int x1 = rect.x1;
		const int x = x0 + (this.value - this.minimum) * rect.width() / (this.maximum - this.minimum);
		if (x > x0) {
			offs.fillRect(x0, y0, x, y1, style.valueColor);
		}
		if (x < x1) {
			offs.fillRect(x, y0, x1, y1, style.focusedColor);
		}
	}

	void onDraw(Slider this, Image offs, Rect rect) {
		char value[64] = {0};
		if (this.stepSize != 0 && this.stepSize % 1 == 0) {
			value.append(0, int64(this.value), this.style.format);
		} else {
			value.append(0, this.value, this.style.format);
		}
		if (this.onDrawSlider != null) {
			this.onDrawSlider(this, offs, rect);
		}
		View.onDraw(this, offs, rect, this.text, value);
	}
}

///@public
struct Histogram: View {
	///@public
	const bool lines = false;
	// histogram data is in alpha channel, display it with color rgb
	///@public
	bool color = false;
	///@public
	argb data[256];

	///@public
	static void update(Histogram this, Image image) {
		uint32 data[*] = pointer(this.data);
		image.calcRgbHist(null, &data);
		this.color = false;
	}

	///@public
	bool onUpdate(Histogram this, int idx, int value) {
		this.data[idx] = argb(idx, value, value, value);
		return true;
	}

	bool onReset(Histogram this) {
		bool result = false;
		for (int i = 0; i < 256; i += 1) {
			result |= Histogram.onUpdate(this, i, i);
		}
		return result;
	}

	void onCreate(Histogram this, View parent) {
		View.onCreate(this, parent);
		Histogram.onReset(this);
	}

	bool onTouchEvent(Histogram this, const Rect rect&, const TouchEvent event&) {
		if (event.release || !event.button) {
			return View.onTouchEvent(this, rect, event);
		}

		int px = Math.max(0, rect.width() - 256) / 2;
		int x0 = event.x - rect.x0 - px;
		int x1 = x0 - event.dx;
		int y0 = event.y - rect.y0;
		int y1 = y0 - event.dy;

		if (x0 > x1) {
			int x = x0;
			x0 = x1;
			x1 = x;
			int y = y0;
			y0 = y1;
			y1 = y;
		}
		int y = y0 << 16;
		int dy = y1 - y0;
		if (x1 != x0) {
			dy = (dy << 16) / (x1 - x0);
		}
		if (x0 < 0) {
			y -= x0 * dy;
			x0 = 0;
		}
		if (x1 > 256) {
			x1 = 256;
		}
		int h = rect.height();
		for (int x = x0; x < x1; x += 1) {
			int val = 255 * (h - (y >> 16)) / h;
			this.onUpdate(this, x, val);
			y += dy;
		}
		return true;
	}

	bool onMeasure(Histogram this, Rect rect&) {
		if (this.width < 0) {
			rect.width(256);
		}
		if (this.height < 0) {
			rect.height(128);
		}
		return View.onMeasure(this, &rect);
	}

	void onDraw(Histogram this, Image offs, const Rect rect) {
		enum {
			colB: 0x4371c6;
			colG: 0x72d874;
			colR: 0xfc6165;
			colL: 0xdadada;
		}
		int px = (rect.width() - 256) / 2;
		int h = rect.height();
		if (this.lines) {
			int y = rect.y1;
			int pb = bch(this.data[0]) * h / 256;
			int pg = gch(this.data[0]) * h / 256;
			int pr = rch(this.data[0]) * h / 256;
			int pl = ach(this.data[0]) * h / 256;

			for (int i = 1; i < this.data.length; i += 1) {
				int x = rect.x0 + i + px;
				argb data = this.data[i];
				int bv = bch(data) * h / 256;
				int gv = gch(data) * h / 256;
				int rv = rch(data) * h / 256;
				int lv = ach(data) * h / 256;

				if (this.color) {
					offs.fillRect(x, y - pl, x + 1, y - lv + int(pl == lv), data.v);
				} else {
					offs.fillRect(x, y - pb, x + 1, y - bv + int(pb == bv), colB);
					offs.fillRect(x, y - pg, x + 1, y - gv + int(pg == gv), colG);
					offs.fillRect(x, y - pr, x + 1, y - rv + int(pr == rv), colR);
					offs.fillRect(x, y - pl, x + 1, y - lv + int(pl == lv), colL);
				}

				pb = bv;
				pg = gv;
				pr = rv;
				pl = lv;
			}
		}
		else if (this.color) {
			for (int i = 0; i < this.data.length; i += 1) {
				argb data = this.data[i];
				int x = rect.x0 + i + px;
				int y1 = rect.y1;
				int y0 = y1 - ach(data) * h / 256;
				offs.fillRect(x, y0 - int(y1 == y0), x + 1, y1, uint32(data));
			}
		}
		else {
			for (int i = 0; i < this.data.length; i += 1) {
				int x = rect.x0 + i + px;
				argb data = this.data[i];
				int bv = bch(data) * h / 256;
				int gv = gch(data) * h / 256;
				int rv = rch(data) * h / 256;
				int lv = ach(data) * h / 256;
				for (int y = 0; y < h; y += 1) {
					uint32 b = colB * uint32(y < bv);
					uint32 g = colG * uint32(y < gv);
					uint32 r = colR * uint32(y < rv);
					uint32 l = colL * uint32(y < lv);
					offs.set(x, h - y + rect.y0 - 1, r | g | b | l);
				}
			}
		}
	}
}

/// debug view to count draws
struct DebugView: View {
	char text[64];

	int64 started = 0;
	int64 maxDuration = 0;
	int64 durations[64];

	/// Number of measures, initialize to `-1` to ignore
	int64 measures = 0;
	/// Number of draw calls, initialize to `-1` to ignore
	int64 draws = 0;

	/// Start time measurement until this view is drawn on screen
	static void startTimer(DebugView this) {
		this.started = System.millis();
		this.maxDuration = 0;
		// todo: don't copy, use a circular queue
		for (int i = this.durations.length - 1; i >= 1; i -= 1) {
			int64 duration = this.durations[i - 1];
			this.durations[i] = duration;
			if (this.maxDuration < duration) {
				this.maxDuration = duration;
			}
		}
		this.durations[0] = this.maxDuration;
	}

	static void update(DebugView this) {
		int pos = 0;
		if (this.measures > 0) {
			pos = this.text.append(pos, pos > 0 ? ", " : "");
			pos = this.text.append(pos, "measures: ");
			pos = this.text.append(pos, this.measures);
		}

		if (this.draws > 0) {
			pos = this.text.append(pos, pos > 0 ? ", " : "");
			pos = this.text.append(pos, "draws: ");
			pos = this.text.append(pos, this.draws);
		}

		if (this.durations[0] > 0 || pos == 0) {
			pos = this.text.append(pos, pos > 0 ? ", " : "");
			pos = this.text.append(pos, "time: ");
			pos = this.text.append(pos, this.durations[0]);
		}
	}

	bool onClick(DebugView this) {
		return this.onReset(this);
	}

	bool onReset(DebugView this) {
		if (this.measures > 0) {
			this.measures = 0;
		}
		if (this.draws > 0) {
			this.draws = 0;
		}
		for (int i = 0; i < this.durations.length; i += 1) {
			this.durations[i] = 0;
		}
		this.maxDuration = 0;
		this.started = 0;
		return true;
	}

	void onCreate(DebugView this, View parent) {
		View.onCreate(this, parent);
		onReset(this);
	}

	bool onMeasure(DebugView this, Rect rect&) {
		if (this.measures >= 0) {
			this.measures += 1;
		}
		this.update();
		Style style& = this.style;
		style.measure(&rect, this.text);
		return View.onMeasure(this, &rect);
	}

	void onDraw(DebugView this, Image offs, Rect rect) {
		if (this.started > 0) {
			int64 duration = System.millis() - this.started;
			this.durations[0] = duration;
			if (this.maxDuration < duration) {
				this.maxDuration = duration;
			}
			this.started = 0;
		}

		Style style& = this.style;
		if (this.maxDuration > 0) {
			int y0 = rect.y1;
			float64 ys = rect.height() / float64(this.maxDuration);
			float64 xs = rect.width() / float64(this.durations.length);
			for (int i = 0; i < this.durations.length; i += 1) {
				int y1 = y0 - ys * this.durations[i];
				int x1 = rect.x0 + xs * (this.durations.length - i);
				offs.fillRect(x1 - xs, y0, x1, y1, style.focusedColor);
			}
		}

		if (this.draws >= 0) {
			this.draws += 1;
		}
		this.update();
		style.align(rect, &rect, this.text);
		offs.drawText(rect, style.font, this.text, style.textColor);
	}
}

///@public
struct Panel: Layout {
	///@public
	bool visible = false;

	///@public
	static bool visible(Panel this, bool value) {
		if (this.visible == value) {
			return false;
		}

		this.visible = value;
		this.invalidate();
		return true;
	}

	bool onMeasure(Panel this, Rect rect&) {
		if (!this.visible) {
			// view is hidden
			rect.setSize(0, 0);
			return false;
		}
		return Layout.onMeasure(this, &rect);
	}
}

// todo this should be a TabPage and/or Accordion
// tab/expand item should be a custom 2 state button
// use a flag to enable multi selection for both TabPage or Accordion
// in case of TabPage the `select button` should be in the tab list
// in case of Accordion the `expand button` should be in the same list with the pages
struct TabPage: Layout {
	Layout tabs = null;
	Layout active = null;
	argb background = argb(0);

	void onCreate(TabPage this, View parent) {
		Layout.onCreate(this, parent);
		this.active = this.items[1].view;
		Style style&  = this.style;
		this.background = mix_rgb8(128, argb(style.backgroundColor), argb(style.hoveredColor));
	}

	static bool onMeasurePage(Layout layout, Rect rect&) {
		TabPage parent = layout.data.as(TabPage);
		if (parent != null && parent.active != layout) {
			// view is hidden
			rect.setSize(0, 0);
			return false;
		}
		return Layout.onMeasure(layout, &rect);
	}

	static void onDrawPage(Layout panel, Image offs, Rect rect) {
		TabPage page = panel.data.as(TabPage);
		offs.fillRect(rect, page.background.v);
		Layout.onDraw(panel, offs, rect);
	}

	static void onDrawBar(Layout tabs, Image offs, Rect rect) {
		TabPage page = tabs.data.as(TabPage);
		offs.fillRect(rect, page.background.v);
		Layout.onDraw(tabs, offs, rect);
	}

	static void onDrawTab(Button tab, Image offs, Rect rect) {
		TabPage page = tab.parent.parent.as(TabPage);
		Style style& = tab.style;
		if (page.active == tab.data.as(Layout)) {
			offs.fillRect(rect, style.focusedColor);
			style.align(rect, &rect, tab.text);
			offs.drawText(rect, style.font, tab.text, style.textColor);
			return;
		}
		Button.onDraw(tab, offs, rect);
	}

	static void onDrawSeparator(View this, Image offs, Rect rect) {}

	static bool onClickTab(Button button) {
		if (Layout page = button.data.as(Layout)) {
			if (TabPage tabs = page.data.as(Layout)) {
				if (tabs.active == page) {
					return false;
				}
				tabs.active = page;
				tabs.invalidate();
				page.focus();
			}
		}
		return true;
	}

	static TabPage addItems(TabPage this, const char text[*], int align, View views...) {
		inline padding = 1;
		Layout page = {
			data: this;
			// fixme: orientation;
			onDraw: onDrawPage;
			onMeasure: onMeasurePage;
		};
		Button tab = {
			text: text;
			data: page;
			focusable: false;
			onDraw: onDrawTab;
			onClick: onClickTab;
		};

		if (this.tabs == null) {
			Layout tabs = {
				paddingTop: padding;
				paddingLeft: padding;
				paddingRight: padding;
				paddingBottom: padding;
				data: this;
				onDraw: onDrawBar;
				orientation: -this.orientation;
			};

			this.tabs = tabs;
			Layout.addItems(this, Style.center, tabs);
		}

		if (this.tabs.itemCount > 0) {
			// todo: replace separator with rowSpacing and colSpacing
			Layout tabs = this.tabs;
			if (tabs.separator == null) {
				View separator = {
					width: padding;
					height: padding;
					enabled: false;
					focusable: false;
					onDraw: onDrawSeparator;
				};
				tabs.separator = separator;
			}
			tabs.addItems(0, tabs.separator);
		}

		this.tabs.addItems(0, tab);
		page.addItems(align, ...views);
		Layout.addItems(this, Style.fill, page);
		return this;
	}
}

///@public
struct Select: Layout {
	///@public
	const char text[];
	char states[*][2]; // fixme: initialize: = {"<", "^"};

	Button selected = null;
	Switch header = null;
	Panel panel = null;

	///@public
	static variant selectedData(Select select) {
		if (select.selected == null) {
			return null;
		}
		return select.selected.data;
	}

	static bool expand(Select select, bool value) {
		// focus the selected option
		if (value && select.selected != null) {
			select.selected.focus();
		} else {
			select.header.focus();
		}

		select.header.onUpdate(int(value));
		select.panel.visible(value);
		select.invalidate();
		return true;
	}

	static bool onItemClick(Select select, Button view) {
		select.selected = view;
		select.expand(false);
		select.states[0] = view.text;
		return true;
	}

	///@public
	static Select setSelectedIndex(Select select, int index) {
		if (index < 0 || index > select.panel.itemCount) {
			error("invalid index selected", index);
			return select;
		}
		Button button = select.panel.items[index].view.as(Button);
		if (button == null) {
			return select;
		}

		select.selected = button;
		select.states[0] = button.text;
		return select;
	}

	///@public
	static Select addItems(Select this, int align, View views...) {
		struct Header: Switch {
			const Select select;
			bool onReset(Header this) {
				return false;
			}
			bool onClick(Header this) {
				if (!Switch.onClick(this)) {
					return false;
				}
				this.select.expand(this.checked());
				return true;
			}
		}
		if (this.itemCount == 0) {
			Header header = {
				text: this.text;
				states: this.states;
				clickToFocus: false;
				select: this;
			};
			Panel panel = {};

			this.states[0] = "<";
			this.states[1] = "^";
			this.header = header;
			this.panel = panel;
			Layout.addItems(this, align, header, panel);
		}

		Layout.addItems(this.panel, align, ...views);
		return this;
	}

	///@public
	static Select addItem(Select this, const char text[*], variant data) {
		struct SelectItem: Button {
			const Select select;
			bool onClick(SelectItem this) {
				return this.select.onItemClick(this);
			}
		}
		SelectItem item = {
			select: this;
			text: text;
			data: data;
		};
		Select.addItems(this, Style.fill, item);
		return this;
	}

	///@public
	static Select addItem(Select this, const char text[*]) {
		return addItem(this, text, text);
	}
}

/// Widget used to display controls in image processing demos
struct FxWidget: Widget {
	///@public
	bool showOriginal = false;
	///@public
	int align = Style.fill;
	///@public
	int margin = 0;
	///@public
	int radius = 0;

	// forward the drag event to the focused view
	bool onTouchEvent(FxWidget this, const Rect rect&, const TouchEvent event&) {
		if (Widget.onTouchEvent(this, rect, event)) {
			return true;
		}

		if (!(event.button && (event.dx || event.dy))) {
			// event is not a drag event
			return false;
		}

		if (this.pressedIndex != -1) {
			// there is a pressed view, and is different than the focused one
			return false;
		}

		View view = Widget.getFocused(this);
		if (view == null) {
			// there is no focused view
			return false;
		}
		Layout parent = view.parent.as(Layout);
		Rect r& = parent.items[parent.focusedIndex].rect;
		// forward the event to the view
		return view.onTouchEvent(view, r, event);
	}
	bool onKeyEvent(FxWidget this, const KeyEvent event&) {
		if (event.key == '[' || event.key == ']') {
			bool changed = this.showOriginal != event.release;
			this.showOriginal = !event.release && (event.repeat != 0 || !this.enabled);
			// show hide on short press and release
			if (event.repeat != 0 && event.release == this.enabled) {
				// hide on long press, show on long release
				return changed && event.repeat == 1;
			}
			if (event.repeat == 0 && !event.release) {
				// show/hide when button is on released, not when pressed
				return changed;
			}

			this.clearState(Style.hovered);
			// hide, show controls
			if (event.key == '[') {
				if (this.align == Style.topLeft) {
					this.enabled = !this.enabled;
					this.invalidate();
					return true;
				}
				this.align = Style.topLeft;
			}
			if (event.key == ']') {
				if (this.align == Style.topRight) {
					this.enabled = !this.enabled;
					this.invalidate();
					return true;
				}
				this.align = Style.topRight;
			}

			this.enabled = true;
			this.invalidate();
			return true;
		}

		if (event.key == '\\') {
			this.showOriginal = !event.release;
			return event.repeat == 0 || event.release;
		}

		if (event.release) {
			return Widget.onKeyEvent(this, event);
		}

		if (event.key == Window.KEY_CODE_BACK && event.isShift) {
			return this.onReset(this);
		}

		return Widget.onKeyEvent(this, event);
	}

	bool onMeasure(FxWidget this, Rect measured&) {
		int margin = this.margin;
		int align = this.align;
		Rect rect = {
			x0: margin;
			y0: margin;
			x1: measured.width() - margin;
			y1: measured.height() - margin;
		};

		measured.x1 = measured.x0 = 0;
		measured.y1 = measured.y0 = 0;
		Layout.onMeasure(this, &measured);
		this.onLayout(this, &measured);
		Style.align(rect, &measured, align);
		return true;
	}

	void onDraw(FxWidget this, Image offs, Rect rect) {
		offs = offs.slice(rect);
		Style style& = this.style;
		if (style.backgroundColor != -1) {
			Rect r = { x0: 0, y0: 0, x1: offs.width(), y1: offs.height() };
			offs.fillRRect(r, this.radius, style.backgroundColor);
		}
		Widget.onDraw(this, offs, rect);
		offs.destroy();
	}

	/// Callback to be executed when the value of a control changes
	void onProcess(FxWidget widget) { }
}

/// Create a widget with the given `width`, `height` and `style`
Widget Widget(int width, int height, const Style style&) {
	Widget widget = {
		width: width;
		height: height;
		style: style;
	};
	return widget
		.focus(widget);	// focus first visible view
}
/// Create a widget with the given `width`, `height` and a default style
Widget Widget(int width, int height) {
	static const Style style = {
		format: { precision: 2, trimDecimal: false };
	};
	return Widget(width, height, style);
}
/// Create a widget with the given `views` used in image processing demos
FxWidget FxWidget(void onProcess(FxWidget widget), View views...) {
	static const Style style = {
		align: Style.left;
		format: { precision: 2, trimDecimal: false };
	};
	FxWidget widget = {
		radius: 5;
		margin: 10;
		align: Style.topRight;
		style: style;

		paddingTop: 3;
		paddingLeft: 3;
		paddingRight: 3;
		paddingBottom: 3;
		onProcess: onProcess;
	};

	return widget
		.focus(widget)	// focus first visible view
		.addItems(...views);
}

///@public
FxWidget FxWidget(View views...) {
	return FxWidget(FxWidget.onProcess, ...views);
}

///@public
bool hasFocused(const Layout this, View items...) {
	if (this.focusedIndex < 0) {
		// nothing is focused.
		return false;
	}
	if (items.length == 0) {
		// something is focused
		return true;
	}

	View view = this.items[this.focusedIndex].view;
	for (int i = 0; i < items.length; i += 1) {
		if (items[i] == view) {
			return true;
		}
	}

	if (Layout layout = view.as(Layout)) {
		return hasFocused(layout, ...items);
	}
	return false;
}
///@public
bool hasPressed(const Layout this, View items...) {
	if (this.pressedIndex < 0) {
		// nothing is pressed.
		return false;
	}
	if (items.length == 0) {
		// something is pressed
		return true;
	}

	View view = this.items[this.pressedIndex].view;
	for (int i = 0; i < items.length; i += 1) {
		if (items[i] == view) {
			return true;
		}
	}

	if (Layout layout = view.as(Layout)) {
		return hasPressed(layout, ...items);
	}
	return false;
}

///@public
static struct Window {
	/// Show the given `widget` in a window drawn to the `offscreen` image
	static void show(Image offscreen, Widget widget) {
		struct WindowData {
			Image offscreen;
			Widget widget;
			Rect rect;

			int64 timeout = 0;

			// Touch state
			int clicks = 0;
			int64 time = 0;
			int32 button = 0;
			int32 lastX = 0;
			int32 lastY = 0;

			// Keyboard state
			bool isShift = false;
			bool isCtrl = false;
			bool isAlt = false;
			int key = 0;
			int repeat = 0;
		}

		static bool dispatchEvent(WindowData window&, Widget widget, int action, int button, int x, int y) {
			if (widget.parent == null) {
				// widget was not created, so create it first
				widget.onCreate(widget, widget);
			}
			if (action == Window.WINDOW_INIT) {
				return true;
			}
			if (action == Window.WINDOW_CLOSE) {
				// TODO: implement reference counted gc
				widget.onDestroy(widget);
				widget.destroy();
				return false;
			}
			if (action == Window.WINDOW_ENTER) {
				// do not process event
				return false;
			}
			if (action == Window.WINDOW_LEAVE) {
				// clear hovered state
				return widget.clearState(Style.hovered);
			}

			if (action == Window.MOUSE_PRESS) {
				if (window.button != button || window.lastX != x || window.lastY != y) {
					window.clicks = 0;
				}
				int64 now = System.millis();
				if ((now - window.time) / 1000. > .5) {
					window.clicks = 0;
				}
				window.time = now;
				if (button == 1) {
					window.timeout = now + 1000;
				} else {
					window.timeout = 0;
				}
				window.button = button;
				window.lastX = x;
				window.lastY = y;
				window.clicks += 1;

				if (button != 1) {
					return false;
				}

				TouchEvent event = {
					release: false;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					clicks: window.clicks;
					button: button;
					x: x - window.rect.x0;
					y: y - window.rect.y0;
				};
				return widget.onTouchEvent(widget, window.rect, event);
			}
			if (action == Window.MOUSE_MOTION) {
				int lastX = window.lastX;
				int lastY = window.lastY;
				window.time = System.millis();
				window.timeout = 0;
				window.button = button;
				window.lastX = x;
				window.lastY = y;
				window.clicks = 0;

				if (button != 0 && button != 1) {
					return false;
				}
				TouchEvent event = {
					release: false;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					clicks: window.clicks;
					button: button;
					dx: x - lastX;
					dy: y - lastY;
					x: x - window.rect.x0;
					y: y - window.rect.y0;
				};
				return widget.onTouchEvent(widget, window.rect, event);
			}
			if (action == Window.MOUSE_RELEASE) {
				int64 now = System.millis();
				if ((now - window.time) / 1000. > .5) {
					window.clicks = 0;
				}
				window.timeout = 0;
				if (button != 1) {
					return false;
				}

				TouchEvent event = {
					release: true;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					clicks: window.clicks;
					button: button;
					x: x - window.rect.x0;
					y: y - window.rect.y0;
				};
				return widget.onTouchEvent(widget, window.rect, event);
			}

			if (action == Window.KEY_PRESS) {
				window.isShift = (y & Window.KEY_MASK_SHIFT) != 0;
				window.isCtrl = (y & Window.KEY_MASK_CTRL) != 0;
				window.isAlt = (y & Window.KEY_MASK_ALT) != 0;
				if (window.key != button) {
					window.key = button;
					window.repeat = 0;
				} else {
					window.repeat += 1;
				}

				KeyEvent event = {
					release: false;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					repeat: window.repeat;
					key: button;
				};
				return widget.onKeyEvent(widget, event);
			}
			if (action == Window.KEY_RELEASE) {
				window.isShift = (y & Window.KEY_MASK_SHIFT) != 0;
				window.isCtrl = (y & Window.KEY_MASK_CTRL) != 0;
				window.isAlt = (y & Window.KEY_MASK_ALT) != 0;
				KeyEvent event = {
					release: true;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					repeat: window.repeat;
					key: button;
				};
				window.key = 0;
				window.repeat = 0;
				return widget.onKeyEvent(widget, event);
			}

			if (action == Window.EVENT_TIMEOUT) {
				if (window.timeout > 0) {
					// long press
					TouchEvent event = {
						release: true;
						isShift: window.isShift;
						isCtrl: window.isCtrl;
						isAlt: window.isAlt;
						clicks: -1;
						button: window.button;
						x: window.lastX - window.rect.x0;
						y: window.lastY - window.rect.y0;
					};
					return widget.onTouchEvent(widget, window.rect, event);
				}
			}

			debug("event not processed", action);
			return false;
		}

		static int draw(WindowData window&, Widget widget) {
			if (!widget.enabled) {
				// widget is disabled, do not show it
				return Window.timeoutMax;
			}
			int64 timeout = Window.timeoutMax;
			if (window.timeout > 0) {
				timeout = window.timeout - System.millis();
				if (timeout < 0) {
					timeout = Window.timeoutMax;
				}
			}

			Image offs = window.offscreen;
			Rect rect& = window.rect;
			if (widget.measure) {
				rect.setSize(offs.width(), offs.height());
				widget.onMeasure(widget, &rect);
				widget.measure = false;
			}

			widget.onDraw(offs, rect, 0);
			widget.redraw = false;
			return timeout;
		}

		static int windowEvent(WindowData win&, int action, int button, int x, int y) {
			if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
				// exit when releasing escape key
				return Window.quit();
			}
			Widget widget = win.widget;

			if (action == Window.FINGER_PRESS) {
				// translate to mouse event
				action = Window.MOUSE_PRESS;
				button = 1;
			}
			if (action == Window.FINGER_MOTION) {
				// translate to mouse event
				action = Window.MOUSE_MOTION;
				button = 1;
			}
			if (action == Window.FINGER_RELEASE) {
				// translate to mouse event
				action = Window.MOUSE_RELEASE;
				button = 1;
			}

			if (!win.dispatchEvent(widget, action, button, x, y)) {
				// event not processed, wait for the next one
				if (!widget.redraw) {
					return Window.timeoutMax;
				}
				return win.draw(widget);
			}
			if (button == 0 && action == Window.MOUSE_MOTION) {
				// hover views
				return win.draw(widget);
			}
			if (button != 0 && action == Window.MOUSE_PRESS) {
				// focus views
				return win.draw(widget);
			}
			if (FxWidget fxWidget = widget.as(FxWidget)) {
				fxWidget.onProcess(fxWidget);
			}
			return win.draw(widget);
		}

		WindowData window = {
			offscreen: offscreen;
			widget: widget;
			rect: {};
		};
		return Window.show(offscreen, window, windowEvent);
	}

	/// Show the given `widget` in a window
	static void show(Widget widget) {
		Rect rect = {};
		widget.onCreate(widget, widget);
		widget.onMeasure(widget, &rect);
		Image offscreen = Image(rect.width(), rect.height(), 32);
		show(offscreen, widget);
		offscreen.destroy();
	}
}

/* original design
struct View: object {...}	// garbage collected
struct Text: View {...}
struct Label: View {...}
struct Image: View {...}
struct Check: View {...}	// Switch?
struct Input: View {...}	// single line, multi line
struct Select: View {...}	// ComboBox
struct Slider: View {...}
struct Button: View {...}

struct Panel ~= Layout
struct List: View {...}
struct Grid: View {...}
struct Page: View {...}
struct Window: View {...}

Window window = {
	width: 100;
	height: 100;
	items: {
		Button {
			label: "button1";
			onClick: print("x");
		};
	};
};
window.show();
*/
/// Style used to layout and draw text and views.
struct Style {
	/// Default dark theme color for background
	static const argb dark = argb(0x1a1a1a);
	/// Default light theme color for background
	static const argb light = argb(0xdadada);

	/// Default blue accent color for controls
	static const argb blue = argb(33, 149, 246);
	/// Default green accent color for controls
	static const argb green = argb(74, 174, 82);
	/// Default gray accent color for controls
	static const argb gray = argb(98, 125, 139);
	/// Default orange accent color for controls
	static const argb orange = argb(255, 153, 0);
	/// Default red accent color for controls
	static const argb red = argb(246, 64, 49);
	/// Default magenta accent color for controls
	static const argb magenta = argb(156, 36, 181);
	/// Default cyan accent color for controls
	static const argb cyan = argb(0, 149, 139);

	static const argb theme = dark;
	static const argb accent = gray;

	/// Alignment of text in views
	const int align = 0;

	/// Padding around text in views
	const int padding = 8;

	/// The font to be used to draw text
	const Image font = Window.font;

	/// Formatting to be used printing numbers, dates, etc
	const FormatFlags format;

	///@public
	uint32 backgroundColor = uint32(theme);
	// int disabledColor = TODO;
	///@public
	uint32 hoveredColor = uint32(mix_rgb8(16, theme, accent));
	///@public
	uint32 focusedColor = uint32(mix_rgb8(64, theme, accent));
	///@public
	uint32 valueColor = uint32(accent);
	///@public
	uint32 textColor = uint32(lum(theme) > 127 ? dark : light);

	enum: int32 {
		top: 1;
		left: 2;
		right: 4;
		bottom: 8;
		center: 0;

		topLeft: top | left;
		topRight: top | right;
		bottomLeft: bottom | left;
		bottomRight: bottom | right;

		vertical: left | right;
		verticalTop: vertical | top;
		verticalBottom: vertical | bottom;

		horizontal: top | bottom;
		horizontalLeft: horizontal | left;
		horizontalRight: horizontal | right;

		fill: top | left | right | bottom;
	}

	enum: int32 {
		hovered: 1;
		pressed: 2;
		focused: 4;
	}

	/// Place the given `rect` inside the `parent` rectangle conforming to `align`
	static void align(Rect parent, Rect rect&, int align) {
		int vertical = align & Style.vertical;
		if (vertical == center) {
			rect.positionX(parent.x0 + (parent.width() - rect.width()) / 2);
		}
		else if (vertical == right) {
			rect.positionX(parent.x0 + (parent.width() - rect.width()));
		}
		else if (vertical == left) {
			rect.positionX(parent.x0);
		}
		else { // fit
			rect.x0 = parent.x0;
			rect.x1 = parent.x1;
		}

		int horizontal = align & Style.horizontal;
		if (horizontal == center) {
			rect.positionY(parent.y0 + (parent.height() - rect.height()) / 2);
		}
		else if (horizontal == bottom) {
			rect.positionY(parent.y0 + (parent.height() - rect.height()));
		}
		else if (horizontal == top) {
			rect.positionY(parent.y0);
		}
		else { // fit
			rect.y0 = parent.y0;
			rect.y1 = parent.y1;
		}
	}

	/// Measure the given `text` whit `this` style.
	static void measure(const Style this&, Rect rect&, const char text[*]) {
		this.font.clipText(&rect, text);
		padded(&rect, this.padding);
	}

	/// Measure and align the given `text` whit `this` style.
	static void align(const Style this&, Rect parent, Rect rect&, const char value[*], int align) {
		parent.padded(-this.padding);
		this.font.clipText(&rect, value);
		if ((align & horizontal) == horizontal) {
			// center text if it is aligned both top and bottom
			align &= ~horizontal;
		}
		if ((align & vertical) == vertical) {
			// todo: justify text if it is aligned both left and right
			align &= ~vertical;
		}
		align(parent, &rect, align);
	}

	/// Measure and align the given `text` whit `this` style.
	static void align(const Style this&, Rect parent, Rect rect&, const char value[*]) {
		return align(this, parent, &rect, value, this.align);
	}

	/// Setup a custom color for the style
	static void setColor(Style style&, argb background, argb accent) {
		style.backgroundColor = uint32(background);
		style.hoveredColor = uint32(mix_rgb8(16, background, accent));
		style.focusedColor = uint32(mix_rgb8(64, background, accent));
		style.valueColor = uint32(accent);
		style.textColor = uint32(lum(background) > 127 ? dark : light);
	}

	inline vertical(int align) = (align & vertical) == vertical;
	inline horizontal(int align) = (align & horizontal) == horizontal;
}
///@public
struct KeyEvent {
	///@public
	const bool release;
	///@public
	const bool isShift;
	///@public
	const bool isCtrl;
	///@public
	const bool isAlt;
	///@public
	const int repeat;
	///@public
	const int key;
}
///@public
struct TouchEvent {
	///@public
	const bool release;
	///@public
	const bool isShift;
	///@public
	const bool isCtrl;
	///@public
	const bool isAlt;
	///@public
	const int clicks;
	///@public
	const int button;
	///@public
	const int dx = 0;
	///@public
	const int dy = 0;
	///@public
	const int x;
	///@public
	const int y;

	///@public
	static bool test(const TouchEvent event&, const Rect rect&) {
		if (event.x < rect.x0 || event.x >= rect.x1) {
			return false;
		}
		if (event.y < rect.y0 || event.y >= rect.y1) {
			return false;
		}
		return true;
	}

	///@public
	static bool isMotion(const TouchEvent event&) {
		return event.dx || event.dy;
	}

	///@public
	static bool isPress(const TouchEvent event&) {
		return !(event.release || event.dx || event.dy);
	}

	///@public
	static bool isLongPress(const TouchEvent event&) {
		return event.release && event.clicks < 0;
	}

	///@public
	static bool isPress(const TouchEvent event&, int button) {
		if (event.release || event.dx || event.dy) {
			return false;
		}
		return event.button == button;
	}
}

/** View is the base class of all user interface elements.
 * it has width and height, forming a rectangular shape on screen.
 * by it's own a view has no position, it must be positioned in a layout.
 */
struct View: object {
	/// fixed or minimum width of the view
	const int width = -5;

	/// fixed or minimum height of the view
	const int height = -5;

	/// the view accepts any user input(event) or not
	bool enabled = true;

	/// the view can be active(focused) or not
	bool focusable = true;

	// parent view
	View parent = null;

	/// style to be used when measuring and drawing the view
	Style style& = null;

	/// user attached data
	variant data = null;

	/// Returns the parent of the view
	static View parent(View this) {
		return this.parent;
	}

	/// Callback function executed when the view is clicked
	bool onClick(View this) {
		return true;
	}

	/// Callback function executed when the view is double clicked
	bool onReset(View this) {
		return false;
	}

	/// Callback function executed when the view is created
	void onCreate(View this, View parent) {
		assert(this.parent == null || this.parent == parent, "can not add the same view to different layouts");
		this.parent = parent;
		if (this.style == null) {
			assert(parent.style != null, "can not create view with a parent without a style");
			this.style = emit(pointer(parent.style));
		}
	}

	/// Callback function executed when the view is destroyed
	void onDestroy(View this) { }

	/// Callback function executed when the view receives a KeyEvent: press or release
	bool onKeyEvent(View this, const KeyEvent event&) {
		if (!this.enabled) {
			// disabled view does not consume events
			return false;
		}
		if (event.release) {
			return false;
		}
		if (event.key == ' ') {
			// click with space key
			return this.onClick(this);
		}
		if (event.key == Window.KEY_CODE_BACK) {
			// reset with backspace key
			return this.onReset(this);
		}
		return false;
	}

	/// Callback function executed when the view receives a TouchEvent: press, motion or release
	bool onTouchEvent(View this, const Rect rect&, const TouchEvent event&) {
		/* press, release or motion
		if (event.dx || event.dy) {
			return onMotion(event);
		}
		if (event.release) {
			return onRelease(event);
		}
		return onPress(event);*/
		if (!this.enabled) {
			// disabled view does not consume events
			return false;
		}
		if (!event.release) {
			// press and motion events are not consumed
			return false;
		}

		if (event.clicks < 0) {
			// long press, not released
			return this.onReset(this);
		}
		if (event.clicks > 1) {
			// multi click to reset
			if (this.onReset(this)) {
				// do not click with press and hold
				return true;
			}
		}
		return this.onClick(this);
	}

	/// Callback function executed when the view needs to be measured
	bool onMeasure(View this, Rect rect&) {
		int width = Math.abs(this.width);
		if (rect.width() < width || this.width > 0) {
			rect.width(width);
		}
		int height = Math.abs(this.height);
		if (rect.height() < height || this.height > 0) {
			rect.height(height);
		}
		return true;
	}

	/// Callback function executed when the view needs to be drawn
	void onDraw(View this, Image offs, Rect rect);

	///@public
	static void onDraw(View this, Image offs, Rect rect, int state) {
		const Style style& = this.style;
		if (state & Style.focused) {
			offs.fillRect(rect, style.focusedColor);
		}
		else if (state & Style.hovered) {
			offs.fillRect(rect, style.hoveredColor);
		}
		else if (this.parent.style != pointer(style)) {
			offs.fillRect(rect, style.backgroundColor);
		}
		this.onDraw(this, offs, rect);
		if (state & Style.pressed) {
			offs.drawRect(rect, style.valueColor);
		}
	}
	static void onDraw(View this, Image offs, Rect rect, const char text[*], const char value[*]) {
		const Style style& = this.style;
		if (text == null) {
			style.align(rect, &rect, value);
			offs.drawText(rect, style.font, value, style.valueColor);
			return;
		}

		if (value != null) {
			Rect valueRoi = rect;
			style.align(valueRoi, &valueRoi, value, Style.right);
			offs.drawText(valueRoi, style.font, value, style.valueColor);
			rect.x1 = valueRoi.x0 - style.padding;
		}
		style.align(rect, &rect, text);
		offs.drawText(rect, style.font, text, style.textColor);
	}
}

static void focus(View view);
static void invalidate(View view, bool layout);

/** Layout is a view containing other views positioned by it.
 * the Layout class does not clip its children.
 * the size of the Layout class should contain all the views.
 */
struct Layout: View {
	struct Item {
		Rect rect;
		View view;
		int align;
	}

	View separator = null;

	Item items[*] = null;
	int itemCount = 0;
	int itemCapacity = 0;
	int hoveredIndex = -1;
	int pressedIndex = -1;
	int focusedIndex = -1;

	/// Space between layout and its content at top.
	int paddingTop = 0;
	/// Space between layout and its content at left.
	int paddingLeft = 0;
	/// Space between layout and its content at right.
	int paddingRight = 0;
	/// Space between layout and its content at bottom.
	int paddingBottom = 0;

	/** Vertical, horizontal or other orientation of the layout
	 * zero represents a stack(Qt) or frame(Android) layout (all child elements are placed on top of each other)
	 * negative value represents a column layout, specifying the number of columns to be used
	 * positive value represents a row layout, specifying the number of rows to be used
	 */
	int orientation = 1;

	// TODO: use positive value for fixed size, negative values for minimum size
	// int colSpacing = 0;
	// int rowSpacing = 0;

	// TODO: make width and height of each cell the same size
	// const bool uniformWidth = true;
	// const bool uniformHeight = true;

	static bool clearState(Layout this, int mode) {
		bool result = false;
		if (mode & Style.hovered && this.hoveredIndex >= 0) {
			View view = this.items[this.hoveredIndex].view;
			if (Layout layout = view.as(Layout)) {
				clearState(layout, mode);
			}
			this.hoveredIndex = -1;
			result = true;
		}
		if (mode & Style.pressed && this.pressedIndex >= 0) {
			View view = this.items[this.pressedIndex].view;
			if (Layout layout = view.as(Layout)) {
				clearState(layout, mode);
			}
			this.pressedIndex = -1;
			result = true;
		}
		if (mode & Style.focused && this.focusedIndex >= 0) {
			View view = this.items[this.focusedIndex].view;
			if (Layout layout = view.as(Layout)) {
				clearState(layout, mode);
			}
			this.focusedIndex = -1;
			result = true;
		}
		return result;
	}

	/// Returns the pressed view in the current layout
	static View getPressed(const Layout this) {
		if (this.pressedIndex < 0) {
			return null;
		}
		View view = this.items[this.pressedIndex].view;
		if (Layout layout = view.as(Layout)) {
			View child = getPressed(layout);
			if (child != null) {
				return child;
			}
		}
		return view;
	}

	/// Returns the focused view in the current layout
	static View getFocused(const Layout this) {
		if (this.focusedIndex < 0) {
			return null;
		}
		View view = this.items[this.focusedIndex].view;
		if (Layout layout = view.as(Layout)) {
			View child = getFocused(layout);
			if (child != null) {
				return child;
			}
		}
		return view;
	}

	/// Sets the focused view in the current layout
	static bool setFocused(Layout this, View focus) {
		if (focus == null) {
			this.clearState(Style.focused);
		}
		for (int i = 0; i < this.itemCount; i += 1) {
			const Item item& = this.items[i];
			const Rect rect& = item.rect;
			const View view = item.view;
			if (view == focus && this.focusedIndex != i) {
				this.clearState(Style.focused);
				this.focusedIndex = i;
				return true;
			}
			if (Layout layout = view.as(Layout)) {
				if (layout.setFocused(focus) && this.focusedIndex != i) {
					this.clearState(Style.focused);
					this.focusedIndex = i;
					return true;
				}
			}
		}
		return false;
	}

	static Layout capacity(Layout this, int capacity) {
		assert(capacity >= this.itemCount);
		if (capacity == this.itemCapacity) {
			// no need to change
			return;
		}

		Item items[*] = this.items;
		this.itemCapacity = capacity;
		this.items = pointer.alloc(null, this.itemCapacity * sizeof(Item));
		pointer.copy(this.items, items, this.itemCount * sizeof(Item));
		pointer.alloc(items, 0);
		return this;
	}

	/// Append the given `views` to `this` layout with the given `alignment`
	static Layout addItems(Layout this, int alignment, View views...) {
		static View separator(Layout this) {
			static void onDraw(View this, Image offs, Rect rect) {}
			if (this.separator != null) {
				return this.separator;
			}
			View separator = {
				enabled: false;
				focusable: false;
				onDraw: onDraw;
			};
			this.separator = separator;
			return separator;
		}

		int itemCount = this.itemCount + views.length;
		if (itemCount >= this.itemCapacity) {
			// double the capacity
			int capacity = 2 * this.itemCapacity;
			if (capacity < itemCount) {
				capacity = itemCount;
			}
			this.capacity(capacity);
		}

		for (int i = 0; i < views.length; i += 1) {
			Item item& = this.items[this.itemCount + i];
			item.view = views[i];
			item.align = alignment;
			if (item.view == null) {
				item.view = separator(this);
			}
		}
		this.itemCount = itemCount;
		return this;
	}

	///@public
	static int size(Layout this) {
		return this.itemCount;
	}

	///@public
	static View getView(Layout this, int idx) {
		assert(idx >= 0 && idx < this.itemCount);
		return this.items[idx].view;
	}

	///@public
	static void setAlignment(Layout this, int idx, int alignment) {
		assert(idx >= 0 && idx < this.itemCount);
		this.items[idx].align = alignment;
	}

	/// Set the padding of `this` layout to the given values
	static Layout padding(Layout this, int top, int left, int right, int bottom) {
		this.paddingTop = top;
		this.paddingLeft = left;
		this.paddingRight = right;
		this.paddingBottom = bottom;
		this.invalidate(true);
		return this;
	}

	bool onClick(Layout this) {
		error("onClick", this);
		return false;
	}

	bool onReset(Layout this) {
		bool result = false;
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i].view;
			if (view.onReset(view)) {
				result = true;
			}
		}
		return result;
	}

	void onCreate(Layout this, View parent) {
		assert(this.parent == null, "can not add the same layout multiple times");
		View.onCreate(this, parent);
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i].view;
			view.onCreate(view, this);
		}
	}

	void onDestroy(Layout this) {
		// destroy views and free up allocations
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i].view;
			view.onDestroy(view);
			view.destroy();
		}
		pointer.alloc(this.items, 0);
	}

	bool onKeyEvent(Layout this, const KeyEvent event&) {
		if (!this.enabled) {
			// disabled layout does not consume events
			return false;
		}

		int idx = this.focusedIndex;
		if (idx < 0) {
			return false;
		}

		View view = this.items[idx].view;
		return view.onKeyEvent(view, event);
	}

	bool onTouchEvent(Layout this, const Rect rect&, const TouchEvent event&) {
		static int findView(Layout this, int x, int y) {
			for (int i = 0; i < this.itemCount; i += 1) {
				Item item& = this.items[i];
				if (item.view.enabled && item.rect.contains(x, y)) {
					return i;
				}
			}
			return -1;
		}

		if (!this.enabled) {
			// disabled layout does not consume events
			return false;
		}

		bool result = false;
		int active = this.pressedIndex;
		if (!(event.dx || event.dy || event.release) || !event.button) {
			active = findView(this, event.x, event.y);
		}

		if (active < 0) {
			// not an active view
			int states = Style.hovered;
			if (event.release) {
				states |= Style.pressed;
			}
			return this.clearState(states);
		}

		Item item& = this.items[active];
		View view = item.view;
		if (!view.enabled) {
			// not an enabled view
			int states = Style.hovered;
			if (event.release) {
				states |= Style.pressed;
			}
			return this.clearState(states);
		}

		if (this.pressedIndex != active && event.isPress(1)) {
			// pressed a different view, update pressed view
			this.clearState(Style.pressed);
			this.pressedIndex = active;
			result = true;
		}

		bool outside = !event.test(item.rect);
		if (this.hoveredIndex != active || outside) {
			// update current view as hovered
			if (this.clearState(Style.hovered)) {
				result = true;
			}
			if (!outside) {
				this.hoveredIndex = active;
				result = true;
			}
		}

		if (event.release && outside) {
			// return if released outside the pressed view
			return this.clearState(Style.pressed|Style.hovered);
		}

		if (view.onTouchEvent(view, item.rect, event)) {
			// event processed by the view
			result = true;
		}

		if (!event.release) {
			return result;
		}

		bool focusable = view.focusable;
		if (outside) {
			focusable = false;
		}
		else if (event.clicks < 0) {
			// do not focus on long press
			this.clearState(Style.hovered);
			focusable = false;
		}
		else if (this.focusedIndex == active) {
			// already in focus, do not focus
			focusable = false;
		}
		else if (Layout layout = view.as(Layout)) {
			if (layout.focusedIndex == -1) {
				// child is a layout, with no focused item
				focusable = false;
			}
		}

		if (focusable) {
			this.clearState(Style.focused);
			this.focusedIndex = active;
			result = true;
		}
		if (this.clearState(Style.pressed)) {
			return true;
		}
		return result;
	}

	bool onMeasure(Layout this, Rect measured&) {
		int dir = this.orientation;
		int N = Math.abs(dir);
		int n = 0;
		int maxWidth = 0;
		int sumWidth = 0;
		int maxHeight = 0;
		int sumHeight = 0;
		int rows = dir < 0 ? N : 1;
		int cols = dir > 0 ? N : 1;
		for (int i = 0; i < this.itemCount; i += 1) {
			Item item& = this.items[i];
			Rect rect& = item.rect;
			View view = item.view;
			rect.x0 = rect.x1 = 0;
			rect.y0 = rect.y1 = 0;
			if (view.onMeasure(view, &rect)) {
				int width = rect.width();
				int height = rect.height();
				if (n >= N) {
					cols += int(dir < 0);
					rows += int(dir > 0);
					n = 0;
				}
				sumWidth += width;
				if (maxWidth < width) {
					maxWidth = width;
				}
				sumHeight += height;
				if (maxHeight < height) {
					maxHeight = height;
				}
				n += 1;
			}
		}
		if (rows == 1 && cols == 1) {
			sumWidth = maxWidth;
			sumHeight = maxHeight;
		}
		if (rows > 1) {
			// multi row layout, using uniform width
			sumWidth = maxWidth * cols;
		}
		if (cols > 1) {
			// multi column layout, using uniform height
			sumHeight = maxHeight * rows;
		}
		measured.width(sumWidth + this.paddingLeft + this.paddingRight);
		measured.height(sumHeight + this.paddingTop + this.paddingBottom);
		return View.onMeasure(this, &measured);
	}

	// TODO: make layout part of the measure step: to calculate the correct width and height,
	//       elements inside the layout must be placed to their position
	void onLayout(Layout this, Rect measured&) {
		static void verticalLayout(Layout this, Rect measured&, int cols) {
			int rowSpacing = measured.width() / cols;
			int colSpacing = 0;
			int grow = 0;

			if (true) {
				int maxSize = 0;
				int sumSize = 0;
				int rows = 0;
				int n = cols;
				for (int i = 0; i < this.itemCount; i += 1) {
					Rect rect& = this.items[i].rect;
					if (!rect.empty()) {
						if (n >= cols) {
							sumSize += maxSize;
							maxSize = 0;
							rows += 1;
							n = 0;
						}
						if (maxSize < rect.height()) {
							maxSize = rect.height();
						}
						if (colSpacing < maxSize) {
							colSpacing = maxSize;
						}
						n += 1;
					}
				}
				sumSize += maxSize;
				if (rows > 0 && measured.height() > sumSize) {
					grow = (measured.height() - sumSize) / rows;
				}
			}

			Rect r = {
				x0: measured.x0;
				y0: measured.y0;
				x1: measured.x0 + (this.width > 0 ? this.width : measured.width());
				y1: measured.y0 + (this.height > 0 ? this.height : measured.height());
			};

			int n = cols;
			r.translateY(-colSpacing - grow);
			for (int i = 0; i < this.itemCount; i += 1) {
				Item item& = this.items[i];
				Rect rect& = item.rect;
				if (rect.empty()) {
					continue;
				}

				if (n >= cols) {
					r.positionX(measured.x0);
					r.translateY(colSpacing + grow);
					if (cols == 1) {
						// single row, allow non uniform heights
						colSpacing = rect.height();
					//} else {
						// using non uniform heights
						//colSpacing = maxHeight(this, i, cols);
					}
					n = 0;
				}

				r.width(rowSpacing);
				r.height(colSpacing + grow);
				View view = item.view;
				int align = item.align;
				if (view.width > 0 && Style.vertical(align)) {
					// fixed width, center instead of stretch
					align &= ~Style.vertical;
				}
				if (view.height > 0 && Style.horizontal(align)) {
					// fixed height, center instead of stretch
					align &= ~Style.horizontal;
				}

				Style.align(r, &rect, align);
				if (Layout layout = view.as(Layout)) {
					layout.onLayout(layout, &rect);
				}

				r.translateX(rowSpacing);
				n += 1;
			}
		}
		static void horizontalLayout(Layout this, Rect measured&, int rows) {
			int colSpacing = measured.height() / rows;
			int rowSpacing = 0;
			int grow = 0;

			if (true) {
				int maxSize = 0;
				int sumSize = 0;
				int cols = 0;
				int n = rows;
				for (int i = 0; i < this.itemCount; i += 1) {
					Rect rect& = this.items[i].rect;
					if (!rect.empty()) {
						if (n >= rows) {
							sumSize += maxSize;
							maxSize = 0;
							cols += 1;
							n = 0;
						}
						if (maxSize < rect.width()) {
							maxSize = rect.width();
						}
						if (rowSpacing < rect.width()) {
							rowSpacing = rect.width();
						}
						n += 1;
					}
				}
				sumSize += maxSize;
				if (cols > 0 && measured.width() > sumSize) {
					grow = (measured.width() - sumSize) / cols;
				}
			}

			Rect r = {
				x0: measured.x0;
				y0: measured.y0;
				x1: measured.x0 + (this.width > 0 ? this.width : measured.width());
				y1: measured.y0 + (this.height > 0 ? this.height : measured.height());
			};

			int n = rows;
			r.translateX(-rowSpacing - grow);
			for (int i = 0; i < this.itemCount; i += 1) {
				Item item& = this.items[i];
				Rect rect& = item.rect;
				if (rect.empty()) {
					continue;
				}

				if (n >= rows) {
					r.positionY(measured.y0);
					r.translateX(rowSpacing + grow);
					if (rows == 1) {
						// single column, allow non uniform widths
						rowSpacing = rect.width();
					//} else {
						// using non uniform widths
						//rowSpacing = maxWidth(this, i, rows);
					}
					n = 0;
				}

				r.width(rowSpacing + grow);
				r.height(colSpacing);
				View view = item.view;
				int align = item.align;
				if (view.width > 0 && Style.vertical(align)) {
					// fixed width, center instead of stretch
					align &= ~Style.vertical;
				}
				if (view.height > 0 && Style.horizontal(align)) {
					// fixed height, center instead of stretch
					align &= ~Style.horizontal;
				}

				Style.align(r, &rect, align);
				if (Layout layout = view.as(Layout)) {
					layout.onLayout(layout, &rect);
				}

				r.translateY(colSpacing);
				n += 1;
			}
		}
		static void addPadding(const Layout this, Rect rect&, int multiplier) {
			rect.x0 -= multiplier * this.paddingLeft;
			rect.y0 -= multiplier * this.paddingTop;
			rect.x1 += multiplier * this.paddingRight;
			rect.y1 += multiplier * this.paddingBottom;
		}

		this.addPadding(&measured, -1);
		if (this.orientation > 0) {
			/* Multi column vertical layout, ex 3 cols:
			/--- col0 ---+--- col1 ---+--- col2 ---\
			|   item00   |   item01   |   item02   | row0
			|   item03   |   item04   |            | row1
			.    ...     |    ...     |    ...     . rowN
			\------------+------------+-----------*/
			verticalLayout(this, &measured, this.orientation);
			this.addPadding(&measured, 1);
			return;
			//return verticalLayout(this, &measured, this.orientation);
		}
		if (this.orientation < 0) {
			/* multi row horizontal layout, ex 2 rows:
			/--- col0 ---+--- col1 ---+--- col2 ---+--- colN ---\
			|   item00   |   item02   |   item04   |    ...     | row0
			|   item01   |   item03   |    ...     |    ...     | row1
			\------------+------------+------------+--- ... ---*/
			horizontalLayout(this, &measured, -this.orientation);
			this.addPadding(&measured, 1);
			return;
			//return horizontalLayout(this, &measured, -this.orientation);
		}

		Rect r = {
			x0: measured.x0;
			y0: measured.y0;
			x1: measured.x0 + (this.width > 0 ? this.width : measured.width());
			y1: measured.y0 + (this.height > 0 ? this.height : measured.height());
		};

		for (int i = 0; i < this.itemCount; i += 1) {
			const Item item& = this.items[i];
			const Rect rect& = item.rect;
			if (rect.empty()) {
				continue;
			}

			const View view = item.view;
			Style.align(measured, &rect, item.align);
			if (Layout layout = view.as(Layout)) {
				layout.onLayout(layout, &rect);
			}
		}
		this.addPadding(&measured, 1);
	}

	void onDraw(Layout this, Image offs, Rect parent) {
		for (int i = 0; i < this.itemCount; i += 1) {
			const Item item& = this.items[i];
			const Rect rect& = item.rect;
			if (rect.empty()) {
				continue;
			}

			const View view = item.view;
			int state = 0;
			if (view.as(Layout) == null) {
				if (i == this.hoveredIndex) {
					state |= Style.hovered;
				}
				if (i == this.pressedIndex) {
					state |= Style.pressed;
				}
				if (i == this.focusedIndex) {
					state |= Style.focused;
				}
			}
			view.onDraw(offs, rect, state);
		}
	}

	/// Create a custom Layout containing the given `items` all of them aligned as `alignment`
	static Layout Custom(int rowsCols, int alignment, View items...) {
		Layout layout = {
			orientation: rowsCols;
		};
		if (items.length > 0) {
			layout.addItems(alignment, ...items);
		}
		return layout;
	}

	/// Create a Row-layout containing the given `items` arranged vertically in a single row
	static Layout Row(View items...) {
		return Custom(-1, Style.fill, ...items);
	}

	/// Create a Column-layout containing the given `items` arranged horizontally in a single column
	static Layout Column(View items...) {
		return Custom(1, Style.fill, ...items);
	}

	/// Create a Stack-layout containing the given `items` stacked on top of each other
	static Layout Stack(View items...) {
		return Custom(0, Style.fill, ...items);
	}
}

/** Widget is a special kind of layout, which can clip the content of its elements.
 * a widget may clip its children and apply scrolling to them, even show a scrollbar.
 */
struct Widget: Layout {
	bool measure = true;	// force layout
	bool redraw = true;		// force redraw
	View focus = null;

	int scrollX = 0;
	int scrollY = 0;

	static bool focusNext(View view, bool prev) {
		if (view == null) {
			// probably a separator
			return false;
		}
		if (!view.enabled) {
			// can not focus a disabled view
			return false;
		}
		if (!view.focusable) {
			// can not focus a non focusable view
			return false;
		}

		Layout this = view.as(Layout);
		if (this == null) {
			// view is not a layout, and is focusable
			return true;
		}

		int n = this.focusedIndex;
		if (prev) {
			if (n < 0) {
				n = this.itemCount - 1;
			}
			for (int i = n; i >= 0; i -= 1) {
				const Item item& = this.items[i];
				const Rect rect& = item.rect;
				const View view = item.view;
				if (!rect.empty() && focusNext(view, prev)) {
					if (view.as(Layout) != null || i != this.focusedIndex) {
						this.focusedIndex = i;
						return true;
					}
				}
			}
		} else {
			if (n < 0) {
				n = 0;
			}
			for (int i = n; i < this.itemCount; i += 1) {
				const Item item& = this.items[i];
				const Rect rect& = item.rect;
				const View view = item.view;
				if (!rect.empty() && focusNext(view, prev)) {
					if (view.as(Layout) != null || i > this.focusedIndex) {
						this.focusedIndex = i;
						return true;
					}
				}
			}
		}

		this.clearState(Style.focused);
		return false;
	}

	/// Append the given `views` to `this` widget with the given `alignment`
	static Widget addItems(Widget this, int align, View views...) {
		Layout.addItems(this, align, ...views);
		return this;
	}

	/// Append the given `views` to `this` widget
	static Widget addItems(Widget this, View views...) {
		Layout.addItems(this, Style.fill, ...views);
		return this;
	}

	/// Set the initial focused wie in the widget
	static Widget focus(Widget this, View value) {
		this.focus = value;
		return this;
	}

	/// Set the padding of `this` widget to the given values
	static Layout padding(Layout this, int top, int left, int right, int bottom) {
		Layout.padding(this, top, left, right, bottom);
		return this;
	}

	/// Set the padding of `this` widget to the given values
	static Layout padding(Widget this, int vertical, int horizontal) {
		Layout.padding(this, vertical, horizontal, horizontal, vertical);
		return this;
	}

	/// Set the padding of `this` widget to the given value
	static Widget padding(Widget this, int padding) {
		Layout.padding(this, padding, padding, padding, padding);
		return this;
	}

	void onCreate(Widget this, View parent) {
		Layout.onCreate(this, parent);
		this.measure = true;

		if (this.focus != null) {
			this.focus.focus();
			this.focus = null;
		}
	}

	bool onKeyEvent(Widget this, const KeyEvent event&) {
		if (Layout.onKeyEvent(this, event)) {
			return true;
		}

		if (event.release) {
			return false;
		}

		if (event.key == Window.KEY_CODE_TAB || event.key == Window.KEY_CODE_ENTER) {
			// Tab, Enter: select prev or next control.
			this.clearState(Style.hovered);
			if (!this.focusNext(event.isShift)) {
				return this.focusNext(event.isShift);
			}
			return true;
		}

		return false;
	}

	// TODO: make layout part of the measure step: to calculate the correct width and height,
	//       elements inside the layout must be placed to their position
	bool onMeasure(Widget this, Rect measured&) {
		Layout.onMeasure(this, &measured);
		this.onLayout(this, &measured);
		return true;
	}

	void onDraw(Widget this, Image offs, Rect rect) {
		offs.fillRect(rect, this.style.backgroundColor);
		Layout.onDraw(this, offs, rect);
	}
}

/// Return the root widget of the given `view`
Widget getWidget(View view) {
	for (View v = view; v != null; v = v.parent) {
		if (Widget w = v.as(Widget)) {
			return w;
		}
		// todo: check for cycles (indirect)
		assert(v != v.parent);
	}
	return null;
}

/// Set the given `view` focused
void focus(View view) {
	static void clearFocus(Layout layout) {
		for (int i = 0; i < layout.itemCount; i += 1) {
			View view = layout.items[i].view;
			if (Layout child = view.as(Layout)) {
				clearFocus(child);
			}
		}
		layout.hoveredIndex = -1;
		layout.pressedIndex = -1;
		layout.focusedIndex = -1;
	}
	Widget widget = getWidget(view);

	Layout layout = view.as(Layout);
	if (layout == null) {
		// the view is a leaf node, focus it
		widget.clearFocus();
		widget.setFocused(view);
		return;
	}

	View focus = layout.getFocused();
	if (focus != null) {
		// the layout has a focused element, focus it
		widget.clearFocus();
		widget.setFocused(focus);
		return;
	}

	Rect rect = {};
	// focus the first visible element from the layout
	widget.onMeasure(widget, &rect);
	widget.clearFocus();
	widget.setFocused(view);
	widget.focusNext(false);
	widget.measure = true;
}

/// Invalidate the view, so the next frame it will be redrawn, and measured in case `layout` is set to true
void invalidate(View view, bool layout) {
	Widget widget = getWidget(view);
	if (layout) {
		widget.measure = true;
	}
	widget.redraw = true;
}

/// Invalidate the view, so the next frame it will be measured and redrawn
inline invalidate(View view) = invalidate(view, true);

/// Returns weather the given `view` is in focused state or not.
bool isFocused(View view) {
	Widget widget = getWidget(view);
	return view == widget.getFocused();
}
/// Returns weather the given `view` is in pressed state or not.
bool isPressed(View view) {
	Widget widget = getWidget(view);
	return view == widget.getPressed();
}
/// Returns weather the given `view` needs to be measured or not.
bool isDirty(View view) {
	Widget widget = getWidget(view);
	return widget.measure;
}
/// Checks whether the given `rectangle` is empty or not.
bool empty(const Rect rectangle&) {
// fixme: inline empty(const Rect roi&) = roi.x0 >= roi.x1 || roi.y0 >= roi.y1;
	return rectangle.x0 >= rectangle.x1 || rectangle.y0 >= rectangle.y1;
}

/// Checks whether the given `rectangle` contains the point (`x`, `y`).
bool contains(const Rect rect&, int x, int y) {
	return x >= rect.x0 && x < rect.x1 && y >= rect.y0 && y < rect.y1;
}

/// Computes the width of the given `rectangle`.
inline width(const Rect rectangle&) = rectangle.x1 - rectangle.x0;
/// Sets the width of the given `rectangle`.
void width(Rect rectangle&, int width) {
	rectangle.x1 = rectangle.x0 + width;
}

/// Computes the height of the given `rectangle`.
inline height(const Rect rectangle&) = rectangle.y1 - rectangle.y0;
/// Sets the height of the given `rectangle`.
void height(Rect rectangle&, int height) {
	rectangle.y1 = rectangle.y0 + height;
}

/// Sets the width and height of the given `rectangle`.
void setSize(Rect rectangle&, int width, int height) {
	rectangle.x1 = rectangle.x0 + width;
	rectangle.y1 = rectangle.y0 + height;
}

/// Sets the x position of the given `rectangle`.
void positionX(Rect rectangle&, int x) {
	rectangle.x1 = x + rectangle.x1 - rectangle.x0;
	rectangle.x0 = x;
}
/// Sets the y position of the given `rectangle`.
void positionY(Rect rectangle&, int y) {
	rectangle.y1 = y + rectangle.y1 - rectangle.y0;
	rectangle.y0 = y;
}

/// Sets the x and y position of the given `rectangle`.
void position(Rect rectangle&, int x, int y) {
	rectangle.positionX(x);
	rectangle.positionY(y);
}

///@public
void adjust(Rect rect&, int dx0, int dy0, int dx1, int dy1) {
	rect.x0 += dx0;
	rect.y0 += dy0;
	rect.x1 += dx1;
	rect.y1 += dy1;
}

///@public
void padded(Rect rect&, int padding) {
	rect.x0 -= padding;
	rect.y0 -= padding;
	rect.x1 += padding;
	rect.y1 += padding;
}

/// Moves the given `rectangle` by `dx` and `dy`.
inline translate(Rect rectangle&, int dx, int dy) = rectangle.adjust(dx, dy, dx, dy);
/// Moves the given `rectangle` horizontally by `dx`.
void translateX(Rect rectangle&, int dx) {
	rectangle.x0 += dx;
	rectangle.x1 += dx;
}
/// Moves the given `rectangle` vertically by `dy`.
void translateY(Rect rectangle&, int dy) {
	rectangle.y0 += dy;
	rectangle.y1 += dy;
}
///@public
static struct Window {
	enum { timeoutMax: (1 << 31) - 1 }

	/// calculate the timeout based on the given fps
	inline timeoutFps(float64 fps) = int64(1000 / fps);

/// Show the given `image` in a window and delegate the events to the `onEvent` callback
void show(Image image, int onEvent(int action, int button, int ex, int ey)) {
	if (onEvent == null) {
		return Window.show(image, null, null);
	}
	static int delegate(int onEvent(int action, int button, int ex, int ey), int action, int button, int ex, int ey) {
		return onEvent(action, button, ex, ey);
	}
	Window.show(image, onEvent, delegate);
}

/// Show the images in a window clicking on the window will select one of them
void show(int width, int height, Image image0, Image image1, Image image2) {
	struct Data {
		Image offs;
		Image image0;
		Image image1;
		Image image2;
	}

	static int onEvent(const Data data&, int action, int button, int ex, int ey) {
		if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
			// exit when releasing escape key
			return Window.quit();
		}
		if (action == Window.MOUSE_PRESS || action == Window.MOUSE_RELEASE) {
			Image show = data.image0;
			if (action == Window.MOUSE_RELEASE) {
				show = data.image0;
			}
			else if (button == 1) {
				show = data.image1;
			}
			else {
				show = data.image2;
			}
			if (data.offs.width() != show.width() || data.offs.height() != show.height()) {
				data.offs.transform(null, show, null, 1, null);
			} else {
				data.offs.copy(0, 0, show, null);
			}
		}
		return Window.timeoutMax;
	}

	Image offs = Image(width, height, image0.depth());
	Data data = {
		offs: offs;
		image0: image0;
		image1: image1;
		image2: image2;
	};
	onEvent(data, Window.MOUSE_RELEASE, 0, 0, 0);
	Window.show(offs, data, onEvent);
	offs.destroy();
}

/// Show the images in a window clicking on the window will select one of them
void show(Image image0, Image image1, Image image2) {
	int width = image0.width();
	int height = image0.height();
	return show(width, height, image0, image1, image1);
}

/// Show the images in a window clicking on the window will select one of them
void show(Image image0, Image image1) {
	return show(image0, image1, image1);
}

/// Show the image in a window
void show(Image image) {
	Window.show(image, image, image);
}

/// Show or animate the the procedural image generated by the `eval` function
void show(int width, int height, int animationResolution, vec4f eval(vec4f in)) {
	static const int64 start = System.millis();
	struct Data {
		bool lerp = true;
		const Image offs;
		const Image thumb;
		const float32 aspect;
		int32 fpsCount = 0;	// frames drawn
		float32 fpsTime = 0;	// frame per sec shot time
		const vec4f eval(vec4f in);
	}

	static int onEvent(Data data&, int action, int button, int ex, int ey) {
		if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
			// exit when releasing escape key
			return Window.quit();
		}
		if (action == Window.WINDOW_CLOSE) {
			return Window.quit();
		}
		if (action == Window.KEY_RELEASE) {
			if (button == ' ') {
				char text[256] = {};
				int64 now = System.millis();
				float32 time = (now - start) / 1000f;
				data.offs.eval(null, data.aspect, time, data.eval);
				text.append(text.append(0, "Millis: "), System.millis() - now);
				Window.setTitle(text);
				return Window.timeoutMax;
			}
			if (button == Window.KEY_CODE_TAB) {
				data.lerp = !data.lerp;
			}
			if (button == 'S') {
				trace("dumping screen");
				data.offs.saveBmp("out/offs.bmp", 0);
				data.thumb.saveBmp("out/thumb.bmp", 0);
			}
		}

		float32 time = (System.millis() - start) / 1000f;
		data.thumb.eval(null, data.aspect, time, data.eval);
		data.offs.resize(null, data.thumb, null, int(data.lerp));
		if (time > data.fpsTime) {
			char text[256] = {};
			text.append(text.append(0, "Fps: "), data.fpsCount);
			Window.setTitle(text);
			data.fpsTime = time + 1;
			data.fpsCount = 0;
		}
		data.fpsCount += 1;

		// do not block for any input
		return 0;
	}

	if (animationResolution == 0) {
		float32 aspect = width / float32(height);
		Image image = Image(width, height, 32);
		image.eval(null, aspect, 0f, eval);
		Window.show(image);
		image.destroy();
		return;
	}

	Data data = {
		offs: Image(width, height, 32);
		thumb: Image(animationResolution, animationResolution, 32);
		aspect: width / float32(height);
		eval: eval;
	};
	Window.show(data.offs, data, onEvent);
	data.thumb.destroy();
	data.offs.destroy();
}

/// Show the the procedural image generated by the `eval` function
void show(int width, int height, vec4f eval(vec4f in)) {
	return show(width, height, 0, eval);
}

/// Show the mesh in a window
void show(int w, int h, float32 fovy, Mesh mesh) {
	struct Data {
		int32 fpsCount = 0;	// frames drawn
		int32 fpsShow = 0;	// frames drawn
		int64 fpsTime = 0;	// frame per sec shot time
		int mode;
		Image offs;
		mat4f proj;
		Camera cam;
		Mesh mesh;

		static void updateCamera(const Data this&) {
			Camera camera& = this.cam;
			camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
		}
	}

	int nextInc(int32 x, int mask) {
		int next = x & mask;

		// add lowest bit of mask
		next += mask & -mask;

		// avoid overflow
		next &= mask;

		return next | (x & ~mask);
	}
	int nextBit(int32 x, int mask) {
		int next = x & mask;

		if (next == 0) {
			next = mask & -mask;
		} else {
			// add lowest bit of mask
			next = (next + next) & mask;
		}

		return next | (x & ~mask);
	}

	static int onEvent(Data data&, int action, int button, int ex, int ey) {
		static int ox = 0;
		static int oy = 0;
		static const float32 slow = 1 / 100f;
		static const float32 fast = 5 / 100f;

		if (action == Window.MOUSE_MOTION || action == Window.FINGER_MOTION) {
			Camera camera& = data.cam;
			int dx = ex - ox;
			int dy = ey - oy;

			if (button == 1 || action == Window.FINGER_MOTION) {
				// orbit around the origin: (x: 0, y: 0, z: 0)
				vec4f orbit = vec4f(0, 0, 0);
				camera.rotate(orbit, camera.up, dx * slow);
				camera.rotate(orbit, camera.right, dy * slow);
				data.updateCamera();
			}
			else if (button == 2) {
				// rotate
				vec4f orbit = camera.position;
				camera.rotate(orbit, camera.up, -dx * slow);
				camera.rotate(orbit, camera.right, -dy * slow);
				data.updateCamera();
			}
			else if (button == 3) {
				// move the camera back and forward
				camera.move(camera.forward, dy * slow);
				data.updateCamera();
			}
			else if (button == 4) {
				// pan the camera
				camera.move(camera.right, -dx * slow);
				camera.move(camera.up, dy * slow);
				data.updateCamera();
			}
			ox = ex;
			oy = ey;
		}
		else if (action == Window.MOUSE_PRESS || action == Window.FINGER_PRESS) {
			ox = ex;
			oy = ey;
			return Window.timeoutMax;
		}
		else if (action == Window.MOUSE_WHEEL) {
			Camera camera& = data.cam;
			camera.move(camera.forward, ey * fast);
			data.updateCamera();
		}

		else if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
			// exit when releasing escape key
			return Window.quit();
		}
		else if (action == Window.KEY_PRESS) {
			if (button == Window.KEY_CODE_ENTER) {
				return onEvent(&data, Window.WINDOW_INIT, button, ex, ey);
			}

			else if (button == 'w') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.forward, +(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 's') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.forward, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 'a') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.right, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 'd') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.right, +(shift ? fast : slow));
				data.updateCamera();
			}

			else if (button == Window.KEY_CODE_UP) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.right, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Window.KEY_CODE_DOWN) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.right, +(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Window.KEY_CODE_LEFT) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.up, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Window.KEY_CODE_RIGHT) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.up, +(shift ? fast : slow));
				data.updateCamera();
			}

			else if (button == 'l') {
				data.mode ^= Mesh.useLights;
			}
			else if (button == 'b') {
				data.mode ^= Mesh.drawBounds;
			}
			else if (button == '0') {
				lights.enable(0, !lights.enabled(0));
			}
			else if (button == '1') {
				lights.enable(1, !lights.enabled(1));
			}
			else if (button == '2') {
				lights.enable(2, !lights.enabled(2));
			}
			else if (button == '3') {
				lights.enable(3, !lights.enabled(3));
			}
			else if (button == 't') {
				data.mode ^= Mesh.useTexture;
			}
			else if (button == '/') {
				data.mode = nextInc(data.mode, Mesh.cullMode);
			}
			else if (button == Window.KEY_CODE_TAB) {
				data.mode = nextBit(data.mode, Mesh.drawMode);
			}
		}

		else if (action == Window.WINDOW_INIT) {
			Camera camera& = data.cam;
			vec4f eye = {x: 0, y: 0, z: 2, w: 1};
			vec4f at = {x: 0, y: 0, z: 0, w: 1};
			vec4f up = {x: 0, y: 1, z: 0, w: 1};
			data.cam = Camera.lookAt(eye, at, up);
			data.updateCamera();
		}

		int rendered = data.offs.drawMesh(data.mesh, data.mode);

		char text[256] = {};
		int pos = text.append(0, "Vertices: ");
		pos = text.append(pos, data.mesh.vertices);
		pos = text.append(pos, ", Triangles: ");
		pos = text.append(pos, data.mesh.triangles);
		pos = text.append(pos, "/");
		pos = text.append(pos, rendered);
		pos = text.append(pos, ", Fps: ");
		pos = text.append(pos, data.fpsShow);
		Window.setTitle(text);

		int64 time = System.millis();
		if (time > data.fpsTime) {
			data.fpsTime = time + 1000;
			data.fpsShow = data.fpsCount;
			data.fpsCount = 0;
		}
		data.fpsCount += 1;
		return Window.timeoutMax;
	}

	Data data = {
		mode: Mesh.useLights | Mesh.cullBack | Mesh.drawFill;
		offs: Image.create3d(w, h);
		proj: Camera.projection(fovy, w / float32(h), 1, 100);
		cam: {};
		mesh: mesh;
	};
	Window.show(data.offs, data, onEvent);
	data.offs.destroy();
}
}
// standard library extension

// Known boolean values
enum: bool {
	true: 0 == 0;
	false: 0 != 0;
}

inline byte = uint8;
inline float = float32;
inline double = float64;

/// Returns the size of the given type
inline sizeof(typename type) = typename.size(type);

static if (typename(raise) == function) {
// extension methods for debugging
inline "lib/lang/Debug.ci";
}

inline "lib/lang/Pointer.ci";       // pointer extension methods

// Math
inline "lib/math/Bits.ci";
inline "lib/math/Math.ci";
inline "lib/math/Fixed.ci";
inline "lib/math/Complex.ci";
inline "lib/math/Vector4f.ci";
inline "lib/math/Matrix4f.ci";
inline "lib/math/Vector2d.ci";
//todo: inline "lib/math/Decimal.ci"?;
//todo: inline "lib/math/Rational.ci"?;
//todo: inline "lib/math/BigInteger.ci"?;   // TODO: inline Rational -> BigInteger.Rational<BigInteger>
//todo: inline "lib/math/BigDecimal.ci"?;   // TODO: inline Complex -> BigDecimal.Complex<BigDecimal>
//todo: inline "lib/math/Perlin.ci"?;


// Time
inline "lib/time/Timeunit.ci";
inline "lib/time/Duration.ci";
inline "lib/time/Timestamp.ci";
inline "lib/time/Timezone.ci";
inline "lib/time/Datetime.ci";


// Text
inline "lib/text/cstr.ci";
inline "lib/text/Format.ci";
inline "lib/text/stream/ByteStream.ci";
inline "lib/text/stream/TextStream.ci";
inline "lib/text/encoding/binary/Base64.ci";
inline "lib/text/encoding/Ascii.ci";
inline "lib/text/encoding/Utf8.ci";
//todo: inline "lib/text/String.ci";
//todo: inline "lib/text/Collator.ci";
//todo: inline "lib/text/serialization/csv.ci";
//todo: inline "lib/text/serialization/json.ci";
//todo: inline "lib/text/serialization/yaml.ci";
//todo: inline "lib/text/serialization/xml.ci";


// etc
inline "lib/math/Easing.ci";
//inline "lib/math/Perlin.ci";
inline "lib/math/Polynomial.ci"?;
// debugging related functions

/// report message at `verbose` logging level
inline verbose(const char message[*], const variant details...) = raise(raise.verbose, raise.noTrace, message, ...details);

/// report message at `debug` logging level
inline debug(const char message[*], const variant details...) = raise(raise.debug, raise.noTrace, message, ...details);

/// report message with stacktrace at `debug` logging level
inline trace(const char message[*], const variant details...) = raise(raise.debug, raise.defTrace, message, ...details);

/// report message at `info` logging level
inline info(const char message[*], const variant details...) = raise(raise.info, raise.noTrace, message, ...details);

/// report message at `warn` logging level
inline warn(const char message[*], const variant details...) = raise(raise.warn, raise.noTrace, message, ...details);

/// report message with stacktrace at `error` logging level
inline error(const char message[*], const variant details...) = raise(raise.error, raise.defTrace, message, ...details);

/// report message with stacktrace at `abort` logging level and abort execution
inline abort(const char message[*], const variant details...) = raise(raise.abort, raise.defTrace, message, ...details);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort() = raise(raise.abort, raise.defTrace, "execution aborted!");

/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, const char message[*], const variant details...) = void(condition ? void(0) : raise(raise.abort, raise.defTrace, message, ...details));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, const variant details...) = void(condition ? void(0) : raise(raise.abort, raise.defTrace, "assertion failed!", ...details));

/// Record used for debugging purposes, containing expected, returned and an array of extra values
struct NotEquals {
	/// Value of the expected result
	const variant expected;

	/// Value of the actual result
	const variant returned;

	/// Extra argument to identify what happened
	const variant extras[];
}

/// Create a not equals record for inspection from expected and returned
NotEquals NotEquals(const variant expected, const variant returned) {
	return {
		expected: expected;
		returned: returned;
		extras: null;
	};
}

/// abort execution displaying the expected and returned values
inline abort(const char message[*], const NotEquals detail&) = raise(raise.abort, raise.defTrace, message, detail);
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, const char message[*], const NotEquals detail&) = void(condition ? void(0) : abort(message, detail));

/// abort execution if the returned value is not equal to the expected value
// TODO: make inline
static void assertEq(int expected, int returned, const char message[*]) {
	if (returned == expected) {
		return;
	}
	variant extras[1] = { message };
	NotEquals detail = {
		expected: expected;
		returned: returned;
		extras: extras;
	};
	raise(raise.abort, raise.defTrace, "assertion failed", detail);
}
/// abort execution if the returned value is not equal to the expected value
inline assertEq(int expected, int returned) = assertEq(expected, returned, null);
static if (int == int32) {
	/// Returns the pointer incremented with the given value
	inline inc(pointer ptr, int val) = pointer(emit(pointer(ptr), int(val), add.i32));
}
static if (int == int64) {
	/// Returns the pointer incremented with the given value
	inline inc(pointer ptr, int val) = pointer(emit(pointer(ptr), int(val), add.i64));
}
/// Utility functions manipulating binary representations
static struct Bits {
	/// convert unsigned to signed integer
	inline signed(uint8 value) = int8(value);

	/// convert unsigned to signed integer
	inline signed(uint16 value) = int16(value);

	/// convert unsigned to signed integer
	inline signed(uint32 value) = int32(value);

	/// convert unsigned to signed integer
	inline signed(uint64 value) = int64(value);

	/// convert signed to unsigned integer
	inline unsigned(int8 value) = uint8(value);

	/// convert signed to unsigned integer
	inline unsigned(int16 value) = uint16(value);

	/// convert signed to unsigned integer
	inline unsigned(int32 value) = uint32(value);

	/// convert signed to unsigned integer
	inline unsigned(int64 value) = uint64(value);

	/// return the 32 bit floating point value as an integer
	inline fromFloat32(float32 value) = uint32(emit(float32(value)));
	/// return the 64 bit floating point value as an integer
	inline fromFloat64(float64 value) = uint64(emit(float64(value)));

	/// return the 32 bit integer as a floating point value
	inline asFloat32(uint32 value) = float32(emit(uint32(value)));
	/// return the 64 bit integer as a floating point value
	inline asFloat64(uint64 value) = float64(emit(uint64(value)));
	/// return the two 32 bit integers merged as a floating point value
	inline asFloat64(uint32 hi, uint32 lo) = float64(emit(uint64(uint64(hi) << 32 | lo)));

	///@public
	int32 zxt32(int32 value, int32 offs, int32 count) {
		static if (preferNativeCalls && typename(uint32.zxt) != null) {
			// use the native method if available
			return uint32.zxt(value, offs, count);
		}

		return uint32(value << (32 - (offs + count))) >> (32 - count);
	}

	///@public
	int32 sxt32(int32 value, int32 offs, int32 count) {
		static if (preferNativeCalls && typename(uint32.sxt) != null) {
			// use the native method if available
			return uint32.sxt(value, offs, count);
		}

		return int32(value << (32 - (offs + count))) >> (32 - count);
	}

	///@public
	int64 zxt64(int64 value, int32 offs, int32 count) {
		static if (preferNativeCalls && typename(uint64.zxt) != null) {
			// use the native method if available
			return uint64.zxt(value, offs, count);
		}

		return uint64(value << (64 - (offs + count))) >> (64 - count);
	}

	///@public
	int64 sxt64(int64 value, int32 offs, int32 count) {
		static if (preferNativeCalls && typename(uint64.sxt) != null) {
			// use the native method if available
			return uint64.sxt(value, offs, count);
		}

		return int64(value << (64 - (offs + count))) >> (64 - count);
	}

	/// convert a 64 bit value between Little endian and Big endian
	uint64 swapBytes(uint64 x) {
		x = (x & 0x00000000ffffffff) << 32 | (x & 0xffffffff00000000) >> 32;
		x = (x & 0x0000ffff0000ffff) << 16 | (x & 0xffff0000ffff0000) >> 16;
		x = (x & 0x00ff00ff00ff00ff) << 8  | (x & 0xff00ff00ff00ff00) >> 8;
		return x;
	}

	/// convert a 32 bit value between Little endian and Big endian
	uint32 swapBytes(uint32 x) {
		x = (x & 0x0000ffff) << 16 | (x & 0xffff0000) >> 16;
		x = (x & 0x00ff00ff) << 8  | (x & 0xff00ff00) >> 8;
		return x;
	}

	/// convert a 16 bit value between Little endian and Big endian
	uint16 swapBytes(uint16 x) {
		return (x & 0x00ff) << 8 | (x & 0xff00) >> 8;
	}

	/// convert a 64 bit value between Little endian and Big endian
	inline swapBytes(int64 x) = int64(swapBytes(uint64(x)));

	/// convert a 32 bit value between Little endian and Big endian
	inline swapBytes(int32 x) = int32(swapBytes(uint32(x)));

	/// convert a 16 bit value between Little endian and Big endian
	inline swapBytes(int16 x) = int16(swapBytes(uint16(x)));


	/// find the index of the most significant(highest) bit
	int scanReverse(uint64 x) {
		static if (preferNativeCalls && typename(uint64.bsr) != null) {
			// use the native method if available
			return uint64.bsr(x);
		}
		if (x == 0) {
			return -1;
		}

		int result = 0;
		if (x & 0xffffffff00000000) {
			result += 32;
			x >>= 32;
		}
		if (x & 0xffff0000) {
			result += 16;
			x >>= 16;
		}
		if (x & 0xff00) {
			result += 8;
			x >>= 8;
		}
		if (x & 0xf0) {
			result += 4;
			x >>= 4;
		}
		if (x & 0xc) {
			result += 2;
			x >>= 2;
		}
		if (x & 0x2) {
			result += 1;
		}
		return result;
	}

	/// find the index of the most significant(highest) bit
	inline scanReverse(int64 x) = scanReverse(uint64(x));

	/// find the index of the most significant(highest) bit
	int scanReverse(uint32 x) {
		static if (preferNativeCalls && typename(uint32.bsr) != null) {
			// use the native method if available
			return uint32.bsr(x);
		}
		if (x == 0) {
			return -1;
		}

		int result = 0;
		if (x & 0xffff0000) {
			result += 16;
			x >>= 16;
		}
		if (x & 0xff00) {
			result += 8;
			x >>= 8;
		}
		if (x & 0xf0) {
			result += 4;
			x >>= 4;
		}
		if (x & 0xc) {
			result += 2;
			x >>= 2;
		}
		if (x & 0x2) {
			result += 1;
		}
		return result;
	}

	/// find the index of the most significant(highest) bit
	inline scanReverse(int32 x) = scanReverse(uint32(x));

	/// find the index of the most significant(highest) bit
	int scanReverse(uint16 x) {
		if (x == 0) {
			return -1;
		}

		int result = 0;
		if (x & 0xff00) {
			result += 8;
			x >>= 8;
		}
		if (x & 0xf0) {
			result += 4;
			x >>= 4;
		}
		if (x & 0xc) {
			result += 2;
			x >>= 2;
		}
		if (x & 0x2) {
			result += 1;
		}
		return result;
	}

	/// find the index of the most significant(highest) bit
	inline scanReverse(int16 x) = scanReverse(uint16(x));

	/// find the index of the most significant(highest) bit
	int scanReverse(uint8 x) {
		if (x == 0) {
			return -1;
		}

		int result = 0;
		if (x & 0xf0) {
			result += 4;
			x >>= 4;
		}
		if (x & 0xc) {
			result += 2;
			x >>= 2;
		}
		if (x & 0x2) {
			result += 1;
		}
		return result;
	}

	/// find the index of the most significant(highest) bit
	inline scanReverse(int8 x) = scanReverse(uint8(x));


	/// find the index of the least significant(lowest) bit
	int scanForward(uint64 x) {
		static if (preferNativeCalls && typename(uint64.bsf) != null) {
			// use the native method if available
			return uint64.bsf(x);
		}

		if (x == 0) {
			return -1;
		}

		int result = 0;
		if ((x & 0xffffffff) == 0) {
			result += 32;
			x >>= 32;
		}
		if ((x & 0xffff) == 0) {
			result += 16;
			x >>= 16;
		}
		if ((x & 0xff) == 0) {
			result += 8;
			x >>= 8;
		}
		if ((x & 0xf) == 0) {
			result += 4;
			x >>= 4;
		}
		if ((x & 0x3) == 0) {
			result += 2;
			x >>= 2;
		}
		if ((x & 0x1) == 0) {
			result += 1;
		}
		return result;
	}

	/// find the index of the least significant(lowest) bit
	inline scanForward(int64 x) = scanForward(uint64(x));

	/// find the index of the least significant(lowest) bit
	int scanForward(uint32 x) {
		static if (preferNativeCalls && typename(uint32.bsf) != null) {
			// use the native method if available
			return uint32.bsf(x);
		}

		if (x == 0) {
			return -1;
		}

		int result = 0;
		if ((x & 0xffff) == 0) {
			result += 16;
			x >>= 16;
		}
		if ((x & 0xff) == 0) {
			result += 8;
			x >>= 8;
		}
		if ((x & 0xf) == 0) {
			result += 4;
			x >>= 4;
		}
		if ((x & 0x3) == 0) {
			result += 2;
			x >>= 2;
		}
		if ((x & 0x1) == 0) {
			result += 1;
		}
		return result;
	}

	/// find the index of the least significant(lowest) bit
	inline scanForward(int32 x) = scanForward(uint32(x));

	/// find the index of the least significant(lowest) bit
	int scanForward(uint16 x) {
		if (x == 0) {
			return -1;
		}

		int result = 0;
		if ((x & 0xff) == 0) {
			result += 8;
			x >>= 8;
		}
		if ((x & 0xf) == 0) {
			result += 4;
			x >>= 4;
		}
		if ((x & 0x3) == 0) {
			result += 2;
			x >>= 2;
		}
		if ((x & 0x1) == 0) {
			result += 1;
		}
		return result;
	}

	/// find the index of the least significant(lowest) bit
	inline scanForward(int16 x) = scanForward(uint16(x));

	/// find the index of the least significant(lowest) bit
	int scanForward(uint8 x) {
		if (x == 0) {
			return -1;
		}

		int result = 0;
		if ((x & 0xf) == 0) {
			result += 4;
			x >>= 4;
		}
		if ((x & 0x3) == 0) {
			result += 2;
			x >>= 2;
		}
		if ((x & 0x1) == 0) {
			result += 1;
		}
		return result;
	}

	/// find the index of the least significant(lowest) bit
	inline scanForward(int8 x) = scanForward(uint8(x));


	/// keep the highest bit set
	uint64 keepMsb(uint64 x) {
		static if (preferNativeCalls && typename(uint64.hib) != null) {
			// use the native method if available
			return uint64.hib(x);
		}

		x |= x >> 1;
		x |= x >> 2;
		x |= x >> 4;
		x |= x >> 8;
		x |= x >> 16;
		x |= x >> 32;
		return x - (x >> 1);
	}

	/// keep the highest bit set
	inline keepMsb(int64 x) = keepMsb(uint64(x));

	/// keep the highest bit set
	uint32 keepMsb(uint32 x) {
		static if (preferNativeCalls && typename(uint32.hib) != null) {
			// use the native method if available
			return uint32.hib(x);
		}

		x |= x >> 1;
		x |= x >> 2;
		x |= x >> 4;
		x |= x >> 8;
		x |= x >> 16;
		return x - (x >> 1);
	}

	/// keep the highest bit set
	inline keepMsb(int32 x) = keepMsb(uint32(x));


	/// keep the lowest bit set
	inline keepLsb(uint64 x) = uint64(x & -x);

	/// keep the lowest bit set
	inline keepLsb(int64 x) = keepLsb(uint64(x));

	/// keep the lowest bit set
	inline keepLsb(uint32 x) = uint32(x & -x);

	/// keep the lowest bit set
	inline keepLsb(int32 x) = keepLsb(uint32(x));

	/// keep the lowest bit set
	inline keepLsb(uint16 x) = uint16(x & -x);

	/// keep the lowest bit set
	inline keepLsb(int16 x) = keepLsb(uint16(x));

	/// keep the lowest bit set
	inline keepLsb(uint8 x) = uint8(x & -x);

	/// keep the lowest bit set
	inline keepLsb(int8 x) = keepLsb(uint8(x));


	/// count bits set to one
	int countOnes(uint64 x) {
		static if (preferNativeCalls && typename(uint64.pop) != null) {
			// use the native method if available
			return uint64.pop(x);
		}

		x -= (x >> 1) & 0x5555555555555555;
		x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
		x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f;
		x += x >> 8;
		x += x >> 16;
		x += x >> 32;
		return x & 0x3f;
	}

	/// count bits set to one
	inline countOnes(int64 x) = countOnes(uint64(x));

	/// count bits set to one
	int countOnes(uint32 x) {
		static if (preferNativeCalls && typename(uint32.pop) != null) {
			// use the native method if available
			return uint32.pop(x);
		}

		x -= (x >> 1) & 0x55555555;
		x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
		x = (x + (x >> 4)) & 0x0f0f0f0f;
		x += x >> 8;
		x += x >> 16;
		return x & 0x3f;
	}

	/// count bits set to one
	inline countOnes(int32 x) = countOnes(uint32(x));


	/// reverse all the bits
	uint64 swapBits(uint64 x) {
		static if (preferNativeCalls && typename(uint64.swap) != null) {
			// use the native method if available
			return uint64.swap(x);
		}

		x = ((x >> 1) & 0x5555555555555555) | ((x & 0x5555555555555555) << 1);
		x = ((x >> 2) & 0x3333333333333333) | ((x & 0x3333333333333333) << 2);
		x = ((x >> 4) & 0x0f0f0f0f0f0f0f0f) | ((x & 0x0f0f0f0f0f0f0f0f) << 4);
		x = ((x >> 8) & 0x00ff00ff00ff00ff) | ((x & 0x00ff00ff00ff00ff) << 8);
		x = ((x >> 16) & 0x0000ffff0000ffff) | ((x & 0x0000ffff0000ffff) << 16);
		return (x >> 32) | (x << 32);
	}

	/// reverse all the bits
	inline swapBits(int64 x) = swapBits(uint64(x));

	/// reverse all the bits
	uint32 swapBits(uint32 x) {
		static if (preferNativeCalls && typename(uint32.swap) != null) {
			// use the native method if available
			return uint32.swap(x);
		}

		x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
		x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
		x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);
		x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);
		return (x >> 16) | (x << 16);
	}

	/// reverse all the bits
	inline swapBits(int32 x) = swapBits(uint32(x));

	/// reverse all the bits
	uint16 swapBits(uint16 x) {
		x = ((x >> 1) & 0x5555) | ((x & 0x5555) << 1);
		x = ((x >> 2) & 0x3333) | ((x & 0x3333) << 2);
		x = ((x >> 4) & 0x0f0f) | ((x & 0x0f0f) << 4);
		return (x >> 8) | (x << 8);
	}

	/// reverse all the bits
	inline swapBits(int16 x) = swapBits(uint16(x));

	/// reverse all the bits
	uint8 swapBits(uint8 x) {
		x = ((x >> 1) & 0x55) | ((x & 0x55) << 1);
		x = ((x >> 2) & 0x33) | ((x & 0x33) << 2);
		return (x >> 4) | (x << 4);
	}

	/// reverse all the bits
	inline swapBits(int8 x) = swapBits(uint8(x));

	/// branch-less clamp
	// adapted from: androidx.constraintlayout.widget.ConstraintAttribute#clamp
	int32 clamp(int32 value, int32 max) {
		value &= ~(value >> 31);
		value -= max;
		value &= (value >> 31);
		value += max;
		return value;
	}

	/// branch-less clamp
	int32 clamp(int32 value, int32 min, int32 max) {
		return clamp(value - min, max - min) + min;
	}
}
/// Complex number
struct Complex {

	/// The real component of a complex number.
	const float64 re;

	/// The imaginary component of a complex number.
	const float64 im = 0;
}

/// Create a Complex number from the given `value`
Complex Complex(float64 value) {
	return {
		re: value;
	};
}

/// Create a Complex number from the given `real` and `imaginary` values
Complex Complex(float64 real, float64 imaginary) {
	return {
		re: real;
		im: imaginary;
	};
}

/// Unary negation of a complex number: -a := Complex(-a.re, -a.im);
inline neg(Complex a) = Complex(emit(struct(a), neg.p2d));

/// Add two complex numbers: a + b := Complex(a.re + b.re, a.im + b.im);
inline add(Complex a, Complex b) = Complex(emit(struct(a), struct(b), add.p2d));
/// Add a complex number `a` to a real number `b`
inline add(Complex a, float64 b) = Complex(a.re + b, a.im);
/// Add a complex number `b` to a real number `a`
inline add(float64 a, Complex b) = Complex(a + b.re, b.im);

/// Subtract two complex numbers: a - b := Complex(a.re - b.re, a.im - b.im);
inline sub(Complex a, Complex b) = Complex(emit(struct(a), struct(b), sub.p2d));
/// Subtract the real number `b` from the complex number `a`
inline sub(Complex a, float64 b) = Complex(a.re - b, a.im);
/// Subtract the complex number `b` from the real number `a`
inline sub(float64 a, Complex b) = Complex(a - b.re, b.im);

/// Multiply two complex numbers: a * b := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
inline mul(Complex a, Complex b) = Complex(emit(
	struct(a), struct(b), swz.x2, mul.p2d, add.f64,
	struct(a), struct(b), mul.p2d, swz.x2, sub.f64
));
/// Multiply a complex number `a` with a real number `b`
inline mul(Complex a, float64 b) = Complex(a.re * b, a.im * b);
/// Multiply a complex number `b` with a real number `a`
inline mul(float64 a, Complex b) = Complex(a * b.re, a * b.im);

/// Divide two complex numbers
Complex div(Complex a, Complex b) {
	// Adapted from Numerical Recipes in C - The Art of Scientific Computing
	// ISBN 0-521-43108-5

	if (Math.abs(b.re) >= Math.abs(b.im)) {
		float64 r = b.im / b.re;
		float64 den = b.re + r * b.im;
		return {
			re: (a.re + r * a.im) / den;
			im: (a.im - r * a.re) / den;
		};
	}
	float64 r = b.re / b.im;
	float64 den = b.im + r * b.re;
	return {
		re: (a.re * r + a.im) / den;
		im: (a.im * r - a.re) / den;
	};
}
/// Divide the complex number `a` by the real number `b`
inline div(Complex a, float64 b) = div(a, Complex(b));
/// Divide the real number `a` by the complex number `b`
inline div(float64 a, Complex b) = div(Complex(a), b);

/// Compute the absolute value of the complex number `a`
inline abs(Complex a) = Math.sqrt(a.re * a.re + a.im * a.im);
/// Compute the argument of the complex number `a`
inline arg(Complex a) = Math.atan2(a.re, a.im);

/// Compute the reciprocal of a complex number (1 / a)
Complex inv(Complex a) {
	float64 d = a.re * a.re + a.im * a.im;
	return {
		re: +a.re / d;
		im: -a.im / d;
	};
}

/// Compute the conjugate of the complex number `a`
inline conj(Complex a) = Complex(a.re, -a.im);

/// Compute the exponential of a complex number: $ e^a $.
inline exp(Complex a) = Complex(Math.exp(a.re) * Math.cos(a.im), Math.exp(a.re) * Math.sin(a.im));

/// Compute the natural logarithm of the complex number `a`.
inline log(Complex a) = Complex(Math.log(abs(a)), arg(a));

/// Compute the complex number `a` raised to the power of `b`: $ a^b $.
Complex pow(Complex a, Complex b) {
	float64 r = abs(a);
	float64 t = arg(a);
	float64 u = b.re * t + b.im * Math.log(r);
	float64 v = Math.pow(r, b.re) * Math.exp(-b.im * t);
	return {
		re: v * Math.cos(u);
		im: v * Math.sin(u);
	};
}
/// Compute the complex number `a` raised to the power of `b`: $ a^b $.
inline pow(Complex a, float64 b) = pow(a, Complex(b));

/// Compute the sine of the complex number `a`.
inline sin(Complex a) = Complex(Math.sin(a.re) * Math.cosh(a.im), +Math.cos(a.re) * Math.sinh(a.im));
/// Compute the cosine of the complex number `a`.
inline cos(Complex a) = Complex(Math.cos(a.re) * Math.cosh(a.im), -Math.sin(a.re) * Math.sinh(a.im));
/// Compute the tangent of the complex number `a`.
inline tan(Complex a) = div(sin(a), cos(a));
/// Compute the cotangent of the complex number `a`.
inline cot(Complex a) = div(cos(a), sin(a));
/// Compute the secant of the complex number `a`.
inline sec(Complex a) = inv(cos(a));
/// Compute the cosecant of the complex number `a`.
inline csc(Complex a) = inv(sin(a));

/// Compute the hyperbolic sine of the complex number `a`.
inline sinh(Complex a) = div(sub(exp(a), exp(neg(a))), 2);
/// Compute the hyperbolic cosine of the complex number `a`.
inline cosh(Complex a) = div(add(exp(a), exp(neg(a))), 2);
/// Compute the hyperbolic tangent of the complex number `a`.
inline tanh(Complex a) = div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
/// Compute the hyperbolic cotangent of the complex number `a`.
inline coth(Complex a) = div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));
/// Compute the hyperbolic secant of the complex number `a`.
inline sech(Complex a) = inv(cosh(a));
/// Compute the hyperbolic cosecant of the complex number `a`.
inline csch(Complex a) = inv(sinh(a));

/// Convert the from polar(r,) to cartesian(x,y) coordinates
inline toCartesian(Complex x) = Complex(x.re * Math.cos(x.im), x.re * Math.sin(x.im));
/// Convert the from cartesian(x,y) to polar(r,) coordinates
inline toPolar(Complex x) = Complex(abs(x), arg(x));


/* TODO: implement enumerations, then:
enum: Complex {
	zero: { re: 0 };	// 0 + 0i
	unit: { re: 1 };	// 1 + 0i
}


// TODO: implement inline initializer, then:
// constructing a complex number
inline Complex(float64 re) = { re: re };
inline Complex(float64 re, float64 im) = { re: re, im: im };


// TODO: implement operator overloading, then:
inline -(Complex a) = Complex(-a.re, -a.im);

inline +(Complex a, Complex b) = Complex(a.re + b.re, a.im + b.im);
inline +(Complex a, float64 b) = Complex(a.re + b, a.im);
inline +(float64 a, Complex b) = Complex(a + b.re, b.im);

inline -(Complex a, Complex b) = Complex(a.re - b.re, a.im - b.im);
inline -(Complex a, float64 b) = Complex(a.re - b, a.im);
inline -(float64 a, Complex b) = Complex(a - b.re, b.im);

inline *(Complex a, Complex b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
inline *(Complex a, float64 b) = Complex(a.re * b, a.im * b);
inline *(float64 a, Complex b) = Complex(a * b.re, a * b.im);

inline /(Complex a, Complex b) = div(a, b);
inline /(Complex a, float64 b) = div(a, Complex(b));
inline /(float64 a, Complex b) = div(Complex(a), b);


// TODO: implement operator overloading, then:
inline tan(Complex a) = sin(a) / cos(a);
inline cot(Complex a) = cos(a) / sin(a);

inline sinh(Complex a) = (exp(a) - exp(-a)) / 2;
inline cosh(Complex a) = (exp(a) + exp(-a)) / 2;
inline tanh(Complex a) = (exp(2 * a) - 1) / (exp(2 * a) + 1);
inline coth(Complex a) = (exp(2 * a) + 1) / (exp(2 * a) - 1);
*/
/// Easing functions maps an input of [0, 1) usually to [0, 1) with an acceleration
// see: https://easings.net
// todo: enum Easing: double(double t) { ... }
static struct Easing {
	///@public
	float64 linear(float64 t) {
		return t;
	}

	///@public
	float64 quad(float64 t) {
		return t * t;
	}

	///@public
	float64 cubic(float64 t) {
		return t * t * t;
	}

	///@public
	float64 quart(float64 t) {
		return t * t * t * t;
	}

	///@public
	float64 quint(float64 t) {
		return t * t * t * t * t;
	}

	///@public
	float64 expo(float64 t) {
		return t == 0 ? 0 : Math.pow(2., 10 * (t - 1));
	}

	///@public
	float64 sine(float64 t) {
		return -Math.cos(t * Math.pi / 2) + 1;
	}

	///@public
	float64 circle(float64 t) {
		return -(Math.sqrt(1 - t * t) - 1);
	}

	///@public
	float64 elastic(float64 t) {
		if (t == 0.0 || t == 1.0) return t;
		t = t - 1.0;
		return - Math.pow(2.0, 10.0 * t) * Math.sin((t - 0.3 / 4.0) * (2.0 * Math.pi) / 0.3) ;
	}

	///@public
	float64 back(float64 t) {
		inline s = 1.70158;
		return t * t * ((s + 1) * t - s);
	}

	///@public
	float64 bounce(float64 t) {
		static float64 Helper(float64 t, float64 c, float64 a) {
			if (t == 1) {
				return c;
			}
			if (t < (4 / 11.)) {
				return c * (7.5625 * t * t);
			}
			if (t < (8 / 11.)) {
				t -= (6 / 11.);
				return -a * (1 - (7.5625 * t * t + 0.75)) + c;
			}
			if (t < (10 / 11.)) {
				t -= (9 / 11.0f);
				return -a * (1 - (7.5625 * t * t + 0.9375)) + c;
			}
			t -= (21 / 22.);
			return -a * (1 - (7.5625 * t * t + 0.984375)) + c;
		}
		inline a = 1.70158;
		return 1 - Helper(1 - t, 1, a);
	}
}

/// ease in, ex: Easing.elastic.in(t)
float64 in(float64 ease(float64 ratio), float64 ratio) {
	if (ease == null) {
		return ratio;
	}
	return ease(ratio);
}

/// ease out, ex: Easing.elastic.out(t)
float64 out(float64 ease(float64 ratio), float64 ratio) {
	if (ease == null) {
		return ratio;
	}
	return 1. - ease(1 - ratio);
}

/// ease in and out, ex: Easing.elastic.inOut(t)
float64 inOut(float64 ease(float64 ratio), float64 ratio) {
	if (ease == null) {
		return ratio;
	}
	ratio *= 2;
	return (ratio < 1) ? .5 * ease(ratio) : .5 * ease.out(ratio - 1) + .5;
}

/// ease out and in, ex: Easing.elastic.outIn(t)
float64 outIn(float64 ease(float64 ratio), float64 ratio) {
	if (ease == null) {
		return ratio;
	}
	ratio *= 2;
	return (ratio < 1) ? .5 * ease.out(ratio) : .5 * ease(ratio - 1) + .5;
}
/// simple fixed point, `precision` bits used for decimal part, the rest for integer part
struct Fixed {
	int32 value = 0;

	enum: int32 {
		precision: 20; // todo: precision should be class parameter and/or declared as inline

		one: 1 << precision;
		nan: 0x80000000;
		inf: 0x7fffffff;
		half: one / 2;
		mask: one - 1;
		pow2max: (31 - precision) << precision;     // maximum positive value computable by pow2

		mpi_28: 0x3243f6a8;							// 3.141592653589793 : pi
		ln2_28: 0x0b17217f;							// .6931471805599453 : natural logarithm (2)
		lg2_28: 0x04d104d4;							// .3010299956639812 : decimal logarithm (2)
		l2e_28: 0x17154765;							// 1.442695040888963 : logarithm base 2  (e)
		l2t_28: 0x35269e12;							// 3.321928094887362 : logarithm base 2 (10)
		d2r_28: 0x00477d1a;							// pi / 180 : degrees to radians
		r2d_24: 0x394bb834;							// 180 / pi : radians to degrees

		piMul2: mpi_28 >> (28 - precision - 1);		// 2 * pi
		piDiv2: mpi_28 >> (28 - precision + 1);		// pi / 2

		pi: mpi_28 >> (28 - precision);				// 3.141592653589793 : pi
		ln2: ln2_28 >> (28 - precision);			// .6931471805599453 : natural logarithm (2)
		lg2: lg2_28 >> (28 - precision);			// .3010299956639812 : decimal logarithm (2)
		l2e: l2e_28 >> (28 - precision);			// 1.442695040888963 : logarithm base 2  (e)
		l2t: l2t_28 >> (28 - precision);			// 3.321928094887362 : logarithm base 2 (10)
	}

	static if (precision > 26) { precision_must_be_at_most_26_bits }

	static Fixed as(int32 value) { return {value: value}; }

	/// Computes the negated value of the given number.
	static Fixed neg(Fixed a) { return {value: -a.value}; }

	/// Adds the two fixed point numbers.
	static Fixed add(Fixed a, Fixed b) { return {value: a.value + b.value}; }

	/// Subtract one from another fixed point number.
	static Fixed sub(Fixed a, Fixed b) { return {value: a.value - b.value}; }

	/// Multiply two fixed-point numbers.
	static Fixed mul(Fixed a, Fixed b) { return {value: (int64(a.value) * b.value) >> precision}; }
	static Fixed mul(Fixed a, int32 b) { return {value: a.value * b}; }
	static Fixed mul_28(Fixed a, int32 b) { return {value: int64(a.value) * b >> 28}; }

	/// Divide one fixed-point number with another one.
	static Fixed div(Fixed a, Fixed b) {
		if (b.value == 0) {
			if (a.value == 0) {
				return as(nan);
			}
			return as(a.value < 0 ? -inf : inf);
		}
		return {value: (int64(a.value) << precision) / b.value};
	}
	static Fixed div(Fixed a, int32 b) { return {value: a.value / b}; }

	/// Returns the remainder of the division of `a` by `b`.
	static Fixed mod(Fixed a, Fixed b) { return {value: a.value % b.value}; }

	/// Compute the reciprocal of a complex number (1 / a)
	static Fixed inv(Fixed x) {
		if (x.value == 0) {
			return {value: inf};
		}
		int64 value = (int64(one) << precision) / x.value;
		if (value >> 31 != value >> 63) {
			return {value: value < 0 ? -inf : inf};
		}
		return {value: value};
	}


	/// Returns the fractional part of the fixed point number
	static Fixed fract(Fixed x) {
		if (x.value < 0) {
			return {value: -(-x.value & mask)};
		}
		return {value: x.value & (nan|mask)};
	}

	/// Computes the largest integer that is less than or equal to `x`.
	static Fixed floor(Fixed x) {
		return {value: x.value & ~mask};
	}

	/// Computes the smallest integer that is greater than or equal to `x`.
	static Fixed ceil(Fixed x) {
		return neg(floor(neg(x)));
	}

	/// Computes the nearest integer to `x`.
	static Fixed round(Fixed x) {
		return floor(as(x.value + half));
	}

	/// Determines whether the given fixed point value is finite: `!isNan(x) && !isInf(x)`
	static bool isFinite(Fixed x) {
		if (x.value == nan) {
			return false;
		}
		if (x.value == inf) {
			return false;
		}
		if (x.value == -inf) {
			return false;
		}
		return true;
	}

	static bool isNan(Fixed x) {
		return x.value == nan;
	}

	/// Determines whether the given fixed point is less than the other one.
	static int compare(Fixed a, Fixed b) {
		return int(a.value < b.value) - int(a.value > b.value);
	}


	/**	Returns the binary logarithm of the argument `x`.
	 * 	log2(x) = log2((2 ** n) * ((x / 2) ** n)) =
	 * 	= log2(2 ** n) + log2((x / 2) ** n) = n + log2(q)
	 * 	n = most significant bit of x (BSR (bit scan reverse))
	 * 	q = (x / 2) ** n = (x > 1) ? (x >> n) : (x << -n)
	 * 	x > 1 <=> n - precision > 0
	 * 	log2(q) = look up from table
	**/
	static Fixed log2(Fixed x) {
		static const uint32 tbl_log2[257] = {
			// log2(x + 1), x : [0, 1), x = float64.log2(index / 256. + 1) << 30
			0x00000000, 0x005c2711, 0x00b7f285, 0x01136311, 0x016e7968, 0x01c9363b, 0x02239a3a, 0x027da612,
			0x02d75a6e, 0x0330b7f8, 0x0389bf57, 0x03e27130, 0x043ace27, 0x0492d6df, 0x04ea8bf7, 0x0541ee0d,
			0x0598fdbe, 0x05efbba5, 0x0646285b, 0x069c4477, 0x06f21090, 0x07478d38, 0x079cbb04, 0x07f19a83,
			0x08462c46, 0x089a70da, 0x08ee68cb, 0x094214a5, 0x099574f1, 0x09e88a36, 0x0a3b54fc, 0x0a8dd5c8,
			0x0ae00d1c, 0x0b31fb7d, 0x0b83a16a, 0x0bd4ff63, 0x0c2615e8, 0x0c76e574, 0x0cc76e83, 0x0d17b191,
			0x0d67af16, 0x0db7678b, 0x0e06db66, 0x0e560b1e, 0x0ea4f726, 0x0ef39ff1, 0x0f4205f3, 0x0f90299c,
			0x0fde0b5c, 0x102baba2, 0x10790adb, 0x10c62975, 0x111307da, 0x115fa676, 0x11ac05b2, 0x11f825f6,
			0x124407ab, 0x128fab35, 0x12db10fc, 0x13263963, 0x137124ce, 0x13bbd3a0, 0x1406463b, 0x14507cfe,
			0x149a784b, 0x14e43880, 0x152dbdfc, 0x1577091b, 0x15c01a39, 0x1608f1b4, 0x16518fe4, 0x1699f524,
			0x16e221cd, 0x172a1637, 0x1771d2ba, 0x17b957ac, 0x1800a563, 0x1847bc33, 0x188e9c72, 0x18d54673,
			0x191bba89, 0x1961f905, 0x19a80239, 0x19edd675, 0x1a33760a, 0x1a78e146, 0x1abe1879, 0x1b031bef,
			0x1b47ebf7, 0x1b8c88db, 0x1bd0f2e9, 0x1c152a6c, 0x1c592fad, 0x1c9d02f6, 0x1ce0a492, 0x1d2414c8,
			0x1d6753e0, 0x1daa6222, 0x1ded3fd4, 0x1e2fed3d, 0x1e726aa1, 0x1eb4b847, 0x1ef6d673, 0x1f38c567,
			0x1f7a8568, 0x1fbc16b9, 0x1ffd799a, 0x203eae4e, 0x207fb517, 0x20c08e33, 0x210139e4, 0x2141b869,
			0x21820a01, 0x21c22eea, 0x22022762, 0x2241f3a7, 0x228193f5, 0x22c10889, 0x2300519e, 0x233f6f71,
			0x237e623d, 0x23bd2a3b, 0x23fbc7a6, 0x243a3ab7, 0x247883a8, 0x24b6a2b1, 0x24f4980b, 0x253263ec,
			0x2570068e, 0x25ad8026, 0x25ead0eb, 0x2627f914, 0x2664f8d5, 0x26a1d064, 0x26de7ff6, 0x271b07c0,
			0x275767f5, 0x2793a0c9, 0x27cfb26f, 0x280b9d1a, 0x284760fd, 0x2882fe49, 0x28be7531, 0x28f9c5e5,
			0x2934f097, 0x296ff577, 0x29aad4b6, 0x29e58e83, 0x2a20230e, 0x2a5a9285, 0x2a94dd19, 0x2acf02f7,
			0x2b09044d, 0x2b42e149, 0x2b7c9a19, 0x2bb62eea, 0x2bef9fe8, 0x2c28ed40, 0x2c62171e, 0x2c9b1dae,
			0x2cd4011c, 0x2d0cc192, 0x2d455f3c, 0x2d7dda44, 0x2db632d4, 0x2dee6917, 0x2e267d36, 0x2e5e6f5a,
			0x2e963fac, 0x2ecdee56, 0x2f057b7f, 0x2f3ce751, 0x2f7431f2, 0x2fab5b8b, 0x2fe26443, 0x30194c40,
			0x305013ab, 0x3086baa9, 0x30bd4161, 0x30f3a7f8, 0x3129ee96, 0x3160155e, 0x31961c76, 0x31cc0404,
			0x3201cc2c, 0x32377512, 0x326cfedb, 0x32a269ab, 0x32d7b5a5, 0x330ce2ed, 0x3341f1a7, 0x3376e1f5,
			0x33abb3fa, 0x33e067d9, 0x3414fdb4, 0x344975ad, 0x347dcfe7, 0x34b20c82, 0x34e62ba0, 0x351a2d62,
			0x354e11eb, 0x3581d959, 0x35b583ce, 0x35e9116a, 0x361c824d, 0x364fd697, 0x36830e69, 0x36b629e1,
			0x36e9291e, 0x371c0c41, 0x374ed367, 0x37817eaf, 0x37b40e39, 0x37e68222, 0x3818da88, 0x384b178a,
			0x387d3945, 0x38af3fd7, 0x38e12b5d, 0x3912fbf4, 0x3944b1b9, 0x39764cc9, 0x39a7cd41, 0x39d9333d,
			0x3a0a7eda, 0x3a3bb033, 0x3a6cc764, 0x3a9dc48a, 0x3acea7c0, 0x3aff7121, 0x3b3020c8, 0x3b60b6d1,
			0x3b913356, 0x3bc19672, 0x3bf1e041, 0x3c2210db, 0x3c52285c, 0x3c8226dd, 0x3cb20c79, 0x3ce1d948,
			0x3d118d66, 0x3d4128eb, 0x3d70abf1, 0x3da01691, 0x3dcf68e3, 0x3dfea301, 0x3e2dc503, 0x3e5ccf02,
			0x3e8bc117, 0x3eba9b59, 0x3ee95de1, 0x3f1808c7, 0x3f469c22, 0x3f75180b, 0x3fa37c98, 0x3fd1c9e2,
			0x40000000
		};
		// Special cases:
		//  * todo: log2(Inf) = +Inf
		//  * log2(0) = -Inf
		//  * log2(x<0) = NaN
		//  * log2(NaN) = NaN
		if (x.value <= 0) {
			if (x.value == 0) {
				return {value: -inf};
			}
			return {value: nan};
		}

		int32 n = Bits.scanReverse(x.value);
		static if (precision < 8) {/* todo: */ error_not_implemented_yet;}
		uint32 idx = (n > 8 ? x.value >> n - 8 : x.value << 8 - n) & 0xff;
		int32 value = tbl_log2[idx];
		static if (precision > 8) {
			uint32 mix = (n > 16
				? x.value >> n - 16
				: x.value << 16 - n
			) & 0xff;
			value += mix * (tbl_log2[idx + 1] - value) >> 8;
		}
		return {value: (n - precision << precision) + (value >> 30 - precision)};
	}

	/// Returns the natural logarithm of the argument `x`.
	static Fixed log(Fixed x) {
		// Special cases todo:
		//  * log(+Inf) = +Inf
		//  * log(0) = -Inf
		//  * log(x<0) = NaN
		//  * log(NaN) = NaN

		// ln(x) = log2(x) / log2(e) = log2(x) * ln(2);
		x = log2(x);
		if (!isFinite(x)) {
			return x;
		}
		// todo: more precision with division
		return mul_28(x, ln2_28);
	}

	/// Returns the decimal logarithm of the argument `x`.
	static Fixed log10(Fixed x) {
		// Special cases todo:
		//  * log10(+Inf) = +Inf
		//  * log10(0) = -Inf
		//  * log10(x<0) = NaN
		//  * log10(NaN) = NaN

		// log10(x) = log2(x) / log2(10) = log2(x) * log10(2);
		x = log2(x);
		if (!isFinite(x)) {
			return x;
		}
		return mul_28(x, lg2_28);
	}

	/// Returns the logarithm of the argument `x`.
	static Fixed log(Fixed x, Fixed base) {
		// log(x, base) := log2(x) / log2(base);
		x = log2(x);
		if (!isFinite(x)) {
			return x;
		}
		base = log2(base);
		if (!isFinite(base)) {
			return base;
		}
		return div(x, base);
	}


	/**	pow2(x) <=> 2 ** x
	 *	pow2(x) = pow2(n + q) = pow2(n) * pow2(q)
	 *	let n = floor(x);
	 *  let q = fract(x);
	 *  pow2(n) = 2 ** n = 1 << n
	 *	pow2(q) = 1 + look up from table
	 *	pow2(x) = (x >= 0) ? (pow2(q) << n) : (pow2(q) >> -n)
	 *	---------------------------------------------------
	**/
	static Fixed pow2(Fixed x) {
		static const uint32 tbl_pow2[257] = {
			// (2 ** x), x : [0, 1), x = (float64.exp2(i / 256.)) << 30
			0x40000000, 0x402c6be9, 0x4058f6a7, 0x4085a050, 0x40b268f9, 0x40df50b8, 0x410c57a1, 0x41397dcb,
			0x4166c34c, 0x41942838, 0x41c1aca7, 0x41ef50ad, 0x421d1461, 0x424af7d9, 0x4278fb2b, 0x42a71e6c,
			0x42d561b3, 0x4303c517, 0x433248ad, 0x4360ec8c, 0x438fb0cb, 0x43be957f, 0x43ed9abf, 0x441cc0a3,
			0x444c0740, 0x447b6ead, 0x44aaf701, 0x44daa053, 0x450a6aba, 0x453a564d, 0x456a6322, 0x459a9151,
			0x45cae0f1, 0x45fb521a, 0x462be4e2, 0x465c9960, 0x468d6fad, 0x46be67e0, 0x46ef8210, 0x4720be54,
			0x47521cc5, 0x47839d7a, 0x47b5408b, 0x47e70610, 0x4818ee21, 0x484af8d5, 0x487d2645, 0x48af7689,
			0x48e1e9b9, 0x49147fee, 0x4947393e, 0x497a15c4, 0x49ad1597, 0x49e038d0, 0x4a137f87, 0x4a46e9d6,
			0x4a7a77d4, 0x4aae299b, 0x4ae1ff43, 0x4b15f8e5, 0x4b4a169b, 0x4b7e587d, 0x4bb2bea4, 0x4be7492a,
			0x4c1bf828, 0x4c50cbb7, 0x4c85c3f1, 0x4cbae0ee, 0x4cf022c9, 0x4d25899b, 0x4d5b157e, 0x4d90c68b,
			0x4dc69cdc, 0x4dfc988c, 0x4e32b9b4, 0x4e69006d, 0x4e9f6cd3, 0x4ed5feff, 0x4f0cb70c, 0x4f439513,
			0x4f7a9930, 0x4fb1c37c, 0x4fe91412, 0x50208b0d, 0x50582887, 0x508fec9c, 0x50c7d765, 0x50ffe8fe,
			0x51382181, 0x5170810a, 0x51a907b4, 0x51e1b59a, 0x521a8ad7, 0x52538786, 0x528cabc3, 0x52c5f7a9,
			0x52ff6b54, 0x533906e0, 0x5372ca67, 0x53acb607, 0x53e6c9da, 0x542105fd, 0x545b6a8b, 0x5495f7a0,
			0x54d0ad5a, 0x550b8bd3, 0x55469329, 0x5581c377, 0x55bd1cda, 0x55f89f6f, 0x56344b52, 0x5670209f,
			0x56ac1f75, 0x56e847ee, 0x57249a29, 0x57611642, 0x579dbc56, 0x57da8c83, 0x581786e5, 0x5854ab9b,
			0x5891fac0, 0x58cf7474, 0x590d18d3, 0x594ae7fa, 0x5988e209, 0x59c7071c, 0x5a055751, 0x5a43d2c6,
			0x5a827999, 0x5ac14be9, 0x5b0049d4, 0x5b3f7377, 0x5b7ec8f1, 0x5bbe4a61, 0x5bfdf7e5, 0x5c3dd19b,
			0x5c7dd7a3, 0x5cbe0a1b, 0x5cfe6922, 0x5d3ef4d7, 0x5d7fad59, 0x5dc092c6, 0x5e01a53f, 0x5e42e4e2,
			0x5e8451cf, 0x5ec5ec25, 0x5f07b404, 0x5f49a98b, 0x5f8bccdb, 0x5fce1e12, 0x60109d50, 0x60534ab7,
			0x60962665, 0x60d9307a, 0x611c6918, 0x615fd05e, 0x61a3666d, 0x61e72b64, 0x622b1f66, 0x626f4291,
			0x62b39508, 0x62f816eb, 0x633cc85a, 0x6381a978, 0x63c6ba64, 0x640bfb40, 0x64516c2e, 0x64970d4e,
			0x64dcdec3, 0x6522e0ad, 0x6569132f, 0x65af7669, 0x65f60a7f, 0x663ccf91, 0x6683c5c3, 0x66caed35,
			0x6712460a, 0x6759d065, 0x67a18c67, 0x67e97a34, 0x683199ed, 0x6879ebb6, 0x68c26fb1, 0x690b2601,
			0x69540ec8, 0x699d2a2b, 0x69e6784c, 0x6a2ff94f, 0x6a79ad55, 0x6ac39484, 0x6b0daeff, 0x6b57fce8,
			0x6ba27e65, 0x6bed3398, 0x6c381ca6, 0x6c8339b2, 0x6cce8ae1, 0x6d1a1056, 0x6d65ca37, 0x6db1b8a7,
			0x6dfddbcb, 0x6e4a33c8, 0x6e96c0c2, 0x6ee382de, 0x6f307a41, 0x6f7da70f, 0x6fcb096f, 0x7018a185,
			0x70666f76, 0x70b47367, 0x7102ad7f, 0x71511de3, 0x719fc4b9, 0x71eea226, 0x723db650, 0x728d015d,
			0x72dc8373, 0x732c3cb9, 0x737c2d55, 0x73cc556d, 0x741cb528, 0x746d4cac, 0x74be1c20, 0x750f23ab,
			0x75606373, 0x75b1dba1, 0x76038c5b, 0x765575c7, 0x76a7980f, 0x76f9f358, 0x774c87cc, 0x779f5590,
			0x77f25ccd, 0x78459dac, 0x78991853, 0x78ecccec, 0x7940bb9e, 0x7994e491, 0x79e947ef, 0x7a3de5df,
			0x7a92be8a, 0x7ae7d219, 0x7b3d20b6, 0x7b92aa88, 0x7be86fb9, 0x7c3e7072, 0x7c94acdd, 0x7ceb2523,
			0x7d41d96d, 0x7d98c9e6, 0x7deff6b6, 0x7e476008, 0x7e9f0606, 0x7ef6e8da, 0x7f4f08ae, 0x7fa765ac,
			0x80000000
		};

		// Special cases:
		//  * exp(+Inf) = +Inf
		//  * exp(NaN) = NaN
		//  * exp(-Inf) = 0
		if (x.value > pow2max) {
			return as(inf);
		}
		if (x.value <= -pow2max) {
			if (x.isNan()) {
				return x;
			}
			return as(0);
		}

		uint32 idx = (x.value >> (precision - 8)) & 0xff;
		static if (precision < 8) {/* todo: */ error_not_implemented_yet;}
		uint32 q = tbl_pow2[idx];
		static if (precision > 8) {
			uint32 mix = (precision > 16
				? x.value >> (precision - 16)
				: x.value << (16 - precision)
			) & 0xff;
			q += mix * (tbl_pow2[idx + 1] - q) >> 8;
		}

		int32 n = (x.value >> precision) - (30 - precision);
		return as(n < 0 ? q >> -n : q << n);
	}

	/// Returns the base-e exponential: $ e^x $.
	static Fixed exp(Fixed x) {
		// Special cases todo:
		//  * exp(+Inf) = +Inf
		//  * exp(NaN) = NaN
		//  * exp(-Inf) = 0
		//  * exp(0) = 1

		// e ** x = exp(x) = pow2(x * log2(e))
		return pow2(mul_28(x, l2e_28));
	}

	/// Returns the base 10 exponential: $ 10^x $.
	static Fixed exp10(Fixed x) {
		// Special cases todo:
		//  * exp(+Inf) = +Inf
		//  * exp(NaN) = NaN
		//  * exp(-Inf) = 0
		//  * exp(0) = 1

		// 10 ** x = exp10(x) = pow2(x * log2(10))
		return pow2(mul_28(x, l2t_28));
	}

	/// Returns the square root of the parameter `x`: $\sqrt{x}$.
	static Fixed sqrt(Fixed x) {
		// Special cases todo:
		//  * sqrt(+Inf) = +Inf
		//  * sqrt(0) = 0
		//  * sqrt(x < 0) = NaN
		//  * sqrt(NaN) = NaN

		if (x.value <= 0) {
			if (x.value < 0) {
				return as(nan);
			}
			return as(0);
		}

		static if ((precision & 1) != 0) {
			return pow2(div(log2(x), 2));
		}

		// adapted from "Graphics Gems"
		uint32 root = 0;			// Clear root
		uint32 remHi = 0;			// Clear high part of partial remainder
		uint32 remLo = x.value;		// Get argument into low part of partial remainder
		for (uint32 count = 16 + (precision >> 1); count != 0; count -= 1) {
			remHi = (remHi << 2) | (remLo >> 30);		// get 2 bits of arg
			remLo <<= 2;
			root <<= 1;									// Get ready for the next bit in the root
			uint32 testDiv = (root << 1) + 1;			// Test radical
			if (remHi >= testDiv) {
				remHi -= testDiv;
				root += 1;
			}
		}
		return as(root);
	}

	/// Returns `x` raised to the power of `y`: $ x^y $.
	static Fixed pow(Fixed x, Fixed y) {
		if (y.value == 0 || x.value == one) {
			// pow(x, 0) = 1 for any x
			// pow(1, y) = 1 for any y
			return as(one);
		}
		if (y.value == one) {
			// pow(x, 1) = x for any x
			return x;
		}
		if (y.value == half) {
			// pow(x, .5) = sqrt(x)
			return sqrt(x);
		}
		if (x.value == nan || y.value == nan) {
			// pow(NaN, y) = NaN
			// pow(x, NaN) = NaN
			return as(nan);
		}
		if (x.value == 0) {
			// pow(0, y) = Inf for y an odd integer < 0
			// pow(0, -Inf) = +Inf
			// pow(0, +Inf) = +0
			// pow(0, y) = +Inf for finite y < 0 and not an odd integer
			// pow(0, y) = 0 for y an odd integer > 0
			// pow(0, y) = +0 for finite y > 0 and not an odd integer
			if (y.value < 0) {
				return as(inf);
			}
			return as(0);
		}

		// Special cases todo:
		//  * pow(-1, Inf) = 1
		//  * pow(x, +Inf) = +Inf for |x| > 1
		//  * pow(x, -Inf) = +0 for |x| > 1
		//  * pow(x, +Inf) = +0 for |x| < 1
		//  * pow(x, -Inf) = +Inf for |x| < 1
		//  * pow(+Inf, y) = +Inf for y > 0
		//  * pow(+Inf, y) = +0 for y < 0
		//  * pow(-Inf, y) = Pow(-0, -y)
		//  * pow(x, y) = NaN for finite x < 0 and finite non-integer y

		if ((y.value & mask) == 0) {
			int32 res = one;
			int64 sqr = x.value;
			int32 pow = (y.value < 0 ? -y.value : y.value) >> precision;
			// todo: overflow check
			for (;pow != 0;) {
				if ((pow & 1) != 0) {
					res = res * sqr >> precision;
				}
				sqr = sqr * sqr >> precision;
				pow >>= 1;
			}
			return y.value < 0 ? inv(as(res)) : as(res);
		}

		return pow2(mul(y, log2(x)));
	}


	inline horner(int32 x, int32 a0, int32 a1) = a0 + int32(a1 * int64(x) >> precision);
	inline horner(int32 x, int32 a0, int32 a1, int32 a2) = horner(x, a0, horner(x, a1, a2));
	inline horner(int32 x, int32 a0, int32 a1, int32 a2, int32 a3) = horner(x, a0, horner(x, a1, a2, a3));
	inline horner(int32 x, int32 a0, int32 a1, int32 a2, int32 a3, int32 a4) = horner(x, a0, horner(x, a1, a2, a3, a4));
	inline horner(int32 x, int32 a0, int32 a1, int32 a2, int32 a3, int32 a4, int32 a5) = horner(x, a0, horner(x, a1, a2, a3, a4, a5));

	/// Returns the sine of the radian argument `x`.
	static Fixed sin(Fixed x) {
		// Special cases todo:
		//  * sin(0) = 0
		//  * sin(Inf) = NaN
		//  * sin(NaN) = NaN

		enum: int32 {
			p0: one * +1. / 1;			// 1/1!
			p1: one * -1. / 6;			// 1/3!
			p2: one * +1. / 120;		// 1/5!
			p3: one * -1. / 5040;		// 1/7!
			p4: one * +1. / 362880;		// 1/9!
			p5: one * -1. / 39916800;	// 1/11!
		}

		x.value %= piMul2;
		if (x.value < 0) {
			x.value += piMul2;
		}

		// x in [0, 2*pi)
		int32 sign = 1;
		if (x.value >= pi) {
			x.value -= pi;
			sign = -1;
		}

		// x in [0, pi)
		if (x.value >= piDiv2) {
			x.value = pi - x.value;
		}

		// x in [0, pi / 2)
		int32 xsq = int64(x.value) * x.value >> precision;
		int32 res = horner(xsq, p0, p1, p2, p3, p4, p5);
		return mul(x, as(sign * res));
	}

	/// Returns the hyperbolic sine of the radian argument `x`.
	static Fixed sinh(Fixed x) {
		// Special cases:
		//  * sinh(0) = 0
		//  * sinh(Inf) = Inf
		//  * sinh(NaN) = NaN
		if (x.value == 0) {
			return as(0);
		}
		if (!isFinite(x)) {
			return x;
		}

		// sinh(x) = (exp(x) - exp(-x)) / 2;
		return div(sub(exp(x), exp(neg(x))), 2);
	}

	/*todo:/// Returns the inverse sine of the radian argument `x`.
	static Fixed asin(Fixed x) {
		// Special cases:
		//  * asin(0) = 0
		//  * asin(x > 1) = NaN
		//  * asin(x < -1) = NaN

		// asin(x) = atan2(x, sqrt((1 + x) * (1 - x)));
		return atan2(x, sqrt((1 + x) * (1 - x)));
	}*/

	/*todo:/// Returns the inverse hyperbolic sine of the radian argument `x`.
	static Fixed asinh(Fixed x) {
		// Special cases:
		//  * asinh(0) = 0
		//  * asinh(Inf) = Inf
		//  * asinh(NaN) = NaN

		// asinh(x) = log(x + sqrt(x * x + 1));
		return log(x + sqrt(x * x + 1));
	}*/


	/// Returns the cosine of the radian argument `x`.
	static Fixed cos(Fixed x) {
		// Special cases todo:
		//  * cos(Inf) = NaN
		//  * cos(NaN) = NaN

		enum: int32 {
			p0: one * +1. / 1;			// 1/0!
			p1: one * -1. / 2;			// 1/2!
			p2: one * +1. / 24;			// 1/4!
			p3: one * -1. / 720;		// 1/6!
			p4: one * +1. / 40320;		// 1/8!
			p5: one * -1. / 3628800;	// 1/10!
		}

		x.value %= piMul2;
		if (x.value < 0) {
			x.value += piMul2;
		}

		// x in [0, 2*pi)
		if (x.value > pi) {
			x.value = piMul2 - x.value;
		}

		// x in [0, pi)
		int32 sign = 1;
		if (x.value >= piDiv2) {
			x.value -= pi;
			sign = -1;
		}

		// x in [0, pi / 2)
		int32 xsq = int64(x.value) * x.value >> precision;
		int32 res = horner(xsq, p0, p1, p2, p3, p4, p5);
		return as(sign * res);
	}

	/*todo:/// Returns the hyperbolic cosine of the radian argument `x`.
	static Fixed cosh(Fixed x) {
		// Special cases:
		//  * cosh(0) = 1
		//  * cosh(Inf) = +Inf
		//  * cosh(NaN) = NaN

		if (x.value == 0) {
			return as(1);
		}

		// cosh(x) = (exp(x) + exp(-x)) / 2;
		return (exp(x) + exp(-x)) / 2;
	}*/

	/*todo:/// Returns the inverse cosine of the radian argument `x`.
	static Fixed acos(Fixed x) {
		// Special cases:
		//  * acos(x > 1) = NaN
		//  * acos(x < -1) = NaN

		// acos(x) = atan2(sqrt((1 + x) * (1 - x)), x);
		return atan2(sqrt((1 + x) * (1 - x)), x);
	}*/

	/*todo:/// Returns the inverse hyperbolic cosine of the radian argument `x`.
	static Fixed acosh(Fixed x) {
		// Special cases:
		//  * acosh(+Inf) = +Inf
		//  * acosh(x < 1) = NaN
		//  * acosh(NaN) = NaN

		// acosh(x) = log(x + sqrt(x * x - 1));
		return log(x + sqrt(x * x - 1));
	}*/


	/// Returns the tangent of the radian argument `x`.
	static Fixed tan(Fixed x) {
		// Special cases todo:
		//  * tan(0) = 0
		//  * tan(Inf) = NaN
		//  * tan(NaN) = NaN
		return div(sin(x), cos(x));
	}

	/*todo:/// Returns the hyperbolic tangent of the radian argument `x`.
	static Fixed tanh(Fixed x) {
		// Special cases:
		//  * tanh(0) = 0
		//  * tanh(Inf) = 1
		//  * tanh(NaN) = NaN

		// tanh(x) = sinh(x) / cosh(x)
		//         = (exp(x) - exp(-x)) / (exp(x) + exp(-x))
		//         = (exp(2 * x) - 1) / (exp(2 * x) + 1)
		//         = (1 - exp(-2*x)) / (exp(-2*x) - 1 + 2)
		//         ...
		//         = 1 - 2 / (exp(2 * x) + 1)
		x = exp(mul(x, 2));
		return div(sub(x, one), add(x, one));
	}*/

	/*todo:/// Returns the inverse tangent of the radian argument `x`.
	static Fixed atan(Fixed x) {
		// Special cases:
		//  * atan(0) = 0
		//  * atan(Inf) = Pi/2
	}*/

	/*todo:/// Returns the inverse tangent of `y / x`.
	static Fixed atan2(Fixed y, Fixed x) {
		// Special cases (in order):
		//  * atan2(y, NaN) = NaN
		//  * atan2(NaN, x) = NaN
		//  * atan2(+0, x>=0) = +0
		//  * atan2(-0, x>=0) = -0
		//  * atan2(+0, x<=-0) = +Pi
		//  * atan2(-0, x<=-0) = -Pi
		//  * atan2(y>0, 0) = +Pi/2
		//  * atan2(y<0, 0) = -Pi/2
		//  * atan2(+Inf, +Inf) = +Pi/4
		//  * atan2(-Inf, +Inf) = -Pi/4
		//  * atan2(+Inf, -Inf) = 3Pi/4
		//  * atan2(-Inf, -Inf) = -3Pi/4
		//  * atan2(y, +Inf) = 0
		//  * atan2(y>0, -Inf) = +Pi
		//  * atan2(y<0, -Inf) = -Pi
		//  * atan2(+Inf, x) = +Pi/2
		//  * atan2(-Inf, x) = -Pi/2
	}*/

	/*todo:/// Returns the inverse hyperbolic tangent of the radian argument `x`.
	static Fixed atanh(Fixed x) {
		// Special cases:
		//  * atanh(1) = +Inf
		//  * atanh(0) = 0
		//  * atanh(-1) = -Inf
		//  * atanh(x > 1) = NaN
		//  * atanh(x < -1) = NaN
		//  * atanh(NaN) = NaN
		//  ? atanh(-x) = -atanh(x)

		// atanh(x) = .5 * log((1 + x) / (1 - x))
		return .5 * log((1 + x) / (1 - x));
	}*/

	/// Returns the cotangent of the radian argument `x`.
	// todo: inline cot(float64 x) = 1 / tan(x);

	/// Returns the hyperbolic cotangent of the radian argument `x`.
	// todo: inline coth(float64 x) = 1 / tanh(x);

	/// Returns the inverse cotangent of the radian argument `x`.
	// todo: inline acot(float64 x) = x == 0 ? pi / 2 : atan(1 / x);

	/// Returns the inverse hyperbolic cotangent of the radian argument `x`.
	// todo: inline acoth(float64 x) = x == 1 ? inf : x == -1 ? -inf : .5 * log((x + 1) / (x - 1));


	/// Returns the secant of the radian argument `x`.
	// todo: inline sec(float64 x) = 1 / cos(x);

	/// Returns the hyperbolic secant of the radian argument `x`.
	// todo: inline sech(float64 x) = 1 / cosh(x);

	/// Returns the inverse secant of the radian argument `x`.
	// todo: inline asec(float64 x) = x == 0 ? inf : acos(1 / x);

	/// Returns the inverse hyperbolic secant of the radian argument `x`.
	// todo: inline asech(float64 x) = x == 0 ? inf : x == 1 ? 0 : log((sqrt(1 - x * x) + 1) / x);


	/// Returns the cosecant of the radian argument `x`.
	// todo: inline csc(float64 x) = 1 / sin(x);

	/// Returns the hyperbolic cosecant of the radian argument `x`.
	// todo: inline csch(float64 x) = 1 / sinh(x);

	/// Returns the inverse cosecant of the radian argument `x`.
	// todo: inline acsc(float64 x) = x == 0 ? inf : asin(1 / x);

	/// Returns the inverse hyperbolic cosecant of the radian argument `x`.
	// todo: inline acsch(float64 x) = x == 0 ? inf : x < 0 ? log((1 - sqrt(1 + x * x)) / x) : log((1 + sqrt(1 + x * x)) / x);


	/// Converts the input to degrees from radians: $radians * 180 / pi$
	static Fixed degrees(Fixed radians) {
		return as(radians.value * int64(r2d_24) >> 24);
	}

	/// Converts the input to radians from degrees: $degrees * pi / 180$
	static Fixed radians(Fixed degrees) {
		return mul_28(degrees, d2r_28);
	}
}

/// Convert the integer `value` to fixed-point value
inline Fixed(int32 value) = Fixed.as(value << Fixed.precision);

/// Convert the fixed point `value` to integer value
inline int32(const Fixed value&) = value.value >> Fixed.precision;

/// Convert the floating point `value` to fixed-point value
//inline Fixed(float64 value) = Fixed.as(value * (1 << Fixed.precision));
Fixed Fixed(float64 value) {
	Fixed result = Fixed.as(value * (1 << Fixed.precision));
	if (result.value == Fixed.nan) {
		if (value != value) {
			result.value = Fixed.nan;
		}
		else if (value > 0) {
			result.value = Fixed.inf;
		}
		else if (value < 0) {
			result.value = -Fixed.inf;
		}
	}
	return result;
}

/// Convert the fixed point `value` to floating point value
//inline float64(const Fixed value&) = value.value / float64(1 << Fixed.precision);
float64 float64(Fixed value) {
	if (value.value == Fixed.nan) {
		return Math.nan;
	}
	if (value.value == Fixed.inf) {
		return Math.inf;
	}
	if (value.value == -Fixed.inf) {
		return -Math.inf;
	}

	return value.value / float64(1 << Fixed.precision);
}
/// Mathematical utility functions and constants
static struct Math {

	// Some useful mathematical constants
	enum: float64 {
		pi: 3.14159265358979323846264338327950288419716939937510582097494459;		// A000796
		e: 2.71828182845904523536028747135266249775724709369995957496696763;		// A001113
		ln2: 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
		log2E: 1. / ln2;
		ln10: 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
		log10E: 1. / ln10;
		phi: 1.61803398874989484820458683436563811772030917980576286213544862;		// A001622
		sqrt2: 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
		sqrtE: 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
		sqrtPi: 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
		sqrtPhi: 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
		nan: 0 / 0.;
		inf: 1 / 0.;
		smallestNormal: 2.2250738585072014e-308; // 2**-1022
	}

	/// Determines whether the given floating point value is not-a-number
	bool isNan(float64 x) { return x != x; }

	/// Determines whether the given floating point value is not-a-number
	// inline isNan(float32 x) = x != x;

	/// Determines whether the given floating point value is infinity
	bool isInf(float64 x) { return x != 0 && x == 2 * x; }
	/// Determines whether the given floating point value is infinity
	// inline isInf(float32 x) = x != 0 && x == 2 * x;

	/// Determines whether the given floating point value is finite: `!isNan(x) && !isInf(x)`
	bool isFinite(float64 x) { return x - x == 0; }

	/// Determines whether the given floating point value is finite: `!isNan(x) && !isInf(x)`
	// inline isFinite(float32 x) = x - x == 0;

	// internal method to check if a number is infinity or not
	bool isInf(float64 x, int sign) {
		if (x.isFinite()) {
			return false;
		}
		if (sign == 0) {
			return true;
		}
		return sign < 0 ? x < 0 : x > 0;
	}


	/// Computes the largest integer value not greater than the input
	float64 floor(float64 x) {
		float64 mod = x % 1;
		if (mod < 0) {
			mod += 1;
		}
		return x - mod;
	}

	/// Computes the largest integer value not greater than the input
	float32 floor(float32 x) {
		float32 mod = x % 1;
		if (mod < 0) {
			mod += 1;
		}
		return x - mod;
	}

	/// Computes the smallest integer not less than the input
	inline ceil(float64 x) = -floor(-x);

	/// Computes the smallest integer not less than the input
	inline ceil(float32 x) = -floor(-x);

	/// Computes the nearest integer to the input
	inline round(float64 x) = floor(x + .5);

	/// Computes the nearest integer to the input
	inline round(float32 x) = floor(x + .5f);


	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(int32 x) = int(x > 0) - int(x < 0);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(int64 x) = int(x > 0) - int(x < 0);

	/// Returns the signum of the input (`0` if zero, `1` if positive)
	inline sign(uint32 x) = int(x > 0);

	/// Returns the signum of the input (`0` if zero, `1` if positive)
	inline sign(uint64 x) = int(x > 0);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float32 x) = int(x > 0) - int(x < 0);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float64 x) = int(x > 0) - int(x < 0);


	/// Returns the positive modulus of the input
	float32 absMod(float32 val, float32 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	/// Returns the positive modulus of the input
	float64 absMod(float64 val, float64 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	/// Returns the absolute value of the input
	inline abs(int32 x) = x < 0 ? -x : x;

	/// Returns the absolute value of the input
	inline abs(int64 x) = x < 0 ? -x : x;

	/// Returns the absolute value of the input
	inline abs(uint32 x) = x;

	/// Returns the absolute value of the input
	inline abs(uint64 x) = x;

	/// Returns the absolute value of the input
	inline abs(float32 x) = x < 0 ? -x : x;

	/// Returns the absolute value of the input
	inline abs(float64 x) = x < 0 ? -x : x;


	/// Returns the smaller value from the input values
	inline min(int32 a, int32 b) = a < b ? a : b;

	/// Returns the smaller value from the input values
	inline min(int64 a, int64 b) = a < b ? a : b;

	/// Returns the smaller value from the input values
	inline min(uint32 a, uint32 b) = a < b ? a : b;

	/// Returns the smaller value from the input values
	inline min(uint64 a, uint64 b) = a < b ? a : b;

	/// Returns the smaller value from the input values
	inline min(float32 a, float32 b) = a < b ? a : b;

	/// Returns the smaller value from the input values
	inline min(float64 a, float64 b) = a < b ? a : b;

	/// Returns the greater value from the input values
	inline max(int32 a, int32 b) = a > b ? a : b;

	/// Returns the greater value from the input values
	inline max(int64 a, int64 b) = a > b ? a : b;

	/// Returns the greater value from the input values
	inline max(uint32 a, uint32 b) = a > b ? a : b;

	/// Returns the greater value from the input values
	inline max(uint64 a, uint64 b) = a > b ? a : b;

	/// Returns the greater value from the input values
	inline max(float32 a, float32 b) = a > b ? a : b;

	/// Returns the greater value from the input values
	inline max(float64 a, float64 b) = a > b ? a : b;


	/// Returns the `value` clamped between `min` and `max`
	inline clamp(int32 value, int32 min, int32 max) = min(max(value, min), max);

	/// Returns the `value` clamped between `min` and `max`
	inline clamp(int64 value, int64 min, int64 max) = min(max(value, min), max);

	/// Returns the `value` clamped between `min` and `max`
	inline clamp(uint32 value, uint32 min, uint32 max) = min(max(value, min), max);

	/// Returns the `value` clamped between `min` and `max`
	inline clamp(uint64 value, uint64 min, uint64 max) = min(max(value, min), max);

	/// Returns the `value` clamped between `min` and `max`
	inline clamp(float32 value, float32 min, float32 max) = min(max(value, min), max);

	/// Returns the `value` clamped between `min` and `max`
	inline clamp(float64 value, float64 min, float64 max) = min(max(value, min), max);

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline mix(float32 a, float32 b, float32 t) = a + t * (b - a);

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline mix(float64 a, float64 b, float64 t) = a + t * (b - a);

	inline smoothstep(float32 t) = t * t * (3 - 2 * t);

	/// Returns the Hermite interpolation between two values
	inline smoothstep(float32 min, float32 max, float32 t) = smoothstep(clamp((t - min) / (max - min), 0f, 1f));

	inline smoothstep(float64 t) = t * t * (3 - 2 * t);

	/// Returns the Hermite interpolation between two values
	inline smoothstep(float64 min, float64 max, float64 t) = smoothstep(clamp((t - min) / (max - min), 0F, 1F));


	/// Returns the smaller value from the input values
	float64 min(float64 values...) {
		if (values.length == 0) {
			return nan;
		}
		float64 result = values[0];
		for (int i = 1; i < values.length; i += 1) {
			if (result > values[i]) {
				result = values[i];
			}
		}
		return result;
	}

	/// Returns the greater value from the input values
	float64 max(float64 values...) {
		if (values.length == 0) {
			return nan;
		}
		float64 result = values[0];
		for (int i = 1; i < values.length; i += 1) {
			if (result < values[i]) {
				result = values[i];
			}
		}
		return result;
	}

	/// Returns the sum of the input values
	float64 sum(float64 values...) {
		float64 result = 0;
		for (int i = 0; i < values.length; i += 1) {
			result += values[i];
		}
		return result;
	}

	/// Returns the mean of the input values
	float64 mean(float64 values...) {
		return sum(...values) / Bits.signed(values.length);
	}

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0) = a0;

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1) = a0 + x * a1;

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2) = a0 + x * eval(x, a1, a2);

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3) = a0 + x * eval(x, a1, a2, a3);

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3, float64 a4) = a0 + x * eval(x, a1, a2, a3, a4);

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3, float64 a4, float64 a5) = a0 + x * eval(x, a1, a2, a3, a4, a5);

	/// Return the polynomial evaluated at x using Horner's algorithm
	float64 eval(float64 x, float64 polynomial...) {
		float64 result = 0;
		for (int i = polynomial.length - 1; i >= 0; i -= 1) {
			result = result * x + polynomial[i];
		}
		return result;
	}

	/// Decompose a value into integer and fractional parts
	float64 modf(float64 x, float64 intPart&) {
		if (x < 1) {
			if (x < 0) {
				float64 result = modf(-x, &intPart);
				intPart = -intPart;
				return -result;
			}
			intPart = 0;
			return x;
		}
		float64 result = x % 1;
		intPart = x - result;
		return result;
	}

	float64 copysign(float64 x, float64 y) {
		uint64 sign = Bits.fromFloat64(y) & (1U << 63);
		uint64 val = Bits.fromFloat64(x) & ~(1U << 63);
		return Bits.asFloat64(sign | val);
	}

	/* Frexp breaks f into a normalized fraction and an integral power of two.
	 * It returns frac and exp satisfying f == frac  2**exp,
	 * with the absolute value of frac in the interval [, 1).
	 *
	 * Special cases are:
	 *   * Frexp(0) = 0, 0
	 *   * Frexp(Inf) = Inf, 0
	 *   * Frexp(NaN) = NaN, 0
	 */
	// adapted from: https://github.com/golang/go/blob/master/src/math/frexp.go
	float64 frexp(float64 f, int exp&) {
		inline mask     = 0x7FFU;
		inline shift    = 64 - 11 - 1;
		inline bias     = 1023;
		inline signMask = 1U << 63;
		inline fracMask = 1U << shift - 1;

		// special cases
		if (f == 0) {
			exp = 0;
			return f;
		}
		if (isInf(f) || isNan(f)) {
			exp = 0;
			return f;
		}

		if (abs(f) < smallestNormal) {
			// normalize
			f *= 1 << 52;
			exp -= 52;
		} else {
			exp = 0;
		}

		uint64 x = Bits.fromFloat64(f);
		exp += int((x >> shift) & mask) - bias + 1;
		x &= ~(mask << shift);
		x |= (-1U + bias) << shift;
		return Bits.asFloat64(x);
	}

	/* Ldexp is the inverse of Frexp.
	 * It returns frac  2**exp.
	 *
	 * Special cases are:
	 *	 * Ldexp(0, exp) = 0
	 *	 * Ldexp(Inf, exp) = Inf
	 *	 * Ldexp(NaN, exp) = NaN
	 */
	// adapted from: https://github.com/golang/go/blob/master/src/math/ldexp.go
	float64 ldexp(float64 f, int exp) {
		inline mask     = 0x7FFU;
		inline shift    = 64 - 11 - 1;
		inline bias     = 1023;
		inline signMask = 1U << 63;
		inline fracMask = 1U << shift - 1;

		// special cases
		if (f == 0) {
			// correctly return -0
			return f;
		}
		if (f != f || f - f != 0) {
			// not a number or non finite number
			return f;
		}

		if (abs(f) < smallestNormal) {
			// normalize
			f *= 1 << 52;
			exp -= 52;
		}

		uint64 x = Bits.fromFloat64(f);
		exp += (int(x>>shift) & mask) - bias;

		if (exp < -1075) {
			// trace("underflow", exp);
			return copysign(0., f);
		}
		if (exp > 1023) {
			// trace("overflow", exp);
			return copysign(inf, f);
		}
		float64 m = 1;
		if (exp < -1022) {
			// denormal
			exp += 53;
			m = 1 / float64(1 << 53); // 2**-53
		}
		x &= ~(mask << shift);
		x |= uint64(exp+bias) << shift;
		return m * Bits.asFloat64(x);
	}

	/// Returns the natural logarithm of the argument `x`.
	// adapted from: https://9p.io/sources/plan9/sys/src/libc/port/log.c
	float64 log(float64 x) {
		static if (preferNativeCalls && typename(float64.log) != null) {
			// use the native method if available
			return float64.log(x);
		}

		enum: float64 {
			log2: 0.693147180559945309e0;
			ln10o1: .4342944819032518276511;
			sqrto2: 0.707106781186547524e0;

			p0: -.240139179559210510e2;
			p1: 0.309572928215376501e2;
			p2: -.963769093377840513e1;
			p3: 0.421087371217979714e0;

			q0: -.120069589779605255e2;
			q1: 0.194809660700889731e2;
			q2: -.891110902798312337e1;
		}

		if (x <= 0) {
			if (x == 0) {
				return -inf;
			}
			return nan;
		}

		int exp;
		x = frexp(x, &exp);
		for (;x < 0.5;) {
			x *= 2;
			exp -= 1;
		}
		if (x < sqrto2) {
			x *= 2;
			exp -= 1;
		}

		float64 z = (x-1) / (x+1);
		float64 zsq = z * z;
		float64 p = eval(zsq, p0, p1, p2, p3);
		float64 q = eval(zsq, q0, q1, q2 + zsq);
		return p / q * z + exp * log2;
	}

	/// Returns the natural logarithm of the argument `x`.
	float32 log(float32 x) {
		static if (preferNativeCalls && typename(float32.log) != null) {
			// use the native method if available
			return float32.log(x);
		}

		return float32(log(float64(x)));
	}

	/// Returns the base 2 logarithm of the argument `x`.
	inline log2(float64 x) = log(x) / ln2;

	/// Returns the base 10 logarithm of the argument `x`.
	inline log10(float64 x) = log(x) / ln10;

	/// Returns the logarithm of the specified `base` of the argument `x`.
	inline log(float64 x, float64 base) = log(x) / log(base);


	/// Returns the base-e exponential: $ e^x $.
	// adapted from: https://github.com/jeremybarnes/cephes/blob/master/cmath/exp.c
	float64 exp(float64 x) {
		static if (preferNativeCalls && typename(float64.exp) != null) {
			// use the native method if available
			return float64.exp(x);
		}

		enum: float64 {
			c1: 6.93145751953125E-1;
			c2: 1.42860682030941723212E-6;

			p0: 1.26177193074810590878E-4;
			p1: 3.02994407707441961300E-2;
			p2: 9.99999999999999999910E-1;

			q0: 3.00198505138664455042E-6;
			q1: 2.52448340349684104192E-3;
			q2: 2.27265548208155028766E-1;
			q3: 2.00000000000000000009E0;

			MAXLOG: 7.08396418532264106224E2;     /* log 2**1022 */
			MINLOG: -7.08396418532264106224E2;     /* log 2**-1022 */
			LOG2E:  1.4426950408889634073599;     /* 1/log(2) */
		}

		if (isNan(x)) {
			return x;
		}
		if (x > MAXLOG) {
			return inf;
		}

		if (x < MINLOG) {
			return 0;
		}

		/* Express e**x = e**g 2**n
		 *   = e**g e**( n loge(2) )
		 *   = e**( g + n loge(2) )
		 */
		/* floor() truncates toward -infinity. */
		float64 px = floor(LOG2E * x + .5);
		x -= px * c1;
		x -= px * c2;

		/* rational approximation for exponential of the fractional part:
		 * e**x = 1 + 2x P(x**2) / (Q(x**2) - P(x**2))
		 */
		float64 xx = x * x;
		float64 p = x * eval(xx, p2, p1, p0);
		float64 q = eval(xx, q3, q2, q1, q0);

		/* multiply by power of 2 */
		return ldexp(1 + 2 * p / (q - p), px);
	}

	/// Returns the base-e exponential: $ e^x $.
	float32 exp(float32 x) {
		static if (preferNativeCalls && typename(float32.exp) != null) {
			// use the native method if available
			return float32.exp(x);
		}

		return float32(exp(float64(x)));
	}

	/// Returns the square root of the parameter `x`: $\sqrt{x}$.
	// adapted from: https://github.com/golang/go/blob/master/src/math/sqrt.go
	float64 sqrt(float64 x) {
		static if (preferNativeCalls && typename(float64.sqrt) != null) {
			// use the native method if available
			return float64.sqrt(x);
		}

		// Special cases are:
		//   * Sqrt(+Inf) = +Inf
		//   * Sqrt(0) = 0
		//   * Sqrt(x < 0) = NaN
		//   * Sqrt(NaN) = NaN

		if (x == 0 || isNan(x) || isInf(x, 1)) {
			return x;
		}
		if (x < 0) {
			return nan;
		}

		inline mask     = 0x7FFU;
		inline shift    = 64 - 11 - 1;
		inline bias     = 1023;

		uint64 ix = Bits.fromFloat64(x);
		// normalize x
		int exp = int((ix >> shift) & mask);
		if (exp == 0) { // subnormal x
			for (;(ix & (1U << shift)) == 0;) {
				ix <<= 1;
				exp -= 1;
			}
			exp += 1;
		}
		exp -= bias; // unbias exponent
		ix &= ~(mask << shift);
		ix |= 1U << shift;
		if ((exp & 1) == 1) { // odd exp, double x to make it even
			ix <<= 1;
		}
		exp >>= 1; // exp = exp/2, exponent of square root
		// generate sqrt(x) bit by bit
		ix <<= 1;
		uint64 s = 0;
		uint64 q = 0;               // q = sqrt(x)
		uint64 r = 1U << (shift + 1); // r = moving bit from MSB to LSB
		for (;r != 0;) {
			uint64 t = s + r;
			if (t <= ix) {
				s = t + r;
				ix -= t;
				q += r;
			}
			ix <<= 1;
			r >>= 1;
		}
		// final rounding
		if (ix != 0) { // remainder, result not exact
			q += q & 1; // round according to extra bit
		}
		ix = (q >> 1) + (uint64(exp - 1 + bias) << shift); // significand + biased exponent
		return Bits.asFloat64(ix);
	}

	/// Returns the square root of the parameter `x`: $\sqrt{x}$.
	float32 sqrt(float32 x) {
		static if (preferNativeCalls && typename(float32.sqrt) != null) {
			// use the native method if available
			return float32.sqrt(x);
		}

		return float32(sqrt(float64(x)));
	}

	/// Returns `x` raised to the power of `y`: $ x^y $.
	// adapted from: https://9p.io/sources/plan9/sys/src/libc/port/pow.c
	float64 pow(float64 x, float64 y) {
		static if (preferNativeCalls && typename(float64.pow) != null) {
			// use the native method if available
			return float64.pow(x, y);
		}

		if (y == 0) {
			return 1;
		}

		int flip = 0;
		if (y < 0) {
			y = -y;
			flip = 1;
		}
		float64 ye;
		float64 xy = 1;
		float64 y1 = modf(y, &ye);
		if (y1 != 0.0) {
			if(x <= 0.){
				if (x == 0 && !flip) {
					return 0;
				}
				return nan;
			}
			if (y1 > .5) {
				y1 -= 1;
				ye += 1;
			}
			xy = exp(y1 * log(x));
		}
		if (ye > 0x7FFFFFFF) {	/* should be ~0UL but compiler can't convert double to ulong */
			if (x <= 0){
				if (x == 0 && !flip) {
					return 0;
				}
				return nan;
			}
			if (flip) {
				if (y == .5) {
					return 1 / sqrt(x);
				}
				y = -y;
			}
			else if (y == .5) {
				return sqrt(x);
			}
			return exp(y * log(x));
		}

		int ex;
		x = frexp(x, &ex);
		int ey = 0;
		int64 i = ye;
		if (i) {
			for (;;) {
				if (i & 1) {
					xy *= x;
					ey += ex;
				}
				i >>= 1;
				if (i == 0) {
					break;
				}
				x *= x;
				ex <<= 1;
				if (x < .5) {
					x += x;
					ex -= 1;
				}
			}
		}
		if (flip) {
			xy = 1. / xy;
			ey = -ey;
		}
		return ldexp(xy, ey);
	}

	/// Returns `x` raised to the power of `y`: $ x^y $.
	float32 pow(float32 x, float32 y) {
		static if (preferNativeCalls && typename(float32.pow) != null) {
			// use the native method if available
			return float32.pow(x, y);
		}

		return float32(pow(float64(x), float64(y)));
	}


	// adapted from: https://9p.io/sources/plan9/sys/src/libc/port/sin.c
	float64 sincos(float64 x, int quad) {
		enum: float64 {
			p0: .1357884097877375669092680e8;
			p1: -.4942908100902844161158627e7;
			p2: .4401030535375266501944918e6;
			p3: -.1384727249982452873054457e5;
			p4: .1459688406665768722226959e3;
			q0: .8644558652922534429915149e7;
			q1: .4081792252343299749395779e6;
			q2: .9463096101538208180571257e4;
			q3: .1326534908786136358911494e3;
		}

		if (x < 0) {
			x = -x;
			quad += 2;
		}

		float64 y;
		x *= 2 / pi;	/* underflow? */
		if (x > 32764) {
			float64 e;
			y = modf(x, &e);
			e += quad;

			float64 f;
			modf(0.25 * e, &f);
			quad = e - 4 * f;
		} else {
			int k = x;
			y = x - k;
			quad += k;
			quad &= 3;
		}
		if (quad & 1) {
			y = 1 - y;
		}
		if (quad > 1) {
			y = -y;
		}

		float64 ysq = y * y;
		float64 p = y * eval(ysq, p0, p1, p2, p3, p4);
		float64 q = eval(ysq, q0, q1, q2, q3 + ysq);
		return p / q;
	}

	// adapted from: https://github.com/jeremybarnes/cephes/blob/master/cmath/tan.c
	float64 tancot(float64 x, int flag) {
		enum: float64 {
			dp1: 7.853981554508209228515625E-1;
			dp2: 7.94662735614792836714E-9;
			dp3: 3.06161699786838294307E-17;

			p0: -1.30936939181383777646e4;
			p1: 1.15351664838587416140e6;
			p2: -1.79565251976484877988e7;

			q0: 1.00000000000000000000e0;
			q1: 1.36812963470692954678e4;
			q2: -1.32089234440210967447e6;
			q3: 2.50083801823357915839e7;
			q4: -5.38695755929454629881e7;

			lossth: 1.073741824e9;
		}

		/* make argument positive but save the sign */
		float64 sign = 1;
		if (x < 0) {
			x = -x;
			sign = -1;
		}

		if (x > lossth) {
			//error("total loss of precision");
			return 0;
		}

		/* compute x mod PIO4 */
		float64 y = floor(x / (pi / 4));

		/* strip high bits of integer part */
		float64 z = ldexp(y, -3);
		z = floor(z);        /* integer part of y/8 */
		z = y - ldexp(z, 3);  /* y - 16 * (y/16) */

		/* integer and fractional part modulo one octant */
		int j = z;

		/* map zeros and singularities to origin */
		if (j & 1) {
			j += 1;
			y += 1.0;
		}

		z = ((x - y * dp1) - y * dp2) - y * dp3;

		float64 zz = z * z;
		if (zz > 1.0e-14) {
			y = z + z * (zz * eval(zz, p2, p1, p0) / eval(zz, q4, q3, q2, q1, q0));
		} else {
			y = z;
		}

		if (j & 2) {
			if (flag) {
				y = -y;
			} else {
				y = -1 / y;
			}
		} else {
			if (flag) {
				y = 1 / y;
			}
		}

		return sign * y;
	}

	/// Returns the inverse tangent of the radian argument `x`.
	// adapted from: https://9p.io/sources/plan9/sys/src/libc/port/atan.c
	float64 atan(float64 x) {
		enum: float64 {
			sq2p1: 2.414213562373095048802e0;
			sq2m1: .414213562373095048802e0;

			p4: .161536412982230228262e2;
			p3: .26842548195503973794141e3;
			p2: .11530293515404850115428136e4;
			p1: .178040631643319697105464587e4;
			p0: .89678597403663861959987488e3;

			q4: .5895697050844462222791e2;
			q3: .536265374031215315104235e3;
			q2: .16667838148816337184521798e4;
			q1: .207933497444540981287275926e4;
			q0: .89678597403663861962481162e3;
		}

		// xatan evaluates a series valid in the range [-0.414...,+0.414...]. (tan(pi/8))
		float64 xatan(float64 x) {
			float64 z = x * x;
			float64 p = eval(z, p0, p1, p2, p3, p4);
			float64 q = eval(z, q0, q1, q2, q3, q4 + z);
			return p / q * x;
		}

		// satan reduces its argument (known to be positive) to the range [0,0.414...] and calls xatan.
		float64 satan(float64 x) {
			if (x < sq2m1) {
				return xatan(x);
			}
			if (x > sq2p1) {
				return pi / 2 - xatan(1 / x);
			}
			return pi / 4 + xatan((x - 1) / (x + 1));
		}

		if (x > 0) {
			return satan(x);
		}
		return -satan(-x);
	}

	/// Returns the inverse tangent of y/x.
	// adapted from: https://9p.io/sources/plan9/sys/src/libc/port/atan2.c
	float64 atan2(float64 arg1, float64 arg2) {
		static if (preferNativeCalls && typename(float64.atan2) != null) {
			// use the native method if available
			return float64.atan2(arg1, arg2);
		}

		if (arg1 + arg2 == arg1) {
			if (arg1 >= 0) {
				return pi / 2;
			}
			return -pi / 2;
		}

		arg1 = atan(arg1 / arg2);
		if (arg2 < 0) {
			if (arg1 <= 0) {
				return arg1 + pi;
			}
			return arg1 - pi;
		}
		return arg1;
	}

	/// Returns the inverse tangent of y/x.
	float32 atan2(float32 y, float32 x) {
		static if (preferNativeCalls && typename(float32.atan2) != null) {
			// use the native method if available
			return float32.atan2(y, x);
		}

		return float32(atan2(float64(y), float64(x)));
	}


	/// Returns the sine of the radian argument `x`.
	float64 sin(float64 x) {
		static if (preferNativeCalls && typename(float64.sin) != null) {
			// use the native method if available
			return float64.sin(x);
		}

		return sincos(x, 0);
	}

	/// Returns the sine of the radian argument `x`.
	float32 sin(float32 x) {
		static if (preferNativeCalls && typename(float32.sin) != null) {
			// use the native method if available
			return float32.sin(x);
		}

		return float32(sin(float64(x)));
	}

	/// Returns the hyperbolic sine of the radian argument `x`.
	inline sinh(float64 x) = x == 0 ? 0 : (exp(x) - exp(-x)) / 2;

	/// Returns the inverse sine of the radian argument `x`.
	inline asin(float64 x) = atan2(x, sqrt((1 + x) * (1 - x)));

	/// Returns the inverse hyperbolic sine of the radian argument `x`.
	inline asinh(float64 x) = log(x + sqrt((x * x) + 1));


	/// Returns the cosine of the radian argument `x`.
	float64 cos(float64 x) {
		static if (preferNativeCalls && typename(float64.cos) != null) {
			// use the native method if available
			return float64.cos(x);
		}

		if (x < 0) {
			x = -x;
		}
		return sincos(x, 1);
	}

	/// Returns the sine of the radian argument `x`.
	float32 cos(float32 x) {
		static if (preferNativeCalls && typename(float32.cos) != null) {
			// use the native method if available
			return float32.cos(x);
		}

		return float32(cos(float64(x)));
	}

	/// Returns the hyperbolic cosine of the radian argument `x`.
	inline cosh(float64 x) = x == 0 ? 1 : (exp(x) + exp(-x)) / 2;

	/// Returns the inverse cosine of the radian argument `x`.
	inline acos(float64 x) = atan2(sqrt((1 + x) * (1 - x)), x);

	/// Returns the inverse hyperbolic cosine of the radian argument `x`.
	inline acosh(float64 x) = log(x + sqrt(x * x - 1)); // log(x + sqrt((x - 1) / (x + 1)) * (x + 1));


	/// Returns the tangent of the radian argument `x`.
	float64 tan(float64 x) {
		static if (preferNativeCalls && typename(float64.tan) != null) {
			// use the native method if available
			return float64.tan(x);
		}

		if (x == 0) {
			return x;
		}
		if (x != x) {
			// nan
			return x;
		}
		if (x == 2 * x) {
			// infinity
			return nan;
		}

		return tancot(x, 0);
	}

	/// Returns the tangent of the radian argument `x`.
	float32 tan(float32 x) {
		static if (preferNativeCalls && typename(float32.tan) != null) {
			// use the native method if available
			return float32.tan(x);
		}

		return float32(tan(float64(x)));
	}

	/// Returns the hyperbolic tangent of the radian argument `x`.
	inline tanh(float64 x) = 1 - 2 / (exp(2 * x) + 1);

	/// Returns the inverse hyperbolic tangent of the radian argument `x`.
	inline atanh(float64 x) = x >= 1 ? inf : x <= -1 ? -inf : .5 * log((1 + x) / (1 - x));


	/// Returns the cotangent of the radian argument `x`.
	float64 cot(float64 x) {
		static if (preferNativeCalls && typename(float64.cot) != null) {
			// use the native method if available
			return float64.cot(x);
		}

		if (x == 0) {
			return inf;
		}
		return tancot(x, 1);
	}

	/// Returns the hyperbolic cotangent of the radian argument `x`.
	inline coth(float64 x) = 1 / tanh(x);

	/// Returns the inverse cotangent of the radian argument `x`.
	inline acot(float64 x) = x == 0 ? pi / 2 : atan(1 / x);

	/// Returns the inverse hyperbolic cotangent of the radian argument `x`.
	inline acoth(float64 x) = x == 1 ? inf : x == -1 ? -inf : .5 * log((x + 1) / (x - 1));


	/// Returns the secant of the radian argument `x`.
	inline sec(float64 x) = 1 / cos(x);

	/// Returns the hyperbolic secant of the radian argument `x`.
	inline sech(float64 x) = 1 / cosh(x);

	/// Returns the inverse secant of the radian argument `x`.
	inline asec(float64 x) = x == 0 ? inf : acos(1 / x);

	/// Returns the inverse hyperbolic secant of the radian argument `x`.
	inline asech(float64 x) = x == 0 ? inf : x == 1 ? 0 : log((sqrt(1 - x * x) + 1) / x);


	/// Returns the cosecant of the radian argument `x`.
	inline csc(float64 x) = 1 / sin(x);

	/// Returns the hyperbolic cosecant of the radian argument `x`.
	inline csch(float64 x) = 1 / sinh(x);

	/// Returns the inverse cosecant of the radian argument `x`.
	inline acsc(float64 x) = x == 0 ? inf : asin(1 / x);

	/// Returns the inverse hyperbolic cosecant of the radian argument `x`.
	inline acsch(float64 x) = x == 0 ? inf : x < 0 ? log((1 - sqrt(1 + x * x)) / x) : log((1 + sqrt(1 + x * x)) / x);


	/// Converts the input to radians from degrees.
	inline radians(float64 degrees) = float64(degrees * pi / 180);

	/// Converts the input to degrees from radians.
	inline degrees(float64 radians) = float64(radians * 180 / pi);

	// inline rand(int min, int max) = System.rand() % (max - min) + min;
	// inline rand(float64 min, float64 max) = (System.rand() / float64(System.rand.max)) * (max - min) + min;
}
/// A 4x4 matrix
struct mat4f: 0 {
	/// Access elements as an array: m[1][0]
	float32 m[4][4];

	/// Access elements as a flatten array: data[4] => m[1][0]
	float32 data[16];

	/// Access elements as an array of vectors: v[1].x => m[1][0]
	vec4f v[4];

	struct {
		/// The first row as a vector
		vec4f x;
		/// The second row as a vector
		vec4f y;
		/// The third row as a vector
		vec4f z;
		/// The fourth row as a vector
		vec4f w;
	}
	struct {
		/// The first element of the first row
		float32 xx;
		/// The second element of the first row
		float32 xy;
		/// The third element of the first row
		float32 xz;
		/// The fourth element of the first row
		float32 xw;

		/// The first element of the second row
		float32 yx;
		/// The second element of the second row
		float32 yy;
		/// The third element of the second row
		float32 yz;
		/// The fourth element of the second row
		float32 yw;

		/// The first element of the third row
		float32 zx;
		/// The second element of the third row
		float32 zy;
		/// The third element of the third row
		float32 zz;
		/// The fourth element of the third row
		float32 zw;

		/// The first element of the fourth row
		float32 wx;
		/// The second element of the fourth row
		float32 wy;
		/// The third element of the fourth row
		float32 wz;
		/// The fourth element of the fourth row
		float32 ww;
	}
}

/// Initialize all elements with the given values
mat4f mat4f(float32 xx, float32 xy, float32 xz, float32 xw,
			float32 yx, float32 yy, float32 yz, float32 yw,
			float32 zx, float32 zy, float32 zz, float32 zw,
			float32 wx, float32 wy, float32 wz, float32 ww) {
	return {
		xx: xx; xy: xy; xz: xz; xw: xw;
		yx: yx; yy: yy; yz: yz; yw: yw;
		zx: zx; zy: zy; zz: zz; zw: zw;
		wx: wx; wy: wy; wz: wz; ww: ww;
	};
}

/// Initialize matrix with row vectors
mat4f mat4f(const vec4f x&, const vec4f y&, const vec4f z&, const vec4f w&) {
	return { x: x, y: y, z: z, w: w };
}

/// Multiply with vector: dot product of the first 3 elements
inline dp3(const mat4f mat&, const vec4f vec&) = vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1f);
/// Multiply with vector: homogeneous dot product
inline dph(const mat4f mat&, const vec4f vec&) = vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
/// Multiply with vector: full dot product
inline dp4(const mat4f mat&, const vec4f vec&) = vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));

/// Transpose the matrix
mat4f transpose(const mat4f mat) {
	return {
		xx: mat.xx; xy: mat.yx; xz: mat.zx; xw: mat.wx;
		yx: mat.xy; yy: mat.yy; yz: mat.zy; yw: mat.wy;
		zx: mat.xz; zy: mat.yz; zz: mat.zz; zw: mat.wz;
		wx: mat.xw; wy: mat.yw; wz: mat.zw; ww: mat.ww;
	};
}

/// Multiply two matrices (rows * cols)
mat4f mul(const mat4f lhs&, const mat4f rhs&) {
	mat4f transposed = transpose(rhs);
	return {
		x: dp4(transposed, lhs.x);
		y: dp4(transposed, lhs.y);
		z: dp4(transposed, lhs.z);
		w: dp4(transposed, lhs.w);
	};
}

/// Build a rotation matrix
// adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas
mat4f rotation(const vec4f center&, const vec4f direction&, float32 angle) {
	float32 len = direction.length();
	if (len < 1e-9) {
		trace("invalid direction of rotation", direction);
		return {
			x: vec4f(0, 0, 0, 0);
			y: vec4f(0, 0, 0, 0);
			z: vec4f(0, 0, 0, 0);
			w: vec4f(0, 0, 0, 0);
		};
	}
	float32 x = direction.x / len;
	float32 y = direction.y / len;
	float32 z = direction.z / len;
	float32 cx = center.x;
	float32 cy = center.y;
	float32 cz = center.z;
	float32 xx = x * x;
	float32 xy = x * y;
	float32 xz = x * z;
	float32 yy = y * y;
	float32 yz = y * z;
	float32 zz = z * z;

	float32 s = Math.sin(angle);
	float32 c = Math.cos(angle);
	float32 k = 1 - c;

	return {
		xx: xx + (yy + zz) * c;
		xy: xy * k - z * s;
		xz: xz * k + y * s;
		xw: (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;

		yx: xy * k + z * s;
		yy: yy + (xx + zz) * c;
		yz: yz * k - x * s;
		yw: (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;

		zx: xz * k - y * s;
		zy: yz * k + x * s;
		zz: zz + (xx + yy) * c;
		zw: (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;

		w: vec4f(0, 0, 0, 1);
	};
}

/// Build a rotation matrix
mat4f rotation(const vec4f direction&, float angle) {
	float32 xx = direction.x * direction.x;
	float32 yy = direction.y * direction.y;
	float32 zz = direction.z * direction.z;
	float32 xy = direction.x * direction.y;
	float32 xz = direction.x * direction.z;
	float32 yz = direction.y * direction.z;
	float32 s = Math.sin(angle);
	float32 c = Math.cos(angle);
	float32 k = 1 - c;
	vec4f tmp = mul(direction, s);

	return {
		xx: k * xx + c;
		xy: k * xy - tmp.z;
		xz: k * xz + tmp.y;
		xw: 0;

		yx: k * xy + tmp.z;
		yy: k * yy + c;
		yz: k * yz - tmp.x;
		yw: 0;

		zx: k * xz - tmp.y;
		zy: k * yz + tmp.x;
		zz: k * zz + c;
		zw: 0;

		w: vec4f(0, 0, 0, 1);
	};
}

/// Build a translation matrix
mat4f translation(const vec4f direction&, float32 amount) {
	return {
		xx: 1; xy: 0; xz: 0; xw: direction.x * amount;
		yx: 0; yy: 1; yz: 0; yw: direction.y * amount;
		zx: 0; zy: 0; zz: 1; zw: direction.z * amount;
		wx: 0; wy: 0; wz: 0; ww: 1;
	};
}

/// Build a scaling matrix
mat4f scale(const vec4f direction&, float32 amount) {
	inline rcp(float32 val) = (val < 0 ? -val : val) < 1e-30 ? 0 : 1 / val;
	return {
		xx: rcp(direction.x * amount); xy: 0; xz: 0; xw: 0;
		yx: 0; yy: rcp(direction.y * amount); yz: 0; yw: 0;
		zx: 0; zy: 0; zz: rcp(direction.z * amount); zw: 0;
		wx: 0; wy: 0; wz: 0; ww: 1;
	};
}

/// Build the inverse of the matrix
// adapted from: https://github.com/glslify/glsl-inverse/blob/master/index.glsl
mat4f inverse(const mat4f mat&) {
	float32 a00 = mat.xx;
	float32 a01 = mat.xy;
	float32 a02 = mat.xz;
	float32 a03 = mat.xw;

	float32 a10 = mat.yx;
	float32 a11 = mat.yy;
	float32 a12 = mat.yz;
	float32 a13 = mat.yw;

	float32 a20 = mat.zx;
	float32 a21 = mat.zy;
	float32 a22 = mat.zz;
	float32 a23 = mat.zw;

	float32 a30 = mat.wx;
	float32 a31 = mat.wy;
	float32 a32 = mat.wz;
	float32 a33 = mat.ww;

	float32 b00 = a00 * a11 - a01 * a10;
	float32 b01 = a00 * a12 - a02 * a10;
	float32 b02 = a00 * a13 - a03 * a10;
	float32 b03 = a01 * a12 - a02 * a11;
	float32 b04 = a01 * a13 - a03 * a11;
	float32 b05 = a02 * a13 - a03 * a12;
	float32 b06 = a20 * a31 - a21 * a30;
	float32 b07 = a20 * a32 - a22 * a30;
	float32 b08 = a20 * a33 - a23 * a30;
	float32 b09 = a21 * a32 - a22 * a31;
	float32 b10 = a21 * a33 - a23 * a31;
	float32 b11 = a22 * a33 - a23 * a32;

	float32 det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	return {
		xx: (a11 * b11 - a12 * b10 + a13 * b09) / det;
		xy: (a02 * b10 - a01 * b11 - a03 * b09) / det;
		xz: (a31 * b05 - a32 * b04 + a33 * b03) / det;
		xw: (a22 * b04 - a21 * b05 - a23 * b03) / det;
		yx: (a12 * b08 - a10 * b11 - a13 * b07) / det;
		yy: (a00 * b11 - a02 * b08 + a03 * b07) / det;
		yz: (a32 * b02 - a30 * b05 - a33 * b01) / det;
		yw: (a20 * b05 - a22 * b02 + a23 * b01) / det;
		zx: (a10 * b10 - a11 * b08 + a13 * b06) / det;
		zy: (a01 * b08 - a00 * b10 - a03 * b06) / det;
		zz: (a30 * b04 - a31 * b02 + a33 * b00) / det;
		zw: (a21 * b02 - a20 * b04 - a23 * b00) / det;
		wx: (a11 * b07 - a10 * b09 - a12 * b06) / det;
		wy: (a00 * b09 - a01 * b07 + a02 * b06) / det;
		wz: (a31 * b01 - a30 * b03 - a32 * b00) / det;
		ww: (a20 * b03 - a21 * b01 + a22 * b00) / det;
	};
}
/// Perlin noise generator
static struct Perlin {
	inline B = 0x100;
	inline BM = 0xff;
	inline N = 0x1000;
	inline NP = 12;   // 2^N
	inline NM = 0xfff;

	int p[B + B + 2];
	float g3[B + B + 2][3];
	float g2[B + B + 2][2];
	float g1[B + B + 2];

	bool start = true;

	inline sqr(float x) = float(x * x);

	void init() {
		int i;
		System.srand(System.time());
		for (i = 0; i < B ; i += 1) {
			p[i] = i;

			g1[i] = float((System.rand() % (B + B)) - B) / B;

			for (int j = 0 ; j < 2 ; j += 1) {
				g2[i][j] = float((System.rand() % (B + B)) - B) / B;
			}

			//~ normalize2(g2[i]);
			float n2 = Math.sqrt(sqr(g2[i][0]) + sqr(g2[i][1]));
			if (n2 != 0) {
				g2[i][0] /= n2;
				g2[i][1] /= n2;
			}

			for (int j = 0 ; j < 3 ; j += 1) {
				g3[i][j] = float((System.rand() % (B + B)) - B) / B;
			}

			//~ normalize3(g3[i]);
			float n3 = Math.sqrt(sqr(g3[i][0]) + sqr(g3[i][1]) + sqr(g3[i][1]));
			if (n3 != 0) {
				g3[i][0] /= n3;
				g3[i][1] /= n3;
				g3[i][2] /= n3;
			}
		}

		for ( ; i -= 1; ) {
			int k = p[i];
			int j = System.rand() % B;
			p[i] = p[j];
			p[j] = k;
		}

		for (i = 0 ; i < B + 2 ; i += 1) {
			p[B + i] = p[i];
			g1[B + i] = g1[i];
			for (int j = 0 ; j < 2 ; j += 1) {
				g2[B + i][j] = g2[i][j];
			}
			for (int j = 0 ; j < 3 ; j += 1) {
				g3[B + i][j] = g3[i][j];
			}
		}
	}

	void setup(float vec_i, int b0&, int b1&, float r0&,float r1&) {
		float t = vec_i + N;
		b0 = int(t) & BM;
		b1 = (b0 + 1) & BM;
		r0 = t - int(t);
		r1 = r0 - 1.;
	}

	inline smooth(float32 t) = Math.smooth(t);
	inline lerp(float32 t, float32 a, float32 b) = Math.lerp(t, a, b);

	inline at2(float rx, float ry, int i) = float(rx * g2[i][0] + ry * g2[i][1]);
	inline at3(float rx, float ry, float rz, int i) = float(rx * g3[i][0] + ry * g3[i][1] + rz * g3[i][2]);

	float noise1f(float x) {
		int bx0;
		int bx1;
		float rx0;
		float rx1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);

		float sx = smooth(rx0);
		float u = rx0 * g1[p[bx0]];
		float v = rx1 * g1[p[bx1]];

		return lerp(sx, u, v);
	}
	float noise2f(float x, float y) {
		int bx0;
		int bx1;
		int by0;
		int by1;
		float rx0;
		float rx1;
		float ry0;
		float ry1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);
		setup(y, &by0, &by1, &ry0, &ry1);

		int i = p[ bx0 ];
		int j = p[ bx1 ];

		int b00 = p[ i + by0 ];
		int b10 = p[ j + by0 ];
		int b01 = p[ i + by1 ];
		int b11 = p[ j + by1 ];

		float sx = smooth(rx0);
		float sy = smooth(ry0);

		float a = lerp(sx, at2(rx0, ry0, b00), at2(rx1, ry0, b10));
		float b = lerp(sx, at2(rx0, ry1, b01), at2(rx1, ry1, b11));

		return lerp(sy, a, b);
	}
	float noise3f(float x, float y, float z) {

		int bx0;
		int bx1;
		int by0;
		int by1;
		int bz0;
		int bz1;
		float rx0;
		float rx1;
		float ry0;
		float ry1;
		float rz0;
		float rz1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);
		setup(y, &by0, &by1, &ry0, &ry1);
		setup(z, &bz0, &bz1, &rz0, &rz1);

		int i = p[ bx0 ];
		int j = p[ bx1 ];

		int b00 = p[ i + by0 ];
		int b10 = p[ j + by0 ];
		int b01 = p[ i + by1 ];
		int b11 = p[ j + by1 ];

		float sx = smooth(rx0);
		float sy = smooth(ry0);
		float sz = smooth(rz0);

		float a;
		float b;
		float c;
		float d;
		float u;
		float v;

		u = at3(rx0, ry0, rz0, b00 + bz0);
		v = at3(rx1, ry0, rz0, b10 + bz0);
		a = lerp(sx, u, v);

		u = at3(rx0, ry1, rz0, b01 + bz0);
		v = at3(rx1, ry1, rz0, b11 + bz0);
		b = lerp(sx, u, v);

		c = lerp(sy, a, b);

		u = at3(rx0, ry0, rz1, b00 + bz1);
		v = at3(rx1, ry0, rz1, b10 + bz1);
		a = lerp(sx, u, v);

		u = at3(rx0, ry1, rz1, b01 + bz1);
		v = at3(rx1, ry1, rz1, b11 + bz1);
		b = lerp(sx, u, v);

		d = lerp(sy, a, b);

		return lerp(sz, c, d);
	}

	inline noise(float x) = noise1f(x);
	inline noise(float x, float y) = noise2f(x, y);
	inline noise(float x, float y, float z) = noise3f(x, y, z);
}
inline scalar = float64;  // fixme: declare inside Polynomial

///@public
struct Polynomial/*(typename scalar)*/: TextWriter.Writeable {
	scalar coefficients[*];
	int capacity;

	enum: scalar {
		c_zero: 0;
		c_unit: 1;
	}

	// Formatted printing of the polynomial to the text writer
	void write(Polynomial this, TextWriter writer) {
		bool first = true;
		for (int i = this.capacity - 1; i >= 0; i -= 1) {
			if (this.coefficients[i] == c_zero && !(first && i == 0)) {
				continue;
			}

			scalar value = this.coefficients[i];
			if (value < c_zero) {
				value = -value;
				if (!first) {
					// binary operator
					writer.write(" - ");
				}
				else {
					// unary operator
					writer.write("-");
				}
			}
			else if (!first) {
				// binary operator
				writer.write(" + ");
			}

			if (value != c_unit || i == 0) {
				writer.write(value, writer.format);
			}

			if (i > 0) {
				writer.write("x");
				if (i > 1) {
					writer.write("^");
					writer.write(i, writer.format);
				}
			}
			first = false;
		}
	}

	/// Dispose the polynomial, free up used memory for coefficients
	void destroy(Polynomial this) {
		pointer.alloc(this.coefficients, 0);
	}

	// Construct a new instance
	static Polynomial create(int degree, scalar values[]) {
		int capacity = Math.max(0, degree) + 1;
		assert(capacity >= values.length);
		scalar coefficients[*] = pointer.alloc(null, capacity * sizeof(scalar));
		Polynomial result = {
			// fixme: coefficients: pointer.alloc(null, capacity * sizeof(scalar));
			coefficients: coefficients;
			capacity: capacity;
		};

		for (int i = 0; i < values.length; i += 1) {
			result.coefficients[i] = values[i];
		}
		for (int i = values.length; i < capacity; i += 1) {
			result.coefficients[i] = c_zero;
		}
		return result;
	}

	/// Compute the degree of the polynomial
	static int degree(Polynomial this&) {
		for (int i = this.capacity - 1; i > 0; i -= 1) {
			if (this.coefficients[i] != c_zero) {
				return i;
			}
		}
		return 0;
	}

	/// Get the nth coefficient of the polynomial
	static scalar get(const Polynomial this&, int index) {
		assert(index >= 0, "negative index", index);
		if (index >= this.capacity) {
			return c_zero;
		}
		return this.coefficients[index];
	}

	/// Set the nth coefficient of the polynomial
	static scalar set(Polynomial this&, int index, scalar value) {
		assert(index >= 0, "negative index", index);
		assert(index < this.capacity, "invalid index");
		return this.coefficients[index];
	}

	/// Negate the polynomial
	static Polynomial neg(const Polynomial a&) {
		Polynomial result = create(degree(a), null);
		for (int i = 0; i < result.capacity; i += 1) {
			result.coefficients[i] = -a.get(i);
		}
		return result;
	}

	/// Add two polynomials
	static Polynomial add(const Polynomial a&, const Polynomial b&) {
		Polynomial result = create(Math.max(degree(a), degree(b)), null);
		for (int i = 0; i < result.capacity; i += 1) {
			result.coefficients[i] = a.get(i) + b.get(i);
		}
		return result;
	}

	/// Subtract two polynomials
	static Polynomial sub(const Polynomial a&, const Polynomial b&) {
		Polynomial result = create(Math.max(degree(a), degree(b)), null);
		for (int i = 0; i < result.capacity; i += 1) {
			result.coefficients[i] = a.get(i) - b.get(i);
		}
		return result;
	}

	/// Multiply two polynomials
	static Polynomial mul(const Polynomial a&, const Polynomial b&) {
		int degreeA = degree(a);
		int degreeB = degree(b);
		Polynomial result = create(degreeA + degreeB, null);
		for (int i = 0; i <= degreeA; i += 1) {
			for (int j = 0; j <= degreeB; j += 1) {
				result.coefficients[i + j] += a.get(i) * b.get(j);
			}
		}
		return result;
	}

	/// Evaluate the polynomial using Horner's method
	static scalar evaluate(const Polynomial this&, scalar value) {
		scalar result = c_zero;
		for (int i = degree(this); i >= 0; i -= 1) {
			result = result * value + this.coefficients[i];
		}
		return result;
	}

	/// Compute the derivative of the polynomial
	static Polynomial derivative(const Polynomial this&) {
		Polynomial result = create(this.degree() - 1, null);
		for (int i = 0; i < result.capacity; i += 1) {
			result.coefficients[i] = (i + 1) * this.coefficients[i + 1];
		}
		return result;
	}

	/// Compute the integral of the polynomial
	static Polynomial integral(const Polynomial this&, scalar c) {
		Polynomial result = create(this.degree() + 1, null);
		result.coefficients[0] = c;
		for (int i = 1; i < result.capacity; i += 1) {
			result.coefficients[i] = this.coefficients[i - 1] / i;
		}
		return result;
	}
}

/// Create a new polynomial by copying the given one.
inline Polynomial(const Polynomial copy&) = Polynomial.create(copy.degree(), copy.coefficients);

/// Create a new polynomial with the given values, coefficients are reversed(lowest index === highest degree)
Polynomial Polynomial(scalar values...) {
	Polynomial result = Polynomial.create(values.length - 1, null);
	for (int i = 0; i < values.length; i += 1) {
		result.coefficients[i] = values[values.length - i - 1];
	}
	return result;
}
/// A 2d vector (2x float64)
struct vec2d: 0 {
	struct {
		/// X component of the vector
		float64 x;
		/// Y component of the vector
		float64 y;
	}
	/// Access the components as an array
	float64 data[2];
}

/// Initialize with given x, y components
vec2d vec2d(float64 x, float64 y) {
	return {
		x: x;
		y: y;
	};
}

/// Component wise add the two vectors.
inline add(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), add.p2d));

/// Component wise subtract the two vectors.
inline sub(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), sub.p2d));

/// Component wise multiply the two vectors.
inline mul(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), mul.p2d));

/// Component wise divide the two vectors.
inline div(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), div.p2d));

/// Component wise select the minimum from the two vectors.
inline min(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), min.p2d));

/// Component wise select the maximum from the two vectors.
inline max(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), max.p2d));

/// Compare the two vectors for equality.
inline ceq(vec2d a, vec2d b) = vec2d(emit(struct(a), struct(b), ceq.p2d));

/// Dot product of thw two vectors
inline dot(const vec2d a&, const vec2d b&) = a.x * b.x + a.y * b.y;
/// A 4d vector (4x float32)
struct vec4f: 0 {
	struct {
		/// X component of the vector
		float32 x;
		/// Y component of the vector
		float32 y;
		/// Z component of the vector
		float32 z;
		/// W component of the vector
		float32 w;
	}
	/// Access the components as an array
	float32 data[4];
}

/* TODO: implement inline initializer
// constructing a vector
inline vec4f(float32 x, float32 y, float32 z, float32 w) = { x: x, y: y, z: z, w: w };
inline vec4f(float32 x, float32 y, float32 z) = { x: x, y: y, z: z, w: 0 };
inline vec4f(const vec4f v&, float32 w) = { x: v.x, y: v.y, z: v.z, w: w };
inline vec4f(const float32 val&) = { x: val, y: val, z: val, w: val };
*/

/// Initialize with given x, y, z, w components
inline vec4f(float32 x, float32 y, float32 z, float32 w) = vec4f(emit(struct(w), struct(z), struct(y), struct(x)));

/// Initialize with  (x: x, y: y, z: z, w: 1)
inline vec4f(float32 x, float32 y, float32 z) = vec4f(x, y, z, 1f);

/// Initialize with (x: x, y: y, z: 0, w: 1)
inline vec4f(float32 x, float32 y) = vec4f(x, y, 0f, 1f);

/// Initialize x, y, z components using the components form the given vector, and w with the given value
inline vec4f(vec4f xyz, float32 w) = vec4f(xyz.x, xyz.y, xyz.z, w);

/// Initialize x, y, z, w components with the given scalar value
inline vec4f(float32 val) = vec4f(val, val, val, val);

/* TODO: implement operator overloading
//~ -a => vec4f(-a.x, -a.y, -a.z, -a.w);
inline -(vec4f rhs) = vec4f(emit(struct(rhs), neg.p4f));

//~ a + b => vec4f(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
inline +(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), add.p4f));

//~ a - b => vec4f(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
inline -(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), sub.p4f));

//~ a * b => vec4f(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
inline *(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), mul.p4f));

//~ a / b => vec4f(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
inline /(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), div.p4f));

inline +(vec4f a, float32 b) = a + vec4f(b);
inline +(float32 a, vec4f b) = vec4f(a) + b;
inline -(vec4f a, float32 b) = a - vec4f(b);
inline -(float32 a, vec4f b) = vec4f(a) - b;
inline *(vec4f a, float32 b) = a * vec4f(b);
inline *(float32 a, vec4f b) = vec4f(a) * b;
inline /(vec4f a, float32 b) = a / vec4f(b);
inline /(float32 a, vec4f b) = vec4f(a) / b;

inline normalize(vec4f v) = v / len(v);
*/

/// Returns a negated copy of the vector.
inline neg(vec4f rhs) = vec4f(emit(struct(rhs), neg.p4f));
/// Component wise add the two vectors.
inline add(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), add.p4f));
/// Component wise subtract the two vectors.
inline sub(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
/// Component wise multiply the two vectors.
inline mul(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
/// Component wise divide the two vectors.
inline div(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), div.p4f));

/// Component wise add vector and scalar.
inline add(float32 a, vec4f b) = add(vec4f(a), b);
/// Component wise add vector and scalar.
inline add(vec4f a, float32 b) = add(a, vec4f(b));

/// Component wise subtract vector and scalar.
inline sub(float32 a, vec4f b) = sub(vec4f(a), b);
/// Component wise subtract vector and scalar.
inline sub(vec4f a, float32 b) = sub(a, vec4f(b));

/// Component wise multiply vector and scalar.
inline mul(float32 a, vec4f b) = mul(vec4f(a), b);
/// Component wise multiply vector and scalar.
inline mul(vec4f a, float32 b) = mul(a, vec4f(b));

/// Component wise divide vector and scalar.
inline div(float32 a, vec4f b) = div(vec4f(a), b);
/// Component wise divide vector and scalar.
inline div(vec4f a, float32 b) = div(a, vec4f(b));

/// Component wise absolute value of a vector.
inline abs(vec4f a) = vec4f(Math.abs(a.x), Math.abs(a.y), Math.abs(a.z), Math.abs(a.w));

/// Component wise minimum of the two vectors.
inline min(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), min.p4f));
/// Component wise maximum of the two vectors.
inline max(vec4f lhs, vec4f rhs) = vec4f(emit(struct(lhs), struct(rhs), max.p4f));

/// Clamp the vector component wise to the range [min ... max]
inline clamp(vec4f vec, vec4f min, vec4f max) = min(max(vec, min), max);

/// Clamp each component of the vector to the range [min ... max]
inline clamp(vec4f vec, float32 min, float32 max) = clamp(vec, vec4f(min), vec4f(max));

/// linear interpolate
inline mix(vec4f a, vec4f b, float32 t) = vec4f(
	Math.mix(a.x, b.x, t),
	Math.mix(a.y, b.y, t),
	Math.mix(a.z, b.z, t),
	Math.mix(a.w, b.w, t)
);

/// Dot product of the first 3 elements
// inline dp3(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z;
inline dp3(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dp3));

/// Homogeneous dot product
// inline dph(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z + a.w;
inline dph(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dph));

/// Dot product
// inline dp4(const vec4f a&, const vec4f b&) = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
inline dp4(vec4f lhs, vec4f rhs) = float32(emit(struct(lhs), struct(rhs), p4x.dp4));

/// Cross product of the first 3 elements
inline cross(const vec4f a&, const vec4f b&) = vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);

/// Length of the vector(xyz)
inline length(vec4f v) = Math.sqrt(dp3(v, v));
/// Normalize the vector(xyz)
inline normalize(const vec4f v&) = div(v, vec4f(length(v)));

/// Evaluate as a polynomial in point x
inline eval(const vec4f v&, float32 x) = float32((((v.w * x + v.z) * x + v.y) * x) + v.x);

/* TODO: leftovers
inline ceq(vec4f x, vec4f y) = emit(ceq.p4f, vec4f(y), vec4f(x));
inline mad(vec4f a, vec4f b, vec4f c) = emit(vec4f, add.p4f, mul.p4f, vec4f(a), vec4f(b), vec4f(c));	// a * b + c

inline lerp(float32 t, vec4f lhs, vec4f rhs) = vec4f(Math.lerp(t, lhs.x, rhs.x), Math.lerp(t, lhs.y, rhs.y), Math.lerp(t, lhs.z, rhs.z), Math.lerp(t, lhs.w, rhs.w));

inline float32(vec4f &vec) = float32(vec.w);
inline bool(vec4f vec) = bool(vec.x && vec.y && vec.z && vec.w);
*/
/// Flags to convert numbers to string
struct FormatFlags {
	/// forced show sign '+' or '-'
	const char sign = 0;

	/// padding character: usually '0' or space
	const char padChr = 0;

	/// padding length
	const int width = 0;

	/// precision length
	const int precision = 10;

	/// trim extra `0` decimal digits
	const bool trimDecimal = true;

	/// read and process c style format flags like: "%02d"
	static FormatFlags read(const char format[], int pos&) {
		int chr = format[pos];
		if (chr != '%') {
			return {};
		}

		pos += 1;
		chr = format[pos];

		if (chr == '%') {
			return {};
		}

		int sgnChr = 0;
		if (chr == '-' || chr == '+') {
			pos += 1;
			sgnChr = chr;
			chr = format[pos];
		}

		int padChr = ' ';
		if (chr == '0') {
			pos += 1;
			padChr = chr;
			chr = format[pos];
		}

		int padLen = 0;
		for (;chr >= '0' && chr <= '9';) {
			pos += 1;
			padLen = padLen * 10 + chr - '0';
			chr = format[pos];
		}

		int precision = 0;
		if (chr == '.') {
			pos += 1;
			chr = format[pos];
			for (;chr >= '0' && chr <= '9';) {
				pos += 1;
				precision = precision * 10 + chr - '0';
				chr = format[pos];
			}
		}

		return {
			sign: sgnChr;
			width: padLen;
			padChr: padChr;
			precision: precision;
		};
	}

	/// override the default padding, in case it's length is zero
	static FormatFlags defPad(const FormatFlags this&, int width, char padChr) {
		if (this.width == 0) {
			return {
				sign: this.sign;
				precision: this.precision;
				padChr: padChr;
				width: width;
			};
		}
		return this;
	}
}

/// Append a string to the output at the given position
int append(char output[], int pos, const char value[*]) {
	if (value == null) {
		return append(output, pos, "NULL");
	}
	for (int i = 0; value[i]; i += 1) {
		if (pos >= output.length) {
			break;
		}
		output[pos] = value[i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

/// Append a number to the output at the given position
int append(char output[], int pos, int radix, uint64 value, const FormatFlags format&) {
	static const char whiteSpace[] = " \t\n\r";
	static const char radixDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz";

	int len = 0;
	char digits[80] = {};

	assert(radix > 1, "radix is too small", radix);
	assert(radix < radixDigits.length, "radix is too big", radix);

	// print digits in reverse order
	for ( ; value > 0; value /= radix) {
		digits[len += 1] = radixDigits[value % radix];
	}
	if (len == 0) {
		digits[len += 1] = '0';
	}

	int maxLen = format.width - len;

	char padChr = format.padChr;
	if (padChr == '\0') {
		padChr = ' ';
	}

	// print sign value
	if (format.sign != 0) {
		maxLen -= 1;
		if (whiteSpace.contains(padChr)) {
			// if padding character is whitespace pad before sign
			for ( ; maxLen > 0; maxLen -= 1) {
				assert(pos < output.length);
				output[pos] = padChr;
				pos += 1;
			}
		}
		assert(pos < output.length);
		output[pos] = format.sign;
		pos += 1;
	}

	// print padding
	for ( ; maxLen > 0; maxLen -= 1) {
		assert(pos < output.length);
		output[pos] = padChr;
		pos += 1;
	}

	// print digits
	for (int i = 0; i < len; i += 1) {
		assert(i < output.length);
		output[pos] = digits[len - i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

/// Append a number to the output at the given position
int append(char output[], int pos, int radix, int64 value, const FormatFlags format&) {
	if (value < 0 /*&& value != -value*/) {
		FormatFlags signedFormat = {
			sign: '-';
			padChr: format.padChr;
			width: format.width;
			precision: format.precision;
		};
		return append(output, pos, radix, uint64(-value), signedFormat);
	}
	return append(output, pos, radix, uint64(value), format);
}

/// Append a number to the output at the given position
int append(char output[], int pos, float64 value, const FormatFlags format&) {
	FormatFlags formatInt = {
		sign: value < 0 ? '-' : format.sign;
		padChr: format.padChr;
		width: format.width - format.precision - 1;
	};

	int end = pos + format.width;
	if (end >= output.length) {
		end = output.length - 1;
	}

	const int beg = pos;
	float64 fraction = Math.modf(Math.abs(value), &value);

	// todo: integer part might not fit into int64
	pos = output.append(pos, 10, uint64(int64(value)), formatInt);

	// add fractional part
	int dotIndex = pos;
	pos = output.append(pos, ".");
	end = Math.max(end, pos + format.precision);
	if (end >= output.length) {
		end = output.length - 1;
	}

	// roundup
	fraction += Math.pow(10., float64(pos - end)) / 2;
	// todo: more precision, don't rewrite the whole integer part
	if (fraction >= 1) {
		fraction %= 1;
		pos = output.append(beg, 10, uint64(int64(value + 1)), formatInt);
		dotIndex = pos;
		pos = output.append(pos, ".");
		end = Math.max(end, pos + format.precision);
		if (end >= output.length) {
			end = output.length - 1;
		}
	}

	for (; pos < end; pos += 1) {
		fraction = Math.modf(fraction * 10, &value);
		output[pos] = '0' + int(value);
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}

	if (!format.trimDecimal) {
		output[pos] = 0;
		return pos;
	}

	// scan backwards all zeroes
	for (int i = pos - 1; i >= dotIndex; i -= 1) {
		if (output[i] != '0') {
			if (i == dotIndex) {
				// remove also the dot
				output[i] = 0;
				return i;
			}
			output[i + 1] = 0;
			return i + 1;
		}
	}

	return pos;
}

/// Append a number to the output at the given position
inline append(char output[], int pos, uint64 value, const FormatFlags format&) = append(output, pos, 10, uint64(value), format);

/// Append a number to the output at the given position
inline append(char output[], int pos, uint32 value, const FormatFlags format&) = append(output, pos, 10, uint64(value), format);

/// Append a number to the output at the given position
inline append(char output[], int pos, uint16 value, const FormatFlags format&) = append(output, pos, 10, uint64(value), format);

/// Append a number to the output at the given position
inline append(char output[], int pos, uint8 value, const FormatFlags format&) = append(output, pos, 10, uint64(value), format);

/// Append a number to the output at the given position
inline append(char output[], int pos, int64 value, const FormatFlags format&) = append(output, pos, 10, int64(value), format);

/// Append a number to the output at the given position
inline append(char output[], int pos, int32 value, const FormatFlags format&) = append(output, pos, 10, int64(value), format);

/// Append a number to the output at the given position
inline append(char output[], int pos, int16 value, const FormatFlags format&) = append(output, pos, 10, int64(value), format);

/// Append a number to the output at the given position
inline append(char output[], int pos, int8 value, const FormatFlags format&) = append(output, pos, 10, int64(value), format);

/// Append a number to the output at the given position
inline append(char output[], int pos, float32 value, const FormatFlags format&) = append(output, pos, float64(value), format);

/* todo: replace FormatFlags with NumberFormat
struct NumberFormat {
	const char digitSymbols[] = "0123456789"; // binary: "01", decimal: "0123456789", hexadecimal: "0123456789abcdef"
	const char negativePrefix = '-';
	const char positivePrefix = '+';
	const char decimalSeparator = '.';
	const char digitGroupSymbol = '\'';

//	const char signPrefix = 0;
	const char decimalPlaces = 2;
	const char digitGrouping = 0;	// 0: "123456789", 3: "123'456'789", 32: "12'34'56'789"
	const bool leadingZeros = false; // false: ".7", true: "0.7"
	const bool trailingZeros = false; // false: "0.7", true: ".70"
	const bool trailingSeparator = false; // false: "6", true: "6."
}*/

/// datetime regional formatter, currently 'en' if instantiated with: `DatetimeFormat fmt = {};`
struct DatetimeFormat {
	// todo Calendar calendar = Calendar.Gregorian;
	// todo Weekday firstDay = Weekday.Monday;
	// todo Timezone timezone = Timezone(System.locale);
	const char monthsLong[][];
	const char monthsShort[][];
	const char weeksLong[][];
	const char weeksShort[][];
	const char amPmUpper[][];
	const char amPmLower[][];
	const char dateLong[] = "%A %d %B %Y";
	const char timeLong[] = "%r";
	const char dateShort[] = "%x";
	const char timeShort[] = "%I:%M %p";

	static int format(const DatetimeFormat formatter&, char output[], int end, const Datetime value&, const char format[]) {
		inline hours24to12(int hour) = hour > 12 ? hour - 12 : hour == 0 ? 12 : hour;

		if (pointer(format) == null) {
			return formatter.format(output, end, value, "%Y.%m.%d");
		}

		char chr = 0;
		for (int pos = 0; pos < format.length; pos += 1) {
			if (end >= output.length) {
				output[output.length - 1] = 0;
				return output.length - 1;
			}

			chr = format[pos];
			if (chr != '%') {
				output[end] = chr;
				end += 1;
				continue;
			}

			FormatFlags flags = FormatFlags.read(format, &pos);
			chr = format[pos];

			if (chr == '%') {
				end = append(output, end, "%");
			}
			else if (chr == 'a') {
				// %a     locale's abbreviated weekday name (e.g., en_US: [Sun, Mon, ..., Sat]; de_DE: [So, Mo, ..., Sa])
				end = append(output, end, formatter.weeksShort[indexOf(value.dayOfWeek)]);
			}
			else if (chr == 'A') {
				// %A     locale's full weekday name (e.g., en_US: [Sunday, ..., Saturday]; de_DE: [Sonntag, ..., Samstag])
				end = append(output, end, formatter.weeksLong[indexOf(value.dayOfWeek)]);
			}
			else if (chr == 'b') {
				// %b     locale's abbreviated month name (e.g., en_US: [Jan, Feb, ..., Dec]; de_DE: [Jan, Feb, ..., Dez])
				end = append(output, end, formatter.monthsShort[indexOf(value.month)]);
			}
			else if (chr == 'B') {
				// %B     locale's full month name (e.g., en_US: [January, ..., December];de_DE: [Januar, ..., Dezember])
				end = append(output, end, formatter.monthsLong[indexOf(value.month)]);
			}
//			else if (chr == 'c') // todo: %c     locale's date and time (e.g., Thu Mar  3 23:05:25 2005)
			else if (chr == 'C') {
				// %C     century; like %Y, except omit last two digits (e.g., 20)
				end = append(output, end, value.year / 100, flags.defPad(2, '0'));
			}
			else if (chr == 'd') {
				// %d     day of month (e.g., 01)
				end = append(output, end, value.day, flags.defPad(2, '0'));
			}
			else if (chr == 'D') {
				// %D     date; same as %m/%d/%y
				end = formatter.format(output, end, value, "%m/%d/%y");
			}
			else if (chr == 'e') {
				// %e     day of month, space padded; same as %_d
				end = append(output, end, value.day, flags.defPad(2, ' '));
			}
			else if (chr == 'F') {
				// %F     full date; like %+4Y-%m-%d
				end = formatter.format(output, end, value, "%04Y-%m-%d");
			}
//			else if (chr == 'g') // todo: %g     last two digits of year of ISO week number (see %G)
//			else if (chr == 'G') // todo: %G     year of ISO week number (see %V); normally useful only with %V
			else if (chr == 'h') {
				// %h     same as %b
				end = append(output, end, formatter.monthsShort[indexOf(value.month)]);
			}
			else if (chr == 'H') {
				// %H     hour (00..23)
				end = append(output, end, value.hour, flags.defPad(2, '0'));
			}
			else if (chr == 'I') {
				// %I     hour (01..12)
				end = append(output, end, hours24to12(value.hour), flags.defPad(2, '0'));
			}
			else if (chr == 'j') {
				// %j     day of year (001..366)
				end = append(output, end, value.dayOfYear, flags.defPad(3, '0'));
			}
			else if (chr == 'k') {
				// %k     hour, space padded ( 0..23); same as %_H
				end = append(output, end, value.hour, flags.defPad(2, ' '));
			}
			else if (chr == 'l') {
				// %l     hour, space padded ( 1..12); same as %_I
				end = append(output, end, hours24to12(value.hour), flags.defPad(2, ' '));
			}
			else if (chr == 'm') {
				// %m     month (01..12)
				end = append(output, end, indexOf(value.month) + 1, flags.defPad(2, '0'));
			}
			else if (chr == 'M') {
				// %M     minute (00..59)
				end = append(output, end, value.minute, flags.defPad(2, '0'));
			}
			else if (chr == 'n') {
				// %n     a newline
				end = append(output, end, "\n");
			}
			else if (chr == 'N') {
				// fixme: precision
				// %N     nanoseconds (000000000..999999999)
				end = append(output, end, value.millis * 1000000, flags.defPad(9, '0'));
			}
			else if (chr == 'p') {
				// %p     locale's equivalent of either AM or PM; blank if not known
				end = append(output, end, formatter.amPmUpper[int(value.hour < 12)]);
			}
			else if (chr == 'P') {
				// %P     like %p, but lower case
				end = append(output, end, formatter.amPmLower[int(value.hour < 12)]);
			}
//			else if (chr == 'q') // todo: %q     quarter of year (1..4)
//			else if (chr == 'r') // todo: %r     locale's 12-hour clock time (e.g., 11:11:04 PM)
			else if (chr == 'R') {
				// %R     24-hour hour and minute; same as %H:%M
				end = formatter.format(output, end, value, "%H:%M");
			}
			else if (chr == 's') {
				// %s     seconds since 1970-01-01 00:00:00 UTC
				end = append(output, end, Timestamp(value).value(Timeunit.Seconds), flags);
			}
			else if (chr == 'S') {
				// %S     second (00..60)
				end = append(output, end, value.second, flags.defPad(2, '0'));
			}
			else if (chr == 't') {
				// %t     a tab
				end = append(output, end, "\t");
			}
			else if (chr == 'T') {
				// %T     time; same as %H:%M:%S
				end = formatter.format(output, end, value, "%H:%M:%S");
			}
			else if (chr == 'u') {
				// %u     day of week (1..7); 1 is Monday
				end = append(output, end, indexOf(value.dayOfWeek) + 1, flags);
			}
//			else if (chr == 'U') // todo: %U     week number of year, with Sunday as first day of week (00..53)
//			else if (chr == 'V') // todo: %V     ISO week number, with Monday as first day of week (01..53)
//			else if (chr == 'w') // todo: %w     day of week (0..6); 0 is Sunday
			else if (chr == 'W') {
				// %W     week number of year, with Monday as first day of week (00..53)
				end = append(output, end, value.weekOfYear, flags.defPad(2, '0'));
			}
			else if (chr == 'x') {
				// %x     locale's date representation (e.g., 12/31/99)
				end = formatter.format(output, end, value, formatter.dateShort);
			}
			else if (chr == 'X') {
				// %X     locale's time representation (e.g., 23:13:48)
				end = formatter.format(output, end, value, formatter.timeShort);
			}
			else if (chr == 'y') {
				// %y     last two digits of year (00..99)
				end = append(output, end, value.year % 100, flags.defPad(2, '0'));
			}
			else if (chr == 'Y') {
				// %Y     year
				end = append(output, end, value.year, flags);
			}
//			else if (chr == 'z') // todo: %z     +hhmm numeric time zone (e.g., -0400)
//			else if (chr == '?') // todo: %:z    +hh:mm numeric time zone (e.g., -04:00)
//			else if (chr == '?') // todo: %::z   +hh:mm:ss numeric time zone (e.g., -04:00:00)
//			else if (chr == '?') // todo: %:::z  numeric time zone with : to necessary precision (e.g., -04, +05:30)
//			else if (chr == 'Z') // todo: %Z     alphabetic time zone abbreviation (e.g., EDT)
			else {
				abort("unimplemented or invalid format character", chr);
			}
		}

		if (end >= output.length) {
			end = output.length - 1;
		}
		output[end] = 0;
		return end;
	}

	/** Format date to text
	 * @param value date to format
	 * @param output write output to this buffer
	 * @param format format string
	 *  	@null defaults to: "%Y.%m.%d"
	 */
	// see: https://man7.org/linux/man-pages/man1/date.1.html
	static int format(const DatetimeFormat formatter&, char output[], const Datetime value&, const char format[]) {
		return formatter.format(output, 0, value, format);
	}
}

/// extension method for backward compatibility, using english region
static int format(const Datetime value&, char output[], const char format[]) {
	static const char monthsLongEn[][] = {
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December",
	};
	static const char monthsShortEn[][] = {
		"Jan", "Feb", "Mar", "Apr",
		"May", "Jun", "Jul", "Aug",
		"Sep", "Oct", "Nov", "Dec",
	};
	static const char weeksLongEn[][] = {
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday",
		"Sunday",
	};
	static const char weeksShortEn[][] = {
		"Mon", "Tue", "Wed",
		"Thu", "Fri", "Sat",
		"Sun",
	};
	static const char amPmUpperEn[][] = {
		"AM",
		"PM"
	};
	static const char amPmLowerEn[][] = {
		"am",
		"pm"
	};

	static const DatetimeFormat fmtEN = {
		monthsLong: monthsLongEn;
		monthsShort: monthsShortEn;
		weeksLong: weeksLongEn;
		weeksShort: weeksShortEn;
		amPmUpper: amPmUpperEn;
		amPmLower: amPmLowerEn;
	};
	return fmtEN.format(output, value, format);
}


/// Append a number to the output at the given position
int append(char output[], int pos, int value) {
	static const FormatFlags format = {};
	return append(output, pos, value, format);
}
// string related functions

/// Computes the length of the string
int length(const char str[*]) {
	if (str == null) {
		return 0;
	}
	int result = 0;
	for (; str[result]; result += 1) {
	}
	return result;
}

/// Returns the index of the first occurrence of a character in string
int indexOf(const char str[*], char chr) {
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			return i;
		}
	}
	return -1;
}

/// Returns the index of the last occurrence of a character in string
int lastIndexOf(const char str[*], char chr) {
	int result = -1;
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			result = i;
		}
	}
	return result;
}

/// Check if a string begins with a specified string, using a custom comparator
bool startsWith(const char str[*], const char with[*], int cmp(char chr, char with)) {
	for (int i = 0; with[i] != 0; i += 1) {
		if (cmp(str[i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

/// Check if a string ends in a specified string, using a custom comparator
bool endsWith(const char str[*], const char with[*], int cmp(char chr, char with)) {
	int withLen = length(with);
	int strLen = length(str);
	if (strLen < withLen) {
		return false;
	}
	for (int i = 0; i < withLen; i += 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

/// Check if the two strings are equal, less or greater, using a custom comparator
int compare(const char str[*], const char with[*], int cmp(char chr, char with)) {
	int result = 0;
	for (int i = 0; result == 0; i += 1) {
		result = cmp(str[i], with[i]);
		if (str[i] == 0) {
			break;
		}
	}
	return result;
}

/// ignore case character comparator
int ignCaseCmp(char chr, char with) {
	static char ignCase(char chr) {
		if (chr < 'A') {
			return chr;
		}
		if (chr > 'Z') {
			return chr;
		}
		return chr - 'A' + 'a';
	}

	return ignCase(chr) - ignCase(with);
}

/// default character comparator
int caseCmp(char chr, char with) {
	return chr - with;
}

/// convert lower part (4 bits) of the input value to the corresponding lower case hexadecimal character
inline toHex(int value) = int("0123456789abcdef"[value & 0xf]);

/// Check if a string begins with a specified string, using case-sensitive comparison
inline startsWith(const char str[*], const char with[*]) = startsWith(str, with, caseCmp);
/// Check if a string ends in a specified string, using case-sensitive comparison
inline endsWith(const char str[*], const char with[*]) = endsWith(str, with, caseCmp);
/// Check if the two strings are equal, less or greater, using case-sensitive comparison
inline compare(const char str[*], const char with[*]) = compare(str, with, caseCmp);
/// Check if the two strings are equal, using case-sensitive comparison
inline equals(const char str[*], const char with[*]) = compare(str, with, caseCmp) == 0;

/// Check if a string contains the given character
inline contains(const char str[*], char chr) = indexOf(str, chr) >= 0;

/* TODO: implement operator overloading
inline ==(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) == 0;
inline !=(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) != 0;
inline <=(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) <= 0;
inline >=(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) >= 0;
inline <(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) < 0;
inline >(const char lhs[*], const char rhs[*]) = compare(lhs, rhs, caseCmp) > 0;
// */

/// Convert a string to a 64 bit floating point value
float64 float64(const char value[]) {
	float64 result = 0;
	static if (preferNativeCalls && typename(float64.parse) != null) {
		// use the native method if available
		int len = float64.parse(value, &result);
		if (len > 0 && len < value.length && value[len] == 0) {
			return result;
		}
		// error("value is not a floating point number");
		return Math.nan;
	}

	float64 sign = 1;
	float64 decimal = 0;

	for (int i = 0; i < value.length && value[i] != 0; i += 1) {
		char chr = value[i];
		if (chr >= '0' && chr <= '9') {
			result = result * 10 + (chr - '0');
			decimal *= 10;
		}
		else if (chr == '.') {
			if (decimal != 0) {
				// multiple decimal points
				return Math.nan;
			}
			decimal = 1;
		}
		else if (chr == '-' && i == 0) {
			sign = -1;
		}
		else if (chr == '+' && i == 0) {
			sign = 1;
		}
		else {
			// invalid character
			return Math.nan;
		}
	}

	if (decimal == 0) {
		if (value.length > 0) {
			return sign * result;
		}
	}
	return sign * result / decimal;
}
/// Ascii reader converts the given input by mapping every byte to a character
struct AsciiReader: TextReader {
	// convert bytes to chars
	int decode(AsciiReader this, unicode chars[]) {
		ByteReader reader = this.reader;
		for (int i = 0; i < chars.length; i += 1) {
			byte value[1] = {};
			if (reader.read(value) <= 0) {
				// end of stream
				return i;
			}
			chars[i] = value[0];
		}
		return chars.length;
	}
}

/// Ascii Writer converts the given input by chopping each character to a byte
struct AsciiWriter: TextWriter {
	// convert characters to bytes(can cause data loss)
	void encode(TextWriter this, unicode chars[]) {
		ByteWriter writer = this.writer;
		for (int i = 0; i < chars.length; i += 1) {
			byte value[1] = {chars[i]};
			writer.write(value);
		}
	}
}
/// Utf-8 decoder
struct Utf8Reader: TextReader {
	// convert utf-8 bytes to unicode codepoints
	int decode(Utf8Reader this, unicode chars[]) {
		byte buff[1] = {0};
		byte ext[3] = {0};
		ByteReader reader = this.reader;
		for (int i = 0; i < chars.length; i += 1) {
			if (reader.read(buff) <= 0) {
				// end of stream
				return i;
			}

			if ((buff[0] & 0x80) == 0) {
				chars[i] = buff[0];
			}
			else if ((buff[0] & 0xe0) == 0xc0) {
				if (reader.read(ext[...1]) != 1) {
					error("invalid codepoint");
					return i;
				}
				assert((ext[0] & 0b11000000) == 0b10000000, "10xxxxxx");
				chars[i] = (buff[0] & 0x1f) << 6 | (ext[0] & 0x3f);
			}
			else if ((buff[0] & 0xf0) == 0xe0) {
				if (reader.read(ext[...2]) != 2) {
					error("invalid codepoint");
					return i;
				}
				assert((ext[0] & 0b11000000) == 0b10000000, "10xxxxxx");
				assert((ext[1] & 0b11000000) == 0b10000000, "10xxxxxx");
				chars[i] = (buff[0] & 0x0f) << 12 | (ext[0] & 0x3f) << 6 | (ext[1] & 0x3f);
			}
			else if ((buff[0] & 0xf8) == 0xf0) {
				if (reader.read(ext[...3]) != 3) {
					error("invalid codepoint");
					return i;
				}
				assert((ext[0] & 0b11000000) == 0b10000000, "10xxxxxx");
				assert((ext[1] & 0b11000000) == 0b10000000, "10xxxxxx");
				assert((ext[2] & 0b11000000) == 0b10000000, "10xxxxxx");
				chars[i] = (buff[0] & 0x07) << 18 | (ext[0] & 0x3f) << 12 | (ext[1] & 0x3f) << 6 | (ext[2] & 0x3f);
			}
		}
		return chars.length;
	}
}

/// Utf-8 encoder
// adapted from: https://github.com/devatrun/sutfcpplib/blob/main/include/sutfcpplib/utf_codepoint.h#L287
struct Utf8Writer: TextWriter {
	// convert unicode codepoints to utf-8 bytes
	void encode(Utf8Writer this, unicode chars[]) {
		ByteWriter writer = this.writer;
		for (int i = 0; i < chars.length; i += 1) {
			unicode cp = chars[i];

			if (cp < 0x80) {
				byte bytes[1] = {cp};
				writer.write(bytes[...1]);
			}
			else if (cp < 0x800) {
				byte bytes[2] = {
					0b11000000 | (cp >> 6);
					0b10000000 | (cp & 0b00111111);
				};
				writer.write(bytes[...2]);
			}
			else if (cp < 0x10000) {
				byte bytes[3] = {
					0b11100000 | (cp >> 12);
					0b10000000 | ((cp >> 6) & 0b00111111);
					0b10000000 | (cp & 0b00111111);
				};
				writer.write(bytes[...3]);
			}
			else { /*if (cp < 0x110000)*/
				byte bytes[4] = {
					0b11110000 | (cp >> 18);
					0b10000000 | ((cp >> 12) & 0b00111111);
					0b10000000 | ((cp >> 6) & 0b00111111);
					0b10000000 | (cp & 0b00111111);
				};
				writer.write(bytes[...4]);
			}
		}
	}
}
/// Base64 encoder
struct Base64Encoder: ByteWriter {
	static const byte lookup[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	///@public
	const ByteWriter writer;

	byte buffer[1024];
	int bufferSize = 0;
	int padding = 0;

	/// wrap at the given position with a newline
	const int wrap = 80;
	int wrapSize = 0;

	static void flushBuffer(Base64Encoder this) {
		ByteWriter writer = this.writer;
		int size = this.bufferSize;

		int wrap = this.wrap - this.wrapSize;
		if (wrap > size || this.wrap == 0) {
			wrap = size;
		}

		writer.write(writer, this.buffer[...wrap]);
		this.wrapSize += wrap;

		// print the rest of the buffer as one or multiple lines
		for ( ; wrap < size; ) {
			writer.write(writer, "\n");

			int len = Math.min(size - wrap, this.wrap);
			byte buffer[*] = this.buffer.inc(wrap);
			writer.write(writer, buffer[...len]);
			this.wrapSize = len;
			wrap += len;
		}
		this.bufferSize = 0;
	}

	void write(Base64Encoder this, byte data[]) {
		assert(buffer.length > 3);

		ByteWriter writer = this.writer;
		byte buffer[] = this.buffer;
		int size& = this.bufferSize;
		int i = 0;

		// revert padding and continue encoding (not mandatory, but reduces output size)
		if (size > 3 && buffer[size - 1] == '=' && data.length > 0) {
			if (buffer[size - 2] == '=') {
				if (data.length < 2) {
					// debug("convert padding: 62== to 664=");
					int32 b = (this.padding << 6)
						| ((data[i] & 0xff) << 2);
					buffer[size - 3] = lookup[b >> 6 & 0x3f];
					buffer[size - 2] = lookup[b & 0x3f];
					this.padding = b;
					return;
				}
				// debug("revert padding: 62==");
				int32 b = (this.padding << 12)
					| ((data[i] & 0xff) << 8)
					| (data[i + 1] & 0xff);
				buffer[size - 3] = lookup[b >> 12 & 0x3f];
				buffer[size - 2] = lookup[b >> 6 & 0x3f];
				buffer[size - 1] = lookup[b & 0x3f];
				i += 2;
			} else {
				// debug("revert padding: 664=");
				int32 b = (this.padding << 6)
					| (data[i] & 0xff);
				buffer[size - 2] = lookup[b >> 6 & 0x3f];
				buffer[size - 1] = lookup[b & 0x3f];
				i += 1;
			}
		}

		// fast loop: read 3 and write 4 bytes at once
		for (int n = data.length - 2; i < n; i += 3) {
			if (size + 4 > buffer.length) {
				flushBuffer(this);
			}

			// Encode the 3 bytes into 4 bytes: 3 * 8 = 4 * 6
			int32 b = ((data[i + 0] & 0xff) << 16)
					| ((data[i + 1] & 0xff) << 8)
					| ((data[i + 2] & 0xff) << 0);
			buffer[size + 0] = lookup[b >> 18 & 0x3f];
			buffer[size + 1] = lookup[b >> 12 & 0x3f];
			buffer[size + 2] = lookup[b >> 6 & 0x3f];
			buffer[size + 3] = lookup[b & 0x3f];
			size += 4;
		}

		// if the input size is not multiple of 3 bytes, add padding, so output will be multiple of 4
		if (int left = data.length - i) {
			if (size + 4 > buffer.length) {
				flushBuffer(this);
			}
			if (left == 2) {
				// 2 bytes = 16 bits => 6 + 6 + 4 + =
				int32 b = ((data[i + 0] & 0xff) << 10)
						| ((data[i + 1] & 0xff) << 2);
				buffer[size + 0] = lookup[b >> 12 & 0x3f];
				buffer[size + 1] = lookup[b >> 6 & 0x3f];
				buffer[size + 2] = lookup[b & 0x3f];
				buffer[size + 3] = '=';
				this.padding = b;
				size += 4;
			} else {
				// 1 bye = 8 bits = 6 + 2 + = + =
				int32 b = (data[i] & 0xff) << 4;
				buffer[size + 0] = lookup[(b >> 6) & 0x3f];
				buffer[size + 1] = lookup[(b >> 0) & 0x3f];
				buffer[size + 2] = '=';
				buffer[size + 3] = '=';
				this.padding = b;
				size += 4;
			}
		}
	}

	void flush(Base64Encoder this) {
		this.flushBuffer();
		this.writer.flush();
	}

	void close(Base64Encoder this) {
		this.flushBuffer();
	}
}

/// Base64 decoder
struct Base64Decoder: ByteReader {
	static const int lookup[256] = {
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
		52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
		-1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
		-1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
		41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	};

	///@public
	const ByteReader reader;

	// TODO: make it buffered
	int bitsDecoded = 0;
	int charDecoded = 0;

	int read(Base64Decoder this, byte data[]) {
		inline isWhite(char c) = c == ' ' || c == '\t' || c == '\n' || c == '\r';

		byte in[1] = {0};
		ByteReader reader = this.reader;
		inline bitsDecoded = this.bitsDecoded;
		inline charDecoded = this.charDecoded;
		for (int i = 0; i < data.length;) {
			if (reader.read(reader, in) <= 0) {
				return i;
			}
			else if (in[0] == '=') {
				bitsDecoded -= 2;
			}
			else if (!isWhite(in[0])) {
				bitsDecoded += 6;
				charDecoded <<= 6;
				charDecoded |= lookup[in[0]] & 0x3f;
				if (bitsDecoded >= 8) {
					bitsDecoded -= 8;
					data[i] = byte(charDecoded >> bitsDecoded);
					i += 1;
				}
			}
		}
		return data.length;
	}

	void close(Base64Decoder this) {
		assert(this.bitsDecoded == 0, "unprocessed bits remaining.", this.bitsDecoded);
	}
}
/// Represents the base class of closeable objects like files, streams, etc
struct Closeable: object {

	/// Release the resources hold by this object.
	void close(Closeable this);

	static void closeSafe(Closeable this) {
		if (this.close == null) {
			// close is disabled, stdout?
			return;
		}
		this.close(this);
	}
}

/// ByteReader can be used to read bytes from a stream (~= java:InputStream)
struct ByteReader: Closeable {

	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * the method must return the number of bytes read from the stream into the `bytes` array
	 * in case there is an error -1 should be returned
	 */
	int read(ByteReader this, byte bytes[]);

	/// Read a single byte from the stream, a negative number is returned in case of error
	static int read(ByteReader this) {
		byte bytes[1] = {0};
		if (this.read(bytes) <= 0) {
			return -1;
		}
		return bytes[0];
	}

	/* TODO: subclasses
		CopyReader
		FileReader
		PipedReader
		SocketReader
		MemoryReader
	*/
}

/// ByteWriter can be used to write bytes to a stream (~= java:OutputStream)
struct ByteWriter: Closeable {
	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * the method must write all the bytes from the `bytes` array
	 */
	void write(ByteWriter this, byte bytes[]);

	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * if a buffer is used directly or indirectly this method must flush all buffered data to the stream.
	 */
	void flush(ByteWriter this);

	/// Write a single byte to the stream
	static void write(ByteWriter this, byte oneByte) {
		byte bytes[1] = { oneByte };
		return this.write(this, bytes);
	}

	/* TODO: uncomment
	static void write(ByteWriter this, void write(ByteWriter writer)) {
		return write(this);
	}

	struct Writeable: object {
		// abstract
		void write(Writeable this, ByteWriter writer);
	}

	static void write(ByteWriter this, Writeable value) {
		return this.write(this, value.write);
	}// */

	/// Copy all bytes from the reader to the writer
	static int copy(ByteWriter this, ByteReader reader) {
		byte buffer[4096] = {};
		int result = 0;
		for ( ; ; ) {
			int read = reader.read(buffer);
			if (read <= 0) {
				return result;
			}
			this.write(this, buffer[...read]);
			result += read;
		}
		return result;
	}

	/* TODO: subclasses
		FileWriter
		PipedWriter
		SocketWriter
		MemoryWriter
	*/
}

// TODO: untested: copy byte-stream
struct CopyReader: ByteReader {
	const ByteReader source;
	const ByteWriter clone;

	// override
	int read(CopyReader this, byte bytes[]) {
		int result = this.source.read(bytes);
		if (result > 0) {
			this.clone.write(bytes[...result]);
		}
		return result;
	}

	// override
	void close(CopyReader this) {
		Closeable.closeSafe(this.source);
		Closeable.closeSafe(this.clone);
	}
}

// TODO: untested
struct ByteBuffer {
	int position = 0;
	int capacity = 32;
	int length = 0;
	byte buffer[*] = pointer.alloc(null, capacity);

	int read(ByteBuffer this, byte bytes[]) {
		if (this.position >= this.length) {
			return -1;
		}
		for (int i = 0; i < bytes.length; i += 1) {
			if (this.position >= this.length) {
				return i;
			}
			bytes[i] = this.buffer[this.position];
			this.position += 1;
		}
		return bytes.length;
	}

	int read(ByteBuffer this) {
		if (this.position >= this.length) {
			return -1;
		}
		int result = this.buffer[this.position];
		this.position += 1;
		return result;
	}

	void write(ByteBuffer this, byte bytes[]) {
		int size = this.position + bytes.length;
		if (size >= this.capacity) {
			// try to double the current size
			this.capacity *= 2;
			if (size > 2 * this.capacity) {
				// double the calculated size
				this.capacity = size * 2;
			}

			// copy old bytes
			byte new[*] = pointer.alloc(null, this.capacity);
			for (int i = 0; i < this.position; i += 1) {
				new[i] = this.buffer[i];
			}
			pointer.alloc(this.buffer, 0);
			this.buffer = new;
		}

		// copy new bytes
		for (int i = 0; i < bytes.length; i += 1) {
			this.buffer[this.position] = bytes[i];
			this.position += 1;
		}
	}

	void flush(ByteBuffer this) {
		// do nothing
	}

	void close(ByteBuffer this) {
		// release memory
		pointer.alloc(this.buffer, 0);

		this.buffer = null;
		this.position = 0;
		this.capacity = 0;
		this.length = 0;
	}
}
// The Unicode Character Set (UCS) contains 1,114,112 code points: U+0000U+10FFFF
// todo: move inside class TextReader
inline unicode = uint32;

// TextReader := Decoder & Parser (java:Reader+Scanner?Parser?)
/// TextReader can be used to read decoded text from a stream, including basic parsing
struct TextReader: Closeable {

	///@public
	const ByteReader reader;

	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * the method must return the number of characters decoded from the stream into the `chars` array
	 * in case there is an error -1 should be returned
	 */
	int decode(TextReader this, unicode chars[]);

	// override
	void close(TextReader this) {
		// by default close the stream, override by need
		Closeable.closeSafe(this.reader);
	}

	/// Read a single character from the stream, a negative number is returned in case of error
	static int decode(TextReader this) {
		unicode chars[1] = {0};
		if (this.decode(chars) <= 0) {
			return -1;
		}
		return chars[0] & 0x00ffffff;
	}

	// TODO: static string readNext(TextReader this, regex matcher) { /*...*/ }
	// TODO: static string readWord(TextReader this) { return this.readNext(/\w+/); }
	// TODO: static string readLine(TextReader this) { return this.readNext(/.*$/); }
	// TODO: static string readAll(TextReader this) { return this.readMatch(/.*/); }
	// TODO: static double readNumber(TextReader this, Locale locale) { /*...*/ }

	/* TODO: subclasses
		Latin1
		Ascii
		Utf8
	*/
}

// TextWriter := Encoder & Printer (java:Writer+PrintStream)
/// TextWriter can be used to write encoded text to a stream, including basic printing
struct TextWriter: Closeable {
	///@public
	struct Writeable: object {
		// abstract
		void write(Writeable this, TextWriter writer);
	}

	///@public
	const ByteWriter writer;

	/// default formatter
	const FormatFlags format;

	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * the method must encode and write all the characters from the `chars` array
	 */
	void encode(TextWriter this, unicode chars[]);

	// override
	void flush(TextWriter this) {
		this.writer.flush();
	}

	// override
	void close(TextWriter this) {
		// by default close the stream, override by need
		Closeable.closeSafe(this.writer);
	}

	/// Write an array of raw characters to the stream (no encoding)
	static TextWriter write(TextWriter this, char value[]) {
		this.writer.write(value);
		return this;
	}

	/// Write a single raw character to the stream (no encoding)
	static TextWriter write(TextWriter this, char value) {
		char buffer[1] = { value };
		return this.write(buffer);
	}

	/// Write the value of the boolean parameter: "true" or "false"
	static TextWriter write(TextWriter this, bool value) {
		if (value) {
			return this.write("true");
		}
		return this.write("false");
	}

	/// Write the value of the 32-bit integer parameter
	static TextWriter write(TextWriter this, int32 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	/// Write the value of the 64-bit integer parameter
	static TextWriter write(TextWriter this, int64 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	/// Write the value of the 32-bit unsigned integer parameter
	static TextWriter write(TextWriter this, uint32 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	/// Write the value of the 64-bit unsigned integer parameter
	static TextWriter write(TextWriter this, uint64 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	/// Write the value of the 32-bit floating-point parameter
	static TextWriter write(TextWriter this, float32 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	/// Write the value of the 64-bit floating-point parameter
	static TextWriter write(TextWriter this, float64 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	/// Write the value of the writeable parameter
	static TextWriter write(TextWriter this, Writeable value) {
		value.write(this);
		return this;
	}

	/// Write a newline character
	static TextWriter writeln(TextWriter this) {
		return this.write("\n");
	}

	///@public
	static TextWriter writeln(TextWriter this, TextWriter.Writeable value) { return this.write(value).writeln(); }

	// TODO: static void write(TextWriter this, Locale locale, char value) { /*...*/ }
	// TODO: static void write(TextWriter this, Locale locale, string value) { /*...*/ }
	// TODO: static void write(TextWriter this, Locale locale, object value) { /*...*/ }
	// TODO: static void write(TextWriter this, Locale locale, variant value) { /*...*/ }
	// TODO: static void write(TextWriter this, void write(TextWriter writer)) { /*...*/ }

	/**
	 * Convert from one encoding to another one.
	 * @returns converted character count.
	 *
	 * example: convert utf-8 encoded file to ascii
	 * TextWriter output = AsciiWriter("out.txt");
	 * TextReader input = Utf8Reader("in.txt");
	 * output.write(input);
	 */
	static int copy(TextWriter writer, TextReader reader) {
		unicode buffer[1024] = {};
		int result = 0;
		for ( ; ; ) {
			int n = reader.decode(buffer);
			if (n <= 0) {
				return result;
			}
			writer.encode(buffer[...n]);
			result += n;
		}
		return result;
	}

	/* TODO: subclasses
		Latin1
		Ascii
		Utf8
	*/
}
/// Month of year, January is 1, February is 2, ...
enum Month: uint8 {
	January: 1;
	February;
	March;
	April;
	May;
	June;
	July;
	August;
	September;
	October;
	November;
	December;
}
/// FIXME: implement enum indexing
inline Month(int index) = Month(emit(int32(index + Month.January)));
/// FIXME: implement enum indexing
inline indexOf(Month value) = int32(value - Month.January);

/// Day of week, Monday is 1, Tuesday is 2, ...
enum Weekday: uint8 {
	Monday: 1;
	Tuesday;
	Wednesday;
	Thursday;
	Friday;
	Saturday;
	Sunday;
}
/// FIXME: implement enum indexing
inline Weekday(int index) = Weekday(emit(int32(index + Weekday.Monday)));
/// FIXME: implement enum indexing
inline indexOf(Weekday value) = int32(value - Weekday.Monday);

/// Type of the calendar
enum Calendar: uint8 {
	Gregorian;
//	Buddhist;
//	Chinese;
//	Coptic;
//	EthiopicAmeteAlem;
//	EthiopicAmeteMihret;
//	Hebrew;
//	Indian;
//	Islamic;
//	IslamicCivil;
//	IslamicTabular;
//	IslamicUmmAlQura;
//	Iso8601;
//	Japanese;
//	Persian;
//	RepublicOfChina;
}

/// DateTime represents the parts of an instant in time.
struct Datetime {
	// Date parts

	/// Year: 1970
	const int32 year;
	/// Month of year: 1 ... 12 / [Jan, Feb, Mar, ...]
	const Month month;
	/// Day of month: 1 ... 30
	const uint8 day;

	// Time parts

	/// Hour of day: 0 ... 23
	const uint8 hour = 0;
	/// Minute of hour: 0 ... 59
	const uint8 minute = 0;
	/// Second of minute: 0 ... 59
	const uint8 second = 0;
	/// Milliseconds of second: 0 ... 999
	const uint16 millis = 0;

	/// timezone
	const Timezone timezone;

	// Extra
	// const uint8 weekOfMonth;	// 1 ... 4
	//dayOfWeekInMonth;		// example: 1..4, may be specified as -1

	/// Nth week of the year: 1 ... 53
	const uint8 weekOfYear;

	/// Nth day of the year: 1 ... 365
	const uint16 dayOfYear;

	/// Day of week: 1 ... 7 / [Mon, Tue, ...]
	const Weekday dayOfWeek;

	/// this is a leap year
	const bool leapYear;

	static const int DaysToMonth365[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
	static const int DaysToMonth366[13] = {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
	static const int DaysTil1970 = 719162;

	/// Checks weather the given year is a leap year or not
	static bool isLeapYear(int year) {
		if (year % 4 != 0) {
			return false;
		}
		if (year % 100 != 0) {
			return true;
		}
		if (year % 400 != 0) {
			return false;
		}
		return true;
	}

	/// Add the amount of `years`, `months` and `days` to the datetime
	static Datetime add(Datetime cal, int years, int months, int days) {
		int year = cal.year + years;

		int month = indexOf(cal.month) + months;
		if (month >= 12) {
			year += month / 12;
			month %= 12;
		}
		else if (month < 0) {
			year += month / 12 - 1;
			month = 12 - (-month % 12);
		}

		assert(days == 0);

		return {
			year: year;
			month: Month(month % 12);
			day: cal.day;
			hour: cal.hour;
			minute: cal.minute;
			second: cal.second;
			millis: cal.millis;
			timezone: cal.timezone;
			weekOfYear: cal.weekOfYear;
			dayOfYear: cal.dayOfYear;
			dayOfWeek: cal.dayOfWeek;
			leapYear: isLeapYear(year);
		};
	}
}

/// Convert the given Datetime `value` to a timestamp (milliseconds since 1970)
Timestamp Timestamp(Datetime value) {
	int year = value.year;
	if (year < 0 || year > 9999) {
		trace("invalid year", year);
		return Timestamp(1D << 63, Timestamp.precision);
	}

	int month = value.month;
	if (month < Month.January || month > Month.December) {
		trace("invalid month", month);
		month = Math.clamp(month, int32(Month.January), int32(Month.December));
	}

	const int DaysToMonth[*] = Datetime.isLeapYear(year) ? Datetime.DaysToMonth366 : Datetime.DaysToMonth365;

	int day = value.day;
	int daysInYear = DaysToMonth[month - 1];
	int daysInMonth = DaysToMonth[month] - daysInYear;
	if (day < 1 || day > daysInMonth) {
		trace("invalid day of month", day);
		day = Math.clamp(day, 1, daysInMonth);
	}

	int y = year - 1;
	int64 d = y * 365 + y / 4 - y / 100 + y / 400 + daysInYear + day - 1 - Datetime.DaysTil1970;
	int64 t = (((d * 24 + value.hour) * 60 + value.minute) * 60 + value.second) * 1000 + value.millis;
	return Timestamp(t, Timeunit.Millis);
}

/// Convert the given `timestamp` to a datetime(year, month, day, ...) using the given `calendar` and `timezone`
Datetime Datetime(Timestamp timestamp, Calendar calendar, Timezone timezone) {
	assert(calendar == Calendar.Gregorian);
	enum: int {
		// Number of days in a non-leap year
		DaysPerYear: 365;

		// Number of days in a leap year
		DaysPerLeapYear: 366;

		// Number of days in 4 years
		DaysPer4Years: DaysPerYear * 4 + 1;
		// Number of days in 100 years
		DaysPer100Years: DaysPer4Years * 25 - 1;
		// Number of days in 400 years
		DaysPer400Years: DaysPer100Years * 4 + 1;
	}

	Duration offset = timezone.offset(timestamp);
	timestamp = timestamp.add(offset.value, Duration.precision);
	int n = Datetime.DaysTil1970 + timestamp.value(Timeunit.Days);

	// n = number of days since 1/1/0001
	int dayOfWeek = n % 7;

	// y400 = number of whole 400-year periods since 1/1/0001
	int y400 = n / DaysPer400Years;
	// n = day number within 400-year period
	n -= y400 * DaysPer400Years;

	// y100 = number of whole 100-year periods within 400-year period
	int y100 = n / DaysPer100Years;

	// Last 100-year period has an extra day, so decrement result if 4
	if (y100 == 4) {
		y100 = 3;
	}
	// n = day number within 100-year period
	n -= y100 * DaysPer100Years;

	// y4 = number of whole 4-year periods within 100-year period
	int y4 = n / DaysPer4Years;
	// n = day number within 4-year period
	n -= y4 * DaysPer4Years;

	// y1 = number of whole years within 4-year period
	int y1 = n / DaysPerYear;
	// Last year has an extra day, so decrement result if 4
	if (y1 == 4) {
		y1 = 3;
	}

	// If year was requested, compute and return it
	int year = y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1;

	// n = day number within year
	n -= y1 * DaysPerYear;

	// All months have less than 32 days, so n >> 5 is a good conservative
	// estimate for the month
	int m = n >> 5 + 1;
	const int DaysToMonth[*] = Datetime.isLeapYear(year) ? Datetime.DaysToMonth366 : Datetime.DaysToMonth365;

	// m = 1-based month number
	for (;n >= DaysToMonth[m];) {
		m += 1;
	}

	return {
		// date
		year: year;
		month: Month(m - 1);
		day: n - DaysToMonth[m - 1] + 1;

		// time
		hour: timestamp.value(Timeunit.Hours) % 24;
		minute: timestamp.value(Timeunit.Minutes) % 60;
		second: timestamp.value(Timeunit.Seconds) % 60;
		millis: timestamp.value(Timeunit.Millis) % 1000;

		// zone
		timezone: timezone;

		// extra
		dayOfYear: n + 1;
		dayOfWeek: Weekday(dayOfWeek);
		weekOfYear: (n - dayOfWeek + indexOf(Weekday.Thursday)) / 7 + 1;
		leapYear: DaysToMonth == Datetime.DaysToMonth366;
	};
}

/// Convert the given timestamp to a datetime
inline Datetime(Timestamp timestamp) = Datetime(timestamp, Calendar.Gregorian, Timezone.utc());

/// Construct the Datetime from the given parts
Datetime Datetime(int year, int month, int day, int hour, int minute, int second, int millis, Timezone zone) {
	return {
		year: year;
		month: Month(month - 1);
		day: day;
		hour: hour;
		minute: minute;
		second: second;
		millis: millis;
		timezone: zone;
		weekOfYear: 0;
		dayOfYear: 0;
		dayOfWeek: Weekday.Monday;
		leapYear: Datetime.isLeapYear(year);
	};
}

/// Construct the Datetime from the given parts
Datetime Datetime(int year, int month, int day, int hour, int minute, int second, int millis) {
	return Datetime(year, month, day, hour, minute, second, millis, Timezone.utc());
}

/// Construct the Datetime from the given parts
Datetime Datetime(int year, int month, int day, int hour, int minute, int second, Timezone zone) {
	return Datetime(year, month, day, hour, minute, second, 0, zone);
}

/// Construct the Datetime from the given parts
Datetime Datetime(int year, int month, int day, Timezone zone) {
	return Datetime(year, month, day, 0, 0, 0, 0, zone);
}

/// Construct the Datetime from the given parts
Datetime Datetime(int year, int month, int day) {
	return Datetime(year, month, day, 0, 0, 0, 0, Timezone.utc());
}
/**
 * Timespan is just a duration
 * for example: 33 seconds
 */
struct Duration {
	const int64 value = 0;
	// fixme: inline precision = Timeunit.Millis;
	static const Timeunit precision = Timeunit.Millis;

	/// Returns the value of the `duration` at the given `precision` (Seconds and Millis are mostly used as unix epoch)
	static int64 value(Duration duration, Timeunit precision) {
		return convert(duration.value, Duration.precision, precision);
	}

	/// Add two durations
	static Duration add(Duration lhs, Duration rhs) {
		return { value: lhs.value + rhs.value };
	}
}

/// Construct a duration from the given `value` at the given `precision`
Duration Duration(int64 value, Timeunit precision) {
	return { value: convert(value, precision, Duration.precision) };
}

/* TODO: inline initialization, operator overloading
inline Duration(int64 value, Timeunit precision) = {
	value: convert(value, precision, Duration.precision);
}

inline +(Duration lhs, Duration rhs) = Duration {
	value: lhs.value + rhs.value;
}

inline -(Duration lhs, Duration rhs) = Duration {
	value: lhs.value - rhs.value;
}

struct Duration {
	static Duration setField(Duration this, int64 value, Timeunit unit) { ... }
	static Duration setValue(Duration this, int64 value, Timeunit unit) { ... }
	static Duration floor(Duration this, Timeunit unit) { ... }
	static Duration ceil(Duration this, Timeunit unit) { ... }
	static Duration distribute(Duration this, Timeunit unit, uint64 duration) { ... }
	static Duration distribute(Duration this, Timeunit unit, int start, int end) { ... }
}
*/
/**
 * Timestamp is a position in time, without timezone information
 * in case locale is needed use Datetime.
 */
struct Timestamp {
	int64 value = 0;

	/// The time unit specifying the precision of the timestamp
	static const Timeunit precision = Timeunit.Millis;

	/// Returns the value of `timestamp` at the given `precision` (Seconds and Millis are mostly used as unix epoch)
	static int64 value(Timestamp timestamp, Timeunit precision) {
		return convert(timestamp.value, Timestamp.precision, precision);
	}

	/// Returns the difference of `a` and `b` at the given `precision`
	static int64 diff(Timestamp a, Timestamp b, Timeunit precision) {
		return convert(a.value - b.value, Timestamp.precision, precision);
	}

	/// Returns the difference of `a` and `b
	static Duration diff(Timestamp a, Timestamp b) {
		return Duration(a.value - b.value, Timestamp.precision);
	}

	/// Returns whether the firs timestamp is less(<0), equal(=0), or greater(>0) than the second timestamp
	static int compare(Timestamp a, Timestamp b) {
		return int(a.value > b.value) - int(a.value < b.value);
	}

	/// Check whether the two timestamps `a` and `b` are equal at the given `precision`
	static bool equal(Timestamp a, Timestamp b, Timeunit precision) {
		return a.value(precision) == b.value(precision);
	}

	/// Check whether the two timestamps `a` and `b` are equal
	static bool equal(Timestamp a, Timestamp b) {
		return a.value == b.value;
	}

	/// Increment the the current timestamp with the given `value` at the given `precision`
	static Timestamp add(Timestamp lhs, int64 value, Timeunit precision) {
		return { value: lhs.value + convert(value, precision, Timestamp.precision) };
	}

	/**
	 * Floor the current timestamp, leaving the field specified as the most significant field.
	 * For example, if you have the timestamp: 2002-03-28 13:45:01.231,
	 * using resolution Timeunit.Days, it should return 2002-03-28 00:00:00.000.
	 * using resolution Timeunit.Hours, it should return 2002-03-28 13:00:00.000.
	 * using resolution Timeunit.Minutes, it should return 2002-03-28 13:45:00.000.
	 *
	 * @param unit Resolution of the operation.
	 */
	static Timestamp floor(Timestamp value, Timeunit precision) {
		if (precision <= Timestamp.precision) {
			trace("small precision", precision);
			return value;
		}
		int64 one = convert(1D, precision, Timestamp.precision);
		return { value: value.value - value.value % one };
	}

	/**
	 * Ceil the current timestamp, leaving the field specified as the most significant field.
	 * For example, if you have the timestamp: 2002-03-28 13:45:01.231,
	 * using resolution Timeunit.Days, it should return 2002-03-29 00:00:00.000.
	 * using resolution Timeunit.Hours, it should return 2002-03-28 14:00:00.000.
	 * using resolution Timeunit.Minutes, it should return 2002-03-28 13:46:00.000.
	 *
	 * @param unit Resolution of the operation.
	 */
	static Timestamp ceil(Timestamp value, Timeunit precision) {
		if (precision <= Timestamp.precision) {
			trace("small precision", precision);
			return value;
		}
		int64 one = convert(1D, precision, Timestamp.precision);
		int64 part = value.value % one;
		if (part == 0) {
			return value;
		}
		return { value: value.value - part + one };
	}

	/**
	 * Distribute randomly between current value and the duration at the given time-unit resolution.
	 * For example, if you had the timestamp: 2002-03-28 13:45:01.231,
	 * using distribute(Timeunit.Hours, 2), it will return a date between 2002-03-28 13:46:01.231 and 2002-03-28 15:46:01.231.
	 *
	 * @param unit  Resolution of the duration.
	 * @param duration The duration of the distribution time frame, negative values are allowed.
	 */
	static Timestamp distribute(Timestamp this, Timeunit unit, uint64 duration) {
		abort("not implemented");
		return { value: 0 };
	}

	/**
	 * Distribute randomly between start and end at the given time-unit resolution.
	 * For example, if you have the timestamp of 2002-03-28 13:46:01.231,
	 * using distribute(Timeunit.Hours, 15, 17) as start and end, it will return a date between 2002-03-28 15:46:01.231 and 2002-03-28 17:46:01.231.
	 * in case you need a timestamp between 15:00:00.000 and 17:00:00.000 yo will need to use the floor method before or after this operation.
	 *
	 * @param unit  Resolution of the operation.
	 * @param start The beginning of the distribution time frame.
	 * @param end   The end of the distribution time frame.
	 */
	static Timestamp distribute(Timestamp this, Timeunit unit, int start, int end) {
		return this./*setField(unit, start).*/distribute(unit, end - start);
	}

	/// get the current utc time as timestamp from the system
	static Timestamp now() {
		return { value: convert(System.millis(), Timeunit.Millis, Timestamp.precision) };
	}
}

/// Create a timestamp from the given `value` at the given `precision`
Timestamp Timestamp(int64 value, Timeunit precision) {
	return { value: convert(value, precision, Timestamp.precision) };
}

/*static if (typename(Duration) != null) {
Timestamp add(Timestamp lhs, Duration rhs) {
	return { value: lhs.value + rhs.value(Timestamp.precision) };
}
}*/

/* TODO: inline initialization, operator overloading
inline Timestamp(int64 value, Timeunit precision) = {
	value: convert(value, precision, Timestamp.precision);
};

inline +(Timestamp lhs, Duration rhs) = Timestamp {
	value: lhs.value + rhs.value(Timestamp.precision);
};
*/
/// enumeration of some known time unit, used for conversions and to specify the precision
enum Timeunit: int64 {
	// approximately 584 years of nanoseconds can be represented in uint64
	Nanos: 1;
	Micros: 1000 * Nanos;
	Millis: 1000 * Micros;
	Seconds: 1000 * Millis;
	Minutes: 60 * Seconds;
	Hours: 60 * Minutes;
	Days: 24 * Hours;
}

/// Convert the given integer `value` from the `from` to `to` unit
int64 convert(int64 value, Timeunit from, Timeunit to) {
	if (from > to) {
		// from Minutes to Seconds
		return value * (from / to);
	}
	// from Seconds to Minutes
	return value / (to / from);
}

/// Convert the given floating point `value` from the `from` to `to` unit
float64 convert(float64 value, Timeunit from, Timeunit to) {
	if (from > to) {
		// from Minutes to Seconds
		return value * (from / to);
	}
	// from Seconds to Minutes
	return value / (to / from);
}
// todo: unfinished implementation
struct Timezone {
	const char name[];		// "UTC", "America/New_York", "Europe/Brussels"
	Duration offset(const Timezone zone&, Timestamp timestamp, bool isDaylightSaving&);

	static Duration offset(const Timezone zone&, Timestamp timestamp) {
		bool isDaylightSaving;
		return zone.offset(zone, timestamp, &isDaylightSaving);
	}

	static Timezone utc() {
		static Duration offset(const Timezone zone&, Timestamp timestamp, bool isDaylightSaving&) {
			isDaylightSaving = false;
			return { value: 0 };
		}
		return {
			offset: offset;
			name: "UTC";
		};
	}

	static Timezone lookup(const char name[]) { abort("todo"); }

	static Timezone local() {
		warn("using fake timezone");	// fixme: fake timezone, needs to be read or lookup from the system
		//static void System.timeInfo(const char timezoneName[*], int64 timeMillis, int64 zoneOffset&, int daylight&) {}
		Duration offset(const Timezone zone&, Timestamp timestamp, bool isDaylightSaving&) {
			isDaylightSaving = false;
			return Duration(3, Timeunit.Hours);
		}
		return {
			offset: offset;
			name: "GMT+3";
		};
	}
}

// Timezone Timezone() {return Timezone.local();}

// Timezone Timezone(const char name[]) { return Timezone.lookup(name);}
