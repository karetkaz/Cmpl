// InputOutput

struct Closeable: object {
	// abstract
	void close(Closeable this);

	static void skipClose(Closeable closeable) {
	}

	static void safeClose(Closeable closeable) {
		if (closeable.close != null) {
			closeable.close(closeable);
		}
	}
}

// destroy a closeable invoking the abstract close method
inline close(Closeable instance) = Closeable.safeClose(instance);
inline void(Closeable instance) = Closeable.safeClose(instance);

// ByteReader ~= java:InputStream
struct ByteReader: Closeable {
	// abstract
	int read(ByteReader this, byte bytes[]);

	static int read(ByteReader this) {
		byte bytes[1] = {0};
		if (this.read(bytes) <= 0) {
			return -1;
		}
		return bytes[0] & 255;
	}

	/* TODO: subclasses
		CopyReader
		FileReader
		PipedReader
		SocketReader
		MemoryReader
	*/
}

// ByteWriter ~= java:OutputStream
struct ByteWriter: Closeable {
	// abstract
	void write(ByteWriter this, byte bytes[]);

	// abstract
	void flush(ByteWriter this);

	static void write(ByteWriter this, byte oneByte) {
		byte bytes[1] = { oneByte };
		return this.write(this, bytes);
	}

	/* TODO: uncomment
	static void write(ByteWriter this, void write(ByteWriter writer)) {
		return write(this);
	}

	struct Writeable: object {
		// abstract
		void write(Writeable this, ByteWriter writer);
	}

	static void write(ByteWriter this, Writeable value) {
		return this.write(this, value.write);
	}// */

	static int write(ByteWriter this, ByteReader reader) {
		byte buffer[1024] = {};
		int result = 0;
		for ( ; ; ) {
			int read = reader.read(buffer);
			if (read <= 0) {
				return result;
			}
			this.write(this, buffer[...read]);
			result += read;
		}
		return result;
	}

	/* TODO: subclasses
		FileWriter
		PipedWriter
		SocketWriter
		MemoryWriter
	*/
}

// The Unicode Character Set (UCS) contains 1,114,112 code points: U+0000â€”U+10FFFF
inline unicode = uint32;

// TextReader := Decoder & Parser(java:Reader + Scanner?Parser?)
struct TextReader: Closeable {
	const ByteReader reader;

	// abstract
	int decode(TextReader this, unicode chars[]);

	// override
	void close(TextReader this) {
		// by default close the stream.
		// override if no need to close it.
		this.reader.close();
	}

	static int decode(TextReader this) {
		unicode chars[1] = {0};
		if (this.decode(chars) <= 0) {
			return -1;
		}
		return chars[0] & 0x00ffffff;
	}

	// TODO: static string readNext(TextReader this, regex matcher) { /*...*/ }
	// TODO: static string readWord(TextReader this) { return this.readNext(/\w+/); }
	// TODO: static string readLine(TextReader this) { return this.readNext(/.*$/); }
	// TODO: static string readAll(TextReader this) { return this.readMatch(/.*/); }
	// TODO: static double readNumber(TextReader this, Locale locale) { /*...*/ }

	/* TODO: subclasses
		Latin1
		Ascii
		Utf8
	*/
}

// TextWriter := Encoder & Printer (java:Writer + PrintStream)
struct TextWriter: Closeable {
	struct Writeable: object {
		// abstract
		void write(Writeable this, TextWriter writer);
	}

	const ByteWriter writer;

	// abstract
	void encode(TextWriter this, unicode chars[]);

	// override
	void flush(TextWriter this) {
		this.writer.flush(this.writer);
	}

	// override
	void close(TextWriter this) {
		this.writer.safeClose();
	}

	static TextWriter write(TextWriter this, char value[]) {
		ByteWriter writer = this.writer;
		writer.write(writer, value);
		return this;
	}

	static TextWriter write(TextWriter this, char value) {
		char buffer[1] = { value };
		return this.write(buffer);
	}

	static TextWriter write(TextWriter this, bool value) {
		if (value) {
			return this.write("true");
		}
		return this.write("false");
	}

	static TextWriter write(TextWriter this, int32 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	static TextWriter write(TextWriter this, int64 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	static TextWriter write(TextWriter this, uint32 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	static TextWriter write(TextWriter this, uint64 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	static TextWriter write(TextWriter this, float32 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	static TextWriter write(TextWriter this, float64 value, const FormatFlags flags&) {
		char buff[1024]= {};
		int n = buff.append(0, value, flags);
		return write(this, buff[ ... n]);
	}

	static TextWriter write(TextWriter this, Writeable value) {
		value.write(this);
		return this;
	}

	static TextWriter writeln(TextWriter this) {
		return this.write("\n");
	}

	// TODO: static void write(TextWriter this, Locale locale, char value) { /*...*/ }
	// TODO: static void write(TextWriter this, Locale locale, string value) { /*...*/ }
	// TODO: static void write(TextWriter this, Locale locale, object value) { /*...*/ }
	// TODO: static void write(TextWriter this, Locale locale, variant value) { /*...*/ }
	// TODO: static void write(TextWriter this, void write(TextWriter writer)) { /*...*/ }

	/**
	 * Convert from one encoding to another one.
	 * @returns converted character count.
	 *
	 * example: convert utf-8 encoded file to ascii
	 * TextWriter output = AsciiWriter("out.txt");
	 * TextReader input = Utf8Reader("in.txt");
	 * output.write(input);
	 */
	static int write(TextWriter writer, TextReader reader) {
		unicode buffer[1024] = {};
		int result = 0;
		for ( ; ; ) {
			int n = reader.decode(buffer);
			if (n <= 0) {
				return result;
			}
			writer.encode(buffer[...n]);
			result += n;
		}
		return result;
	}

	/* TODO: subclasses
		Latin1
		Ascii
		Utf8
	*/
}

// copy byte-stream
struct CopyReader: ByteReader {
	const ByteReader source;
	const ByteWriter clone;

	// override
	int read(CopyReader this, byte bytes[]) {
		int result = this.source.read(bytes);
		if (result > 0) {
			this.clone.write(bytes[...result]);
		}
		return result;
	}

	// override
	void close(CopyReader this) {
		this.source.close();
		this.clone.close();
	}
}

// File streams
static if (typename(File) != null) {
inline "Stream.file.ci";
}

// TODO: untested
struct ByteBuffer {
	int position = 0;
	int capacity = 32;
	int length = 0;
	byte buffer[*] = pointer.alloc(null, capacity);

	int read(ByteBuffer this, byte bytes[]) {
		if (this.position >= this.length) {
			return -1;
		}
		for (int i = 0; i < bytes.length; i += 1) {
			if (this.position >= this.length) {
				return i;
			}
			bytes[i] = this.buffer[this.position];
			this.position += 1;
		}
		return bytes.length;
	}

	int read(ByteBuffer this) {
		if (this.position >= this.length) {
			return -1;
		}
		int result = this.buffer[this.position];
		this.position += 1;
		return result;
	}

	void write(ByteBuffer this, byte bytes[]) {
		int size = this.position + bytes.length;
		if (size >= this.capacity) {
			// try to double the current size
			this.capacity *= 2;
			if (size > 2 * this.capacity) {
				// double the calculated size
				this.capacity = size * 2;
			}

			// copy old bytes
			byte new[*] = pointer.alloc(null, this.capacity);
			for (int i = 0; i < this.position; i += 1) {
				new[i] = this.buffer[i];
			}
			pointer.alloc(this.buffer, 0);
			this.buffer = new;
		}

		// copy new bytes
		for (int i = 0; i < bytes.length; i += 1) {
			this.buffer[this.position] = bytes[i];
			this.position += 1;
		}
	}

	void flush(ByteBuffer this) {
		// do nothing
	}

	void close(ByteBuffer this) {
		// release memory
		pointer.alloc(this.buffer, 0);

		this.buffer = null;
		this.position = 0;
		this.capacity = 0;
		this.length = 0;
	}
}

static if (true) {
// todo: fix lookup and delete these global methods
static const FormatFlags flagsTextWriter = {};
static TextWriter write(TextWriter this, int32 value) { return this.write(value, flagsTextWriter); }
static TextWriter write(TextWriter this, int64 value) { return this.write(value, flagsTextWriter); }
static TextWriter write(TextWriter this, uint32 value) { return this.write(value, flagsTextWriter); }
static TextWriter write(TextWriter this, uint64 value) { return this.write(value, flagsTextWriter); }
static TextWriter write(TextWriter this, float32 value) { return this.write(value, flagsTextWriter); }
static TextWriter write(TextWriter this, float64 value) { return this.write(value, flagsTextWriter); }
static TextWriter writeln(TextWriter this, int32 value) { return this.write(value, flagsTextWriter).writeln(); }
static TextWriter writeln(TextWriter this, int64 value) { return this.write(value, flagsTextWriter).writeln(); }
static TextWriter writeln(TextWriter this, uint32 value) { return this.write(value, flagsTextWriter).writeln(); }
static TextWriter writeln(TextWriter this, uint64 value) { return this.write(value, flagsTextWriter).writeln(); }
static TextWriter writeln(TextWriter this, float32 value) { return this.write(value, flagsTextWriter).writeln(); }
static TextWriter writeln(TextWriter this, float64 value) { return this.write(value, flagsTextWriter).writeln(); }
static TextWriter writeln(TextWriter this, TextWriter.Writeable value) { return this.write(value).writeln(); }
}
