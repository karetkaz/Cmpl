// string related functions

/// Computes the length of the string
int length(char str[*]) {
	if (str == null) {
		return 0;
	}
	int result = 0;
	for (; str[result]; result += 1) {
	}
	return result;
}

/// Returns the index of the first occurrence of a character in string
int indexOf(char str[], char chr, int start) {
	for (int i = start; i < str.length; i += 1) {
		if (str[i] == chr) {
			return i;
		}
	}
	return -1;
}

/// Returns the position of a character inside an array of characters, returns a negative value if not found.
inline indexOf(char str[], char chr) = indexOf(str, chr, 0);

/// Check if a string contains the given character
inline contains(char str[], char chr) = indexOf(str, chr, 0) >= 0;

// compare the first n elements of two arrays, like memcmp
int compare(char str[*], char with[*], int length, int cmp(char chr, char with)) {
	if (cmp == null) {
		return pointer.compare(str, with, length);
	}
	for (int i = 0; i < length; i += 1) {
		int cmp = cmp(str[i], with[i]);
		if (cmp != 0) {
			return cmp;
		}
	}
	return 0;
}

/// ignore case character comparator
int ignCaseCmp(char a, char b) {
	// todo: performance check vs. a lookup table
	// make both characters lowercase
	if (a >= 'A' & a <= 'Z') {
		a -= 'A' - 'a';
	}
	if (b >= 'A' & b <= 'Z') {
		b -= 'A' - 'a';
	}
	return a - b;
}

/// default character comparator
int caseCmp(char chr, char with) = null;

/// Check if a string begins with a specified string, using a custom comparator
bool startsWith(char str[], char with[], int cmp(char chr, char with)) {
	if (str.length < with.length) {
		return false;
	}
	return compare(str, with, with.length, cmp) == 0;
}

/// Check if a string ends in a specified string, using a custom comparator
bool endsWith(char str[], char with[], int cmp(char chr, char with)) {
	if (str.length < with.length) {
		return false;
	}
	char end![*] = str.inc(str.length - with.length);
	return compare(end, with, with.length, cmp) == 0;
}

/// Check if the two strings are equal, less or greater, using a custom comparator
int compare(char str[], char with[], int cmp(char chr, char with)) {
	int length = str.length < with.length ? str.length : with.length;
	int result = compare(str, with, length, cmp);
	if (result != 0) {
		return result;
	}
//	return str.length - with.length;
	if (str.length < with.length) {
		return -1;
	}
	if (str.length > with.length) {
		return 1;
	}
	return 0;
}

/// convert lower part (4 bits) of the input value to the corresponding lower case hexadecimal character
inline toHex(int value) = "0123456789abcdef"[value & 0xf];

/// Check if a string begins with a specified string, using case-sensitive comparison
inline startsWith(char str[], char with[]) = startsWith(str, with, caseCmp);
/// Check if a string ends in a specified string, using case-sensitive comparison
inline endsWith(char str[], char with[]) = endsWith(str, with, caseCmp);
/// Check if the two strings are equal, less or greater, using case-sensitive comparison
inline compare(char str[], char with[]) = compare(str, with, caseCmp);
/// Check if the two strings are equal, using case-sensitive comparison
inline equals(char str[], char with[]) = compare(str, with, caseCmp) == 0;

/// reverse the characters in the string between start and end
static void reverse(char str&[], int start, int end) {
	assert(start >= 0 && start <= str.length);
	assert(end >= 0 && end <= str.length);
	if (start >= end) {
		return;
	}
	assert(start <= end);
	for (end -= 1; start < end; ) {
		char swap = str[start];
		str[start] = str[end];
		str[end] = swap;
		start += 1;
		end -= 1;
	}
}

/// remove the characters in the string between start and end
static void remove(char str&[], int start, int end) {
	assert(start >= 0 && start <= str.length);
	assert(end >= 0 && end <= str.length);
	if (start >= end) {
		return;
	}
	assert(start <= end);
	for (; end < str.length; ) {
		str[start] = str[end];
		start += 1;
		end += 1;
	}
}

/* TODO: implement operator overloading
inline ==(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) == 0;
inline !=(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) != 0;
inline <=(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) <= 0;
inline >=(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) >= 0;
inline <(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) < 0;
inline >(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) > 0;
// */

/// Convert a string to a 64 bit floating point value
float64 float64(char value[]) {
	float64 result = 0;
	static if (preferNativeCalls && struct(float64.parse) != null) {
		// use the native method if available
		int len = float64.parse(value, &result);
		if (len > 0 && len == value.length) {
			return result;
		}
		if (len > 0 && value[len] == 0) {
			return result;
		}
		error("value is not a floating point number", len, result, value);
		return Float64.nan;
	}

	float64 sign = 1;
	float64 decimal = 0;

	for (int i = 0; i < value.length && value[i] != 0; i += 1) {
		char chr = value[i];
		if (chr >= '0' && chr <= '9') {
			result = result * 10 + (chr - '0');
			decimal *= 10;
		}
		else if (chr == '.') {
			if (decimal != 0) {
				// multiple decimal points
				return Float64.nan;
			}
			decimal = 1;
		}
		else if (chr == '-' && i == 0) {
			sign = -1;
		}
		else if (chr == '+' && i == 0) {
			sign = 1;
		}
		else {
			// invalid character
			return Float64.nan;
		}
	}

	if (decimal == 0) {
		if (value.length > 0) {
			return sign * result;
		}
	}
	return sign * result / decimal;
}
