static if (typename(Timeunit) == null) {
inline "Timeunit.ci";
}
/**
 * Timestamp is a position in time, without timezone information
 * in case locale is needed use calendar.
 */
struct Timestamp {
	int64 value = 0;
	static const Timeunit precision = Timeunit.precision;

	static int64 value(Timestamp value, Timeunit precision) {
		return convert(value.value, Timestamp.precision, precision);
	}

	static Timestamp add(Timestamp lhs, int64 value, Timeunit precision) {
		return { value: lhs.value + convert(value, precision, Timestamp.precision) };
	}

	/**
	 * Floor the current datetime, leaving the field specified as the most significant field.
	 * For example, if you have the timestamp: 2002-03-28 13:45:01.231,
	 * using resolution Timeunit.Days, it should return 2002-03-28 00:00:00.000.
	 * using resolution Timeunit.Hours, it should return 2002-03-28 13:00:00.000.
	 * using resolution Timeunit.Minutes, it should return 2002-03-28 13:45:00.000.
	 *
	 * @param unit Resolution of the operation.
	 */
	static Timestamp floor(Timestamp value, Timeunit precision) {
		if (precision <= Timestamp.precision) {
			trace("small precision", precision);
			return value;
		}
		int64 one = convert(1D, precision, Timestamp.precision);
		return { value: value.value - value.value % one };
	}

	/**
	 * Ceil the current datetime, leaving the field specified as the most significant field.
	 * For example, if you have the timestamp: 2002-03-28 13:45:01.231,
	 * using resolution Timeunit.Days, it should return 2002-03-29 00:00:00.000.
	 * using resolution Timeunit.Hours, it should return 2002-03-28 14:00:00.000.
	 * using resolution Timeunit.Minutes, it should return 2002-03-28 13:46:00.000.
	 *
	 * @param unit Resolution of the operation.
	 */
	static Timestamp ceil(Timestamp value, Timeunit precision) {
		if (precision <= Timestamp.precision) {
			trace("small precision", precision);
			return value;
		}
		int64 one = convert(1D, precision, Timestamp.precision);
		int64 part = value.value % one;
		if (part == 0) {
			return value;
		}
		return { value: value.value - part + one };
	}

	/**
	 * Distribute randomly between current value and the duration at the given time-unit resolution.
	 * For example, if you had the timestamp: 2002-03-28 13:45:01.231,
	 * using distribute(Timeunit.Hours, 2), it will return a date between 2002-03-28 13:46:01.231 and 2002-03-28 15:46:01.231.
	 *
	 * @param unit  Resolution of the duration.
	 * @param duration The duration of the distribution time frame, negative values are allowed.
	 */
	static Timestamp distribute(Timestamp this, Timeunit unit, uint64 duration) {
		abort("not implemented");
		return { value: 0 };
	}

	/**
	 * Distribute randomly between start and end at the given time-unit resolution.
	 * For example, if you have the timestamp of 2002-03-28 13:46:01.231,
	 * using distribute(Timeunit.Hours, 15, 17) as start and end, it will return a date between 2002-03-28 15:46:01.231 and 2002-03-28 17:46:01.231.
	 * in case you need a timestamp between 15:00:00.000 and 17:00:00.000 yo will need to use the floor method before or after this operation.
	 *
	 * @param unit  Resolution of the operation.
	 * @param start The beginning of the distribution time frame.
	 * @param end   The end of the distribution time frame.
	 */
	static Timestamp distribute(Timestamp this, Timeunit unit, int start, int end) {
		return this./*setField(unit, start).*/distribute(unit, end - start);
	}

	static Timestamp now() {
		return { value: convert(System.millis(), Timeunit.Millis, Timestamp.precision) };
	}
}

Timestamp Timestamp(int64 value, Timeunit precision) {
	return { value: convert(value, precision, Timestamp.precision) };
}

/*static if (typename(Duration) != null) {
Timestamp add(Timestamp lhs, Duration rhs) {
	return { value: lhs.value + rhs.value(Timestamp.precision) };
}
}*/

/* TODO: inline initialization, operator overloading
inline Timestamp(int64 value, Timeunit precision) = {
	value: convert(value, precision, Timestamp.precision);
};

inline +(Timestamp lhs, Duration rhs) = Timestamp {
	value: lhs.value + rhs.value(Timestamp.precision);
};

*/
