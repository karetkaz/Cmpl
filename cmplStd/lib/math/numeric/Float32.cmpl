/// 32 bit floating point struct and mathematical methods
static struct Float32 {
	// Some useful mathematical constants
	enum: float32 {
		nan: 0 / 0.;
		inf: 1 / 0.;

		pi: Float64.pi;
		e: Float64.e;
	}

	/// return the 32 bit floating point value as an integer
	static uint32 toBits(float32 value) { return inline(value); }

	/// return the 32 bit integer as a floating point value
	static float32 fromBits(uint32 value) { return inline(value); }

	/// Computes the largest integer value not greater than the input
	static float32 floor(float32 x) {
		float32 mod = x % 1;
		if (mod < 0) {
			mod += 1;
		}
		return x - mod;
	}

	/// Computes the smallest integer not less than the input
	inline ceil(float32 x) = -floor(-x);

	/// Computes the nearest integer to the input
	inline round(float32 x) = floor(x + .5f);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float32 x) = int32(x > 0) - int32(x < 0);

	/// Returns the positive modulus of the input
	static float32 absMod(float32 val, float32 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	/// Returns the absolute value of the input
	inline abs(float32 x) = x < 0 ? -x : x;

	/// Returns the smaller value from the input values
	inline min(float32 a, float32 b) = a < b ? a : b;

	/// Returns the greater value from the input values
	inline max(float32 a, float32 b) = a > b ? a : b;

	/// Returns the `value` clamped between `min` and `max`
	inline clamp(float32 value, float32 min, float32 max) = min(max(value, min), max);

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline mix(float32 a, float32 b, float32 t) = a + t * (b - a);

	inline smoothstep(float32 t) = t * t * (3 - 2 * t);

	/// Returns the Hermite interpolation between two values
	inline smoothstep(float32 min, float32 max, float32 t) = smoothstep(clamp((t - min) / (max - min), 0f, 1f));


	/// Returns the natural logarithm of the argument `x`.
	static float32 ln(float32 x) {
		static if (preferNativeCalls && struct(float32.ln) != null) {
			// use the native method if available
			return float32.ln(x);
		}

		return float32(Float64.ln(float64(x)));
	}

	/// Returns the base-e exponential: $ e^x $.
	static float32 exp(float32 x) {
		static if (preferNativeCalls && struct(float32.exp) != null) {
			// use the native method if available
			return float32.exp(x);
		}

		return float32(Float64.exp(float64(x)));
	}

	/// Returns the base 2 logarithm of the argument `x`.
	static float32 log2(float32 x) {
		static if (preferNativeCalls && struct(float32.log2) != null) {
			// use the native method if available
			return float32.log2(x);
		}

		return float32(Float64.log2(float64(x)));
	}

	/// Returns the square root of the parameter `x`: $\sqrt{x}$.
	static float32 sqrt(float32 x) {
		static if (preferNativeCalls && struct(float32.sqrt) != null) {
			// use the native method if available
			return float32.sqrt(x);
		}

		return float32(Float64.sqrt(float64(x)));
	}

	/// Returns `x` raised to the power of `y`: $ x^y $.
	static float32 pow(float32 x, float32 y) {
		static if (preferNativeCalls && struct(float32.pow) != null) {
			// use the native method if available
			return float32.pow(x, y);
		}

		return float32(Float64.pow(float64(x), float64(y)));
	}


	/// Converts the input to radians from degrees.
	inline radians(float32 degrees) = degrees * pi / 180;

	/// Converts the input to degrees from radians.
	inline degrees(float32 radians) = radians * 180 / pi;

	/// Returns the sine of the radian argument `x`.
	static float32 sin(float32 x) {
		static if (preferNativeCalls && struct(float32.sin) != null) {
			// use the native method if available
			return float32.sin(x);
		}

		return float32(Float64.sin(float64(x)));
	}

	/// Returns the sine of the radian argument `x`.
	static float32 cos(float32 x) {
		static if (preferNativeCalls && struct(float32.cos) != null) {
			// use the native method if available
			return float32.cos(x);
		}

		return float32(Float64.cos(float64(x)));
	}

	/// Returns the tangent of the radian argument `x`.
	static float32 tan(float32 x) {
		static if (preferNativeCalls && struct(float32.tan) != null) {
			// use the native method if available
			return float32.tan(x);
		}

		return float32(Float64.tan(float64(x)));
	}

	/// Returns the inverse tangent of y/x.
	static float32 atan2(float32 y, float32 x) {
		static if (preferNativeCalls && struct(float32.atan2) != null) {
			// use the native method if available
			return float32.atan2(y, x);
		}

		return float32(Float64.atan2(float64(y), float64(x)));
	}

	/// Returns the inverse sine of the radian argument `x`.
	inline asin(float32 x) = atan2(x, sqrt((1 + x) * (1 - x)));

	/// Returns the inverse cosine of the radian argument `x`.
	inline acos(float32 x) = atan2(sqrt((1 + x) * (1 - x)), x);

	/// Returns the inverse tangent of the radian argument `x`.
	inline atan(float32 x) = atan2(x, 1);
}
