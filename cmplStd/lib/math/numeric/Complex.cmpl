/// Complex number
struct Complex {
	/// The real component of a complex number.
	float64 re;

	/// The imaginary component of a complex number.
	float64 im = 0;

	/// Unary negation of a complex number: -a := Complex(-a.re, -a.im);
	static Complex neg(Complex a) { return inline(inline(a), p128.neg2d); }

	/// Add two complex numbers: a + b := Complex(a.re + b.re, a.im + b.im);
	static Complex add(Complex a, Complex b) { return inline(inline(a), inline(b), p128.add2d); }
	/// Add a complex number `a` to a real number `b`
	static Complex add(Complex a, float64 b) { return { re: a.re + b, im: a.im }; }

	/// Subtract two complex numbers: a - b := Complex(a.re - b.re, a.im - b.im);
	static Complex sub(Complex a, Complex b) { return inline(inline(a), inline(b), p128.sub2d); }
	/// Subtract the real number `b` from the complex number `a`
	static Complex sub(Complex a, float64 b) { return { re: a.re - b, im: a.im}; }

	/// Multiply two complex numbers: a * b := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
	static Complex mul(Complex a, Complex b) {
		float64 re = inline(inline(a), inline(b), p128.mul2d, u64.swap, f64.sub);
		float64 im = inline(inline(a), inline(b), u64.swap, p128.mul2d, f64.add);
		return { re: re, im: im };
	}
	/// Multiply a complex number `a` with a real number `b`
	static Complex mul(Complex a, float64 b) { return {re: a.re * b, im: a.im * b}; }

	/// Divide two complex numbers
	static Complex div(Complex a, Complex b) {
		// Adapted from Numerical Recipes in C - The Art of Scientific Computing
		// ISBN 0-521-43108-5

		if (Float64.abs(b.re) >= Float64.abs(b.im)) {
			float64 r = b.im / b.re;
			float64 den = b.re + r * b.im;
			return {
				re: (a.re + r * a.im) / den;
				im: (a.im - r * a.re) / den;
			};
		}
		float64 r = b.re / b.im;
		float64 den = b.im + r * b.re;
		return {
			re: (a.re * r + a.im) / den;
			im: (a.im * r - a.re) / den;
		};
	}
	/// Divide the complex number `a` by the real number `b`
	static Complex div(Complex a, float64 b) { return { re: a.re / b, im: a.im / b}; }

	/// Compute the absolute value of the complex number `a`
	static float64 abs(Complex a) { return Float64.sqrt(a.re * a.re + a.im * a.im); }
	/// Compute the argument of the complex number `a`
	static float64 arg(Complex a) { return Float64.atan2(a.re, a.im); }

	/// Compute the reciprocal of a complex number (1 / a)
	static Complex inv(Complex a) {
		float64 d = a.re * a.re + a.im * a.im;
		return {
			re: +a.re / d;
			im: -a.im / d;
		};
	}

	/// Compute the conjugate of the complex number `a`
	static Complex conj(Complex a) { return {re: a.re, im: -a.im}; }

	/// Compute the exponential of a complex number: $ e^a $.
	static Complex exp(Complex a) {
		return {
			re: Float64.exp(a.re) * Float64.cos(a.im);
			im: Float64.exp(a.re) * Float64.sin(a.im);
		};
	}

	/// Compute the natural logarithm of the complex number `a`.
	static Complex ln(Complex a) { return { re: Float64.ln(abs(a)), im: arg(a) }; }

	/// Compute the complex number `a` raised to the power of `b`: $ a^b $.
	static Complex pow(Complex a, Complex b) {
		float64 r = a.abs();
		float64 t = a.arg();
		float64 u = b.re * t + b.im * Float64.ln(r);
		float64 v = Float64.pow(r, b.re) * Float64.exp(-b.im * t);
		return {
			re: v * Float64.cos(u);
			im: v * Float64.sin(u);
		};
	}
	/// Compute the complex number `a` raised to the power of `b`: $ a^b $.
	static Complex pow(Complex a, float64 b) {
		static Complex from(float64 re) { return {re: re, im: 0}; }
		return pow(a, from(b));
	}

	/// Compute the sine of the complex number `a`.
	static Complex sin(Complex a) {
		return {
			re: Float64.sin(a.re) * Float64.cosh(a.im);
			im: Float64.cos(a.re) * Float64.sinh(a.im);
		};
	}
	/// Compute the cosine of the complex number `a`.
	static Complex cos(Complex a) {
		return {
			re: Float64.cos(a.re) * Float64.cosh(a.im);
			im: -Float64.sin(a.re) * Float64.sinh(a.im);
		};
	}
	/// Compute the tangent of the complex number `a`.
	static Complex tan(Complex a) { return div(sin(a), cos(a)); }
	/// Compute the cotangent of the complex number `a`.
	static Complex cot(Complex a) { return div(cos(a), sin(a)); }
	/// Compute the secant of the complex number `a`.
	static Complex sec(Complex a) { return inv(cos(a)); }
	/// Compute the cosecant of the complex number `a`.
	static Complex csc(Complex a) { return inv(sin(a)); }

	/// Compute the hyperbolic sine of the complex number `a`.
	static Complex sinh(Complex a) { return div(sub(exp(a), exp(a.neg())), 2); }
	/// Compute the hyperbolic cosine of the complex number `a`.
	static Complex cosh(Complex a) { return div(add(exp(a), exp(neg(a))), 2); }
	/// Compute the hyperbolic tangent of the complex number `a`.
	static Complex tanh(Complex a) { return div(sub(exp(mul(a, 2)), 1), add(exp(mul(a, 2)), 1)); }
	/// Compute the hyperbolic cotangent of the complex number `a`.
	static Complex coth(Complex a) { return div(add(exp(mul(a, 2)), 1), sub(exp(mul(a, 2)), 1)); }
	/// Compute the hyperbolic secant of the complex number `a`.
	static Complex sech(Complex a) { return inv(cosh(a)); }
	/// Compute the hyperbolic cosecant of the complex number `a`.
	static Complex csch(Complex a) { return inv(sinh(a)); }
}

/// Create a Complex number from the given `value`
Complex Complex(float64 value) {
	return {
		re: value;
	};
}

/// Create a Complex number from the given `real` and `imaginary` values
Complex Complex(float64 real, float64 imaginary) {
	return {
		re: real;
		im: imaginary;
	};
}

/// Convert the from polar(r,θ) to cartesian(x,y) coordinates
inline toCartesian(Complex x) = Complex(x.re * Float64.cos(x.im), x.re * Float64.sin(x.im));
/// Convert the from cartesian(x,y) to polar(r,θ) coordinates
inline toPolar(Complex x) = Complex(x.abs(), x.arg());


/* TODO: implement enumerations, then:
enum: Complex {
	zero: { re: 0 };	// 0 + 0i
	unit: { re: 1 };	// 1 + 0i
}


// TODO: implement operator overloading, then:
inline -(Complex a) = Complex(-a.re, -a.im);

inline +(Complex a, Complex b) = Complex(a.re + b.re, a.im + b.im);
inline +(Complex a, float64 b) = Complex(a.re + b, a.im);
/// Add a complex number `b` to a real number `a`
inline +(float64 a, Complex b) = Complex(a + b.re, b.im);

inline -(Complex a, Complex b) = Complex(a.re - b.re, a.im - b.im);
inline -(Complex a, float64 b) = Complex(a.re - b, a.im);
/// Subtract the complex number `b` from the real number `a`
inline -(float64 a, Complex b) = Complex(a - b.re, b.im);

inline *(Complex a, Complex b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
inline *(Complex a, float64 b) = Complex(a.re * b, a.im * b);
/// Multiply a complex number `b` with a real number `a`
inline *(float64 a, Complex b) = Complex(a * b.re, a * b.im);

inline /(Complex a, Complex b) = div(a, b);
inline /(Complex a, float64 b) = div(a, Complex(b));
/// Divide the real number `a` by the complex number `b`
inline /(float64 a, Complex b) = Complex(a).div(b);
*/
