// test the emulated math trigonometry functions

void assertEq(float64 expected, Fixed retFixed, float64 maxErr&, const char func[*], variant args...) {
	if (!Math.isFinite(maxErr)) {
		// error is already invalid
		return;
	}
	float64 returned = float64(retFixed);
	if (returned == expected) {
		return;
	}

	if (Fixed.compare(retFixed, Fixed(expected)) == 0) {
		return;
	}

	if (Math.isNan(returned) && Math.isNan(expected)) {
		// nan === nan in this case
		return;
	}

	/*if (!Fixed.isFinite(Fixed(expected))) {
		return;
	}
	if (!Fixed.isFinite(retFixed)) {
		return;
	}*/

	float64 diff = Math.abs(returned - expected);
	if (diff == diff && diff < maxErr) {
		return;
	}
	maxErr = diff;
	static if (false) {
		struct Info {
			variant expected;
			variant returned;
			char func[*];
			variant args[];
		}
		Info info = {
			expected: expected;
			returned: returned;
			func: func;
			args: args;
		};
		if (diff > 0.25) {
			abort("assertion failed", info);
		}
	}
}

struct Domain {
	const float64 sc = 1;	// scale
	const float64 tr = 0;	// translate

	float64 castErr = 0;
	float64 fractErr = 0;
	float64 roundErr = 0;
	float64 invErr = 0;
	float64 log2Err = 0;
	float64 logErr = 0;
	float64 exp2Err = 0;
	float64 expErr = 0;
	float64 sqrtErr = 0;
	float64 powErr = 0;
	float64 sinErr = 0;
	float64 cosErr = 0;
	float64 tanErr = 0;
	float64 hypErr = 0;
	float64 arcErr = 0;
	float64 archErr = 0;

	static void normalize(Domain domain&) {
		domain.castErr = Math.log10(domain.castErr);
		domain.fractErr = Math.log10(domain.fractErr);
		domain.roundErr = Math.log10(domain.roundErr);
		domain.invErr = Math.log10(domain.invErr);
		domain.log2Err = Math.log10(domain.log2Err);
		domain.logErr = Math.log10(domain.logErr);
		domain.exp2Err = Math.log10(domain.exp2Err);
		domain.expErr = Math.log10(domain.expErr);
		domain.sqrtErr = Math.log10(domain.sqrtErr);
		domain.powErr = Math.log10(domain.powErr);
		domain.sinErr = Math.log10(domain.sinErr);
		domain.cosErr = Math.log10(domain.cosErr);
		domain.tanErr = Math.log10(domain.tanErr);
		domain.hypErr = Math.log10(domain.hypErr);
		domain.arcErr = Math.log10(domain.arcErr);
		domain.archErr = Math.log10(domain.archErr);
	}
}

int fixedPointPrecision = Fixed.precision;
Domain domains[] = {
	{sc: 1},                  // [0, 1)
	{tr: -1},                 // [-1, 0)
	{tr: 1},                  // [1, 2)
	{tr: 10},                 // [10, 11)
	{tr: 100},                // [100, 101)
	{tr: 10, sc: -20},        // [-10, 10)
	{tr: 100, sc: -200},      // [-100, 100)
	{tr: 1000, sc: -2000},    // [-1000, 1000)
	{tr: 10000, sc: -20000},  // [-10000, 10000)
};// */

for (int n = 0; n < domains.length; n += 1) {
	Domain domain& = domains[n];
	float64 scale = domain.sc / Fixed.one;
	float64 translate = domain.tr;
	for (int32 Y = 0; Y < Fixed.one; Y += 1) {
		Fixed f = Fixed(Y * scale + translate);
		float64 x = float64(f);

		assertEq(Y * scale + translate, f, &domain.castErr, "cast(x)", x, f);
		assertEq(1. / x, Fixed.inv(f), &domain.invErr, "inv(x)", x, f);
		assertEq(x % 1, Fixed.fract(f), &domain.fractErr, "fract(x)", x, f);
		assertEq(Math.floor(x), Fixed.floor(f), &domain.roundErr, "floor(x)", x, f);
		assertEq(Math.ceil(x), Fixed.ceil(f), &domain.roundErr, "ceil(x)", x, f);
		assertEq(Math.round(x), Fixed.round(f), &domain.roundErr, "round(x)", x, f);
		assertEq(Math.log2(x), Fixed.log2(f), &domain.log2Err, "log2(x)", x, f);
		assertEq(Math.pow(2, x), Fixed.exp2(f), &domain.exp2Err, "exp2(x)", x, f);
		assertEq(Math.sqrt(x), Fixed.sqrt(f), &domain.sqrtErr, "sqrt(x)", x, f);
		assertEq(Math.log(x), Fixed.log(f), &domain.logErr, "log(x)", x, f);
		assertEq(Math.exp(x), Fixed.exp(f), &domain.expErr, "exp(x)", x, f);
		assertEq(Math.sin(x), Fixed.sin(f), &domain.sinErr, "sin(x)", x, f);
		assertEq(Math.cos(x), Fixed.cos(f), &domain.cosErr, "cos(x)", x, f);
		assertEq(Math.tan(x), Fixed.tan(f), &domain.tanErr, "tan(x)", x, f);
		assertEq(Math.sinh(x), Fixed.sinh(f), &domain.hypErr, "sinh(x)", x, f);
		assertEq(Math.degrees(x), Fixed.degrees(f), &domain.roundErr, "degrees(x)", x, f);
		assertEq(Math.radians(x), Fixed.radians(f), &domain.roundErr, "degrees(x)", x, f);

		Fixed g = Fixed(Y * scale * .5 + translate);
		float64 y = float64(g);// (N + Y) / N;
		assertEq(float64.pow(x, y), Fixed.pow(f, g), &domain.powErr, "pow(x, y)", x, y, f, g);
		assertEq(float64.pow(y, x), Fixed.pow(g, f), &domain.powErr, "pow(y, x)", x, y, f, g);
	}
	Domain.normalize(&domain);
}

/* generate lookup table and constants
FormatFlags flags = {width: 8, padChr: '0'};
char buff[1024] = {0};

inline n = 256;
for (int i = 0; i <= n; i += 1) {
	if (i > 0) {
		File.out.write(",");
	}
	if (i % 8 == 0) {
		File.out.write("\n");
	} else {
		File.out.write(" ");
	}

	float64 x = float64.log2(i / float64(n) + 1);
//	float64 x = float64.exp2(i / float64(n)) - 1;
	int64 val = x * (1 << 28);
	int p = buff.append(0, "0x");
	p = buff.append(p, 16, val, flags);
	File.out.write(buff[...p]);
}

if (!true) {
	int64 val = Math.pi / 180 * (1 << 28);
	int p = buff.append(0, "\npi / 180 = 0x");
	p = buff.append(p, 16, val, flags);
	File.out.write(buff[...p]);
}
// */

/* references
https://www.musicdsp.org/en/latest/Other/106-fast-exp2-approximation.html
https://www.desmos.com/calculator/sgbqxe08w4
// */

/* todo: leftovers
exp(underflow) = 0	underflow for double: -7.08396418532264106224E2;     log 2**-1022
exp(overflow) = Inf overflow for double:   7.08396418532264106224E2;     log 2**1022

inline sign(Fixed x) = int(x.value > 0) - int(xx.value < 0);
inline abs(Fixed x) = x.value < 0 ? as(-x.value) : x;
inline min(Fixed x, Fixed y)?;
inline max(Fixed x, Fixed y)?;
clamp;
mix;
smoothstep;
rsqrt(x) = pow(x, -.5);

long atan2(long x, long y) {
	static long const polyatan[4] = {			// eps < 0.000195 in [-9, +9] R
		-TOFIXED(0.0410220),
		+TOFIXED(0.1493840),
		-TOFIXED(0.3224560),
		+TOFIXED(0.9993370),
	};

	long mx, my, tmp, res;
	//~ if (!x || !y) return 0;
	mx = (x < 0 ? -x : x);
	my = (y < 0 ? -y : y);
	tmp = fxpdiv(mx < my ? mx : my, mx > my ? mx : my);
	res = fxvevalp(polyatan, fxpmul(tmp, tmp));
	res = fxpmul(res, tmp);
	res = (mx > my) ? FXP_PI2 - res : res;
	res = (y < 0) ? FXP_MPI - res : res;
	res = (x < 0) ? -res : res;
	return res;
}

long asin(long x) {
	static long const polyasin[4] = {		// eps < 0.000106 in [-1, +1]
		-TOFIXED(0.0187293),
		+TOFIXED(0.0742610),
		-TOFIXED(0.2121144),
		+TOFIXED(1.5707288),
	};

	long res, neg = 2 * (x < 0);
	x = x < 0 ? -x : x;
	res = fxvevalp(polyasin, x);
	res = fxpmul(res, fxpsqrt(FXP_ONE - x));
	res -= neg * (res - FXP_PI2);
	return FXP_PI2 - res;
}

long acos(long x) {
	static long const polyacos[4] = {		// eps < 0.000117 in [-1, +1]
		-TOFIXED(0.0187293),
		+TOFIXED(0.0742610),
		-TOFIXED(0.2121144),
		+TOFIXED(1.5707288),
	};

	long res, neg = 2 * (x < 0);
	x = x < 0 ? -x : x;
	res = fxvevalp(polyacos, x);
	res = fxpmul(res, fxpsqrt(FXP_ONE - x));
	res += neg * (FXP_PI2 - res);
	return res;
}
*/
