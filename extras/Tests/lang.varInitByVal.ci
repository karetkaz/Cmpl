// requires `-X+glob` option to generate non static global variables

static if (typename(integer) == null) {
inline integer = int32;
}

integer localNoInit;
static integer globalNoInit;
integer localInitValue = 42;
static integer globalInitValue = 1024;
integer localInitLocal = localInitValue;
static integer globalInitLocal = localInitValue;
integer localInitGlobal = globalInitValue;
static integer globalInitGlobal = globalInitValue;

//* TODO: member, local and global variable initializations
struct InitMember {
	// member variable
	// compiler: WARN if not initialized when instantiated.
	int32 intMember;

	// member variable with default value
	// compiler: use default value if not initialized when instantiated.
	int32 intMemberDef = 9;

	// constant member variable
	// compiler: ERROR if not initialized when instantiated.
	// compiler: ERROR if assigned after initialization.
	const int32 intConstMember;

	// constant member variable with default value
	// compiler: use default value if not initialized when instantiated.
	// compiler: ERROR if assigned after initialization.
	const int32 intConstMemberDef = 42;

	// global variable(hidden in class)
	// compiler: WARN if not initialized when declared.
	static int32 intGlobal = 0;

	// constant global variable(hidden in class)
	// compiler: ERROR if not initialized when declared.
	// compiler: ERROR if assigned after initialized.
	static const int32 intConstant = 0;

	/* TODO: implement function parsing
	// static method (can not be overridden)
	int staticMethod(int x, int y) {
		return x + y;
	}

	// static forward method
	// compiler: ERROR if not implemented in the current record.
	static int forwardMethod(int x, int y);

	// virtual method (may be overridden when instantiated)
	int virtualMethod(int x, int y) = staticMethod;

	// abstract method (must be overridden when instantiated)
	// compiler: ERROR if not initialized/overridden when instantiated.
	int abstractMethod(int x, int y);

	// forward method implementation
	int forwardMethod(int x, int y) {
		return x * y;
	}

	/+ FIXME: virtualMethod2 will point to ... when overridden / not overridden?
	// virtual method (may be overridden when instantiated)
	int virtualMethodA(int x, int y);

	// virtual method (may be overridden when instantiated)
	int virtualMethodB(int x, int y) = virtualMethodA;

	// virtual method implementation.
	int virtualMethodA(int x, int y) {
		return x * y;
	}
	// +/ */
}

/*void initLocals() {
	// local variable
	// compiler: WARN if not initialized when declared.
	int32 local;

	// constant local variable
	// compiler: ERROR if not initialized when declared.
	const int32 constant = 31;

	// global variable
	// compiler: WARN if not initialized when declared.
	static int32 global = 7;

	// constant global variable.
	// compiler: ERROR if not initialized when declared.
	static const int32 globalConstant = 4;
}

InitMember globalOrLocal = {
	intMember: 42;
	intConstMember: 42;
	int abstractMethod(int x, int y) {
		return x - y;
	}
};

static InitMember global = {
	intMember: 42;
	intConstMember: 42;
	int abstractMethod(int x, int y) {
		return x - y;
	}
};
// */