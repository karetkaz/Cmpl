// InputOutput

struct Closeable: object {
	// abstract method
	void close(Closeable closeable);
}

// ByteReader ~= java:InputStream
struct ByteReader: Closeable {

	// abstract method
	int read(ByteReader this, byte bytes[]);

	int read(ByteReader this) {
		byte bytes[1];
		result = this.read(bytes);
		if (result > 0) {
			result = bytes[0];
		}
		return result;
	}

	// TODO: bool read(ByteReader this, int8 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, int16 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, int32 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, int64 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, uint8 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, uint16 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, uint32 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, uint64 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, float32 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, float64 &value) { /*...*/ }
	// TODO: bool read(ByteReader this, variant value) { /*???*/ }

	/* TODO: subclasses
		CopyReader
		FileReader
		PipedReader
		SocketReader
		MemoryReader
	*/
}

// ByteWriter ~= java:OutputStream
struct ByteWriter: Closeable {

	// abstract method
	int write(ByteWriter this, byte bytes[]);

	// abstract method
	void flush(ByteWriter this);

	int write(ByteWriter this, byte oneByte) {
		byte bytes[1] = { oneByte };
		return this.write(bytes);
	}

	// TODO: bool write(ByteWriter this, int8 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, int16 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, int32 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, int64 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, uint8 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, uint16 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, uint32 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, uint64 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, float32 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, float64 value) { /*...*/ }
	// TODO: bool write(ByteWriter this, variant value) { /*???*/ }

	/* TODO: subclasses
	 ?	CopyWriter
		FileWriter
		PipedWriter
		SocketWriter
		MemoryWriter
	*/
}

struct CopyReader: ByteReader {  // Tee
	const ByteReader source;
	const ByteWriter clone;

	int read(CopyReader this, byte bytes[]) {
		result = this.source.read(bytes);
		if (result > 0) {
			this.clone.write(bytes[0, result]);
		}
		return result;
	}

	void close(CopyReader this) {
		// FIXME: do we need to close these streams?
		this.source.close();
		this.copy.close();
	}

	inline CopyReader(ByteReader source, ByteWriter clone) = {
		source: source;
		clone: clone;
	};
}

struct FileReader: ByteReader {
	const File file;
	const bool close;

	int read(FileReader this, byte bytes[]) {
		return File.read(this.file, bytes);
	}

	void close(FileReader this) {
		if (this.close) {
			File.close(this.file);
		}
	}

	// initializer
	inline FileReader(File file) = {
		file: file;
		close: false;   // we did not open it, we will not close it.
	};

	inline FileReader(Path path) = {
		file: File.open(path);
		close: true;    // we did open it, we will close it.
	};
}
struct FileWriter: ByteWriter {
	const File file;
	const bool close;

	int write(FileWriter this, byte bytes[]) {
		return File.write(this.file, bytes);
	}

	void flush(FileWriter this) {
		return File.flush(this.file);
	}

	void close(FileWriter this) {
		if (this.close) {
			File.close(this.file);
		}
	}

	// initializer
	inline FileWriter(File file) = {
		file: file;
		close: false;   // we did not open it, we will not close it.
	};

	inline FileWriter(Path path, bool append) = {
		file: append ? File.append(path) : File.create(path);
		close: true;    // we did open it, we will close it.
	};
}

// TextReader := Decoder & Parser
struct TextReader: Closeable {  // java:Reader + Scanner?Parser?
	const ByteReader reader;
	const bool close;

	// abstract method
	int decode(ByteReader reader, char chars[]);

	int read(TextReader this, char chars[]) {
		return this.decode(this.reader, chars);
	}

	int read(TextReader this) {
		char chars[1];
		result = this.read(chars);
		if (result > 0) {
			result = chars[0];
		}
		return result;
	}

	void close(Utf8Reader this) {
		if (this.close) {
			this.reader.close();
		}
	}

	// TODO: string readToken(TextReader this, regex matcher) { /*...*/ }
	// TODO: string readWord(TextReader this) { return this.readToken(/\w+/); }
	// TODO: string readLine(TextReader this) { return this.readToken(/^.*$/); }
	// TODO: string readNumber(TextReader this, Locale locale) { /*...*/ }

	/* TODO: subclasses
		Latin1
		Ascii
		Utf7
		Utf8
	*/
}

// TextWriter := Encoder & Printer
struct TextWriter: Closeable {  // java:Writer + PrintStream
	const ByteWriter writer;
	const bool close;

	// abstract method
	int encode(ByteWriter this, char chars[]);

	int write(TextWriter this, char chars[]) {
		return this.encode(this.writer, chars);
	}

	int write(ByteWriter this, char oneChar) {
		char chars[1] = { oneChar };
		return this.write(chars);
	}

	void flush(TextWriter this) {
		this.writer.flush();
	}

	void close(Utf8Writer this) {
		if (this.close) {
			this.writer.close();
		}
	}

	// TODO: bool print(TextWriter this, Locale locale, bool value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, char value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, int32 value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, int64 value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, uint32 value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, uint64 value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, float32 value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, float64 value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, string value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, object value) { /*...*/ }
	// TODO: bool print(TextWriter this, Locale locale, variant value) { /*...*/ }

	/* TODO: subclasses
		Latin1
		Ascii
		Utf7
		Utf8
	*/
}

struct AsciiReader: TextReader {

	int decode(ByteReader reader, char chars[]) {
		for (result = 0; result < chars.length; result += 1) {
			int value = reader.read();
			if (value < 0) {
				// end of stream
				break;
			}
			chars[i] = value;
		}
		return result;
	}

	// initializer
	inline AsciiReader(ByteReader reader) = {
		reader: reader;
		close: false;
	};

	inline AsciiReader(Path path) = {
		reader: FileReader(path);
		close: true;
	};
}
struct AsciiWriter: TextWriter {

	int encode(ByteWriter writer, char chars[]) {
		result = 0;
		for (int i = 0; i < chars.length; i += 1) {
			int chr = chars[i];
			if (writer.write(chr) < 0) {
				// destination stream closed?
				break;
			}
			result += 1;
		}
		return result;
	}

	// initializer
	inline AsciiWriter(ByteWriter writer) = {
		writer: writer;
		close: false;
	};

	inline AsciiWriter(Path path, bool append) = {
		writer: FileWriter(path, append);
		close: true;
	};
}

struct Utf8Reader: TextReader {

	int decode(ByteReader reader, char chars[]) {
		for (result = 0; result < chars.length; result += 1) {
			int value = reader.read();
			if (value < 0) {
				// end of stream
				break;
			}

			if ((value & 0x80) == 0) {
				// value = value;
			}
			else if ((value & 0xe0) == 0xc0) {
				int val1 = this.reader.read() & 0x3f;
				value = (value & 31) << 6 | val1;
			}
			else if ((value & 0xf0) == 0xe0) {
				int val1 = this.reader.read() & 0x3f;
				int val2 = this.reader.read() & 0x3f;
				value = (value & 15) << 12 | val1 << 6| val2;
			}
			else if ((value & 0xf8) == 0xf0) {
				int val1 = this.reader.read() & 0x3f;
				int val2 = this.reader.read() & 0x3f;
				int val3 = this.reader.read() & 0x3f;
				value = (value & 7) << 18 | val1 << 12 | val2 << 6 | val3;
			}
			chars[i] = value;
		}
		return result;
	}

	// initializer
	inline Utf8Reader(ByteReader reader) = {
		reader: reader;
		close: false;
	};

	inline Utf8Reader(Path path) = {
		reader: FileReader(path);
		close: true;
	};
}
struct Utf8Writer: TextWriter {

	int encode(ByteWriter writer, char chars[]) {
		result = 0;
		for (int i = 0; i < chars.length; i += 1) {
			int chr = chars[i];
			byte bytes[4];
			int size = 0;

			if (chr < 0x80) {
				bytes[0] = chr;
				size = 1;
			}
			else if (chr < 0x800) {
				bytes[0] = (chr & 0x7c0) >> 6 | 0xc0;
				bytes[1] = chr & 0x3f | 0x80;
				size = 2;
			}
			else if (chr < 0xe000) {
				bytes[0] = (chr & 0xf000) >> 12 | 0xe0;
				bytes[1] = (chr & 0xfc) >> 6 | 0x80;
				bytes[2] = chr & 0x3f | 0x80;
				size = 3;
			}
			else {
				bytes[0] = (chr & 0x1c0000) >> 18 | 0xf0;
				bytes[1] = (chr & 0x3f0) >> 12 | 0x80;
				bytes[2] = (chr & 0xfc) >> 6 | 0x80;
				bytes[3] = chr & 0x3f | 0x80;
				size = 4;
			}
			// FIXME: what if size is 4 but we write only 2 bytes?
			if (writer.write(bytes[0, size]) < 0) {
				// destination stream closed?
				break;
			}
			result += size;
		}
		return result;
	}

	// initializer
	inline Utf8Writer(ByteWriter writer) = {
		writer: writer;
		close: false;
	};

	inline Utf8Writer(Path path, bool append) = {
		writer: FileWriter(path, append);
		close: true;
	};
}

/*
struct Path {
	bool exists();
	bool isFile();
	bool isDirectory();
	bool isHidden();
	bool isAbsolute();

	Path parent();
	// permissions: canRead,write,execute,...
}

//~ */
