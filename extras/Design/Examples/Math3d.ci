//~ some basic 3d math (vector + matrix)

struct vec4f {
	float32 x;
	float32 y;
	float32 z;
	float32 w;
}

inline vec4f(float32 x, float32 y, float32 z, float32 w) = { x: x, y: y, z: z, w: w };
inline vec4f(float32 x, float32 y, float32 z) = vec4f(x, y, z, 0f);
inline vec4f(vec4f v, float32 w) = vec4f(v.x, v.y, v.z, w);
inline vec4f(float32 val) = vec4f(val, val, val, val);

inline -(vec4f a) = vec4f(-a.x, -a.y, -a.z, -a.w);

//~ inline +(vec4f a, vec4f b) = vec4f(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
inline +(vec4f a, vec4f b) = emit(add.p4f, vec4f(a), vec4f(b));
inline +(vec4f a, float32 b) = a + vec4f(b);
inline +(float32 a, vec4f b) = vec4f(a) + b;

//~ inline -(vec4f a, vec4f b) = vec4f(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
inline -(vec4f a, vec4f b) = emit(sub.p4f, vec4f(a), vec4f(b));
inline -(vec4f a, float32 b) = a - vec4f(b);
inline -(float32 a, vec4f b) = vec4f(a) - b;

//~ inline *(vec4f a, vec4f b) = vec4f(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
inline *(vec4f a, vec4f b) = emit(mul.p4f, vec4f(a), vec4f(b));
inline *(vec4f a, float32 b) = mul(a, vec4f(b));
inline *(float32 a, vec4f b) = mul(vec4f(a), b);

//~ inline /(vec4f a, vec4f b) = vec4f(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
inline /(vec4f a, vec4f b) = emit(div.p4f, vec4f(a), vec4f(b));
inline /(vec4f a, float32 b) = a / vec4f(b);
inline /(float32 a, vec4f b) = vec4f(a) / b;

inline min(vec4f a, vec4f b) = emit(min.p4f, vec4f(b), vec4f(a));
inline max(vec4f a, vec4f b) = emit(max.p4f, vec4f(b), vec4f(a));

inline mad(vec4f a, vec4f b, vec4f c) = emit(add.p4f, mul.p4f, vec4f(a), vec4f(b), vec4f(c));	// a * b + c

//~ inline dp3(vec4f a, vec4f b) = b.x * a.x + b.y * a.y + b.z * a.z;
inline dp3(vec4f a, vec4f b) = emit(p4x.dp3, vec4f(b), vec4f(a));
//~ inline dph(vec4f a, vec4f b) = b.x * a.x + b.y * a.y + b.z * a.z + b.w;
inline dph(vec4f a, vec4f b) = emit(p4x.dph, vec4f(b), vec4f(a));
//~ inline dp4(vec4f a, vec4f b) = b.x * a.x + b.y * a.y + b.z * a.z + b.w * a.w;
inline dp4(vec4f a, vec4f b) = emit(p4x.dp4, vec4f(b), vec4f(a));

inline cross(vec4f a, vec4f b) = vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);

inline lerp(float32 t, vec4f a, vec4f b) = vec4f(Math.lerp(t, a.x, b.x), Math.lerp(t, a.y, b.y), Math.lerp(t, a.z, b.z), Math.lerp(t, a.w, b.w));

inline len(vec4f v) = float64.sqrt(dp3(v, v));
inline eval(vec4f v, float32 x) = float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
inline normalize(vec4f a) = a / len(a);

// inline float32(vec4f vec) = vec.w;
// inline bool(vec4f vec) = vec.x && vec.y && vec.z && vec.w;

struct mat4f {
	vec4f x;
	vec4f y;
	vec4f z;
	vec4f w;
}

inline mat4f(
	float32 m11, float32 m12, float32 m13, float32 m14,
	float32 m21, float32 m22, float32 m23, float32 m24,
	float32 m31, float32 m32, float32 m33, float32 m34,
	float32 m41, float32 m42, float32 m43, float32 m44
) = mat4f {
	x: vec4f(m11, m12, m13, m14);
	y: vec4f(m21, m22, m23, m24);
	z: vec4f(m31, m32, m33, m34);
	w: vec4f(m41, m42, m43, m44);
};

inline dp3(const mat4f &mat, const vec4f &vec) = vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1f);
inline dph(const mat4f &mat, const vec4f &vec) = vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
inline dp4(const mat4f &mat, const vec4f &vec) = vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));

inline transposed(mat4f &mat) = mat4f(
	mat.x.x, mat.y.x, mat.z.x, mat.w.x,
	mat.x.y, mat.y.y, mat.z.y, mat.w.y,
	mat.x.z, mat.y.z, mat.z.z, mat.w.z,
	mat.x.w, mat.y.w, mat.z.w, mat.w.w
);

mat4f mul(mat4f &a, const mat4f &b) {
	mat4f transposed = transposed(b);
	return {
		x: dp4(transposed, a.x);
		y: dp4(transposed, a.y);
		z: dp4(transposed, a.z);
		w: dp4(transposed, a.w);
	};
}

inline *(mat4f &a, mat4f &b) = mul(a, b);
