
static if (typename(vec2d) == null) {
struct vec2d {
	float64 x;
	float64 y;
}

vec2d vec2d(float64 x, float64 y) {
	return {
		x: x;
		y: y;
	};
}

inline sub(vec2d a, vec2d b) = vec2d(emit(vec2d(a), vec2d(b), sub.p2d));
/*vec2d sub(const vec2d a&, const vec2d b&) {
	return {
		x: a.x - b.x;
		y: a.y - b.y;
	};
}*/

float64 dot(const vec2d a, const vec2d b) {
	return a.x * b.x + a.y * b.y;
}

}
static if (typename(vec4f) == null) {
struct vec4f {
	float32 x;
	float32 y;
	float32 z;
	float32 w;
}

vec4f vec4f(float32 x, float32 y, float32 z, float32 w) {
	return { x: x, y: y, z: z, w: w };
}
vec4f vec4f(float32 x, float32 y, float32 z) {
	return { x: x, y: y, z: z, w: 0 };
}
vec4f vec4f(float32 xyzw) {
	return { x: xyzw, y: xyzw, z: xyzw, w: xyzw };
}
}

static if (true) {

uint32 grayClamp(uint32 c) {
	if (c > 255) {
		return 255;
	}
	return c;
}
uint32 grayClamp(int32 c) {
	if (c < 0) {
		return 0;
	}
	if (c > 255) {
		return 255;
	}
	return c;
}
inline grayAnd(uint32 c) = uint32(c & 255);

inline rgb(uint32 r, uint32 g, uint32 b) = uint32((((r << 8) | g) << 8) | b);
inline rgbClamp(uint32 r, uint32 g, uint32 b) = rgb(grayClamp(r), grayClamp(g), grayClamp(b));
inline rgbClamp(int32 r, int32 g, int32 b) = rgb(grayClamp(r), grayClamp(g), grayClamp(b));
inline rgbAnd(uint32 r, uint32 g, uint32 b) = rgb(grayAnd(r), grayAnd(g), grayAnd(b));

inline rgb(float64 r, float64 g, float64 b) = rgbClamp(int32(r * 255), int32(g * 255), int32(b * 255));
inline rgb(float32 r, float32 g, float32 b) = rgbClamp(int32(r * 255), int32(g * 255), int32(b * 255));
inline rgb(vec4f vec) = rgbClamp(int32(vec.x * 255), int32(vec.y * 255), int32(vec.z * 255));
inline gray(float64 c) = grayClamp(int32(c * 255));
inline gray(float32 c) = grayClamp(int32(c * 255));

// get the Red channel of the color
inline rch(int32 col) = int32((col >> 16) & 0xff);
// get the Green channel of the color
inline gch(int32 col) = int32((col >> 8) & 0xff);
// get the Blue channel of the color
inline bch(int32 col) = int32(col & 0xff);
// get the luminosity of the color
inline lum(int32 c) = int32((rch(c) * 76 + gch(c) * 150 + bch(c) * 29) >> 8);

/*struct rgb:1 {
	int8 b;
	int8 g;
	int8 r;
	int8 x;
}

define int32(rgb value) = emit(int, rgb(value));
define asrgb(int32 value) = emit(rgb, int32(value));
define asrgb(int r, int g, int b) = emit(rgb, rgb(r, g, b));
*/

uint32 rgbOr(uint32 c1, uint32 c2) {
	return c1 | c2;
}
uint32 rgbXor(uint32 c1, uint32 c2) {
	return c1 ^ c2;
}
uint32 rgbAnd(uint32 c1, uint32 c2) {
	return c1 & c2;
}
uint32 rgbAdd(uint32 c1, uint32 c2) {
	uint32 r = rch(c1) + rch(c2);
	uint32 g = gch(c1) + gch(c2);
	uint32 b = bch(c1) + bch(c2);
	return rgbClamp(r, g, b);
}
uint32 rgbAvg(uint32 c1, uint32 c2) {
	uint32 r = (rch(c1) + rch(c2)) / 2;
	uint32 g = (gch(c1) + gch(c2)) / 2;
	uint32 b = (bch(c1) + bch(c2)) / 2;
	return rgb(r, g, b);
}
uint32 rgbSub(uint32 c1, uint32 c2) {
	int32 r = rch(c1) - rch(c2);
	int32 g = gch(c1) - gch(c2);
	int32 b = bch(c1) - bch(c2);
	return rgbClamp(r, g, b);
}
uint32 rgbMul(uint32 c1, uint32 c2) {
	uint32 r = (rch(c1) * (rch(c2) + 1)) >> 8;
	uint32 g = (gch(c1) * (gch(c2) + 1)) >> 8;
	uint32 b = (bch(c1) * (bch(c2) + 1)) >> 8;
	return rgb(r, g, b);
}
uint32 rgbDiv(uint32 c1, uint32 c2) {
	uint32 r = (rch(c1) << 8) / (rch(c2) + 1);
	uint32 g = (gch(c1) << 8) / (gch(c2) + 1);
	uint32 b = (bch(c1) << 8) / (bch(c2) + 1);
	return rgb(r, g, b);
}

uint32 rgbLerp16(uint32 c1, uint32 c2, uint32 t) {
	inline lrpfix16(uint32 x, uint32 y) = uint32(x + (t * (y - x) >> 16));

	uint32 r = lrpfix16(rch(c1), rch(c2));
	uint32 g = lrpfix16(gch(c1), gch(c2));
	uint32 b = lrpfix16(bch(c1), bch(c2));
	return rgb(r, g, b);
}

uint32 rgbLerp(uint32 c1, uint32 c2, double t) {
	return rgbLerp16(c1, c2, uint32(t * (1 << 16)));
}

vec4f Hsv2Rgb(vec4f hsv) {
	float32 h = hsv.x;
	float32 s = hsv.y;
	float32 v = hsv.z;

	if (s == 0) {
		return vec4f(v);
	}

	h *= 360 / 60;

	int i = int(h);		// round
	float32 f = h - i;	// fract

	float32 u = v;
	float32 p = v * (1 - s);
	float32 q = v * (1 - s * f);
	float32 t = v * (1 - s * (1 - f));

	if (i == 0) {
		return vec4f(u, t, p);
	}
	if (i == 1) {
		return vec4f(q, u, p);
	}
	if (i == 2) {
		return vec4f(p, u, t);
	}
	if (i == 3) {
		return vec4f(p, q, u);
	}
	if (i == 4) {
		return vec4f(t, p, u);
	}
	return vec4f(u, p, q);
}

}

inline gxSurf(int width, int height, int depth) = gxSurf.create(width, height, depth);

gxSurf gxSurf(char fileName[*], int depth) {

// TODO: move to stdlib
static int strlen(char str[*]) {
	int result = 0;
	for (result = 0; str[result]; result += 1) {}
	return result;
}

static bool endsWith(char str[*], char with[*]) {
	int strLen = strlen(str);
	int withLen = strlen(with);
	if (strLen < withLen) {
		return false;
	}
	for (int i = 0; i < withLen; i += 1) {
		if (str[strLen - i] != with[withLen - i]) {
			return false;
		}
	}
	return true;
}

	if (fileName.endsWith(".jpg")) {
		return gxSurf.openJpg(fileName, depth);
	}
	if (fileName.endsWith(".png")) {
		return gxSurf.openPng(fileName, depth);
	}
	if (fileName.endsWith(".bmp")) {
		return gxSurf.openBmp(fileName, depth);
	}
	abort("error opening file", fileName);
}

//inline gxSurf(char fileName[*]) = gxSurf(fileName, 32);
//inline gxSurf(int width, int height) = gxSurf.create(width, height, 32);
// TODO: inline gxSurf(gxSurf copy) = copySurf(newSurf(width(copy), height(copy)), 0, 0, copy, null);

//inline fillRect(gxSurf dst, gxRect roi, int col) = fillRect(dst, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);
//inline drawRect(gxSurf dst, gxRect roi, int col) = drawRect(dst, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);

bool clipRect(gxSurf src, gxRect roi&) {
	int minx = 0;
	int miny = 0;
	int maxx = src.width();
	int maxy = src.height();

	roi.w += roi.x;
	roi.h += roi.y;

	if (roi.x < minx)
		roi.x = minx;
	if (roi.y < miny)
		roi.y = miny;
	if (roi.w > maxx)
		roi.w = maxx;
	if (roi.h > maxy)
		roi.h = maxy;

	roi.w -= roi.x;
	roi.h -= roi.y;

	return roi.w > 0 && roi.h > 0;
}
void evalSurf(gxSurf dst, gxRect roi&, vec4f eval(double x, double y)) {
	gxRect rect;
	/*FIXME:
	if (roi == null) {
		rect.x = rect.y = 0;
		rect.w = dst.width();
		rect.h = dst.height();
	}
	else {
		rect = roi;
	}*/
	double dx = 1. / rect.w;
	double dy = 1. / rect.h;

	double y01 = 0;
	for (int y = rect.y; y < rect.y + rect.h; y += 1) {
		double x01 = 0;
		for (int x = rect.x; x < rect.x + rect.w; x += 1) {
			dst.set(x, y, rgb(eval(x01, y01)));
			x01 += dx;
		}
		y01 += dy;
	}
}

void tileSurf(gxSurf dst, int x, int y, gxSurf src, gxRect roi&) {
	gxRect clip = {
		x: 0;
		y: 0;
		w: src.width();
		h: src.height();
	};

//	if (roi != null) {
//		clip = roi;
//	}

	if (clipRect(src, clip)) {
		int dstw = dst.width();
		int dsth = dst.height();
		if (x < 0) x = -(-x % clip.w);
		//~ if (y < 0) y = y % clip.h;
		for (int j = y; j < dsth; j += clip.h) {
			for (int i = x; i < dstw; i += clip.w) {
				dst.copySurf(i, j, src, clip);
			}
		}
	}
}

void showMesh(gxMesh mesh, int w, int h, float32 fovy) {
	static gxMesh obj;
	static gxSurf ofs;

	static int onEvent(int action, int button, int ex, int ey) {
		static int ox = 0;
		static int oy = 0;
		static const float speed = 1. / 100;

		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
		}
		if (action == Gui.MOUSE_MOTION) {
			float32 dir[3];
			int dx = ex - ox;
			int dy = ey - oy;

			if (button == 1) {
				// orbit
				float32 orig[3];
				orig[0] = 0;
				orig[1] = 0;
				orig[2] = 0;

				camera.readUp(dir);
				camera.rotate(dir, orig, dx * speed);
				camera.readRight(dir);
				camera.rotate(dir, orig, dy * speed);
			}
			else if (button == 2) {
				// rotate
				camera.readUp(dir);
				camera.rotate(dir, null, -dx * speed);
				camera.readRight(dir);
				camera.rotate(dir, null, -dy * speed);
			}
			else if (button == 3) {
				// move
				camera.readForward(dir);
				camera.move(dir, dy * speed);
			}
			else if (button == 4) {
				// pan
				camera.readRight(dir);
				camera.move(dir, -dx * speed);
				camera.readUp(dir);
				camera.move(dir, dy * speed);
			}
		}

		ox = ex;
		oy = ey;
		ofs.drawMesh(obj);

		return 1;
	}

	obj = mesh;
	ofs = gxSurf.create3d(w, h);

	camera.projection(fovy, w / float32(h), 1, 100);
	Gui.showWindow(ofs, onEvent);
}
