/// A 4x4 matrix
struct mat4f: 0 {
	/// Access elements as a flatten array: data[4] => m[1][0]
	float32 data[16];

	/// Access elements as an array: m[1][0]
	float32 m[4][4];

	/// Access elements as an array of vectors: v[1].x => m[1][0]
	vec4f v[4];

	struct {
		///@public
		vec4f x;
		///@public
		vec4f y;
		///@public
		vec4f z;
		///@public
		vec4f w;
	}
	struct {
		///@public
		float32 xx;
		///@public
		float32 xy;
		///@public
		float32 xz;
		///@public
		float32 xw;

		///@public
		float32 yx;
		///@public
		float32 yy;
		///@public
		float32 yz;
		///@public
		float32 yw;

		///@public
		float32 zx;
		///@public
		float32 zy;
		///@public
		float32 zz;
		///@public
		float32 zw;

		///@public
		float32 wx;
		///@public
		float32 wy;
		///@public
		float32 wz;
		///@public
		float32 ww;
	}
}

/// Initialize all elements with the given values
mat4f mat4f(float32 xx, float32 xy, float32 xz, float32 xw,
			float32 yx, float32 yy, float32 yz, float32 yw,
			float32 zx, float32 zy, float32 zz, float32 zw,
			float32 wx, float32 wy, float32 wz, float32 ww) {
	return {
		x: { x: xx, y: xy, z: xz, w: xw };
		y: { x: yx, y: yy, z: yz, w: yw };
		z: { x: zx, y: zy, z: zz, w: zw };
		w: { x: wx, y: wy, z: wz, w: ww };
	};
}

/// Initialize matrix with row vectors
mat4f mat4f(const vec4f x&, const vec4f y&, const vec4f z&, const vec4f w&) {
	return { x: x, y: y, z: z, w: w };
}

/// Multiply with vector: dot product of the first 3 elements
inline dp3(const mat4f mat&, const vec4f vec&) = vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1f);
/// Multiply with vector: homogeneous dot product
inline dph(const mat4f mat&, const vec4f vec&) = vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
/// Multiply with vector: dot product
inline dp4(const mat4f mat&, const vec4f vec&) = vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));

/// Multiply two matrices (rows * cols)
mat4f mul(const mat4f lhs&, const mat4f rhs&) {
	mat4f transposed = {
		x: { x: rhs.x.x, y: rhs.y.x, z: rhs.z.x, w: rhs.w.x };
		y: { x: rhs.x.y, y: rhs.y.y, z: rhs.z.y, w: rhs.w.y };
		z: { x: rhs.x.z, y: rhs.y.z, z: rhs.z.z, w: rhs.w.z };
		w: { x: rhs.x.w, y: rhs.y.w, z: rhs.z.w, w: rhs.w.w };
	};
	return {
		x: dp4(transposed, lhs.x);
		y: dp4(transposed, lhs.y);
		z: dp4(transposed, lhs.z);
		w: dp4(transposed, lhs.w);
	};
}

/**
 * Build a rotation matrix
 * adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas
 */
mat4f rotation(const vec4f center&, const vec4f direction&, float angle) {
	float len = direction.length();
	if (len < 1e-9) {
		trace("invalid direction of rotation", direction);
		return {
			x: vec4f(0, 0, 0, 0);
			y: vec4f(0, 0, 0, 0);
			z: vec4f(0, 0, 0, 0);
			w: vec4f(0, 0, 0, 0);
		};
	}
	float x = direction.x / len;
	float y = direction.y / len;
	float z = direction.z / len;
	float cx = center.x;
	float cy = center.y;
	float cz = center.z;
	float xx = x * x;
	float xy = x * y;
	float xz = x * z;
	float yy = y * y;
	float yz = y * z;
	float zz = z * z;

	float s = float.sin(angle);
	float c = float.cos(angle);
	float k = 1 - c;

	return {
		xx: xx + (yy + zz) * c;
		xy: xy * k - z * s;
		xz: xz * k + y * s;
		xw: (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;

		yx: xy * k + z * s;
		yy: yy + (xx + zz) * c;
		yz: yz * k - x * s;
		yw: (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;

		zx: xz * k - y * s;
		zy: yz * k + x * s;
		zz: zz + (xx + yy) * c;
		zw: (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;

		w: vec4f(0, 0, 0, 1);
	};
}

/// Build a rotation matrix
inline rotation(const vec4f direction&, float angle) = rotation(vec4f(0), direction, angle);

/// Build a translation matrix
mat4f translation(const vec4f direction&, float amount) {
	return {
		x: {x: 1, y: 0, z: 0, w: direction.x * amount};
		y: {x: 0, y: 1, z: 0, w: direction.y * amount};
		z: {x: 0, y: 0, z: 1, w: direction.z * amount};
		w: {x: 0, y: 0, z: 0, w: 1};
	};
}

/// Build a scaling matrix
mat4f scale(const vec4f direction&, float amount) {
	inline rcp(float val) = (val < 0 ? -val : val) < 1e-30 ? 0 : 1 / val;
	return {
		x: {x: rcp(direction.x * amount), y: 0, z: 0, w: 0};
		y: {x: 0, y: rcp(direction.y * amount), z: 0, w: 0};
		z: {x: 0, y: 0, z: rcp(direction.z * amount), w: 0};
		w: {x: 0, y: 0, z: 0, w: 1};
	};
}
