// standard library extension

// TODO: move these aliases here
//inline int = int32;
//inline uint = uint32;
//inline byte = uint8;
//inline float = float32;
//inline double = float64;
//inline true = 0 == 0;
//inline false = 0 != 0;

static if (typename(raise) == function) {

/// report message at `verbose` logging level
inline verbose(char message[*], variant inspect) = raise(raise.verbose, raise.noTrace, message, inspect);
/// report message at `verbose` logging level
inline verbose(char message[*]) = raise(raise.verbose, raise.noTrace, message, null);

/// report message at `debug` logging level
inline debug(char message[*], variant inspect) = raise(raise.debug, raise.noTrace, message, inspect);
/// report message at `debug` logging level
inline debug(char message[*]) = raise(raise.debug, raise.noTrace, message, null);

/// report message with stacktrace at `debug` logging level
inline trace(char message[*], variant inspect) = raise(raise.debug, raise.defTrace, message, inspect);
/// report message with stacktrace at `debug` logging level
inline trace(char message[*]) = raise(raise.debug, raise.defTrace, message, null);

/// report message at `info` logging level
inline info(char message[*], variant inspect) = raise(raise.info, raise.noTrace, message, inspect);
/// report message at `info` logging level
inline info(char message[*]) = raise(raise.info, raise.noTrace, message, null);

/// report message at `warn` logging level
inline warn(char message[*], variant inspect) = raise(raise.warn, raise.noTrace, message, inspect);
/// report message at `warn` logging level
inline warn(char message[*]) = raise(raise.warn, raise.noTrace, message, null);

/// report message with stacktrace at `error` logging level
inline error(char message[*], variant inspect) = raise(raise.error, raise.defTrace, message, inspect);
/// report message with stacktrace at `error` logging level
inline error(char message[*]) = raise(raise.error, raise.defTrace, message, null);

/// report message with stacktrace at `abort` logging level and abort execution
inline abort(char message[*], variant inspect) = raise(raise.abort, raise.defTrace, message, inspect);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort(char message[*]) = raise(raise.abort, raise.defTrace, message, null);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort() = raise(raise.abort, raise.defTrace, "execution aborted!", null);

/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, char message[*], variant inspect) = void(condition ? void(0) : abort(message, inspect));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, char message[*]) = void(condition ? void(0) : abort(message));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition) = void(condition ? void(0) : abort("assertion failed!"));

///@public
struct NotEquals {
	/// Value of the expected result
	const variant expected;

	/// Value of the actual result
	const variant returned;

	/// Extra argument to identify what happened
	const variant argument = null;

	/// Extra message to identify what happened
	const char message[*] = null;
}

/// abort execution if the returned value is not equal to the expected value
// TODO: make inline
static void assertEq(int expected, int returned, char message[*]) {
	if (returned == expected) {
		return;
	}
	NotEquals details = {
		expected: expected;
		returned: returned;
		message: message;
	};
	raise(raise.abort, raise.defTrace, "assertion failed", details);
}
/// abort execution if the returned value is not equal to the expected value
inline assertEq(int expected, int returned) = assertEq(expected, returned, null);

}

/// Returns the size of the given type
inline sizeof(typename type) = int(type.size);

inline "std/math.ci";
inline "std/string.ci";

inline "vec/vec2d.ci"?;
inline "vec/vec4f.ci"?;
inline "vec/mat4f.ci"?;
