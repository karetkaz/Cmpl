// string related functions

int length(char str[*]) {
	if (str == null) {
		return 0;
	}
	int result = 0;
	for (; str[result]; result += 1) {
	}
	return result;
}

/// the first occurrence of a char in string
int indexOf(char str[*], char chr) {
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			return i;
		}
	}
	return -1;
}

/// the last occurrence of a char in string
int lastIndexOf(char str[*], char chr) {
	int result = -1;
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			result = i;
		}
	}
	return result;
}


bool startsWith(char str[*], char with[*], int cmp(char chr, char with)) {
	for (int i = 0; with[i] != 0; i += 1) {
		if (cmp(str[i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

bool endsWith(char str[*], char with[*], int cmp(char chr, char with)) {
	int withLen = length(with);
	int strLen = length(str);
	if (strLen < withLen) {
		return false;
	}
	for (int i = 0; i < withLen; i += 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return false;
		}
	}
	return true;
}

int compare(char str[*], char with[*], int cmp(char chr, char with)) {
	int result = 0;
	for (int i = 0; result == 0; i += 1) {
		result = cmp(str[i], with[i]);
		if (str[i] == 0) {
			break;
		}
	}
	return result;
}

// ignore case compare
int ignCaseCmp(char chr, char with) {
	static char ignCase(char chr) {
		if (chr >= 'A' && chr <= 'Z') {
			chr -= 'A';
			chr += 'a';
		}
		return chr;
	}

	return ignCase(chr) - ignCase(with);
}

int caseCmp(char chr, char with) {
	return chr - with;
}

inline startsWith(char str[*], char with[*]) = startsWith(str, with, caseCmp);
inline endsWith(char str[*], char with[*]) = endsWith(str, with, caseCmp);
inline compare(char str[*], char with[*]) = compare(str, with, caseCmp);

inline contains(char str[*], char chr) = indexOf(str, chr) >= 0;

// convert number to string
struct FormatFlags {
	const int radix;	// radix
	const char sign;	// should be one of: 0, '-', '+'
	const char padChr;	// padding character: 0, '0'
	const int padLen;	// padding length
	const int precision;	// padding length
}

int append(char output[], int pos, char value[*]) {
	for (int i = 0; value[i]; i += 1) {
		if (pos >= output.length) {
			break;
		}
		output[pos] = value[i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

int append(char output[], int pos, uint32 value, FormatFlags format&) {
	static const char whiteSpace[] = " \t\n\r";
	static const char radixDigits[] = "0123456789abcdefghijklmnopqrstuvwxyz";

	int len = 0;
	char digits[80];

	int radix = format.radix;
	assert(radix > 1 && radix < radixDigits.length);

	// print digits in reverse order
	for ( ; value > 0; value /= radix) {
		digits[len += 1] = radixDigits[value % radix];
	}
	if (len == 0) {
		digits[len += 1] = '0';
	}

	int maxLen = format.padLen - len;

	char padChr = format.padChr;
	if (padChr == '\0') {
		padChr = ' ';
	}

	// print sign value
	if (format.sign != '\0') {
		maxLen -= 1;
		if (whiteSpace.contains(padChr)) {
			// if padding character is whitespace padd before sign
			for ( ; maxLen > 0; maxLen -= 1) {
				assert(pos < output.length);
				output[pos] = padChr;
				pos += 1;
			}
		}
		assert(pos < output.length);
		output[pos] = format.sign;
		pos += 1;
	}

	// print padding
	for ( ; maxLen > 0; maxLen -= 1) {
		assert(pos < output.length);
		output[pos] = padChr;
		pos += 1;
	}

	// print digits
	for (int i = 0; i < len; i += 1) {
		assert(i < output.length);
		output[pos] = digits[len - i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

int append(char output[], int pos, uint32 value) {
	static const FormatFlags format = {
		radix: 10;
		sign: '\0';
		padChr: ' ';
		padLen: 0;
		precision: 0;
	};
	return append(output, pos, value, format);
}
