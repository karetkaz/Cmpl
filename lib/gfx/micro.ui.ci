// micro ui

struct View: object {
	const char text[*];
	bool enabled = true;
	bool selectable = true;
	const variant data = null;

	bool onClick(View this) = null; /*TODO: {
		//trace("onClick", this);
		return true;
	}*/
}

struct Button: View {
	/* FIXME: do the override, use this method as default initializer
	// TODO: override or overload: bool onClick(Button this) { ??? }
	bool onClick(View this) {
		View.onClick(this);   // call super
		trace("onClick", this);
		// FIXME: enable lookup: value.value = 0;
		return this.enabled;
	}// */
}

struct Switch: View {
	const char on[*] = "on";
	const char off[*] = "off";

	bool checked = false;
}

struct Slider: View {
	int value = 0;
	const int minimum = 0;
	const int maximum = -1u >> 1;
	const int divisor = 1;
}

struct Histogram: View {
	const gxSurf image;
	const int height = 128;
	const bool showLines = false;
	uint32 data[256] = null;   // FIXME: this should be not possible
}

struct MouseState {
	int32 clicks;   // click count
	int64 time;     // old clock
	int32 btn;      // old button
	int32 x;        // old x coord
	int32 y;        // old y coord
}

struct Layout {
	gxSurf offs;
	gxSurf font;
	int border = 3;
	int padding = 5;
	MouseState mouse;
	gxRect rect;

	int count = 0;
	View items[200] = null;
	gxRect rects[200] = null;
	int reset[200] = null;
	int selectedIndex = -1;

	int backgroundColor = 0x1a1a1a;
	int focusedColor = 0x3b4754;
	int valueColor = 0x6897bb;
	int textColor = 0xdadada;
}

int val(Slider slider&) {
	if (slider.value < slider.minimum) {
		slider.value = slider.minimum;
	}
	if (slider.value > slider.maximum) {
		slider.value = slider.maximum;
	}
	return slider.value;
}

double valFlt(Slider slider&) {
	return slider.val() / double(slider.divisor);
}

void measure(Layout layout&) {
	int bottom = layout.rect.y;
	int fontHeight = layout.font.height() / 256;

	// measure
	for (int i = 0; i < layout.count; i += 1) {
		gxRect rect& = layout.rects[i];
		rect.x = layout.rect.x;
		rect.y = bottom;
		rect.w = layout.rect.w;
		rect.h = fontHeight;
		View view = layout.items[i];
		if (Histogram item = view.as(Histogram)) {
			if (rect.h < item.height) {
				rect.h = item.height;
			}
		}
		else if (Slider item = view.as(Slider)) {
			rect.h += 2 * layout.padding;
		}
		else if (Switch item = view.as(Switch)) {
			rect.h += 2 * layout.padding;
		}
		else if (Button item = view.as(Button)) {
			rect.h += 2 * layout.padding;
		}
		else {
			abort("item is not a known ui element", view);
		}
		bottom += rect.h;
	}
	layout.rect.h = bottom - layout.rect.y;
}
void draw(Layout layout&) {
	static const FormatFlags flagsInt = { padLen: 4 };
	static const FormatFlags flagsFlt = { padLen: 4, precision: 2 };

	// draw background
	if (layout.backgroundColor != -1) {
		int b = layout.border;
		const gxRect r& = layout.rect;
		layout.offs.fillRect(r.x - b, r.y - b, r.x + r.w + b, r.y + r.h + b, layout.backgroundColor);
	}

	// draw items
	for (int i = 0; i < layout.count; i += 1) {
		int pos = 0;
		char value[256];
		View view = layout.items[i];
		gxRect rect& = layout.rects[i];
		value[0] = 0;
		if (Histogram item = view.as(Histogram)) {
			if (item.showLines) {
				offs.drawLut(rect, null, item.data);
			} else {
				offs.drawLut(rect, item.data, null);
			}
		}
		else if (Slider item = view.as(Slider)) {
			if (item.divisor != 1) {
				pos = value.append(pos, item.valFlt(), flagsFlt);
			} else {
				pos = value.append(pos, item.val(), flagsInt);
			}
		}
		else if (Switch item = view.as(Switch)) {
			if (item.checked) {
				pos = value.append(pos, item.on);
			} else {
				pos = value.append(pos, item.off);
			}
		}
		else if (Button item = view.as(Button)) {
		}
		else {
			abort("item is not a known ui element", view);
		}
		if (i == layout.selectedIndex) {
			layout.offs.fillRect(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h, layout.focusedColor);
		}

		int p = layout.padding;
		gxRect valueRect = rect;
		layout.font.clipText(valueRect, value);
		if (valueRect.w > layout.rect.w - 2 * p) {
			valueRect.w = layout.rect.w - 2 * p;
		}
		if (view.text != null) {
			gxRect textRect = rect;
			textRect.x += p;
			textRect.y += p;
			textRect.w -= valueRect.w + 3 * p;
			layout.offs.drawText(textRect, layout.font, view.text, layout.textColor);
		}

		valueRect.x += rect.w - valueRect.w - p;
		valueRect.y += p;
		layout.offs.drawText(valueRect, layout.font, value, layout.valueColor);
	}
}

Layout Layout(gxSurf offs, int x, int y, gxSurf font, View items...) {
	Layout layout = {
		offs: offs;
		font: font;
		mouse: {};
		rect: {
			x: x;
			y: y;
			w: 256;
			h: 0;
		};
	};

	for (int i = 0; i < items.length; i += 1) {
		if (Slider slider = items[i].as(Slider)) {
			layout.reset[i] = slider.value;
		}
		layout.items[i] = items[i];
	}
	layout.count = items.length;

	if (y < 0) {
		layout.measure();
		layout.rect.y = offs.height() - layout.rect.h + y;
	}
	if (x < 0) {
		layout.rect.x = offs.width() - layout.rect.w + x;
	}
	return layout;
}

inline selected(Layout layout&) = layout.selectedIndex < 0 ? null : pointer(layout.items[layout.selectedIndex]);
inline selected(Layout layout&, typename type) = layout.selectedIndex < 0 ? null : layout.items[layout.selectedIndex].as(type);
inline isSelected(Layout layout&, View item) = item == layout.selected();

bool uiEvent(Layout layout&, int action, int button, int x, int y) {
static int click(MouseState old&, int btn, int x, int y) {
	if ((btn != 0 && btn != old.btn) || x != old.x || y != old.y) {
		// reset values
		old.time = System.millis();
		old.btn = btn;
		old.clicks = 1;
		old.x = x;
		old.y = y;
		return 0;
	}
	if (btn == 0) {
		// release button
		// old.time = keep value?;
		// old.btn = keep value?;
		// old.cnt = keep value?;
		return old.clicks;
	}

	int64 now = System.millis();
	if ((now - old.time) / 1000. > .5) {
		// reset counter
		old.clicks = 0;
	}
	old.time = now;
	old.btn = btn;
	old.clicks += 1;
	return old.clicks;
}

bool click(Layout layout&, int index) {
	if (index < 0) {
		return false;
	}

	View view = layout.items[index];
	if (!view.enabled) {
		return false;
	}

	if (view.selectable) {
		if (index != layout.selectedIndex) {
			layout.selectedIndex = index;
		}
	}

	if (Slider item = view.as(Slider)) {
		if (layout.mouse.clicks == 2) {
			item.value = layout.reset[index];
		}
		if (view.onClick != null) {
			// FIXME: use: view.onClick(item)
			return item.onClick(item);
		}
		return true;
	}
	if (Switch item = view.as(Switch)) {
		if (layout.mouse.clicks == 2) {
			// change only if already selected
			item.checked = !item.checked;
		}
		if (item.onClick != null) {
			return item.onClick(item);
		}
		return true;
	}
	if (Button item = view.as(Button)) {
		if (item.onClick != null) {
			return item.onClick(item);
		}
		return true;
	}
	return false;
}
bool click(Layout layout&, int x, int y) {
	bool test(const gxRect rect&, int x, int y) {
		if (x < rect.x || x >= rect.x + rect.w) {
			return false;
		}
		if (y < rect.y || y >= rect.y + rect.h) {
			return false;
		}
		return true;
	}

	if (!layout.rect.test(x, y)) {
		return false;
	}
	for (int i = 0; i < layout.count; i += 1) {
		if (!layout.rects[i].test(x, y)) {
			continue;
		}
		return click(layout, i);
	}
	// click is outside any control
	return false;
}

bool update(Layout layout&, int delta) {
	if (layout.selectedIndex < 0) {
		return false;
	}
	View selectedItem = layout.items[layout.selectedIndex];
	if (Slider slider = selectedItem.as(Slider)) {
		slider.value += delta;
		return true;
	}
	return false;
}

bool reset(Layout layout&, int index) {
	if (index < 0) {
		for (int i = 0; i < layout.count; i += 1) {
			layout.reset(i);
		}
		return true;
	}
	if (Slider item = layout.items[index].as(Slider)) {
		item.value = layout.reset[index];
		return true;
	}
	return false;
}

bool select(Layout layout&, bool prev) {
	for (int i = 1; i < layout.count; i += 1) {
		int index = layout.selectedIndex + (prev ? -i : i);
		if (index >= layout.count) {
			index -= layout.count;
		}
		else if (index < 0) {
			index += layout.count;
		}
		View view = layout.items[index];
		if (Button item = view.as(Button)) {
			if (item.enabled && item.selectable) {
				layout.selectedIndex = index;
				return true;
			}
		}
		else if (Switch item = view.as(Switch)) {
			if (item.enabled && item.selectable) {
				layout.selectedIndex = index;
				return true;
			}
		}
		else if (Slider item = view.as(Slider)) {
			if (item.enabled && item.selectable) {
				layout.selectedIndex = index;
				return true;
			}
		}
	}
	return false;
}

	bool isCtrl = (y & Gui.KEY_MASK_CONTROL) != 0;
	bool isShift = (y & Gui.KEY_MASK_SHIFT) != 0;

	if (action == Gui.WINDOW_INIT) {
		layout.selectedIndex = -1;
		layout.select(false);
		layout.measure();
		return true;
	}

	if (action == Gui.FINGER_MOTION) {
		action = Gui.MOUSE_MOTION;
	}
	if (action == Gui.KEY_PRESS) {
		if (button == ' ') {
			if (isShift) {
				layout.reset(-1);
				return true;
			}
			layout.mouse.clicks = 2;  // FIXME: hack: simulate double clock to reset slider 
			if (layout.click(layout.selectedIndex)) {
				return true;
			}
		}
		if (button == '-' || button == '_') {	// down
			int delta = isShift ? 10 : 1;
			if (layout.update(-delta)) {
				return true;
			}
		}
		if (button == '+' || button == '=') {	// up
			int delta = isShift ? 10 : 1;
			if (layout.update(+delta)) {
				return true;
			}
		}
		if (button == '\t') {
			if (layout.select(isShift)) {
				return true;
			}
		}
	}
	else if (action == Gui.MOUSE_PRESS) {
		layout.mouse.click(button, x, y);
		if (button == 1) {
			if (layout.click(x, y)) {
				return true;
			}
		}
	}
	else if (action == Gui.MOUSE_RELEASE) {
		layout.mouse.click(0, x, y);
	}
	else if (action == Gui.MOUSE_MOTION) {
		int dy = layout.mouse.y - y;
		layout.mouse.click(-1, x, y);
		if (button == 1) {
			if (layout.update(dy)) {
				return true;
			}
		}
	}
	return false;
}
