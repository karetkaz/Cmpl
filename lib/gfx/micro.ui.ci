// micro ui, TODO: add comments

struct Style {
	const Image font;

	int backgroundColor = 0x1a1a1a;
	int focusedColor = 0x3b4754;
	int valueColor = 0x6897bb;
	int textColor = 0xdadada;

	int border = 3;
	int padding = 8;
}
struct KeyEvent {
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int repeat;
	const int key;
}
struct MouseEvent {
	const Rect clientRect&;
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int repeat;
	const int button;
	const int dx = 0;
	const int dy = 0;
	const int x;
	const int y;
}

struct View: object {
	const int height = 0;
	const int group = 0;
	bool enabled = true;
	bool selectable = true;
	const variant data = null;

	bool onMouseEvent(View this, const MouseEvent event&) = null;
	bool onClick(View this) {
		return true;
	}
}

struct Button: View {
	const char text[*];
	/* FIXME: do the override, use this method as default initializer
	// TODO: override or overload: bool onClick(Button this) { ... }
	bool onClick(Button this) {
		View.onClick(this);   // call super
		trace("onClick", this);
		return this.enabled;
	}// */
}

struct Switch: View {
	const char text[*];
	/* TODO: allow selecting one out of multiple choices
	const char choices[*][] = {
		"off",
		"on"
	};
	int selected = 0;*/

	const char on[*] = "on";
	const char off[*] = "off";

	bool checked = false;
	const bool resetValue = false;

	bool onUpdate(Switch this, bool checked) {
		this.checked = checked;
		return true;
	}
}

struct Slider: View {
	const char text[*];
	int value = 0;
	const int minimum = 0;
	const int maximum = -1u >> 1;
	const int divisor = 1;
	const int resetValue = 0;

	bool onUpdate(Slider this, int value) {
		this.value = value;
		return true;
	}
}

struct Histogram: View {
	const Image image;
	const bool lines = false;
	uint32 data[256] = null;   // FIXME: this should be not possible

	bool onUpdate(Histogram this, int idx, int value) {
		this.data[idx] = uint32(argb(idx, value, value, value));
		return true;
	}
}

struct ColorPicker: View {
	const float32 lum = 1f;
	argb value = argb(0);
	int x = 0;
	int y = 0;

	bool onUpdate(ColorPicker this, argb value) {
		this.value = value;
		return true;
	}
}

struct Layout: object {
	Style style;
	Image offs;
	Rect rect;

	bool visible = true;
	bool measure = true;
	int selectedIndex = -1;
	int activeIndex = -1;
	View views[64] = null;
	Rect rects[64] = null;
	int items = 0;
	int group = 0;
}

int val(Slider slider&) {
	if (slider.value < slider.minimum) {
		slider.value = slider.minimum;
	}
	if (slider.value > slider.maximum) {
		slider.value = slider.maximum;
	}
	return slider.value;
}

float64 valFlt(Slider slider&) {
	return slider.val() / float64(slider.divisor);
}

inline selected(const Layout layout&) = layout.selectedIndex < 0 ? null : pointer(layout.views[layout.selectedIndex]);
inline selected(const Layout layout&, typename type) = layout.selectedIndex < 0 ? null : layout.views[layout.selectedIndex].as(type);

inline activeIndex(const Layout layout&) = layout.activeIndex != -1 ? layout.activeIndex : layout.selectedIndex;

bool isSelected(const Layout layout&, View items...) {
	View selected = layout.selected();
	for (int i = 0; i < items.length; i += 1) {
		if (items[i] == selected) {
			return true;
		}
	}
	return false;
}
bool isActive(const Layout layout&, View views...) {
	int activeIndex = layout.activeIndex != -1 ? layout.activeIndex : layout.selectedIndex;
	if (activeIndex < 0) {
		return false;
	}
	View view = layout.views[activeIndex];
	for (int i = 0; i < views.length; i += 1) {
		if (views[i] == view) {
			return true;
		}
	}
	return false;

}

bool setSelected(Layout layout&, View view) {
	if (view == null) {
		layout.selectedIndex = -1;
		return true;
	}
	for (int i = 0; i < layout.items; i += 1) {
		if (layout.views[i] == view) {
			layout.selectedIndex = i;
			return true;
		}
	}
	return false;
}
bool setGroup(Layout layout&, int group) {
	if (layout.group != group) {
		layout.group = group;
		layout.measure = true;
		return true;
	}
	return false;
}

void onInit(View this, Layout layout&, int idx) {
	// FIXME: dispatch click event using inheritance and override
	if (ColorPicker item = this.as(ColorPicker)) {
		return;
	}
	if (Histogram item = this.as(Histogram)) {
		for (int i = 0; i < 256; i += 1) {
			item.data[i] = uint32(argb(i, i, i, i));
		}
		return;
	}
	if (Slider item = this.as(Slider)) {
		int resetValue& = pointer(item.resetValue);
		resetValue = item.value;
		return;
	}
	if (Switch item = this.as(Switch)) {
		bool resetValue& = pointer(item.resetValue);
		resetValue = item.checked;
		return;
	}
	if (Button item = this.as(Button)) {
		return;
	}
	abort("invalid view", this);
}
bool onClick(View this) {
	if (this.onClick == null) {
		return false;
	}
	return this.onClick(this);
}
bool onReset(View this) {
	// FIXME: dispatch click event using inheritance and override
	if (ColorPicker item = this.as(ColorPicker)) {
		return false;
	}
	if (Histogram item = this.as(Histogram)) {
		if (item.onUpdate == null) {
			return false;
		}
		bool result = false;
		for (int i = 0; i < 256; i += 1) {
			result |= item.onUpdate(i, i);
		}
		return result;
	}
	if (Slider item = this.as(Slider)) {
		if (item.onUpdate == null) {
			return false;
		}
		return item.onUpdate(item.resetValue);
	}
	if (Switch item = this.as(Switch)) {
		if (item.onUpdate == null) {
			return false;
		}
		return item.onUpdate(item.resetValue);
	}
	if (Button item = this.as(Button)) {
		return false;
	}
	abort("invalid view", this);
	return false;
}
bool onEvent(View this, const KeyEvent event&) {
	// FIXME: dispatch click event using inheritance and override

	if (!event.release) {
		return false;
	}
	if (ColorPicker item = this.as(ColorPicker)) {
		return false;
	}
	if (Histogram item = this.as(Histogram)) {
		if (event.key == ' ' || event.key == 8) {
			return item.onReset();
		}
		return false;
	}
	if (Slider item = this.as(Slider)) {
		if (event.key == '+' || event.key == '=') {
			if (item.onUpdate == null) {
				return false;
			}
			return item.onUpdate(item.value + (event.isShift ? 1 : 10));
		}
		if (event.key == '-' || event.key == '_') {
			if (item.onUpdate == null) {
				return false;
			}
			return item.onUpdate(item.value - (event.isShift ? 1 : 10));
		}
		if (event.key == ' ' || event.key == 8) {
			return item.onReset();
		}
		return false;
	}
	if (Switch item = this.as(Switch)) {
		if (event.key == ' ') {
			if (item.onUpdate != null) {
				item.onUpdate(!item.checked);
			}
			return item.onClick();
		}
		if (event.key == 8) {
			return item.onReset();
		}
		return false;
	}
	if (Button item = this.as(Button)) {
		if (event.key == ' ') {
			return item.onClick();
		}
		return false;
	}
	abort("invalid view", this);
	return false;
}
bool onEvent(View this, const MouseEvent event&) {
	// FIXME: dispatch click event using inheritance and override

	if (this.onMouseEvent != null) {
		return this.onMouseEvent(event);
	}

	if (ColorPicker item = this.as(ColorPicker)) {
		if (event.release) {
			return item.onClick();
		}
		if (item.onUpdate == null) {
			return false;
		}

		const Rect rect& = event.clientRect;
		float32 px = Math.clamp(float32(event.x - rect.x), 0f, rect.w - 1f) / rect.w;
		float32 py = Math.clamp(float32(event.y - rect.y), 0f, rect.h - 1f) / rect.h;
		item.onUpdate(hsv2rgb(px, 1 - py, item.lum));
		item.x = event.x - rect.x;
		item.y = event.y - rect.y;
		return true;
	}
	if (Histogram item = this.as(Histogram)) {
		if (event.release) {
			if (event.repeat > 1) {
				// double click to reset
				return item.onReset();
			}
			return item.onClick();
		}
		if (item.onUpdate == null) {
			return false;
		}

		const Rect rect& = event.clientRect;
		int x0 = event.x - rect.x;
		int x1 = x0 + event.dx;
		int y0 = event.y - rect.y;
		int y1 = y0 + event.dy;

		if (x0 > x1) {
			int x = x0;
			x0 = x1;
			x1 = x;
			int y = y0;
			y0 = y1;
			y1 = y;
		}
		int y = y0 << 16;
		int dy = y1 - y0;
		if (x1 != x0) {
			dy = (dy << 16) / (x1 - x0);
		}
		if (x0 < 0) {
			y -= x0 * dy;
			x0 = 0;
		}
		if (x1 > 256) {
			x1 = 256;
		}
		int h = rect.h;
		for (int x = x0; x < x1; x += 1) {
			int val = 255 * (h - (y >> 16)) / h;
			item.onUpdate(x, val);
			y += dy;
		}
		return true;
	}
	if (Slider item = this.as(Slider)) {
		if (event.release) {
			if (event.repeat > 1) {
				// double click to reset
				return item.onReset();
			}
			return item.onClick();
		}
		if (item.onUpdate == null) {
			return false;
		}

		return item.onUpdate(item.value + event.dy);
	}
	if (Switch item = this.as(Switch)) {
		if (event.release) {
			if (item.onUpdate != null) {
				item.onUpdate(!item.checked);
			}
			return item.onClick();
		}
		return false;
	}
	if (Button item = this.as(Button)) {
		if (event.release) {
			return item.onClick();
		}
		return false;
	}
	abort("invalid view", this);
	return false;
}

void onMeasure(View this, Rect rect&, const Style style&) {
	// FIXME: dispatch click event using inheritance and override
	if (ColorPicker item = this.as(ColorPicker)) {
		if (item.height == 0) {
			rect.h = 128;
		} else {
			rect.h = item.height;
		}
		return;
	}
	if (Histogram item = this.as(Histogram)) {
		if (item.height == 0) {
			rect.h = 128;
		} else {
			rect.h = item.height;
		}
		return;
	}
	if (Slider item = this.as(Slider)) {
		if (item.height == 0) {
			rect.h = style.font.height() + 2 * style.padding;
		} else {
			rect.h = item.height;
		}
		return;
	}
	if (Switch item = this.as(Switch)) {
		if (item.height == 0) {
			rect.h = style.font.height() + 2 * style.padding;
		} else {
			rect.h = item.height;
		}
		return;
	}
	if (Button item = this.as(Button)) {
		if (item.height == 0) {
			rect.h = style.font.height() + 2 * style.padding;
		}
		else if (item.text == null) {
			// TODO: remove hack: empty button used for separator
			rect.h = item.height * style.padding;
		}
		else {
			rect.h = item.height;
		}
		return;
	}
	abort("invalid view", this);
}
bool onDraw(View this, const Rect rect&, const Style style&) {
	/* FIXME: dispatch click event using inheritance and override
	if (ColorPicker item = this.as(ColorPicker)) {
		return;
	}
	if (Histogram item = this.as(Histogram)) {
		return;
	}
	if (Slider item = this.as(Slider)) {
		return;
	}
	if (Switch item = this.as(Switch)) {
		return;
	}
	if (Button item = this.as(Button)) {
		return;
	}
	abort("invalid view", this);
	*/
}

bool uiEvent(Layout layout&, int action, int button, int x, int y) {
	struct Mouse {
		int32 clicks;   // click count
		int64 time;     // old clock
		int32 btn;      // old button
		int32 x;        // old x coord
		int32 y;        // old y coord
	}
	static Mouse mouse;
	static bool isShift;
	static bool isCtrl;
	static bool isAlt;

static int click(Mouse old&, int btn, int x, int y) {
	if ((btn != 0 && btn != old.btn) || x != old.x || y != old.y) {
		// reset values
		old.clicks = 1;
		old.time = System.millis();
		old.btn = btn;
		old.x = x;
		old.y = y;
		return 0;
	}
	if (btn == 0) {
		// release button
		// old.time = keep value?;
		// old.btn = keep value?;
		// old.cnt = keep value?;
		return old.clicks;
	}

	int64 now = System.millis();
	if ((now - old.time) / 1000. > .5) {
		// reset counter
		old.clicks = 0;
	}
	old.time = now;
	old.btn = btn;
	old.clicks += 1;
	return old.clicks;
}
static int click(Layout layout&, int x, int y) {
static bool test(const Rect rect&, int x, int y) {
	if (x < rect.x || x >= rect.x + rect.w) {
		return false;
	}
	if (y < rect.y || y >= rect.y + rect.h) {
		return false;
	}
	return true;
}

	if (!layout.visible) {
		return -1;
	}
	if (!layout.rect.test(x, y)) {
		return -1;
	}
	for (int i = 0; i < layout.items; i += 1) {
		if (!layout.rects[i].test(x, y)) {
			continue;
		}

		View view = layout.views[i];
		if (!view.enabled) {
			return -1;
		}
		return i;
	}
	return -1;
}

static bool select(Layout layout&, int index) {
	assert(index >= 0, "invalid selection");
	assert(index < layout.items, "invalid selection");

	View view = layout.views[index];
	if (!view.enabled) {
		return false;
	}
	if (!view.selectable) {
		return false;
	}
	if (layout.group != view.group) {
		if (layout.group != 0) {
			if (view.group != 0) {
				return false;
			}
		}
	}
	layout.selectedIndex = index;
	return true;
}
static bool select(Layout layout&, bool prev) {
	layout.activeIndex = -1;
	int selectedIndex = layout.selectedIndex;
	for (int i = 1; i < layout.items; i += 1) {
		int index = selectedIndex + (prev ? -i : i);
		if (index >= layout.items) {
			index -= layout.items;
		}
		else if (index < 0) {
			index += layout.items;
		}
		if (layout.select(index)) {
			return true;
		}
	}
	return false;
}
static View active(const Layout layout&) {
	int idx = layout.activeIndex;
	if (idx < 0) {
		idx = layout.selectedIndex;
	}
	if (idx < 0) {
		return null;
	}
	return layout.views[idx];
}

static void measure(Layout layout&) {
	int bottom = layout.rect.y;
	for (int i = 0; i < layout.items; i += 1) {
		Rect rect& = layout.rects[i];
		View view = layout.views[i];

		rect.x = layout.rect.x;
		rect.y = bottom;
		rect.w = layout.rect.w;
		rect.h = view.height;

		view.onMeasure(&rect, layout.style);
		if (layout.group != view.group) {
			if (layout.group != 0) {
				if (view.group != 0) {
					rect.h = 0;
				}
			}
		}
		bottom += rect.h;
	}
	layout.rect.h = bottom - layout.rect.y;
}
static void draw(Layout layout&) {
	static const FormatFlags flagsInt = { padLen: 4 };
	static const FormatFlags flagsFlt = { padLen: 4, precision: 2 };

	if (!layout.visible) {
		return;
	}
	// draw background
	if (layout.style.backgroundColor != -1) {
		int b = layout.style.border;
		const Rect r& = layout.rect;
		layout.offs.fillRect(r.x - b, r.y - b, r.x + r.w + b, r.y + r.h + b, layout.style.backgroundColor);
	}

	// draw items
	for (int i = 0; i < layout.items; i += 1) {
		View view = layout.views[i];
		Rect rect& = layout.rects[i];

		if (i == layout.selectedIndex) {
			layout.offs.fillRect(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h, layout.style.focusedColor);
		}

		int pos = 0;
		char text[*] = null;
		char value[256] = {};
		value[0] = 0;
		if (ColorPicker item = view.as(ColorPicker)) {
			for (int y = 0; y < rect.h; y += 1) {
				for (int x = 0; x < rect.w; x += 1) {
					float32 px = float32(x) / rect.w;
					float32 py = float32(y) / rect.h;
					argb color = hsv2rgb(px, 1 - py, item.lum);
					layout.offs.set(x + rect.x, y + rect.y, color);
				}
			}
			int x = rect.x + Math.clamp(float32(item.x), 0f, rect.w - 1f);
			int y = rect.y + Math.clamp(float32(item.y), 0f, rect.h - 1f);
			layout.offs.drawOval(x - 4, y - 4, x + 4, y + 4, layout.style.valueColor);
			layout.offs.drawOval(x - 2, y - 2, x + 2, y + 2, layout.style.valueColor);
			layout.offs.drawOval(x - 1, y - 1, x + 1, y + 1, layout.style.valueColor);
		}
		else if (Histogram item = view.as(Histogram)) {
			if (item.lines) {
				layout.offs.drawLut(rect, null, item.data);
			} else {
				layout.offs.drawLut(rect, item.data, null);
			}
		}
		else if (Slider item = view.as(Slider)) {
			text = item.text;
			if (item.divisor != 1) {
				pos = value.append(pos, item.valFlt(), flagsFlt);
			} else {
				pos = value.append(pos, item.val(), flagsInt);
			}
		}
		else if (Switch item = view.as(Switch)) {
			text = item.text;
			if (item.checked) {
				pos = value.append(pos, item.on);
			} else {
				pos = value.append(pos, item.off);
			}
		}
		else if (Button item = view.as(Button)) {
			text = item.text;
		}
		else {
			abort("item is not a known ui element", view);
		}
		int p = layout.style.padding;
		Rect valueRect = rect;
		layout.style.font.clipText(&valueRect, value);
		if (valueRect.w > layout.rect.w - 2 * p) {
			valueRect.w = layout.rect.w - 2 * p;
		}
		if (text != null) {
			Rect textRect = rect;
			textRect.x += p;
			textRect.y += p;
			textRect.w -= valueRect.w + 3 * p;
			layout.offs.drawText(textRect, layout.style.font, text, layout.style.textColor);
		}

		valueRect.h = rect.h;
		valueRect.x += rect.w - valueRect.w - p;
		valueRect.y += p;
		layout.offs.drawText(valueRect, layout.style.font, value, layout.style.valueColor);

		if (i == layout.activeIndex) {
			layout.offs.drawRect(rect.x, rect.y, rect.x + rect.w - 1, rect.y + rect.h - 1, layout.style.valueColor);
		}
	}
}

	if (action == Gui.WINDOW_INIT) {
		layout.selectedIndex = -1;
		layout.measure = true;
		layout.select(false);
		return true;
	}
	if (action == Gui.WINDOW_DRAW) {
		if (layout.measure) {
			layout.measure = false;
			measure(layout);
		}
		layout.draw();
		return true;
	}
	if (action == Gui.WINDOW_ENTER) {
		// do not process event
		return false;
	}
	if (action == Gui.WINDOW_LEAVE) {
		// do not process event
		return false;
	}

	if (action == Gui.FINGER_PRESS) {
		// finger press results also a mouse event
		// skip the finger event
		return false;
	}
	if (action == Gui.FINGER_MOTION) {
		// translate to mouse event
		action = Gui.MOUSE_MOTION;
	}
	if (action == Gui.FINGER_RELEASE) {
		// finger release results also a mouse event
		// skip the finger event
		return false;
	}

	if (action == Gui.MOUSE_PRESS) {
		mouse.click(button, x, y);
		if (button != 1) {
			return false;
		}
		bool result = false;
		int activeIndex = layout.click(x, y);
		if (layout.activeIndex != activeIndex) {
			// active index changed, most probably from -1
			layout.activeIndex = activeIndex;
			result = true;
		}
		if (activeIndex < 0) {
			// allow update of selected control
			activeIndex = layout.selectedIndex;
			if (activeIndex < 0) {
				return result;
			}
		}
		if (View view = layout.views[activeIndex]) {
			Rect rect& = layout.rects[activeIndex];
			MouseEvent event = {
				clientRect: rect;
				release: false;
				isShift: isShift;
				isCtrl: isCtrl;
				isAlt: isAlt;
				repeat: mouse.clicks;
				button: button;
				x: x;
				y: y;
			};
			if (view.onEvent(event)) {
				return true;
			}
		}
		return result;
	}
	if (action == Gui.MOUSE_MOTION) {
		int ox = mouse.x;
		int oy = mouse.y;
		mouse.click(-1, x, y);
		if (button != 1) {
			return false;
		}
		if (ox == x && oy == y) {
			return false;
		}
		int activeIndex = layout.activeIndex;
		if (activeIndex < 0) {
			// allow update of selected control
			activeIndex = layout.selectedIndex;
			if (activeIndex < 0) {
				return;
			}
		}
		if (View view = layout.views[activeIndex]) {
			Rect rect& = layout.rects[activeIndex];
			MouseEvent event = {
				clientRect: rect;
				release: false;
				isShift: isShift;
				isCtrl: isCtrl;
				isAlt: isAlt;
				repeat: mouse.clicks;
				button: button;
				dx: ox - x;
				dy: oy - y;
				x: x;
				y: y;
			};
			if (view.onEvent(event)) {
				return true;
			}
		}
		return false;
	}
	if (action == Gui.MOUSE_RELEASE) {
		int btn = mouse.btn;
		mouse.click(0, x, y);
		if (button != 1) {
			return false;
		}

		bool result = false;
		int activeIndex = layout.activeIndex;
		if (activeIndex >= 0) {
			layout.activeIndex = -1;
			result = true;
		}
		if (activeIndex != layout.click(x, y)) {
			// release on a different view
			return result;
		}
		if (activeIndex < 0) {
			// might be a disabled view
			return result;
		}
		// select / focus the view
		if (layout.select(activeIndex)) {
			result = true;
		}
		if (View view = layout.views[activeIndex]) {
			Rect rect& = layout.rects[activeIndex];
			MouseEvent event = {
				clientRect: rect;
				release: true;
				isShift: isShift;
				isCtrl: isCtrl;
				isAlt: isAlt;
				repeat: mouse.clicks;
				button: button;
				x: x;
				y: y;
			};
			if (view.onEvent(event)) {
				result = true;
			}
		}
		return result;
	}

	if (action == Gui.KEY_PRESS) {
		isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
		isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
		isAlt = (y & Gui.KEY_MASK_ALT) != 0;
		if (View view = layout.active()) {
			KeyEvent event = {
				release: false;
				isShift: isShift;
				isCtrl: isCtrl;
				isAlt: isAlt;
				repeat: 0;
				key: button;
			};
			if (view.onEvent(event)) {
				return true;
			}
		}
		if (button == '\t' || button == '\r') {
			// Tab, Enter: select prev or next control.
			return layout.select(isShift);
		}
		if (button == '[' || button == ']') {
			// hide, show controls
			layout.visible = !layout.visible;
			return true;
		}
		if (button == 8 && isShift) {
			for (int i = 0; i < layout.items; i += 1) {
				layout.views[i].onReset();
			}
			return true;
		}
		return false;
	}
	if (action == Gui.KEY_RELEASE) {
		isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
		isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
		isAlt = (y & Gui.KEY_MASK_ALT) != 0;
		if (View view = layout.active()) {
			KeyEvent event = {
				release: true;
				isShift: isShift;
				isCtrl: isCtrl;
				isAlt: isAlt;
				repeat: 0;
				key: button;
			};
			if (view.onEvent(event)) {
				return true;
			}
		}
		return false;
	}

	debug("event not processed", action);
	return false;
}

Layout Layout(Image offs, int x, int y, Image font, View items...) {
	Layout layout = {
		offs: offs;
		rect: {
			x: x;
			y: y;
			w: 256;
			h: 0;
		};
		style: {
			font: font;
		};
	};

	for (int i = 0; i < layout.views.length; i += 1) {
		layout.views[i] = null;
	}

	for (int i = 0; i < items.length; i += 1) {
		assert(i < layout.views.length);
		layout.views[i] = items[i];
		items[i].onInit(&layout, i);
	}
	layout.items = items.length;

	if (y < 0) {
		layout.uiEvent(Gui.WINDOW_INIT, 0, 0, 0);
		layout.rect.y = offs.height() - layout.rect.h + y;
	}
	if (x < 0) {
		layout.rect.x = offs.width() - layout.rect.w + x;
	}
	return layout;
}

inline draw(Layout layout&) = uiEvent(layout, Gui.WINDOW_DRAW, 0, 0, 0);
