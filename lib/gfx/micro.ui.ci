// micro ui

struct Button {
	const char text[*];
	bool enabled = true;
	bool selectable = false;

	const variant data = null;
	bool onClick(Button item&) = null;
}

struct Checker {
	const char text[*];
	const char on[*] = "on";
	const char off[*] = "off";
	bool enabled = true;
	bool selectable = false;

	bool checked = false;
	const variant data = null;
	bool onClick(Checker item&) = null;
}

struct Slider {
	const char text[*];
	bool enabled = true;
	bool selectable = true;

	const int divValue = 1;
	const int minValue = 0;
	const int maxValue = -1u >> 1;

	int value = 0;
	const variant data = null;
	bool onClick(Slider item&) = null;
}

struct Layout {
	gxSurf offs;
	gxSurf font;
	variant items[200] = {};
	gxRect rects[200] = {};
	int reset[200] = {};
	int selectedIndex = -1;
	int count = 0;
}

int val(Slider slider&) {
	if (slider.value < slider.minValue) {
		slider.value = slider.minValue;
	}
	if (slider.value > slider.maxValue) {
		slider.value = slider.maxValue;
	}
	return slider.value;
}

double valFlt(Slider slider&) {
	return slider.val() / double(slider.divValue);
}

Layout Layout(gxSurf offs, gxSurf font, variant items...) {
	Layout layout;/* FIXME:BUG: = {
		selectedIndex: -1;
		// rect: {x: 0, y: 0, w: 0, h: 0};
	};*/
	layout.offs = offs;
	layout.font = font;
	layout.selectedIndex = -1;
	for (int i = 0; i < items.length; i += 1) {
		if (Slider slider& = items[i].as(Slider)) {
			layout.reset[i] = slider.value;
		}
		layout.items[i] = items[i];
	}
	layout.count = items.length;
	return layout;
}

void draw(Layout layout&, int x, int y) {
	int posAll = 0;
	char textAll[1024];
	FormatFlags flagsInt = { padLen: 4 };
	FormatFlags flagsFlt = { padLen: 4, precision: 2 };
	gxRect rectAll = { x:x, y:y, w:0, h:0 };

	for (int i = 0; i < layout.count; i += 1) {
		int pos = 0;
		char text[256];
		gxRect rect& = layout.rects[i];
		if (i == layout.selectedIndex) {
			pos = text.append(pos, "* ");
		} else {
			pos = text.append(pos, " ");
		}
		if (Slider item& = layout.items[i].as(Slider)) {
			pos = text.append(pos, item.text);
			pos = text.append(pos, ": ");
			if (item.divValue != 1) {
				pos = append(text, pos, item.valFlt(), flagsFlt);
			} else {
				pos = text.append(pos, item.val(), flagsInt);
			}
		}
		else if (Checker item& = layout.items[i].as(Checker)) {
			pos = text.append(pos, item.text);
			pos = text.append(pos, ": ");
			if (item.checked) {
				pos = text.append(pos, item.on);
			} else {
				pos = text.append(pos, item.off);
			}
		}
		else if (Button item& = layout.items[i].as(Button)) {
			pos = text.append(pos, item.text);
		}
		else {
			abort("item is not a known ui element", layout.items[i]);
		}
		posAll = textAll.append(posAll, text);
		posAll = textAll.append(posAll, "\n");
		layout.font.clipText(rect, text);
		rect.x = x;
		rect.y = y;
		y += rect.h;
	}
	layout.font.clipText(rectAll, textAll);
	layout.offs.fill(rectAll, 5, 0x000000);
	layout.offs.drawText(rectAll.x, rectAll.y, layout.font, textAll, 0xffffff);
}

inline selected(Layout layout&) = layout.selectedIndex < 0 ? null : pointer(layout.items[layout.selectedIndex]);
inline selected(Layout layout&, typename type) = layout.selectedIndex < 0 ? null : layout.items[layout.selectedIndex].as(type);
inline isSelected(Layout layout&, pointer item) = item == layout.selected();

bool uiEvent(Layout layout&, int action, int button, int x, int y) {
// TODO: void measure(Layout layout&) { }
// TODO: void layout(Layout layout&) { }

bool click(Layout layout&, int index) {
	if (index < 0) {
		return false;
	}
	if (Slider item& = layout.items[index].as(Slider)) {
		if (!item.enabled) {
			return false;
		}
		if (item.selectable) {
			layout.selectedIndex = index;
		}
		if (item.onClick != null) {
			return item.onClick(item);
		}
		return true;
	}
	if (Checker item& = layout.items[index].as(Checker)) {
		if (!item.enabled) {
			return false;
		}
		int previousIndex = index;
		if (item.selectable) {
			previousIndex = layout.selectedIndex;
			layout.selectedIndex = index;
		}
		if (previousIndex == index) {
			// change only if already selected
			item.checked = !item.checked;
		}
		if (item.onClick != null) {
			return item.onClick(item);
		}
		return true;
	}
	if (Button item& = layout.items[index].as(Button)) {
		if (!item.enabled) {
			return false;
		}
		if (item.selectable) {
			layout.selectedIndex = index;
		}
		if (item.onClick != null) {
			return item.onClick(item);
		}
		return true;
	}

	abort("item is not a known ui element", layout.items[index]);
	return false;
}
bool click(Layout layout&, int x, int y) {
	bool test(const gxRect rect&, int x, int y) {
		if (x < rect.x || x >= rect.x + rect.w) {
			return false;
		}
		if (y < rect.y || y >= rect.y + rect.h) {
			return false;
		}
		return true;
	}

	for (int i = 0; i < layout.count; i += 1) {
		if (!layout.rects[i].test(x, y)) {
			continue;
		}
		return click(layout, i);
	}
	// click is outside any control
	return false;
}

bool update(Layout layout&, int delta) {
	if (layout.selectedIndex < 0) {
		return false;
	}
	variant selectedItem = layout.items[layout.selectedIndex];
	if (Slider slider& = selectedItem.as(Slider)) {
		slider.value += delta;
		return true;
	}
	if (Checker checker& = selectedItem.as(Checker)) {
		checker.checked = delta < 0;
		return true;
	}
	return false;
}

bool reset(Layout layout&, int index) {
	if (index < 0) {
		for (int i = 0; i < layout.count; i += 1) {
			layout.reset(i);
		}
		return true;
	}
	if (Slider item& = layout.items[index].as(Slider)) {
		item.value = layout.reset[index];
		return true;
	}
	return false;
}

bool select(Layout layout&, bool prev) {
	for (int i = 1; i < layout.count; i += 1) {
		int index = layout.selectedIndex + (prev ? -i : i);
		if (index >= layout.count) {
			index -= layout.count;
		}
		else if (index < 0) {
			index += layout.count;
		}
		if (Button item& = layout.items[index].as(Button)) {
			if (item.enabled && item.selectable) {
				layout.selectedIndex = index;
				return true;
			}
		}
		else if (Checker item& = layout.items[index].as(Checker)) {
			if (item.enabled && item.selectable) {
				layout.selectedIndex = index;
				return true;
			}
		}
		else if (Slider item& = layout.items[index].as(Slider)) {
			if (item.enabled && item.selectable) {
				layout.selectedIndex = index;
				return true;
			}
		}
	}
	return false;
}

	static int ox = 0;
	static int px = 0;
	static int oy = 0;
	static int py = 0;

	bool isCtrl = (y & Gui.KEY_MASK_CONTROL) != 0;
	bool isShift = (y & Gui.KEY_MASK_SHIFT) != 0;

	if (action == Gui.FINGER_MOTION) {
		action = Gui.MOUSE_MOTION;
	}
	
	if (action == Gui.WINDOW_INIT) {
		layout.selectedIndex = -1;
		layout.select(false);
		return true;
	}
	else if (action == Gui.KEY_PRESS) {
		if (button == 8) {	// backspace
			if (layout.reset(isShift ? -1 : layout.selectedIndex)) {
				return true;
			}
		}
		if (button == ' ') {
			if (layout.click(layout.selectedIndex)) {
				return true;
			}
		}
		if (button == '-' || button == '_') {	// down
			int delta = isShift ? 10 : 1;
			if (layout.update(-delta)) {
				return true;
			}
		}
		if (button == '+' || button == '=') {	// up
			int delta = isShift ? 10 : 1;
			if (layout.update(+delta)) {
				return true;
			}
		}
		if (button == '\t') {
			if (layout.select(isShift)) {
				return true;
			}
		}
	}
	else if (action == Gui.MOUSE_PRESS) {
		px = ox = x;
		py = oy = y;
	}
	else if (action == Gui.MOUSE_RELEASE) {
		if (button == 1 && x == px && y == py) {
			if (layout.click(x, y)) {
				return true;
			}
		}
	}
	else if (action == Gui.MOUSE_MOTION) {
		if (button == 1) {
			if (layout.update(oy - y)) {
				ox = x;
				oy = y;
				return true;
			}
		}
	}
	return false;
}
