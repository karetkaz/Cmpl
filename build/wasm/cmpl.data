/// extension method to read a single byte from a file
int read(File file) {
	uint8 buff[1] = {...};
	if (file.read(buff) <= 0) {
		return -1;
	}
	return buff[0] & 0xff;
}

/// extension method to read a line from a file, or fill the buffer, no zero termination
int readLineRaw(File file, char buff&[]) {
	assert(buff.length > 0);

	for (int pos = 0; pos < buff.length; pos += 1) {
		int chr = file.read();
		if (chr < 0) {
			// end of file
			if (pos == 0) {
				// nothing to read
				return chr;
			}

			return pos;
		}

		if (chr == '\n' || chr == '\r') {
			// end of line
			if (chr == '\r' && file.peek() == '\n') {
				// windows line endings
				chr = file.read();
			}

			return pos;
		}

		buff[pos] = chr;
	}

	return buff.length;
}

/// extension method to read a line from a file, or fill the buffer
bool readLine(File file, char buff&[]) {
	int len = readLineRaw(file, buff[... (buff.length - 1)]);
	if (len < 0) {
		return false;
	}
	if (len == buff.length - 1) {
		debug("line too long");
	}
	// zero terminate
	buff[len] = 0;
	return true;
}


/// extension method to write a single byte into a file
int write(File file, int value) {
	uint8 buff[1] = {value};
	return file.write(buff);
}

static if (struct(Closeable) == object) {
inline "./lib/FileStream.cmpl";
}
///@public
struct FileReader: ByteReader {
	File file;

	int read(FileReader this, uint8 bytes[]) {
		return File.read(this.file, bytes);
	}

	void close(FileReader this) {
		File.close(this.file);
	}
}

///@public
struct FileWriter: ByteWriter {
	///@public
	File file;

	void write(FileWriter this, uint8 bytes[]) {
		int wrote = File.write(this.file, bytes);
		assert(wrote == bytes.length);
	}

	void flush(FileWriter this) {
		File.flush(this.file);
	}

	void close(FileWriter this) {
		File.close(this.file);
	}
}

///@public
struct BufferedFileWriter: FileWriter {
	uint8 buffer[1024];
	int bufferSize = 0;

	static void flushBuffer(BufferedFileWriter this) {
		int wrote = File.write(this.file, this.buffer[... this.bufferSize]);
		assert(wrote == this.bufferSize);
		this.bufferSize = 0;
	}

	void write(BufferedFileWriter this, uint8 bytes[]) {
		if (this.bufferSize + bytes.length > this.buffer.length) {
			if (this.bufferSize > 0) {
				this.flushBuffer();
			}
			if (bytes.length > this.buffer.length / 2) {
				// writing more than buffer half size, make the write
				FileWriter.write(this, bytes);
				return;
			}
		}
		// accumulate into buffer
		pointer buffer = this.buffer.inc(this.bufferSize);
		pointer.copy(buffer, bytes, bytes.length);
		this.bufferSize += bytes.length;
	}

	void flush(BufferedFileWriter this) {
		this.flushBuffer();
		FileWriter.flush(this);
	}

	void close(BufferedFileWriter this) {
		this.flushBuffer();
		FileWriter.close(this);
	}
}

///@public
FileReader FileReader(char path[]) {
	return {
		file: File.open(path);
	};
}

///@public
FileWriter FileWriter(char path[], bool append) {
	return {
		file: append ? File.append(path) : File.create(path);
	};
}

///@public
BufferedFileWriter BufferedFileWriter(char path[], bool append) {
	return {
		buffer: null;
		file: append ? File.append(path) : File.create(path);
	};
}
// graphics library extension

inline "./lib/rect.cmpl";
inline "./lib/color.cmpl";
inline "./lib/image.cmpl";
inline "./lib/draw.cmpl";

inline "./lib/fx/image.blend.cmpl";
inline "./lib/fx/image.transform.cmpl";
inline "./lib/fx/image.blur.cmpl";
inline "./lib/fx/color.lookup.cmpl";
inline "./lib/fx/color.matrix.cmpl";

inline "./lib/3d/mesh.cmpl";
inline "./lib/3d/camera.cmpl";

inline "./lib/ui/window.cmpl";
inline "./lib/ui/micro.ui.cmpl";
/// Simple camera for 3d transformations and projection.
struct Camera {
	///@public
	vec4f position = vec4f(0, 0, 0, 1);
	///@public
	vec4f forward = vec4f(0, 0, 0, 1);
	///@public
	vec4f right = vec4f(0, 0, 0, 1);
	///@public
	vec4f up = vec4f(0, 1, 0, 1);

	/// Create an orthographic(`fov` == 0) or perspective projection matrix
	static mat4f projection(float32 fov, float32 asp, float32 n, float32 f) {
		float32 nf = n - f;
		/* step by step matrix construction:
		float32 y = 2 / Float32.tan(Float32.radians(fov));
		float32 x = y * asp;

		float32 l = -1; // left
		float32 r = +1; // right
		float32 t = +1; // top
		float32 b = -1; // bottom

		mat4f scale = mat4f(
			x/(r-l),	0.,			0.,			0.,
			0.,			y/(t-b),	0.,			0.,
			0.,			0.,			2/(n-f),	0.,
			0.,			0.,			0.,			1.);

		mat4f translate = mat4f(
			1.,			0.,			0.,			-(l+r)/2,
			0.,			1.,			0.,			-(t+b)/2,
			0.,			0.,			1.,			-(n+f)/2,
			0.,			0.,			0.,			1.);

		if (fov == 0) {
			// orthographic
			return scale.mul(translate);
		}

		mat4f perspective = mat4f(
			n,			0.,			0.,			0,
			0.,			n,			0.,			0,
			0.,			0.,			n+f,		-n*f,
			0.,			0.,			1.,			0.);

		return scale.mul(translate).mul(perspective);
		// */

		if (fov == 0) {
			// orthographic
			return {
				x: vec4f(1 / asp, 0,       0,      0);
				y: vec4f(0,       1,       0,      0);
				z: vec4f(0,       0,       2 / nf, -(f+n) / nf);
				w: vec4f(0,       0,       0,      1);
			};
		}

		// perspective
		float32 yy = Float32.tan(Float32.radians(fov));
		float32 xx = asp * yy;

		return {
			x: vec4f(n / xx,  0,       0,          0);
			y: vec4f(0,       n / yy,  0,          0);
			z: vec4f(0,       0,       (n+f) / nf, -2 * n * f / nf);
			w: vec4f(0,       0,       1,          0);
		};
	}

	/// Create a camera at the given `position` looking at the given `target`
	static Camera lookAt(vec4f position, vec4f target, vec4f up) {
		vec4f forward = normalize(target - position);
		vec4f right = normalize(cross(up, forward));
		return {
			position: position;
			forward: forward;
			right: right;
			up: cross(forward, right);
		};
	}

	/// get the matrix of the camera, which can be multiplied with the projection matrix
	static mat4f matrix(Camera camera!) {
		return {
			x: vec4f(camera.right, -camera.right.dp3(camera.position));
			y: vec4f(camera.up, -camera.up.dp3(camera.position));
			z: vec4f(camera.forward, -camera.forward.dp3(camera.position));
			w: vec4f(0, 0, 0, 1);
		};
	}

	/// get the matrix of the camera multiplied with the projection matrix
	static mat4f matrix(Camera camera!, float32 fov, float32 asp, float32 n, float32 f) {
		return projection(fov, asp, n, f).mul(camera.matrix());
	}

	/// Move the camera in the given `direction` with the given `amount`
	static void move(Camera camera&, vec4f direction, float32 amount) {
		camera.position += direction * amount;
	}

	/// Rotate the camera around `orbit` in the given `direction` with the given `amount`
	static void rotate(Camera camera&, vec4f orbit, vec4f direction, float32 amount) {
		if (amount == 0) {
			return;
		}

		// rotate the camera
		mat4f matrix = rotation(orbit, direction, amount);
		camera.forward = normalize(matrix.dp3(camera.forward));
		camera.right = normalize(matrix.dp3(camera.right));
		camera.up = cross(camera.forward, camera.right);
		camera.position = matrix.dph(camera.position);
	}
}
/// Create a mesh by opening a file
Mesh Mesh(char fileName[]) {
	if (fileName.endsWith(".obj", ignCaseCmp)) {
		return Mesh.openObj(fileName);
	}
	if (fileName.endsWith(".3ds", ignCaseCmp)) {
		return Mesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
	return Mesh.create(0);
}
/// an 32 bit argb color
struct argb: 0 {
	/// value of color
	uint32 v;
	struct: 1 {
		/// blue component
		uint8 b;

		/// green component
		uint8 g;

		/// red component
		uint8 r;

		/// alpha component
		uint8 a;
	}
}

/// cast unsigned integer to argb value
inline argb(uint32 argb) = inline(argb);
/// cast argb value to unsigned integer
inline uint32(argb value) = inline(value);


/// clamp signed gray or color component to fit in 8 bits (0 ... 255)
inline sat_s8(int32 c) = uint32(c > 255 ? 255 : c < 0 ? 0 : c);
/// clamp unsigned gray or color component to fit in 8 bits (0 ... 255)
inline sat_u8(uint32 c) = uint32(c > 255 ? 255 : c);

/// pack an argb color from the given component
inline pack(uint32 c) = argb((((c << 8) | c) << 8) | c);
/// pack an argb color from the given components
inline pack(uint32 r, uint32 g, uint32 b) = argb((((r << 8) | g) << 8) | b);
/// pack an argb color from the given components
inline pack(uint32 a, uint32 r, uint32 g, uint32 b) = argb((((((a << 8) | r) << 8) | g) << 8) | b);

/// construct a rgb8 color from the given gray value, clamp the input
inline gray(int32 c) = pack(sat_s8(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(uint32 c) = pack(sat_s8(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float32 c) = gray(int32(c * 255));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float64 c) = gray(int32(c * 255));


/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 r, int32 g, int32 b) = pack(sat_s8(r), sat_s8(g), sat_s8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 r, uint32 g, uint32 b) = pack(sat_u8(r), sat_u8(g), sat_u8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 r, float32 g, float32 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 r, float64 g, float64 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 a, int32 r, int32 g, int32 b) = pack(sat_s8(a), sat_s8(r), sat_s8(g), sat_s8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 a, uint32 r, uint32 g, uint32 b) = pack(sat_u8(a), sat_u8(r), sat_u8(g), sat_u8(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 a, float32 r, float32 g, float32 b) = argb(int32(a * 255), int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 a, float64 r, float64 g, float64 b) = argb(int32(a * 255), int32(r * 255), int32(g * 255), int32(b * 255));


/// get the Alpha channel of the color
inline ach(argb color) = int32((uint32(color) >> 24));
/// get the Red channel of the color
inline rch(argb color) = int32(uint32(color) >> 16 & 0xff);
/// get the Green channel of the color
inline gch(argb color) = int32(uint32(color) >> 8 & 0xff);
/// get the Blue channel of the color
inline bch(argb color) = int32(uint32(color) & 0xff);

/// get the luminosity of the color (0.299 * color.r + 0.587 * color.g + 0.114 * color.b)
inline lum(argb color) = int32((19595 * rch(color) + 38470 * gch(color) + 7471 * bch(color)) >> 16);

/// get the hue of the color
// adapted from: https://gist.github.com/mity/6034000
uint32 hue(argb rgb) {
	int32 r = rch(rgb);
	int32 g = gch(rgb);
	int32 b = bch(rgb);
	int32 min = r;
	int32 max = r;

	if (min > g) {
		min = g;
	}
	if (min > b) {
		min = b;
	}
	if (max < g) {
		max = g;
	}
	if (max < b) {
		max = b;
	}

	if (max == min) {
		return 0;
	}

	int32 hue = 0;
	if (max == r) {
		hue = ((g - b) * 60) / (max - min);
	}
	else if (max == g) {
		hue = ((b - r) * 60) / (max - min) + 120;
	}
	else if (max == b) {
		hue = ((r - g) * 60) / (max - min) + 240;
	}
	if (hue < 0) {
		hue += 360;
	}
	return hue;
}

/// compute the linear interpolation of the values `a` and `b` by `t` in range 0...255
inline mix_s8(int32 t, int32 a, int32 b) = int32(a + (t * (b - a + 1) >> 8));
/// compute the linear interpolation of the values `a` and `b` by `t` in range 0...65535
inline mix_s16(int32 t, int32 a, int32 b) = int32(a + (t * (b - a + 1) >> 16));
/// compute the linear interpolation of the colors `a` and `b` by `t` in range 0...255
inline mix_rgb8(int32 t, argb a, argb b) = argb(mix_s8(t, rch(a), rch(b)), mix_s8(t, gch(a), gch(b)), mix_s8(t, bch(a), bch(b)));

/// linear interpolate a lookup-table with the given colors
void lerpLut(argb lut&[], argb colors...) {
	int32 dt = (colors.length - 1 << 16) / (lut.length - 1);
	for (int i = 0; i < lut.length; i += 1) {
		int32 t = i * dt;
		argb c1 = colors[t >> 16];
		argb c2 = colors[(t >> 16) + 1];
		int32 a = mix_s16(t & 0xffff, ach(c1), ach(c2));
		int32 r = mix_s16(t & 0xffff, rch(c1), rch(c2));
		int32 g = mix_s16(t & 0xffff, gch(c1), gch(c2));
		int32 b = mix_s16(t & 0xffff, bch(c1), bch(c2));
		lut[i].v = a << 24 | r << 16 | g << 8 | b;
	}
}

/// linear interpolate a alpha lookup-table with the given colors
void alphaLut(int32 lut&[], int32 hardness, int32 alpha, bool reflect) {
	int32 mid = hardness <= 0 ? -1 : 255;
	int32 div = 256 - sat_u8(hardness < 0 ? -hardness : hardness);
	for (int i = 0; i < lut.length; i += 1) {
		int32 t = i * 255 / (lut.length - 1);
		lut[i] = sat_s8((t - mid) * 255 / div + mid);
		if (alpha < 0) {
			lut[i] = 255 - (255 - lut[i]) * -alpha / 255;
		} else {
			lut[i] = 255 - lut[i] * alpha / 255;
		}
	}
	if (reflect) {
		int32 end = lut.length - 1;
		int32 mid = lut.length / 2;
		for (int i = end; i >= mid; i -= 1) {
			lut[i] = lut[end];
			end -= 2;
		}
		for (int i = 0; i < mid; i += 1) {
			lut[i] = lut[lut.length - i - 1];
		}
	}
}

static if (struct(vec4f) != null) {

/// convert an argb color to a floating point vector
inline vec4f(argb rgb) = vec4f(rch(rgb) / 255f, gch(rgb) / 255f, bch(rgb) / 255f, ach(rgb) / 255f);

/// convert a floating point vector to an argb color
inline argb(vec4f vec!) = argb(vec.w, vec.x, vec.y, vec.z);

/// calculate the luminosity of a color
inline lum(vec4f vec!) = 0.299f * vec.x + 0.587f * vec.y + 0.114f * vec.z;

inline "./color/color.hsl.cmpl";
}
/// Convert color from Rgb color space to Hsl color space
// adapted from: https://gitlab.bestminr.com/bestminr/FrontShaders/-/blob/master/shaders/hsl.glsl
vec4f rgb2hsl(vec4f rgb) {
	inline min(float32 x, float32 y) = x < y ? x : y;
	inline max(float32 x, float32 y) = x > y ? x : y;
	inline clamp(float32 value, float32 min, float32 max) = min(max(value, min), max);
	float32 fmin = min(min(rgb.x, rgb.y), rgb.z);    //Min. value of RGB
	float32 fmax = max(max(rgb.x, rgb.y), rgb.z);    //Max. value of RGB
	float32 delta = fmax - fmin;             //Delta RGB value

	// Luminance
	float32 lum = (fmax + fmin) / 2;

	if (delta == 0) {
		//This is a gray, no chroma...
		return {
			x: 0;   // Hue
			y: 0;   // Saturation
			z: lum; // Luminance
		};
	}

	// Chromatic data...
	float32 sat;
	if (lum < 0.5f) {
		sat = delta / (fmax + fmin);
	} else {
		sat = delta / (2 - fmax - fmin);
	}

	float32 deltaR = (((fmax - rgb.x) / 6) + (delta / 2)) / delta;
	float32 deltaG = (((fmax - rgb.y) / 6) + (delta / 2)) / delta;
	float32 deltaB = (((fmax - rgb.z) / 6) + (delta / 2)) / delta;

	float32 hue;
	if (rgb.x == fmax) {
		hue = deltaB - deltaG;
	}
	else if (rgb.y == fmax) {
		hue = (1 / 3f) + deltaR - deltaB;
	}
	else if (rgb.z == fmax) {
		hue = (2 / 3f) + deltaG - deltaR;
	}

	if (hue < 0) {
		hue += 1;
	}
	else if (hue > 1) {
		hue -= 1;
	}

	return {
		x: clamp(hue, 0, 1); // Hue
		y: clamp(sat, 0, 1); // Saturation
		z: clamp(lum, 0, 1); // Luminance
	};
}

/// Convert color from Hsl color space to Rgb color space
vec4f hsl2rgb(vec4f hsl) {
float32 hue2rgb(float32 f1, float32 f2, float32 hue) {
	if (hue < 0) {
		hue += 1;
	}
	else if (hue > 1) {
		hue -= 1;
	}

	if (hue < 1f / 6) {
		return f1 + (f2 - f1) * 6 * hue;
	}
	if (hue < 1f / 2) {
		return f2;
	}
	if (hue < 2f / 3) {
		return f1 + (f2 - f1) * ((2 / 3f) - hue) * 6;
	}
	return f1;
}

	if (hsl.y == 0) {
		return vec4f(hsl.z); // Luminance
	}

	float32 f2;
	if (hsl.z < .5f) {
		f2 = hsl.z * (1 + hsl.y);
	}
	else {
		f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);
	}

	float32 f1 = 2 * hsl.z - f2;
	return {
		x: hue2rgb(f1, f2, hsl.x + (1 / 3f));
		y: hue2rgb(f1, f2, hsl.x);
		z: hue2rgb(f1, f2, hsl.x - (1 / 3f));
	};
}
/// convert from hsv color space to rgb color space
vec4f hsv2rgb(vec4f hsv) {
	float32 h = hsv.x;
	float32 s = hsv.y;
	float32 v = hsv.z;

	if (s == 0) {
		return vec4f(v);
	}

	h *= 360 / 60;

	int i = int(h);		// round
	float32 f = h - i;	// fraction

	float32 u = v;
	float32 p = v * (1 - s);
	float32 q = v * (1 - s * f);
	float32 t = v * (1 - s * (1 - f));

	if (i == 0) {
		return vec4f(u, t, p);
	}
	if (i == 1) {
		return vec4f(q, u, p);
	}
	if (i == 2) {
		return vec4f(p, u, t);
	}
	if (i == 3) {
		return vec4f(p, q, u);
	}
	if (i == 4) {
		return vec4f(t, p, u);
	}
	return vec4f(u, p, q);
}
static if (struct(drawAntiAliased) == null) {
	// by default draw without antialiasing
	inline drawAntiAliased = true;
}
inline "./draw/draw.rect.cmpl";
inline "./draw/draw.rrect.cmpl";
inline "./draw/draw.line.cmpl";

// todo: https://rreusser.github.io/regl-gpu-lines/docs/debug.html
// void fillTriangle(Image image, int x0, int y0, int x1, int y1, int x2, int y2, uint32 color, uint32 flags);

/// Fill the entire image with the given color
Image fill(Image image, uint32 color) {
	image.fillRect(0, 0, image.width(), image.height(), color);
	return image;
}

/// Fill an ellipse on the `image` specified by the given coordinates and the given `color`
inline fillOval(Image image, int32 x0, int32 y0, int32 x1, int32 y1, uint32 color) = image.fillRRect(x0, y0, x1, y1, Int32.abs(x0 - x1), Int32.abs(y0 - y1), color);

/// Draw an ellipse on the `image` specified by the given coordinates and the given `color`
inline drawOval(Image image, int32 x0, int32 y0, int32 x1, int32 y1, uint32 color) = image.drawRRect(x0, y0, x1, y1, Int32.abs(x0 - x1), Int32.abs(y0 - y1), color);

/// Fill an ellipse on the `image` specified by `roi` with the given `color`
void fillOval(Image image, Rect roi!, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.fillOval(roi.x0, roi.y0, roi.x1, roi.y1, color);
}

/// Draw an ellipse on the `image` specified by `roi` with the given `color`
void drawOval(Image image, Rect roi!, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.drawOval(roi.x0, roi.y0, roi.x1, roi.y1, color);
}

/// Draw the given ASCII `text` to the `image` at the given `x`, `y` coordinate, with the given `font` and `color`
void drawText(Image image, int32 x, int32 y, Image font, char text[], int32 color) {
	Rect rect = {x0: x, y0: y, x1: image.width(), y1: image.height()};
	return image.drawText(rect, font, text, color);
}
/// Draw a line, including ending pixel
void drawLineIncl(Image image, int32 x0, int32 y0, int32 x1, int32 y1, uint32 color) {
	inline mix(Image image, int32 x0, int32 y0, int32 alpha, uint32 color) = image.set(x0, y0, mix_rgb8(alpha, argb(uint32(image.get(x0, y0))), argb(color)));

	if (x0 == x1 || y0 == y1) {
		// horizontal or vertical line && avoid division by zero
		return image.fillRect(x0, y0, x1, y1, 1, color);
	}

	int32 dx = x1 - x0;
	int32 dy = y1 - y0;

	if (Int32.abs(dx) > Int32.abs(dy)) {
		if (x0 > x1) {
			int32 x = x0;
			x0 = x1;
			x1 = x;
			y0 = y1;
		}
		int32 y = y0 << 16;
		dy = (dy << 16) / dx;
		if (x1 > image.width()) {
			x1 = image.width();
		}
		if (x0 < 0) {
			y -= dy * x0;
			x0 = 0;
		}

		static if (drawAntiAliased) {
			for (int32 x = x0; x <= x1; x += 1) {
				int32 alpha = (~y >> 8) & 255;
				image.mix(x, y >> 16, alpha, color);
				image.mix(x, (y >> 16) + 1, 255 - alpha, color);
				y += dy;
			}
		} else {
			y += 0x8000;
			for (int32 x = x0; x <= x1; x += 1) {
				image.set(x, y >> 16, color);
				y += dy;
			}
		}
	} else {
		if (y0 > y1) {
			int32 y = y0;
			y0 = y1;
			y1 = y;
			x0 = x1;
		}
		int32 x = x0 << 16;
		dx = (dx << 16) / dy;
		if (y1 > image.height()) {
			y1 = image.height();
		}
		if (y0 < 0) {
			x -= dx * y0;
			y0 = 0;
		}

		static if (drawAntiAliased) {
			for (int32 y = y0; y <= y1; y += 1) {
				int32 alpha = (~x >> 8) & 255;
				image.mix(x >> 16, y, alpha, color);
				image.mix((x >> 16) + 1, y, 255 - alpha, color);
				x += dx;
			}
		} else {
			x += 0x8000;
			for (int32 y = y0; y <= y1; y += 1) {
				image.set(x >> 16, y, color);
				x += dx;
			}
		}
	}
}

/// Draw a line between the given coordinates(excluding the rightmost bottom pixel)
void drawLine(Image image, int32 x0, int32 y0, int32 x1, int32 y1, uint32 color) {
	inline p(int32 a, int32 b) = a - int32(b < a);
	return drawLineIncl(image, p(x0 , x1), p(y0, y1), p(x1, x0), p(y1, y0), color);
}

/// Draw a quadratic bezier curve
void drawBezier(Image image, int32 x0, int32 y0, int32 x1, int32 y1, int32 x2, int32 y2, uint32 color) {
	int32 px_0 = x0;
	int32 py_0 = y0;
	int32 px_1 = 2 * (x1 - x0);
	int32 py_1 = 2 * (y1 - y0);
	int32 px_2 = x2 - 2 * x1 + x0;
	int32 py_2 = y2 - 2 * y1 + y0;

	float64 dt = 1. / 128;
	for (float64 t = dt; t < 1; t += dt) {
		x1 = (px_2 * t + px_1) * t + px_0;
		y1 = (py_2 * t + py_1) * t + py_0;
		drawLineIncl(image, x0, y0, x1, y1, color);
		x0 = x1;
		y0 = y1;
	}
	drawLine(image, x0, y0, x2, y2, color);
}

/// Draw a cubic bezier curve
void drawBezier(Image image, int32 x0, int32 y0, int32 x1, int32 y1, int32 x2, int32 y2, int32 x3, int32 y3, uint32 color) {
	int32 px_0 = x0;
	int32 py_0 = y0;
	int32 px_1 = 3 * (x1 - x0);
	int32 py_1 = 3 * (y1 - y0);
	int32 px_2 = 3 * (x2 - x1) - px_1;
	int32 py_2 = 3 * (y2 - y1) - py_1;
	int32 px_3 = x3 - px_2 - px_1 - px_0;
	int32 py_3 = y3 - py_2 - py_1 - py_0;

	float64 dt = 1. / 128;
	for (float64 t = dt; t < 1; t += dt) {
		x1 = ((px_3 * t + px_2) * t + px_1) * t + px_0;
		y1 = ((py_3 * t + py_2) * t + py_1) * t + py_0;
		drawLineIncl(image, x0, y0, x1, y1, color);
		x0 = x1;
		y0 = y1;
	}
	drawLine(image, x0, y0, x3, y3, color);
}
/// Fill a rectangle on the `image` specified by the coordinates with the given `color`
void fillRect(Image image, int32 x0, int32 y0, int32 x1, int32 y1, int32 incl, uint32 color) {
	static if (preferNativeCalls && struct(Image.fillRect) != null) {
		return Image.fillRect(image, x0, y0, x1, y1, incl, color);
	}

	if (x0 > x1) {
		int32 t = x0;
		x0 = x1;
		x1 = t;
	}
	if (y0 > y1) {
		int32 t = y0;
		y0 = y1;
		y1 = t;
	}
	x1 += incl;
	y1 += incl;

	for (int32 y = y0; y < y1; y += 1) {
		for (int32 x = x0; x < x1; x += 1) {
			image.set(x, y, color);
		}
	}
}

/// Fill a rectangle on the `image` specified by the coordinates with the given `color`
inline fillRect(Image image, int32 x0, int32 y0, int32 x1, int32 y1, uint32 color) = image.fillRect(x0, y0, x1, y1, 0, color);

/// Draw a rectangle on the `image` specified by the coordinates with the given `width` and `color`
void drawRect(Image image, int32 x0, int32 y0, int32 x1, int32 y1, int32 width, uint32 color) {
	if (y0 > y1) {
		int32 t = y1;
		y1 = y0;
		y0 = t;
	}
	if (x0 > x1) {
		int32 t = x1;
		x1 = x0;
		x0 = t;
	}

	int32 half1 = (width - 0) / 2;
	int32 half2 = (width - 1) / 2;
	x0 -= half1;
	y0 -= half1;
	x1 += half2;
	y1 += half2;

	if (x1 - x0 <= 2 * width || y1 - y0 <= 2 * width) {
		// no gap between top and bottom or left and right; draw all at once
		return image.fillRect(x0, y0, x1, y1, color);
	}

	image.fillRect(x0, y0, x1, y0 + width, color);					// top
	image.fillRect(x0, y0 + width, x0 + width, y1 - width, color);	// left
	image.fillRect(x1 - width, y0 + width, x1, y1 - width, color);	// right
	image.fillRect(x0, y1 - width, x1, y1, color);					// bottom
}

/// Draw a rectangle on the `image` specified by the coordinates with the given `color`
inline drawRect(Image image, int32 x0, int32 y0, int32 x1, int32 y1, uint32 color) = image.drawRect(x0, y0, x1, y1, 1, color);

/// Fill a rectangle on the `image` specified by `roi` with the given `color`
void fillRect(Image image, Rect roi!, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.fillRect(roi.x0, roi.y0, roi.x1, roi.y1, color);
}

/// Draw a rectangle on the `image` specified by `roi` with the given `color`
void drawRect(Image image, Rect roi!, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.drawRect(roi.x0, roi.y0, roi.x1, roi.y1, 1, color);
}
/// Fill a rounded rectangle on `image` specified by the coordinates and rounding, with the given `color`
void fillRRect(Image image, int32 x0, int32 y0, int32 x1, int32 y1, int32 rx, int32 ry, uint32 color) {
	if (x0 > x1) {
		int32 t = x0;
		x0 = x1;
		x1 = t;
	}
	if (y0 > y1) {
		int32 t = y0;
		y0 = y1;
		y1 = t;
	}
	x1 -= int32(x1 > x0);
	y1 -= int32(y1 > y0);

	int32 dx = x1 - x0;
	int32 dy = y1 - y0;
	if (dx < 3 || dy < 3) {
		// no rounding is needed
		return image.fillRect(x0, y0, x1, y1, 1, color);
	}

	ry = Int32.min(ry, (dy - int32(dx > 16)) / 2);
	rx = Int32.min(rx, (dx - int32(dy > 16)) / 2);
	if (rx < 8 || ry < 8) {
		if (rx < 1 || ry < 1) {
			// no rounding is needed
			return image.fillRect(x0, y0, x1, y1, 1, color);
		}
		// apply some visual fixes
		rx += int32(rx == 7) - int32(rx == 6);
		ry += int32(ry == 7) - int32(ry == 6);
	}

	int64 sx = rx * rx;
	int64 sy = ry * ry;
	int64 rdy = sx * ry;
	int64 rdx = 0;
	int64 r = rdy / 2;

	x0 += rx;
	x1 -= rx;
	for (;y0 < y1;) {
		image.fillRect(x0, y0, x1, y0, 1, color);
		image.fillRect(x0, y1, x1, y1, 1, color);
		if (r >= 0) {
			x0 -= 1;
			x1 += 1;
			r -= rdx += sy;
		}
		if (r < 0) {
			y0 += 1;
			y1 -= 1;
			r += rdy -= sx;
		}
	}
	image.fillRect(x0, y0, x1, y1, 1, color);
}

/// Draw a rounded rectangle on `image` specified by the coordinates and rounding, with the given `color`
void drawRRect(Image image, int32 x0, int32 y0, int32 x1, int32 y1, int32 rx, int32 ry, uint32 color) {
	if (x0 > x1) {
		int32 t = x0;
		x0 = x1;
		x1 = t;
	}
	if (y0 > y1) {
		int32 t = y0;
		y0 = y1;
		y1 = t;
	}
	x1 -= int32(x1 > x0);
	y1 -= int32(y1 > y0);

	int32 dx = x1 - x0;
	int32 dy = y1 - y0;
	if (dx < 2 || dy < 2) {
		// no gap between top and bottom or left and right; draw all at once
		return image.fillRect(x0, y0, x1, y1, 1, color);
	}

	ry = Int32.min(ry, (dy - int32(dx > 16)) / 2);
	rx = Int32.min(rx, (dx - int32(dy > 16)) / 2);
	if (rx < 8 || ry < 8) {
		if (rx < 1 || ry < 1) {
			// no rounding is needed
			return image.drawRect(x0, y0, x1 + 1, y1 + 1, 1, color);
		}
		// apply some visual fixes
		rx += int32(rx == 7) - int32(rx == 6);
		ry += int32(ry == 7) - int32(ry == 6);
	}

	int64 sx = rx * rx;
	int64 sy = ry * ry;
	int64 rdy = sx * ry;
	int64 rdx = 0;
	int64 r = rdy / 2;

	x0 += rx;
	x1 -= rx;
	image.fillRect(x0, y0, x1, y0, 1, color);
	image.fillRect(x0, y1, x1, y1, 1, color);
	for (;y0 < y1;) {
		image.set(x0, y0, color);
		image.set(x1, y0, color);
		image.set(x0, y1, color);
		image.set(x1, y1, color);
		if (r >= 0) {
			x0 -= 1;
			x1 += 1;
			r -= rdx += sy;
		}
		if (r < 0) {
			y0 += 1;
			y1 -= 1;
			r += rdy -= sx;
		}
	}
	image.fillRect(x0, y0, x0, y1, 1, color);
	image.fillRect(x1, y0, x1, y1, 1, color);
}

/// Fill the given rectangle rounding the corners using the given radius
inline fillRRect(Image image, int32 x1, int32 y1, int32 x2, int32 y2, int32 r, uint32 color) = fillRRect(image, x1, y1, x2, y2, r, r, color);

/// Draw the given rectangle rounding the corners using the given radius
inline drawRRect(Image image, int32 x1, int32 y1, int32 x2, int32 y2, int32 r, uint32 color) = drawRRect(image, x1, y1, x2, y2, r, r, color);

/// Fill the given rectangle rounding the corners using the given radius
void fillRRect(Image image, Rect roi!, int32 rx, int32 ry, uint32 color) {
	if (roi.empty()) {
		return;
	}
	image.fillRRect(roi.x0, roi.y0, roi.x1, roi.y1, rx, ry, color);
}

/// Fill the given rectangle rounding the corners using the given radius
inline fillRRect(Image image, Rect roi!, int32 r, uint32 color) = fillRRect(image, roi, r, r, color);
/// apply a color lookup table to each pixel component (alpha channel as luminosity), defined by the `roi` on the `image`
void colorMap(Image image, int32 x, int32 y, Image src, Rect roi?, argb lut[256]) {
	static if (preferNativeCalls && struct(Image.copy.lookupLrgb) != null) {
		return Image.copy(image, x, y, src, roi, lut, Image.copy.lookupLrgb);
	}

	inline fxpBits = 20;
	inline fxp(float64 v) = int32(v * (1 << fxpBits));
	static int32 rgb2luv[] = {
		fxp( 0.299), fxp( 0.587), fxp( 0.114),
		fxp(-0.147), fxp(-0.289), fxp( 0.437),
		fxp( 0.615), fxp(-0.515), fxp(-0.100),
	};
	static int32 luv2rgb[] = {
		fxp(1), fxp( 0.000), fxp( 1.140),
		fxp(1), fxp(-0.394), fxp(-0.581),
		fxp(1), fxp( 2.028), fxp( 0.000),
	};

	static argb mapLuv(argb lut[256], argb base, argb with) {
		// lookup also luminosity using the alpha channel:
		// convert the color from `rgb` to `luv` color space,
		// lookup luminosity, then convert back and store the new color
		int32 r = lut[with.r].r;
		int32 g = lut[with.g].g;
		int32 b = lut[with.b].b;

		int32 l = (r * rgb2luv[0] + g * rgb2luv[1] + b * rgb2luv[2]) >> fxpBits;
		int32 u = (r * rgb2luv[3] + g * rgb2luv[4] + b * rgb2luv[5]) >> fxpBits;
		int32 v = (r * rgb2luv[6] + g * rgb2luv[7] + b * rgb2luv[8]) >> fxpBits;

		l = lut[sat_s8(l)].a;

		return {
			r: sat_s8((l * luv2rgb[0] + u * luv2rgb[1] + v * luv2rgb[2]) >> fxpBits);
			g: sat_s8((l * luv2rgb[3] + u * luv2rgb[4] + v * luv2rgb[5]) >> fxpBits);
			b: sat_s8((l * luv2rgb[6] + u * luv2rgb[7] + v * luv2rgb[8]) >> fxpBits);
		};
	}
	return image.copy(x, y, src, roi, lut, mapLuv);
}

/// apply a color lookup table to the red, green and blue pixel components, defined by the `roi` on the `image`
void colorMapRgb(Image image, int32 x, int32 y, Image src, Rect roi?, argb lut[256]) {
	static if (preferNativeCalls && struct(Image.copy.lookupRgb) != null) {
		return Image.copy(image, x, y, src, roi, lut, Image.copy.lookupRgb);
	}
	static argb mapRgb(argb lut[256], argb base, argb with) {
		return {
			r: lut[with.r].r;
			g: lut[with.g].g;
			b: lut[with.b].b;
		};
	}
	return image.copy(x, y, src, roi, lut, mapRgb);
}

/// apply a color lookup table to the red, green and blue pixel components, defined by the `roi` on the `image`
void colorMap3d(Image image, int32 x, int32 y, Image src, Rect roi?, argb lut[256*256*256]) {
	static if (preferNativeCalls && struct(Image.copy.lookup3d) != null) {
		return Image.copy(image, x, y, src, roi, lut, Image.copy.lookup3d);
	}
	static argb mapRgb(argb lut[256], argb base, argb with) {
		return lut[with.r + 256 * (with.g + 256 * with.b)];
	}
	return image.copy(x, y, src, roi, lut, mapRgb);
}
/// apply a color matrix to each pixel defined by the `roi` on the `image`
void colorMat(Image image, int32 x, int32 y, Image src, Rect roi?, mat4f mat!) {
	static if (preferNativeCalls && struct(Image.colorMatrix) != null) {
		return Image.colorMatrix(image, x, y, src, roi, mat.data);
	}

	inline fxpBits = 16;
	inline fxp(float64 v) = int32(v * (1 << fxpBits));
	static argb colorMatrix(int32 m[12], argb base, argb with) {
		int32 r = rch(with);
		int32 g = gch(with);
		int32 b = bch(with);
		return {
			r: sat_s8((r * m[0x0] + g * m[0x1] + b * m[0x2] + m[0x3]) >> fxpBits);
			g: sat_s8((r * m[0x4] + g * m[0x5] + b * m[0x6] + m[0x7]) >> fxpBits);
			b: sat_s8((r * m[0x8] + g * m[0x9] + b * m[0xa] + m[0xb]) >> fxpBits);
			// a: sat_s8((r * m[0xc] + g * m[0xd] + b * m[0xe] + m[0xf]) >> fxpBits);
		};
	}

	assert(image.depth() == 32);
	int32 m[12] = {
		fxp(mat.xx), fxp(mat.xy), fxp(mat.xz), fxp(256 * mat.xw),
		fxp(mat.yx), fxp(mat.yy), fxp(mat.yz), fxp(256 * mat.yw),
		fxp(mat.zx), fxp(mat.zy), fxp(mat.zz), fxp(256 * mat.zw),
		// fxp(mat.wx), fxp(mat.wy), fxp(mat.wz), fxp(256 * mat.ww),
	};

	return image.copy(x, y, src, roi, m, colorMatrix);
}
/// copy the `src` image to the destination with an optional blend method
void copy(Image image, int32 x0, int32 y0, Image src, Rect roi?, pointer extra, argb blend(pointer extra, argb base, argb with)) {
	static if (preferNativeCalls && struct(Image.copy) != null) {
		return Image.copy(image, x0, y0, src, roi, extra, pointer(blend));
	}

	assert(image.depth() == 32);
	assert(src.depth() == 32);

	// clip roi with source image
	Rect rect = {
		x0: roi != null ? roi.x0 : 0;
		y0: roi != null ? roi.y0 : 0;
		x1: roi != null ? roi.x1 : src.width();
		y1: roi != null ? roi.y1 : src.height();
	};
	if (x0 < 0) {
		rect.x0 -= x0;
	}
	if (y0 < 0) {
		rect.y0 -= y0;
	}
	if (!src.clip(&rect)) {
		// nothing to get
		return;
	}

	// clip also destination
	rect.positionX(x0 < 0 ? 0 : x0);
	rect.positionY(y0 < 0 ? 0 : y0);
	if (!image.clip(&rect)) {
		// nothing to set
		return;
	}

	if (blend == null) {
		for (int y = rect.y0; y < rect.y1; y += 1) {
			for (int x = rect.x0; x < rect.x1; x += 1) {
				image.set(x, y, src.get(x - x0, y - y0));
			}
		}
		return;
	}

	for (int y = rect.y0; y < rect.y1; y += 1) {
		for (int x = rect.x0; x < rect.x1; x += 1) {
			argb base = argb(image.get(x, y));
			argb with = argb(src.get(x - x0, y - y0));
			image.set(x, y, blend(extra, base, with));
		}
	}
}

/// copy the `src` image to the destination with an optional blend method
void copy(Image image, int32 x0, int32 y0, Image src, Rect roi?, vec4f blend(vec4f base, vec4f with)) {
	static if (preferNativeCalls && struct(Image.copy.blendVec4f) != null) {
		return Image.copy(image, x0, y0, src, roi, blend, Image.copy.blendVec4f);
	}
	static argb blendVec4f(vec4f blend(vec4f base, vec4f with), argb base, argb with) {
		return argb(blend(vec4f(base), vec4f(with)));
	}
	if (blend == null) {
		return copy(image, x0, y0, src, roi, null, null);
	}
	return copy(image, x0, y0, src, roi, blend, pointer(blendVec4f));
}

/// copy or convert `src` image to the destination `image`
void copy(Image image, int32 x, int32 y, Image src, Rect roi?) {
	return copy(image, x, y, src, roi, null, null);
}

/// copy or convert `src` image to the destination `image`
void copy(Image image, Image src) {
	return copy(image, 0, 0, src, null, null, null);
}

/// fill the destination with the given `col` (alpha channel is used)
void copy(Image image, Rect roi!, argb col) {
	static if (preferNativeCalls && struct(Image.blend.color) != null) {
		return image.blend(roi.x0, roi.y0, image, roi, col, Image.blend.color);
	}
	argb blender(argb color!, argb base, argb with) {
		int alpha = ach(color);
		return {
			b: mix_s8(alpha, bch(color), bch(base));
			g: mix_s8(alpha, gch(color), gch(base));
			r: mix_s8(alpha, rch(color), rch(base));
			a: alpha;
		};
	}
	return copy(image, roi.x0, roi.y0, image, roi, col, blender);
}

/// fill the destination with the given `col` (alpha channel is used)
void copy(Image image, argb col) {
	static if (preferNativeCalls && struct(Image.blend.color) != null) {
		return image.blend(0, 0, image, null, col, Image.blend.color);
	}
	return copy(image, Rect(0, 0, image.width(), image.height()), col);
}

/// copy the `src` image to the destination with the given transparency
void blendAlpha(Image image, int32 x, int32 y, Image src, Rect roi?, int32 alpha) {
	static if (preferNativeCalls && struct(Image.copy.alpha) != null) {
		return Image.copy(image, x, y, src, roi, alpha, Image.copy.alpha);
	}

	static argb blender(int32 alpha!, argb base, argb with) {
		return {
			b: sat_s8(mix_s8(alpha, bch(base), bch(with)));
			g: sat_s8(mix_s8(alpha, gch(base), gch(with)));
			r: sat_s8(mix_s8(alpha, rch(base), rch(with)));
			a: alpha;
		};
	}
	return image.copy(x, y, src, roi, alpha, blender);
}

/// copy the `src` image to the destination masked with destination alpha
void blendDstAlpha(Image image, int32 x, int32 y, Image src, Rect roi?) {
	static if (preferNativeCalls && struct(Image.blend.dstAlpha) != null) {
		return Image.blend(image, x, y, src, roi, null, Image.blend.dstAlpha);
	}

	argb blender(pointer null, argb base, argb with) {
		int alpha = ach(base);
		return {
			b: mix_s8(alpha, bch(base), bch(with));
			g: mix_s8(alpha, gch(base), gch(with));
			r: mix_s8(alpha, rch(base), rch(with));
			a: alpha;
		};
	}
	return image.copy(x, y, src, roi, null, blender);
}

/// Create an image by copying another one
Image Image(Image copy) {
	Image result = Image.create(copy.width(), copy.height(), copy.depth());
	result.copy(0, 0, copy, null);
	return result;
}

/// copy the `src` image multiple times so it fills the whole `image`
void tile(Image image, int x, int y, Image src, Rect roi?) {
	Rect rect = {
		x0: roi != null ? roi.x0 : 0;
		y0: roi != null ? roi.y0 : 0;
		x1: roi != null ? roi.x1 : src.width();
		y1: roi != null ? roi.y1 : src.height();
	};

	if (!src.clip(&rect)) {
		return;
	}

	if (x < 0) {
		x = -(-x % rect.width());
	}
	if (y < 0) {
		y = -(-y % rect.height());
	}
	int width = image.width();
	int height = image.height();
	for (int j = y; j < height; j += rect.height()) {
		for (int i = x; i < width; i += rect.width()) {
			image.copy(i, j, src, rect);
		}
	}
}

/// Fill the surface by evaluating the given function for each pixel
void eval(Image image, Rect roi?, float32 aspect, float32 time, vec4f eval(vec4f in)) {
	Rect rect = {
		x0: roi != null ? roi.x0 : 0;
		y0: roi != null ? roi.y0 : 0;
		x1: roi != null ? roi.x1 : image.width();
		y1: roi != null ? roi.y1 : image.height();
	};

	if (!image.clip(&rect)) {
		return;
	}

	float32 w = rect.width();
	float32 h = rect.height();
	if (aspect == 0) {
		aspect = w / h;
	}
	h *= aspect;

	vec4f in = vec4f(0, 0, 0, time);
	for (int y = rect.y0; y < rect.y1; y += 1) {
		in.y = (y - rect.y0) / h;
		for (int x = rect.x0; x < rect.x1; x += 1) {
			in.x = (x - rect.x0) / w;
			image.set(x, y, argb(eval(in)));
		}
	}
}
/// emulated implementation of blur function
void blur(Image image, int radius, float64 sigma) {
	static if (preferNativeCalls && struct(Image.blur) != null) {
		return Image.blur(image, radius, sigma);
	}
	static float64 gauss(float64 x, float64 sigma) {
		inline SQRT_2_PI_INV = 0.398942280401432677939946059935;
		float64 t = x / sigma;
		/*switch (dx) {
			default:
				break;
			case -1:
				return 1;
			case 0:
				return SQRT_2_PI_INV * exp(-0.5*t*t) / sigma;
			case 1:
				return -x * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma);
			case 2:
				return (x * x - sigma * sigma) * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma * sigma * sigma);
		}*/
		return SQRT_2_PI_INV * Float64.exp(-0.5 * t * t) / sigma;
	}

	int32 kernel[1024] = {...};
	int size = radius * 2 + 1;
	assert(size < kernel.length);

	float64 kernelSum = 0;
	float64 kernelFlt[kernel.length] = {...};
	for (int i = 0; i < size; i += 1) {
		kernelFlt[i] = gauss(radius - i, sigma);
		kernelSum += kernelFlt[i];
	}

	for (int i = 0; i < size; i += 1) {
		kernel[i] = 65536 * (kernelFlt[i] / kernelSum);
	}

	int width = image.width();
	int height = image.height();
	Image tmp = Image.create(width, height, image.depth());

	// x direction: inout -> temp
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			int32 r = 0;
			int32 g = 0;
			int32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _x = x + i - radius;
				if (_x >= 0 && _x < width) {
					argb col = argb(image.get(_x, y));
					int32 _k = kernel[i];
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			tmp.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}

	// y direction: temp -> inout
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			int32 r = 0;
			int32 g = 0;
			int32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _y = y + i - radius;
				if (_y >= 0 && _y < height) {
					argb col = argb(tmp.get(x, _y));
					int32 _k = kernel[i];
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			image.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}

	tmp.destroy();
}
/// Copy one image to another using a transformation matrix [scale, rotate, translate, shear, perspective, etc]
void transform(Image image, Rect rect?, Image src, mat4f mat!, int32 interpolate) {
	static if (preferNativeCalls && struct(Image.transform) != null) {
		return Image.transform(image, rect, src, null, interpolate, pointer(mat.data));
	}

	assert(image.depth() == 32);
	assert(src.depth() == 32);

	Rect dRec = {
		x0: rect != null ? rect.x0 : 0;
		y0: rect != null ? rect.y0 : 0;
		x1: rect != null ? rect.x1 : image.width();
		y1: rect != null ? rect.y1 : image.height();
	};
	if (!image.clip(&dRec)) {
		// nothing to set
		return;
	}

	int32 width = dRec.width();
	int32 height = dRec.height();
	if (interpolate == 0) {
		for (int32 y = 0; y < height; y += 1) {
			int32 yDst = y + dRec.y0;
			for (int32 x = 0; x < width; x += 1) {
				vec4f t = mat.dph(vec4f(x, y, 0, 1));
				image.set(x + dRec.x0, yDst, src.get(t.x, t.y));
			}
		}
		return;
	}

	// fixme: src.tex(x, y) does not center, do: transform.xw += .5; transform.yw += .5;
	mat4f transform = scale(vec4f(src.width(), src.height(), 0, 0), 1).mul(mat);
	for (int32 y = 0; y < height; y += 1) {
		int32 yDst = y + dRec.y0;
		for (int32 x = 0; x < width; x += 1) {
			vec4f t = transform.dph(vec4f(x, y, 0, 1));
			image.set(x + dRec.x0, yDst, argb(src.tex(t.x, t.y)));
		}
	}
}

/// Resize the given `region` of the `source` image into the `destination` image using the `interpolation`.
void resize(Image image, Rect rect?, Image src, Rect roi?, int32 interpolate) {
	int32 srcX0 = roi != null ? roi.x0 : 0;
	int32 srcY0 = roi != null ? roi.y0 : 0;
	int32 dstX0 = rect != null ? rect.x0 : 0;
	int32 dstY0 = rect != null ? rect.y0 : 0;
	int32 srcWidth = roi != null ? roi.x1 - roi.x0 : src.width();
	int32 srcHeight = roi != null ? roi.y1 - roi.y0 : src.height();
	int32 dstWidth = rect != null ? rect.x1 - rect.x0 : image.width();
	int32 dstHeight = rect != null ? rect.y1 - rect.y0 : image.height();
	mat4f scale = {
		x: vec4f(float32(srcWidth) / dstWidth, 0, 0, srcX0);
		y: vec4f(0, float32(srcHeight) / dstHeight, 0, srcY0);
		z: vec4f(0, 0, 1, 0);
		w: vec4f(0, 0, 0, 1);
	};
	scale = scale.mul(translation(vec4f(dstX0, dstY0, 0, 0), -1));
	return transform(image, rect, src, scale, interpolate);
}

/// Create an image by copying another one using a custom width and height
Image Image(Image image, int width, int height, int align, float64 maxScale) {
	// todo: merge with align from micro.ui.ci
	enum: int {
		center: 0;
		left: 1;
		right: 2;
		top: 4;
		bottom: 8;
		fitVertical: left + right;
		fitHorizontal: top + bottom;
		fill: 0x10;
		highRes: 0x20;
	}

	int alignVertical = align & fitVertical;
	int alignHorizontal = align & fitHorizontal;
	bool fitWidth = alignVertical == fitVertical;
	bool fitHeight = alignHorizontal == fitHorizontal;

	float64 scale = 1;
	if (fitWidth && fitHeight) {
		float64 widthScale = width / float64(image.width());
		float64 heightScale = height / float64(image.height());
		if (align & fill) {
			scale = Float64.max(widthScale, heightScale);
		} else {
			scale = Float64.min(widthScale, heightScale);
		}
	}
	else if (fitWidth) {
		scale = width / float64(image.width());
	}
	else if (fitHeight) {
		scale = height / float64(image.height());
	}
	if (scale > maxScale) {
		scale = maxScale;
	}

	// calculate translation
	float64 tx = 0;
	if (fitWidth || alignVertical == center) {
		tx = (width - image.width() * scale) / 2;
	}
	else if (alignVertical == right) {
		tx = (width - image.width() * scale);
	}

	float64 ty = 0;
	if (fitHeight || alignHorizontal == center) {
		ty = (height - image.height() * scale) / 2;
	}
	else if (alignHorizontal == bottom) {
		ty = (height - image.height() * scale);
	}

	mat4f mat = {
		x: {x: 1 / scale, y: 0, z: 0, w: -tx / scale};
		y: {x: 0, y: 1 / scale, z: 0, w: -ty / scale};
		z: {x: 0, y: 0, z: 1 / scale, w: 0};
		w: {x: 0, y: 0, z: 0, w: 1};
	};

	Image result = Image(width, height, image.depth());
	result.transform(null, image, mat, align & highRes ? 1 : 0);
	return result;
}

/// Create an image by opening an image file with custom width and height
Image Image(char fileName[], int width, int height, int depth, int align, float64 maxScale) {
	Image image = Image(fileName, depth);
	Image result = Image(image, width, height, align, maxScale);
	image.destroy();
	return result;
}

/// Create an image by opening an image file with custom width and height
inline Image(char fileName[], int width, int height, int depth, int align) = Image(fileName, width, height, depth, align, Float64.inf);

/// Create an image by opening an image file with custom width and height
inline Image(char fileName[], int width, int height, int depth) = Image(fileName, width, height, depth, -1, Float64.inf);
/// Create an image with the given with, height and depth
inline Image(int width, int height, int depth) = Image.create(width, height, depth);

/// Create an image by opening an image file
Image Image(char fileName[], int depth) {
	static if (struct(Image.openPng) != null) {
		if (fileName.endsWith(".png", ignCaseCmp)) {
			return Image.openPng(fileName, depth);
		}
	}
	static if (struct(Image.openJpg) != null) {
		if (fileName.endsWith(".jpeg", ignCaseCmp)) {
			return Image.openJpg(fileName, depth);
		}
		if (fileName.endsWith(".jpg", ignCaseCmp)) {
			return Image.openJpg(fileName, depth);
		}
	}
	static if (struct(Image.openBmp) != null) {
		if (fileName.endsWith(".bmp", ignCaseCmp)) {
			return Image.openBmp(fileName, depth);
		}
	}
	return Image.openImg(fileName, depth);
}

/// Create an image by opening an image file
inline Image(char fileName[]) = Image(fileName, 32);

/// Clip the rectangle against the given image boundaries
bool clip(Image image, Rect roi&) {
	if (roi.x0 < 0) {
		roi.x0 = 0;
	}

	if (roi.y0 < 0) {
		roi.y0 = 0;
	}

	int width = image.width();
	if (roi.x1 > width) {
		roi.x1 = width;
	}

	int height = image.height();
	if (roi.y1 > height) {
		roi.y1 = height;
	}

	return !roi.empty();
}

/// Set the the color of a pixel at the given position
inline set(Image image, int32 x, int32 y, argb color) = Image.set(image, x, y, uint32(color));
/// Checks whether the given `rectangle` is empty or not.
bool empty(Rect rectangle!) {
// fixme: inline empty(Rect roi&) = roi.x0 >= roi.x1 || roi.y0 >= roi.y1;
	return rectangle.x0 >= rectangle.x1 || rectangle.y0 >= rectangle.y1;
}

/// Checks whether the given `rectangle` contains the point (`x`, `y`).
bool contains(Rect rect!, int32 x, int32 y) {
	return x >= rect.x0 && x < rect.x1 && y >= rect.y0 && y < rect.y1;
}

/// Computes the width of the given `rectangle`.
inline width(Rect rectangle!) = rectangle.x1 - rectangle.x0;
/// Sets the width of the given `rectangle`.
void width(Rect rectangle&, int32 width) {
	rectangle.x1 = rectangle.x0 + width;
}

/// Computes the height of the given `rectangle`.
inline height(Rect rectangle!) = rectangle.y1 - rectangle.y0;
/// Sets the height of the given `rectangle`.
void height(Rect rectangle&, int32 height) {
	rectangle.y1 = rectangle.y0 + height;
}

/// Sets the width and height of the given `rectangle`.
void setSize(Rect rectangle&, int32 width, int32 height) {
	rectangle.x1 = rectangle.x0 + width;
	rectangle.y1 = rectangle.y0 + height;
}

/// Sets the x position of the given `rectangle`.
void positionX(Rect rectangle&, int32 x) {
	rectangle.x1 = x + rectangle.x1 - rectangle.x0;
	rectangle.x0 = x;
}
/// Sets the y position of the given `rectangle`.
void positionY(Rect rectangle&, int32 y) {
	rectangle.y1 = y + rectangle.y1 - rectangle.y0;
	rectangle.y0 = y;
}

/// Sets the x and y position of the given `rectangle`.
void position(Rect rectangle&, int32 x, int32 y) {
	rectangle.positionX(x);
	rectangle.positionY(y);
}

///@public
void adjust(Rect rect&, int32 dx0, int32 dy0, int32 dx1, int32 dy1) {
	rect.x0 += dx0;
	rect.y0 += dy0;
	rect.x1 += dx1;
	rect.y1 += dy1;
}

///@public
void padded(Rect rect&, int32 padding) {
	rect.x0 -= padding;
	rect.y0 -= padding;
	rect.x1 += padding;
	rect.y1 += padding;
}

/// Moves the given `rectangle` by `dx` and `dy`.
inline translate(Rect rectangle&, int32 dx, int32 dy) = rectangle.adjust(dx, dy, dx, dy);
/// Moves the given `rectangle` horizontally by `dx`.
void translateX(Rect rectangle&, int32 dx) {
	rectangle.x0 += dx;
	rectangle.x1 += dx;
}
/// Moves the given `rectangle` vertically by `dy`.
void translateY(Rect rectangle&, int32 dy) {
	rectangle.y0 += dy;
	rectangle.y1 += dy;
}

/// Create a rectangle using left, top, right and bottom values
Rect Rect(int32 x0, int32 y0, int32 x1, int32 y1) {
	return { x0: x0, y0: y0, x1: x1, y1: y1 };
}
///@public
struct Button: View {
	///@public
	char text[];

	bool onMeasure(Button this, Rect rect&) {
		Style style& = this.style;
		style.measure(&rect, this.text);
		return View.onMeasure(this, &rect);
	}

	void onDraw(Button this, Image offs, Rect rect) {
		View.onDraw(this, offs, rect, null, this.text);
	}
}
/// Style used to layout and draw text and views.
struct Style {
	/// Default dark theme color for background
	static argb dark! = argb(0x1a1a1a);
	/// Default light theme color for background
	static argb light! = argb(0xdadada);

	/// Default blue accent color for controls
	static argb blue! = argb(33, 149, 246);
	/// Default green accent color for controls
	static argb green! = argb(74, 174, 82);
	/// Default gray accent color for controls
	static argb gray! = argb(98, 125, 139);
	/// Default orange accent color for controls
	static argb orange! = argb(255, 153, 0);
	/// Default red accent color for controls
	static argb red! = argb(246, 64, 49);
	/// Default magenta accent color for controls
	static argb magenta! = argb(156, 36, 181);
	/// Default cyan accent color for controls
	static argb cyan! = argb(0, 149, 139);

	static argb theme! = dark;
	static argb accent! = gray;

	/// Alignment of text in views
	int32 align = 0;

	/// Padding around text in views
	int32 padding = 8;

	/// The font to be used to draw text
	Image font = Window.font;

	/// the default number format used for widgets
	static NumberFormat defaultFormat! = {
		trailingZeros: true;
		precision: 2;
	};

	/// Formatting to be used printing numbers, dates, etc
	NumberFormat format = defaultFormat;

	///@public
	uint32 backgroundColor = uint32(theme);
	// uint32 disabledColor = TODO;
	///@public
	uint32 hoveredColor = uint32(mix_rgb8(16, theme, accent));
	///@public
	uint32 focusedColor = uint32(mix_rgb8(64, theme, accent));
	///@public
	uint32 valueColor = uint32(accent);
	///@public
	uint32 textColor = uint32(lum(theme) > 127 ? dark : light);

	enum: int32 {
		top: 1;
		left: 2;
		right: 4;
		bottom: 8;
		center: 0;

		topLeft: top | left;
		topRight: top | right;
		bottomLeft: bottom | left;
		bottomRight: bottom | right;

		vertical: left | right;
		verticalTop: vertical | top;
		verticalBottom: vertical | bottom;

		horizontal: top | bottom;
		horizontalLeft: horizontal | left;
		horizontalRight: horizontal | right;

		fill: top | left | right | bottom;
	}

	/// Place the given `rect` inside the `parent` rectangle conforming to `align`
	static void align(Rect parent, Rect rect&, int32 align) {
		int32 vertical = align & Style.vertical;
		if (vertical == center) {
			rect.positionX(parent.x0 + (parent.width() - rect.width()) / 2);
		}
		else if (vertical == right) {
			rect.positionX(parent.x0 + (parent.width() - rect.width()));
		}
		else if (vertical == left) {
			rect.positionX(parent.x0);
		}
		else { // fit
			rect.x0 = parent.x0;
			rect.x1 = parent.x1;
		}

		int32 horizontal = align & Style.horizontal;
		if (horizontal == center) {
			rect.positionY(parent.y0 + (parent.height() - rect.height()) / 2);
		}
		else if (horizontal == bottom) {
			rect.positionY(parent.y0 + (parent.height() - rect.height()));
		}
		else if (horizontal == top) {
			rect.positionY(parent.y0);
		}
		else { // fit
			rect.y0 = parent.y0;
			rect.y1 = parent.y1;
		}
	}

	/// Measure the given `text` whit `this` style.
	static void measure(Style this!, Rect rect&, char text[]) {
		this.font.clipText(&rect, text);
		rect.x1 += 2 * this.padding;
		rect.y1 += 2 * this.padding;
	}

	/// Measure and align the given `text` whit `this` style.
	static void align(Style this!, Rect parent, Rect rect&, char value[], int32 align) {
		parent.padded(-this.padding);
		this.font.clipText(&rect, value);
		if ((align & horizontal) == horizontal) {
			// center text if it is aligned both top and bottom
			align &= ~horizontal;
		}
		if ((align & vertical) == vertical) {
			// todo: justify text if it is aligned both left and right
			align &= ~vertical;
		}
		align(parent, &rect, align);
	}

	/// Measure and align the given `text` whit `this` style.
	static void align(Style this!, Rect parent, Rect rect&, char value[]) {
		return align(this, parent, &rect, value, this.align);
	}

	/// Setup a custom color for the style
	static void setColor(Style style&, argb background, argb accent) {
		style.backgroundColor = uint32(background);
		style.hoveredColor = uint32(mix_rgb8(16, background, accent));
		style.focusedColor = uint32(mix_rgb8(64, background, accent));
		style.valueColor = uint32(accent);
		style.textColor = uint32(lum(background) > 127 ? dark : light);
	}

	inline vertical(int32 align) = (align & vertical) == vertical;
	inline horizontal(int32 align) = (align & horizontal) == horizontal;
}

///@public
struct KeyEvent {
	///@public
	bool release;
	///@public
	bool isShift;
	///@public
	bool isCtrl;
	///@public
	bool isAlt;
	///@public
	int32 repeat;
	///@public
	int32 key;
}

///@public
struct TouchEvent {
	///@public
	bool release;
	///@public
	bool isShift;
	///@public
	bool isCtrl;
	///@public
	bool isAlt;
	///@public
	int32 clicks;
	///@public
	int32 button;
	///@public
	int32 dx = 0;
	///@public
	int32 dy = 0;
	///@public
	int32 x;
	///@public
	int32 y;

	///@public
	static bool test(TouchEvent event!, Rect rect!) {
		if (event.x < rect.x0 || event.x >= rect.x1) {
			return false;
		}
		if (event.y < rect.y0 || event.y >= rect.y1) {
			return false;
		}
		return true;
	}

	///@public
	static bool isMotion(TouchEvent event!) {
		return event.dx || event.dy;
	}

	///@public
	static bool isPress(TouchEvent event!) {
		return !(event.release || event.dx || event.dy);
	}

	///@public
	static bool isLongPress(TouchEvent event!) {
		return event.release && event.clicks < 0;
	}

	///@public
	static bool isPress(TouchEvent event!, int32 button) {
		if (event.release || event.dx || event.dy) {
			return false;
		}
		return event.button == button;
	}
}

/** View is the base class of all user interface elements.
 * it has width and height, forming a rectangular shape on screen.
 * by it's own a view has no position, it must be positioned in a layout.
 */
struct View: object {
	/// State of the view used for drawing, and returned from event handlers
	enum State: int32 {
		ignored: 0;		// the view is in normal state, or the event is ignored by the handler
		hovered: 1;     // the view is hovered by a touch event
		focused: 2;     // the view is focused
		pressed: 4;     // the view is pressed
		clicked: 8;     // the view is clicked
		consumed: 8;    // the view is in normal state, or the event is consumed by the handler
	}

	/// fixed or minimum width of the view
	int32 width = -5;

	/// fixed or minimum height of the view
	int32 height = -5;

	/// the view accepts any user input(event) or not
	bool enabled = true;

	/// the view can be active(focused) or not
	bool focusable = true;

	// parent view
	View parent = null;

	/// style to be used for measuring and drawing views
	Style style! = null;

	/// user attached data
	variant data = null;

	/// Returns the parent of the view
	static View parent(View this) {
		return this.parent;
	}

	/// Callback function executed when the view is clicked
	bool onClick(View this&) {
		return true;
	}

	/// Callback function executed when the view is double clicked
	bool onReset(View this&) {
		return false;
	}

	/// Callback function executed when the view is created
	void onCreate(View this&, View parent) {
		assert(this.parent == null || this.parent == parent, "can not add the same view to different layouts");
		this.parent = parent;
		if (this.style == null) {
			assert(parent.style != null, "can not create view with a parent without a style");
			typename field = object.type(this).field("style"); // todo: do not use reflection
			pointer(this).inc(field.offset).sti(parent.style); // to initialize this variable
		}
	}

	/// Callback function executed when the view is destroyed
	void onDestroy(View this) { }

	/// Callback function executed when the view receives a KeyEvent: press or release
	State onKeyEvent(View this, KeyEvent event!) {
		if (!this.enabled) {
			// disabled view does not consume events
			return State.ignored;
		}
		if (event.key == ' ' || event.key == Window.KEY_CODE_ENTER) {
			if (!event.release) {
				return State.pressed;
			}
			// click with space key
			if (!this.onClick(this)) {
				return State.consumed;
			}
			return State.consumed;
		}
		if (event.key == Window.KEY_CODE_BACK) {
			if (!event.release) {
				return State.pressed;
			}
			// reset with backspace key
			if (!this.onReset(this)) {
				return State.consumed;
			}
			return State.consumed;
		}
		return State.ignored;
	}

	/// Callback function executed when the view receives a TouchEvent: press, motion or release
	bool onTouchEvent(View this, Rect rect!, TouchEvent event!) {
		/* press, release or motion
		if (event.dx || event.dy) {
			return onMotion(event);
		}
		if (event.release) {
			return onRelease(event);
		}
		return onPress(event);*/
		if (!this.enabled) {
			// disabled view does not consume events
			return false;
		}
		if (!event.release) {
			// press and motion events are not consumed
			return false;
		}

		if (event.clicks < 0) {
			// long press, not released
			return this.onReset(this);
		}
		if (event.clicks > 1) {
			// multi click to reset
			if (this.onReset(this)) {
				// do not click with press and hold
				return true;
			}
		}
		return this.onClick(this);
	}

	/// Callback function executed when the view needs to be measured
	bool onMeasure(View this, Rect rect&) {
		int32 width = Int32.abs(this.width);
		if (rect.width() < width || this.width > 0) {
			rect.width(width);
		}
		int32 height = Int32.abs(this.height);
		if (rect.height() < height || this.height > 0) {
			rect.height(height);
		}
		return true;
	}

	/// Callback function executed when the view needs to be drawn
	void onDraw(View this, Image offs, Rect rect);

	///@public
	static void onDraw(View this, Image offs, Rect rect, int32 state) {
		Style style! = this.style;
		if (state & State.focused) {
			offs.fillRect(rect, style.focusedColor);
		}
		else if (state & State.hovered) {
			offs.fillRect(rect, style.hoveredColor);
		}
		else if (this.parent.style != pointer(style)) {
			offs.fillRect(rect, style.backgroundColor);
		}
		this.onDraw(this, offs, rect);
		if (state & State.pressed) {
			offs.drawRect(rect, style.valueColor);
		}
	}

	///@public
	static void onDraw(View this, Image offs, Rect rect, char text[], char value[]) {
		Style style! = this.style;
		if (text.length == 0) {
			style.align(rect, &rect, value);
			offs.drawText(rect, style.font, value, style.valueColor);
			return;
		}

		if (value.length != 0) {
			Rect valueRoi = rect;
			style.align(valueRoi, &valueRoi, value, Style.right);
			offs.drawText(valueRoi, style.font, value, style.valueColor);
			rect.x1 = valueRoi.x0 - style.padding;
		}
		style.align(rect, &rect, text);
		offs.drawText(rect, style.font, text, style.textColor);
	}
}

static void focus(View view);
static void invalidate(View view, bool layout);

/** Layout is a view containing other views positioned by it.
 * the Layout class does not clip its children.
 * the size of the Layout class should contain all the views.
 */
struct Layout: View {
	struct Item {
		Rect rect;
		View view;
		int32 align;
	}

	View separator = null;

	Item items[*] = null;
	int itemCount = 0;
	int itemCapacity = 0;
	int hoveredIndex = -1;
	int pressedIndex = -1;
	int focusedIndex = -1;

	/// Space between layout and its content at top.
	int32 paddingTop = 0;
	/// Space between layout and its content at left.
	int32 paddingLeft = 0;
	/// Space between layout and its content at right.
	int32 paddingRight = 0;
	/// Space between layout and its content at bottom.
	int32 paddingBottom = 0;

	/** Vertical, horizontal or other orientation of the layout
	 * zero represents a stack(Qt) or frame(Android) layout (all child elements are placed on top of each other)
	 * negative value represents a column layout, specifying the number of columns to be used
	 * positive value represents a row layout, specifying the number of rows to be used
	 */
	int32 orientation = 1;

	// TODO: use positive value for fixed size, negative values for minimum size
	// int32 colSpacing = 0;
	// int32 rowSpacing = 0;

	// TODO: make width and height of each cell the same size
	// bool uniformWidth! = true;
	// bool uniformHeight! = true;

	static bool clearState(Layout this, int32 mode) {
		bool result = false;
		if (mode & State.hovered && this.hoveredIndex >= 0) {
			View view = this.items[this.hoveredIndex].view;
			if (Layout layout = view.as(Layout)) {
				clearState(layout, mode);
			}
			this.hoveredIndex = -1;
			result = true;
		}
		if (mode & State.pressed && this.pressedIndex >= 0) {
			View view = this.items[this.pressedIndex].view;
			if (Layout layout = view.as(Layout)) {
				clearState(layout, mode);
			}
			this.pressedIndex = -1;
			result = true;
		}
		if (mode & State.focused && this.focusedIndex >= 0) {
			View view = this.items[this.focusedIndex].view;
			if (Layout layout = view.as(Layout)) {
				clearState(layout, mode);
			}
			this.focusedIndex = -1;
			result = true;
		}
		return result;
	}

	/// Returns the pressed view in the current layout
	static View getPressed(Layout this!) {
		if (this.pressedIndex < 0) {
			return null;
		}
		View view = this.items[this.pressedIndex].view;
		if (Layout layout = view.as(Layout)) {
			View child = getPressed(layout);
			if (child != null) {
				return child;
			}
		}
		return view;
	}

	/// Returns the focused view in the current layout
	static View getFocused(Layout this!) {
		if (this.focusedIndex < 0) {
			return null;
		}
		View view = this.items[this.focusedIndex].view;
		if (Layout layout = view.as(Layout)) {
			View child = getFocused(layout);
			if (child != null) {
				return child;
			}
		}
		return view;
	}

	/// Sets the focused view in the current layout
	static bool setFocused(Layout this, View focus) {
		if (focus == null) {
			this.clearState(State.focused);
		}
		for (int i = 0; i < this.itemCount; i += 1) {
			Item item! = this.items[i];
			Rect rect! = item.rect;
			View view! = item.view;
			if (view == focus && this.focusedIndex != i) {
				this.clearState(State.focused);
				this.focusedIndex = i;
				return true;
			}
			if (Layout layout = view.as(Layout)) {
				if (layout.setFocused(focus) && this.focusedIndex != i) {
					this.clearState(State.focused);
					this.focusedIndex = i;
					return true;
				}
			}
		}
		return false;
	}

	static Layout capacity(Layout this&, int capacity) {
		assert(capacity >= this.itemCount);
		if (capacity == this.itemCapacity) {
			// no need to change
			return;
		}

		Item items[*] = this.items;
		this.itemCapacity = capacity;
		this.items = pointer.alloc(null, this.itemCapacity * sizeof(Item));
		pointer.copy(this.items, items, this.itemCount * sizeof(Item));
		pointer.alloc(items, 0);
		return this;
	}

	/// Append the given `views` to `this` layout with the given `alignment`
	static Layout addItems(Layout this&, int32 alignment, View views?...) {
		static View separator(Layout this&) {
			static void onDraw(View this, Image offs, Rect rect) {}
			if (this.separator != null) {
				return this.separator;
			}
			View separator = {
				enabled: false;
				focusable: false;
				onDraw: onDraw;
			};
			this.separator = separator;
			return separator;
		}

		int itemCount = this.itemCount + views.length;
		if (itemCount >= this.itemCapacity) {
			// double the capacity
			int capacity = 2 * this.itemCapacity;
			if (capacity < itemCount) {
				capacity = itemCount;
			}
			this.capacity(capacity);
		}

		for (int i = 0; i < views.length; i += 1) {
			Item item& = this.items[this.itemCount + i];
			item.view = views[i];
			item.align = alignment;
			if (item.view == null) {
				item.view = separator(this);
			}
		}
		this.itemCount = itemCount;
		return this;
	}

	///@public
	static int size(Layout this) {
		return this.itemCount;
	}

	///@public
	static View getView(Layout this, int idx) {
		assert(idx >= 0 && idx < this.itemCount);
		return this.items[idx].view;
	}

	///@public
	static void setAlignment(Layout this, int idx, int32 alignment) {
		assert(idx >= 0 && idx < this.itemCount);
		this.items[idx].align = alignment;
	}

	/// Set the padding of `this` layout to the given values
	static Layout padding(Layout this, int32 top, int32 left, int32 right, int32 bottom) {
		this.paddingTop = top;
		this.paddingLeft = left;
		this.paddingRight = right;
		this.paddingBottom = bottom;
		this.invalidate(true);
		return this;
	}

	bool onClick(Layout this) {
		error("onClick");
		return false;
	}

	bool onReset(Layout this) {
		bool result = false;
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i].view;
			if (view.onReset(view)) {
				result = true;
			}
		}
		return result;
	}

	void onCreate(Layout this&, View parent) {
		assert(this.parent == null, "can not add the same layout multiple times");
		View.onCreate(this, parent);
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i].view;
			view.onCreate(view, this);
		}
	}

	void onDestroy(Layout this) {
		// destroy views and free up allocations
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i].view;
			view.onDestroy(view);
			view.destroy();
		}
		pointer.alloc(this.items, 0);
	}

	State onKeyEvent(Layout this, KeyEvent event!) {
		if (!this.enabled) {
			// disabled layout does not consume events
			return State.ignored;
		}

		int32 idx = this.focusedIndex;

		if (idx < 0) {
			// no child focused, ignore event
			return State.ignored;
		}

		if (event.release && this.pressedIndex != idx) {
			// releasing any key when the pressed button is not the focused one
			this.clearState(State.pressed);
			return State.ignored;
		}

		View view = this.items[idx].view;
		State state = view.onKeyEvent(view, event);
		if (state == State.clicked) {
			this.clearState(State.pressed);
			return state;
		}
		if (state == State.pressed) {
			this.pressedIndex = idx;
			return state;
		}

		return state;
	}

	bool onTouchEvent(Layout this, Rect rect!, TouchEvent event!) {
		static int32 findView(Layout this, int32 x, int32 y) {
			for (int i = 0; i < this.itemCount; i += 1) {
				Item item& = this.items[i];
				if (item.view.enabled && item.rect.contains(x, y)) {
					return i;
				}
			}
			return -1;
		}

		if (!this.enabled) {
			// disabled layout does not consume events
			return false;
		}

		bool result = false;
		int active = this.pressedIndex;
		if (!(event.dx || event.dy || event.release) || !event.button) {
			active = findView(this, event.x, event.y);
		}

		if (active < 0) {
			// not an active view
			int32 states = State.hovered;
			if (event.release) {
				states |= State.pressed;
			}
			return this.clearState(states);
		}

		Item item& = this.items[active];
		View view = item.view;
		if (!view.enabled) {
			// not an enabled view
			int32 states = State.hovered;
			if (event.release) {
				states |= State.pressed;
			}
			return this.clearState(states);
		}

		if (this.pressedIndex != active && event.isPress(1)) {
			// pressed a different view, update pressed view
			this.clearState(State.pressed);
			this.pressedIndex = active;
			result = true;
		}

		bool outside = !event.test(item.rect);
		if (this.hoveredIndex != active || outside) {
			// update current view as hovered
			if (this.clearState(State.hovered)) {
				result = true;
			}
			if (!outside) {
				this.hoveredIndex = active;
				result = true;
			}
		}

		if (event.release && outside) {
			// return if released outside the pressed view
			return this.clearState(State.pressed|State.hovered);
		}

		if (view.onTouchEvent(view, item.rect, event)) {
			// event processed by the view
			result = true;
		}

		if (!event.release) {
			return result;
		}

		bool focusable = view.focusable;
		if (outside) {
			focusable = false;
		}
		else if (event.clicks < 0) {
			// do not focus on long press
			this.clearState(State.hovered);
			focusable = false;
		}
		else if (this.focusedIndex == active) {
			// already in focus, do not focus
			focusable = false;
		}
		else if (Layout layout = view.as(Layout)) {
			if (layout.focusedIndex == -1) {
				// child is a layout, with no focused item
				focusable = false;
			}
		}

		if (focusable) {
			this.clearState(State.focused);
			this.focusedIndex = active;
			result = true;
		}
		if (this.clearState(State.pressed)) {
			return true;
		}
		return result;
	}

	bool onMeasure(Layout this, Rect measured&) {
		int32 dir = this.orientation;
		int32 N = Int32.abs(dir);
		int32 n = 0;
		int32 maxWidth = 0;
		int32 sumWidth = 0;
		int32 maxHeight = 0;
		int32 sumHeight = 0;
		int32 rows = dir < 0 ? N : 1;
		int32 cols = dir > 0 ? N : 1;
		for (int i = 0; i < this.itemCount; i += 1) {
			Item item& = this.items[i];
			Rect rect& = item.rect;
			View view = item.view;
			rect.x0 = rect.x1 = 0;
			rect.y0 = rect.y1 = 0;
			if (view.onMeasure(view, &rect)) {
				int32 width = rect.width();
				int32 height = rect.height();
				if (n >= N) {
					cols += int32(dir < 0);
					rows += int32(dir > 0);
					n = 0;
				}
				sumWidth += width;
				if (maxWidth < width) {
					maxWidth = width;
				}
				sumHeight += height;
				if (maxHeight < height) {
					maxHeight = height;
				}
				n += 1;
			}
		}
		if (rows == 1 && cols == 1) {
			sumWidth = maxWidth;
			sumHeight = maxHeight;
		}
		if (rows > 1) {
			// multi row layout, using uniform width
			sumWidth = maxWidth * cols;
		}
		if (cols > 1) {
			// multi column layout, using uniform height
			sumHeight = maxHeight * rows;
		}
		measured.width(sumWidth + this.paddingLeft + this.paddingRight);
		measured.height(sumHeight + this.paddingTop + this.paddingBottom);
		return View.onMeasure(this, &measured);
	}

	// TODO: make layout part of the measure step: to calculate the correct width and height,
	//       elements inside the layout must be placed to their position
	void onLayout(Layout this, Rect measured&) {
		static void verticalLayout(Layout this, Rect measured&, int32 cols) {
			int32 rowSpacing = measured.width() / cols;
			int32 colSpacing = 0;
			int32 grow = 0;

			if (true) {
				int32 maxSize = 0;
				int32 sumSize = 0;
				int32 rows = 0;
				int32 n = cols;
				for (int i = 0; i < this.itemCount; i += 1) {
					Rect rect& = this.items[i].rect;
					if (!rect.empty()) {
						if (n >= cols) {
							sumSize += maxSize;
							maxSize = 0;
							rows += 1;
							n = 0;
						}
						if (maxSize < rect.height()) {
							maxSize = rect.height();
						}
						if (colSpacing < maxSize) {
							colSpacing = maxSize;
						}
						n += 1;
					}
				}
				sumSize += maxSize;
				if (rows > 0 && measured.height() > sumSize) {
					grow = (measured.height() - sumSize) / rows;
				}
			}

			Rect r = {
				x0: measured.x0;
				y0: measured.y0;
				x1: measured.x0 + (this.width > 0 ? this.width : measured.width());
				y1: measured.y0 + (this.height > 0 ? this.height : measured.height());
			};

			int32 n = cols;
			r.translateY(-colSpacing - grow);
			for (int i = 0; i < this.itemCount; i += 1) {
				Item item& = this.items[i];
				Rect rect& = item.rect;
				if (rect.empty()) {
					continue;
				}

				if (n >= cols) {
					r.positionX(measured.x0);
					r.translateY(colSpacing + grow);
					if (cols == 1) {
						// single row, allow non uniform heights
						colSpacing = rect.height();
					//} else {
						// using non uniform heights
						//colSpacing = maxHeight(this, i, cols);
					}
					n = 0;
				}

				r.width(rowSpacing);
				r.height(colSpacing + grow);
				View view = item.view;
				int32 align = item.align;
				if (view.width > 0 && Style.vertical(align)) {
					// fixed width, center instead of stretch
					align &= ~Style.vertical;
				}
				if (view.height > 0 && Style.horizontal(align)) {
					// fixed height, center instead of stretch
					align &= ~Style.horizontal;
				}

				Style.align(r, &rect, align);
				if (Layout layout = view.as(Layout)) {
					layout.onLayout(layout, &rect);
				}

				r.translateX(rowSpacing);
				n += 1;
			}
		}
		static void horizontalLayout(Layout this, Rect measured&, int32 rows) {
			int32 colSpacing = measured.height() / rows;
			int32 rowSpacing = 0;
			int32 grow = 0;

			if (true) {
				int32 maxSize = 0;
				int32 sumSize = 0;
				int32 cols = 0;
				int32 n = rows;
				for (int i = 0; i < this.itemCount; i += 1) {
					Rect rect& = this.items[i].rect;
					if (!rect.empty()) {
						if (n >= rows) {
							sumSize += maxSize;
							maxSize = 0;
							cols += 1;
							n = 0;
						}
						if (maxSize < rect.width()) {
							maxSize = rect.width();
						}
						if (rowSpacing < rect.width()) {
							rowSpacing = rect.width();
						}
						n += 1;
					}
				}
				sumSize += maxSize;
				if (cols > 0 && measured.width() > sumSize) {
					grow = (measured.width() - sumSize) / cols;
				}
			}

			Rect r = {
				x0: measured.x0;
				y0: measured.y0;
				x1: measured.x0 + (this.width > 0 ? this.width : measured.width());
				y1: measured.y0 + (this.height > 0 ? this.height : measured.height());
			};

			int32 n = rows;
			r.translateX(-rowSpacing - grow);
			for (int i = 0; i < this.itemCount; i += 1) {
				Item item& = this.items[i];
				Rect rect& = item.rect;
				if (rect.empty()) {
					continue;
				}

				if (n >= rows) {
					r.positionY(measured.y0);
					r.translateX(rowSpacing + grow);
					if (rows == 1) {
						// single column, allow non uniform widths
						rowSpacing = rect.width();
					//} else {
						// using non uniform widths
						//rowSpacing = maxWidth(this, i, rows);
					}
					n = 0;
				}

				r.width(rowSpacing + grow);
				r.height(colSpacing);
				View view = item.view;
				int32 align = item.align;
				if (view.width > 0 && Style.vertical(align)) {
					// fixed width, center instead of stretch
					align &= ~Style.vertical;
				}
				if (view.height > 0 && Style.horizontal(align)) {
					// fixed height, center instead of stretch
					align &= ~Style.horizontal;
				}

				Style.align(r, &rect, align);
				if (Layout layout = view.as(Layout)) {
					layout.onLayout(layout, &rect);
				}

				r.translateY(colSpacing);
				n += 1;
			}
		}
		static void addPadding(Layout this, Rect rect&, int32 multiplier) {
			rect.x0 -= multiplier * this.paddingLeft;
			rect.y0 -= multiplier * this.paddingTop;
			rect.x1 += multiplier * this.paddingRight;
			rect.y1 += multiplier * this.paddingBottom;
		}

		this.addPadding(&measured, -1);
		if (this.orientation > 0) {
			/* Multi column vertical layout, ex 3 cols:
			/--- col0 ---+--- col1 ---+--- col2 ---\
			|   item00   |   item01   |   item02   | row0
			|   item03   |   item04   |            | row1
			.    ...     |    ...     |    ...     . rowN
			\------------+------------+-----------*/
			verticalLayout(this, &measured, this.orientation);
			this.addPadding(&measured, 1);
			return;
			//return verticalLayout(this, &measured, this.orientation);
		}
		if (this.orientation < 0) {
			/* multi row horizontal layout, ex 2 rows:
			/--- col0 ---+--- col1 ---+--- col2 ---+--- colN ---\
			|   item00   |   item02   |   item04   |    ...     | row0
			|   item01   |   item03   |    ...     |    ...     | row1
			\------------+------------+------------+--- ... ---*/
			horizontalLayout(this, &measured, -this.orientation);
			this.addPadding(&measured, 1);
			return;
			//return horizontalLayout(this, &measured, -this.orientation);
		}

		Rect r = {
			x0: measured.x0;
			y0: measured.y0;
			x1: measured.x0 + (this.width > 0 ? this.width : measured.width());
			y1: measured.y0 + (this.height > 0 ? this.height : measured.height());
		};

		for (int i = 0; i < this.itemCount; i += 1) {
			Item item& = this.items[i];
			Rect rect& = item.rect;
			if (rect.empty()) {
				continue;
			}

			View view& = item.view;
			Style.align(measured, &rect, item.align);
			if (Layout layout = view.as(Layout)) {
				layout.onLayout(layout, &rect);
			}
		}
		this.addPadding(&measured, 1);
	}

	void onDraw(Layout this, Image offs, Rect parent) {
		for (int i = 0; i < this.itemCount; i += 1) {
			Item item! = this.items[i];
			Rect rect! = item.rect;
			if (rect.empty()) {
				continue;
			}

			View view! = item.view;
			int32 state = 0;
			if (view.as(Layout) == null) {
				if (i == this.hoveredIndex) {
					state |= State.hovered;
				}
				if (i == this.pressedIndex) {
					state |= State.pressed;
				}
				if (i == this.focusedIndex) {
					state |= State.focused;
				}
			}
			view.onDraw(offs, rect, state);
		}
	}

	/// Create a custom Layout containing the given `items` all of them aligned as `alignment`
	static Layout Custom(int32 rowsCols, int32 alignment, View items?...) {
		Layout layout = {
			orientation: rowsCols;
		};
		if (items.length > 0) {
			layout.addItems(alignment, ...items);
		}
		return layout;
	}

	/// Create a Row-layout containing the given `items` arranged vertically in a single row
	static Layout Row(View items?...) {
		return Custom(-1, Style.fill, ...items);
	}

	/// Create a Column-layout containing the given `items` arranged horizontally in a single column
	static Layout Column(View items?...) {
		return Custom(1, Style.fill, ...items);
	}

	/// Create a Stack-layout containing the given `items` stacked on top of each other
	static Layout Stack(View items?...) {
		return Custom(0, Style.fill, ...items);
	}
}

/** Widget is a special kind of layout, which can clip the content of its elements.
 * a widget may clip its children and apply scrolling to them, even show a scrollbar.
 */
struct Widget: Layout {
	/// the default style used for widgets
	static Style defaultStyle! = {
		align: Style.left;
	};

	bool measure = true;	// force layout
	bool redraw = true;		// force redraw
	View focus? = null;

	int32 scrollX = 0;
	int32 scrollY = 0;

	static bool focusNext(View view&, bool prev) {
		if (view == null) {
			// probably a separator
			return false;
		}
		if (!view.enabled) {
			// can not focus a disabled view
			return false;
		}
		if (!view.focusable) {
			// can not focus a non focusable view
			return false;
		}

		Layout this& = view.as(Layout);
		if (this == null) {
			// view is not a layout, and is focusable
			return true;
		}

		int n = this.focusedIndex;
		if (prev) {
			if (n < 0) {
				n = this.itemCount - 1;
			}
			for (int i = n; i >= 0; i -= 1) {
				Item item& = this.items[i];
				Rect rect& = item.rect;
				View view& = item.view;
				if (!rect.empty() && focusNext(&view, prev)) {
					if (view.as(Layout) != null || i != this.focusedIndex) {
						this.focusedIndex = i;
						return true;
					}
				}
			}
		} else {
			if (n < 0) {
				n = 0;
			}
			for (int i = n; i < this.itemCount; i += 1) {
				Item item& = this.items[i];
				Rect rect& = item.rect;
				View view& = item.view;
				if (!rect.empty() && focusNext(&view, prev)) {
					if (view.as(Layout) != null || i > this.focusedIndex) {
						this.focusedIndex = i;
						return true;
					}
				}
			}
		}

		this.clearState(State.focused);
		return false;
	}

	/// Append the given `views` to `this` widget with the given `alignment`
	static Widget addItems(Widget this, int32 align, View views?...) {
		Layout.addItems(this, align, ...views);
		return this;
	}

	/// Append the given `views` to `this` widget
	static Widget addItems(Widget this&, View views?...) {
		Layout.addItems(this, Style.fill, ...views);
		return this;
	}

	/// Set the initial focused wie in the widget
	static Widget focus(Widget this&, View value) {
		this.focus = value;
		return this;
	}

	/// Set the padding of `this` widget to the given values
	static Layout padding(Layout this, int32 top, int32 left, int32 right, int32 bottom) {
		Layout.padding(this, top, left, right, bottom);
		return this;
	}

	/// Set the padding of `this` widget to the given values
	static Layout padding(Widget this, int32 vertical, int32 horizontal) {
		Layout.padding(this, vertical, horizontal, horizontal, vertical);
		return this;
	}

	/// Set the padding of `this` widget to the given value
	static Widget padding(Widget this, int32 padding) {
		Layout.padding(this, padding, padding, padding, padding);
		return this;
	}

	void onCreate(Widget this&, View parent) {
		Layout.onCreate(this, parent);
		this.measure = true;

		if (this.focus != null) {
			View notNull = pointer(this.focus);
			notNull.focus();
			this.focus = null;
		}
	}

	// TODO: make layout part of the measure step: to calculate the correct width and height,
	//       elements inside the layout must be placed to their position
	bool onMeasure(Widget this, Rect measured&) {
		Layout.onMeasure(this, &measured);
		this.onLayout(this, &measured);
		return true;
	}

	void onDraw(Widget this, Image offs, Rect rect) {
		offs.fillRect(rect, this.style.backgroundColor);
		Layout.onDraw(this, offs, rect);
	}
}

/// Return the root widget of the given `view`
Widget getWidget(View view) {
	for (View v& = view; v != null; v = v.parent) {
		if (Widget w = v.as(Widget)) {
			return w;
		}
		// todo: check for cycles (indirect)
		assert(v != v.parent);
	}
	return null;
}

/// Set the given `view` focused
void focus(View view) {
	static void clearFocus(Layout layout) {
		for (int i = 0; i < layout.itemCount; i += 1) {
			View view = layout.items[i].view;
			if (Layout child = view.as(Layout)) {
				clearFocus(child);
			}
		}
		layout.hoveredIndex = -1;
		layout.pressedIndex = -1;
		layout.focusedIndex = -1;
	}
	Widget widget = getWidget(view);

	Layout layout = view.as(Layout);
	if (layout == null) {
		// the view is a leaf node, focus it
		widget.clearFocus();
		widget.setFocused(view);
		return;
	}

	View focus = layout.getFocused();
	if (focus != null) {
		// the layout has a focused element, focus it
		widget.clearFocus();
		widget.setFocused(focus);
		return;
	}

	Rect rect = {};
	// focus the first visible element from the layout
	widget.onMeasure(widget, &rect);
	widget.clearFocus();
	widget.setFocused(view);
	widget.focusNext(false);
	widget.measure = true;
}
/// Returns weather the given `view` is in focused state or not.
bool isFocused(View view) {
	Widget widget = getWidget(view);
	return view == widget.getFocused();
}
///@public
bool hasFocused(Layout this, View items...) {
	if (this.focusedIndex < 0) {
		// nothing is focused.
		return false;
	}
	if (items.length == 0) {
		// something is focused
		return true;
	}

	View view = this.items[this.focusedIndex].view;
	for (int i = 0; i < items.length; i += 1) {
		if (items[i] == view) {
			return true;
		}
	}

	if (Layout layout = view.as(Layout)) {
		return hasFocused(layout, ...items);
	}
	return false;
}

/// Returns weather the given `view` is in pressed state or not.
bool isPressed(View view) {
	Widget widget = getWidget(view);
	return view == widget.getPressed();
}
///@public
bool hasPressed(Layout this, View items...) {
	if (this.pressedIndex < 0) {
		// nothing is pressed.
		return false;
	}
	if (items.length == 0) {
		// something is pressed
		return true;
	}

	View view = this.items[this.pressedIndex].view;
	for (int i = 0; i < items.length; i += 1) {
		if (items[i] == view) {
			return true;
		}
	}

	if (Layout layout = view.as(Layout)) {
		return hasPressed(layout, ...items);
	}
	return false;
}

/// Invalidate the view, so the next frame it will be redrawn, and measured in case `layout` is set to true
void invalidate(View view, bool layout) {
	Widget widget = getWidget(view);
	widget.measure |= layout;
	widget.redraw = true;
}
/// Invalidate the view, so the next frame it will be measured and redrawn
inline invalidate(View view) = invalidate(view, true);
/// Returns weather the given `view` needs to be measured or not.
bool isDirty(View view) {
	Widget widget = getWidget(view);
	return widget.measure;
}

inline "./micro.ui.button.cmpl";
inline "./micro.ui.slider.cmpl";
inline "./micro.ui.switch.cmpl";
inline "./micro.ui.window.cmpl";

inline "./micro.ui.panel.cmpl";
inline "./micro.ui.debug.cmpl";
inline "./micro.ui.histo.cmpl";

inline "./micro.ui.widget.fx.cmpl";
/// debug view to count draws
struct DebugView: View {
	char text[64] = null;

	int64 durations[32];
	int64 started = 0;
	int position = 0;

	/// Number of measures, initialize to `-1` to ignore
	int64 measures = 0;
	/// Number of draw calls, initialize to `-1` to ignore
	int64 draws = 0;

	/// Start time measurement until this view is drawn on screen
	static void restartTimer(DebugView this&) {
		this.durations[this.position] = 0;
		this.started = System.millis();
	}

	/// Start time measurement until this view is drawn on screen
	static void startTimer(DebugView this&) {
		if (this.started == 0) {
			restartTimer(this);
		}
	}

	static void update(DebugView this) {
		int pos = 0;
		if (this.measures > 0) {
			if (pos > 0) {
				pos = this.text.append(pos, ", ");
			}
			pos = this.measures.format(this.text, pos, "measures: %d");
		}

		if (this.draws > 0) {
			if (pos > 0) {
				pos = this.text.append(pos, ", ");
			}
			pos = this.draws.format(this.text, pos, "draws: %d");
		}

		int64 value = this.durations[this.position];
		if (this.started > 0) {
			if (pos > 0) {
				pos = this.text.append(pos, ", ");
			}
			pos = value.format(this.text, pos, "time: %d ms");
		}
	}

	bool onClick(DebugView this&) {
		return this.onReset(this);
	}

	bool onReset(DebugView this&) {
		if (this.measures > 0) {
			this.measures = 0;
		}
		if (this.draws > 0) {
			this.draws = 0;
		}
		for (int i = 0; i < this.durations.length; i += 1) {
			this.durations[i] = 0;
		}
		this.position = 0;
		this.started = 0;
		return true;
	}

	void onCreate(DebugView this&, View parent) {
		View.onCreate(this, parent);
		DebugView.onReset(&this);
	}

	bool onMeasure(DebugView this, Rect rect&) {
		if (this.measures >= 0) {
			this.measures += 1;
		}
		this.update();
		Style style& = this.style;
		style.measure(&rect, this.text);
		if (rect.width() < this.durations.length) {
			rect.width(this.durations.length);
		}
		return View.onMeasure(this, &rect);
	}

	void onDraw(DebugView this, Image offs, Rect rect) {
		DebugView mutable& = pointer(this);
		int64 duration = 0;
		if (mutable.started > 0) {
			duration = System.millis() - mutable.started;
			mutable.durations[this.position] = duration;
			this.update();
			mutable.started = 0;
			this.position += 1;
			this.position %= this.durations.length;
		}
		for (int i = 0; i < mutable.durations.length; i += 1) {
			if (duration < mutable.durations[i]) {
				duration = mutable.durations[i];
			}
		}

		Style style& = mutable.style;
		int32 y0 = rect.y1;
		float64 ys = duration == 0 ? 0 : rect.height() / float64(duration);
		float64 xs = rect.width() / float64(mutable.durations.length);
		for (int i = 0; i < mutable.durations.length; i += 1) {
			int idx = (this.position + i) % mutable.durations.length;
			int64 value = mutable.durations[idx];
			int32 y1 = y0 - ys * value;
			int32 x1 = rect.x0 + xs * i;
			offs.fillRect(x1 + xs, y0, x1, y1, style.focusedColor);
		}

		if (mutable.draws >= 0) {
			mutable.draws += 1;
		}
		mutable.update();
		style.align(rect, &rect, mutable.text);
		offs.drawText(rect, style.font, mutable.text, style.textColor);
	}
}
///@public
struct Histogram: View {
	/// display lines instead of bars
	bool lines = false;

	///@public
	bool color = false;

	///@public
	argb data[256];

	/// update the histogram computed from the given image
	static void update(Histogram this&, Image image) {
		uint32 data[*] = pointer(this.data);
		image.calcRgbHist(null, &data);
		this.color = false;
	}

	/// update the histogram value at the given lookup table index
	bool onUpdate(Histogram this&, int32 idx, argb value) {
		if (this.data[idx].v == value.v) {
			return this.isDirty();
		}

		// using custom luminosity value
		this.data[idx] = value;
		return true;
	}

	bool onReset(Histogram this&) {
		bool result = false;
		for (int32 i = 0; i < 256; i += 1) {
			result |= Histogram.onUpdate(this, i, argb(i, i, i, i));
		}
		return result;
	}

	void onCreate(Histogram this&, View parent) {
		View.onCreate(this, parent);
		Histogram.onReset(this);
	}

	bool onTouchEvent(Histogram this, Rect rect!, TouchEvent event!) {
		if (event.release || !event.button) {
			return View.onTouchEvent(this, rect, event);
		}

		int32 px = Int32.max(0, rect.width() - 256) / 2;
		int32 x0 = event.x - rect.x0 - px;
		int32 x1 = x0 - event.dx;
		int32 y0 = event.y - rect.y0;
		int32 y1 = y0 - event.dy;

		if (x0 > x1) {
			int32 x = x0;
			x0 = x1;
			x1 = x;
			int32 y = y0;
			y0 = y1;
			y1 = y;
		}
		int32 y = y0 << 16;
		int32 dy = y1 - y0;
		if (x1 != x0) {
			dy = (dy << 16) / (x1 - x0);
		}
		if (x0 < 0) {
			y -= x0 * dy;
			x0 = 0;
		}
		if (x1 > 256) {
			x1 = 256;
		}
		int32 h = rect.height();
		for (int32 x = x0; x < x1; x += 1) {
			int32 val = 255 * (h - (y >> 16)) / h;
			this.onUpdate(this, x, argb(val, val, val, val));
			y += dy;
		}
		return true;
	}

	bool onMeasure(Histogram this, Rect rect&) {
		if (this.width < 0) {
			rect.width(256);
		}
		if (this.height < 0) {
			rect.height(128);
		}
		return View.onMeasure(this, &rect);
	}

	void onDraw(Histogram this, Image offs, Rect rect) {
		enum {
			colB: 0x4371c6;
			colG: 0x72d874;
			colR: 0xfc6165;
			colL: 0xdadada;
		}
		static argb cols[8] = {
			/*0b000*/ argb(0),
			/*0b001*/ argb(colB),
			/*0b010*/ argb(colG),
			/*0b011*/ mix_rgb8(127, argb(colB), argb(colG)),
			/*0b100*/ argb(colR),
			/*0b101*/ mix_rgb8(127, argb(colR), argb(colB)),
			/*0b110*/ mix_rgb8(127, argb(colR), argb(colG)),
			/*0b111*/ argb(colL)
		};
		int32 px = (rect.width() - 256) / 2;
		int32 h = rect.height();
		if (this.lines) {
			int32 y = rect.y1;
			int32 pb = bch(this.data[0]) * h / 256;
			int32 pg = gch(this.data[0]) * h / 256;
			int32 pr = rch(this.data[0]) * h / 256;
			int32 pl = ach(this.data[0]) * h / 256;

			for (int i = 1; i < this.data.length; i += 1) {
				int32 x = rect.x0 + i + px;
				argb data = this.data[i];
				int32 bv = bch(data) * h / 256;
				int32 gv = gch(data) * h / 256;
				int32 rv = rch(data) * h / 256;
				int32 lv = ach(data) * h / 256;

				if (this.color) {
					offs.fillRect(x, y - pl, x + 1, y - lv + int32(pl == lv), data.v);
				} else {
					offs.fillRect(x, y - pb, x + 1, y - bv + int32(pb == bv), colB);
					offs.fillRect(x, y - pg, x + 1, y - gv + int32(pg == gv), colG);
					offs.fillRect(x, y - pr, x + 1, y - rv + int32(pr == rv), colR);
					offs.fillRect(x, y - pl, x + 1, y - lv + int32(pl == lv), colL);
				}

				pb = bv;
				pg = gv;
				pr = rv;
				pl = lv;
			}
		}
		else if (this.color) {
			for (int i = 0; i < this.data.length; i += 1) {
				argb data = this.data[i];
				int32 x = rect.x0 + i + px;
				int32 y1 = rect.y1;
				int32 y0 = y1 - ach(data) * h / 256;
				offs.fillRect(x, y0 - int32(y1 == y0), x + 1, y1, uint32(data));
			}
		}
		else {
			for (int i = 0; i < this.data.length; i += 1) {
				int32 x = rect.x0 + i + px;
				argb data = this.data[i];
				int32 bv = bch(data) * h / 256;
				int32 gv = gch(data) * h / 256;
				int32 rv = rch(data) * h / 256;
				int32 lv = ach(data) * h / 256;
				for (int32 y = 0; y < h; y += 1) {
					int idx = (int(y < rv) << 2) | (int(y < gv) << 1) | int(y < bv);
					offs.set(x, h - y + rect.y0 - 1, cols[idx]);
				}
			}
		}
	}
}
///@public
struct Panel: Layout {
	///@public
	bool visible = false;

	///@public
	static bool visible(Panel this, bool value) {
		if (this.visible == value) {
			return false;
		}

		this.visible = value;
		this.invalidate();
		return true;
	}

	bool onMeasure(Panel this, Rect rect&) {
		if (!this.visible) {
			// view is hidden
			rect.setSize(0, 0);
			return false;
		}
		return Layout.onMeasure(this, &rect);
	}
}

// todo this should be a TabPage and/or Accordion
// tab/expand item should be a custom 2 state button
// use a flag to enable multi selection for both TabPage or Accordion
// in case of TabPage the `select button` should be in the tab list
// in case of Accordion the `expand button` should be in the same list with the pages
struct TabPage: Layout {
	Layout tabs? = null;
	Layout active? = null;
	argb background = argb(0);

	void onCreate(TabPage this&, View parent) {
		Layout.onCreate(this, parent);
		this.active = this.items[1].view;
		Style style&  = this.style;
		this.background = mix_rgb8(128, argb(style.backgroundColor), argb(style.hoveredColor));
	}

	static bool onMeasurePage(Layout layout, Rect rect&) {
		TabPage parent = layout.data.as(TabPage);
		if (parent != null && parent.active != layout) {
			// view is hidden
			rect.setSize(0, 0);
			return false;
		}
		return Layout.onMeasure(layout, &rect);
	}

	static void onDrawPage(Layout panel, Image offs, Rect rect) {
		TabPage page = panel.data.as(TabPage);
		offs.fillRect(rect, page.background.v);
		Layout.onDraw(panel, offs, rect);
	}

	static void onDrawBar(Layout tabs, Image offs, Rect rect) {
		TabPage page = tabs.data.as(TabPage);
		offs.fillRect(rect, page.background.v);
		Layout.onDraw(tabs, offs, rect);
	}

	static void onDrawTab(Button tab, Image offs, Rect rect) {
		TabPage page = tab.parent.parent.as(TabPage);
		Style style& = tab.style;
		if (page.active == tab.data.as(Layout)) {
			offs.fillRect(rect, style.focusedColor);
			style.align(rect, &rect, tab.text);
			offs.drawText(rect, style.font, tab.text, style.textColor);
			return;
		}
		Button.onDraw(tab, offs, rect);
	}

	static void onDrawSeparator(View this, Image offs, Rect rect) {}

	static bool onClickTab(Button button) {
		if (Layout page = button.data.as(Layout)) {
			if (TabPage tabs& = page.data.as(Layout)) {
				if (tabs.active == page) {
					return false;
				}
				tabs.active = page;
				tabs.invalidate();
				page.focus();
			}
		}
		return true;
	}

	static TabPage addItems(TabPage this&, char text[], int32 align, View views...) {
		inline padding = 1;
		Layout page = {
			data: this;
			// fixme: orientation;
			onDraw: onDrawPage;
			onMeasure: onMeasurePage;
		};
		Button tab = {
			text: text;
			data: page;
			focusable: false;
			onDraw: onDrawTab;
			onClick: onClickTab;
		};

		if (this.tabs == null) {
			Layout tabs = {
				paddingTop: padding;
				paddingLeft: padding;
				paddingRight: padding;
				paddingBottom: padding;
				data: this;
				onDraw: onDrawBar;
				orientation: -this.orientation;
			};

			this.tabs = tabs;
			Layout.addItems(this, Style.center, tabs);
		}

		Layout tabs& = pointer(this.tabs);
		if (tabs.itemCount > 0) {
			// todo: replace separator with rowSpacing and colSpacing
			if (tabs.separator == null) {
				View separator = {
					width: padding;
					height: padding;
					enabled: false;
					focusable: false;
					onDraw: onDrawSeparator;
				};
				tabs.separator = separator;
			}
			tabs.addItems(0, tabs.separator);
		}

		tabs.addItems(0, tab);
		page.addItems(align, ...views);
		Layout.addItems(this, Style.fill, page);
		return this;
	}
}

///@public
struct Select: Layout {
	///@public
	char text[];
	char states[][2]; // fixme: initialize: = {"<", "^"};

	Button selected = null;
	Switch header = null;
	Panel panel = null;

	///@public
	static variant selectedData(Select this) {
		if (this.selected == null) {
			return null;
		}
		return this.selected.data;
	}

	static bool expand(Select this, bool value) {
		// focus the selected option
		if (value && this.selected != null) {
			this.selected.focus();
		} else {
			this.header.focus();
		}

		this.header.onUpdate(int32(value));
		this.panel.visible(value);
		this.invalidate();
		return true;
	}

	static bool onItemClick(Select this&, Button view) {
		this.selected = view;
		this.expand(false);
		this.states[0] = view.text;
		return true;
	}

	///@public
	static Select setSelectedIndex(Select this&, int32 index) {
		if (index < 0 || index > this.panel.itemCount) {
			error("invalid index selected", index);
			return this;
		}
		Button button = this.panel.items[index].view.as(Button);
		if (button == null) {
			return this;
		}

		this.selected = button;
		this.states[0] = button.text;
		return this;
	}

	///@public
	static Select addItems(Select this&, int32 align, View views...) {
		struct Header: Switch {
			Select select;
			bool onReset(Header this) {
				return false;
			}
			bool onClick(Header this) {
				if (!Switch.onClick(this)) {
					return false;
				}
				this.select.expand(this.selected != 0);
				return true;
			}
		}
		if (this.itemCount == 0) {
			Header header = {
				text: this.text;
				states: this.states;
				clickToFocus: false;
				select: this;
			};
			Panel panel = {};

			this.states[0] = "<";
			this.states[1] = "^";
			this.header = header;
			this.panel = panel;

			int type = this.orientation;
			panel.orientation = type;
			this.orientation = Int32.sign(type);

			Layout.addItems(this, align, header, panel);
		}

		Layout.addItems(this.panel, align, ...views);
		return this;
	}

	///@public
	static Select addItem(Select this, char text[], variant data) {
		struct SelectItem: Button {
			Select select;
			bool onClick(SelectItem this) {
				return this.select.onItemClick(this);
			}
		}
		SelectItem item = {
			select: this;
			text: text;
			data: data;
		};
		Select.addItems(this, Style.fill, item);
		return this;
	}

	///@public
	static Select addItem(Select this, char text[]) {
		return addItem(this, text, text);
	}
}
///@public
struct Slider: View {
	///@public
	char text[];

	///@public
	float64 value = 0;
	float64 _value = 0;
	///@public
	float64 minimum = 0;
	///@public
	float64 maximum = 1;
	///@public
	float64 stepSize = 0;
	///@public
	float64 shiftFactor = 1. / 20; // holding the shift key slide twenty times slower
	float64 resetValue = 0;

	/// clicking on a non focused view will not update the value, it will just focus it.
	bool clickToFocus = true;

	///@public
	bool onUpdate(Slider this, float64 value) {
		if (value > this.maximum) {
			value = this.maximum;
		}
		if (value < this.minimum) {
			value = this.minimum;
		}
		this._value = value;
		if (this.stepSize != 0) {
			value = Float64.round(value / this.stepSize) * this.stepSize;
		}
		if (this.value == value) {
			return this.isDirty();
		}
		this.value = value;
		return true;
	}

	bool onReset(Slider this) {
		return this.onUpdate(this, this.resetValue);
	}

	bool onClick(Slider this) {
		return this.onUpdate(this, this.resetValue);
	}

	void onCreate(Slider this&, View parent) {
		View.onCreate(this, parent);
		// clamp to initial value and force update with a reset
		Slider.onUpdate(this, this.value);
		this.resetValue = this.value;
		this.onReset(this);
	}

	State onKeyEvent(Slider this, KeyEvent event!) {
		if (event.key >= '0' && event.key <= '9') {
			// set percent
			if (this.minimum == this.maximum) {
				return State.ignored;
			}
			if (!event.release) {
				return State.pressed;
			}
			float64 p = (event.key - '0') * (this.maximum - this.minimum) / 10;
			this.onUpdate(this, this.minimum + p);
			return State.consumed;
		}

		// +/- =>
		if (event.key == '+' || event.key == '=') {
			// todo: event.key == Window.KEY_CODE_RIGHT, UP, PAGE_UP, ???
			if (event.release) {
				return State.consumed;
			}

			float64 delta = this.maximum - this.minimum;
			if (event.isCtrl) {
				delta = 1;
			} else {
				if (Float64.isFinite(delta)) {
					delta *= this.shiftFactor;
				} else {
					delta = 1 / this.shiftFactor;
				}
			}

			if (event.isShift && this.shiftFactor < 1) {
				delta *= this.shiftFactor;
			}
			if (delta < this.stepSize) {
				delta = this.stepSize;
			}

			if (!this.onUpdate(this, this._value + delta)) {
				return State.pressed;
			}
			return State.consumed;
		}
		if (event.key == '-' || event.key == '_') {
			// todo: event.key == Window.KEY_CODE_LEFT, DOWN, PAGE_DOWN
			if (event.release) {
				return State.consumed;
			}

			float64 delta = this.maximum - this.minimum;
			if (event.isCtrl) {
				delta = 1;
			} else {
				if (Float64.isFinite(delta)) {
					delta *= this.shiftFactor;
				} else {
					delta = 1 / this.shiftFactor;
				}
			}

			if (event.isShift && this.shiftFactor < 1) {
				delta *= this.shiftFactor;
			}
			if (delta < this.stepSize) {
				delta = this.stepSize;
			}

			if (!this.onUpdate(this, this._value - delta)) {
				return State.pressed;
			}
			return State.consumed;
		}
		return View.onKeyEvent(this, event);
	}

	bool onTouchEvent(Slider this, Rect rect!, TouchEvent event!) {
		if (event.button == 0) {
			return false;
		}
		if (event.release && (event.clicks < 0 || event.clicks > 1)) {
			return this.onReset(this);
		}

		if (event.clicks < 1) {
			float64 delta = event.dx * (this.maximum - this.minimum) / rect.width();
			if (!Float64.isFinite(delta)) {
				delta = event.dx / this.shiftFactor;
			} else if (event.isShift) {
				delta *= this.shiftFactor;
			}
			return this.onUpdate(this, this._value + delta);
		}
		if (event.release) {
			if (this.focusable && this.clickToFocus) {
				if (!this.isFocused()) {
					return true;
				}
			}
			if (Float64.isFinite(this.minimum) && Float64.isFinite(this.maximum)) {
				float64 value = event.x - rect.x0;
				value *= float64(this.maximum - this.minimum) / rect.width();
				return this.onUpdate(this, this.minimum + value);
			}
			return true;
		}
		return View.onTouchEvent(this, rect, event);
	}

	bool onMeasure(Slider this, Rect rect&) {
		char value[64] = {...};
		Style style! = this.style;
		if (this.stepSize != 0 && this.stepSize % 1 == 0) {
			style.format.format(value, 0, int64(this.value));
		} else {
			style.format.format(value, 0, this.value);
		}
		Rect valueRect = {};
		style.measure(&valueRect, value);
		style.measure(&rect, this.text);
		rect.width(rect.width() + valueRect.width());
		return View.onMeasure(this, &rect);
	}

	///@public
	void onDrawSlider(Slider this, Image offs, Rect rect) {
		if (!Float64.isFinite(this.maximum) || !Float64.isFinite(this.minimum)) {
			// no slider for infinite or undefined bounds
			return;
		}
		if (this.maximum == this.minimum) {
			return;
		}
		Style style& = this.style;
		int32 y1 = rect.y1;
		int32 y0 = y1 - style.padding / 4;
		int32 x0 = rect.x0;
		int32 x1 = rect.x1;
		int32 x = x0 + (this.value - this.minimum) * rect.width() / (this.maximum - this.minimum);
		if (x > x0) {
			offs.fillRect(x0, y0, x, y1, style.valueColor);
		}
		if (x < x1) {
			offs.fillRect(x, y0, x1, y1, style.focusedColor);
		}
	}

	void onDraw(Slider this, Image offs, Rect rect) {
		char value[64] = {...};
		if (this.stepSize != 0 && this.stepSize % 1 == 0) {
			this.style.format.format(value, 0, int64(this.value));
		} else {
			this.style.format.format(value, 0, this.value);
		}
		if (this.onDrawSlider != null) {
			this.onDrawSlider(this, offs, rect);
		}
		View.onDraw(this, offs, rect, this.text, value);
	}
}
///@public
struct Switch: View {
	static char onOff[][] = {
		"off",
		"on"
	};

	///@public
	char text[];
	///@public
	char states[][] = onOff;

	///@public
	int selected = 0;
	int resetValue = 0;

	/// clicking on a non focused view will not change the value, it will just focus it.
	bool clickToFocus = false;

	/// update the selected value of this switch
	bool onUpdate(Switch this, int selected) {
		int maxValue = this.states.length;
		if (maxValue == 0) {
			// graphical switch
			maxValue = 2;
		}
		if (selected >= maxValue) {
			selected = maxValue - 1;
		}
		else if (selected < 0) {
			selected = 0;
		}

		if (this.selected == selected) {
			return this.isDirty();
		}

		this.selected = selected;
		return true;
	}

	bool onReset(Switch this) {
		return this.onUpdate(this, this.resetValue);
	}

	bool onClick(Switch this) {
		if (this.focusable && this.clickToFocus) {
			if (!this.isFocused()) {
				return true;
			}
		}
		int maxValue = this.states.length;
		int value = this.selected + 1;
		if (maxValue == 0) {
			// graphical switch
			maxValue = 2;
		}
		if (value >= maxValue) {
			value = 0;
		}
		return this.onUpdate(this, value);
	}

	void onCreate(Switch this&, View parent) {
		View.onCreate(this, parent);
		// clamp to initial value and force update with a reset
		Switch.onUpdate(this, this.selected);
		this.resetValue = this.selected;
		this.onReset(this);
	}

	State onKeyEvent(Switch this, KeyEvent event!) {
		if (!this.enabled || event.release) {
			return View.onKeyEvent(this, event);
		}
		if (event.key == '+' || event.key == '=') {
			int value = this.selected + 1;
			return this.onUpdate(this, value);
		}
		if (event.key == '-' || event.key == '_') {
			int value = this.selected - 1;
			return this.onUpdate(this, value);
		}
		return View.onKeyEvent(this, event);
	}

	bool onTouchEvent(Switch this, Rect rect!, TouchEvent event!) {
		if (!this.enabled || !event.release) {
			return View.onTouchEvent(this, rect, event);
		}
		if (event.isShift && event.clicks >= 0) {
			int value = this.selected - 1;
			return this.onUpdate(this, value);
		}
		return View.onTouchEvent(this, rect, event);
	}

	bool onMeasure(Switch this, Rect rect&) {
		int32 maxWidth = 0;
		Style style& = this.style;
		for (int i = 0; i < this.states.length; i += 1) {
			Rect measured = {};
			style.measure(&measured, this.states[i]);
			if (maxWidth < measured.width()) {
				maxWidth = measured.width();
			}
		}
		style.measure(&rect, this.text);
		if (this.states.length == 0) {
			rect.width(rect.width() + rect.height() * 3 / 2);
		} else {
			rect.width(rect.width() + maxWidth);
		}
		return View.onMeasure(this, &rect);
	}

	void onDraw(Switch this, Image offs, Rect rect) {
		char value[] = null;
		Style style& = this.style;
		if (this.states.length == 0) {
			Rect onOffRect = {
				x0: rect.x0;
				y0: rect.y0;
				x1: rect.x0 + rect.height() * 3 / 2;
				y1: rect.y1;
			};
			Style.align(rect, &onOffRect, Style.right);
			rect.x1 = onOffRect.x0;

			onOffRect.padded(-style.padding);
			uint32 color = style.focusedColor;
			if (this.selected != 0) {
				color = style.valueColor;
			}
			else if (this.isFocused()) {
				color = style.hoveredColor;
			}
			offs.fillRRect(onOffRect, onOffRect.height() / 2, color);

			if (this.selected != 0) {
				onOffRect.x0 = onOffRect.x1 - onOffRect.height();
			} else {
				onOffRect.x1 = onOffRect.x0 + onOffRect.height();
			}

			onOffRect.padded(-style.padding / 3);
			offs.fillOval(onOffRect, style.textColor);
		} else {
			value = this.states[this.selected];
		}
		View.onDraw(this, offs, rect, this.text, value);
	}
}
/// Widget used to display controls in image processing demos
struct FxWidget: Widget {
	///@public
	bool showOriginal = false;
	///@public
	int32 align = Style.fill;
	///@public
	int32 margin = 0;
	///@public
	int32 radius = 0;

	// forward the drag event to the focused view
	bool onTouchEvent(FxWidget this, Rect rect!, TouchEvent event!) {
		if (Widget.onTouchEvent(this, rect, event)) {
			return true;
		}

		if (!(event.button && (event.dx || event.dy))) {
			// event is not a drag event
			return false;
		}

		if (this.pressedIndex != -1) {
			// there is a pressed view, and is different than the focused one
			return false;
		}

		View view = Widget.getFocused(this);
		if (view == null) {
			// there is no focused view
			return false;
		}
		Layout parent = view.parent.as(Layout);
		Rect r& = parent.items[parent.focusedIndex].rect;
		// forward the event to the view
		return view.onTouchEvent(view, r, event);
	}

	State onKeyEvent(FxWidget this, KeyEvent event!) {
		if (event.key == '[' || event.key == ']') {
			bool changed = this.showOriginal != event.release;
			this.showOriginal = !event.release && (event.repeat != 0 || !this.enabled);
			// show hide on short press and release
			if (event.repeat != 0 && event.release == this.enabled) {
				// hide on long press, show on long release
				return changed && event.repeat == 1;
			}
			if (event.repeat == 0 && !event.release) {
				// show/hide when button is on released, not when pressed
				return changed;
			}

			this.clearState(State.hovered);
			// hide, show controls
			if (event.key == '[') {
				if (this.align == Style.topLeft) {
					this.enabled = !this.enabled;
					this.invalidate();
					return true;
				}
				this.align = Style.topLeft;
			}
			if (event.key == ']') {
				if (this.align == Style.topRight) {
					this.enabled = !this.enabled;
					this.invalidate();
					return true;
				}
				this.align = Style.topRight;
			}

			this.enabled = true;
			this.invalidate();
			return true;
		}

		if (event.key == '\\') {
			this.showOriginal = !event.release;
			return event.repeat == 0 || event.release;
		}

		if (event.release) {
			return Widget.onKeyEvent(this, event);
		}

		if (event.key == Window.KEY_CODE_BACK && event.isShift) {
			return this.onReset(this);
		}

		return Widget.onKeyEvent(this, event);
	}

	bool onMeasure(FxWidget this, Rect measured&) {
		int32 margin = this.margin;
		int32 align = this.align;
		Rect rect = {
			x0: margin;
			y0: margin;
			x1: measured.width() - margin;
			y1: measured.height() - margin;
		};

		measured.x1 = measured.x0 = 0;
		measured.y1 = measured.y0 = 0;
		Layout.onMeasure(this, &measured);
		this.onLayout(this, &measured);
		Style.align(rect, &measured, align);
		return true;
	}

	void onDraw(FxWidget this, Image offs, Rect rect) {
		offs = offs.slice(rect);
		Style style& = this.style;
		if (style.backgroundColor != -1) {
			Rect r = { x0: 0, y0: 0, x1: offs.width(), y1: offs.height() };
			offs.fillRRect(r, this.radius, style.backgroundColor);
		}
		Widget.onDraw(this, offs, rect);
		offs.destroy();
	}

	/// returns true if the widget needs to show the original image
	static bool showOriginal(Widget anyWidget) {
		if (FxWidget widget = anyWidget.as(FxWidget)) {
			return widget.showOriginal;
		}
		return false;
	}
}

/// Create a widget with the given `width`, `height` and `style`
Widget Widget(int32 width, int32 height, Style style!) {
	Widget widget = {
		width: width;
		height: height;
		style: style;
	};
	return widget.focus(widget);	// focus first visible view
}

/// Create a widget with the given `width`, `height` and a default style
Widget Widget(int32 width, int32 height) {
	return Widget(width, height, Widget.defaultStyle);
}
/// Create a widget with the given `views` used in image processing demos
FxWidget FxWidget(View views?...) {
	FxWidget widget = {
		radius: 5;
		margin: 10;
		align: Style.topRight;
		style: Widget.defaultStyle;

		paddingTop: 3;
		paddingLeft: 3;
		paddingRight: 3;
		paddingBottom: 3;
	};

	return widget
		.focus(widget)	// focus first visible view
		.addItems(...views);
}
///@public
static struct Window {
	/// events with action having this bit set, were processed by the widget
	inline EVENT_PROCESSED = 1 << 16;

	/// Show the given `widget` in a window drawn to the `offscreen` image
	static void show(Image offscreen, int32 onEvent(int32 action, int32 button, int32 x, int32 y), Widget widget) {
		struct WindowData {
			Image offscreen;
			int32 onEvent(int32 action, int32 button, int32 x, int32 y);
			Widget widget;
			Rect rect;

			int64 timeout = 0;

			// Touch state
			int32 clicks = 0;
			int64 time = 0;
			int32 button = 0;
			int32 lastX = 0;
			int32 lastY = 0;

			// Keyboard state
			bool isShift = false;
			bool isCtrl = false;
			bool isAlt = false;
			int32 key = 0;
			int32 repeat = 0;
		}

		static bool dispatchEvent(WindowData window&, Widget widget, int32 action, int32 button, int32 x, int32 y) {
			if (widget.parent == null) {
				// widget was not created, so create it first
				widget.onCreate(widget, widget);
			}
			if (action == Window.WINDOW_INIT) {
				return true;
			}
			if (action == Window.WINDOW_CLOSE) {
				// TODO: implement reference counted gc
				widget.onDestroy(widget);
				widget.destroy();
				return false;
			}
			if (action == Window.WINDOW_ENTER) {
				// do not process event
				return false;
			}
			if (action == Window.WINDOW_LEAVE) {
				// clear hovered state
				return widget.clearState(View.State.hovered);
			}

			if (action == Window.MOUSE_PRESS) {
				if (window.button != button || window.lastX != x || window.lastY != y) {
					window.clicks = 0;
				}
				int64 now = System.millis();
				if ((now - window.time) / 1000. > .5) {
					window.clicks = 0;
				}
				window.time = now;
				if (button == 1) {
					window.timeout = now + 1000;
				} else {
					window.timeout = 0;
				}
				window.button = button;
				window.lastX = x;
				window.lastY = y;
				window.clicks += 1;

				if (button != 1) {
					return false;
				}

				TouchEvent event = {
					release: false;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					clicks: window.clicks;
					button: button;
					x: x - window.rect.x0;
					y: y - window.rect.y0;
				};
				return widget.onTouchEvent(widget, window.rect, event);
			}
			if (action == Window.MOUSE_MOTION) {
				int32 lastX = window.lastX;
				int32 lastY = window.lastY;
				window.time = System.millis();
				window.timeout = 0;
				window.button = button;
				window.lastX = x;
				window.lastY = y;
				window.clicks = 0;

				if (button != 0 && button != 1) {
					return false;
				}
				TouchEvent event = {
					release: false;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					clicks: window.clicks;
					button: button;
					dx: x - lastX;
					dy: y - lastY;
					x: x - window.rect.x0;
					y: y - window.rect.y0;
				};
				return widget.onTouchEvent(widget, window.rect, event);
			}
			if (action == Window.MOUSE_RELEASE) {
				int64 now = System.millis();
				if ((now - window.time) / 1000. > .5) {
					window.clicks = 0;
				}
				window.timeout = 0;
				if (button != 1) {
					return false;
				}

				TouchEvent event = {
					release: true;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					clicks: window.clicks;
					button: button;
					x: x - window.rect.x0;
					y: y - window.rect.y0;
				};
				return widget.onTouchEvent(widget, window.rect, event);
			}

			if (action == Window.KEY_PRESS) {
				window.isShift = (y & Window.KEY_MASK_SHIFT) != 0;
				window.isCtrl = (y & Window.KEY_MASK_CTRL) != 0;
				window.isAlt = (y & Window.KEY_MASK_ALT) != 0;
				if (window.key != button) {
					window.key = button;
					window.repeat = 0;
				} else {
					window.repeat += 1;
				}

				KeyEvent event = {
					release: false;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					repeat: window.repeat;
					key: button;
				};
				int32 r = widget.onKeyEvent(widget, event);
				if (button == Window.KEY_CODE_TAB && r == View.State.ignored) {
					if (!Widget.focusNext(widget, window.isShift)) {
						// focus run out of last focused item
						if (!Widget.focusNext(widget, window.isShift)) {
							// there is no focusable view found
							return false;
						}
					}
					return true;
				}
				return r != View.State.ignored;
			}
			if (action == Window.KEY_RELEASE) {
				window.isShift = (y & Window.KEY_MASK_SHIFT) != 0;
				window.isCtrl = (y & Window.KEY_MASK_CTRL) != 0;
				window.isAlt = (y & Window.KEY_MASK_ALT) != 0;
				KeyEvent event = {
					release: true;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					repeat: window.repeat;
					key: button;
				};
				window.key = 0;
				window.repeat = 0;
				return widget.onKeyEvent(widget, event) != View.State.ignored;
			}

			if (action == Window.EVENT_TIMEOUT) {
				return false;
			}

			debug("event not processed", action);
			return false;
		}

		static int32 draw(WindowData window&, Widget widget) {
			if (!widget.enabled) {
				// widget is disabled, do not show it
				return Window.timeoutMax;
			}
			int64 timeout = Window.timeoutMax;
			if (window.timeout > 0) {
				timeout = window.timeout - System.millis();
				if (timeout < 0) {
					timeout = Window.timeoutMax;
				}
			}

			Image offs = window.offscreen;
			Rect rect& = window.rect;
			if (widget.measure) {
				rect.setSize(offs.width(), offs.height());
				widget.onMeasure(widget, &rect);
				widget.measure = false;
			}

			widget.onDraw(offs, rect, 0);
			widget.redraw = false;
			return timeout;
		}

		static int32 windowEvent(WindowData win&, int32 action, int32 button, int32 x, int32 y) {
			if (action == Window.FINGER_PRESS) {
				// translate to mouse event
				action = Window.MOUSE_PRESS;
				button = 1;
			}
			if (action == Window.FINGER_MOTION) {
				// translate to mouse event
				action = Window.MOUSE_MOTION;
				button = 1;
			}
			if (action == Window.FINGER_RELEASE) {
				// translate to mouse event
				action = Window.MOUSE_RELEASE;
				button = 1;
			}

			Widget widget = win.widget;
			if (win.dispatchEvent(widget, action, button, x, y)) {
				action |= EVENT_PROCESSED;
			}
			int32 timeout = win.onEvent(action, button, x, y);
			win.draw(widget);
			return timeout;
		}

		WindowData window = {
			offscreen: offscreen;
			onEvent: onEvent;
			widget: widget;
			rect: {};
		};
		return Window.show(offscreen, window, pointer(windowEvent));
	}

	/// Show the given `widget` in a window
	static void show(Widget widget) {
		static int32 onEvent(int32 action, int32 button, int32 x, int32 y) {
			if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
				return Window.quit();
			}
			return Window.timeoutMax;
		}
		Rect rect = {};
		widget.onCreate(widget, widget);
		widget.onMeasure(widget, &rect);
		Image offscreen = Image(rect.width(), rect.height(), 32);
		show(offscreen, onEvent, widget);
		offscreen.destroy();
	}
}

/* original design
struct View: object {...}	// garbage collected
struct Text: View {...}
struct Label: View {...}
struct Image: View {...}
struct Check: View {...}	// Switch?
struct Input: View {...}	// single line, multi line
struct Select: View {...}	// ComboBox
struct Slider: View {...}
struct Button: View {...}

struct Panel ~= Layout
struct List: View {...}
struct Grid: View {...}
struct Page: View {...}
struct Window: View {...}

Window window = {
	width: 100;
	height: 100;
	items: {
		Button {
			label: "button1";
			onClick: print("x");
		};
	};
};
window.show();
*/
///@public
static struct Window {
	enum { timeoutMax: (1 << 31) - 1 }

	/// calculate the timeout based on the given fps
	inline timeoutFps(float64 fps) = int64(1000 / fps);

/// Show the given `image` in a window and delegate the events to the `onEvent` callback
void show(Image image, int onEvent(int action, int button, int ex, int ey)) {
	if (onEvent == null) {
		return Window.show(image, null, null);
	}
	static int delegate(int onEvent(int action, int button, int ex, int ey), int action, int button, int ex, int ey) {
		return onEvent(action, button, ex, ey);
	}
	Window.show(image, onEvent, pointer(delegate));
}

/// Show the images in a window clicking on the window will select one of them
void show(int width, int height, Image image0, Image image1, Image image2) {
	struct Data {
		Image offs;
		Image image0;
		Image image1;
		Image image2;
	}

	static int onEvent(pointer extraData, int action, int button, int ex, int ey) {
		Data data& = extraData;
		if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
			// exit when releasing escape key
			return Window.quit();
		}
		if (action == Window.MOUSE_PRESS || action == Window.MOUSE_RELEASE) {
			Image show = data.image0;
			if (action == Window.MOUSE_RELEASE) {
				show = data.image0;
			}
			else if (button == 1) {
				show = data.image1;
			}
			else {
				show = data.image2;
			}
			if (data.offs.width() != show.width() || data.offs.height() != show.height()) {
				data.offs.resize(null, show, null, 1);
			} else {
				data.offs.copy(0, 0, show, null);
			}
		}
		return Window.timeoutMax;
	}

	Image offs = Image(width, height, image0.depth());
	Data data = {
		offs: offs;
		image0: image0;
		image1: image1;
		image2: image2;
	};
	onEvent(data, Window.MOUSE_RELEASE, 0, 0, 0);
	Window.show(offs, data, onEvent);
	offs.destroy();
}

/// Show the images in a window clicking on the window will select one of them
void show(Image image0, Image image1, Image image2) {
	int width = image0.width();
	int height = image0.height();
	return show(width, height, image0, image1, image1);
}

/// Show the images in a window clicking on the window will select one of them
void show(Image image0, Image image1) {
	return show(image0, image1, image1);
}

/// Show the image in a window
void show(Image image) {
	Window.show(image, image, image);
}

/// Show or animate the the procedural image generated by the `eval` function
void show(int32 width, int32 height, int32 animationDownScale, vec4f eval(vec4f in)) {
	static int64 start! = System.millis();
	struct Data {
		vec4f eval(vec4f in);
		Image offs;
		int32 downScale;
		float32 aspect;
		bool animate;
		int32 smooth = 1;
		int32 fpsCount = 0;	// frames drawn
		float32 fpsTime = 0;	// frame per sec shot time
	}

	static int onEvent(pointer extraData, int action, int button, int ex, int ey) {
		if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
			// exit when releasing escape key
			return Window.quit();
		}
		if (action == Window.WINDOW_CLOSE) {
			return Window.quit();
		}

		Data data& = extraData;
		if (action == Window.KEY_RELEASE) {
			if (button == ' ') {
				if (data.animate || data.downScale > 0) {
					data.animate = !data.animate;
				}
				action = Window.WINDOW_INIT;
			}
			else if (button == Window.KEY_CODE_TAB) {
				data.smooth = 1 - data.smooth;
			}
			else if (button == 'S') {
				trace("dumping screen");
				data.offs.saveBmp("out/offs.bmp", 0);
			}
		}
		if (action == Window.WINDOW_INIT && !data.animate) {
			char text[256] = {...};
			int64 now = System.millis();
			float32 time = (now - start) / 1000f;
			data.offs.eval(null, data.aspect, time, data.eval);
			(System.millis() - now).format(text, "Render time: %d ms");
			Window.setTitle(text);
			return Window.timeoutMax;
		}

		if (!data.animate) {
			return Window.timeoutMax;
		}

		float32 time = (System.millis() - start) / 1000f;
		if (data.downScale > 1) {
			Rect r = {
				x1: data.offs.width();
				y1: data.offs.height();
				x0: r.x1 - r.x1 / data.downScale;
				y0: r.y1 - r.y1 / data.downScale;
			};
			data.offs.eval(r, data.aspect, time, data.eval);
			data.offs.resize(null, data.offs, r, data.smooth);
		} else {
			data.offs.eval(null, data.aspect, time, data.eval);
		}
		if (time > data.fpsTime) {
			char text[256] = {...};
			data.fpsCount.format(text, "Fps: %d");
			Window.setTitle(text);
			data.fpsTime = time + 1;
			data.fpsCount = 0;
		}
		data.fpsCount += 1;

		// do not block for any input
		return 0;
	}

	Data data = {
		eval: eval;
		offs: Image(width, height, 32);
		animate: animationDownScale > 0;
		downScale: animationDownScale;
		aspect: width / float32(height);
	};
	Window.show(data.offs, data, onEvent);
	data.offs.destroy();
}

/// Show the the procedural image generated by the `eval` function
void show(int width, int height, vec4f eval(vec4f in)) {
	return show(width, height, 0, eval);
}

/// Show the mesh in a window
void show(int w, int h, float32 fovy, Mesh mesh) {
	struct Data {
		int32 fpsCount = 0;	// frames drawn
		int32 fpsShow = 0;	// frames drawn
		int64 fpsTime = 0;	// frame per sec shot time
		int mode;
		Image offs;
		mat4f proj;
		Camera cam;
		Mesh mesh;

		static void updateCamera(Data this!) {
			Camera camera& = this.cam;
			Mesh.camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
		}
	}

	int nextInc(int32 x, int mask) {
		int next = x & mask;

		// add lowest bit of mask
		next += mask & -mask;

		// avoid overflow
		next &= mask;

		return next | (x & ~mask);
	}
	int nextBit(int32 x, int mask) {
		int next = x & mask;

		if (next == 0) {
			next = mask & -mask;
		} else {
			// add lowest bit of mask
			next = (next + next) & mask;
		}

		return next | (x & ~mask);
	}

	static int onEvent(pointer extraData, int action, int button, int ex, int ey) {
		Data data& = extraData;
		static int ox = 0;
		static int oy = 0;
		static float32 slow! = 1 / 100f;
		static float32 fast! = 5 / 100f;

		if (action == Window.MOUSE_MOTION || action == Window.FINGER_MOTION) {
			Camera camera& = data.cam;
			int dx = ex - ox;
			int dy = ey - oy;

			if (button == 1 || action == Window.FINGER_MOTION) {
				// orbit around the origin: (x: 0, y: 0, z: 0)
				vec4f orbit = vec4f(0, 0, 0);
				camera.rotate(orbit, camera.up, dx * slow);
				camera.rotate(orbit, camera.right, dy * slow);
				data.updateCamera();
			}
			else if (button == 2) {
				// rotate
				vec4f orbit = camera.position;
				camera.rotate(orbit, camera.up, -dx * slow);
				camera.rotate(orbit, camera.right, -dy * slow);
				data.updateCamera();
			}
			else if (button == 3) {
				// move the camera back and forward
				camera.move(camera.forward, dy * slow);
				data.updateCamera();
			}
			else if (button == 4) {
				// pan the camera
				camera.move(camera.right, -dx * slow);
				camera.move(camera.up, dy * slow);
				data.updateCamera();
			}
			ox = ex;
			oy = ey;
		}
		else if (action == Window.MOUSE_PRESS || action == Window.FINGER_PRESS) {
			ox = ex;
			oy = ey;
			return Window.timeoutMax;
		}
		else if (action == Window.GESTURE_SCROLL) {
			Camera camera& = data.cam;
			camera.move(camera.forward, ey * fast);
			data.updateCamera();
		}

		else if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
			// exit when releasing escape key
			return Window.quit();
		}
		else if (action == Window.KEY_PRESS) {
			if (button == Window.KEY_CODE_ENTER) {
				return onEvent(&data, Window.WINDOW_INIT, button, ex, ey);
			}

			else if (button == 'w') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.forward, +(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 's') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.forward, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 'a') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.right, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 'd') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.right, +(shift ? fast : slow));
				data.updateCamera();
			}

			else if (button == Window.KEY_CODE_UP) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.right, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Window.KEY_CODE_DOWN) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.right, +(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Window.KEY_CODE_LEFT) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.up, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Window.KEY_CODE_RIGHT) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.up, +(shift ? fast : slow));
				data.updateCamera();
			}

			else if (button == 'l') {
				data.mode ^= Mesh.useLights;
			}
			else if (button == 'b') {
				data.mode ^= Mesh.drawBounds;
			}
			else if (button >= '0' && button <= '3') {
				int light = button - '0';
				Mesh.lights.enable(light, !Mesh.lights.enabled(light));
			}
			else if (button == 't') {
				data.mode ^= Mesh.useTexture;
			}
			else if (button == '/') {
				data.mode = nextInc(data.mode, Mesh.cullMode);
			}
			else if (button == Window.KEY_CODE_TAB) {
				data.mode = nextBit(data.mode, Mesh.drawMode);
			}
		}

		else if (action == Window.WINDOW_INIT) {
			Mesh.lights.enable(0, true);
			Mesh.lights.position(0, 2., -2., 2.);
			Mesh.lights.ambient(0, .4, .4, .4);
			Mesh.lights.diffuse(0, .8, .8, .8);
			Mesh.lights.specular(0, 1., 1., 1.);
			Mesh.lights.attenuation(0, 1., 0., 0.);

			Mesh.lights.enable(1, false);
			Mesh.lights.position(1, 2., -2., 2.);
			Mesh.lights.ambient(1, .4, .0, .0);
			Mesh.lights.diffuse(1, .8, .0, .0);
			Mesh.lights.specular(1, 1., 1., 1.);
			Mesh.lights.attenuation(1, 1., 0., 0.);

			Mesh.lights.enable(2, false);
			Mesh.lights.position(2, -2, -2, +2);
			Mesh.lights.ambient(2, .0, .4, .0);
			Mesh.lights.diffuse(2, .0, .8, .0);
			Mesh.lights.specular(2, 1., 1., 1.);
			Mesh.lights.attenuation(2, 1., 0., 0.);

			Mesh.lights.enable(3, false);
			Mesh.lights.position(3, -2, +2, +2);
			Mesh.lights.ambient(3, .0, .0, .4);
			Mesh.lights.diffuse(3, .0, .0, .8);
			Mesh.lights.specular(3, 1., 1., 1.);
			Mesh.lights.attenuation(3, 1., 0., 0.);

			Camera camera& = data.cam;
			vec4f eye = {x: 0, y: 0, z: 2, w: 1};
			vec4f at = {x: 0, y: 0, z: 0, w: 1};
			vec4f up = {x: 0, y: 1, z: 0, w: 1};
			data.cam = Camera.lookAt(eye, at, up);
			data.updateCamera();
		}

		int rendered = data.offs.drawMesh(data.mesh, data.mode);

		char text[256] = {...};
		int pos = 0;
		pos = data.mesh.vertices.format(text, pos, "Vertices: %d");
		pos = data.mesh.triangles.format(text, pos, ", Triangles: %d");
		pos = int64(rendered).format(text, pos, " / %d");
		pos = int64(data.fpsShow).format(text, pos, ", Fps: %d");
		Window.setTitle(text);

		int64 time = System.millis();
		if (time > data.fpsTime) {
			data.fpsTime = time + 1000;
			data.fpsShow = data.fpsCount;
			data.fpsCount = 0;
		}
		data.fpsCount += 1;
		return Window.timeoutMax;
	}

	Data data = {
		mode: Mesh.useLights | Mesh.cullBack | Mesh.drawFill;
		offs: Image.create3d(w, h);
		proj: Camera.projection(fovy, w / float32(h), 1, 100);
		cam: {};
		mesh: mesh;
	};
	Window.show(data.offs, data, onEvent);
	data.offs.destroy();
}
}
// standard library extension

// Known boolean values
enum: bool {
	true: 0 == 0;
	false: 0 != 0;
}

inline "./lib/lang/Casts.cmpl";
inline "./lib/lang/Pointer.cmpl";
static if (struct(raise) == function) {
// extension methods for debugging
inline "./lib/lang/Debug.cmpl";
}

/// Returns the size of the given type
inline sizeof(typename type) = typename.refSize(type);

// Math
inline "./lib/math/numeric/Int8.cmpl";
inline "./lib/math/numeric/Int16.cmpl";
inline "./lib/math/numeric/Int32.cmpl";
inline "./lib/math/numeric/Int64.cmpl";
inline "./lib/math/numeric/Float64.cmpl";
inline "./lib/math/numeric/Float32.cmpl";
static if (int == int32) { inline Int = Int32; }
static if (int == int64) { inline Int = Int64; }

inline "./lib/math/numeric/Fixed32.cmpl";
inline "./lib/math/numeric/Complex.cmpl";
//todo: inline "./lib/math/numeric/Rational.cmpl"?;
//todo: inline "./lib/math/numeric/Decimal.cmpl"?;
//todo: inline "./lib/math/numeric/BigInteger.cmpl"?;   // TODO: inline Rational -> BigInteger.Rational<BigInteger>
//todo: inline "./lib/math/numeric/BigDecimal.cmpl"?;   // TODO: inline Complex -> BigDecimal.Complex<BigDecimal>
inline "./lib/math/vector/Vector2d.cmpl";
inline "./lib/math/vector/Vector4f.cmpl";
inline "./lib/math/vector/Matrix4f.cmpl";
inline "./lib/math/random/Random.cmpl";
//todo: inline "./lib/math/random/Perlin.cmpl"?;
inline "./lib/math/Statistics.cmpl";


// Time
inline "./lib/time/Timeunit.cmpl";
inline "./lib/time/Duration.cmpl";
inline "./lib/time/Timestamp.cmpl";
inline "./lib/time/Timezone.cmpl";
inline "./lib/time/Datetime.cmpl";


// Text
inline "./lib/text/cstr.cmpl";
inline "./lib/text/Format.cmpl";
inline "./lib/text/stream/ByteStream.cmpl";
inline "./lib/text/stream/TextStream.cmpl";
inline "./lib/text/encoding/binary/Base64.cmpl";
inline "./lib/text/encoding/Ascii.cmpl";
inline "./lib/text/encoding/Utf8.cmpl";
//todo: inline "./lib/text/String.cmpl";
//todo: inline "./lib/text/Collator.cmpl";
//todo: inline "./lib/text/serialization/csv.cmpl";
//todo: inline "./lib/text/serialization/json.cmpl";
//todo: inline "./lib/text/serialization/yaml.cmpl";
//todo: inline "./lib/text/serialization/xml.cmpl";


// etc
inline "./lib/math/Easing.cmpl";
//inline "./lib/math/Perlin.cmpl";
inline "./lib/math/vector/Polynomial.cmpl"?;
/// Explicit cast of base types
inline int32(int32 value) = inline(value);
/// Explicit cast of base types
inline int64(int64 value) = inline(value);
/// Explicit cast of base types
inline uint32(uint32 value) = inline(value);
/// Explicit cast of base types
inline uint64(uint64 value) = inline(value);
/// Explicit cast of base types
inline float32(float32 value) = inline(value);
/// Explicit cast of base types
inline float64(float64 value) = inline(value);

/// Explicit cast of base types
inline int32(int64 value) = inline(int64(value), i64.i32);
/// Explicit cast of base types
inline int32(uint32 value) = inline(value);
/// Explicit cast of base types
inline int32(uint64 value) = inline(uint64(value), u64.i32);
/// Explicit cast of base types
inline int32(float32 value) = inline(float32(value), f32.i32);
/// Explicit cast of base types
inline int32(float64 value) = inline(float64(value), f64.i32);

/// Explicit cast of base types
inline int64(int32 value) = inline(int32(value), i32.i64);
/// Explicit cast of base types
inline int64(uint64 value) = inline(value);
/// Explicit cast of base types
inline int64(uint32 value) = inline(uint32(value), u32.i64);
/// Explicit cast of base types
inline int64(float32 value) = inline(float32(value), f32.i64);
/// Explicit cast of base types
inline int64(float64 value) = inline(float64(value), f64.i64);

/// Explicit cast of base types
inline uint32(int32 value) = inline(value);
/// Explicit cast of base types
inline uint32(int64 value) = inline(int64(value), i64.u32);
/// Explicit cast of base types
inline uint32(uint64 value) = inline(uint64(value), u64.u32);
/// Explicit cast of base types
inline uint32(float32 value) = inline(float32(value), cvt.f32_u32);
/// Explicit cast of base types
inline uint32(float64 value) = inline(float64(value), cvt.f64_u32);

/// Explicit cast of base types
inline uint64(int32 value) = inline(int32(value), i32.i64); // safe to use i32 to i64
/// Explicit cast of base types
inline uint64(int64 value) = inline(value);
/// Explicit cast of base types
inline uint64(uint32 value) = inline(uint32(0), uint32(value)); // todo: inline(value, cvt.u32_u64);
/// Explicit cast of base types
inline uint64(float32 value) = inline(float32(value), cvt.f32_u64);
/// Explicit cast of base types
inline uint64(float64 value) = inline(float64(value), cvt.f64_u64);

/// Explicit cast of base types
inline float32(int32 value) = inline(int32(value), i32.f32);
/// Explicit cast of base types
inline float32(int64 value) = inline(int64(value), i64.f32);
/// Explicit cast of base types
inline float32(uint32 value) = inline(uint32(value), cvt.u32_f32);
/// Explicit cast of base types
inline float32(uint64 value) = inline(uint64(value), cvt.u64_f32);
/// Explicit cast of base types
inline float32(float64 value) = inline(float64(value), f64.f32);

/// Explicit cast of base types
inline float64(int32 value) = inline(int32(value), i32.f64);
/// Explicit cast of base types
inline float64(int64 value) = inline(int64(value), i64.f64);
/// Explicit cast of base types
inline float64(uint32 value) = inline(uint32(value), cvt.u32_f64);
/// Explicit cast of base types
inline float64(uint64 value) = inline(uint64(value), cvt.u64_f64);
/// Explicit cast of base types
inline float64(float32 value) = inline(float32(value), f32.f64);

/// Explicit cast of base types
inline bool(bool value) = inline(value);
/// Explicit cast of base types
inline bool(int8 value) = inline(int32(value), i32.bool); // int32(value) != 0;
/// Explicit cast of base types
inline bool(int16 value) = inline(int32(value), i32.bool); // int32(value) != 0;
/// Explicit cast of base types
inline bool(int32 value) = inline(int32(value), i32.bool); // value != 0;
/// Explicit cast of base types
inline bool(int64 value) = inline(int64(value), i64.bool); // value != 0D;
/// Explicit cast of base types
inline bool(uint8 value) = inline(uint32(value), i32.bool); // uint32(value) != 0u;
/// Explicit cast of base types
inline bool(uint16 value) = inline(uint32(value), i32.bool); // uint32(value) != 0u;
/// Explicit cast of base types
inline bool(uint32 value) = inline(uint32(value), i32.bool); // value != 0u;
/// Explicit cast of base types
inline bool(uint64 value) = inline(uint64(value), i64.bool); // value != 0U;
/// Explicit cast of base types
inline bool(float32 value) = inline(float32(value), f32.bool); // value != 0f && value == value;
/// Explicit cast of base types
inline bool(float64 value) = inline(float64(value), f64.bool); // value != 0F && value == value;

/// Explicit cast of base types
inline int8(bool value) = inline(value);
/// Explicit cast of base types
inline int8(int8 value) = inline(value);
/// Explicit cast of base types
inline int8(int16 value!) = inline(pointer(value), ldi_s8);
/// Explicit cast of base types
inline int8(int32 value!) = inline(pointer(value), ldi_s8);
/// Explicit cast of base types
inline int8(int64 value!) = inline(pointer(value), ldi_s8);
/// Explicit cast of base types
inline int8(uint8 value!) = inline(pointer(value), ldi_u8); // value & 0xff
/// Explicit cast of base types
inline int8(uint16 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline int8(uint32 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline int8(uint64 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline int8(float32 value) = inline(int32(value));
/// Explicit cast of base types
inline int8(float64 value) = inline(int32(value));

/// Explicit cast of base types
inline uint8(bool value) = inline(value);
/// Explicit cast of base types
inline uint8(int8 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline uint8(int16 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline uint8(int32 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline uint8(int64 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline uint8(uint8 value) = inline(value);
/// Explicit cast of base types
inline uint8(uint16 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline uint8(uint32 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline uint8(uint64 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline uint8(float32 value) = inline(uint32(value));
/// Explicit cast of base types
inline uint8(float64 value) = inline(uint32(value));

/// Explicit cast of base types
inline int16(bool value) = inline(value);
/// Explicit cast of base types
inline int16(int8 value!) = inline(pointer(value), ldi_s8);
/// Explicit cast of base types
inline int16(int16 value) = inline(value);
/// Explicit cast of base types
inline int16(int32 value!) = inline(pointer(value), ldi_s16);
/// Explicit cast of base types
inline int16(int64 value!) = inline(pointer(value), ldi_s16);
/// Explicit cast of base types
inline int16(uint8 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline int16(uint16 value) = inline(pointer(value), ldi_u16);
/// Explicit cast of base types
inline int16(uint32 value) = inline(pointer(value), ldi_u16);
/// Explicit cast of base types
inline int16(uint64 value!) = inline(pointer(value), ldi_u16);
/// Explicit cast of base types
inline int16(float32 value) = inline(int32(value));
/// Explicit cast of base types
inline int16(float64 value) = inline(int32(value));

/// Explicit cast of base types
inline uint16(bool value) = inline(value);
/// Explicit cast of base types
inline uint16(int8 value!) = inline(pointer(value), ldi_s8);
/// Explicit cast of base types
inline uint16(int16 value!) = inline(pointer(value), ldi_u16);
/// Explicit cast of base types
inline uint16(int32 value!) = inline(pointer(value), ldi_u16);
/// Explicit cast of base types
inline uint16(int64 value!) = inline(pointer(value), ldi_u16);
/// Explicit cast of base types
inline uint16(uint8 value!) = inline(pointer(value), ldi_u8);
/// Explicit cast of base types
inline uint16(uint16 value) = inline(value);
/// Explicit cast of base types
inline uint16(uint32 value!) = inline(pointer(value), ldi_u16);
/// Explicit cast of base types
inline uint16(uint64 value!) = inline(pointer(value), ldi_u16);
/// Explicit cast of base types
inline uint16(float32 value) = inline(uint32(value));
/// Explicit cast of base types
inline uint16(float64 value) = inline(uint32(value));

/// Explicit cast of base types
inline int32(bool value) = inline(value); // fixme: value ? 0 : 1;
/// Explicit cast of base types
inline int32(int8 value!) = inline(pointer(value), ldi_s8);	// sign extend: -128 .. 127
/// Explicit cast of base types
inline int32(uint8 value!) = inline(pointer(value), ldi_u8);	// zero extend: 0 .. 255
/// Explicit cast of base types
inline int32(int16 value!) = inline(pointer(value), ldi_s16);
/// Explicit cast of base types
inline int32(uint16 value!) = inline(pointer(value), ldi_u16);

/// Explicit cast of base types
inline uint32(bool value) = inline(value); // fixme: value ? 0 : 1;
/// Explicit cast of base types
inline uint32(int8 value!) = inline(pointer(value), ldi_s8);	// sign extend: -128 .. 127
/// Explicit cast of base types
inline uint32(uint8 value!) = inline(pointer(value), ldi_u8);	// zero extend: 0 .. 255
/// Explicit cast of base types
inline uint32(int16 value!) = inline(pointer(value), ldi_s16);
/// Explicit cast of base types
inline uint32(uint16 value!) = inline(pointer(value), ldi_u16);

/// Explicit cast of base types
inline int64(bool value) = int64(int32(value));
/// Explicit cast of base types
inline int64(int8 value) = int64(int32(value));
/// Explicit cast of base types
inline int64(uint8 value) = int64(uint32(value));
/// Explicit cast of base types
inline int64(int16 value) = int64(int32(value));
/// Explicit cast of base types
inline int64(uint16 value) = int64(uint32(value));

/// Explicit cast of base types
inline uint64(bool value) = uint64(uint32(value));
/// Explicit cast of base types
inline uint64(int8 value) = uint64(int32(value));
/// Explicit cast of base types
inline uint64(uint8 value) = uint64(uint32(value));
/// Explicit cast of base types
inline uint64(int16 value) = uint64(int32(value));
/// Explicit cast of base types
inline uint64(uint16 value) = uint64(uint32(value));

/// Explicit cast of base types
inline float32(bool value) = float32(int32(value));
/// Explicit cast of base types
inline float32(int8 value) = float32(int32(value));
/// Explicit cast of base types
inline float32(uint8 value) = float32(uint32(value));
/// Explicit cast of base types
inline float32(int16 value) = float32(int32(value));
/// Explicit cast of base types
inline float32(uint16 value) = float32(uint32(value));

/// Explicit cast of base types
inline float64(bool value) = float64(int32(value));
/// Explicit cast of base types
inline float64(int8 value) = float64(int32(value));
/// Explicit cast of base types
inline float64(uint8 value) = float64(uint32(value));
/// Explicit cast of base types
inline float64(int16 value) = float64(int32(value));
/// Explicit cast of base types
inline float64(uint16 value) = float64(uint32(value));
// debugging related functions

/// report message at `verbose` logging level
inline verbose(char message[*], variant details...) = raise(raise.verbose, raise.noTrace, message, ...details);

/// report message at `debug` logging level
inline debug(char message[*], variant details...) = raise(raise.debug, raise.noTrace, message, ...details);

/// report message with stacktrace at `debug` logging level
inline trace(char message[*], variant details...) = raise(raise.debug, raise.defTrace, message, ...details);

/// report message at `info` logging level
inline info(char message[*], variant details...) = raise(raise.info, raise.noTrace, message, ...details);

/// report message at `warn` logging level
inline warn(char message[*], variant details...) = raise(raise.warn, raise.noTrace, message, ...details);

/// report message with stacktrace at `error` logging level
inline error(char message[*], variant details...) = raise(raise.error, raise.defTrace, message, ...details);

/// report message with stacktrace at `abort` logging level and abort execution
inline abort(char message[*], variant details...) = raise(raise.abort, raise.defTrace, message, ...details);
/// report message with stacktrace at `abort` logging level and abort execution
inline abort() = raise(raise.abort, raise.defTrace, "execution aborted!");

/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, char message[*], variant details...) = void(condition ? void(0) : raise(raise.abort, raise.defTrace, message, ...details));
/// report message and abort the execution if the assertion condition fails (is false)
inline assert(bool condition, variant details...) = void(condition ? void(0) : raise(raise.abort, raise.defTrace, "assertion failed!", ...details));

/// small timer to measure elapsed time
struct DebugTimer {
	int64 start;
	int64 last;

	/// create a new timer and start it
	static DebugTimer start() {
		int64 now = System.millis();
		return {
			start: now;
			last: now;
		};
	}

	static int64 end(DebugTimer timer!) {
		int64 now = System.millis();
		return now - timer.start;
	}
	static int64 lap(DebugTimer timer&) {
		int64 now = System.millis();
		int64 last = timer.last;
		timer.last = now;
		return now - last;
	}

	inline print(char message[*], int64 time!) = debug(message, time);

	/// log time spent since start
	inline end(DebugTimer timer&, char message[*]) = print(message, end(timer));

	/// log time spent since last lap
	inline lap(DebugTimer timer&, char message[*]) = print(message, lap(&timer));
}

/// Record used for debugging purposes, containing expected, returned and an array of extra values
struct NotEquals {
	/// Value of the expected result
	variant expected;

	/// Value of the actual result
	variant returned;

	/// Extra argument to identify what happened
	variant details![];

	/// abort execution displaying the expected and returned values
	inline debug(char message[*], NotEquals detail!) = raise(raise.debug, raise.noTrace, message, detail);

	/// abort execution displaying the expected and returned values
	inline error(char message[*], NotEquals detail!) = raise(raise.error, raise.noTrace, message, detail);

	/// abort execution displaying the expected and returned values
	inline abort(char message[*], NotEquals detail!) = raise(raise.abort, raise.noTrace, message, detail);
}

/// Create a not equals record for inspection from expected and returned
NotEquals NotEquals(variant expected, variant returned, variant details[]) {
	return {
		expected: expected;
		returned: returned;
		details: details;
	};
}

/// abort execution if the returned value is not equal to the expected value
inline assertEq(int64 expected, int64 returned, char message[*], variant details...) = expected == returned ? void(0) : NotEquals.abort(message, NotEquals(expected, returned, details));

/// abort execution if the returned value is not equal to the expected value
inline assertEq(int64 expected, int64 returned) = assertEq(expected, returned, "assertion failed");

/// abort execution if the returned value is not equal to the expected value
inline assertEq(bool expected, bool returned, char message[*], variant details...) = expected == returned ? void(0) : NotEquals.abort(message, NotEquals(expected, returned, details));
static if (int == int32) {
/// Explicit cast of base types
inline int(bool value) = int32(value);
/// Explicit cast of base types
inline int(int8 value) = int32(value);
/// Explicit cast of base types
inline int(int16 value) = int32(value);
/// Explicit cast of base types
inline int(int32 value) = int32(value);
/// Explicit cast of base types
inline int(int64 value) = int32(value);
/// Explicit cast of base types
inline int(uint8 value) = int32(value);
/// Explicit cast of base types
inline int(uint16 value) = int32(value);
/// Explicit cast of base types
inline int(uint32 value) = int32(value);
/// Explicit cast of base types
inline int(uint64 value) = int32(value);
/// Explicit cast of base types
inline int(float32 value) = int32(value);
/// Explicit cast of base types
inline int(float64 value) = int32(value);

/// Returns the pointer incremented with the given value
inline inc(pointer ptr, int val) = pointer(inline(pointer(ptr), int32(val), i32.add));

/// Load pointer indirection
inline ldi(pointer ptr) = pointer(inline(pointer(ptr), ldi32));
/// Store pointer indirect
inline sti(pointer ptr, pointer value) = void(inline(pointer(value), pointer(ptr), sti32));
}
static if (int == int64) {
/// Returns the pointer incremented with the given value
inline inc(pointer ptr, int val) = pointer(inline(pointer(ptr), int64(val), i64.add));
/// Load pointer indirection
inline ldi(pointer ptr) = pointer(inline(pointer(ptr), ldi64));
/// Store pointer indirect
inline sti(pointer ptr, pointer value) = void(inline(pointer(value), pointer(ptr), sti64));
}
/// Easing functions maps an input of [0, 1) usually to [0, 1) with an acceleration
// see: https://easings.net
// todo: enum Easing: float64(float64 t) { ... }
static struct Easing {
	///@public
	float64 linear(float64 t) {
		return t;
	}

	///@public
	float64 quad(float64 t) {
		return t * t;
	}

	///@public
	float64 cubic(float64 t) {
		return t * t * t;
	}

	///@public
	float64 quart(float64 t) {
		return t * t * t * t;
	}

	///@public
	float64 quint(float64 t) {
		return t * t * t * t * t;
	}

	///@public
	float64 expo(float64 t) {
		return t == 0 ? 0 : Float64.pow(2., 10 * (t - 1));
	}

	///@public
	float64 sine(float64 t) {
		return -Float64.cos(t * Float64.pi / 2) + 1;
	}

	///@public
	float64 circle(float64 t) {
		return -(Float64.sqrt(1 - t * t) - 1);
	}

	///@public
	float64 elastic(float64 t) {
		if (t == 0.0 || t == 1.0) {
			return t;
		}
		t = t - 1.0;
		return - Float64.pow(2.0, 10.0 * t) * Float64.sin((t - 0.3 / 4.0) * (2.0 * Float64.pi) / 0.3) ;
	}

	///@public
	float64 back(float64 t) {
		inline s = 1.70158;
		return t * t * ((s + 1) * t - s);
	}

	///@public
	float64 bounce(float64 t) {
		static float64 Helper(float64 t, float64 c, float64 a) {
			if (t == 1) {
				return c;
			}
			if (t < (4 / 11.)) {
				return c * (7.5625 * t * t);
			}
			if (t < (8 / 11.)) {
				t -= (6 / 11.);
				return -a * (1 - (7.5625 * t * t + 0.75)) + c;
			}
			if (t < (10 / 11.)) {
				t -= (9 / 11.0f);
				return -a * (1 - (7.5625 * t * t + 0.9375)) + c;
			}
			t -= (21 / 22.);
			return -a * (1 - (7.5625 * t * t + 0.984375)) + c;
		}
		inline a = 1.70158;
		return 1 - Helper(1 - t, 1, a);
	}
}

/// ease in, ex: Easing.elastic.in(t)
float64 in(float64 ease(float64 ratio), float64 ratio) {
	if (ease == null) {
		return ratio;
	}
	return ease(ratio);
}

/// ease out, ex: Easing.elastic.out(t)
float64 out(float64 ease(float64 ratio), float64 ratio) {
	if (ease == null) {
		return ratio;
	}
	return 1. - ease(1 - ratio);
}

/// ease in and out, ex: Easing.elastic.inOut(t)
float64 inOut(float64 ease(float64 ratio), float64 ratio) {
	if (ease == null) {
		return ratio;
	}
	ratio *= 2;
	return (ratio < 1) ? .5 * ease(ratio) : .5 * ease.out(ratio - 1) + .5;
}

/// ease out and in, ex: Easing.elastic.outIn(t)
float64 outIn(float64 ease(float64 ratio), float64 ratio) {
	if (ease == null) {
		return ratio;
	}
	ratio *= 2;
	return (ratio < 1) ? .5 * ease.out(ratio) : .5 * ease(ratio - 1) + .5;
}
/// Statistics class to compute the most frequent statistical functions
// https://www.johndcook.com/blog/standard_deviation/
// https://www.calculatorsoup.com/calculators/statistics/statistics.php
struct RunningStat {
	// count of values in the dataset
	float64 count = 0;

	// sum of all values
	float64 sum = 0;

	// minimum value
	float64 min = 0;

	// maximum value
	float64 max = 0;

	// computed average value
	float64 mean = 0;

	// sum of squared differences from the mean
	float64 SMDif = 0;

	/// reset the counters
	static void clear(RunningStat this&) {
		this.count = 0;
	}

	/// add a new value to the stats
	static void push(RunningStat this&, float64 value) {
		// See Knuth TAOCP vol 2, 3rd edition, page 232
		if (this.count == 0) {
			this.mean = value;
			this.min = value;
			this.max = value;
			this.sum = value;
			this.SMDif = 0;
			this.count = 1;
			return;
		}

		this.count += 1;
		this.sum += value;
		float64 oldMean = this.mean;
		this.mean = oldMean + (value - oldMean) / this.count;
		this.SMDif += (value - oldMean) * (value - this.mean);
		if (this.min > value) {
			this.min = value;
		}
		if (this.max < value) {
			this.max = value;
		}
	}

	/// add new values to the stats
	static void push(RunningStat this&, float64 values...) {
		for (int i = 0; i < values.length; i += 1) {
			this.push(values[i]);
		}
	}

	/// Returns the number of values added stats
	static float64 count(RunningStat this!) {
		return this.count;
	}

	/// Returns the smallest value added to the stats
	static float64 min(RunningStat this!) {
		if (this.count <= 0) {
			return Float64.nan;
		}
		return this.min;
	}

	/// Returns the largest value added to the stats
	static float64 max(RunningStat this!) {
		if (this.count <= 0) {
			return Float64.nan;
		}
		return this.max;
	}

	/// Returns the mean of all values added to the stats
	static float64 mean(RunningStat this!) {
		if (this.count <= 0) {
			return 0;
		}
		return this.mean;
	}

	/// Returns the variance of all values added to the stats
	static float64 variance(RunningStat this!) {
		if (this.count <= 1) {
			return 0;
		}
		return this.SMDif / (this.count - 1);
	}

	/// Returns the standard deviation of all values added to the stats
	static float64 stddev(RunningStat this!) {
		return Float64.sqrt(this.variance());
	}

	/// Returns the sum of all values added to the stats
	static float64 sum(RunningStat this!) {
		return this.sum;
	}
}
/// Complex number
struct Complex {
	/// The real component of a complex number.
	float64 re;

	/// The imaginary component of a complex number.
	float64 im = 0;

	/// Unary negation of a complex number: -a := Complex(-a.re, -a.im);
	static Complex neg(Complex a) { return inline(inline(a), p128.neg2d); }

	/// Add two complex numbers: a + b := Complex(a.re + b.re, a.im + b.im);
	static Complex add(Complex a, Complex b) { return inline(inline(a), inline(b), p128.add2d); }
	/// Add a complex number `a` to a real number `b`
	static Complex add(Complex a, float64 b) { return { re: a.re + b, im: a.im }; }

	/// Subtract two complex numbers: a - b := Complex(a.re - b.re, a.im - b.im);
	static Complex sub(Complex a, Complex b) { return inline(inline(a), inline(b), p128.sub2d); }
	/// Subtract the real number `b` from the complex number `a`
	static Complex sub(Complex a, float64 b) { return { re: a.re - b, im: a.im}; }

	/// Multiply two complex numbers: a * b := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
	static Complex mul(Complex a, Complex b) {
		float64 re = inline(inline(a), inline(b), p128.mul2d, u64.swap, f64.sub);
		float64 im = inline(inline(a), inline(b), u64.swap, p128.mul2d, f64.add);
		return { re: re, im: im };
	}
	/// Multiply a complex number `a` with a real number `b`
	static Complex mul(Complex a, float64 b) { return {re: a.re * b, im: a.im * b}; }

	/// Divide two complex numbers
	static Complex div(Complex a, Complex b) {
		// Adapted from Numerical Recipes in C - The Art of Scientific Computing
		// ISBN 0-521-43108-5

		if (Float64.abs(b.re) >= Float64.abs(b.im)) {
			float64 r = b.im / b.re;
			float64 den = b.re + r * b.im;
			return {
				re: (a.re + r * a.im) / den;
				im: (a.im - r * a.re) / den;
			};
		}
		float64 r = b.re / b.im;
		float64 den = b.im + r * b.re;
		return {
			re: (a.re * r + a.im) / den;
			im: (a.im * r - a.re) / den;
		};
	}
	/// Divide the complex number `a` by the real number `b`
	static Complex div(Complex a, float64 b) { return { re: a.re / b, im: a.im / b}; }

	/// Compute the absolute value of the complex number `a`
	static float64 abs(Complex a) { return Float64.sqrt(a.re * a.re + a.im * a.im); }
	/// Compute the argument of the complex number `a`
	static float64 arg(Complex a) { return Float64.atan2(a.re, a.im); }

	/// Compute the reciprocal of a complex number (1 / a)
	static Complex inv(Complex a) {
		float64 d = a.re * a.re + a.im * a.im;
		return {
			re: +a.re / d;
			im: -a.im / d;
		};
	}

	/// Compute the conjugate of the complex number `a`
	static Complex conj(Complex a) { return {re: a.re, im: -a.im}; }

	/// Compute the exponential of a complex number: $ e^a $.
	static Complex exp(Complex a) {
		return {
			re: Float64.exp(a.re) * Float64.cos(a.im);
			im: Float64.exp(a.re) * Float64.sin(a.im);
		};
	}

	/// Compute the natural logarithm of the complex number `a`.
	static Complex ln(Complex a) { return { re: Float64.ln(abs(a)), im: arg(a) }; }

	/// Compute the complex number `a` raised to the power of `b`: $ a^b $.
	static Complex pow(Complex a, Complex b) {
		float64 r = a.abs();
		float64 t = a.arg();
		float64 u = b.re * t + b.im * Float64.ln(r);
		float64 v = Float64.pow(r, b.re) * Float64.exp(-b.im * t);
		return {
			re: v * Float64.cos(u);
			im: v * Float64.sin(u);
		};
	}
	/// Compute the complex number `a` raised to the power of `b`: $ a^b $.
	static Complex pow(Complex a, float64 b) {
		static Complex from(float64 re) { return {re: re, im: 0}; }
		return pow(a, from(b));
	}

	/// Compute the sine of the complex number `a`.
	static Complex sin(Complex a) {
		return {
			re: Float64.sin(a.re) * Float64.cosh(a.im);
			im: Float64.cos(a.re) * Float64.sinh(a.im);
		};
	}
	/// Compute the cosine of the complex number `a`.
	static Complex cos(Complex a) {
		return {
			re: Float64.cos(a.re) * Float64.cosh(a.im);
			im: -Float64.sin(a.re) * Float64.sinh(a.im);
		};
	}
	/// Compute the tangent of the complex number `a`.
	static Complex tan(Complex a) { return div(sin(a), cos(a)); }
	/// Compute the cotangent of the complex number `a`.
	static Complex cot(Complex a) { return div(cos(a), sin(a)); }
	/// Compute the secant of the complex number `a`.
	static Complex sec(Complex a) { return inv(cos(a)); }
	/// Compute the cosecant of the complex number `a`.
	static Complex csc(Complex a) { return inv(sin(a)); }

	/// Compute the hyperbolic sine of the complex number `a`.
	static Complex sinh(Complex a) { return div(sub(exp(a), exp(a.neg())), 2); }
	/// Compute the hyperbolic cosine of the complex number `a`.
	static Complex cosh(Complex a) { return div(add(exp(a), exp(neg(a))), 2); }
	/// Compute the hyperbolic tangent of the complex number `a`.
	static Complex tanh(Complex a) { return div(sub(exp(mul(a, 2)), 1), add(exp(mul(a, 2)), 1)); }
	/// Compute the hyperbolic cotangent of the complex number `a`.
	static Complex coth(Complex a) { return div(add(exp(mul(a, 2)), 1), sub(exp(mul(a, 2)), 1)); }
	/// Compute the hyperbolic secant of the complex number `a`.
	static Complex sech(Complex a) { return inv(cosh(a)); }
	/// Compute the hyperbolic cosecant of the complex number `a`.
	static Complex csch(Complex a) { return inv(sinh(a)); }
}

/// Create a Complex number from the given `value`
Complex Complex(float64 value) {
	return {
		re: value;
	};
}

/// Create a Complex number from the given `real` and `imaginary` values
Complex Complex(float64 real, float64 imaginary) {
	return {
		re: real;
		im: imaginary;
	};
}

/// Convert the from polar(r,) to cartesian(x,y) coordinates
inline toCartesian(Complex x) = Complex(x.re * Float64.cos(x.im), x.re * Float64.sin(x.im));
/// Convert the from cartesian(x,y) to polar(r,) coordinates
inline toPolar(Complex x) = Complex(x.abs(), x.arg());


/* TODO: implement enumerations, then:
enum: Complex {
	zero: { re: 0 };	// 0 + 0i
	unit: { re: 1 };	// 1 + 0i
}


// TODO: implement operator overloading, then:
inline -(Complex a) = Complex(-a.re, -a.im);

inline +(Complex a, Complex b) = Complex(a.re + b.re, a.im + b.im);
inline +(Complex a, float64 b) = Complex(a.re + b, a.im);
/// Add a complex number `b` to a real number `a`
inline +(float64 a, Complex b) = Complex(a + b.re, b.im);

inline -(Complex a, Complex b) = Complex(a.re - b.re, a.im - b.im);
inline -(Complex a, float64 b) = Complex(a.re - b, a.im);
/// Subtract the complex number `b` from the real number `a`
inline -(float64 a, Complex b) = Complex(a - b.re, b.im);

inline *(Complex a, Complex b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
inline *(Complex a, float64 b) = Complex(a.re * b, a.im * b);
/// Multiply a complex number `b` with a real number `a`
inline *(float64 a, Complex b) = Complex(a * b.re, a * b.im);

inline /(Complex a, Complex b) = div(a, b);
inline /(Complex a, float64 b) = div(a, Complex(b));
/// Divide the real number `a` by the complex number `b`
inline /(float64 a, Complex b) = Complex(a).div(b);
*/
/// A 32 bit fixed-point type, with `precision` bits used for fractional part, the rest for integer part
struct Fixed32: 4 { // todo: packing should be automatically set to 4
	int32 bits = 0;

	enum: int32 {
		precision: 20; // todo: precision should be type parameter

		one: 1 << precision;
		half: one / 2;
		mask: one - 1;
		nan: 0x80000000;
	}

	static if (precision > 30) { OneMustBeNonOverflowingPositiveNumber }

	/// return the fixed point value of the given raw bits
	static Fixed32 bits(int32 bits) { return { bits: bits }; }
	/// return the internal raw value of the fixed point value
	static int32 bits(Fixed32 value) { return value.bits; }

	///@todo: should be private
	static Fixed32 overflow(int64 result, char message[*], variant args...) {
		// raise(raise.error, raise.defTrace, message, ...args);
		// static if (inf != nan) { return { bits: nan - Int64.sign(result) }; }
		return { bits: nan };
	}

	/// Determines whether the given fixed point value is undefined
	static bool isUndefined(Fixed32 x) { return x.bits == nan; }


	/// Computes the negated value of the given number
	static Fixed32 neg(Fixed32 x) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan) {
				return Fixed32.overflow(0, "neg.args", x);
			}
		}
		return { bits: -x.bits };
	}

	/// Adds the two fixed point numbers
	static Fixed32 add(Fixed32 x, Fixed32 y) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y.bits == nan) {
				return Fixed32.overflow(0, "add.args", x, y);
			}

			int64 result = int64(x.bits) + y.bits;
			if ((result >> 63) != (result >> 31)) {
				return Fixed32.overflow(result, "add.result", x, y);
			}
			return { bits: result };
		}
		return { bits: x.bits + y.bits };
	}

	/// Subtract one from another fixed point number
	static Fixed32 sub(Fixed32 x, Fixed32 y) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y.bits == nan) {
				return Fixed32.overflow(0, "sub.args", x, y);
			}

			int64 result = int64(x.bits) - y.bits;
			if ((result >> 63) != (result >> 31)) {
				return Fixed32.overflow(result, "sub.result", x, y);
			}
			return { bits: result };
		}
		return { bits: x.bits - y.bits };
	}

	/// Multiply two fixed-point numbers
	static Fixed32 mul(Fixed32 x, Fixed32 y) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y.bits == nan) {
				return Fixed32.overflow(0, "mul.args", x, y);
			}
		}

		int64 result = int64(x.bits) * y.bits;
		result += result & half;
		static if (struct(Fixed32.overflow) == function) {
			if ((result >> 63) != (result >> 31 + precision)) {
				return Fixed32.overflow(result, "mul.result", x, y);
			}
		}
		return { bits: result >> precision };
	}

	/// Divide one fixed-point number with another one
	static Fixed32 div(Fixed32 x, Fixed32 y) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y.bits == -y.bits) {
				if (y.bits == 0 && x.bits != -x.bits) {
					return Fixed32.overflow(x.bits, "div.zero", x, y);
				}
				return Fixed32.overflow(0, "div.args", x, y);
			}
		} else {
			if (y.bits == 0) {
				return { bits: nan };
			}
		}

		int64 result = (int64(x.bits) << precision) / y.bits;
		static if (struct(Fixed32.overflow) == function) {
			if ((result >> 63) != (result >> 31)) {
				return Fixed32.overflow(result, "div.result", x, y);
			}
		}
		return { bits: result };
	}

	/// Returns the remainder of the division of `x` by `y`
	static Fixed32 rem(Fixed32 x, Fixed32 y) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y.bits == -y.bits) {
				return Fixed32.overflow(0, "rem.args", x, y);
			}
		} else {
			if (y.bits == 0) {
				return { bits: nan };
			}
		}
		return { bits: x.bits % y.bits };
	}

	/// Compute the reciprocal of x: (1 / x)
	static Fixed32 inv(Fixed32 x) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == -x.bits) {
				// x.bits == 0 || x.bits == nan
				return Fixed32.overflow(0, "inv.args", x);
			}
		} else {
			if (x.bits == 0) {
				return { bits: nan };
			}
		}

		int64 result = (int64(one) << precision) / x.bits;
		static if (struct(Fixed32.overflow) == function) {
			if (result >> 31 != result >> 63) {
				return Fixed32.overflow(result, "inv.result", x);
			}
		}
		return { bits: result };
	}

	/// Determines whether the given fixed point is less than the other one
	static int32 cmp(Fixed32 x, Fixed32 y) {
		// todo: overflow check
		return int32(x.bits < y.bits) - int32(x.bits > y.bits);
	}

	static Fixed32 add(Fixed32 x, int32 y) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y == nan) {
				return Fixed32.overflow(0, "add.i.args", x, y);
			}
		}
		int64 result = x.bits + (int64(y) << precision);
		static if (struct(Fixed32.overflow) == function) {
			if ((result >> 63) != (result >> 31)) {
				return Fixed32.overflow(result, "add.i.result", x, y);
			}
		}
		return { bits: result };
	}
	static Fixed32 mul(Fixed32 x, int32 y) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y == nan) {
				return Fixed32.overflow(0, "mul.i.args", x, y);
			}
			int64 result = int64(x.bits) * y;
			if ((result >> 63) != (result >> 31)) {
				return Fixed32.overflow(result, "mul.i.result", x, y);
			}
			return { bits: result };
		}
		return { bits: x.bits * y };
	}
	static Fixed32 div(Fixed32 x, int32 y) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y == -y) {
				return Fixed32.overflow(0, "div.i.args", x, y);
			}
		} else {
			if (y == 0) {
				return { bits: nan };
			}
		}
		return { bits: x.bits / y };
	}
	static Fixed32 madSat(Fixed32 x, Fixed32 y, Fixed32 z) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y.bits == nan || z.bits == nan) {
				return Fixed32.overflow(0, "mad.args", x, y, z);
			}
		}

		int64 result = int64(x.bits) * int64(y.bits);
		result += int64(z.bits) << precision;
		result += result & half;
		if ((result >> 63) != (result >> 31 + precision)) {
			return { bits: nan - Int64.sign(result) };
		}
		return { bits: result >> precision };
	}
	static Fixed32 divSat(Fixed32 x, Fixed32 y) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan || y.bits == -y.bits) {
				if (y.bits == 0 && x.bits != -x.bits) {
					return Fixed32.overflow(x.bits, "div.zero", x, y);
				}
				return Fixed32.overflow(0, "div.args", x, y);
			}
		} else {
			if (y.bits == 0) {
				return { bits: nan };
			}
		}

		int64 result = (int64(x.bits) << precision) / y.bits;
		if ((result >> 63) != (result >> 31)) {
			return { bits: nan - Int64.sign(result) };
		}
		return { bits: result };
	}
	static Fixed32 invSat(Fixed32 x) {
		if (x.bits == 0) {
			return { bits: nan };
		}

		int64 result = (int64(one) << precision) / x.bits;
		if (result >> 31 != result >> 63) {
			return { bits: nan - Int64.sign(result) };
		}
		return { bits: result };
	}



	/// Returns the fractional part of the fixed point number
	static Fixed32 fract(Fixed32 x) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan) {
				return Fixed32.overflow(0, "fract.args", x);
			}
		}
		if (x.bits < 0) {
			return { bits: -(-x.bits & mask) };
		}
		return { bits: x.bits & mask };
	}

	/// Computes the largest integer that is less than or equal to `x`
	static Fixed32 floor(Fixed32 x) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan) {
				return Fixed32.overflow(0, "floor.args", x);
			}
		}
		return { bits: x.bits & ~mask };
	}

	/// Computes the smallest integer that is greater than or equal to `x`
	static Fixed32 ceil(Fixed32 x) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan) {
				return Fixed32.overflow(0, "ceil.args", x);
			}
		}
		return { bits: -(-x.bits & ~mask) };
	}

	/// Computes the nearest integer to `x`
	static Fixed32 round(Fixed32 x) {
		static if (struct(Fixed32.overflow) == function) {
			if (x.bits == nan) {
				return Fixed32.overflow(0, "round.args", x);
			}
		}
		// todo: check overflow
		return { bits: (x.bits + half) & ~mask };
	}


	// power and logarithm fixed point functions
	static if (precision <= 28) {
		enum: int32 {
			l2e_30u: 0x5c551d94;                            // 1.442695040888963 : log2(e) = 1 / ln(2)
			l2t_30u: 0xd49a784b;                            // 3.321928094887362 : log2(10) = 1 / lg(2)
			ln2_30u: 0x2c5c85fd;                            // .6931471805599453 : natural logarithm (2)
			lg2_30u: 0x13441350;                            // .3010299956639812 : decimal logarithm (2)

			lutInterp: 2; // lookup table interpolation: 0: none, 1: linear, 2: parabola
		}

		///@todo: should be private
		static int32 mul_30u(int32 x, uint32 y) {
			int64 result = int64(x) * y;
			result += result & (1 << 29);
			if ((result >> 63) != (result >> 61 - precision)) {
				return nan;
			}
			return result >> 30 - precision;
		}
		static Fixed32 mul_30u(Fixed32 x, uint32 y) {
			if (x.bits == nan) {
				return x;
			}
			int64 result = int64(x.bits) * y;
			result += result & (1 << 29);
			static if (struct(Fixed32.overflow) == function) {
				if ((result >> 63) != (result >> 31 + 30)) {
					return Fixed32.overflow(result, "mul.30.result", x, y);
				}
			}
			return { bits: result >> 30 };
		}

		/// Returns the binary logarithm of the argument `x`
		// Special cases:
		//  * log2(Inf) = +Inf
		//  * log2(0) = -Inf
		//  * log2(x<0) = NaN
		//  * log2(NaN) = NaN
		static Fixed32 log2(Fixed32 x) {
			static uint32 tbl_log2![258] = {
				// log2(x + 1), x : [0, 1), x = float64.log2(index / 256. + 1) << 31
				0x00000000, 0x00b84e23, 0x016fe50b, 0x0226c622, 0x02dcf2d0, 0x03926c77, 0x04473475, 0x04fb4c25,
				0x05aeb4dd, 0x06616ff0, 0x07137eae, 0x07c4e260, 0x08759c4f, 0x0925adbf, 0x09d517ee, 0x0a83dc1b,
				0x0b31fb7d, 0x0bdf774b, 0x0c8c50b7, 0x0d3888ef, 0x0de42120, 0x0e8f1a71, 0x0f397608, 0x0fe33507,
				0x108c588c, 0x1134e1b4, 0x11dcd197, 0x1284294b, 0x132ae9e2, 0x13d1146d, 0x1476a9f9, 0x151bab90,
				0x15c01a39, 0x1663f6fa, 0x170742d4, 0x17a9fec7, 0x184c2bd0, 0x18edcae8, 0x198edd07, 0x1a2f6323,
				0x1acf5e2d, 0x1b6ecf17, 0x1c0db6cd, 0x1cac163c, 0x1d49ee4c, 0x1de73fe3, 0x1e840be7, 0x1f205339,
				0x1fbc16b9, 0x20575744, 0x20f215b7, 0x218c52ea, 0x22260fb5, 0x22bf4ced, 0x23580b65, 0x23f04bed,
				0x24880f56, 0x251f566b, 0x25b621f8, 0x264c72c6, 0x26e2499d, 0x2777a741, 0x280c8c76, 0x28a0f9fd,
				0x2934f097, 0x29c87101, 0x2a5b7bf8, 0x2aee1236, 0x2b803473, 0x2c11e368, 0x2ca31fc8, 0x2d33ea49,
				0x2dc4439b, 0x2e542c6f, 0x2ee3a574, 0x2f72af58, 0x30014ac6, 0x308f7867, 0x311d38e5, 0x31aa8ce7,
				0x32377512, 0x32c3f20a, 0x33500472, 0x33dbaceb, 0x3466ec14, 0x34f1c28d, 0x357c30f2, 0x360637df,
				0x368fd7ee, 0x371911b7, 0x37a1e5d3, 0x382a54d8, 0x38b25f5a, 0x393a05ed, 0x39c14924, 0x3a482990,
				0x3acea7c0, 0x3b54c444, 0x3bda7fa8, 0x3c5fda7a, 0x3ce4d543, 0x3d69708f, 0x3dedace6, 0x3e718acf,
				0x3ef50ad1, 0x3f782d72, 0x3ffaf335, 0x407d5c9d, 0x40ff6a2e, 0x41811c67, 0x420273c9, 0x428370d3,
				0x43041403, 0x43845dd5, 0x44044ec5, 0x4483e74e, 0x450327ea, 0x45821112, 0x4600a33d, 0x467edee3,
				0x46fcc47a, 0x477a5476, 0x47f78f4c, 0x4874756e, 0x48f10750, 0x496d4562, 0x49e93016, 0x4a64c7d9,
				0x4ae00d1c, 0x4b5b004d, 0x4bd5a1d7, 0x4c4ff228, 0x4cc9f1aa, 0x4d43a0c9, 0x4dbcffed, 0x4e360f80,
				0x4eaecfea, 0x4f274192, 0x4f9f64de, 0x50173a34, 0x508ec1fa, 0x5105fc93, 0x517cea62, 0x51f38bcb,
				0x5269e12f, 0x52dfeaef, 0x5355a96c, 0x53cb1d06, 0x5440461c, 0x54b5250b, 0x5529ba32, 0x559e05ee,
				0x5612089a, 0x5685c292, 0x56f93432, 0x576c5dd4, 0x57df3fd0, 0x5851da80, 0x58c42e3d, 0x59363b5d,
				0x59a80239, 0x5a198325, 0x5a8abe79, 0x5afbb489, 0x5b6c65a9, 0x5bdcd22f, 0x5c4cfa6c, 0x5cbcdeb4,
				0x5d2c7f59, 0x5d9bdcac, 0x5e0af6ff, 0x5e79cea2, 0x5ee863e4, 0x5f56b716, 0x5fc4c886, 0x60329881,
				0x60a02756, 0x610d7553, 0x617a82c2, 0x61e74ff1, 0x6253dd2c, 0x62c02abc, 0x632c38ed, 0x63980808,
				0x64039858, 0x646eea24, 0x64d9fdb6, 0x6544d356, 0x65af6b4a, 0x6619c5db, 0x6683e34e, 0x66edc3ea,
				0x675767f5, 0x67c0cfb3, 0x6829fb69, 0x6892eb5b, 0x68fb9fce, 0x69641904, 0x69cc5740, 0x6a345ac5,
				0x6a9c23d6, 0x6b03b2b2, 0x6b6b079c, 0x6bd222d4, 0x6c39049a, 0x6c9fad2f, 0x6d061cd2, 0x6d6c53c2,
				0x6dd2523d, 0x6e381882, 0x6e9da6ce, 0x6f02fd5f, 0x6f681c73, 0x6fcd0445, 0x7031b511, 0x70962f15,
				0x70fa728b, 0x715e7fae, 0x71c256ba, 0x7225f7e8, 0x72896372, 0x72ec9993, 0x734f9a83, 0x73b2667b,
				0x7414fdb4, 0x74776066, 0x74d98ec9, 0x753b8915, 0x759d4f80, 0x75fee242, 0x76604190, 0x76c16da2,
				0x772266ac, 0x77832ce5, 0x77e3c082, 0x784421b6, 0x78a450b8, 0x79044dba, 0x796418f2, 0x79c3b291,
				0x7a231acd, 0x7a8251d7, 0x7ae157e3, 0x7b402d22, 0x7b9ed1c6, 0x7bfd4602, 0x7c5b8a07, 0x7cb99e05,
				0x7d17822f, 0x7d7536b3, 0x7dd2bbc3, 0x7e30118f, 0x7e8d3845, 0x7eea3017, 0x7f46f931, 0x7fa393c5,
				0x80000000, 0x805c3e0f
			};

			if (x.bits <= 0) {
				static if (struct(Fixed32.overflow) == function) {
					return Fixed32.overflow(0, "log2.args", x);
				}
				return Fixed32.bits(nan);
			}

			int32 n = Uint32.scanReverse(x.bits);
			uint32 f = x.bits << (32 - n);

			// index table using 8 most significant bits of fraction
			inline p = 24;
			int32 idx = f >> p;

			static if (lutInterp == 2) {
				// fit parabola through closest 3 sampling points; find coefficients a,b
				int32 f0 = tbl_log2[idx];
				int32 f1 = (tbl_log2[idx + 1] - f0) * 2;
				int32 f2 = tbl_log2[idx + 2] - f0;
				int32 a = f2 - f1;
				int32 b = f1 - a;

				// difference between argument and next smaller sampling point
				int32 dx = f & (1 << p) - 1;
				// find function value offset for argument x by computing ((a*dx+b)*dx)
				int64 r = a;
				r = (r * dx >> p) + b;
				r = r * dx >> p + 1;
				r = f0 + r + 64;
				return Fixed32.bits((n - precision << precision) + (r >> 31 - precision));
			}
			static if (lutInterp == 1) {
				int32 r = tbl_log2[idx];
				uint32 mix = (f >> 16) & 0xff;
				r += mix * (tbl_log2[idx + 1] - r) >> 8;
				return Fixed32.bits((n - precision << precision) + (r >> 31 - precision));
			}
			static if (lutInterp == 0) {
				int32 r = tbl_log2[idx];
				return Fixed32.bits((n - precision << precision) + (r >> 31 - precision));
			}
			return Fixed32.bits(nan);
		}

		///	Returns the base-2 exponential of the argument `x`
		// Special cases:
		//  * exp(+Inf) = +Inf
		//  * exp(NaN) = NaN
		//  * exp(-Inf) = 0
		static Fixed32 exp2(Fixed32 x) {
			static uint32 tbl_exp2![258] = {
				// (2 ** x), x : [0, 1), x = (float64.exp2(i / 256.)) << 31
				0x00000000, 0x0058d7d2, 0x00b1ed4f, 0x010b40a1, 0x0164d1f3, 0x01bea170, 0x0218af43, 0x0272fb97,
				0x02cd8698, 0x03285071, 0x0383594e, 0x03dea15b, 0x043a28c3, 0x0495efb3, 0x04f1f656, 0x054e3cd8,
				0x05aac367, 0x06078a2f, 0x0664915b, 0x06c1d919, 0x071f6196, 0x077d2afe, 0x07db357f, 0x08398146,
				0x08980e80, 0x08f6dd5a, 0x0955ee03, 0x09b540a7, 0x0a14d575, 0x0a74ac9a, 0x0ad4c645, 0x0b3522a3,
				0x0b95c1e3, 0x0bf6a434, 0x0c57c9c4, 0x0cb932c1, 0x0d1adf5b, 0x0d7ccfc0, 0x0ddf0420, 0x0e417ca9,
				0x0ea4398b, 0x0f073af5, 0x0f6a8117, 0x0fce0c21, 0x1031dc43, 0x1095f1ab, 0x10fa4c8b, 0x115eed13,
				0x11c3d373, 0x1228ffdc, 0x128e727d, 0x12f42b88, 0x135a2b2f, 0x13c071a0, 0x1426ff0f, 0x148dd3ac,
				0x14f4efa8, 0x155c5336, 0x15c3fe86, 0x162bf1cb, 0x16942d37, 0x16fcb0fb, 0x17657d49, 0x17ce9255,
				0x1837f051, 0x18a1976f, 0x190b87e2, 0x1975c1dd, 0x19e04593, 0x1a4b1337, 0x1ab62afc, 0x1b218d16,
				0x1b8d39b9, 0x1bf93118, 0x1c657368, 0x1cd200db, 0x1d3ed9a7, 0x1dabfdff, 0x1e196e18, 0x1e872a27,
				0x1ef53260, 0x1f6386f8, 0x1fd22825, 0x2041161b, 0x20b0510f, 0x211fd938, 0x218faeca, 0x21ffd1fc,
				0x22704303, 0x22e10215, 0x23520f68, 0x23c36b34, 0x243515ae, 0x24a70f0c, 0x25195786, 0x258bef53,
				0x25fed6a9, 0x26720dc0, 0x26e594cf, 0x27596c0e, 0x27cd93b4, 0x28420bfa, 0x28b6d516, 0x292bef41,
				0x29a15ab4, 0x2a1717a7, 0x2a8d2652, 0x2b0386ef, 0x2b7a39b5, 0x2bf13edf, 0x2c6896a4, 0x2ce0413f,
				0x2d583eea, 0x2dd08fdd, 0x2e493452, 0x2ec22c84, 0x2f3b78ad, 0x2fb51906, 0x302f0dcb, 0x30a95736,
				0x3123f581, 0x319ee8e8, 0x321a31a6, 0x3295cff5, 0x3311c412, 0x338e0e38, 0x340aaea2, 0x3487a58c,
				0x3504f333, 0x358297d3, 0x360093a8, 0x367ee6ee, 0x36fd91e3, 0x377c94c2, 0x37fbefca, 0x387ba337,
				0x38fbaf47, 0x397c1437, 0x39fcd245, 0x3a7de9ae, 0x3aff5ab2, 0x3b81258d, 0x3c034a7e, 0x3c85c9c5,
				0x3d08a39f, 0x3d8bd84b, 0x3e0f6809, 0x3e935317, 0x3f1799b6, 0x3f9c3c24, 0x40213aa1, 0x40a6956e,
				0x412c4cca, 0x41b260f5, 0x4238d231, 0x42bfa0bc, 0x4346ccda, 0x43ce56c9, 0x44563ecc, 0x44de8523,
				0x45672a11, 0x45f02dd6, 0x467990b5, 0x470352f0, 0x478d74c8, 0x4817f681, 0x48a2d85c, 0x492e1a9d,
				0x49b9bd86, 0x4a45c15a, 0x4ad2265e, 0x4b5eecd3, 0x4bec14fe, 0x4c799f23, 0x4d078b86, 0x4d95da6a,
				0x4e248c15, 0x4eb3a0ca, 0x4f4318cf, 0x4fd2f468, 0x506333da, 0x50f3d76c, 0x5184df62, 0x52164c02,
				0x52a81d91, 0x533a5457, 0x53ccf099, 0x545ff29e, 0x54f35aab, 0x55872909, 0x561b5dfe, 0x56aff9d1,
				0x5744fcca, 0x57da6731, 0x5870394c, 0x59067364, 0x599d15c2, 0x5a3420ad, 0x5acb946f, 0x5b63714f,
				0x5bfbb797, 0x5c946791, 0x5d2d8185, 0x5dc705bc, 0x5e60f482, 0x5efb4e1f, 0x5f9612de, 0x6031430a,
				0x60ccdeec, 0x6168e6cf, 0x62055aff, 0x62a23bc7, 0x633f8972, 0x63dd444c, 0x647b6ca0, 0x651a02ba,
				0x65b906e7, 0x66587973, 0x66f85aaa, 0x6798aada, 0x68396a50, 0x68da9958, 0x697c3840, 0x6a1e4756,
				0x6ac0c6e7, 0x6b63b743, 0x6c0718b6, 0x6caaeb8f, 0x6d4f301e, 0x6df3e6b1, 0x6e990f98, 0x6f3eab20,
				0x6fe4b99b, 0x708b3b58, 0x713230a7, 0x71d999d8, 0x7281773c, 0x7329c923, 0x73d28fde, 0x747bcbbe,
				0x75257d15, 0x75cfa433, 0x767a416c, 0x77255510, 0x77d0df73, 0x787ce0e5, 0x792959bb, 0x79d64a46,
				0x7a83b2db, 0x7b3193cc, 0x7bdfed6c, 0x7c8ec011, 0x7d3e0c0c, 0x7dedd1b4, 0x7e9e115c, 0x7f4ecb59,
				0x80000000, 0x80b1afa5
			};
			static int32 underflow_exp = -mul_30u(precision, 1 << 30);
			static int32 overflow_exp = mul_30u(31 - precision, 1 << 30);

			if (x.bits <= underflow_exp) {
				if (x.bits == nan) {
					static if (struct(Fixed32.overflow) == function) {
						return Fixed32.overflow(0, "exp2.args", x);
					}
					return x;
				}
				return Fixed32.bits(0);
			}
			if (x.bits > overflow_exp) {
				static if (struct(Fixed32.overflow) == function) {
					return Fixed32.overflow(1, "exp2.args", x);
				}
				return Fixed32.bits(nan);
			}

			// extract integer portion; 2 ** i is realized as a shift at the end
			int32 i = x.bits >> precision;
			// extract fraction f so we can compute 2 ** f, 0 <= f < 1
			uint32 f = x.bits & mask;

			// index table using 8 most significant bits of fraction
			inline p = precision - 8;
			int32 idx = f >> p;

			static if (lutInterp == 2) {
				// fit parabola through closest 3 sampling points; find coefficients a,b
				int32 f0 = tbl_exp2[idx];
				int32 f1 = (tbl_exp2[idx+1] - f0);
				int32 f2 = (tbl_exp2[idx+2] - f0);
				int32 a = f2 - (f1 << 1);
				int32 b = (f1 << 1) - a;

				// difference between argument and next smaller sampling point
				int32 dx = f & (1 << p) - 1;
				// find function value offset for argument x by computing ((a*dx+b)*dx)
				int64 r = a;
				r = (r * dx >> p) + b;
				r = r * dx >> p + 1;
				r = f0 + r + (1U << 31);
				return Fixed32.bits(((r >> (30 - precision - i)) + 1) >> 1);
			}
			static if (lutInterp == 1) {
				int64 r = tbl_exp2[idx];
				uint32 mix = (f >> p - 8) & 0xff;
				r += mix * (tbl_exp2[idx + 1] - r) >> 8;
				r += 1U << 31;
				return Fixed32.bits(((r >> (30 - precision - i)) + 1) >> 1);
			}
			static if (lutInterp == 0) {
				int64 r = tbl_exp2[idx];
				r += 1U << 31;
				return Fixed32.bits(((r >> (30 - precision - i)) + 1) >> 1);
			}
			return Fixed32.bits(nan);
		}

		/// Returns the natural logarithm of the argument `x`
		// ln(x) = log2(x) / log2(e) = log2(x) * ln(2)
		static Fixed32 ln(Fixed32 x) {
			// Special cases handled by log2
			return mul_30u(log2(x), ln2_30u);
		}

		/// Returns the decimal logarithm of the argument `x`
		// log10(x) = log2(x) / log2(10) = log2(x) * log10(2)
		static Fixed32 log10(Fixed32 x) {
			// Special cases handled by log2
			return mul_30u(log2(x), lg2_30u);
		}

		/// Returns the logarithm of the argument `x`
		// log(x, y) := log2(x) / log2(y)
		static Fixed32 log(Fixed32 x, Fixed32 y) {
			if (x.bits > 0 && y.bits == 0) {
				// todo: handle overflow
				return y;
			}
			// Special cases handled by log2
			return div(log2(x), log2(y));
		}


		/// Returns the base-e exponential: $ e^x $
		// e ** x = exp(x) = exp2(x * log2(e))
		static Fixed32 exp(Fixed32 x) {
			static int32 underflow_exp = -mul_30u(precision, ln2_30u);
			if (x.bits <= underflow_exp) {
				if (x.bits == nan) {
					static if (struct(Fixed32.overflow) == function) {
						return Fixed32.overflow(0, "exp2.args", x);
					}
					return x;
				}
				return Fixed32.bits(0);
			}

			// Other special cases handled by exp2
			return exp2(mul_30u(x, l2e_30u));
		}

		/// Returns the base 10 exponential: $ 10^x $
		// 10 ** x = exp10(x) = exp2(x * log2(10))
		static Fixed32 exp10(Fixed32 x) {
			static int32 underflow_exp = -mul_30u(precision, lg2_30u);
			if (x.bits <= underflow_exp) {
				if (x.bits == nan) {
					static if (struct(Fixed32.overflow) == function) {
						return Fixed32.overflow(0, "exp2.args", x);
					}
					return x;
				}
				return Fixed32.bits(0);
			}

			// Other special cases handled by exp2
			return exp2(mul_30u(x, l2t_30u));
		}

		/// Returns the square root of the parameter `x`: $\sqrt{x}$
		// Special cases:
		//  * sqrt(+Inf) = +Inf
		//  * sqrt(0) = 0
		//  * sqrt(x < 0) = NaN
		//  * sqrt(NaN) = NaN
		static Fixed32 sqrt(Fixed32 x) {
			if (x.bits <= 0) {
				if (x.bits < 0) {
					return bits(nan);
				}
				return x;
			}

			static if ((precision & 1) != 0) {
				return exp2(log2(x).div(2));
			}

			// adapted from "Graphics Gems"
			uint32 root = 0;			// Clear root
			uint32 remHi = 0;			// Clear high part of partial remainder
			uint32 remLo = x.bits;		// Get argument into low part of partial remainder
			for (uint32 count = 16 + (precision >> 1); count != 0; count -= 1) {
				remHi = (remHi << 2) | (remLo >> 30);		// get 2 bits of arg
				remLo <<= 2;
				root <<= 1;									// Get ready for the next bit in the root
				uint32 testDiv = (root << 1) + 1;			// Test radical
				if (remHi >= testDiv) {
					remHi -= testDiv;
					root += 1;
				}
			}
			return bits(root);
		}

		/// Returns `x` raised to the power of `y`: $ x^y $
		static Fixed32 pow(Fixed32 x, Fixed32 y) {
			// Special cases are (in order):
			//	Pow(x, 0) = 1 for any x
			//	Pow(1, y) = 1 for any y
			if (y.bits == 0 || x.bits == one) {
				return bits(one);
			}
			//	Pow(x, 1) = x for any x
			if (y.bits == one) {
				return x;
			}
			//	Pow(NaN, y) = NaN
			//	Pow(x, NaN) = NaN
			if (x.bits == nan || y.bits == nan) {
				return bits(nan);
			}
			//	todo: Pow(0, y) = Inf for y an odd integer < 0
			//	todo: Pow(0, -Inf) = +Inf
			//	todo: Pow(0, +Inf) = +0
			//	todo: Pow(0, y) = +Inf for finite y < 0 and not an odd integer
			//	todo: Pow(0, y) = 0 for y an odd integer > 0
			//	todo: Pow(0, y) = +0 for finite y > 0 and not an odd integer
			if (x.bits == 0) {
				if (y.bits < 0) {
					return bits(nan);
				}
				return bits(0);
			}
			//	todo: Pow(-1, Inf) = 1
			//	todo: Pow(x, +Inf) = +Inf for |x| > 1
			//	todo: Pow(x, -Inf) = +0 for |x| > 1
			//	todo: Pow(x, +Inf) = +0 for |x| < 1
			//	todo: Pow(x, -Inf) = +Inf for |x| < 1
			//	todo: Pow(+Inf, y) = +Inf for y > 0
			//	todo: Pow(+Inf, y) = +0 for y < 0
			//	todo: Pow(-Inf, y) = Pow(-0, -y)

			if ((y.bits & mask) == 0) {
				int32 res = one;
				int64 sqr = x.bits;
				int32 pow = (y.bits < 0 ? -y.bits : y.bits) >> precision;
				// todo: recheck overflow check
				for (;pow != 0;) {
					if ((pow & 1) != 0) {
						res = res * sqr >> precision;
					}
					sqr = sqr * sqr >> precision;
					if ((sqr >> 63) != (sqr >> 31)) {
						return bits(y.bits < 0 ? 0 : nan);
					}
					pow >>= 1;
				}
				return y.bits < 0 ? inv(bits(res)) : bits(res);
			}

			//	Pow(x, y) = NaN for finite x < 0 and finite non-integer y
			if (x.bits < 0) {
				return bits(nan);
			}

			// Pow(x, .5) = sqrt(x)
			if (y.bits == half) {
				return sqrt(x);
			}

			// pow(x, y) = exp(log(x) * y)
			return exp2(log2(x).mul(y));
		}
	}

	// trigonometry fixed point functions
	static if (precision <= 28) {
		enum: int32 {
			mpi_29: 0x6487ed51;                             // 3.141592653589793 : pi
			pi: mpi_29 >> (29 - precision);                 // pi: 3.141592653589793
			twoPi: mpi_29 >> (29 - precision - 1);          // 2 * pi
			halfPi: mpi_29 >> (29 - precision + 1);         // pi / 2
		}

		// evaluate a polynomial using horner's method
		static int64 poly_30(int64 x, int32 polynomial...) {
			int64 result = 0;
			for (int i = polynomial.length - 1; i >= 0; i -= 1) {
				result *= x;
				result += result & (1 << 29);
				result >>= 30;
				result += polynomial[i];
			}
			return result;
		}

		/// Converts the input to degrees from radians: $radians * 180 / pi$
		static Fixed32 degrees(Fixed32 radians) {
			int64 result = int64(radians.bits) * 180;
			static if (struct(Fixed32.overflow) == function) {
				if ((result >> 63) != (result >> 33) || radians.bits == nan) {
					return Fixed32.overflow(result, "degrees", radians);
				}
			}
			result = (result << 29) / mpi_29;
			static if (struct(Fixed32.overflow) == function) {
				if ((result >> 63) != (result >> 31)) {
					return Fixed32.overflow(result, "degrees", radians);
				}
			}

			return bits(result);
		}

		/// Converts the input to radians from degrees: $degrees * pi / 180$
		static Fixed32 radians(Fixed32 degrees) {
			int64 result = int64(degrees.bits) * mpi_29 / 180;
			result += result & (1 << 28);
			result >>= 29;
			static if (struct(Fixed32.overflow) == function) {
				if ((result >> 63) != (result >> 31) || degrees.bits == nan) {
					return Fixed32.overflow(result, "radians", degrees);
				}
			}
			return bits(result);
		}

		/// Returns the sine of the radian argument `x`
		// Special cases:
		//  * sin(0) = 0
		//  * sin(Inf) = NaN
		//  * sin(NaN) = NaN
		static Fixed32 sin(Fixed32 x) {
			if (x.bits == -x.bits) {
				// x.bits == 0 || x.bits == nan
				return x;
			}

			enum: int32 {
				/* old polynomial values:
				p0: (1 << 30) / +1;				// 1/1!
				p1: (1 << 30) / -6;				// 1/3!
				p2: (1 << 30) / +120;			// 1/5!
				p3: (1 << 30) / -5040;			// 1/7!
				p4: (1 << 30) / +362880;		// 1/9!
				p5: (1 << 30) / -39916800;		// 1/11!
				*/// new values adapted from: https://www.geometrictools.com/GTE/Mathematics/SinEstimate.h
				p0: (1 << 30) * +1.0;
				p1: (1 << 30) * -1.6666666601721269e-1;
				p2: (1 << 30) * +8.3333303183525942e-3;
				p3: (1 << 30) * -1.9840782426250314e-4;
				p4: (1 << 30) * +2.7521557770526783e-6;
				p5: (1 << 30) * -2.3828544692960918e-8;

				pi: mpi_29 >> 1;
				twoPi: mpi_29 >> 0;
				halfPi: mpi_29 >> 2;
			}

			int64 bits = int64(x.bits) << (28 - precision);
			bits %= twoPi;
			if (bits < 0) {
				bits += twoPi;
			}

			// x in [0, 2*pi)
			int32 sign = 1;
			if (bits >= pi) {
				bits -= pi;
				sign = -1;
			}

			// x in [0, pi)
			if (bits >= halfPi) {
				bits = pi - bits;
			}

			// x in [0, pi / 2)
			int64 xsq = bits * bits >> 2 * 28 - 30;
			int64 res = poly_30(xsq, p0, p1, p2, p3, p4, p5);
			res *= sign * bits;
			res += res & (1U << 57 - precision);
			return bits(res >> 58 - precision);
		}

		/// Returns the inverse sine of the radian argument `x`
		// Special cases:
		//  - asin(0) = 0
		//  * asin(x > 1) = NaN
		//  * asin(x < -1) = NaN
		//  * asin(NaN) = NaN
		//  - asin(1/2) = pi/6
		//  - asin(1) = pi/2
		// asin(x) = atan2(x, sqrt((1 + x) * (1 - x)))
		//  = 2 * atan(x / (1 + sqrt(1 - x * x)))
		static Fixed32 asin(Fixed32 x) {
			if (x.bits < -one || x.bits > one) {
				static if (struct(Fixed32.overflow) == function) {
					return Fixed32.overflow(0, "asin.args", x);
				}
				return bits(nan);
			}

			enum: int32 {
				// values adapted from: https://www.geometrictools.com/GTE/Mathematics/ACosEstimate.h
				p0: (1 << 30) * +1.5707963267948966;
				p1: (1 << 30) * -2.1458939285677325e-1;
				p2: (1 << 30) * +8.8784960563641491e-2;
				p3: (1 << 30) * -4.8887131453156485e-2;
				p4: (1 << 30) * +2.7011519960012720e-2;
				p5: (1 << 30) * -1.1210537323478320e-2;
				p6: (1 << 30) * +2.3078166879102469e-3;
			}

			int32 sign = 1;
			if (x.bits < 0) {
				x.bits = -x.bits;
				sign = -sign;
			}
			int64 res = x.bits << 30 - precision;
			res = poly_30(res, p0, p1, p2, p3, p4, p5, p6);
			x = sqrt(bits(one).sub(x));
			res = res * x.bits >> 30;
			return bits(sign * (halfPi - res));
		}

		/// Returns the hyperbolic sine of the radian argument `x`
		// Special cases:
		//  * sinh(0) = 0
		//  - sinh(Inf) = Inf
		//  * sinh(NaN) = NaN
		// sinh(x) = (exp(x) - exp(-x)) / 2
		static Fixed32 sinh(Fixed32 x) {
			if (x.bits == -x.bits) {
				// x.bits == 0 || x.bits == nan
				return x;
			}

			return sub(exp(x), exp(neg(x))).div(2);
		}

		/// Returns the inverse hyperbolic sine of the radian argument `x`
		// Special cases:
		//  * asinh(0) = 0
		//  - asinh(Inf) = Inf
		//  * asinh(NaN) = NaN
		// asinh(x) = log(x + sqrt(x * x + 1))
		static Fixed32 asinh(Fixed32 x) {
			if (x.bits == -x.bits) {
				// x.bits == 0 || x.bits == nan
				return x;
			}

			return ln(x.add(sqrt(madSat(x, x, bits(one)))));
		}


		/// Returns the cosine of the radian argument `x`
		// Special cases:
		//  * cos(Inf) = NaN
		//  * cos(NaN) = NaN
		//  - cos(0) = 1
		static Fixed32 cos(Fixed32 x) {
			if (x.bits == nan) {
				return x;
			}

			enum: int32 {
				/* old polynomial values:
				q0: (1 << 30) / +1;				// 1/0!
				q1: (1 << 30) / -2;				// 1/2!
				q2: (1 << 30) / +24;			// 1/4!
				q3: (1 << 30) / -720;			// 1/6!
				q4: (1 << 30) / +40320;			// 1/8!
				q5: (1 << 30) / -3628800;		// 1/10!
				q6: (1 << 30) / +479001600;		// 1/12!
				*/// new adapted from: https://www.geometrictools.com/GTE/Mathematics/CosEstimate.h
				q0: (1 << 30) * +1.0;
				q1: (1 << 30) * -4.9999999508695869e-1;
				q2: (1 << 30) * +4.1666638865338612e-2;
				q3: (1 << 30) * -1.3888377661039897e-3;
				q4: (1 << 30) * +2.4760495088926859e-5;
				q5: (1 << 30) * -2.6051615464872668e-7;

				pi: mpi_29 >> 1;
				twoPi: mpi_29 >> 0;
				halfPi: mpi_29 >> 2;
			}

			int64 bits = int64(x.bits) << (28 - precision);
			bits %= twoPi;
			if (bits < 0) {
				bits += twoPi;
			}

			// x in [0, 2*pi)
			if (bits > pi) {
				bits = twoPi - bits;
			}

			// x in [0, pi)
			int32 sign = 1;
			if (bits >= halfPi) {
				bits -= pi;
				sign = -1;
			}

			// x in [0, pi / 2)
			int64 xsq = bits * bits >> 2 * 28 - 30;
			int64 res = poly_30(xsq, q0, q1, q2, q3, q4, q5);
			res *= sign;
			res += res & (1 << 29 - precision);
			return bits(res >> (30 - precision));
		}

		/// Returns the inverse cosine of the radian argument `x`
		// Special cases:
		//  - acos(0) = pi/2
		//  * acos(x > 1) = NaN
		//  * acos(x < -1) = NaN
		//  * acos(NaN) = NaN
		//  - acos(1) = 0
		//  - acos(-1) = pi
		//  - acos(1/2) = pi/3
		//  - acos(-1/2) = 2*pi/3
		// acos(x) = atan2(sqrt((1 + x) * (1 - x)), x)
		//  = pi / 2 - asin(x)
		static Fixed32 acos(Fixed32 x) {
			if (x.bits < -one || x.bits > one) {
				static if (struct(Fixed32.overflow) == function) {
					return Fixed32.overflow(0, "acos.args", x);
				}
				return bits(nan);
			}

			enum: int32 {
				// values adapted from: https://www.geometrictools.com/GTE/Mathematics/ACosEstimate.h
				p0: (1 << 30) * +1.5707963267948966;
				p1: (1 << 30) * -2.1458939285677325e-1;
				p2: (1 << 30) * +8.8784960563641491e-2;
				p3: (1 << 30) * -4.8887131453156485e-2;
				p4: (1 << 30) * +2.7011519960012720e-2;
				p5: (1 << 30) * -1.1210537323478320e-2;
				p6: (1 << 30) * +2.3078166879102469e-3;
			}

			int32 shift = 0;
			int32 sign = 1;
			if (x.bits <= 0) {
				x.bits = -x.bits;
				shift = pi;
				sign = -1;
			}
			int64 res = x.bits << 30 - precision;
			res = poly_30(res, p0, p1, p2, p3, p4, p5, p6);
			x = sqrt(bits(one).sub(x));
			res = res * x.bits >> 30;
			return bits(shift + sign * res);
		}

		/// Returns the hyperbolic cosine of the radian argument `x`
		// Special cases:
		//  * cosh(0) = 1
		//  - cosh(Inf) = +Inf
		//  * cosh(NaN) = NaN
		// cosh(x) = (exp(x) + exp(-x)) / 2
		static Fixed32 cosh(Fixed32 x) {
			if (x.bits == -x.bits) {
				if (x.bits == 0) {
					return bits(one);
				}
				return x;
			}

			return add(exp(x), exp(neg(x))).div(2);
		}

		/// Returns the inverse hyperbolic cosine of the radian argument `x`
		// Special cases:
		//  * acosh(x < 1) = NaN
		//  - acosh(1) = 0
		//  - acosh(Inf) = Inf
		//  * acosh(NaN) = NaN
		// acosh(x) = log(x + sqrt(x * x - 1))
		static Fixed32 acosh(Fixed32 x) {
			if (x.bits < one) {
				// including nan
				return bits(nan);
			}

			return ln(x.add(sqrt(madSat(x, x, bits(-one)))));
		}


		/// Returns the tangent of the radian argument `x`
		// Special cases:
		//  * tan(0) = 0
		//  - tan(Inf) = NaN
		//  * tan(NaN) = NaN
		// tan(x) = sin(x) / cos(x)
		static Fixed32 tan(Fixed32 x) {
			if (x.bits == -x.bits) {
				// x.bits == 0 || x.bits == nan
				return x;
			}

			enum: int32 {
				q0: (1 << 30) / +1;				// 1/0!
				p0: (1 << 30) / +1;				// 1/1!
				q1: (1 << 30) / -2;				// 1/2!
				p1: (1 << 30) / -6;				// 1/3!
				q2: (1 << 30) / +24;			// 1/4!
				p2: (1 << 30) / +120;			// 1/5!
				q3: (1 << 30) / -720;			// 1/6!
				p3: (1 << 30) / -5040;			// 1/7!
				q4: (1 << 30) / +40320;			// 1/8!
				p4: (1 << 30) / +362880;		// 1/9!
				q5: (1 << 30) / -3628800;		// 1/10!
				p5: (1 << 30) / -39916800;		// 1/11!
				q6: (1 << 30) / +479001600;		// 1/12!
				p6: (1 << 30) / +6227020800;	// 1/13!

				pi: mpi_29 >> 1;
				twoPi: mpi_29 >> 0;
				halfPi: mpi_29 >> 2;
			}

			int64 bits = int64(x.bits) << (28 - precision);
			bits %= twoPi;
			if (bits < 0) {
				bits += twoPi;
			}

			// x in [0, 2*pi)
			int64 sin = bits;
			int64 cos = bits;
			int64 result = 1;
			if (bits >= pi) {
				sin = sin - pi;
				cos = twoPi - cos;
				result = -result;
			}

			// x in [0, pi)
			if (sin >= halfPi) {
				sin = pi - sin;
			}
			if (cos >= halfPi) {
				cos = cos - pi;
				result = -result;
			}

			// x in [0, pi / 2)
			int64 ssq = sin * sin >> 2 * 28 - 30;
			int64 csq = cos * cos >> 2 * 28 - 30;
			sin = sin * poly_30(ssq, p0, p1, p2, p3, p4, p5, p6);
			cos = poly_30(csq, q0, q1, q2, q3, q4, q5, q6);
			if (cos != 0) {
				result *= (sin >> 28 - precision) / cos;
			}

			static if (struct(Fixed32.overflow) == function) {
				if ((result >> 63) != (result >> 31)) {
					return Fixed32.overflow(result, "tan.result", x);
				}
			}
			return bits(result);
		}

		/// Returns the inverse tangent of the radian argument `x`
		// Special cases:
		//  * atan(0) = 0
		//  - atan(Inf) = pi/2
		//  * atan(NaN) = NaN
		//  - atan(1) = pi/4
		static Fixed32 atan(Fixed32 x) {
			if (x.bits == nan) {
				static if (struct(Fixed32.overflow) == function) {
					return Fixed32.overflow(0, "atan.args", x);
				}
				return x;
			}

			enum: int32 {
				// values adapted from: https://www.geometrictools.com/GTE/Mathematics/ATanEstimate.h
				p0: (1 << 30) * +1.0;
				p1: (1 << 30) * -3.3324998579202170e-1;
				p2: (1 << 30) * +1.9856563505717162e-1;
				p3: (1 << 30) * -1.3374657325451267e-1;
				p4: (1 << 30) * +8.1675882859940430e-2;
				p5: (1 << 30) * -3.5059680836411644e-2;
				p6: (1 << 30) * +7.2128853633444123e-3;
			}

			int32 sign = 1;
			int32 shift = 0;
			if (x.bits > one) {
				// return pi / 2 - atan(1 / x);
				x.bits = (int64(one) << precision) / x.bits;
				shift = pi / 2;
				sign = -1;
			}
			else if (x.bits < -one) {
				// return -pi / 2 - atan(1 / x);
				x.bits = (int64(one) << precision) / x.bits;
				shift = -pi / 2;
				sign = -1;
			}

			int64 xsq = x.bits * int64(x.bits);
			static if (precision >= 15) {
				xsq >>= 2 * precision - 30;
			} else {
				xsq <<= 30 - 2 * precision;
			}
			int64 res = poly_30(xsq, p0, p1, p2, p3, p4, p5, p6);
			return bits(shift + (sign * res * x.bits >> 30));
		}

		/// Returns the hyperbolic tangent of the radian argument `x`
		// Special cases:
		//  * tanh(0) = 0
		//  - tanh(Inf) = 1
		//  * tanh(NaN) = NaN
		// tanh(x) = sinh(x) / cosh(x)
		//  = (exp(x) - exp(-x)) / (exp(x) + exp(-x))
		//  = (exp(2 * x) - 1) / (exp(2 * x) + 1)
		//  = (1 - exp(-2*x)) / (exp(-2*x) - 1 + 2)
		//  = ...
		//  = 1 - 2 / (exp(2 * x) + 1)
		static Fixed32 tanh(Fixed32 x) {
			if (x.bits == -x.bits) {
				// x.bits == 0 || x.bits == nan
				return x;
			}

			// precision trick: calculate exp(-x)
			int32 sign = 1;
			if (x.bits > 0) {
				x.bits = -x.bits;
				sign = -1;
			}

			x = exp(x.mul(2));
			return div(x.add(-1), x.add(1)).mul(sign);
		}

		/// Returns the inverse hyperbolic tangent of the radian argument `x`
		// Special cases:
		//  - atanh(0) = 0
		//  - atanh(1) = Inf
		//  * atanh(x > 1) = NaN
		//  * atanh(x < -1) = NaN
		//  - atanh(Inf) = NaN
		//  * atanh(NaN) = NaN
		// atanh(x) = ln((1 + x) / (1 - x)) / 2
		// = -ln((1 - x) / (1 + x)) / 2
		static Fixed32 atanh(Fixed32 x) {
			if (x.bits <= -one || x.bits >= one) {
				return bits(nan);
			}

			if (x.bits > 0) {
				// better precision at division
				return ln(bits(one).sub(x).divSat(x.add(1))).div(-2);
			}
			return ln(x.add(1).divSat(bits(one).sub(x))).div(2);
		}


		/// Returns the secant of the radian argument `x`
		// sec(x) = 1 / cos(x)
		static Fixed32 sec(Fixed32 x) { return x.cos().inv(); }

		/// Returns the inverse secant of the radian argument `x`
		// Special cases:
		//  - asec(0) = Inf
		// asec(x) = acos(1 / x)
		static Fixed32 asec(Fixed32 x) {
			if (x.bits == 0) {
				return bits(nan);
			}
			return x.inv().acos();
		}

		/// Returns the hyperbolic secant of the radian argument `x`
		// sech(x) = 1 / cosh(x)
		static Fixed32 sech(Fixed32 x) { return x.cosh().inv(); }

		/// Returns the inverse hyperbolic secant of the radian argument `x`
		// Special cases:
		//  - asech(0) = Inf
		//  * asech(1) = 0
		// asech(x) = ln((sqrt(1 - x * x) + 1) / x)
		static Fixed32 asech(Fixed32 x) {
			if (x.bits == 0) {
				return bits(nan);
			}
			if (x.bits == one) {
				return bits(0);
			}
			return ln(sqrt(bits(one).sub(x.mul(x))).add(1).div(x));
		}


		/// Returns the cosecant of the radian argument `x`
		// csc(x) = 1 / sin(x)
		static Fixed32 csc(Fixed32 x) { return x.sin().inv(); }

		/// Returns the inverse cosecant of the radian argument `x`
		// Special cases:
		//  - acsc(0) = Inf
		// acsc(x) = asin(1 / x)
		static Fixed32 acsc(Fixed32 x) {
			if (x.bits == 0) {
				return bits(nan);
			}
			return x.inv().asin();
		}

		/// Returns the hyperbolic cosecant of the radian argument `x`
		// csch(x) = 1 / sinh(x)
		static Fixed32 csch(Fixed32 x) { return x.sinh().inv(); }

		/// Returns the inverse hyperbolic cosecant of the radian argument `x`
		// Special cases:
		//  - acsch(0) = Inf
		// acsch(x > 0) = ln((1 + sqrt(1 + x * x)) / x)
		// acsch(x < 0) = ln((1 - sqrt(1 + x * x)) / x)
		// = -acsch(-x)
		static Fixed32 acsch(Fixed32 x) {
			if (x.bits == 0) {
				return bits(nan);
			}
			if (x.bits < 0) {
				// using `-acsch(-x)` for precision
				x.bits = -x.bits;
				return neg(ln(bits(one).add(sqrt(madSat(x, x, bits(one)))).div(x)));
			}
			return ln(bits(one).add(sqrt(madSat(x, x, bits(one)))).div(x));
		}

		/// Returns the cotangent of the radian argument `x`
		// cot(x) = 1 / tan(x)
		static Fixed32 cot(Fixed32 x) { return x.tan().invSat(); }

		/// Returns the inverse cotangent of the radian argument `x`
		// Special cases:
		//  - acot(0) = pi / 2
		// acot(x) = atan(1 / x)
		static Fixed32 acot(Fixed32 x) {
			if (x.bits == 0) {
				return bits(halfPi);
			}
			return x.inv().atan();
		}

		/// Returns the hyperbolic cotangent of the radian argument `x`
		// coth(x) = 1 / tanh(x)
		static Fixed32 coth(Fixed32 x) { return x.tanh().inv(); }

		/// Returns the inverse hyperbolic cotangent of the radian argument `x`
		// Special cases:
		//  - acoth(1) = Inf
		// acoth(x) = ln((x + 1) / (x - 1)) / 2
		static Fixed32 acoth(Fixed32 x) {
			if (x.bits == one) {
				return bits(nan);
			}
			if (x.bits == -one) {
				return bits(nan);
			}
			return ln(x.add(1).divSat(x.add(-1))).div(2);
		}


		/*todo:/// Returns the inverse tangent of `y / x`
		static Fixed32 atan2(Fixed32 y, Fixed32 x) {
			// Special cases (in order):
			//  * atan2(y, NaN) = NaN
			//  * atan2(NaN, x) = NaN
			//  * atan2(+0, x>=0) = +0
			//  * atan2(-0, x>=0) = -0
			//  * atan2(+0, x<=-0) = +Pi
			//  * atan2(-0, x<=-0) = -Pi
			//  * atan2(y>0, 0) = +Pi/2
			//  * atan2(y<0, 0) = -Pi/2
			//  * atan2(+Inf, +Inf) = +Pi/4
			//  * atan2(-Inf, +Inf) = -Pi/4
			//  * atan2(+Inf, -Inf) = 3Pi/4
			//  * atan2(-Inf, -Inf) = -3Pi/4
			//  * atan2(y, +Inf) = 0
			//  * atan2(y>0, -Inf) = +Pi
			//  * atan2(y<0, -Inf) = -Pi
			//  * atan2(+Inf, x) = +Pi/2
			//  * atan2(-Inf, x) = -Pi/2
		}*/
	}
}

/// Convert the integer `value` to fixed-point value
Fixed32 Fixed32(int32 value) {
	int64 result = int64(value) << Fixed32.precision;
	static if (struct(Fixed32.overflow) == function) {
		if ((result >> 63) != (result >> 31)) {
			return Fixed32.overflow(result, "Fixed32", value);
		}
	}
	return { bits: result };
}

/// Convert the fixed point `value` to integer value
inline int32(Fixed32 value!) = value.bits >> Fixed32.precision;

/// Convert the floating point `value` to fixed-point value
Fixed32 Fixed32(float64 value) {
	static float64 max = float64(Fixed32.nan - 1) / Fixed32.one;

	int64 result = Float64.round(value * Fixed32.one);
	static if (struct(Fixed32.overflow) == function) {
		if (value > max || value < -max || value != value) {
		// if (result >> 63 != result >> 31) { int64(nan) == 0 on arm?
			return Fixed32.overflow(result, "Fixed32", value);
		}
	}
	return { bits: result };
}

/// Convert the fixed point `value` to floating point value
float64 float64(Fixed32 value) {
	if (value.bits == Fixed32.nan) {
		return Float64.nan;
	}
	return value.bits / float64(Fixed32.one);
}
/// 32 bit floating point struct and mathematical methods
static struct Float32 {
	// Some useful mathematical constants
	enum: float32 {
		nan: 0 / 0.;
		inf: 1 / 0.;

		pi: Float64.pi;
		e: Float64.e;
	}

	/// return the 32 bit floating point value as an integer
	static uint32 toBits(float32 value) { return inline(value); }

	/// return the 32 bit integer as a floating point value
	static float32 fromBits(uint32 value) { return inline(value); }

	/// Computes the largest integer value not greater than the input
	static float32 floor(float32 x) {
		float32 mod = x % 1;
		if (mod < 0) {
			mod += 1;
		}
		return x - mod;
	}

	/// Computes the smallest integer not less than the input
	inline ceil(float32 x) = -floor(-x);

	/// Computes the nearest integer to the input
	inline round(float32 x) = floor(x + .5f);

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float32 x) = int32(x > 0) - int32(x < 0);

	/// Returns the positive modulus of the input
	static float32 absMod(float32 val, float32 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}

	/// Returns the absolute value of the input
	inline abs(float32 x) = x < 0 ? -x : x;

	/// Returns the smaller value from the input values
	inline min(float32 a, float32 b) = a < b ? a : b;

	/// Returns the greater value from the input values
	inline max(float32 a, float32 b) = a > b ? a : b;

	/// Returns the `value` clamped between `min` and `max`
	inline clamp(float32 value, float32 min, float32 max) = min(max(value, min), max);

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline mix(float32 a, float32 b, float32 t) = a + t * (b - a);

	inline smoothstep(float32 t) = t * t * (3 - 2 * t);

	/// Returns the Hermite interpolation between two values
	inline smoothstep(float32 min, float32 max, float32 t) = smoothstep(clamp((t - min) / (max - min), 0f, 1f));


	/// Returns the natural logarithm of the argument `x`.
	static float32 ln(float32 x) {
		static if (preferNativeCalls && struct(float32.ln) != null) {
			// use the native method if available
			return float32.ln(x);
		}

		return float32(Float64.ln(float64(x)));
	}

	/// Returns the base-e exponential: $ e^x $.
	static float32 exp(float32 x) {
		static if (preferNativeCalls && struct(float32.exp) != null) {
			// use the native method if available
			return float32.exp(x);
		}

		return float32(Float64.exp(float64(x)));
	}

	/// Returns the base 2 logarithm of the argument `x`.
	static float32 log2(float32 x) {
		static if (preferNativeCalls && struct(float32.log2) != null) {
			// use the native method if available
			return float32.log2(x);
		}

		return float32(Float64.log2(float64(x)));
	}

	/// Returns the square root of the parameter `x`: $\sqrt{x}$.
	static float32 sqrt(float32 x) {
		static if (preferNativeCalls && struct(float32.sqrt) != null) {
			// use the native method if available
			return float32.sqrt(x);
		}

		return float32(Float64.sqrt(float64(x)));
	}

	/// Returns `x` raised to the power of `y`: $ x^y $.
	static float32 pow(float32 x, float32 y) {
		static if (preferNativeCalls && struct(float32.pow) != null) {
			// use the native method if available
			return float32.pow(x, y);
		}

		return float32(Float64.pow(float64(x), float64(y)));
	}


	/// Converts the input to radians from degrees.
	inline radians(float32 degrees) = degrees * pi / 180;

	/// Converts the input to degrees from radians.
	inline degrees(float32 radians) = radians * 180 / pi;

	/// Returns the sine of the radian argument `x`.
	static float32 sin(float32 x) {
		static if (preferNativeCalls && struct(float32.sin) != null) {
			// use the native method if available
			return float32.sin(x);
		}

		return float32(Float64.sin(float64(x)));
	}

	/// Returns the sine of the radian argument `x`.
	static float32 cos(float32 x) {
		static if (preferNativeCalls && struct(float32.cos) != null) {
			// use the native method if available
			return float32.cos(x);
		}

		return float32(Float64.cos(float64(x)));
	}

	/// Returns the tangent of the radian argument `x`.
	static float32 tan(float32 x) {
		static if (preferNativeCalls && struct(float32.tan) != null) {
			// use the native method if available
			return float32.tan(x);
		}

		return float32(Float64.tan(float64(x)));
	}

	/// Returns the inverse tangent of y/x.
	static float32 atan2(float32 y, float32 x) {
		static if (preferNativeCalls && struct(float32.atan2) != null) {
			// use the native method if available
			return float32.atan2(y, x);
		}

		return float32(Float64.atan2(float64(y), float64(x)));
	}

	/// Returns the inverse sine of the radian argument `x`.
	inline asin(float32 x) = atan2(x, sqrt((1 + x) * (1 - x)));

	/// Returns the inverse cosine of the radian argument `x`.
	inline acos(float32 x) = atan2(sqrt((1 + x) * (1 - x)), x);

	/// Returns the inverse tangent of the radian argument `x`.
	inline atan(float32 x) = atan2(x, 1);
}
/// 64 bit floating point struct and mathematical methods
static struct Float64 { // todo:  : static Arithmetic, static Comparable

	// Some useful mathematical constants
	enum: float64 {
		nan: 0 / 0.;
		inf: 1 / 0.;

		e: 2.71828182845904523536028747135266249775724709369995957496696763; // https://oeis.org/A001113
		pi: 3.14159265358979323846264338327950288419716939937510582097494459; // https://oeis.org/A000796
		phi: 1.61803398874989484820458683436563811772030917980576286213544862; // https://oeis.org/A001622

		sqrt2: 1.41421356237309504880168872420969807856967187537694807317667974; // https://oeis.org/A002193
		sqrtE: 1.64872127070012814684865078781416357165377610071014801157507931; // https://oeis.org/A019774
		sqrtPi: 1.77245385090551602729816748334114518279754945612238712821380779; // https://oeis.org/A002161
		sqrtPhi: 1.27201964951406896425242246173749149171560804184009624861664038; // https://oeis.org/A139339

		ln2: 0.693147180559945309417232121458176568075500134360255254120680009; // https://oeis.org/A002162
		log2E: 1 / ln2;
		ln10: 2.30258509299404568401799145468436420760110148862877297603332790; // https://oeis.org/A002392
		log10E: 1 / ln10;

		smallestNormal: 2.2250738585072014e-308; // 2**-1022
	}

	/// Determines whether the given floating point value is undefined: not-a-number
	static bool isUndefined(float64 x) {
		return x != x;
	}

	/// Determines whether the given floating point value is finite: `!isNan(x) && !isInf(x)`
	static bool isFinite(float64 x) {
		return x - x == 0;
	}

	/// Determines whether the given floating point value is infinity
	static bool isInfinity(float64 x) {
		return x != 0 && x == 2 * x;
	}

	static bool isPosInf(float64 x) {
		return x > 0 && x == 2 * x;
	}

	static bool isNegInf(float64 x) {
		return x < 0 && x == 2 * x;
	}

	/// return the 64 bit floating point value as an integer
	static uint64 toBits(float64 value) { return inline(value); }

	/// return the 64 bit integer as a floating point value
	static float64 fromBits(uint64 value) { return inline(value); }

	/// return the two 32 bit integers merged as a floating point value
	static float64 fromBits(uint32 hi, uint32 lo) { return fromBits((uint64(hi) << 32) | lo); }


	/// Computes the largest integer value not greater than the input
	static float64 floor(float64 x) {
		float64 mod = x % 1;
		if (mod < 0) {
			mod += 1;
		}
		return x - mod;
	}

	/// Computes the smallest integer not less than the input
	static float64 ceil(float64 x) {
		return -floor(-x);
	}

	/// Computes the nearest integer to the input
	static float64 round(float64 x) {
		return floor(x + .5);
	}


	/// Returns the positive modulus of the input
	static float64 absMod(float64 val, float64 mod) {
		if ((val %= mod) < 0) {
			return val + mod;
		}
		return val;
	}


	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(float64 x) = int32(x > 0) - int32(x < 0);

	/// Returns the absolute value of the input
	static float64 abs(float64 x) {
		return x < 0 ? -x : x;
	}

	/// Compute least significant bit (Unit in Last Position) for a number.
	static float64 ulp(float64 x) {
		if (isInfinity(x)) {
			return inf;
		}
		return abs(x - fromBits(toBits(x) ^ 1));
	}

	/// Returns the smaller value from the input values
	inline min(float64 a, float64 b) = a < b ? a : b;

	/// Returns the greater value from the input values
	inline max(float64 a, float64 b) = a > b ? a : b;

	/// Returns the `value` clamped between `min` and `max`
	inline clamp(float64 value, float64 min, float64 max) = min(max(value, min), max);

	/// Returns the linear interpolation between `a` and `b` by `t`
	inline mix(float64 a, float64 b, float64 t) = a + t * (b - a);

	inline smoothstep(float64 t) = t * t * (3 - 2 * t);

	/// Returns the Hermite interpolation between two values
	inline smoothstep(float64 min, float64 max, float64 t) = smoothstep(clamp((t - min) / (max - min), 0F, 1F));

	/// Returns the smaller value from the input values
	static float64 min(float64 values...) {
		if (values.length == 0) {
			return nan;
		}
		float64 result = values[0];
		for (int i = 1; i < values.length; i += 1) {
			if (result > values[i]) {
				result = values[i];
			}
		}
		return result;
	}

	/// Returns the greater value from the input values
	static float64 max(float64 values...) {
		if (values.length == 0) {
			return nan;
		}
		float64 result = values[0];
		for (int i = 1; i < values.length; i += 1) {
			if (result < values[i]) {
				result = values[i];
			}
		}
		return result;
	}

	/// Returns the sum of the input values
	static float64 sum(float64 values...) {
		float64 result = 0;
		for (int i = 0; i < values.length; i += 1) {
			result += values[i];
		}
		return result;
	}

	/// Returns the mean of the input values
	static float64 mean(float64 values...) {
		return sum(...values) / values.length;
	}

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1) = a1 * x + a0;

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2) = eval(x, a1, a2) * x + a0;

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3) = eval(x, a1, a2, a3) * x + a0;

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3, float64 a4) = eval(x, a1, a2, a3, a4) * x + a0;

	/// Return the polynomial evaluated at x using Horner's algorithm
	inline eval(float64 x, float64 a0, float64 a1, float64 a2, float64 a3, float64 a4, float64 a5) = eval(x, a1, a2, a3, a4, a5) * x + a0;

	/// Return the polynomial evaluated at x using Horner's algorithm
	static float64 eval(float64 x, float64 polynomial...) {
		float64 result = 0;
		for (int i = polynomial.length - 1; i >= 0; i -= 1) {
			result = result * x + polynomial[i];
		}
		return result;
	}

	/// Decompose a value into integer and fractional parts
	static float64 modf(float64 x, float64 intPart&) {
		if (x < 1) {
			if (x < 0) {
				float64 result = modf(-x, &intPart);
				intPart = -intPart;
				return -result;
			}
			intPart = 0;
			return x;
		}
		float64 result = x % 1;
		intPart = x - result;
		return result;
	}

	static float64 copysign(float64 x, float64 y) {
		uint64 sign = toBits(y) & (1U << 63);
		uint64 val = toBits(x) & ~(1U << 63);
		return fromBits(sign | val);
	}

// pow

	/** Frexp breaks f into a normalized fraction and an integral power of two.
	 * It returns frac and exp satisfying f == frac  2**exp,
	 * with the absolute value of frac in the interval [, 1).
	 *
	 * Special cases are:
	 *   * Frexp(0) = 0, 0
	 *   * Frexp(Inf) = Inf, 0
	 *   * Frexp(NaN) = NaN, 0
	 */
	// adapted from: https://github.com/golang/go/blob/master/src/math/frexp.go
	static float64 frexp(float64 f, int32 exp&) {
		static if (preferNativeCalls && struct(float64.frexp) != null) {
			// use the native method if available
			return float64.frexp(f, &exp);
		}
		inline mask     = 0x7FFU;
		inline shift    = 64 - 11 - 1;
		inline bias     = 1023;
		inline signMask = 1U << 63;
		inline fracMask = 1U << shift - 1;

		// special cases
		if (f == 0) {
			exp = 0;
			return f;
		}
		if (isInfinity(f) || isUndefined(f)) {
			exp = 0;
			return f;
		}

		if (abs(f) < smallestNormal) {
			// normalize
			f *= 1 << 52;
			exp -= 52;
		} else {
			exp = 0;
		}

		uint64 x = toBits(f);
		exp += int32((x >> shift) & mask) - bias + 1;
		x &= ~(mask << shift);
		x |= (-1U + bias) << shift;
		return fromBits(x);
	}

	/** Ldexp is the inverse of Frexp.
	 * It returns frac  2**exp.
	 *
	 * Special cases are:
	 *	 * Ldexp(0, exp) = 0
	 *	 * Ldexp(Inf, exp) = Inf
	 *	 * Ldexp(NaN, exp) = NaN
	 */
	// adapted from: https://github.com/golang/go/blob/master/src/math/ldexp.go
	static float64 ldexp(float64 f, int32 exp) {
		static if (preferNativeCalls && struct(float64.ldexp) != null) {
			// use the native method if available
			return float64.ldexp(f, exp);
		}
		inline mask     = 0x7FFU;
		inline shift    = 64 - 11 - 1;
		inline bias     = 1023;
		inline signMask = 1U << 63;
		inline fracMask = 1U << shift - 1;

		// special cases
		if (f == 0) {
			// correctly return -0
			return f;
		}
		if (f != f || f - f != 0) {
			// not a number or non finite number
			return f;
		}

		if (abs(f) < smallestNormal) {
			// normalize
			f *= 1 << 52;
			exp -= 52;
		}

		uint64 x = toBits(f);
		exp += (int32(x >> shift) & mask) - bias;

		if (exp < -1075) {
			// trace("underflow", exp);
			return copysign(0., f);
		}
		if (exp > 1023) {
			// trace("overflow", exp);
			return copysign(inf, f);
		}
		float64 m = 1;
		if (exp < -1022) {
			// denormal
			exp += 53;
			m = 1 / float64(1 << 53); // 2**-53
		}
		x &= ~(mask << shift);
		x |= uint64(exp+bias) << shift;
		return m * fromBits(x);
	}

	/// Returns the natural logarithm of the argument `x`.
	// adapted from: https://github.com/golang/go/blob/master/src/math/log.go
	static float64 ln(float64 x) {
		static if (preferNativeCalls && struct(float64.ln) != null) {
			// use the native method if available
			return float64.ln(x);
		}

		enum: float64 {
			Ln2Hi : 6.93147180369123816490e-01; // 3fe62e42 fee00000
			Ln2Lo : 1.90821492927058770002e-10; // 3dea39ef 35793c76
			L1    : 6.666666666666735130e-01;   // 3FE55555 55555593
			L2    : 3.999999999940941908e-01;   // 3FD99999 9997FA04
			L3    : 2.857142874366239149e-01;   // 3FD24924 94229359
			L4    : 2.222219843214978396e-01;   // 3FCC71C5 1D8E78AF
			L5    : 1.818357216161805012e-01;   // 3FC74664 96CB03DE
			L6    : 1.531383769920937332e-01;   // 3FC39A09 D078C69F
			L7    : 1.479819860511658591e-01;   // 3FC2F112 DF3E5244
		}

		// special cases
		if (isUndefined(x) || isPosInf(x)) {
			return x;
		}
		if (x < 0) {
			return Float64.nan;
		}
		if (x == 0) {
			return -Float64.inf;
		}

		// reduce
		int32 ki;
		float64 f1 = frexp(x, &ki);
		if (f1 < sqrt2 / 2) {
			f1 *= 2;
			ki -= 1;
		}
		float64 f = f1 - 1;
		float64 k = float64(ki);

		// compute
		float64 s = f / (2 + f);
		float64 s2 = s * s;
		float64 s4 = s2 * s2;
		float64 t1 = s2 * (L1 + s4 * (L3 + s4 * (L5 + s4 * L7)));
		float64 t2 = s4 * (L2 + s4 * (L4 + s4 * L6));
		float64 R = t1 + t2;
		float64 hfsq = 0.5 * f * f;
		return k * Ln2Hi - ((hfsq - (s * (hfsq + R) + k * Ln2Lo)) - f);
	}

	/// Returns the base-e exponential: $ e^x $.
	// adapted from: https://github.com/golang/go/blob/master/src/math/exp.go
	static float64 exp(float64 x) {
		static if (preferNativeCalls && struct(float64.exp) != null) {
			// use the native method if available
			return float64.exp(x);
		}

		// exp1 returns e**r  2**k where r = hi - lo and |r|  ln(2)/2.
		float64 expmulti(float64 hi, float64 lo, int32 k) {
			enum: float64 {
				P1:  1.66666666666666657415e-01;  // 0x3FC55555; 0x55555555
				P2: -2.77777777770155933842e-03; // 0xBF66C16C; 0x16BEBD93
				P3:  6.61375632143793436117e-05;  // 0x3F11566A; 0xAF25DE2C
				P4: -1.65339022054652515390e-06; // 0xBEBBBD41; 0xC5D26BF1
				P5:  4.13813679705723846039e-08;  // 0x3E663769; 0x72BEA4D0
			}

			float64 r = hi - lo;
			float64 t = r * r;
			float64 c = r - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));
			float64 y = 1 - ((lo - (r * c) / (2 - c)) - hi);
			// TODO(rsc): make sure Ldexp can handle boundary k
			return ldexp(y, k);
		}
		enum: float64 {
			Ln2Hi: 6.93147180369123816490e-01;
			Ln2Lo: 1.90821492927058770002e-10;
			Log2e: 1.44269504088896338700e+00;

			Overflow : 7.09782712893383973096e+02;
			Underflow: -7.45133219101941108420e+02;
			NearZero : 1.0 / (1 << 28); // 2**-28
		}

		// special cases
		if (isUndefined(x) || isPosInf(x)) {
			return x;
		}
		if (isNegInf(x)) {
			return 0;
		}
		if (x > Overflow) {
			return Float64.inf;
		}
		if (x < Underflow) {
			return 0;
		}
		if (-NearZero < x && x < NearZero) {
			return 1 + x;
		}

		// reduce; computed as r = hi - lo for extra precision.
		int32 k = 0;
		if (x < 0) {
			k = Log2e * x - .5;
		}
		if (x > 0) {
			k = Log2e * x + .5;
		}
		float64 hi = x - k * Ln2Hi;
		float64 lo = k * Ln2Lo;

		// compute
		return expmulti(hi, lo, k);
	}

	/// Returns the base-2 logarithm of the argument `x`.
	static float64 log2(float64 x) {
		static if (preferNativeCalls && struct(float64.log2) != null) {
			// use the native method if available
			return float64.log2(x);
		}
		return ln(x) / ln2;
	}

	///	Returns the base-2 exponential of the argument `x`.
	static float64 exp2(float64 x) {
		static if (preferNativeCalls && struct(float64.exp2) != null) {
			// use the native method if available
			return float64.exp2(x);
		}
		return exp(x * ln2);
	}

	/// Returns the base-10 logarithm of the argument `x`.
	static float64 log10(float64 x) {
		return ln(x) / ln10;
	}

	/// Returns the logarithm of the specified `base` of the argument `x`.
	static float64 log(float64 x, float64 base) {
		return ln(x) / ln(base);
	}

	/// Returns the square root of the parameter `x`: $\sqrt{x}$.
	// adapted from: https://github.com/golang/go/blob/master/src/math/sqrt.go
	static float64 sqrt(float64 x) {
		static if (preferNativeCalls && struct(float64.sqrt) != null) {
			// use the native method if available
			return float64.sqrt(x);
		}

		// Special cases are:
		//   * Sqrt(+Inf) = +Inf
		//   * Sqrt(0) = 0
		//   * Sqrt(x < 0) = NaN
		//   * Sqrt(NaN) = NaN

		if (x == 0 || x.isUndefined() || isPosInf(x)) {
			return x;
		}
		if (x < 0) {
			return nan;
		}

		inline mask     = 0x7FFU;
		inline shift    = 64 - 11 - 1;
		inline bias     = 1023;

		uint64 ix = toBits(x);
		// normalize x
		int32 exp = int32((ix >> shift) & mask);
		if (exp == 0) { // subnormal x
			for (;(ix & (1U << shift)) == 0;) {
				ix <<= 1;
				exp -= 1;
			}
			exp += 1;
		}
		exp -= bias; // unbias exponent
		ix &= ~(mask << shift);
		ix |= 1U << shift;
		if ((exp & 1) == 1) { // odd exp, double x to make it even
			ix <<= 1;
		}
		exp >>= 1; // exp = exp/2, exponent of square root
		// generate sqrt(x) bit by bit
		ix <<= 1;
		uint64 s = 0;
		uint64 q = 0;               // q = sqrt(x)
		uint64 r = 1U << (shift + 1); // r = moving bit from MSB to LSB
		for (;r != 0;) {
			uint64 t = s + r;
			if (t <= ix) {
				s = t + r;
				ix -= t;
				q += r;
			}
			ix <<= 1;
			r >>= 1;
		}
		// final rounding
		if (ix != 0) { // remainder, result not exact
			q += q & 1; // round according to extra bit
		}
		ix = (q >> 1) + (uint64(exp - 1 + bias) << shift); // significand + biased exponent
		return fromBits(ix);
	}


	/// Returns `x` raised to the power of `y`: $ x^y $.
	// adapted from: https://github.com/golang/go/blob/master/src/math/pow.go
	static float64 pow(float64 x, float64 y) {
		static if (preferNativeCalls && struct(float64.pow) != null) {
			// use the native method if available
			return float64.pow(x, y);
		}

		bool isOddInt(float64 x) {
			if (abs(x) >= (1D << 53)) {
				// 1 << 53 is the largest exact integer in the float64 format.
				// Any number outside this range will be truncated before the decimal point and therefore will always be
				// an even integer.
				// Without this check and if x overflows int64 the int64(xi) conversion below may produce incorrect results
				// on some architectures (and does so on arm64). See issue #57465.
				return false;
			}
			float64 xi;
			float64 xf = modf(x, &xi);
			return xf == 0 && (int64(xi) & 1) == 1;
		}

		if (y == 0 || x == 1) {
			return 1;
		}
		if (y == 1) {
			return x;
		}
		if (isUndefined(x) || isUndefined(y)) {
			return nan;
		}
		if (x == 0) {
			if (y < 0) {
				if (isOddInt(y)) {
					return copysign(inf, x);
//					return x < 0 ? -inf : inf;
				}
				return inf;
			}
			if (y > 0) {
				if (isOddInt(y)) {
					return x;
				}
				return 0;
			}
		}
		if (isInfinity(y)) {
			if (x == -1) {
				return 1;
			}
			if ((abs(x) < 1) == isPosInf(y)) {
				return 0;
			}
			return inf;
		}
		if (isInfinity(x)) {
			if (isNegInf(x)) {
				return pow(1 / x, -y); // Pow(-0, -y)
			}
			if (y < 0) {
				return 0;
			}
			if (y > 0) {
				return inf;
			}
		}
		if (y == 0.5) {
			return sqrt(x);
		}
		if (y == -0.5) {
			return 1 / sqrt(x);
		}

		float64 yi;
		float64 yf = modf(abs(y), &yi);
		if (yf != 0 && x < 0) {
			return nan;
		}

		if (yi >= 2.*(1D << 62)) { // 1<<63
			// yi is a large even int that will lead to overflow (or underflow to 0)
			// for all x except -1 (x == 1 was handled earlier)
			if (x == -1) {
				return 1;
			}
			if ((abs(x) < 1) == (y > 0)) {
				return 0;
			}
			return inf;
		}

		// ans = a1 * 2**ae (= 1 for now).
		float64 a1 = 1;
		int32 ae = 0;

		// ans *= x**yf
		if (yf != 0) {
			if (yf > 0.5) {
				yf -= 1;
				yi += 1;
			}
			a1 = exp(yf * ln(x));
		}

		// ans *= x**yi
		// by multiplying in successive squarings
		// of x according to bits of yi.
		// accumulate powers of two into exp.
		int32 xe;
		float64 x1 = frexp(x, &xe);
		for (int64 i = yi; i != 0; i >>= 1) {
			if (xe < -1<<12 || 1<<12 < xe) {
				// catch xe before it overflows the left shift below
				// Since i !=0 it has at least one bit still set, so ae will accumulate xe
				// on at least one more iteration, ae += xe is a lower bound on ae
				// the lower bound on ae exceeds the size of a float64 exp
				// so the final call to Ldexp will produce under/overflow (0/Inf)
				ae += xe;
				break;
			}
			if ((i & 1) == 1) {
				a1 *= x1;
				ae += xe;
			}
			x1 *= x1;
			xe <<= 1;
			if (x1 < .5) {
				x1 += x1;
				xe -= 1;
			}
		}

		// ans = a1*2**ae
		// if y < 0 { ans = 1 / ans }
		// but in the opposite order
		if (y < 0) {
			a1 = 1 / a1;
			ae = -ae;
		}
		return ldexp(a1, ae);
	}

// trig

	/// Converts the input to radians from degrees.
	inline radians(float64 degrees) = float64(degrees * pi / 180);

	/// Converts the input to degrees from radians.
	inline degrees(float64 radians) = float64(radians * 180 / pi);


	// adapted from: https://9p.io/sources/plan9/sys/src/libc/port/sin.c
	static float64 sincos(float64 x, int32 quad) {
		enum: float64 {
			p0: .1357884097877375669092680e8;
			p1: -.4942908100902844161158627e7;
			p2: .4401030535375266501944918e6;
			p3: -.1384727249982452873054457e5;
			p4: .1459688406665768722226959e3;
			q0: .8644558652922534429915149e7;
			q1: .4081792252343299749395779e6;
			q2: .9463096101538208180571257e4;
			q3: .1326534908786136358911494e3;
		}

		if (x < 0) {
			x = -x;
			quad += 2;
		}

		float64 y;
		x *= 2 / pi;	/* underflow? */
		if (x > 32764) {
			float64 e;
			y = modf(x, &e);
			e += quad;

			float64 f;
			modf(0.25 * e, &f);
			quad = e - 4 * f;
		} else {
			int32 k = x;
			y = x - k;
			quad += k;
			quad &= 3;
		}
		if (quad & 1) {
			y = 1 - y;
		}
		if (quad > 1) {
			y = -y;
		}

		float64 ysq = y * y;
		float64 p = y * eval(ysq, p0, p1, p2, p3, p4);
		float64 q = eval(ysq, q0, q1, q2, q3 + ysq);
		return p / q;
	}

	// adapted from: https://github.com/jeremybarnes/cephes/blob/master/cmath/tan.c
	static float64 tancot(float64 x, int32 flag) {
		enum: float64 {
			dp1: 7.853981554508209228515625E-1;
			dp2: 7.94662735614792836714E-9;
			dp3: 3.06161699786838294307E-17;

			p0: -1.30936939181383777646e4;
			p1: 1.15351664838587416140e6;
			p2: -1.79565251976484877988e7;

			q0: 1.00000000000000000000e0;
			q1: 1.36812963470692954678e4;
			q2: -1.32089234440210967447e6;
			q3: 2.50083801823357915839e7;
			q4: -5.38695755929454629881e7;

			lossth: 1.073741824e9;
		}

		/* make argument positive but save the sign */
		float64 sign = 1;
		if (x < 0) {
			x = -x;
			sign = -1;
		}

		if (x > lossth) {
			//error("total loss of precision");
			return 0;
		}

		/* compute x mod PIO4 */
		float64 y = floor(x / (pi / 4));

		/* strip high bits of integer part */
		float64 z = ldexp(y, -3);
		z = floor(z);        /* integer part of y/8 */
		z = y - ldexp(z, 3);  /* y - 16 * (y/16) */

		/* integer and fractional part modulo one octant */
		int32 j = z;

		/* map zeros and singularities to origin */
		if (j & 1) {
			j += 1;
			y += 1.0;
		}

		z = ((x - y * dp1) - y * dp2) - y * dp3;

		float64 zz = z * z;
		if (zz > 1.0e-14) {
			y = z + z * (zz * eval(zz, p2, p1, p0) / eval(zz, q4, q3, q2, q1, q0));
		} else {
			y = z;
		}

		if (j & 2) {
			if (flag) {
				y = -y;
			} else {
				y = -1 / y;
			}
		} else {
			if (flag) {
				y = 1 / y;
			}
		}

		return sign * y;
	}

	/// Returns the inverse tangent of `y / x`.
	// adapted from: https://9p.io/sources/plan9/sys/src/libc/port/atan.c
	// adapted from: https://9p.io/sources/plan9/sys/src/libc/port/atan2.c
	static float64 atan2(float64 y, float64 x) {
		static if (preferNativeCalls && struct(float64.atan2) != null) {
			// use the native method if available
			return float64.atan2(y, x);
		}

		if (y + x == y) {
			if (y >= 0) {
				return pi / 2;
			}
			return -pi / 2;
		}

		enum: float64 {
			sq2p1: 2.414213562373095048802e0;
			sq2m1: .414213562373095048802e0;

			p4: .161536412982230228262e2;
			p3: .26842548195503973794141e3;
			p2: .11530293515404850115428136e4;
			p1: .178040631643319697105464587e4;
			p0: .89678597403663861959987488e3;

			q4: .5895697050844462222791e2;
			q3: .536265374031215315104235e3;
			q2: .16667838148816337184521798e4;
			q1: .207933497444540981287275926e4;
			q0: .89678597403663861962481162e3;
		}

		// xatan evaluates a series valid in the range [-0.414...,+0.414...]. (tan(pi/8))
		float64 xatan(float64 x) {
			float64 z = x * x;
			float64 p = eval(z, p0, p1, p2, p3, p4);
			float64 q = eval(z, q0, q1, q2, q3, q4 + z);
			return p / q * x;
		}

		// satan reduces its argument (known to be positive) to the range [0,0.414...] and calls xatan.
		float64 satan(float64 x) {
			if (x < sq2m1) {
				return xatan(x);
			}
			if (x > sq2p1) {
				return pi / 2 - xatan(1 / x);
			}
			return pi / 4 + xatan((x - 1) / (x + 1));
		}

		y = y / x;
		if (y <= 0) {
			y = -satan(-y);
			if (x < 0) {
				y += pi;
			}
		} else {
			y = satan(y);
			if (x < 0) {
				y -= pi;
			}
		}

		return y;
	}


	/// Returns the sine of the radian argument `x`.
	static float64 sin(float64 x) {
		static if (preferNativeCalls && struct(float64.sin) != null) {
			// use the native method if available
			return float64.sin(x);
		}

		return sincos(x, 0);
	}

	/// Returns the inverse sine of the radian argument `x`.
	static float64 asin(float64 x) {
		static if (preferNativeCalls && struct(float64.asin) != null) {
			// use the native method if available
			return float64.asin(x);
		}
		return atan2(x, sqrt((1 + x) * (1 - x)));
	}

	/// Returns the hyperbolic sine of the radian argument `x`.
	static float64 sinh(float64 x) {
		static if (preferNativeCalls && struct(float64.sinh) != null) {
			// use the native method if available
			return float64.sinh(x);
		}

		if (x == 0) {
			return 0;
		}
		return (exp(x) - exp(-x)) / 2;
	}

	/// Returns the inverse hyperbolic sine of the radian argument `x`.
	static float64 asinh(float64 x) {
		return ln(x + sqrt(x * x + 1));
	}


	/// Returns the cosine of the radian argument `x`.
	static float64 cos(float64 x) {
		static if (preferNativeCalls && struct(float64.cos) != null) {
			// use the native method if available
			return float64.cos(x);
		}

		if (x < 0) {
			x = -x;
		}
		return sincos(x, 1);
	}

	/// Returns the inverse cosine of the radian argument `x`.
	static float64 acos(float64 x) {
		static if (preferNativeCalls && struct(float64.acos) != null) {
			// use the native method if available
			return float64.acos(x);
		}
		return atan2(sqrt((1 + x) * (1 - x)), x);
	}

	/// Returns the hyperbolic cosine of the radian argument `x`.
	static float64 cosh(float64 x) {
		static if (preferNativeCalls && struct(float64.cosh) != null) {
			// use the native method if available
			return float64.cosh(x);
		}

		if (x == 0) {
			return 1;
		}
		return (exp(x) + exp(-x)) / 2;
	}

	/// Returns the inverse hyperbolic cosine of the radian argument `x`.
	static float64 acosh(float64 x) {
		//return ln(x + sqrt((x - 1) / (x + 1)) * (x + 1));
		return ln(x + sqrt(x * x - 1));
	}


	/// Returns the tangent of the radian argument `x`.
	static float64 tan(float64 x) {
		static if (preferNativeCalls && struct(float64.tan) != null) {
			// use the native method if available
			return float64.tan(x);
		}

		if (x == 0) {
			return x;
		}
		if (x != x) {
			// nan
			return x;
		}
		if (x == 2 * x) {
			// infinity
			return nan;
		}

		return tancot(x, 0);
	}

	/// Returns the inverse tangent of the radian argument `x`.
	static float64 atan(float64 x) {
		static if (preferNativeCalls && struct(float64.atan) != null) {
			// use the native method if available
			return float64.atan(x);
		}
		return atan2(x, 1);
	}

	/// Returns the hyperbolic tangent of the radian argument `x`.
	static float64 tanh(float64 x) {
		static if (preferNativeCalls && struct(float64.tanh) != null) {
			// use the native method if available
			return float64.tanh(x);
		}
		return 1 - 2 / (exp(2 * x) + 1);
	}

	/// Returns the inverse hyperbolic tangent of the radian argument `x`.
	static float64 atanh(float64 x) {
		if (x >= 1) {
			return inf;
		}
		if (x <= -1) {
			return -inf;
		}
		return ln((1 + x) / (1 - x)) / 2;
	}


	/// Returns the secant of the radian argument `x`.
	static float64 sec(float64 x) {
		return 1 / cos(x);
	}

	/// Returns the inverse secant of the radian argument `x`.
	static float64 asec(float64 x) {
		if (x == 0) {
			return inf;
		}
		return acos(1 / x);
	}

	/// Returns the hyperbolic secant of the radian argument `x`.
	static float64 sech(float64 x) {
		return 1 / cosh(x);
	}

	/// Returns the inverse hyperbolic secant of the radian argument `x`.
	static float64 asech(float64 x) {
		if (x == 0) {
			return inf;
		}
		if (x == 1) {
			return 0;
		}
		return ln((sqrt(1 - x * x) + 1) / x);
	}


	/// Returns the cosecant of the radian argument `x`.
	static float64 csc(float64 x) {
		return 1 / sin(x);
	}

	/// Returns the inverse cosecant of the radian argument `x`.
	static float64 acsc(float64 x) {
		if (x == 0) {
			return inf;
		}
		return asin(1 / x);
	}

	/// Returns the hyperbolic cosecant of the radian argument `x`.
	static float64 csch(float64 x) {
		return 1 / sinh(x);
	}

	/// Returns the inverse hyperbolic cosecant of the radian argument `x`.
	static float64 acsch(float64 x) {
		if (x == 0) {
			return inf;
		}
		if (x < 0) {
			return ln((1 - sqrt(1 + x * x)) / x);
		}
		return ln((1 + sqrt(1 + x * x)) / x);
	}


	/// Returns the cotangent of the radian argument `x`.
	static float64 cot(float64 x) {
		if (x == 0) {
			return inf;
		}
		return tancot(x, 1);
	}

	/// Returns the inverse cotangent of the radian argument `x`.
	static float64 acot(float64 x) {
		if (x == 0) {
			return pi / 2;
		}
		return atan(1 / x);
	}

	/// Returns the hyperbolic cotangent of the radian argument `x`.
	static float64 coth(float64 x) {
		return 1 / tanh(x);
	}

	/// Returns the inverse hyperbolic cotangent of the radian argument `x`.
	static float64 acoth(float64 x) {
		if (x == 1) {
			return inf;
		}
		if (x == -1) {
			return -inf;
		}
		return ln((x + 1) / (x - 1)) / 2;
	}
}
/// 16-bit unsigned integer operations
static struct Uint16 {
	enum {
		bits: 16;
		min: 0x0000;
		max: 0xffff;
	}

	/// Computes the bitwise NOT of an 16-bit unsigned value
	uint16 cmt(uint16 x) { return inline(uint32(x), u32.cmt); }

	/// Computes the bitwise OR of two 16-bit unsigned integers
	uint16 or(uint16 x, uint16 y) { return inline(uint32(x), uint32(y), u32.or); }

	/// Computes the bitwise XOR of two 16-bit unsigned integers
	uint16 xor(uint16 x, uint16 y) { return inline(uint32(x), uint32(y), u32.xor); }

	/// Computes the bitwise AND of two 16-bit unsigned integers
	uint16 and(uint16 x, uint16 y) { return inline(uint32(x), uint32(y), u32.and); }

	/// Performs a logical right shift of x by n bits for an 16-bit unsigned integer
	uint16 shr(uint16 x, uint32 n) { return inline(uint32(x), uint32(n), u32.shr); }

	/// Performs a logical left shift of x by n bits for an 16-bit unsigned integer
	uint16 shl(uint16 x, uint32 n) { return inline(uint32(x), uint32(n), u32.shl); }

	/// Returns the signum of the input (`0` if zero, `1` if positive)
	int32 sign(uint16 x) { return int32(x > 0); }

	/// Returns the absolute value of the input
	uint16 abs(uint16 x) { return x; }

	/// Returns the smaller value from the input values
	uint16 min(uint16 a, uint16 b) { return a < b ? a : b; }

	/// Returns the greater value from the input values
	uint16 max(uint16 a, uint16 b) { return a > b ? a : b; }

	/// Returns the `value` clamped between the provided `min` and `max`
	uint16 clamp(uint16 value, uint16 min, uint16 max) { return min(max(value, min), max); }

	/// Extract and zero-extends a bit field from a byte value
	uint16 zeroExtend(uint16 value, int32 offs, int32 size) {
		return uint32(uint32(value) << (bits - (offs + size))) >> (bits - size);
	}

	/// Adds two 16-bit unsigned integers with carry out
	uint16 add(uint16 x, uint16 y, uint16 overflow&) {
		uint32 result = uint32(x) + uint32(y);
		overflow = result >> bits;
		return result;
	}

	/// Subtracts two 16-bit unsigned integers with borrow out
	uint16 sub(uint16 x, uint16 y, uint16 overflow&) {
		uint32 result = uint32(x) - uint32(y);
		overflow = result >> bits;
		return result;
	}

	/// Multiplies two 16-bit unsigned integers with overflow out
	uint16 mul(uint16 x, uint16 y, uint16 overflow&) {
		uint32 result = uint32(x) * uint32(y);
		overflow = result >> bits;
		return result;
	}

	/// Compares two 16-bit unsigned integers
	int32 compare(uint16 x, uint16 y) {
		return uint32(x) - uint32(y);
	}

	/// Returns the minimum number of bits required to represent the value of `x`
	int32 length(uint16 x) {
		static if (preferNativeCalls && struct(uint32.len) != null) {
			// use the native method if available
			return uint32.len(x);
		}

		uint32 bits = x;	// speed up by by avoiding load and store indirect memory
		int32 result = 0;

		if ((bits >> 8) != 0) {
			result += 8;
			bits >>= 8;
		}
		if ((bits >> 4) != 0) {
			result += 4;
			bits >>= 4;
		}
		if ((bits >> 2) != 0) {
			result += 2;
			bits >>= 2;
		}
		if ((bits >> 1) != 0) {
			result += 1;
			bits >>= 1;
		}
		return result + bits;
	}

	/// Returns the number of leading zero bits in x
	int32 leadingZeros(uint16 x) { return bits - length(x); }

	/// Returns the number of trailing zero bits in x
	int32 trailingZeros(uint16 x) {
		if (x == 0) {
			return bits;
		}

		return length(x & -x) - 1;
	}

	/// Finds the index of the most significant(highest) set bit.
	int32 scanReverse(uint16 x) { return length(x) - 1; }

	/// Finds the index of the least significant(lowest) set bit
	// or return x == 0 ? -1 : trailingZeros(x);
	int32 scanForward(uint16 x) { return length(x & -x) - 1; }

	/// Returns the number of set bits ("population count") in x
	int32 countOnes(uint16 x) {
		static if (preferNativeCalls && struct(uint32.pop) != null) {
			// use the native method if available
			return uint32.pop(x);
		}

		x -= (x >> 1) & 0x5555;
		x = (x & 0x3333) + ((x >> 2) & 0x3333);
		x = (x + (x >> 4)) & 0x0f0f;
		return (x + (x >> 8)) & 0x1f;
	}

	/// Returns the value of x rotated left by (n mod size) bits
	uint16 rotateLeft(uint16 x, int32 n) {
		n &= bits - 1;
		return (x << n) | (x >> (bits - n));
	}

	/// Returns the value of x rotated right by (n mod size) bits
	// inline rotateRight(uint16 x, int32 n) = rotateLeft(x, -n);
	uint16 rotateRight(uint16 x, int32 n) {
		n &= bits - 1;
		return (x >> n) | (x << (bits - n));
	}

	/// Returns the value of x with its bits in reversed order
	uint16 reverseBits(uint16 x) {
		x = ((x >> 1) & 0x5555) | ((x & 0x5555) << 1);
		x = ((x >> 2) & 0x3333) | ((x & 0x3333) << 2);
		x = ((x >> 4) & 0x0f0f) | ((x & 0x0f0f) << 4);
		return (x >> 8) | (x << 8);
	}

	/// Reverses the byte order of an 16-bit unsigned integer
	uint16 reverseBytes(uint16 x) {
		return (x & 0x00ff) << 8 | (x & 0xff00) >> 8;
	}
}

/// 16-bit signed integer operations
static struct Int16 {
	enum {
		bits: Uint16.bits;
		min: -32768;
		max: 32767;
	}

	/// Computes the arithmetic negation of an 16-bit signed integer
	int16 neg(int16 x, int16 overflow&) {
		overflow = int16(x == min);
		return inline(int32(x), i32.neg);
	}

	/// Performs an arithmetic right shift of an 16-bit signed integer
	int16 shr(int16 x, int32 n) { return inline(int32(x), int32(n), u32.sar); }

	/// Adds two 16-bit signed integers with carry out
	int16 add(int16 x, int16 y, int16 overflow&) {
		int32 result = int32(x) + int32(y);
		overflow = result >> bits;
		return result;
	}

	/// Subtracts two 16-bit signed integers with borrow out
	int16 sub(int16 x, int16 y, int16 overflow&) {
		int32 result = int32(x) - int32(y);
		overflow = result >> bits;
		return result;
	}

	/// Multiplies two 16-bit signed integers with overflow out
	int16 mul(int16 x, int16 y, int16 overflow&) {
		int32 result = int32(x) * int32(y);
		overflow = result >> bits;
		return result;
	}

	/// Compares two 16-bit signed integers(`0` if equal, `< 0` if fist is less, `> 0` if first is greater)
	int32 compare(int16 x, int16 y) {
		return int32(x) - int32(y);
	}

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	int32 sign(int16 x) {return int32(x > 0) - int32(x < 0); }

	/// Returns the absolute value of the input
	int16 abs(int16 x) { return x < 0 ? -x : x; }

	/// Returns the smaller value from the input values
	int16 min(int16 a, int16 b) { return a < b ? a : b; }

	/// Returns the greater value from the input values
	int16 max(int16 a, int16 b) { return a > b ? a : b; }

	/// Returns the `value` clamped between the provided `min` and `max`
	int16 clamp(int16 value, int16 min, int16 max) { return min(max(value, min), max); }

	/// Extract and sign-extends a bit field from a signed byte value
	int16 signExtend(int16 value, int32 offs, int32 size) {
		return int32(int32(value) << (bits - (offs + size))) >> (bits - size);
	}
}
/// 32-bit unsigned integer operations
static struct Uint32 {
	enum: uint32 {
		bits: 32;
		min: 0x00000000;
		max: 0xffffffff;
	}

	/// Computes the bitwise NOT of an 32-bit unsigned value
	uint32 cmt(uint32 x) { return inline(uint32(x), u32.cmt); }

	/// Computes the bitwise OR of two 32-bit unsigned integers
	uint32 or(uint32 x, uint32 y) { return inline(uint32(x), uint32(y), u32.or); }

	/// Computes the bitwise XOR of two 32-bit unsigned integers
	uint32 xor(uint32 x, uint32 y) { return inline(uint32(x), uint32(y), u32.xor); }

	/// Computes the bitwise AND of two 32-bit unsigned integers
	uint32 and(uint32 x, uint32 y) { return inline(uint32(x), uint32(y), u32.and); }

	/// Performs a logical right shift of x by n bits for an 32-bit unsigned integer
	uint32 shr(uint32 x, uint32 n) { return inline(uint32(x), uint32(n), u32.shr); }

	/// Performs a logical left shift of x by n bits for an 32-bit unsigned integer
	uint32 shl(uint32 x, int32 n) { return inline(uint32(x), int32(n), u32.shl); }

	/// Returns the signum of the input (`0` if zero, `1` if positive)
	int32 sign(uint32 x) { return int32(x > 0); }

	/// Returns the absolute value of the input
	uint32 abs(uint32 x) { return x; }

	/// Returns the smaller value from the input values
	uint32 min(uint32 a, uint32 b) { return a < b ? a : b; }

	/// Returns the greater value from the input values
	uint32 max(uint32 a, uint32 b) { return a > b ? a : b; }

	/// Returns the `value` clamped between the provided `min` and `max`
	uint32 clamp(uint32 value, uint32 min, uint32 max) { return min(max(value, min), max); }

	/// Extract and zero-extends a bit field from a value
	uint32 zeroExtend(uint32 value, int32 offs, int32 size) {
		return value << (bits - (offs + size)) >> (bits - size);
	}

	/// Adds two 32-bit unsigned integers with carry out
	uint32 add(uint32 x, uint32 y, uint32 overflow&) {
		uint64 result = uint64(x) + uint64(y);
		overflow = result >> bits;
		return result;
	}

	/// Subtracts two 32-bit unsigned integers with borrow out
	uint32 sub(uint32 x, uint32 y, uint32 overflow&) {
		uint64 result = uint64(x) - uint64(y);
		overflow = result >> bits;
		return result;
	}

	/// Multiplies two 32-bit unsigned integers with overflow out
	uint32 mul(uint32 x, uint32 y, uint32 overflow&) {
		uint64 result = uint64(x) * uint64(y);
		overflow = result >> bits;
		return result;
	}

	/// Compares two 32-bit unsigned integers
	int32 compare(uint32 x, uint32 y) {
		return uint32(x > y) - uint32(x < y);
	}

	/// Returns the minimum number of bits required to represent the value of `x`
	int32 length(uint32 x) {
		static if (preferNativeCalls && struct(uint32.len) != null) {
			// use the native method if available
			return uint32.len(x);
		}

		int32 result = 0;

		if ((x >> 16) != 0) {
			result += 16;
			x >>= 16;
		}
		if ((x >> 8) != 0) {
			result += 8;
			x >>= 8;
		}
		if ((x >> 4) != 0) {
			result += 4;
			x >>= 4;
		}
		if ((x >> 2) != 0) {
			result += 2;
			x >>= 2;
		}
		if ((x >> 1) != 0) {
			result += 1;
			x >>= 1;
		}
		return result + x;
	}

	/// Returns the number of leading zero bits in x
	int32 leadingZeros(uint32 x) { return bits - length(x); }

	/// Returns the number of trailing zero bits in x
	int32 trailingZeros(uint32 x) {
		if (x == 0) {
			return bits;
		}

		return length(x & -x) - 1;
	}

	/// Finds the index of the most significant(highest) set bit.
	int32 scanReverse(uint32 x) { return length(x) - 1; }

	/// Finds the index of the least significant(lowest) set bit
	// or return x == 0 ? -1 : trailingZeros(x);
	int32 scanForward(uint32 x) { return length(x & -x) - 1; }

	/// Returns the number of set bits ("population count") in x
	int32 countOnes(uint32 x) {
		static if (preferNativeCalls && struct(uint32.pop) != null) {
			// use the native method if available
			return uint32.pop(x);
		}

		x -= (x >> 1) & 0x55555555;
		x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
		x = (x + (x >> 4)) & 0x0f0f0f0f;
		x += x >> 8;
		x += x >> 16;
		return x & 0x3f;
	}

	/// Returns the value of x rotated left by (n mod size) bits
	uint32 rotateLeft(uint32 x, int32 n) {
		n &= bits - 1;
		return (x << n) | (x >> (bits - n));
	}

	/// Returns the value of x rotated right by (n mod size) bits
	// inline rotateRight(uint16 x, int32 n) = rotateLeft(x, -n);
	uint32 rotateRight(uint32 x, int32 n) {
		n &= bits - 1;
		return (x >> n) | (x << (bits - n));
	}

	/// Returns the value of x with its bits in reversed order
	uint32 reverseBits(uint32 x) {
		x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
		x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
		x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);
		x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);
		return (x >> 16) | (x << 16);
	}

	/// Reverses the byte order of an 32-bit unsigned integer
	uint32 reverseBytes(uint32 x) {
		x = (x & 0x0000ffff) << 16 | (x & 0xffff0000) >> 16;
		x = (x & 0x00ff00ff) << 8  | (x & 0xff00ff00) >> 8;
		return x;
	}
}

/// 32-bit signed integer operations
static struct Int32 {
	enum {
		bits: Uint32.bits;
		max: Uint32.max >> 1;
		min: ~max;
	}

	/// Computes the arithmetic negation of an 32-bit signed integer
	int32 neg(int32 x, int32 overflow&) {
		overflow = int32(x == min);
		return inline(int32(x), i32.neg);
	}

	/// Performs an arithmetic right shift of an 32-bit signed integer
	int32 shr(int32 x, int32 n) { return inline(int32(x), int32(n), u32.sar); }

	/// Adds two 32-bit signed integers with carry out
	int32 add(int32 x, int32 y, int32 overflow&) {
		int64 result = int64(x) + int64(y);
		overflow = result >> bits;
		return result;
	}

	/// Subtracts two 32-bit signed integers with borrow out
	int32 sub(int32 x, int32 y, int32 overflow&) {
		int64 result = int64(x) - int64(y);
		overflow = result >> bits;
		return result;
	}

	/// Multiplies two 32-bit signed integers with overflow out
	int32 mul(int32 x, int32 y, int32 overflow&) {
		int64 result = int64(x) * int64(y);
		overflow = result >> bits;
		return result;
	}

	/// Compares two 32-bit signed integers(`0` if equal, `< 0` if fist is less, `> 0` if first is greater)
	int32 compare(int32 x, int32 y) {
		return int32(x > y) - int32(x < y);
	}

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	int32 sign(int32 x) {return int32(x > 0) - int32(x < 0); }

	/// Returns the absolute value of the input
	int32 abs(int32 x) { return x < 0 ? -x : x; }

	/// Returns the smaller value from the input values
	int32 min(int32 a, int32 b) { return a < b ? a : b; }

	/// Returns the greater value from the input values
	int32 max(int32 a, int32 b) { return a > b ? a : b; }

	/// Returns the `value` clamped between the provided `min` and `max`
	int32 clamp(int32 value, int32 min, int32 max) { return min(max(value, min), max); }

	/// Extract and sign-extends a bit field from a signed byte value
	int32 signExtend(int32 value, int32 offs, int32 size) {
		return value << (bits - (offs + size)) >> (bits - size);
	}
}
/// 64-bit unsigned integer operations
static struct Uint64 {
	enum: uint64 {
		bits: 64;
		min: 0x0000000000000000;
		max: 0xffffffffffffffff;
	}

	/// Computes the bitwise NOT of an 64-bit unsigned value
	uint64 cmt(uint64 x) { return inline(uint64(x), u64.cmt); }

	/// Computes the bitwise OR of two 64-bit unsigned integers
	uint64 or(uint64 x, uint64 y) { return inline(uint64(x), uint64(y), u64.or); }

	/// Computes the bitwise XOR of two 64-bit unsigned integers
	uint64 xor(uint64 x, uint64 y) { return inline(uint64(x), uint64(y), u64.xor); }

	/// Computes the bitwise AND of two 64-bit unsigned integers
	uint64 and(uint64 x, uint64 y) { return inline(uint64(x), uint64(y), u64.and); }

	/// Performs a logical right shift of x by n bits for an 64-bit unsigned integer
	uint64 shr(uint64 x, int32 n) { return inline(uint64(x), int32(n), u64.shr); }

	/// Performs a logical left shift of x by n bits for an 64-bit unsigned integer
	uint64 shl(uint64 x, int32 n) { return inline(uint64(x), int32(n), u64.shl); }

	/// Returns the signum of the input (`0` if zero, `1` if positive)
	int32 sign(uint64 x) { return int32(x > 0); }

	/// Returns the absolute value of the input
	uint64 abs(uint64 x) { return x; }

	/// Returns the smaller value from the input values
	uint64 min(uint64 a, uint64 b) { return a < b ? a : b; }

	/// Returns the greater value from the input values
	uint64 max(uint64 a, uint64 b) { return a > b ? a : b; }

	/// Returns the `value` clamped between the provided `min` and `max`
	uint64 clamp(uint64 value, uint64 min, uint64 max) { return min(max(value, min), max); }

	/// Extract and zero-extends a bit field from a value
	uint64 zeroExtend(uint64 value, int32 offs, int32 size) {
		return value << (bits - (offs + size)) >> (bits - size);
	}

	/// Adds two 64-bit unsigned integers with carry out
	uint64 add(uint64 x, uint64 y, uint64 overflow&) {
		uint64 result = x + y;
		overflow = uint64(result < x);
		return result;
	}

	/// Subtracts two 64-bit unsigned integers with borrow out
	uint64 sub(uint64 x, uint64 y, uint64 overflow&) {
		uint64 result = x - y;
		overflow = uint64(x < result);
		return result;
	}

	/// Multiplies two 64-bit unsigned integers with overflow out
	uint64 mul(uint64 x, uint64 y, uint64 overflow&) {
		enum { bits: Uint32.bits, mask: Uint32.max }
		uint64 xl = x & mask;
		uint64 xh = x >> bits;
		uint64 yl = y & mask;
		uint64 yh = y >> bits;

		uint64 t0 = xl * yl;
		uint64 t1 = xh * yl;
		uint64 t2 = xl * yh;
		uint64 t3 = xh * yh;

		uint64 u1 = t1 + (t0 >> bits);
		uint64 u2 = t2 + (u1 & mask);

		overflow = t3 + (u2 >> bits) + (u1 >> bits);
		return (u2 << bits) | (t0 & mask);
	}

	/// Compares two 64-bit unsigned integers
	int32 compare(uint64 x, uint64 y) {
		return uint32(x > y) - uint32(x < y);
	}

	/// Returns the minimum number of bits required to represent the value of `x`
	int32 length(uint64 x) {
		static if (preferNativeCalls && struct(uint64.len) != null) {
			// use the native method if available
			return uint64.len(x);
		}

		int32 result = 0;
		if ((x >> 32) != 0) {
			result += 32;
			x >>= 32;
		}
		if ((x >> 16) != 0) {
			result += 16;
			x >>= 16;
		}
		if ((x >> 8) != 0) {
			result += 8;
			x >>= 8;
		}
		if ((x >> 4) != 0) {
			result += 4;
			x >>= 4;
		}
		if ((x >> 2) != 0) {
			result += 2;
			x >>= 2;
		}
		if ((x >> 1) != 0) {
			result += 1;
			x >>= 1;
		}
		return result + x;
	}

	/// Returns the number of leading zero bits in x
	int32 leadingZeros(uint64 x) { return bits - length(x); }

	/// Returns the number of trailing zero bits in x
	int32 trailingZeros(uint64 x) {
		if (x == 0) {
			return bits;
		}

		return length(x & -x) - 1;
	}

	/// Finds the index of the most significant(highest) set bit.
	int32 scanReverse(uint64 x) { return length(x) - 1; }

	/// Finds the index of the least significant(lowest) set bit
	// or return x == 0 ? -1 : trailingZeros(x);
	int32 scanForward(uint64 x) { return length(x & -x) - 1; }

	/// Returns the number of set bits ("population count") in x
	int32 countOnes(uint64 x) {
		static if (preferNativeCalls && struct(uint64.pop) != null) {
			// use the native method if available
			return uint64.pop(x);
		}

		x -= (x >> 1) & 0x5555555555555555;
		x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);
		x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f;
		x += x >> 8;
		x += x >> 16;
		x += x >> 32;
		return x & 0x3f;
	}

	/// Returns the value of x rotated left by (n mod size) bits
	uint64 rotateLeft(uint64 x, int32 n) {
		n &= bits - 1;
		return (x << n) | (x >> (bits - n));
	}

	/// Returns the value of x rotated right by (n mod size) bits
	// inline rotateRight(uint16 x, int32 n) = rotateLeft(x, -n);
	uint64 rotateRight(uint64 x, int32 n) {
		n &= bits - 1;
		return (x >> n) | (x << (bits - n));
	}

	/// Returns the value of x with its bits in reversed order
	uint64 reverseBits(uint64 x) {
		x = ((x >>  1) & 0x5555555555555555) | ((x & 0x5555555555555555) <<  1);
		x = ((x >>  2) & 0x3333333333333333) | ((x & 0x3333333333333333) <<  2);
		x = ((x >>  4) & 0x0f0f0f0f0f0f0f0f) | ((x & 0x0f0f0f0f0f0f0f0f) <<  4);
		x = ((x >>  8) & 0x00ff00ff00ff00ff) | ((x & 0x00ff00ff00ff00ff) <<  8);
		x = ((x >> 16) & 0x0000ffff0000ffff) | ((x & 0x0000ffff0000ffff) << 16);
		return (x >> 32) | (x << 32);
	}

	/// Reverses the byte order of an 64-bit unsigned integer
	// todo: convert a 64 bit value between Little endian and Big endian
	uint64 reverseBytes(uint64 x) {
		x = (x & 0x00000000ffffffff) << 32 | (x & 0xffffffff00000000) >> 32;
		x = (x & 0x0000ffff0000ffff) << 16 | (x & 0xffff0000ffff0000) >> 16;
		x = (x & 0x00ff00ff00ff00ff) << 8  | (x & 0xff00ff00ff00ff00) >> 8;
		return x;
	}
}

/// 64-bit signed integer operations
static struct Int64 {
	enum: int64 {
		bits: Uint32.bits;
		max: Uint32.max >> 1;
		min: ~max;
	}

	/// Computes the arithmetic negation of an 64-bit signed integer
	int64 neg(int64 x, int64 overflow&) {
		overflow = int64(x == min);
		return inline(int64(x), i64.neg);
	}

	/// Performs an arithmetic right shift of an 64-bit signed integer
	int64 shr(int64 x, int32 n) { return inline(int64(x), int32(n), u64.sar); }

	/// Adds two 64-bit signed integers with carry out
	int64 add(int64 x, int64 y, int64 overflow&) {
		int64 result = x + y;
		overflow = int64(((x ^ result) & (y ^ result)) < 0);
		return result;
	}

	/// Subtracts two 64-bit signed integers with borrow out
	int64 sub(int64 x, int64 y, int64 overflow&) {
		int64 result = int64(x) - int64(y);
		overflow = int64(((x ^ y) & (x ^ result)) < 0);
		return result;
	}

	/// Multiplies two 64-bit signed integers with overflow out
	int64 mul(int64 x, int64 y, int64 overflow&) {
		bool neg = false;
		if (x < 0) {
			neg = !neg;
			x = -x;
		}
		if (y < 0) {
			neg = !neg;
			y = -y;
		}

		uint64 u& = pointer(overflow);
		int64 result = Uint64.mul(uint64(x), uint64(y), &u);
		if (neg) {
			result = -result;
			// Overflow from low to high
			u = ~u + int64(result == 0);
		}
		return result;
	}

	/// Compares two 64-bit signed integers(`0` if equal, `< 0` if fist is less, `> 0` if first is greater)
	int32 compare(int64 x, int64 y) {
		return int32(x > y) - int32(x < y);
	}

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	inline sign(int64 x) = int32(x > 0) - int32(x < 0);

	/// Returns the absolute value of the input
	inline abs(int64 x) = x < 0 ? -x : x;

	/// Returns the smaller value from the input values
	inline min(int64 a, int64 b) = a < b ? a : b;

	/// Returns the greater value from the input values
	inline max(int64 a, int64 b) = a > b ? a : b;

	/// Returns the `value` clamped between `min` and `max`
	inline clamp(int64 value, int64 min, int64 max) = min(max(value, min), max);

	/// Extract and sign-extends a bit field from a signed byte value
	int64 signExtend(int64 value, int32 offs, int32 size) {
		return value << (bits - (offs + size)) >> (bits - size);
	}
}
/// 8-bit unsigned integer operations
static struct Uint8 {
	enum {
		bits: 8;
		min: 0x00;
		max: 0xff;
	}

	/// Computes the bitwise NOT of an 8-bit unsigned value
	uint8 cmt(uint8 x) { return inline(uint32(x), u32.cmt); }

	/// Computes the bitwise OR of two 8-bit unsigned integers
	uint8 or(uint8 x, uint8 y) { return inline(uint32(x), uint32(y), u32.or); }

	/// Computes the bitwise XOR of two 8-bit unsigned integers
	uint8 xor(uint8 x, uint8 y) { return inline(uint32(x), uint32(y), u32.xor); }

	/// Computes the bitwise AND of two 8-bit unsigned integers
	uint8 and(uint8 x, uint8 y) { return inline(uint32(x), uint32(y), u32.and); }

	/// Performs a logical right shift of x by n bits for an 8-bit unsigned integer
	uint8 shr(uint8 x, uint32 n) { return inline(uint32(x), uint32(n), u32.shr); }

	/// Performs a logical left shift of x by n bits for an 8-bit unsigned integer
	uint8 shl(uint8 x, uint32 n) { return inline(uint32(x), uint32(n), u32.shl); }

	/// Returns the signum of the input (`0` if zero, `1` if positive)
	int32 sign(uint8 x) { return int32(x > 0); }

	/// Returns the absolute value of the input
	uint8 abs(uint8 x) { return x; }

	/// Returns the smaller value from the input values
	uint8 min(uint8 a, uint8 b) { return a < b ? a : b; }

	/// Returns the greater value from the input values
	uint8 max(uint8 a, uint8 b) { return a > b ? a : b; }

	/// Returns the `value` clamped between the provided `min` and `max`
	uint8 clamp(uint8 value, uint8 min, uint8 max) { return min(max(value, min), max); }

	/// Extract and zero-extends a bit field from a byte value
	uint8 zeroExtend(uint8 value, int32 offs, int32 size) {
		return uint32(uint32(value) << (bits - (offs + size))) >> (bits - size);
	}

	/// Adds two 8-bit unsigned integers with carry out
	uint8 add(uint8 x, uint8 y, uint8 overflow&) {
		uint32 result = uint32(x) + uint32(y);
		overflow = result >> bits;
		return result;
	}

	/// Subtracts two 8-bit unsigned integers with borrow out
	uint8 sub(uint8 x, uint8 y, uint8 overflow&) {
		uint32 result = uint32(x) - uint32(y);
		overflow = result >> bits;
		return result;
	}

	/// Multiplies two 8-bit unsigned integers with overflow out
	uint8 mul(uint8 x, uint8 y, uint8 overflow&) {
		uint32 result = uint32(x) * uint32(y);
		overflow = result >> bits;
		return result;
	}

	/// Compares two 8-bit unsigned integers
	int32 compare(uint8 x, uint8 y) {
		return uint32(x) - uint32(y);
	}

	/// Returns the minimum number of bits required to represent the value of `x`
	int32 length(uint8 x) {
		static if (preferNativeCalls && struct(uint32.len) != null) {
			// use the native method if available
			return uint32.len(x);
		}

		uint32 bits = x;	// speed up by by avoiding load and store indirect memory
		int32 result = 0;

		if ((bits >> 4) != 0) {
			result += 4;
			bits >>= 4;
		}
		if ((bits >> 2) != 0) {
			result += 2;
			bits >>= 2;
		}
		if ((bits >> 1) != 0) {
			result += 1;
			bits >>= 1;
		}
		return result + bits;
	}

	/// Returns the number of leading zero bits in x
	int32 leadingZeros(uint8 x) { return bits - length(x); }

	/// Returns the number of trailing zero bits in x
	int32 trailingZeros(uint8 x) {
		if (x == 0) {
			return bits;
		}

		return length(x & -x) - 1;
	}

	/// Finds the index of the most significant(highest) set bit.
	int32 scanReverse(uint8 x) { return length(x) - 1; }

	/// Finds the index of the least significant(lowest) set bit
	// or return x == 0 ? -1 : trailingZeros(x);
	int32 scanForward(uint8 x) { return length(x & -x) - 1; }

	/// Returns the number of set bits ("population count") in x
	int32 countOnes(uint8 x) {
		static if (preferNativeCalls && struct(uint32.pop) != null) {
			// use the native method if available
			return uint32.pop(x);
		}

		x -= (x >> 1) & 0x55;
		x = (x & 0x33) + ((x >> 2) & 0x33);
		return (x + (x >> 4)) & 0xf;
	}

	/// Returns the value of x rotated left by (n mod size) bits
	uint8 rotateLeft(uint8 x, int32 n) {
		n &= bits - 1;
		return (x << n) | (x >> (bits - n));
	}

	/// Returns the value of x rotated right by (n mod size) bits
	// inline rotateRight(uint8 x, int32 n) = rotateLeft(x, -n);
	uint8 rotateRight(uint8 x, int32 n) {
		n &= bits - 1;
		return (x >> n) | (x << (bits - n));
	}

	/// Returns the value of x with its bits in reversed order
	uint8 reverseBits(uint8 x) {
		x = ((x >> 1) & 0x55) | ((x & 0x55) << 1);
		x = ((x >> 2) & 0x33) | ((x & 0x33) << 2);
		return (x >> 4) | (x << 4);
	}

	/// Reverses the byte order of an 8-bit unsigned integer
	uint8 reverseBytes(uint8 x) {
		return x;
	}
}

/// 8-bit signed integer operations
static struct Int8 {
	enum {
		bits: Uint8.bits;
		min: -128;
		max: 127;
	}

	/// Computes the arithmetic negation of an 8-bit signed integer
	int8 neg(int8 x, int8 overflow&) {
		overflow = int8(x == min);
		return inline(int32(x), i32.neg);
	}

	/// Performs an arithmetic right shift of an 8-bit signed integer
	int8 shr(int8 x, int32 n) { return inline(int32(x), int32(n), u32.sar); }

	/// Adds two 8-bit signed integers with carry out
	int8 add(int8 x, int8 y, int8 overflow&) {
		int32 result = int32(x) + int32(y);
		overflow = result >> bits;
		return result;
	}

	/// Subtracts two 8-bit signed integers with borrow out
	int8 sub(int8 x, int8 y, int8 overflow&) {
		int32 result = int32(x) - int32(y);
		overflow = result >> bits;
		return result;
	}

	/// Multiplies two 8-bit signed integers with overflow out
	int8 mul(int8 x, int8 y, int8 overflow&) {
		int32 result = int32(x) * int32(y);
		overflow = result >> bits;
		return result;
	}

	/// Compares two 8-bit signed integers(`0` if equal, `< 0` if fist is less, `> 0` if first is greater)
	int32 compare(int8 x, int8 y) {
		return int32(x) - int32(y);
	}

	/// Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)
	int32 sign(int8 x) {return int32(x > 0) - int32(x < 0); }

	/// Returns the absolute value of the input
	int8 abs(int8 x) { return x < 0 ? -x : x; }

	/// Returns the smaller value from the input values
	int8 min(int8 a, int8 b) { return a < b ? a : b; }

	/// Returns the greater value from the input values
	int8 max(int8 a, int8 b) { return a > b ? a : b; }

	/// Returns the `value` clamped between the provided `min` and `max`
	int8 clamp(int8 value, int8 min, int8 max) { return min(max(value, min), max); }

	/// Extract and sign-extends a bit field from a signed byte value
	int8 signExtend(int8 value, int32 offs, int32 size) {
		return int32(int32(value) << (bits - (offs + size))) >> (bits - size);
	}
}
struct Uint128 {
	uint32 words[4];
	inline BigUint = Uint128;
	inline "./UintImpl.cmpl";
}
inline Uint128(uint64 value) = Uint128.make(value);

struct Uint256 {
	uint32 words[8];
	inline BigUint = Uint256;
	inline "./UintImpl.cmpl";
}
inline Uint256(uint64 value) = Uint256.make(value);

struct Uint512 {
	uint32 words[16];
	inline BigUint = Uint512;
	inline "./UintImpl.cmpl";
}
inline Uint512(uint64 value) = Uint512.make(value);

/* todo: allow arbitrary precision big unsigned integers
struct UintBig {
	uint32 words[];
	inline BigUint = UintBig;
	// todo: inline "./UintImpl.cmpl";
}*/
/// include this file from a UintXXX class, see UintBig.cmpl

static BigUint make(uint64 value) {
	BigUint result = {...};
	for (int i = 0; i < result.words.length; i += 1) {
		result.words[i] = value;
		value >>= 32;
	}
	return result;
}

static BigUint make(int64 value) {
	BigUint result = {...};
	for (int i = 0; i < result.words.length; i += 1) {
		result.words[i] = value;
		value >>= 32;
	}
	return result;
}

static int32 bits(BigUint this!) {
	return this.words.length * 32;
}

/// returns true if all elements of m_data are zero.
static bool isZero(BigUint this!) {
	for (int i = 0; i < this.words.length; i += 1) {
		if (this.words[i] != 0) {
			return false;
		}
	}
	return true;
}

/// shifts bits to left value in place
static void shiftLeft(BigUint this&, int count) {
	if (count <= 0) {
		return;
	}

	int wordShift = count / 32;
	int bitShift = count % 32;
	uint64 value = 0;
	if (wordShift < this.words.length) {
		value = this.words[this.words.length - wordShift - 1];
	} else {
		wordShift = this.words.length;
	}

	for (int i = this.words.length - 1; i > wordShift; i -= 1) {
		value = (value << 32) | this.words[i - wordShift - 1];
		this.words[i] = value >> (32 - bitShift);
	}
	this.words[wordShift] = value << bitShift;
	for (int i = wordShift - 1; i >= 0; i -= 1) {
		this.words[i] = 0;
	}
}

/// shifts bits to right value in place
static void shiftRight(BigUint this&, int count) {
	if (count <= 0) {
		return;
	}

	int wordShift = count / 32;
	int bitShift = count % 32;
	uint64 value = 0;
	if (wordShift < this.words.length) {
		value = uint64(this.words[wordShift]) << 32;
	} else {
		wordShift = this.words.length;
	}

	int n = this.words.length - wordShift;
	for (int i = 0; i < n - 1; i += 1) {
		value = (value >> 32) | (uint64(this.words[wordShift + i + 1]) << 32);
		this.words[i] = value >> bitShift;
	}

	if (n > 0) {
		this.words[n - 1] = value >> 32 + bitShift;
	}
	for (int i = n; i < this.words.length; i += 1) {
		this.words[i] = 0;
	}
}

/// divides the value in place and returns the remainder
static uint32 divRem(BigUint this&, uint32 value) {
	uint32 remainder = 0;
	// Standard long-division algorithm.
	for (int i = this.words.length - 1; i >= 0; i -= 1) {
		uint64 dividend = (uint64(remainder) << 32) + this.words[i];
		this.words[i] = dividend / value;
		remainder = dividend % value;
	}

	return remainder;
}

/// multiplies the value in place and returns the overflow
static uint32 mulOvf(BigUint this&, uint32 value) {
	uint32 overflow = 0;
	for (int i = 0; i < this.words.length; i += 1) {
		uint64 result = uint64(value) * this.words[i] + overflow;
		this.words[i] = result;
		overflow = result >> 32;
	}
	return overflow;
}


/// complements all elements of `words`.
static BigUint cmt(BigUint this!) {
	BigUint result = {...};
	for (int i = 0; i < this.words.length; i += 1) {
		result.words[i] = ~this.words[i];
	}
	return result;
}

static BigUint and(BigUint a!, BigUint b!) {
	BigUint result = {...};
	for (int i = 0; i < result.words.length; i += 1) {
		result.words[i] = a.words[i] & b.words[i];
	}
	return result;
}

static BigUint or(BigUint a!, BigUint b!) {
	BigUint result = {...};
	for (int i = 0; i < result.words.length; i += 1) {
		result.words[i] = a.words[i] | b.words[i];
	}
	return result;
}

static BigUint xor(BigUint a!, BigUint b!) {
	BigUint result = {...};
	for (int i = 0; i < result.words.length; i += 1) {
		result.words[i] = a.words[i] ^ b.words[i];
	}
	return result;
}

/// returns the negation of the value.
static BigUint neg(BigUint this!) {
	// -value = ~value + 1
	BigUint result = {...};
	uint64 carry = 1;
	for (int i = 0; i < this.words.length; i += 1) {
		carry += ~this.words[i];
		result.words[i] = carry;
		carry >>= 32;
	}
	return result;
}

/// returns the sum of the values.
static BigUint add(BigUint a!, BigUint b!) {
	BigUint result = {...};
	uint64 carry = 0;
	for (int i = 0; i < result.words.length; i += 1) {
		carry += uint64(a.words[i]) + b.words[i];
		result.words[i] = carry;
		carry >>= 32;
	}
	return result;
}

/// returns the difference of the values.
static BigUint sub(BigUint a!, BigUint b!) {
	BigUint result = {...};
	uint64 borrow = 0;
	for (int i = 0; i < result.words.length; i += 1) {
		borrow += uint64(a.words[i]) - b.words[i];
		result.words[i] = borrow;
		borrow >>= 32;
	}
	return result;
}

/// Compares two 64-bit signed integers(`0` if equal, `< 0` if fist is less, `> 0` if first is greater)
static int32 compare(BigUint a!, BigUint b!) {
	for (int i = a.words.length - 1; i >= 0; i -= 1) {
		int32 c = Int32.compare(a.words[i], b.words[i]);
		if (c != 0) {
			return c;
		}
	}
	return 0;
}
/// A very simple random number generator
// based on: http://www.codeproject.com/Articles/25172/Simple-Random-Number-Generation
// based on: http://iquilezles.org/www/articles/sfrand/sfrand.htm
struct Random {
	uint32 m_w = 521288629;
	uint32 m_z = 362436069;

	/// Calculate the next uniformly distributed random number
	static int32 nextInt32(Random random&) {
		random.m_z = 36969 * (random.m_z & 0xffff) + (random.m_z >> 16);
		random.m_w = 18000 * (random.m_w & 0xffff) + (random.m_w >> 16);
		return (random.m_z << 16) + random.m_w;
	}

	/// Calculate the next uniformly distributed random number
	static int64 nextInt64(Random random&) {
		uint64 hi = nextInt32(&random);
		uint32 lo = nextInt32(&random);
		return (hi << 32) | lo;
	}

	/// Calculate the next uniformly distributed random number
	static float32 nextFloat32(Random random&) {
		uint32 value = nextInt32(&random);
		return Float32.fromBits((value >> 9) | 0x3f800000) - 1;
	}

	/// Calculate the next uniformly distributed random number
	static float64 nextFloat64(Random random&) {
		uint32 hi = nextInt32(&random);
		uint32 lo = nextInt32(&random);
		return Float64.fromBits((hi >> 12) | 0x3ff00000, lo) - 1;
	}

	/// Calculate the next uniformly distributed random number
	static int32 nextInt32(Random random&, int32 min, int32 max) {
		if (min > max) {
			int32 tmp = min;
			min = max;
			max = tmp;
		}
		int32 result = nextInt32(&random) % (max - min);
		if (result < 0) {
			result += max - min;
		}
		return result + min;
	}

	/// Calculate the next uniformly distributed random number
	static int64 nextInt64(Random random&, int64 min, int64 max) {
		if (min > max) {
			int64 tmp = min;
			min = max;
			max = tmp;
		}
		int64 result = nextInt64(&random) % (max - min);
		if (result < 0) {
			result += max - min;
		}
		return result + min;
	}

	/// Calculate the next uniformly distributed random number
	static float32 nextFloat32(Random random&, float32 min, float32 max) {
		if (min > max) {
			float32 tmp = min;
			min = max;
			max = tmp;
		}
		float32 result = nextFloat32(&random) % (max - min);
		if (result < 0) {
			result += max - min;
		}
		return result + min;
	}

	/// Calculate the next uniformly distributed random number
	static float64 nextFloat64(Random random&, float64 min, float64 max) {
		if (min > max) {
			float64 tmp = min;
			min = max;
			max = tmp;
		}
		float64 result = nextFloat64(&random) % (max - min);
		if (result < 0) {
			result += max - min;
		}
		return result + min;
	}

	/// Get normal (Gaussian) random sample with mean 0 and standard deviation 1
	static float64 nextNormal(Random random&) {
		// Use Box-Muller algorithm
		float64 rho = Float64.sqrt(-2 * Float64.ln(nextFloat64(&random)));
		float64 theta = 2 * Float64.pi * nextFloat64(&random);
		return rho * Float64.cos(theta);
	}

	/// Get normal (Gaussian) random sample with specified mean and standard deviation
	static float64 nextNormal(Random random&, float64 mean, float64 standardDeviation) {
		assert(standardDeviation > 0, "Shape must be positive. Received", standardDeviation);
		return mean + standardDeviation * nextNormal(&random);
	}
}

/// Create a random number generator based on the given seed
Random Random(int64 seed) {
	return {
		// use low 32 bits
		m_w: uint32(seed);
	};
}

/// Create a random number generator based on the current time
Random Random() {
	return {
		// use low 32 bits
		m_w: uint32(System.millis());
	};
}
/// A 4x4 matrix
struct mat4f: 0 {
	/// Access elements as an array: m[1][0]
	float32 m[4][4];

	/// Access elements as a flatten array: data[4] => m[1][0]
	float32 data[16];

	/// Access elements as an array of vectors: v[1].x => m[1][0]
	vec4f v[4];

	struct {
		/// The first row as a vector
		vec4f x;
		/// The second row as a vector
		vec4f y;
		/// The third row as a vector
		vec4f z;
		/// The fourth row as a vector
		vec4f w;
	}
	struct {
		/// The first element of the first row
		float32 xx;
		/// The second element of the first row
		float32 xy;
		/// The third element of the first row
		float32 xz;
		/// The fourth element of the first row
		float32 xw;

		/// The first element of the second row
		float32 yx;
		/// The second element of the second row
		float32 yy;
		/// The third element of the second row
		float32 yz;
		/// The fourth element of the second row
		float32 yw;

		/// The first element of the third row
		float32 zx;
		/// The second element of the third row
		float32 zy;
		/// The third element of the third row
		float32 zz;
		/// The fourth element of the third row
		float32 zw;

		/// The first element of the fourth row
		float32 wx;
		/// The second element of the fourth row
		float32 wy;
		/// The third element of the fourth row
		float32 wz;
		/// The fourth element of the fourth row
		float32 ww;
	}

	/// Multiply with vector: dot product of the first 3 elements
	//inline dp3(mat4f mat&, vec4f vec&) = vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1f);
	static vec4f dp3(mat4f mat!, vec4f vec) {
		return {
			x: dp3(mat.x, vec);
			y: dp3(mat.y, vec);
			z: dp3(mat.z, vec);
			w: 1;
		};
	}

	/// Multiply with vector: homogeneous dot product
	//inline dph(mat4f mat&, vec4f vec&) = vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
	static vec4f dph(mat4f mat!, vec4f vec) {
		return {
			x: dph(mat.x, vec);
			y: dph(mat.y, vec);
			z: dph(mat.z, vec);
			w: dph(mat.w, vec);
		};
	}

	/// Multiply with vector: full dot product
	//inline dp4(mat4f mat&, vec4f vec&) = vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));
	static vec4f dp4(mat4f mat!, vec4f vec) {
		return {
			x: dp4(mat.x, vec);
			y: dp4(mat.y, vec);
			z: dp4(mat.z, vec);
			w: dp4(mat.w, vec);
		};
	}

	/// Transform a 3d point by the given matrix: homogeneous dot product
	static vec4f transform(mat4f mat!, float32 x, float32 y, float32 z) {
		return mat.dph(vec4f(x, y, z, 1));
	}

	/// Transform a 2d point by the given matrix: homogeneous dot product
	static vec4f transform(mat4f mat!, float32 x, float32 y) {
		return mat.dph(vec4f(x, y, 0, 1));
	}
}

/// Initialize all elements with the given values
mat4f mat4f(float32 xx, float32 xy, float32 xz, float32 xw,
			float32 yx, float32 yy, float32 yz, float32 yw,
			float32 zx, float32 zy, float32 zz, float32 zw,
			float32 wx, float32 wy, float32 wz, float32 ww) {
	return {
		xx: xx; xy: xy; xz: xz; xw: xw;
		yx: yx; yy: yy; yz: yz; yw: yw;
		zx: zx; zy: zy; zz: zz; zw: zw;
		wx: wx; wy: wy; wz: wz; ww: ww;
	};
}

/// Initialize matrix with row vectors
mat4f mat4f(vec4f x!, vec4f y!, vec4f z!, vec4f w!) {
	return { x: x, y: y, z: z, w: w };
}

/// Transpose the matrix
static mat4f transpose(mat4f mat!) {
	return {
		xx: mat.xx; xy: mat.yx; xz: mat.zx; xw: mat.wx;
		yx: mat.xy; yy: mat.yy; yz: mat.zy; yw: mat.wy;
		zx: mat.xz; zy: mat.yz; zz: mat.zz; zw: mat.wz;
		wx: mat.xw; wy: mat.yw; wz: mat.zw; ww: mat.ww;
	};
}

/// Build the inverse of the matrix
// adapted from: https://github.com/glslify/glsl-inverse/blob/master/index.glsl
static mat4f inverse(mat4f mat) {
	float32 b00 = mat.xx * mat.yy - mat.xy * mat.yx;
	float32 b01 = mat.xx * mat.yz - mat.xz * mat.yx;
	float32 b02 = mat.xx * mat.yw - mat.xw * mat.yx;
	float32 b03 = mat.xy * mat.yz - mat.xz * mat.yy;
	float32 b04 = mat.xy * mat.yw - mat.xw * mat.yy;
	float32 b05 = mat.xz * mat.yw - mat.xw * mat.yz;
	float32 b06 = mat.zx * mat.wy - mat.zy * mat.wx;
	float32 b07 = mat.zx * mat.wz - mat.zz * mat.wx;
	float32 b08 = mat.zx * mat.ww - mat.zw * mat.wx;
	float32 b09 = mat.zy * mat.wz - mat.zz * mat.wy;
	float32 b10 = mat.zy * mat.ww - mat.zw * mat.wy;
	float32 b11 = mat.zz * mat.ww - mat.zw * mat.wz;

	float32 det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	return {
		xx: (mat.yy * b11 - mat.yz * b10 + mat.yw * b09) / det;
		xy: (mat.xz * b10 - mat.xy * b11 - mat.xw * b09) / det;
		xz: (mat.wy * b05 - mat.wz * b04 + mat.ww * b03) / det;
		xw: (mat.zz * b04 - mat.zy * b05 - mat.zw * b03) / det;
		yx: (mat.yz * b08 - mat.yx * b11 - mat.yw * b07) / det;
		yy: (mat.xx * b11 - mat.xz * b08 + mat.xw * b07) / det;
		yz: (mat.wz * b02 - mat.wx * b05 - mat.ww * b01) / det;
		yw: (mat.zx * b05 - mat.zz * b02 + mat.zw * b01) / det;
		zx: (mat.yx * b10 - mat.yy * b08 + mat.yw * b06) / det;
		zy: (mat.xy * b08 - mat.xx * b10 - mat.xw * b06) / det;
		zz: (mat.wx * b04 - mat.wy * b02 + mat.ww * b00) / det;
		zw: (mat.zy * b02 - mat.zx * b04 - mat.zw * b00) / det;
		wx: (mat.yy * b07 - mat.yx * b09 - mat.yz * b06) / det;
		wy: (mat.xx * b09 - mat.xy * b07 + mat.xz * b06) / det;
		wz: (mat.wy * b01 - mat.wx * b03 - mat.wz * b00) / det;
		ww: (mat.zx * b03 - mat.zy * b01 + mat.zz * b00) / det;
	};
}


/// Multiply two matrices (rows * cols)
static mat4f mul(mat4f lhs!, mat4f rhs!) {
	// multiply row vector with a matrix resulting a row vector
	inline dp4(vec4f vec!, mat4f mat!) = mat.dp4(vec);

	mat4f transposed = transpose(rhs);
	return {
		x: lhs.x.dp4(transposed);
		y: lhs.y.dp4(transposed);
		z: lhs.z.dp4(transposed);
		w: lhs.w.dp4(transposed);
	};
}

/// Build a rotation matrix
// adapted from: https://sites.google.com/site/glennmurray/Home/rotation-matrices-and-formulas
static mat4f rotation(vec4f center!, vec4f direction!, float32 angle) {
	float32 len = direction.length();
	if (len < 1e-9) {
		trace("invalid direction of rotation", direction);
		return {
			x: vec4f(0, 0, 0, 0);
			y: vec4f(0, 0, 0, 0);
			z: vec4f(0, 0, 0, 0);
			w: vec4f(0, 0, 0, 0);
		};
	}
	float32 x = direction.x / len;
	float32 y = direction.y / len;
	float32 z = direction.z / len;
	float32 cx = center.x;
	float32 cy = center.y;
	float32 cz = center.z;
	float32 xx = x * x;
	float32 xy = x * y;
	float32 xz = x * z;
	float32 yy = y * y;
	float32 yz = y * z;
	float32 zz = z * z;

	float32 s = Float32.sin(angle);
	float32 c = Float32.cos(angle);
	float32 k = 1 - c;

	return {
		xx: xx + (yy + zz) * c;
		xy: xy * k - z * s;
		xz: xz * k + y * s;
		xw: (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;

		yx: xy * k + z * s;
		yy: yy + (xx + zz) * c;
		yz: yz * k - x * s;
		yw: (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;

		zx: xz * k - y * s;
		zy: yz * k + x * s;
		zz: zz + (xx + yy) * c;
		zw: (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;

		w: vec4f(0, 0, 0, 1);
	};
}

/// Build a rotation matrix
static mat4f rotation(vec4f direction!, float32 angle) {
	float32 xx = direction.x * direction.x;
	float32 yy = direction.y * direction.y;
	float32 zz = direction.z * direction.z;
	float32 xy = direction.x * direction.y;
	float32 xz = direction.x * direction.z;
	float32 yz = direction.y * direction.z;
	float32 s = Float32.sin(angle);
	float32 c = Float32.cos(angle);
	float32 k = 1 - c;
	vec4f tmp = direction * s;

	return {
		xx: k * xx + c;
		xy: k * xy - tmp.z;
		xz: k * xz + tmp.y;
		xw: 0;

		yx: k * xy + tmp.z;
		yy: k * yy + c;
		yz: k * yz - tmp.x;
		yw: 0;

		zx: k * xz - tmp.y;
		zy: k * yz + tmp.x;
		zz: k * zz + c;
		zw: 0;

		w: vec4f(0, 0, 0, 1);
	};
}

/// Build a translation matrix
static mat4f translation(vec4f direction!, float32 amount) {
	return {
		xx: 1; xy: 0; xz: 0; xw: direction.x * amount;
		yx: 0; yy: 1; yz: 0; yw: direction.y * amount;
		zx: 0; zy: 0; zz: 1; zw: direction.z * amount;
		wx: 0; wy: 0; wz: 0; ww: 1;
	};
}

/// Build a scaling matrix
static mat4f scale(vec4f direction!, float32 amount) {
	inline rcp(float32 val) = (val < 0 ? -val : val) < 1e-30 ? 0 : 1 / val;
	return {
		xx: rcp(direction.x * amount); xy: 0; xz: 0; xw: 0;
		yx: 0; yy: rcp(direction.y * amount); yz: 0; yw: 0;
		zx: 0; zy: 0; zz: rcp(direction.z * amount); zw: 0;
		wx: 0; wy: 0; wz: 0; ww: 1;
	};
}
inline scalar = float64;  // fixme: declare inside Polynomial

///@public
struct Polynomial/*(typename scalar)*/: TextWriter.Writeable {
	scalar coefficients[*];
	int capacity;

	enum: scalar {
		c_zero: 0;
		c_unit: 1;
	}

	// Formatted printing of the polynomial to the text writer
	void write(Polynomial this, TextWriter writer) {
		bool first = true;
		for (int i = this.capacity - 1; i >= 0; i -= 1) {
			if (this.coefficients[i] == c_zero && !(first && i == 0)) {
				continue;
			}

			scalar value = this.coefficients[i];
			if (value < c_zero) {
				value = -value;
				if (!first) {
					// binary operator
					writer.write(" - ");
				}
				else {
					// unary operator
					writer.write("-");
				}
			}
			else if (!first) {
				// binary operator
				writer.write(" + ");
			}

			if (value != c_unit || i == 0) {
				writer.write(value, writer.format);
			}

			if (i > 0) {
				writer.write("x");
				if (i > 1) {
					writer.write("^");
					writer.write(i, writer.format);
				}
			}
			first = false;
		}
	}

	/// Dispose the polynomial, free up used memory for coefficients
	void destroy(Polynomial this) {
		pointer.alloc(this.coefficients, 0);
	}

	// Construct a new instance
	static Polynomial create(int degree, scalar values[]) {
		int capacity = Int.max(0, degree) + 1;
		assert(capacity >= values.length);
		scalar coefficients[*] = pointer.alloc(null, capacity * sizeof(scalar));
		Polynomial result& = {
			// fixme: coefficients: pointer.alloc(null, capacity * sizeof(scalar));
			coefficients: coefficients;
			capacity: capacity;
		};

		for (int i = 0; i < values.length; i += 1) {
			result.coefficients[i] = values[i];
		}
		for (int i = values.length; i < capacity; i += 1) {
			result.coefficients[i] = c_zero;
		}
		return result;
	}

	/// Compute the degree of the polynomial
	static int degree(Polynomial this&) {
		for (int i = this.capacity - 1; i > 0; i -= 1) {
			if (this.coefficients[i] != c_zero) {
				return i;
			}
		}
		return 0;
	}

	/// Get the nth coefficient of the polynomial
	static scalar get(Polynomial this!, int index) {
		assert(index >= 0, "negative index", index);
		if (index >= this.capacity) {
			return c_zero;
		}
		return this.coefficients[index];
	}

	/// Set the nth coefficient of the polynomial
	static Polynomial set(Polynomial this&, int index, scalar value) {
		assert(index >= 0, "negative index", index);
		assert(index < this.capacity, "invalid index");
		this.coefficients[index] = value;
		return this;
	}

	/// Negate the polynomial
	static Polynomial neg(Polynomial a!) {
		Polynomial result& = create(degree(a), null);
		for (int i = 0; i < result.capacity; i += 1) {
			result.coefficients[i] = -a.get(i);
		}
		return result;
	}

	/// Add two polynomials
	static Polynomial add(Polynomial a!, Polynomial b!) {
		Polynomial result& = create(Int.max(degree(a), degree(b)), null);
		for (int i = 0; i < result.capacity; i += 1) {
			result.coefficients[i] = a.get(i) + b.get(i);
		}
		return result;
	}

	/// Subtract two polynomials
	static Polynomial sub(Polynomial a!, Polynomial b!) {
		Polynomial result& = create(Int.max(degree(a), degree(b)), null);
		for (int i = 0; i < result.capacity; i += 1) {
			result.coefficients[i] = a.get(i) - b.get(i);
		}
		return result;
	}

	/// Multiply two polynomials
	static Polynomial mul(Polynomial a!, Polynomial b!) {
		int degreeA = degree(a);
		int degreeB = degree(b);
		Polynomial result& = create(degreeA + degreeB, null);
		for (int i = 0; i <= degreeA; i += 1) {
			for (int j = 0; j <= degreeB; j += 1) {
				result.coefficients[i + j] += a.get(i) * b.get(j);
			}
		}
		return result;
	}

	/// Evaluate the polynomial using Horner's method
	static scalar evaluate(Polynomial this!, scalar value) {
		scalar result = c_zero;
		for (int i = degree(this); i >= 0; i -= 1) {
			result = result * value + this.coefficients[i];
		}
		return result;
	}

	/// Compute the derivative of the polynomial
	static Polynomial derivative(Polynomial this!) {
		Polynomial result& = create(this.degree() - 1, null);
		for (int i = 0; i < result.capacity; i += 1) {
			result.coefficients[i] = (i + 1) * this.coefficients[i + 1];
		}
		return result;
	}

	/// Compute the integral of the polynomial
	static Polynomial integral(Polynomial this!, scalar c) {
		Polynomial result& = create(this.degree() + 1, null);
		result.coefficients[0] = c;
		for (int i = 1; i < result.capacity; i += 1) {
			result.coefficients[i] = this.coefficients[i - 1] / i;
		}
		return result;
	}
}

/// Create a new polynomial by copying the given one.
inline Polynomial(Polynomial copy!) = Polynomial.create(copy.degree(), copy.coefficients);

/// Create a new polynomial with the given values, coefficients are reversed(lowest index === highest degree)
Polynomial Polynomial(scalar values...) {
	Polynomial result& = Polynomial.create(values.length - 1, null);
	for (int i = 0; i < values.length; i += 1) {
		result.coefficients[i] = values[values.length - i - 1];
	}
	return result;
}
/// A 2d vector (2x float64)
struct vec2d: 0 {
	struct {
		/// X component of the vector
		float64 x;
		/// Y component of the vector
		float64 y;
	}
	/// Access the components as an array
	float64 data[2];

	/// Component wise add the two vectors.
	static vec2d add(vec2d a, vec2d b) { return inline(inline(a), inline(b), p128.add2d); }

	/// Component wise subtract the two vectors.
	static vec2d sub(vec2d a, vec2d b) { return inline(inline(a), inline(b), p128.sub2d); }

	/// Component wise multiply the two vectors.
	static vec2d mul(vec2d a, vec2d b) { return inline(inline(a), inline(b), p128.mul2d); }

	/// Component wise divide the two vectors.
	static vec2d div(vec2d a, vec2d b) { return inline(inline(a), inline(b), p128.div2d); }

	/// Component wise select the minimum from the two vectors.
	static vec2d min(vec2d a, vec2d b) { return inline(inline(a), inline(b), p128.min2d); }

	/// Component wise select the maximum from the two vectors.
	static vec2d max(vec2d a, vec2d b) { return inline(inline(a), inline(b), p128.max2d); }

	/// Compare the two vectors for equality.
	static bool ceq(vec2d a, vec2d b) { return inline(inline(a), inline(b), p128.ceq); }

	/// Dot product of thw two vectors
	static float64 dot(vec2d a, vec2d b) { return a.x * b.x + a.y * b.y; }
}

/// Initialize with given x, y components
vec2d vec2d(float64 x, float64 y) {
	return {
		x: x;
		y: y;
	};
}
/// A 4d vector (4x float32)
struct vec4f: 0 {
	struct {
		/// X component of the vector
		float32 x;
		/// Y component of the vector
		float32 y;
		/// Z component of the vector
		float32 z;
		/// W component of the vector
		float32 w;
	}
	/// Access the components as an array
	float32 data[4];

	/// Returns a negated copy of the vector.
	static vec4f neg(vec4f rhs) { return inline(inline(rhs), p128.neg4f); }

	/// Component wise add the two vectors.
	static vec4f add(vec4f lhs, vec4f rhs) { return inline(inline(lhs), inline(rhs), p128.add4f); }

	/// Component wise subtract the two vectors.
	static vec4f sub(vec4f lhs, vec4f rhs) { return inline(inline(lhs), inline(rhs), p128.sub4f); }

	/// Component wise multiply the two vectors.
	static vec4f mul(vec4f lhs, vec4f rhs) { return inline(inline(lhs), inline(rhs), p128.mul4f); }

	/// Component wise divide the two vectors.
	static vec4f div(vec4f lhs, vec4f rhs) { return inline(inline(lhs), inline(rhs), p128.div4f); }

//	/// Dot product of the first 3 elements
//	static float32 dp3(vec4f lhs, vec4f rhs) {
//		// dp3(vec4f a, vec4f b) = a.x * b.x + a.y * b.y + a.z * b.z;
//		return inline(inline(lhs), inline(rhs), p128.dp3);
//	}
//
//	/// Homogeneous dot product
//	static float32 dph(vec4f lhs, vec4f rhs) {
//		// dph(vec4f a, vec4f b) = a.x * b.x + a.y * b.y + a.z * b.z + a.w;
//		return inline(inline(lhs), inline(rhs), p128.dph);
//	}
//
//	/// Dot product
//	static float32 dp4(vec4f lhs, vec4f rhs) {
//		// dp4(vec4f a, vec4f b) = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
//		return inline(inline(lhs), inline(rhs), p128.dp4);
//	}

	/// Evaluate as a polynomial in point x
	static float32 eval(vec4f v, float32 x) {
		return ((v.w * x + v.z) * x + v.y) * x + v.x;
	}

	/*
	/// Component wise absolute value of a vector.
	inline abs(vec4f a) = vec4f(Float32.abs(a.x), Float32.abs(a.y), Float32.abs(a.z), Float32.abs(a.w));

	/// Component wise minimum of the two vectors.
	inline min(vec4f lhs, vec4f rhs) = vec4f(inline(vec4f(lhs), vec4f(rhs), p128.min4f));

	/// Component wise maximum of the two vectors.
	inline max(vec4f lhs, vec4f rhs) = vec4f(inline(vec4f(lhs), vec4f(rhs), p128.max4f));

	/// Clamp the vector component wise to the range [min ... max]
	inline clamp(vec4f vec, vec4f min, vec4f max) = min(max(vec, min), max);

	/// Clamp each component of the vector to the range [min ... max]
	inline clamp(vec4f vec, float32 min, float32 max) = clamp(vec, vec4f(min), vec4f(max));
	// */
}

/// Initialize with given x, y, z, w components
inline vec4f(float32 x, float32 y, float32 z, float32 w) = inline(float32(w), float32(z), float32(y), float32(x));

/// Initialize with  (x: x, y: y, z: z, w: 1)
inline vec4f(float32 x, float32 y, float32 z) = vec4f(x, y, z, 1f);

/// Initialize with (x: x, y: y, z: 0, w: 1)
inline vec4f(float32 x, float32 y) = vec4f(x, y, 0f, 1f);

/// Initialize x, y, z components using the components form the given vector, and w with the given value
inline vec4f(vec4f xyz, float32 w) = vec4f(xyz.x, xyz.y, xyz.z, w);

/// Initialize x, y, z, w components with the given scalar value
inline vec4f(vec4f val) = vec4f(inline(val));

/// Initialize all components using the components form the given vector
inline vec4f(float32 val) = vec4f(val, val, val, val);

/// Returns a negated copy of the vector.
inline -(vec4f rhs) = vec4f(inline(vec4f(rhs), p128.neg4f));

/// Component wise add the two vectors.
inline +(vec4f lhs, vec4f rhs) = vec4f(inline(vec4f(lhs), vec4f(rhs), p128.add4f));
/// Component wise add vector and scalar.
inline +(vec4f lhs, float32 rhs) = lhs + vec4f(rhs);
/// Component wise add vector and scalar.
inline +(float32 lhs, vec4f rhs) = vec4f(lhs) + rhs;

/// Component wise subtract the two vectors.
inline -(vec4f lhs, vec4f rhs) = vec4f(inline(vec4f(lhs), vec4f(rhs), p128.sub4f));
/// Component wise subtract vector and scalar.
inline -(vec4f lhs, float32 rhs) = lhs - vec4f(rhs);
/// Component wise subtract vector and scalar.
inline -(float32 lhs, vec4f rhs) = vec4f(lhs) - rhs;

/// Component wise multiply the two vectors.
inline *(vec4f lhs, vec4f rhs) = vec4f(inline(vec4f(lhs), vec4f(rhs), p128.mul4f));
/// Component wise multiply vector and scalar.
inline *(vec4f lhs, float32 rhs) = lhs * vec4f(rhs);
/// Component wise multiply vector and scalar.
inline *(float32 lhs, vec4f rhs) = vec4f(lhs) * rhs;

/// Component wise divide the two vectors.
inline /(vec4f lhs, vec4f rhs) = vec4f(inline(vec4f(lhs), vec4f(rhs), p128.div4f));
/// Component wise divide vector and scalar.
inline /(vec4f lhs, float32 rhs) = lhs / vec4f(rhs);
/// Component wise divide vector and scalar.
inline /(float32 lhs, vec4f rhs) = vec4f(lhs) / rhs;

/// Dot product of the first 3 elements
inline dp3(vec4f lhs, vec4f rhs) = float32(inline(inline(lhs), inline(rhs), p128.dp3));

/// Homogeneous dot product
inline dph(vec4f lhs, vec4f rhs) = float32(inline(inline(lhs), inline(rhs), p128.dph));

/// Dot product
inline dp4(vec4f lhs, vec4f rhs) = float32(inline(inline(lhs), inline(rhs), p128.dp4));

/// Cross product of the first 3 elements
static vec4f cross(vec4f a, vec4f b) {
	return {
		x: a.y * b.z - a.z * b.y;
		y: a.z * b.x - a.x * b.z;
		z: a.x * b.y - a.y * b.x;
		w: 1;
	};
}

/// Length of the vector(xyz)
inline length(vec4f v) = Float32.sqrt(dp3(v, v));
/// Normalize the vector(xyz)
inline normalize(vec4f v!) = v / vec4f(length(v));

/// linear interpolate
inline mix(vec4f a, vec4f b, float32 t) = vec4f(
	Float32.mix(a.x, b.x, t),
	Float32.mix(a.y, b.y, t),
	Float32.mix(a.z, b.z, t),
	Float32.mix(a.w, b.w, t)
);

/* TODO: leftovers
inline ceq(vec4f x, vec4f y) = inline(ceq.p4f, vec4f(y), vec4f(x));
inline bool(vec4f vec) = bool(vec.x && vec.y && vec.z && vec.w);
*/
/// Append a string to the output at the given position
int append(char output&[], int pos, char str[]) {
	if (pointer(str) == null) {
		return append(output, pos, "NULL");
	}
	for (int i = 0; i < str.length; i += 1) {
		if (pos >= output.length) {
			break;
		}
		output[pos] = str[i];
		pos += 1;
	}

	if (pos >= output.length) {
		pos = output.length - 1;
	}
	output[pos] = 0;
	return pos;
}

/// Append a character to the output at the given position
int append(char output&[], int pos, char chr) {
	if (chr == 0 || pos >= output.length) {
		return pos;
	}
	output[pos] = chr;
	return pos + 1;
}

inline "./format/NumberFormat.cmpl";
inline "./format/DatetimeFormat.cmpl";

// read and process c style format flags like: "%02d"
static NumberFormat parseFormat(char format[], int fmt&) {
	char chr = format[fmt];
	if (chr != '%') {
		return {};
	}

	NumberFormat result = {};
	chr = format[fmt += 1];
	if (chr == '+') {
		// force sign
		result.positiveSymbol = '+';
		chr = format[fmt += 1];
	}

	if (chr == '0' || chr == ' ') {// || chr == '_') {
		result.paddingSymbol = chr;
		chr = format[fmt += 1];
	}

	if (chr >= '0' && chr <= '9') {
		int width = 0;
		for (;chr >= '0' && chr <= '9';) {
			width = width * 10 + chr - '0';
			chr = format[fmt += 1];
		}
		result.width = width;
	}

	if (chr == '.') {
		int precision = 0;
		chr = format[fmt += 1];
		for (;chr >= '0' && chr <= '9';) {
			precision = precision * 10 + chr - '0';
			chr = format[fmt += 1];
		}
		result.precision = precision;
	}

	if (chr == 'b') {
		result.digitSymbols = NumberFormat.digits[...2];
	}
	else if (chr == 'o') {
		result.digitSymbols = NumberFormat.digits[...8];
	}
	else if (chr == 'd') {
		result.digitSymbols = NumberFormat.digits[...10];
	}
	else if (chr == 'x') {
		result.digitSymbols = NumberFormat.digits[...16];
	}
	return result;
}

/**
 * Format integer to text
 * @param value value to format
 * @param output write output to this buffer
 * @param pos starting position for output
 * @param format format string
 *  	%b format as binary
 *  	%o format as octal
 *  	%d format as decimal
 *  	%x format as hexadecimal
 *  	%i format with custom radix passed as precision
 */
int format(uint64 value, char output&[], int out, char format[]) {
	for (int fmt = 0; out < output.length && fmt < format.length; fmt += 1) {
		char chr = format[fmt];
		if (chr != '%') {
			output[out] = chr;
			out += 1;
			continue;
		}

		NumberFormat formatter = parseFormat(format, &fmt);
		chr = format[fmt];

		if (chr == '%') {
			out = append(output, out, '%');
			continue;
		}
		else if (chr == 'i') {
			assert(formatter.precision > 1, "radix must be set and must be at least 2");
			assert(formatter.precision < NumberFormat.digits.length, "maximum radix value is", NumberFormat.digits.length);
			formatter.digitSymbols = NumberFormat.digits[...formatter.precision];
		}
		else if (chr != 'b' && chr != 'o' && chr != 'd' && chr != 'x') {
			abort("invalid format character", chr);
		}

		if (formatter.digitSymbols.length != 10) {
			out = formatter.formatNoSign(output, out, value);
		} else {
			out = formatter.format(output, out, value);
		}
	}

	if (out >= output.length) {
		out = output.length - 1;
	}
	output[out] = 0;
	return out;
}

/**
 * Format integer to text
 * @param value value to format
 * @param output write output to this buffer
 * @param pos starting position for output
 * @param format format string
 *  	%b format as binary
 *  	%o format as octal
 *  	%d format as decimal
 *  	%x format as hexadecimal
 *  	%i format with custom radix passed as precision
 */
int format(int64 value, char output&[], int out, char format[]) {
	for (int fmt = 0; out < output.length && fmt < format.length; fmt += 1) {
		char chr = format[fmt];
		if (chr != '%') {
			output[out] = chr;
			out += 1;
			continue;
		}

		NumberFormat formatter = parseFormat(format, &fmt);
		chr = format[fmt];

		if (chr == '%') {
			out = append(output, out, '%');
			continue;
		}
		else if (chr == 'i') {
			assert(formatter.precision > 1, "radix must be set and must be at least 2");
			assert(formatter.precision < NumberFormat.digits.length, "maximum radix value is", NumberFormat.digits.length);
			formatter.digitSymbols = NumberFormat.digits[...formatter.precision];
		}
		else if (chr != 'b' && chr != 'o' && chr != 'd' && chr != 'x') {
			abort("invalid format character", chr);
		}

		if (formatter.digitSymbols.length != 10) {
			out = formatter.formatNoSign(output, out, value);
		} else {
			out = formatter.format(output, out, value);
		}
	}

	if (out >= output.length) {
		out = output.length - 1;
	}
	output[out] = 0;
	return out;
}

/**
 * Format integer to text
 * @param value value to format
 * @param output write output to this buffer
 * @param pos starting position for output
 * @param format format string
 *  	%b format as binary
 *  	%o format as octal
 *  	%d format as decimal
 *  	%x format as hexadecimal
 *  	%i format with custom radix passed as precision
 */
int format(int32 value, char output&[], int out, char format[]) {
	for (int fmt = 0; out < output.length && fmt < format.length; fmt += 1) {
		char chr = format[fmt];
		if (chr != '%') {
			output[out] = chr;
			out += 1;
			continue;
		}

		NumberFormat formatter = parseFormat(format, &fmt);
		chr = format[fmt];

		if (chr == '%') {
			out = append(output, out, '%');
			continue;
		}
		else if (chr == 'i') {
			assert(formatter.precision > 1, "radix must be set and must be at least 2");
			assert(formatter.precision < NumberFormat.digits.length, "maximum radix value is", NumberFormat.digits.length);
			formatter.digitSymbols = NumberFormat.digits[...formatter.precision];
		}
		else if (chr != 'b' && chr != 'o' && chr != 'd' && chr != 'x') {
			abort("invalid format character", chr);
		}

		if (formatter.digitSymbols.length != 10) {
			out = formatter.formatNoSign(output, out, uint32(value));
		} else {
			out = formatter.format(output, out, int64(value));
		}
	}

	if (out >= output.length) {
		out = output.length - 1;
	}
	output[out] = 0;
	return out;
}

/**
 * Format a 64-bit floating-point value
 * @param value value to format
 * @param output write output to this buffer
 * @param pos starting position for output
 * @param format format string
 *  	%d format as decimal(%lg): => 3.141593
 *  	%f format as fixed precision(%lf) (always pad with `0` at the end)
 *  	%b, %o, %x can be used to display the binary representation of the number
 */
//  	%e todo: format as exponential(%le): 3.141593e+00
//  	%x todo: format as hexadecimal(%la): 0x1.921fb54442d18p+1
int format(float64 value, char output&[], int out, char format[]) {
	for (int fmt = 0; out < output.length && fmt < format.length; fmt += 1) {
		char chr = format[fmt];
		if (chr != '%') {
			output[out] = chr;
			out += 1;
			continue;
		}

		NumberFormat formatter = parseFormat(format, &fmt);
		chr = format[fmt];

		if (chr == '%') {
			out = append(output, out, '%');
			continue;
		}
		else if (chr == 'd') { // decimal: 3.1415
			formatter.trailingZeros = false;
			out = formatter.format(output, out, value);
		}
		else if (chr == 'f') { // fixed: 3.141500
			formatter.trailingZeros = true;
			out = formatter.format(output, out, value);
		}
		else if (chr == 'b' || chr == 'o' || chr == 'x') {
			if (formatter.precision > 0) {
				formatter.digitGrouping = formatter.precision;
				formatter.groupingSymbol = '.';
			}
			out = formatter.formatNoSign(output, out, Float64.toBits(value));
		}
		else {
			abort("invalid format character", chr);
		}
	}

	if (out >= output.length) {
		out = output.length - 1;
	}
	output[out] = 0;
	return out;
}

/**
 * Format a 32-bit floating-point value
 * @param value value to format
 * @param output write output to this buffer
 * @param pos starting position for output
 * @param format format string
 *  	%d format as decimal(%lg): => 3.141593
 *  	%f format as fixed precision(%lf) (always pad with `0` at the end)
 *  	%b, %o, %x can be used to display the binary representation of the number
 */
//  	%e todo: format as exponential(%le): 3.141593e+00
int format(float32 value, char output&[], int out, char format[]) {
	for (int fmt = 0; out < output.length && fmt < format.length; fmt += 1) {
		char chr = format[fmt];
		if (chr != '%') {
			output[out] = chr;
			out += 1;
			continue;
		}

		NumberFormat formatter = parseFormat(format, &fmt);
		chr = format[fmt];

		if (chr == '%') {
			out = append(output, out, '%');
			continue;
		}
		else if (chr == 'd') { // decimal: 3.1415
			formatter.trailingZeros = false;
			out = formatter.format(output, out, float64(value));
		}
		else if (chr == 'f') { // fixed: 3.141500
			formatter.trailingZeros = true;
			out = formatter.format(output, out, float64(value));
		}
		else if (chr == 'b' || chr == 'o' || chr == 'x') {
			if (formatter.precision > 0) {
				formatter.digitGrouping = formatter.precision;
				formatter.groupingSymbol = '.';
			}
			out = formatter.formatNoSign(output, out, Float32.toBits(value));
		}
		else {
			abort("invalid format character", chr);
		}
	}

	if (out >= output.length) {
		out = output.length - 1;
	}
	output[out] = 0;
	return out;
}

/**
 * Format a 32-bit fixed-point value
 * @param value value to format
 * @param output write output to this buffer
 * @param pos starting position for output
 * @param format format string
 *  	%d format as decimal(%lg): => 3.141593
 *  	%f format as fixed precision(%lf) (always pad with `0` at the end)
 *  	%b, %o, %x can be used to display the binary representation of the number
 */
//  	%e todo: format as exponential(%le): 3.141593e+00
int format(Fixed32 value, char output&[], int out, char format[]) {
	for (int fmt = 0; out < output.length && fmt < format.length; fmt += 1) {
		char chr = format[fmt];
		if (chr != '%') {
			output[out] = chr;
			out += 1;
			continue;
		}

		NumberFormat formatter = parseFormat(format, &fmt);
		chr = format[fmt];

		if (chr == '%') {
			out = append(output, out, '%');
		}
		else if (chr == 'd') { // decimal: 3.1415
			formatter.trailingZeros = false;
			out = formatter.format(output, out, value);
		}
		else if (chr == 'f') { // fixed: 3.141500
			formatter.trailingZeros = true;
			out = formatter.format(output, out, value);
		}
		else if (chr == 'b' || chr == 'o' || chr == 'x') {
			if (formatter.precision > 0) {
				formatter.digitGrouping = formatter.precision;
				formatter.groupingSymbol = '.';
			}
			out = formatter.formatNoSign(output, out, uint32(value.bits()));
		}
		else {
			abort("invalid format character", chr);
		}
	}

	if (out >= output.length) {
		out = output.length - 1;
	}
	output[out] = 0;
	return out;
}

/// extension method for backward compatibility
int format(Datetime value!, char output&[], int out, char format[]) {
	static DatetimeFormat fmt! = {
		numberFormat: {};
	};
	return fmt.format(output, out, value, format);
}

/// extension method for backward compatibility
inline format(Datetime value!, char output&[], char format[]) = format(value, output, 0, format);

/// extension method for debugging and testing
inline format(float64 value, char output&[], char format[]) = format(value, output, 0, format);
/// extension method for debugging and testing
inline format(float32 value, char output&[], char format[]) = format(value, output, 0, format);
/// extension method for debugging and testing
inline format(Fixed32 value, char output&[], char format[]) = format(value, output, 0, format);

/// extension method for debugging and testing
inline format(uint32 value, char output&[], int pos, char format[]) = format(uint64(value), output, pos, format);
// extension method for debugging and testing
// inline format(int32 value, char output&[], int pos, char format[]) = format(int64(value), output, pos, format);

/// extension method for debugging and testing
inline format(uint64 value, char output&[], char format[]) = format(value, output, 0, format);
/// extension method for debugging and testing
inline format(int64 value, char output&[], char format[]) = format(value, output, 0, format);

/// extension method for debugging and testing
inline format(uint32 value, char output&[], char format[]) = format(value, output, 0, format);
/// extension method for debugging and testing
inline format(int32 value, char output&[], char format[]) = format(value, output, 0, format);
// string related functions

/// Computes the length of the string
int length(char str[*]) {
	if (str == null) {
		return 0;
	}
	int result = 0;
	for (; str[result]; result += 1) {
	}
	return result;
}

/// Returns the index of the first occurrence of a character in string
int indexOf(char str[], char chr, int start) {
	for (int i = start; i < str.length; i += 1) {
		if (str[i] == chr) {
			return i;
		}
	}
	return -1;
}

/// Returns the position of a character inside an array of characters, returns a negative value if not found.
inline indexOf(char str[], char chr) = indexOf(str, chr, 0);

/// Check if a string contains the given character
inline contains(char str[], char chr) = indexOf(str, chr, 0) >= 0;

// compare the first n elements of two arrays, like memcmp
int compare(char str[*], char with[*], int length, int cmp(char chr, char with)) {
	if (cmp == null) {
		return pointer.compare(str, with, length);
	}
	for (int i = 0; i < length; i += 1) {
		int cmp = cmp(str[i], with[i]);
		if (cmp != 0) {
			return cmp;
		}
	}
	return 0;
}

/// ignore case character comparator
int ignCaseCmp(char a, char b) {
	// todo: performance check vs. a lookup table
	// make both characters lowercase
	if (a >= 'A' & a <= 'Z') {
		a -= 'A' - 'a';
	}
	if (b >= 'A' & b <= 'Z') {
		b -= 'A' - 'a';
	}
	return a - b;
}

/// default character comparator
int caseCmp(char chr, char with) = null;

/// Check if a string begins with a specified string, using a custom comparator
bool startsWith(char str[], char with[], int cmp(char chr, char with)) {
	if (str.length < with.length) {
		return false;
	}
	return compare(str, with, with.length, cmp) == 0;
}

/// Check if a string ends in a specified string, using a custom comparator
bool endsWith(char str[], char with[], int cmp(char chr, char with)) {
	if (str.length < with.length) {
		return false;
	}
	char end![*] = str.inc(str.length - with.length);
	return compare(end, with, with.length, cmp) == 0;
}

/// Check if the two strings are equal, less or greater, using a custom comparator
int compare(char str[], char with[], int cmp(char chr, char with)) {
	int length = str.length < with.length ? str.length : with.length;
	int result = compare(str, with, length, cmp);
	if (result != 0) {
		return result;
	}
//	return str.length - with.length;
	if (str.length < with.length) {
		return -1;
	}
	if (str.length > with.length) {
		return 1;
	}
	return 0;
}

/// convert lower part (4 bits) of the input value to the corresponding lower case hexadecimal character
inline toHex(int value) = "0123456789abcdef"[value & 0xf];

/// Check if a string begins with a specified string, using case-sensitive comparison
inline startsWith(char str[], char with[]) = startsWith(str, with, caseCmp);
/// Check if a string ends in a specified string, using case-sensitive comparison
inline endsWith(char str[], char with[]) = endsWith(str, with, caseCmp);
/// Check if the two strings are equal, less or greater, using case-sensitive comparison
inline compare(char str[], char with[]) = compare(str, with, caseCmp);
/// Check if the two strings are equal, using case-sensitive comparison
inline equals(char str[], char with[]) = compare(str, with, caseCmp) == 0;

/// reverse the characters in the string between start and end
static void reverse(char str&[], int start, int end) {
	assert(start >= 0 && start <= str.length);
	assert(end >= 0 && end <= str.length);
	if (start >= end) {
		return;
	}
	assert(start <= end);
	for (end -= 1; start < end; ) {
		char swap = str[start];
		str[start] = str[end];
		str[end] = swap;
		start += 1;
		end -= 1;
	}
}

/// remove the characters in the string between start and end
static void remove(char str&[], int start, int end) {
	assert(start >= 0 && start <= str.length);
	assert(end >= 0 && end <= str.length);
	if (start >= end) {
		return;
	}
	assert(start <= end);
	for (; end < str.length; ) {
		str[start] = str[end];
		start += 1;
		end += 1;
	}
}

/* TODO: implement operator overloading
inline ==(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) == 0;
inline !=(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) != 0;
inline <=(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) <= 0;
inline >=(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) >= 0;
inline <(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) < 0;
inline >(char lhs[], char rhs[]) = compare(lhs, rhs, caseCmp) > 0;
// */

/// Convert a string to a 64 bit floating point value
float64 float64(char value[]) {
	float64 result = 0;
	static if (preferNativeCalls && struct(float64.parse) != null) {
		// use the native method if available
		int len = float64.parse(value, &result);
		if (len > 0 && len == value.length) {
			return result;
		}
		if (len > 0 && value[len] == 0) {
			return result;
		}
		error("value is not a floating point number", len, result, value);
		return Float64.nan;
	}

	float64 sign = 1;
	float64 decimal = 0;

	for (int i = 0; i < value.length && value[i] != 0; i += 1) {
		char chr = value[i];
		if (chr >= '0' && chr <= '9') {
			result = result * 10 + (chr - '0');
			decimal *= 10;
		}
		else if (chr == '.') {
			if (decimal != 0) {
				// multiple decimal points
				return Float64.nan;
			}
			decimal = 1;
		}
		else if (chr == '-' && i == 0) {
			sign = -1;
		}
		else if (chr == '+' && i == 0) {
			sign = 1;
		}
		else {
			// invalid character
			return Float64.nan;
		}
	}

	if (decimal == 0) {
		if (value.length > 0) {
			return sign * result;
		}
	}
	return sign * result / decimal;
}
/// Ascii reader converts the given input by mapping every byte to a character
struct AsciiReader: TextReader {
	// convert bytes to chars
	int decode(AsciiReader this, unicode chars&[]) {
		ByteReader reader = this.reader;
		for (int i = 0; i < chars.length; i += 1) {
			uint8 value[1] = {...};
			if (reader.read(value) <= 0) {
				// end of stream
				return i;
			}
			chars[i] = value[0];
		}
		return chars.length;
	}
}

/// Ascii Writer converts the given input by chopping each character to a byte
struct AsciiWriter: TextWriter {
	// convert characters to bytes(can cause data loss)
	void encode(TextWriter this, unicode chars[]) {
		ByteWriter writer = this.writer;
		for (int i = 0; i < chars.length; i += 1) {
			uint8 value![1] = {chars[i]};
			writer.write(value);
		}
	}
}
/// Utf-8 decoder
struct Utf8Reader: TextReader {
	// convert utf-8 bytes to unicode codepoints
	int decode(Utf8Reader this, unicode chars&[]) {
		uint8 buff[1] = {...};
		uint8 ext[3] = {...};
		ByteReader reader = this.reader;
		for (int i = 0; i < chars.length; i += 1) {
			if (reader.read(buff) <= 0) {
				// end of stream
				return i;
			}

			if ((buff[0] & 0x80) == 0) {
				chars[i] = buff[0];
			}
			else if ((buff[0] & 0xe0) == 0xc0) {
				if (reader.read(ext[...1]) != 1) {
					error("invalid codepoint");
					return i;
				}
				assert((ext[0] & 0b11000000) == 0b10000000, "10xxxxxx");
				chars[i] = (buff[0] & 0x1f) << 6 | (ext[0] & 0x3f);
			}
			else if ((buff[0] & 0xf0) == 0xe0) {
				if (reader.read(ext[...2]) != 2) {
					error("invalid codepoint");
					return i;
				}
				assert((ext[0] & 0b11000000) == 0b10000000, "10xxxxxx");
				assert((ext[1] & 0b11000000) == 0b10000000, "10xxxxxx");
				chars[i] = (buff[0] & 0x0f) << 12 | (ext[0] & 0x3f) << 6 | (ext[1] & 0x3f);
			}
			else if ((buff[0] & 0xf8) == 0xf0) {
				if (reader.read(ext[...3]) != 3) {
					error("invalid codepoint");
					return i;
				}
				assert((ext[0] & 0b11000000) == 0b10000000, "10xxxxxx");
				assert((ext[1] & 0b11000000) == 0b10000000, "10xxxxxx");
				assert((ext[2] & 0b11000000) == 0b10000000, "10xxxxxx");
				chars[i] = (buff[0] & 0x07) << 18 | (ext[0] & 0x3f) << 12 | (ext[1] & 0x3f) << 6 | (ext[2] & 0x3f);
			}
		}
		return chars.length;
	}
}

/// Utf-8 encoder
// adapted from: https://github.com/devatrun/sutfcpplib/blob/main/include/sutfcpplib/utf_codepoint.h#L287
struct Utf8Writer: TextWriter {
	// convert unicode codepoints to utf-8 bytes
	void encode(Utf8Writer this, unicode chars[]) {
		ByteWriter writer = this.writer;
		for (int i = 0; i < chars.length; i += 1) {
			unicode cp = chars[i];

			if (cp < 0x80) {
				uint8 bytes![1] = {cp};
				writer.write(bytes[...1]);
			}
			else if (cp < 0x800) {
				uint8 bytes![2] = {
					0b11000000 | (cp >> 6);
					0b10000000 | (cp & 0b00111111);
				};
				writer.write(bytes[...2]);
			}
			else if (cp < 0x10000) {
				uint8 bytes![3] = {
					0b11100000 | (cp >> 12);
					0b10000000 | ((cp >> 6) & 0b00111111);
					0b10000000 | (cp & 0b00111111);
				};
				writer.write(bytes[...3]);
			}
			else { /*if (cp < 0x110000)*/
				uint8 bytes![4] = {
					0b11110000 | (cp >> 18);
					0b10000000 | ((cp >> 12) & 0b00111111);
					0b10000000 | ((cp >> 6) & 0b00111111);
					0b10000000 | (cp & 0b00111111);
				};
				writer.write(bytes[...4]);
			}
		}
	}
}
/// Base64 encoder
struct Base64Encoder: ByteWriter {
	static uint8 lookup![] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	///@public
	ByteWriter writer;

	uint8 buffer[1024];
	int bufferSize = 0;
	int padding = 0;

	/// wrap at the given position with a newline
	int wrap = 80;
	int wrapSize = 0;

	static void flushBuffer(Base64Encoder this) {
		ByteWriter writer = this.writer;
		int size = this.bufferSize;

		int wrap = this.wrap - this.wrapSize;
		if (wrap > size || this.wrap == 0) {
			wrap = size;
		}

		writer.write(writer, this.buffer[...wrap]);
		this.wrapSize += wrap;

		// print the rest of the buffer as one or multiple lines
		for ( ; wrap < size; ) {
			writer.write(writer, "\n");

			int len = Int.min(size - wrap, this.wrap);
			uint8 buffer![*] = this.buffer.inc(wrap);
			writer.write(writer, buffer[...len]);
			this.wrapSize = len;
			wrap += len;
		}
		this.bufferSize = 0;
	}

	void write(Base64Encoder this, uint8 data[]) {
		assert(buffer.length > 3);

		ByteWriter writer = this.writer;
		uint8 buffer[] = this.buffer;
		int size& = this.bufferSize;
		int i = 0;

		// revert padding and continue encoding (not mandatory, but reduces output size)
		if (size > 3 && buffer[size - 1] == '=' && data.length > 0) {
			if (buffer[size - 2] == '=') {
				if (data.length < 2) {
					// debug("convert padding: 62== to 664=");
					int32 b = (this.padding << 6)
						| ((data[i] & 0xff) << 2);
					buffer[size - 3] = lookup[b >> 6 & 0x3f];
					buffer[size - 2] = lookup[b & 0x3f];
					this.padding = b;
					return;
				}
				// debug("revert padding: 62==");
				int32 b = (this.padding << 12)
					| ((data[i] & 0xff) << 8)
					| (data[i + 1] & 0xff);
				buffer[size - 3] = lookup[b >> 12 & 0x3f];
				buffer[size - 2] = lookup[b >> 6 & 0x3f];
				buffer[size - 1] = lookup[b & 0x3f];
				i += 2;
			} else {
				// debug("revert padding: 664=");
				int32 b = (this.padding << 6)
					| (data[i] & 0xff);
				buffer[size - 2] = lookup[b >> 6 & 0x3f];
				buffer[size - 1] = lookup[b & 0x3f];
				i += 1;
			}
		}

		// fast loop: read 3 and write 4 bytes at once
		for (int n = data.length - 2; i < n; i += 3) {
			if (size + 4 > buffer.length) {
				flushBuffer(this);
			}

			// Encode the 3 bytes into 4 bytes: 3 * 8 = 4 * 6
			int32 b = ((data[i + 0] & 0xff) << 16)
					| ((data[i + 1] & 0xff) << 8)
					| ((data[i + 2] & 0xff) << 0);
			buffer[size + 0] = lookup[b >> 18 & 0x3f];
			buffer[size + 1] = lookup[b >> 12 & 0x3f];
			buffer[size + 2] = lookup[b >> 6 & 0x3f];
			buffer[size + 3] = lookup[b & 0x3f];
			size += 4;
		}

		// if the input size is not multiple of 3 bytes, add padding, so output will be multiple of 4
		if (int left = data.length - i) {
			if (size + 4 > buffer.length) {
				flushBuffer(this);
			}
			if (left == 2) {
				// 2 bytes = 16 bits => 6 + 6 + 4 + =
				int32 b = ((data[i + 0] & 0xff) << 10)
						| ((data[i + 1] & 0xff) << 2);
				buffer[size + 0] = lookup[b >> 12 & 0x3f];
				buffer[size + 1] = lookup[b >> 6 & 0x3f];
				buffer[size + 2] = lookup[b & 0x3f];
				buffer[size + 3] = '=';
				this.padding = b;
				size += 4;
			} else {
				// 1 bye = 8 bits = 6 + 2 + = + =
				int32 b = (data[i] & 0xff) << 4;
				buffer[size + 0] = lookup[(b >> 6) & 0x3f];
				buffer[size + 1] = lookup[(b >> 0) & 0x3f];
				buffer[size + 2] = '=';
				buffer[size + 3] = '=';
				this.padding = b;
				size += 4;
			}
		}
	}

	void flush(Base64Encoder this) {
		this.flushBuffer();
		this.writer.flush();
	}

	void close(Base64Encoder this) {
		this.flushBuffer();
	}
}

/// Base64 decoder
struct Base64Decoder: ByteReader {
	static int lookup![256] = {
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,
		52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -2, -1, -1,
		-1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,
		15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,
		-1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
		41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
	};

	///@public
	ByteReader reader;

	// TODO: make it buffered
	int bitsDecoded = 0;
	int charDecoded = 0;

	int read(Base64Decoder this, uint8 data&[]) {
		inline isWhite(char c) = c == ' ' || c == '\t' || c == '\n' || c == '\r';

		uint8 in[1] = {...};
		ByteReader reader = this.reader;
		int bitsDecoded& = this.bitsDecoded;
		int charDecoded& = this.charDecoded;
		for (int i = 0; i < data.length;) {
			if (reader.read(reader, in) <= 0) {
				return i;
			}
			else if (in[0] == '=') {
				bitsDecoded -= 2;
			}
			else if (!isWhite(in[0])) {
				bitsDecoded += 6;
				charDecoded <<= 6;
				charDecoded |= lookup[in[0]] & 0x3f;
				if (bitsDecoded >= 8) {
					bitsDecoded -= 8;
					data[i] = charDecoded >> bitsDecoded;
					i += 1;
				}
			}
		}
		return data.length;
	}

	void close(Base64Decoder this) {
		assert(this.bitsDecoded == 0, "unprocessed bits remaining.", this.bitsDecoded);
	}
}
/// datetime regional formatter, currently 'en' if instantiated with: `DatetimeFormat fmt = {};`
struct DatetimeFormat {
	static char monthsLongEn![][] = {
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December",
	};
	static char monthsShortEn![][] = {
		"Jan", "Feb", "Mar", "Apr",
		"May", "Jun", "Jul", "Aug",
		"Sep", "Oct", "Nov", "Dec",
	};
	static char weeksLongEn![][] = {
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday",
		"Sunday",
	};
	static char weeksShortEn![][] = {
		"Mon", "Tue", "Wed",
		"Thu", "Fri", "Sat",
		"Sun",
	};
	static char amPmUpperEn![][] = {
		"AM",
		"PM"
	};
	static char amPmLowerEn![][] = {
		"am",
		"pm"
	};

	// formatter for the separate numbers
	NumberFormat numberFormat;

	char monthsLong![][] = monthsLongEn;
	char monthsShort![][] = monthsShortEn;
	char weeksLong![][] = weeksLongEn;
	char weeksShort![][] = weeksShortEn;
	char amPmUpper![][] = amPmUpperEn;
	char amPmLower![][] = amPmLowerEn;
	char dateLong![] = "%A %d %B %Y";
	char timeLong![] = "%r";
	char dateShort![] = "%x";
	char timeShort![] = "%I:%M %p";

	/** Format date to text
	 * @param formatter the formatter to be used
	 * @param output write output to this buffer
	 * @param end position in buffer where to print the datetime
	 * @param value date to format
	 * @param format format string
	 *  	@null defaults to: "%Y.%m.%d"
	 */
	static int format(DatetimeFormat formatter!, char output&[], int end, Datetime value!, char format[]) {
		static int append(DatetimeFormat formatter!, char output&[], int end, uint64 value, int width, int defaultWidth, int pad) {
			// todo: this should be the same and as simple as: NumberFormat format = { *: formatter.numberFormat, width, paddingSymbol };
			NumberFormat format = {
				digitSymbols: formatter.numberFormat.digitSymbols;
				positiveSymbol: formatter.numberFormat.positiveSymbol;
				negativeSymbol: formatter.numberFormat.negativeSymbol;
				infinitySymbol: formatter.numberFormat.infinitySymbol;
				undefinedSymbol: formatter.numberFormat.undefinedSymbol;
				groupingSymbol: formatter.numberFormat.groupingSymbol;
				digitGrouping: formatter.numberFormat.digitGrouping;
				firstGrouping: formatter.numberFormat.firstGrouping;
				fractGrouping: formatter.numberFormat.fractGrouping;
				paddingSymbol: pad;
				width: width > 0 ? width : defaultWidth;
				fractionSymbol: formatter.numberFormat.fractionSymbol;
				trailingSeparator: formatter.numberFormat.trailingSeparator;
				precision: formatter.numberFormat.precision;
				trailingZeros: formatter.numberFormat.trailingZeros;
			};
			return format.format(output, end, uint64(value));
		}
		inline hours24to12(int32 hour) = hour > 12 ? hour - 12 : hour == 0 ? 12 : hour;

		if (pointer(format) == null) {
			return formatter.format(output, end, value, "%Y.%m.%d");
		}

		char chr = 0;
		for (int pos = 0; pos < format.length; pos += 1) {
			if (end >= output.length) {
				output[output.length - 1] = 0;
				return output.length - 1;
			}

			chr = format[pos];
			if (chr != '%') {
				output[end] = chr;
				end += 1;
				continue;
			}

			pos += 1;
			chr = format[pos];

			/* By default, date pads numeric fields with zeroes. The following optional flags may follow '%':
			 - (hyphen) do not pad the field
			 _ (underscore) pad with spaces
			 0 (zero) pad with zeros
			 + pad with zeros, and put '+' before future years with >4 digits
			 ^ use upper case if possible
			 # use opposite case if possible
			 */

			char pad = '0';
			if (chr == '-' || chr == '_' || chr == '0' || chr == '+' || chr == '^' || chr == '#') {
				if (chr == '-') {
					pad = 0;
				}
				else if (chr == '_') {
					pad = ' ';
				}
				else if (chr == '0') {
					pad = '0';
				}
				else {
					abort("unimplemented format flag character [for padding]", chr);
				}
				pos += 1;
				chr = format[pos];
			}

			/* After any flags comes an optional field width, as a decimal
			 number; then an optional modifier, which is either E to use the
			 locale's alternate representations if available, or O to use the
			 locale's alternate numeric symbols if available.
			 */

			int32 width = 0;
			for (;chr >= '0' && chr <= '9';) {
				width = width * 10 + chr - '0';
				pos += 1;
				chr = format[pos];
			}

			char formatLocale = '0';
			if (chr == 'E' || chr == 'O') {
				abort("unimplemented format flag character [for locale]", chr);
				formatLocale = chr;
				pos += 1;
				chr = format[pos];
			}

			chr = format[pos];

			if (chr == '%') {
				end = append(output, end, "%");
			}
			else if (chr == 'a') {
				// %a     locale's abbreviated weekday name (e.g., en_US: [Sun, Mon, ..., Sat]; de_DE: [So, Mo, ..., Sa])
				end = append(output, end, formatter.weeksShort[indexOf(value.dayOfWeek)]);
			}
			else if (chr == 'A') {
				// %A     locale's full weekday name (e.g., en_US: [Sunday, ..., Saturday]; de_DE: [Sonntag, ..., Samstag])
				end = append(output, end, formatter.weeksLong[indexOf(value.dayOfWeek)]);
			}
			else if (chr == 'b') {
				// %b     locale's abbreviated month name (e.g., en_US: [Jan, Feb, ..., Dec]; de_DE: [Jan, Feb, ..., Dez])
				end = append(output, end, formatter.monthsShort[indexOf(value.month)]);
			}
			else if (chr == 'B') {
				// %B     locale's full month name (e.g., en_US: [January, ..., December];de_DE: [Januar, ..., Dezember])
				end = append(output, end, formatter.monthsLong[indexOf(value.month)]);
			}
//			else if (chr == 'c') // todo: %c     locale's date and time (e.g., Thu Mar  3 23:05:25 2005)
			else if (chr == 'C') {
				// %C     century; like %Y, except omit last two digits (e.g., 20)
				end = append(formatter, output, end, value.year / 100, width, 2, pad);
			}
			else if (chr == 'd') {
				// %d     day of month (e.g., 01)
				end = append(formatter, output, end, value.day, width, 2, pad);
			}
			else if (chr == 'D') {
				// %D     date; same as %m/%d/%y
				end = formatter.format(output, end, value, "%m/%d/%y");
			}
			else if (chr == 'e') {
				// %e     day of month, space padded; same as %_d
				end = append(formatter, output, end, value.day, width, 2, ' ');
			}
			else if (chr == 'F') {
				// %F     full date; like %+4Y-%m-%d
				end = formatter.format(output, end, value, "%04Y-%m-%d");
			}
//			else if (chr == 'g') // todo: %g     last two digits of year of ISO week number (see %G)
//			else if (chr == 'G') // todo: %G     year of ISO week number (see %V); normally useful only with %V
			else if (chr == 'h') {
				// %h     same as %b
				end = append(output, end, formatter.monthsShort[indexOf(value.month)]);
			}
			else if (chr == 'H') {
				// %H     hour (00..23)
				end = append(formatter, output, end, value.hour, width, 2, pad);
			}
			else if (chr == 'I') {
				// %I     hour (01..12)
				end = append(formatter, output, end, hours24to12(value.hour), width, 2, pad);
			}
			else if (chr == 'j') {
				// %j     day of year (001..366)
				end = append(formatter, output, end, value.dayOfYear, width, 3, pad);
			}
			else if (chr == 'k') {
				// %k     hour, space padded ( 0..23); same as %_H
				end = append(formatter, output, end, value.hour, width, 2, ' ');
			}
			else if (chr == 'l') {
				// %l     hour, space padded ( 1..12); same as %_I
				end = append(formatter, output, end, hours24to12(value.hour), width, 2, ' ');
			}
			else if (chr == 'm') {
				// %m     month (01..12)
				end = append(formatter, output, end, indexOf(value.month) + 1, width, 2, pad);
			}
			else if (chr == 'M') {
				// %M     minute (00..59)
				end = append(formatter, output, end, value.minute, width, 2, pad);
			}
			else if (chr == 'n') {
				// %n     a newline
				end = append(output, end, "\n");
			}
			else if (chr == 'N') {
				// fixme: precision
				// %N     nanoseconds (000000000..999999999)
				end = append(formatter, output, end, value.millis * 1000000, width, 9, pad);
			}
			else if (chr == 'p') {
				// %p     locale's equivalent of either AM or PM; blank if not known
				end = append(output, end, formatter.amPmUpper[int(value.hour < 12)]);
			}
			else if (chr == 'P') {
				// %P     like %p, but lower case
				end = append(output, end, formatter.amPmLower[int(value.hour < 12)]);
			}
//			else if (chr == 'q') // todo: %q     quarter of year (1..4)
//			else if (chr == 'r') // todo: %r     locale's 12-hour clock time (e.g., 11:11:04 PM)
			else if (chr == 'R') {
				// %R     24-hour hour and minute; same as %H:%M
				end = formatter.format(output, end, value, "%H:%M");
			}
			else if (chr == 's') {
				// %s     seconds since 1970-01-01 00:00:00 UTC
				end = append(formatter, output, end, Timestamp(value).value(Timeunit.Seconds), width, width, pad);
			}
			else if (chr == 'S') {
				// %S     second (00..60)
				end = append(formatter, output, end, value.second, width, 2, pad);
			}
			else if (chr == 't') {
				// %t     a tab
				end = append(output, end, "\t");
			}
			else if (chr == 'T') {
				// %T     time; same as %H:%M:%S
				end = formatter.format(output, end, value, "%H:%M:%S");
			}
			else if (chr == 'u') {
				// %u     day of week (1..7); 1 is Monday
				end = append(formatter, output, end, indexOf(value.dayOfWeek) + 1, width, width, pad);
			}
//			else if (chr == 'U') // todo: %U     week number of year, with Sunday as first day of week (00..53)
//			else if (chr == 'V') // todo: %V     ISO week number, with Monday as first day of week (01..53)
//			else if (chr == 'w') // todo: %w     day of week (0..6); 0 is Sunday
			else if (chr == 'W') {
				// %W     week number of year, with Monday as first day of week (00..53)
				end = append(formatter, output, end, value.weekOfYear, width, 2, pad);
			}
			else if (chr == 'x') {
				// %x     locale's date representation (e.g., 12/31/99)
				end = formatter.format(output, end, value, formatter.dateShort);
			}
			else if (chr == 'X') {
				// %X     locale's time representation (e.g., 23:13:48)
				end = formatter.format(output, end, value, formatter.timeShort);
			}
			else if (chr == 'y') {
				// %y     last two digits of year (00..99)
				end = append(formatter, output, end, value.year % 100, width, 2, pad);
			}
			else if (chr == 'Y') {
				// %Y     year
				end = append(formatter, output, end, value.year, width, width, pad);
			}
//			else if (chr == 'z') // todo: %z     +hhmm numeric time zone (e.g., -0400)
//			else if (chr == '?') // todo: %:z    +hh:mm numeric time zone (e.g., -04:00)
//			else if (chr == '?') // todo: %::z   +hh:mm:ss numeric time zone (e.g., -04:00:00)
//			else if (chr == '?') // todo: %:::z  numeric time zone with : to necessary precision (e.g., -04, +05:30)
//			else if (chr == 'Z') // todo: %Z     alphabetic time zone abbreviation (e.g., EDT)
			else {
				abort("unimplemented or invalid format character", chr);
			}
		}

		if (end >= output.length) {
			end = output.length - 1;
		}
		output[end] = 0;
		return end;
	}
}
/// formated print a fixed-point value to the given `output` buffer
static int format(NumberFormat format!, char output&[], int pos, Fixed32 value) {
	if (value.isUndefined()) {
		return append(output, pos, format.undefinedSymbol);
	}

	if (value.bits() < 0) {
		pos = append(output, pos, format.negativeSymbol);
		value = value.neg();
	} else {
		pos = append(output, pos, format.positiveSymbol);
	}

	char digitSymbols![] = format.digitSymbols;
	assert(digitSymbols.length > 1, "radix is too small", format);

	uint32 integerPart = int32(value);

	int width = Int32.abs(format.width);
	int integerPos = pos;
	int groupPosition = format.firstGrouping(pos);
	for (; integerPart > 0; width -= 1) {
		if (pos >= output.length) {
			output.remove(integerPos, integerPos + 1);
			pos -= 1;
		}
		if (pos == groupPosition) {
			pos = append(output, pos, format.groupingSymbol);
			groupPosition = format.digitGrouping(pos);
			continue;
		}
		uint32 remainder = integerPart % digitSymbols.length;
		pos = append(output, pos, digitSymbols[remainder]);
		integerPart /= digitSymbols.length;
	}
	for (; width > 0; width -= 1) {
		if (pos >= output.length) {
			break;
		}
		if (pos == groupPosition) {
			pos = append(output, pos, format.groupingSymbol);
			groupPosition = format.digitGrouping(pos);
			continue;
		}
		pos = append(output, pos, format.paddingSymbol);
	}

	// Put the digits in the correct order.
	reverse(output, integerPos, pos);
	pos = append(output, pos, format.fractionSymbol);

	uint32 fractionPart = value.bits() & Fixed32.mask;

	int precision = Int32.abs(format.precision);
	int fractionPos = pos;
	groupPosition = format.fractGrouping(pos);
	for (; precision > 0 && fractionPart != 0; ) {
		if (pos >= output.length) {
			break;
		}
		if (pos == groupPosition) {
			pos = append(output, pos, format.groupingSymbol);
			groupPosition = format.fractGrouping(pos);
			continue;
		}
		uint32 overflow = uint64(fractionPart) * digitSymbols.length >> Fixed32.precision;
		fractionPart = fractionPart * digitSymbols.length & Fixed32.mask;
		pos = append(output, pos, digitSymbols[overflow]);
		precision -= 1;
	}

	if (precision == 0 || pos >= output.length) {
		// round if needed: `0.358` is `0.36` printed using 2 precision digits
		uint32 overflow = uint64(fractionPart) * digitSymbols.length >> Fixed32.precision;
		fractionPart = fractionPart * digitSymbols.length & Fixed32.mask;
		bool carry = overflow >= digitSymbols.length / 2;

		for (int i = pos-1; carry && i >= integerPos; i -= 1) {
			char idx = digitSymbols.indexOf(output[i]);
			if (idx < 0) {
				continue;
			}
			idx += 1;
			carry = idx >= digitSymbols.length;
			if (carry) {
				idx = 0;
			}
			output[i] = digitSymbols[idx];
		}
		if (carry) {
			// one extra digit is needed: 9.9999 => 10.000
			for (int i = pos; i > integerPos; i -= 1) {
				output[i] = output[i - 1];
			}
			output[integerPos] = digitSymbols[1];
			pos += 1;
			groupPosition += 1;
		}
	}

	// add or remove trailing zeros
	if (format.trailingZeros) {
		for (; precision > 0; ) {
			if (pos >= output.length) {
				break;
			}
			if (pos == groupPosition) {
				pos = append(output, pos, format.groupingSymbol);
				groupPosition = format.fractGrouping(pos);
				continue;
			}
			pos = append(output, pos, digitSymbols[0]);
			precision -= 1;
		}
	} else {
		// remove trailing zeros
		for (;pos > fractionPos;) {
			if (digitSymbols.indexOf(output[pos - 1]) > 0) {
				// stop if a digit is found, but not the first
				break;
			}
			pos -= 1;
		}
	}
	if (pos == fractionPos && pos < output.length) {
		if (!format.trailingSeparator) {
			// remove trailing separator
			pos -= 1;
		}
	}

	if (pos >= output.length) {
		error("buffer overrun", pos);
		output[output.length - 1] = 0;
		return output.length;
	}

	output[pos] = 0;
	return pos;
}
/// formated print a floating-point value to the given `output` buffer
static int format(NumberFormat format!, char output&[], int pos, float64 value) {
	if (value < 0) {
		pos = append(output, pos, format.negativeSymbol);
		value = -value;
	} else {
		pos = append(output, pos, format.positiveSymbol);
	}

	if (value - value != 0) {
		if (value != value) {
			return append(output, pos, format.undefinedSymbol);
		}
		return append(output, pos, format.infinitySymbol);
	}

	struct BigUint {
		uint32 words[32];
		inline "cmplStd/lib/math/numeric/UintImpl.cmpl";
	}

	uint64 bits = Float64.toBits(value);
	bool negative = (bits >> 63) != 0;
	int32 exponent = (bits >> 52) & 0x7ff;
	uint64 mantissa = bits & ((1U << 52) - 1);
	if (exponent == 0) {
		// Special-case for de-normals - no special exponent value and no implied one.
		exponent = -1022;
	} else {
		exponent -= 1023;
		mantissa += 1U << 52;
	}

	char digitSymbols![] = format.digitSymbols;
	assert(digitSymbols.length > 1, "radix is too small", format);

	BigUint integerPart = BigUint.make(mantissa);
	if (exponent < 52) {
		integerPart.shiftRight(52 - exponent);
	} else {
		integerPart.shiftLeft(exponent - 52);
	}

	int width = Int32.abs(format.width);
	int integerPos = pos;
	int groupPosition = format.firstGrouping(pos);
	for (; !integerPart.isZero(); width -= 1) {
		if (pos >= output.length) {
			output.remove(integerPos, integerPos + 1);
			pos -= 1;
		}
		if (pos == groupPosition) {
			pos = append(output, pos, format.groupingSymbol);
			groupPosition = format.digitGrouping(pos);
			continue;
		}
		uint32 remainder = integerPart.divRem(digitSymbols.length);
		pos = append(output, pos, digitSymbols[remainder]);
	}
	for (; width > 0; width -= 1) {
		if (pos >= output.length) {
			break;
		}
		if (pos == groupPosition) {
			pos = append(output, pos, format.groupingSymbol);
			groupPosition = format.digitGrouping(pos);
			continue;
		}
		pos = append(output, pos, format.paddingSymbol);
	}

	// Put the digits in the correct order.
	reverse(output, integerPos, pos);
	pos = append(output, pos, format.fractionSymbol);

	BigUint fractionPart = BigUint.make(mantissa);
	fractionPart.shiftLeft(fractionPart.bits() - (52 - exponent));

	int precision = Int32.abs(format.precision);
	int fractionPos = pos;
	groupPosition = format.fractGrouping(pos);
	for (; precision > 0 && !fractionPart.isZero(); ) {
		if (pos >= output.length) {
			break;
		}
		if (pos == groupPosition) {
			pos = append(output, pos, format.groupingSymbol);
			groupPosition = format.fractGrouping(pos);
			continue;
		}
		uint32 overflow = fractionPart.mulOvf(digitSymbols.length);
		pos = append(output, pos, digitSymbols[overflow]);
		precision -= 1;
	}

	if (precision == 0 || pos >= output.length) {
		// round if needed: `0.358` is `0.36` printed using 2 precision digits
		uint32 overflow = fractionPart.mulOvf(digitSymbols.length);
		bool carry = overflow >= digitSymbols.length / 2;

		for (int i = pos-1; carry && i >= integerPos; i -= 1) {
			char idx = digitSymbols.indexOf(output[i]);
			if (idx < 0) {
				continue;
			}
			idx += 1;
			carry = idx >= digitSymbols.length;
			if (carry) {
				idx = 0;
			}
			output[i] = digitSymbols[idx];
		}
		if (carry) {
			// one extra digit is needed: 9.9999 => 10.000
			for (int i = pos; i > integerPos; i -= 1) {
				output[i] = output[i - 1];
			}
			output[integerPos] = digitSymbols[1];
			pos += 1;
			groupPosition += 1;
		}
	}

	// add or remove trailing zeros
	if (format.trailingZeros) {
		for (; precision > 0; ) {
			if (pos >= output.length) {
				break;
			}
			if (pos == groupPosition) {
				pos = append(output, pos, format.groupingSymbol);
				groupPosition = format.fractGrouping(pos);
				continue;
			}
			pos = append(output, pos, digitSymbols[0]);
			precision -= 1;
		}
	} else {
		// remove trailing zeros
		for (;pos > fractionPos;) {
			if (digitSymbols.indexOf(output[pos - 1]) > 0) {
				// stop if a digit is found, but not the first
				break;
			}
			pos -= 1;
		}
	}
	if (pos == fractionPos && pos < output.length) {
		if (!format.trailingSeparator) {
			// remove trailing separator
			pos -= 1;
		}
	}

	if (pos >= output.length) {
		error("buffer overrun", pos);
		output[output.length - 1] = 0;
		return output.length;
	}

	output[pos] = 0;
	return pos;
}
// formated print an integer value to the given `output` buffer, sign symbol is ignored
static int formatNoSign(NumberFormat format!, char output&[], int pos, uint64 value) {
	char digitSymbols![] = format.digitSymbols;
	assert(digitSymbols.length > 1, "radix is too small");

	int width = Int32.abs(format.width);
	int integerPos = pos;
	int groupPosition = format.firstGrouping(pos);
	for (; value != 0; width -= 1) {
		if (pos >= output.length) {
			break;
		}
		if (pos == groupPosition) {
			pos = append(output, pos, format.groupingSymbol);
			groupPosition = format.digitGrouping(pos);
			continue;
		}
		uint32 remainder = value % digitSymbols.length;
		pos = append(output, pos, digitSymbols[remainder]);
		value /= digitSymbols.length;
	}
	for (; width > 0; width -= 1) {
		if (pos >= output.length) {
			break;
		}
		if (pos == groupPosition) {
			pos = append(output, pos, format.groupingSymbol);
			groupPosition = format.digitGrouping(pos);
			continue;
		}
		pos = append(output, pos, format.paddingSymbol);
	}

	// Put the digits in the correct order.
	reverse(output, integerPos, pos);

	if (pos >= output.length) {
		error("buffer overrun", pos);
		output[output.length - 1] = 0;
		return output.length;
	}

	output[pos] = 0;
	return pos;
}

/// formated print an integer value to the given `output` buffer
static int format(NumberFormat format!, char output&[], int pos, int64 value) {
	// Add on the sign and the decimal point.
	if (value < 0) {
		pos = append(output, pos, format.negativeSymbol);
		value = -value;
	} else {
		pos = append(output, pos, format.positiveSymbol);
	}
	return formatNoSign(format, output, pos, uint64(value));
}

/// formated print an integer value to the given `output` buffer
static int format(NumberFormat format!, char output&[], int pos, uint64 value) {
	pos = append(output, pos, format.positiveSymbol);
	return formatNoSign(format, output, pos, value);
}
/// Number formater
struct NumberFormat {
	/// number digits to be used for formatting
	static char digits![] = "0123456789abcdefghijklmnopqrstuv";
	// static char hex_digits[] = hex[...16]; // hexadecimal
	// static char dec_digits[] = hex[...10]; // decimal
	// static char oct_digits[] = hex[...8];  // octal
	// static char bin_digits[] = hex[...2];  // binary

	/// specify the digit symbols and the radix to be used for formatting
	/// binary: "01", decimal: "0123456789", hexadecimal: "0123456789abcdef"
	char digitSymbols![] = digits[...10];

	/// the prefix symbol to be used for positive values
	char positiveSymbol = '';
	/// the prefix symbol to be used for negative values
	char negativeSymbol = '-';
	/// the symbol to be used for floating-point infinity values
	char infinitySymbol![] = "inf";
	/// the symbol to be used for floating-point `not a number` values
	char undefinedSymbol![] = "nan";

	// International("123'456'789"): digitGrouping = 3, firstGrouping = 0 || 3, fractGrouping = 0
	// Myriads("1'2345'6789"): digitGrouping = 4, firstGrouping = 0 || 4, fractGrouping = 0
	// Indian("12'34'56'789"): digitGrouping = 2, firstGrouping = 3, fractGrouping = 0

	/// the symbol to be used for grouping values
	char groupingSymbol = '';
	/// the number of digits to group together
	uint32 digitGrouping = 0;
	/// the number of digits making the first group
	uint32 firstGrouping = 0;
	/// the number of digits to be grouped in the fractional part
	uint32 fractGrouping = 0;

	/// symbol used for padding the integer and fractional parts
	char paddingSymbol = digits[0];
	/// minimum integer digits: 0: ".7", 1: "0.7", 2: "00.7", ...
	int32 width = -1;

	/// the symbol to be used between floating-point integer and fractional part as separator
	char fractionSymbol = '.';
	/// keep trailing separator: false: "6", true: "6."
	bool trailingSeparator = false;

	/// floating-point precision to be used for the fractional part
	int32 precision = -6;
	/// keep trailing zeroes: false: "0.7", true: ".700000" (for precision: 6)
	bool trailingZeros = false;

	static int digitGrouping(NumberFormat format!, int pos) {
		if (format.digitGrouping <= 0 || format.groupingSymbol == 0) {
			return -1;
		}
		return pos + format.digitGrouping;
	}

	static int firstGrouping(NumberFormat format!, int pos) {
		if (format.firstGrouping <= 0) {
			return digitGrouping(format, pos);
		}
		if (format.groupingSymbol == 0) {
			return -1;
		}
		return pos + format.firstGrouping;
	}

	static int fractGrouping(NumberFormat format!, int pos) {
		if (format.fractGrouping <= 0 || format.groupingSymbol == 0) {
			return -1;
		}
		return pos + format.fractGrouping;
	}

	inline "./NumberFormat.Integer.cmpl";
	inline "./NumberFormat.Float64.cmpl";
	inline "./NumberFormat.Fixed32.cmpl";
}
/// Represents the base class of closeable objects like files, streams, etc
struct Closeable: object {

	/// Release the resources hold by this object.
	void close(Closeable this);

	static void closeSafe(Closeable this) {
		if (this.close == null) {
			// close is disabled, stdout?
			return;
		}
		this.close(this);
	}
}

/// ByteReader can be used to read bytes from a stream (~= java:InputStream)
struct ByteReader: Closeable {

	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * the method must return the number of bytes read from the stream into the `bytes` array
	 * in case there is an error -1 should be returned
	 */
	int read(ByteReader this, uint8 bytes[]);

	/// Read a single byte from the stream, a negative number is returned in case of error
	static int read(ByteReader this) {
		uint8 bytes[1] = {...};
		if (this.read(bytes) <= 0) {
			return -1;
		}
		return bytes[0];
	}

	/* TODO: subclasses
		CopyReader
		FileReader
		PipedReader
		SocketReader
		MemoryReader
	*/
}

/// ByteWriter can be used to write bytes to a stream (~= java:OutputStream)
struct ByteWriter: Closeable {
	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * the method must write all the bytes from the `bytes` array
	 */
	void write(ByteWriter this, uint8 bytes[]);

	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * if a buffer is used directly or indirectly this method must flush all buffered data to the stream.
	 */
	void flush(ByteWriter this);

	/// Write a single byte to the stream
	static void write(ByteWriter this, uint8 oneByte) {
		uint8 bytes![1] = { oneByte };
		return this.write(this, bytes);
	}

	/* TODO: uncomment
	static void write(ByteWriter this, void write(ByteWriter writer)) {
		return write(this);
	}

	struct Writeable: object {
		// abstract
		void write(Writeable this, ByteWriter writer);
	}

	static void write(ByteWriter this, Writeable value) {
		return this.write(this, value.write);
	}// */

	/// Copy all bytes from the reader to the writer
	static int copy(ByteWriter this, ByteReader reader) {
		uint8 buffer[4096] = {...};
		int result = 0;
		for ( ; ; ) {
			int read = reader.read(buffer);
			if (read <= 0) {
				return result;
			}
			this.write(this, buffer[...read]);
			result += read;
		}
		return result;
	}

	/* TODO: subclasses
		FileWriter
		PipedWriter
		SocketWriter
		MemoryWriter
	*/
}

// TODO: untested: copy byte-stream
struct CopyReader: ByteReader {
	ByteReader source;
	ByteWriter clone;

	// override
	int read(CopyReader this, uint8 bytes[]) {
		int result = this.source.read(bytes);
		if (result > 0) {
			this.clone.write(bytes[...result]);
		}
		return result;
	}

	// override
	void close(CopyReader this) {
		Closeable.closeSafe(this.source);
		Closeable.closeSafe(this.clone);
	}
}

// TODO: untested
struct ByteBuffer {
	int position = 0;
	int capacity = 32;
	int length = 0;
	uint8 buffer[*] = pointer.alloc(null, capacity);

	int read(ByteBuffer this, uint8 bytes&[]) {
		if (this.position >= this.length) {
			return -1;
		}
		for (int i = 0; i < bytes.length; i += 1) {
			if (this.position >= this.length) {
				return i;
			}
			bytes[i] = this.buffer[this.position];
			this.position += 1;
		}
		return bytes.length;
	}

	int read(ByteBuffer this) {
		if (this.position >= this.length) {
			return -1;
		}
		int result = this.buffer[this.position];
		this.position += 1;
		return result;
	}

	void write(ByteBuffer this, uint8 bytes[]) {
		int size = this.position + bytes.length;
		if (size >= this.capacity) {
			// try to double the current size
			this.capacity *= 2;
			if (size > 2 * this.capacity) {
				// double the calculated size
				this.capacity = size * 2;
			}

			// copy old bytes
			uint8 new[*] = pointer.alloc(null, this.capacity);
			for (int i = 0; i < this.position; i += 1) {
				new[i] = this.buffer[i];
			}
			pointer.alloc(this.buffer, 0);
			this.buffer = new;
		}

		// copy new bytes
		for (int i = 0; i < bytes.length; i += 1) {
			this.buffer[this.position] = bytes[i];
			this.position += 1;
		}
	}

	void flush(ByteBuffer this) {
		// do nothing
	}

	void close(ByteBuffer this) {
		// release memory
		pointer.alloc(this.buffer, 0);

		this.buffer = null;
		this.position = 0;
		this.capacity = 0;
		this.length = 0;
	}
}
// The Unicode Character Set (UCS) contains 1,114,112 code points: U+0000U+10FFFF
// todo: move inside class TextReader
inline unicode = uint32;

// TextReader := Decoder & Parser (java:Reader+Scanner?Parser?)
/// TextReader can be used to read decoded text from a stream, including basic parsing
struct TextReader: Closeable {

	///@public
	ByteReader reader;

	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * the method must return the number of characters decoded from the stream into the `chars` array
	 * in case there is an error -1 should be returned
	 */
	int decode(TextReader this, unicode chars[]);

	// override
	void close(TextReader this) {
		// by default close the stream, override by need
		Closeable.closeSafe(this.reader);
	}

	/// Read a single character from the stream, a negative number is returned in case of error
	static int decode(TextReader this) {
		unicode chars[1] = {0};
		if (this.decode(chars) <= 0) {
			return -1;
		}
		return chars[0] & 0x00ffffff;
	}

	// TODO: static string readNext(TextReader this, regex matcher) { /*...*/ }
	// TODO: static string readWord(TextReader this) { return this.readNext(/\w+/); }
	// TODO: static string readLine(TextReader this) { return this.readNext(/.*$/); }
	// TODO: static string readAll(TextReader this) { return this.readMatch(/.*/); }
	// TODO: static float64 readNumber(TextReader this, Locale locale) { /*...*/ }

	/* TODO: subclasses
		Latin1
		Ascii
		Utf8
	*/
}

// TextWriter := Encoder & Printer (java:Writer+PrintStream)
/// TextWriter can be used to write encoded text to a stream, including basic printing
struct TextWriter: Closeable {
	static NumberFormat defaultFormat! = {};

	///@public
	struct Writeable: object {
		// abstract
		void write(Writeable this, TextWriter writer);
	}

	///@public
	ByteWriter writer;

	/// default formatter
	NumberFormat format = defaultFormat;

	/** This abstract method must be implemented in subclasses containing the proper implementation
	 * the method must encode and write all the characters from the `chars` array
	 */
	void encode(TextWriter this, unicode chars[]);

	// override
	void flush(TextWriter this) {
		this.writer.flush();
	}

	// override
	void close(TextWriter this) {
		// by default close the stream, override by need
		Closeable.closeSafe(this.writer);
	}

	/// Write an array of raw characters to the stream (no encoding)
	static TextWriter write(TextWriter this, char value[]) {
		this.writer.write(value);
		return this;
	}

	/// Write a single raw character to the stream (no encoding)
	static TextWriter write(TextWriter this, char value) {
		char buffer![1] = { value };
		return this.write(buffer);
	}

	/// Write the value of the boolean parameter: "true" or "false"
	static TextWriter write(TextWriter this, bool value) {
		if (value) {
			return this.write("true");
		}
		return this.write("false");
	}

	/// Write the value of the 32-bit floating-point parameter
	static TextWriter write(TextWriter this, float32 value, NumberFormat format!) {
		return write(this, float64(value), format);
	}

	/// Write the value of the 64-bit integer parameter
	static TextWriter write(TextWriter this, int64 value, NumberFormat format!) {
		char buff[1024]= {...};
		int n = format.format(buff, 0, value);
		return write(this, buff[ ... n]);
	}

	/// Write the value of the 32-bit integer parameter
	static TextWriter write(TextWriter this, int32 value, NumberFormat format!) {
		return write(this, int64(value), format);
	}

	/// Write the value of the 64-bit unsigned integer parameter
	static TextWriter write(TextWriter this, uint64 value, NumberFormat format!) {
		char buff[1024]= {...};
		int n = format.format(buff, 0, value);
		return write(this, buff[ ... n]);
	}

	/// Write the value of the 32-bit unsigned integer parameter
	static TextWriter write(TextWriter this, uint32 value, NumberFormat format!) {
		return write(this, uint64(value), format);
	}

	/// Write the value of the 64-bit floating-point parameter
	static TextWriter write(TextWriter this, float64 value, NumberFormat format!) {
		char buff[1024]= {...};
		int n = format.format(buff, 0, value);
		return write(this, buff[ ... n]);
	}

	/// Write the value of the writeable parameter
	static TextWriter write(TextWriter this, Writeable value) {
		value.write(this);
		return this;
	}

	/// Write a newline character
	static TextWriter writeln(TextWriter this) {
		return this.write("\n");
	}

	///@public
	static TextWriter writeln(TextWriter this, TextWriter.Writeable value) { return this.write(value).writeln(); }

	// TODO: static void write(TextWriter this, Locale locale, char value) { /*...*/ }
	// TODO: static void write(TextWriter this, Locale locale, string value) { /*...*/ }
	// TODO: static void write(TextWriter this, Locale locale, object value) { /*...*/ }
	// TODO: static void write(TextWriter this, Locale locale, variant value) { /*...*/ }
	// TODO: static void write(TextWriter this, void write(TextWriter writer)) { /*...*/ }

	/**
	 * Convert from one encoding to another one.
	 * @returns converted character count.
	 *
	 * example: convert utf-8 encoded file to ascii
	 * TextWriter output = AsciiWriter("out.txt");
	 * TextReader input = Utf8Reader("in.txt");
	 * output.write(input);
	 */
	static int copy(TextWriter writer, TextReader reader) {
		unicode buffer[1024] = {...};
		int result = 0;
		for ( ; ; ) {
			int n = reader.decode(buffer);
			if (n <= 0) {
				return result;
			}
			writer.encode(buffer[...n]);
			result += n;
		}
		return result;
	}

	/* TODO: subclasses
		Latin1
		Ascii
		Utf8
	*/
}
/// Month of year, January is 1, February is 2, ...
enum Month: int8 {
	January: 1;
	February;
	March;
	April;
	May;
	June;
	July;
	August;
	September;
	October;
	November;
	December;
}
/// FIXME: implement enum indexing
Month Month(int32 index) { return index + Month.January; }
/// FIXME: implement enum indexing
inline indexOf(Month value) = (value - Month.January);

/// Day of week, Monday is 1, Tuesday is 2, ...
enum Weekday: int8 {
	Monday: 1;
	Tuesday;
	Wednesday;
	Thursday;
	Friday;
	Saturday;
	Sunday;
}
/// FIXME: implement enum indexing
Weekday Weekday(int32 index) {return index + Weekday.Monday; }
/// FIXME: implement enum indexing
inline indexOf(Weekday value) = (value - Weekday.Monday);

/// Type of the calendar
enum Calendar: uint8 {
	Gregorian;
//	Buddhist;
//	Chinese;
//	Coptic;
//	EthiopicAmeteAlem;
//	EthiopicAmeteMihret;
//	Hebrew;
//	Indian;
//	Islamic;
//	IslamicCivil;
//	IslamicTabular;
//	IslamicUmmAlQura;
//	Iso8601;
//	Japanese;
//	Persian;
//	RepublicOfChina;
}

/// DateTime represents the parts of an instant in time.
struct Datetime {
	// Date parts

	/// Year: 1970
	int32 year = 1970;
	/// Month of year: 1 ... 12 / [Jan, Feb, Mar, ...]
	Month month = Month.January;
	/// Day of month: 1 ... 30
	uint8 day = 1;

	// Time parts

	/// Hour of day: 0 ... 23
	uint8 hour = 0;
	/// Minute of hour: 0 ... 59
	uint8 minute = 0;
	/// Second of minute: 0 ... 59
	uint8 second = 0;
	/// Milliseconds of second: 0 ... 999
	uint16 millis = 0;

	/// timezone
	Timezone timezone;

	// Extra
	// uint8 weekOfMonth!;	// 1 ... 4
	//dayOfWeekInMonth;		// example: 1..4, may be specified as -1

	/// Nth week of the year: 1 ... 53
	uint8 weekOfYear;

	/// Nth day of the year: 1 ... 365
	uint16 dayOfYear;

	/// Day of week: 1 ... 7 / [Mon, Tue, ...]
	Weekday dayOfWeek;

	/// this is a leap year
	bool leapYear;

	static int32 DaysToMonth365![13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
	static int32 DaysToMonth366![13] = {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
	static int32 DaysTil1970! = 719162;

	/// Checks weather the given year is a leap year or not
	static bool isLeapYear(int32 year) {
		if (year % 4 != 0) {
			return false;
		}
		if (year % 100 != 0) {
			return true;
		}
		if (year % 400 != 0) {
			return false;
		}
		return true;
	}

	/// Add the amount of `years`, `months` and `days` to the datetime
	static Datetime add(Datetime cal, int32 years, int32 months, int32 days) {
		int32 year = cal.year + years;

		int32 month = indexOf(cal.month) + months;
		if (month >= 12) {
			year += month / 12;
			month %= 12;
		}
		else if (month < 0) {
			year += month / 12 - 1;
			month = 12 - (-month % 12);
		}

		assert(days == 0);

		return {
			year: year;
			month: Month(month % 12);
			day: cal.day;
			hour: cal.hour;
			minute: cal.minute;
			second: cal.second;
			millis: cal.millis;
			timezone: cal.timezone;
			weekOfYear: cal.weekOfYear;
			dayOfYear: cal.dayOfYear;
			dayOfWeek: cal.dayOfWeek;
			leapYear: isLeapYear(year);
		};
	}
}

/// Convert the given Datetime `value` to a timestamp (milliseconds since 1970)
Timestamp Timestamp(Datetime value) {
	int32 year = value.year;
	if (year < 0 || year > 9999) {
		trace("invalid year", year);
		return Timestamp(1D << 63, Timestamp.precision);
	}

	int32 month = value.month;
	if (month < Month.January || month > Month.December) {
		trace("invalid month", month);
		int32 jan = Month.January;
		int32 dec = Month.December;
		month = Int32.clamp(month, jan, dec);
	}

	int32 DaysToMonth![*] = Datetime.isLeapYear(year) ? Datetime.DaysToMonth366 : Datetime.DaysToMonth365;

	int32 day = value.day;
	int32 daysInYear = DaysToMonth[month - 1];
	int32 daysInMonth = DaysToMonth[month] - daysInYear;
	if (day < 1 || day > daysInMonth) {
		trace("invalid day of month", day);
		day = Int32.clamp(day, 1, daysInMonth);
	}

	int32 y = year - 1;
	int64 d = y * 365 + y / 4 - y / 100 + y / 400 + daysInYear + day - 1 - Datetime.DaysTil1970;
	int64 t = (((d * 24 + value.hour) * 60 + value.minute) * 60 + value.second) * 1000 + value.millis;
	return Timestamp(t, Timeunit.Millis);
}

/// Convert the given `timestamp` to a datetime(year, month, day, ...) using the given `calendar` and `timezone`
Datetime Datetime(Timestamp timestamp, Calendar calendar, Timezone timezone) {
	assert(calendar == Calendar.Gregorian);
	enum: int32 {
		// Number of days in a non-leap year
		DaysPerYear: 365;

		// Number of days in a leap year
		DaysPerLeapYear: 366;

		// Number of days in 4 years
		DaysPer4Years: DaysPerYear * 4 + 1;
		// Number of days in 100 years
		DaysPer100Years: DaysPer4Years * 25 - 1;
		// Number of days in 400 years
		DaysPer400Years: DaysPer100Years * 4 + 1;
	}

	Duration offset = timezone.offset(timestamp);
	timestamp = timestamp.add(offset.value, Duration.precision);
	int32 n = Datetime.DaysTil1970 + timestamp.value(Timeunit.Days);

	// n = number of days since 1/1/0001
	int32 dayOfWeek = n % 7;

	// y400 = number of whole 400-year periods since 1/1/0001
	int32 y400 = n / DaysPer400Years;
	// n = day number within 400-year period
	n -= y400 * DaysPer400Years;

	// y100 = number of whole 100-year periods within 400-year period
	int32 y100 = n / DaysPer100Years;

	// Last 100-year period has an extra day, so decrement result if 4
	if (y100 == 4) {
		y100 = 3;
	}
	// n = day number within 100-year period
	n -= y100 * DaysPer100Years;

	// y4 = number of whole 4-year periods within 100-year period
	int32 y4 = n / DaysPer4Years;
	// n = day number within 4-year period
	n -= y4 * DaysPer4Years;

	// y1 = number of whole years within 4-year period
	int32 y1 = n / DaysPerYear;
	// Last year has an extra day, so decrement result if 4
	if (y1 == 4) {
		y1 = 3;
	}

	// If year was requested, compute and return it
	int32 year = y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1;

	// n = day number within year
	n -= y1 * DaysPerYear;

	// All months have less than 32 days, so n >> 5 is a good conservative
	// estimate for the month
	int32 m = n >> 5 + 1;
	int32 DaysToMonth![*] = Datetime.isLeapYear(year) ? Datetime.DaysToMonth366 : Datetime.DaysToMonth365;

	// m = 1-based month number
	for (;n >= DaysToMonth[m];) {
		m += 1;
	}

	return {
		// date
		year: year;
		month: Month(m - 1);
		day: n - DaysToMonth[m - 1] + 1;

		// time
		hour: timestamp.value(Timeunit.Hours) % 24;
		minute: timestamp.value(Timeunit.Minutes) % 60;
		second: timestamp.value(Timeunit.Seconds) % 60;
		millis: timestamp.value(Timeunit.Millis) % 1000;

		// zone
		timezone: timezone;

		// extra
		dayOfYear: n + 1;
		dayOfWeek: Weekday(dayOfWeek);
		weekOfYear: (n - dayOfWeek + indexOf(Weekday.Thursday)) / 7 + 1;
		leapYear: DaysToMonth == Datetime.DaysToMonth366;
	};
}

/// Convert the given timestamp to a datetime
inline Datetime(Timestamp timestamp) = Datetime(timestamp, Calendar.Gregorian, Timezone.utc());

/// Construct the Datetime from the given parts
Datetime Datetime(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millis, Timezone zone) {
	return {
		year: year;
		month: Month(month - 1);
		day: day;
		hour: hour;
		minute: minute;
		second: second;
		millis: millis;
		timezone: zone;
		weekOfYear: 0;
		dayOfYear: 0;
		dayOfWeek: Weekday.Monday;
		leapYear: Datetime.isLeapYear(year);
	};
}

/// Construct the Datetime from the given parts
Datetime Datetime(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, int32 millis) {
	return Datetime(year, month, day, hour, minute, second, millis, Timezone.utc());
}

/// Construct the Datetime from the given parts
Datetime Datetime(int32 year, int32 month, int32 day, int32 hour, int32 minute, int32 second, Timezone zone) {
	return Datetime(year, month, day, hour, minute, second, 0, zone);
}

/// Construct the Datetime from the given parts
Datetime Datetime(int32 year, int32 month, int32 day, Timezone zone) {
	return Datetime(year, month, day, 0, 0, 0, 0, zone);
}

/// Construct the Datetime from the given parts
Datetime Datetime(int32 year, int32 month, int32 day) {
	return Datetime(year, month, day, 0, 0, 0, 0, Timezone.utc());
}
/**
 * Timespan is just a duration
 * for example: 33 seconds
 */
struct Duration {
	int64 value = 0;
	// fixme: inline precision = Timeunit.Millis;
	static Timeunit precision! = Timeunit.Millis;

	/// Returns the value of the `duration` at the given `precision` (Seconds and Millis are mostly used as unix epoch)
	static int64 value(Duration duration, Timeunit precision) {
		return convert(duration.value, Duration.precision, precision);
	}

	/// Return duration from the passed milliseconds
	static Duration millis(int64 duration) {
		return { value: convert(duration, Timeunit.Millis, Duration.precision); };
	}

	/// Return milliseconds from the passed duration
	static int64 millis(Duration duration) {
		return convert(duration.value, Duration.precision, Timeunit.Millis);
	}

	/// Return duration from the passed seconds
	static Duration seconds(int64 duration) {
		return { value: convert(duration, Timeunit.Seconds, Duration.precision); };
	}

	/// Return seconds from the passed duration
	static int64 seconds(Duration duration) {
		return convert(duration.value, Duration.precision, Timeunit.Seconds);
	}

	/// Return duration from the passed minutes
	static Duration minutes(int64 duration) {
		return { value: convert(duration, Timeunit.Minutes, Duration.precision); };
	}

	/// Return minutes from the passed duration
	static int64 minutes(Duration duration) {
		return convert(duration.value, Duration.precision, Timeunit.Minutes);
	}

	/// Return duration from the passed hours
	static Duration hours(int64 duration) {
		return { value: convert(duration, Timeunit.Hours, Duration.precision); };
	}

	/// Return hours from the passed duration
	static int64 hours(Duration duration) {
		return convert(duration.value, Duration.precision, Timeunit.Hours);
	}

	/// Return duration from the passed days
	static Duration days(int64 duration) {
		return { value: convert(duration, Timeunit.Days, Duration.precision); };
	}

	/// Return days from the passed duration
	static int64 days(Duration duration) {
		return convert(duration.value, Duration.precision, Timeunit.Days);
	}

	/// Add two durations
	static Duration add(Duration lhs, Duration rhs) {
		return { value: lhs.value + rhs.value };
	}
}

/// Construct a duration from the given `value` at the given `precision`
Duration Duration(int64 value, Timeunit precision) {
	return { value: convert(value, precision, Duration.precision) };
}

/* TODO: inline initialization, operator overloading
inline Duration(int64 value, Timeunit precision) = {
	value: convert(value, precision, Duration.precision);
}

inline +(Duration lhs, Duration rhs) = Duration {
	value: lhs.value + rhs.value;
}

inline -(Duration lhs, Duration rhs) = Duration {
	value: lhs.value - rhs.value;
}

struct Duration {
	static Duration setField(Duration this, int64 value, Timeunit unit) { ... }
	static Duration setValue(Duration this, int64 value, Timeunit unit) { ... }
	static Duration floor(Duration this, Timeunit unit) { ... }
	static Duration ceil(Duration this, Timeunit unit) { ... }
	static Duration distribute(Duration this, Timeunit unit, uint64 duration) { ... }
	static Duration distribute(Duration this, Timeunit unit, int start, int end) { ... }
}
*/
/**
 * Timestamp is a position in time, without timezone information
 * in case locale is needed use Datetime.
 */
struct Timestamp {
	int64 value = 0;

	/// The time unit specifying the precision of the timestamp
	static Timeunit precision! = Timeunit.Millis;

	/// Returns the value of `timestamp` at the given `precision` (Seconds and Millis are mostly used as unix epoch)
	static int64 value(Timestamp timestamp, Timeunit precision) {
		return convert(timestamp.value, Timestamp.precision, precision);
	}

	/// Returns the difference of `a` and `b` at the given `precision`
	static int64 diff(Timestamp a, Timestamp b, Timeunit precision) {
		return convert(a.value - b.value, Timestamp.precision, precision);
	}

	/// Returns the difference of `a` and `b
	static Duration diff(Timestamp a, Timestamp b) {
		return Duration(a.value - b.value, Timestamp.precision);
	}

	/// Returns whether the firs timestamp is less(<0), equal(=0), or greater(>0) than the second timestamp
	static int32 compare(Timestamp a, Timestamp b) {
		return int32(a.value > b.value) - int32(a.value < b.value);
	}

	/// Check whether the two timestamps `a` and `b` are equal at the given `precision`
	static bool equal(Timestamp a, Timestamp b, Timeunit precision) {
		return a.value(precision) == b.value(precision);
	}

	/// Check whether the two timestamps `a` and `b` are equal
	static bool equal(Timestamp a, Timestamp b) {
		return a.value == b.value;
	}

	/// Increment the the current timestamp with the given `value` at the given `precision`
	static Timestamp add(Timestamp lhs, int64 value, Timeunit precision) {
		return { value: lhs.value + convert(value, precision, Timestamp.precision) };
	}

	/**
	 * Floor the current timestamp, leaving the field specified as the most significant field.
	 * For example, if you have the timestamp: 2002-03-28 13:45:01.231,
	 * using resolution Timeunit.Days, it should return 2002-03-28 00:00:00.000.
	 * using resolution Timeunit.Hours, it should return 2002-03-28 13:00:00.000.
	 * using resolution Timeunit.Minutes, it should return 2002-03-28 13:45:00.000.
	 *
	 * @param unit Resolution of the operation.
	 */
	static Timestamp floor(Timestamp value, Timeunit precision) {
		if (precision <= Timestamp.precision) {
			trace("small precision", precision);
			return value;
		}
		int64 one = convert(1D, precision, Timestamp.precision);
		return { value: value.value - value.value % one };
	}

	/**
	 * Ceil the current timestamp, leaving the field specified as the most significant field.
	 * For example, if you have the timestamp: 2002-03-28 13:45:01.231,
	 * using resolution Timeunit.Days, it should return 2002-03-29 00:00:00.000.
	 * using resolution Timeunit.Hours, it should return 2002-03-28 14:00:00.000.
	 * using resolution Timeunit.Minutes, it should return 2002-03-28 13:46:00.000.
	 *
	 * @param unit Resolution of the operation.
	 */
	static Timestamp ceil(Timestamp value, Timeunit precision) {
		if (precision <= Timestamp.precision) {
			trace("small precision", precision);
			return value;
		}
		int64 one = convert(1D, precision, Timestamp.precision);
		int64 part = value.value % one;
		if (part == 0) {
			return value;
		}
		return { value: value.value - part + one };
	}

	/**
	 * Distribute randomly between current value and the duration at the given time-unit resolution.
	 * For example, if you had the timestamp: 2002-03-28 13:45:01.231,
	 * using distribute(Timeunit.Hours, 2), it will return a date between 2002-03-28 13:46:01.231 and 2002-03-28 15:46:01.231.
	 *
	 * @param unit  Resolution of the duration.
	 * @param duration The duration of the distribution time frame, negative values are allowed.
	 */
	static Timestamp distribute(Timestamp this, Timeunit unit, uint64 duration) {
		abort("not implemented");
		return { value: 0 };
	}

	/**
	 * Distribute randomly between start and end at the given time-unit resolution.
	 * For example, if you have the timestamp of 2002-03-28 13:46:01.231,
	 * using distribute(Timeunit.Hours, 15, 17) as start and end, it will return a date between 2002-03-28 15:46:01.231 and 2002-03-28 17:46:01.231.
	 * in case you need a timestamp between 15:00:00.000 and 17:00:00.000 yo will need to use the floor method before or after this operation.
	 *
	 * @param unit  Resolution of the operation.
	 * @param start The beginning of the distribution time frame.
	 * @param end   The end of the distribution time frame.
	 */
	static Timestamp distribute(Timestamp this, Timeunit unit, int start, int end) {
		return this./*setField(unit, start).*/distribute(unit, end - start);
	}

	/// get the current utc time as timestamp from the system
	static Timestamp now() {
		return { value: convert(System.millis(), Timeunit.Millis, Timestamp.precision) };
	}
}

/// Create a timestamp from the given `value` at the given `precision`
Timestamp Timestamp(int64 value, Timeunit precision) {
	return { value: convert(value, precision, Timestamp.precision) };
}

/*static if (struct(Duration) != null) {
Timestamp add(Timestamp lhs, Duration rhs) {
	return { value: lhs.value + rhs.value(Timestamp.precision) };
}
}*/

/* TODO: inline initialization, operator overloading
inline Timestamp(int64 value, Timeunit precision) = {
	value: convert(value, precision, Timestamp.precision);
};

inline +(Timestamp lhs, Duration rhs) = Timestamp {
	value: lhs.value + rhs.value(Timestamp.precision);
};
*/
/// enumeration of some known time unit, used for conversions and to specify the precision
enum Timeunit: int64 {
	// approximately 584 years of nanoseconds can be represented in uint64
	Nanos: 1;
	Micros: 1000 * Nanos;
	Millis: 1000 * Micros;
	Seconds: 1000 * Millis;
	Minutes: 60 * Seconds;
	Hours: 60 * Minutes;
	Days: 24 * Hours;
}

/// Convert the given integer `value` from the `from` to `to` unit
int64 convert(int64 value, Timeunit from, Timeunit to) {
	if (from > to) {
		// from Minutes to Seconds
		return value * (from / to);
	}
	// from Seconds to Minutes
	return value / (to / from);
}

/// Convert the given floating point `value` from the `from` to `to` unit
float64 convert(float64 value, Timeunit from, Timeunit to) {
	if (from > to) {
		// from Minutes to Seconds
		return value * (from / to);
	}
	// from Seconds to Minutes
	return value / (to / from);
}
// todo: unfinished implementation
struct Timezone {
	char name![];		// "UTC", "America/New_York", "Europe/Brussels"
	Duration offset(Timezone zone!, Timestamp timestamp, bool isDaylightSaving&);

	static Duration offset(Timezone zone!, Timestamp timestamp) {
		bool isDaylightSaving;
		return zone.offset(zone, timestamp, &isDaylightSaving);
	}

	static Timezone utc() {
		static Duration offset(Timezone zone!, Timestamp timestamp, bool isDaylightSaving&) {
			isDaylightSaving = false;
			return { value: 0 };
		}
		return {
			offset: offset;
			name: "UTC";
		};
	}

	static Timezone lookup(char name[]) {
		abort("todo");
		return {
			offset: null;
			name: name;
		};
	}

	static Timezone local() {
		warn("using fake timezone");	// fixme: fake timezone, needs to be read or lookup from the system
		//static void System.timeInfo(char timezoneName[*], int64 timeMillis, int64 zoneOffset&, int daylight&) {}
		Duration offset(Timezone zone!, Timestamp timestamp, bool isDaylightSaving&) {
			isDaylightSaving = false;
			return Duration(3, Timeunit.Hours);
		}
		return {
			offset: offset;
			name: "GMT+3";
		};
	}
}

// Timezone Timezone() {return Timezone.local();}

// Timezone Timezone(char name[]) { return Timezone.lookup(name);}
