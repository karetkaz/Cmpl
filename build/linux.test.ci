
---------- Compile: `/cmplStd/lib.ci`
warn: variable `args` hides previous declaration
debug: inline file: `cmplStd/lib.ci`
cmplStd/lib.ci:18: debug: inline file: `cmplStd/lib/lang/Debug.ci`
cmplStd/lib/lang/Debug.ci:48: warn: adding implicit cast variant[](null: pointer)
cmplStd/lib/lang/Debug.ci:63: warn: adding implicit cast variant(message: char[*])
cmplStd/lib/lang/Debug.ci:65: warn: adding implicit cast variant(expected: int32)
cmplStd/lib/lang/Debug.ci:66: warn: adding implicit cast variant(returned: int32)
cmplStd/lib/lang/Debug.ci:67: warn: adding implicit cast variant[](extras: variant[1])
cmplStd/lib.ci:21: debug: inline file: `cmplStd/lib/lang/Pointer.ci`
cmplStd/lib/lang/Pointer.ci:7: warn: variable `inc(ptr: pointer, val: int32): pointer` hides previous declaration
cmplStd/lib/lang/Pointer.ci:3: warn: previously defined here as `inc(ptr: pointer, val: int32): pointer`
cmplStd/lib.ci:24: debug: inline file: `cmplStd/lib/math/Bits.ci`
cmplStd/lib/math/Bits.ci:37: warn: adding implicit cast uint64(lo: uint32)
cmplStd/lib/math/Bits.ci:41: warn: adding implicit cast pointer(typename(uint32.zxt): typename)
cmplStd/lib/math/Bits.ci:41: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:51: warn: adding implicit cast pointer(typename(uint32.sxt): typename)
cmplStd/lib/math/Bits.ci:51: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:61: warn: adding implicit cast pointer(typename(uint64.zxt): typename)
cmplStd/lib/math/Bits.ci:61: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:71: warn: adding implicit cast pointer(typename(uint64.sxt): typename)
cmplStd/lib/math/Bits.ci:71: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:81: warn: adding implicit cast uint64(4294967295: int64)
cmplStd/lib/math/Bits.ci:81: warn: adding implicit cast uint64(-4294967296: int64)
cmplStd/lib/math/Bits.ci:82: warn: adding implicit cast uint64(281470681808895: int64)
cmplStd/lib/math/Bits.ci:82: warn: adding implicit cast uint64(-281470681808896: int64)
cmplStd/lib/math/Bits.ci:83: warn: adding implicit cast uint64(71777214294589695: int64)
cmplStd/lib/math/Bits.ci:83: warn: adding implicit cast uint64(-71777214294589696: int64)
cmplStd/lib/math/Bits.ci:89: warn: adding implicit cast uint32(65535: int32)
cmplStd/lib/math/Bits.ci:89: warn: adding implicit cast int64(x: uint32)
cmplStd/lib/math/Bits.ci:89: warn: adding implicit cast int64((x & (65535)) << 16: uint32)
cmplStd/lib/math/Bits.ci:89: warn: adding implicit cast uint32(((x & (65535)) << 16) | ((x) & 4294901760) >> 16: int64)
cmplStd/lib/math/Bits.ci:90: warn: adding implicit cast uint32(16711935: int32)
cmplStd/lib/math/Bits.ci:90: warn: adding implicit cast int64(x: uint32)
cmplStd/lib/math/Bits.ci:90: warn: adding implicit cast int64((x & (16711935)) << 8: uint32)
cmplStd/lib/math/Bits.ci:90: warn: adding implicit cast uint32(((x & (16711935)) << 8) | ((x) & 4278255360) >> 8: int64)
cmplStd/lib/math/Bits.ci:96: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:96: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:111: warn: adding implicit cast pointer(typename(uint64.bsr): typename)
cmplStd/lib/math/Bits.ci:111: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:113: verbose: reference `bsr` is not defined
cmplStd/lib/math/Bits.ci:113: verbose: reference `bsr` is not defined
cmplStd/lib/math/Bits.ci:113: verbose: can not type check expression: `.result := uint64.bsr(x)`
cmplStd/lib/math/Bits.ci:115: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:120: warn: adding implicit cast uint64(-4294967296: int64)
cmplStd/lib/math/Bits.ci:124: warn: adding implicit cast uint64(4294901760: int64)
cmplStd/lib/math/Bits.ci:128: warn: adding implicit cast uint64(65280: int32)
cmplStd/lib/math/Bits.ci:132: warn: adding implicit cast uint64(240: int32)
cmplStd/lib/math/Bits.ci:136: warn: adding implicit cast uint64(12: int32)
cmplStd/lib/math/Bits.ci:140: warn: adding implicit cast uint64(2: int32)
cmplStd/lib/math/Bits.ci:151: warn: adding implicit cast pointer(typename(uint32.bsr): typename)
cmplStd/lib/math/Bits.ci:151: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:155: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:160: warn: adding implicit cast int64(x: uint32)
cmplStd/lib/math/Bits.ci:164: warn: adding implicit cast uint32(65280: int32)
cmplStd/lib/math/Bits.ci:168: warn: adding implicit cast uint32(240: int32)
cmplStd/lib/math/Bits.ci:172: warn: adding implicit cast uint32(12: int32)
cmplStd/lib/math/Bits.ci:176: warn: adding implicit cast uint32(2: int32)
cmplStd/lib/math/Bits.ci:187: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:192: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:194: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:194: warn: adding implicit cast uint16((x) >> 8: int32)
cmplStd/lib/math/Bits.ci:196: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:198: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:198: warn: adding implicit cast uint16((x) >> 4: int32)
cmplStd/lib/math/Bits.ci:200: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:202: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:202: warn: adding implicit cast uint16((x) >> 2: int32)
cmplStd/lib/math/Bits.ci:204: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:215: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:220: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:222: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:222: warn: adding implicit cast uint8((x) >> 4: int32)
cmplStd/lib/math/Bits.ci:224: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:226: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:226: warn: adding implicit cast uint8((x) >> 2: int32)
cmplStd/lib/math/Bits.ci:228: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:240: warn: adding implicit cast pointer(typename(uint64.bsf): typename)
cmplStd/lib/math/Bits.ci:240: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:242: verbose: reference `bsf` is not defined
cmplStd/lib/math/Bits.ci:242: verbose: reference `bsf` is not defined
cmplStd/lib/math/Bits.ci:242: verbose: can not type check expression: `.result := uint64.bsf(x)`
cmplStd/lib/math/Bits.ci:245: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:250: warn: adding implicit cast uint64(4294967295: int64)
cmplStd/lib/math/Bits.ci:250: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:254: warn: adding implicit cast uint64(65535: int32)
cmplStd/lib/math/Bits.ci:254: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:258: warn: adding implicit cast uint64(255: int32)
cmplStd/lib/math/Bits.ci:258: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:262: warn: adding implicit cast uint64(15: int32)
cmplStd/lib/math/Bits.ci:262: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:266: warn: adding implicit cast uint64(3: int32)
cmplStd/lib/math/Bits.ci:266: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:270: warn: adding implicit cast uint64(1: int32)
cmplStd/lib/math/Bits.ci:270: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:281: warn: adding implicit cast pointer(typename(uint32.bsf): typename)
cmplStd/lib/math/Bits.ci:281: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:286: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:291: warn: adding implicit cast uint32(65535: int32)
cmplStd/lib/math/Bits.ci:291: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:295: warn: adding implicit cast uint32(255: int32)
cmplStd/lib/math/Bits.ci:295: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:299: warn: adding implicit cast uint32(15: int32)
cmplStd/lib/math/Bits.ci:299: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:303: warn: adding implicit cast uint32(3: int32)
cmplStd/lib/math/Bits.ci:303: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:307: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Bits.ci:307: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:318: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:323: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:325: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:325: warn: adding implicit cast uint16((x) >> 8: int32)
cmplStd/lib/math/Bits.ci:327: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:329: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:329: warn: adding implicit cast uint16((x) >> 4: int32)
cmplStd/lib/math/Bits.ci:331: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:333: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:333: warn: adding implicit cast uint16((x) >> 2: int32)
cmplStd/lib/math/Bits.ci:335: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:346: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:351: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:353: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:353: warn: adding implicit cast uint8((x) >> 4: int32)
cmplStd/lib/math/Bits.ci:355: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:357: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:357: warn: adding implicit cast uint8((x) >> 2: int32)
cmplStd/lib/math/Bits.ci:359: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:371: warn: adding implicit cast pointer(typename(uint64.hib): typename)
cmplStd/lib/math/Bits.ci:371: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:373: verbose: reference `hib` is not defined
cmplStd/lib/math/Bits.ci:373: verbose: reference `hib` is not defined
cmplStd/lib/math/Bits.ci:373: verbose: can not type check expression: `.result := uint64.hib(x)`
cmplStd/lib/math/Bits.ci:390: warn: adding implicit cast pointer(typename(uint32.hib): typename)
cmplStd/lib/math/Bits.ci:390: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:434: warn: adding implicit cast pointer(typename(uint64.pop): typename)
cmplStd/lib/math/Bits.ci:434: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:436: verbose: reference `pop` is not defined
cmplStd/lib/math/Bits.ci:436: verbose: reference `pop` is not defined
cmplStd/lib/math/Bits.ci:436: verbose: can not type check expression: `.result := uint64.pop(x)`
cmplStd/lib/math/Bits.ci:439: warn: adding implicit cast uint64(6148914691236517205: int64)
cmplStd/lib/math/Bits.ci:440: warn: adding implicit cast uint64(3689348814741910323: int64)
cmplStd/lib/math/Bits.ci:440: warn: adding implicit cast uint64(3689348814741910323: int64)
cmplStd/lib/math/Bits.ci:441: warn: adding implicit cast uint64(1085102592571150095: int64)
cmplStd/lib/math/Bits.ci:445: warn: adding implicit cast uint64(63: int32)
cmplStd/lib/math/Bits.ci:453: warn: adding implicit cast pointer(typename(uint32.pop): typename)
cmplStd/lib/math/Bits.ci:453: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:458: warn: adding implicit cast uint32(1431655765: int32)
cmplStd/lib/math/Bits.ci:459: warn: adding implicit cast uint32(858993459: int32)
cmplStd/lib/math/Bits.ci:459: warn: adding implicit cast uint32(858993459: int32)
cmplStd/lib/math/Bits.ci:460: warn: adding implicit cast uint32(252645135: int32)
cmplStd/lib/math/Bits.ci:463: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/math/Bits.ci:472: warn: adding implicit cast pointer(typename(uint64.swap): typename)
cmplStd/lib/math/Bits.ci:472: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:474: verbose: reference `swap` is not defined
cmplStd/lib/math/Bits.ci:474: verbose: reference `swap` is not defined
cmplStd/lib/math/Bits.ci:474: verbose: can not type check expression: `.result := uint64.swap(x)`
cmplStd/lib/math/Bits.ci:477: warn: adding implicit cast uint64(6148914691236517205: int64)
cmplStd/lib/math/Bits.ci:477: warn: adding implicit cast uint64(6148914691236517205: int64)
cmplStd/lib/math/Bits.ci:478: warn: adding implicit cast uint64(3689348814741910323: int64)
cmplStd/lib/math/Bits.ci:478: warn: adding implicit cast uint64(3689348814741910323: int64)
cmplStd/lib/math/Bits.ci:479: warn: adding implicit cast uint64(1085102592571150095: int64)
cmplStd/lib/math/Bits.ci:479: warn: adding implicit cast uint64(1085102592571150095: int64)
cmplStd/lib/math/Bits.ci:480: warn: adding implicit cast uint64(71777214294589695: int64)
cmplStd/lib/math/Bits.ci:480: warn: adding implicit cast uint64(71777214294589695: int64)
cmplStd/lib/math/Bits.ci:481: warn: adding implicit cast uint64(281470681808895: int64)
cmplStd/lib/math/Bits.ci:481: warn: adding implicit cast uint64(281470681808895: int64)
cmplStd/lib/math/Bits.ci:490: warn: adding implicit cast pointer(typename(uint32.swap): typename)
cmplStd/lib/math/Bits.ci:490: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:495: warn: adding implicit cast uint32(1431655765: int32)
cmplStd/lib/math/Bits.ci:495: warn: adding implicit cast uint32(1431655765: int32)
cmplStd/lib/math/Bits.ci:496: warn: adding implicit cast uint32(858993459: int32)
cmplStd/lib/math/Bits.ci:496: warn: adding implicit cast uint32(858993459: int32)
cmplStd/lib/math/Bits.ci:497: warn: adding implicit cast uint32(252645135: int32)
cmplStd/lib/math/Bits.ci:497: warn: adding implicit cast uint32(252645135: int32)
cmplStd/lib/math/Bits.ci:498: warn: adding implicit cast uint32(16711935: int32)
cmplStd/lib/math/Bits.ci:498: warn: adding implicit cast uint32(16711935: int32)
cmplStd/lib/math/Bits.ci:507: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:507: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:507: warn: adding implicit cast uint16((((x) >> 1) & 21845) | (((x) & 21845) << 1): int32)
cmplStd/lib/math/Bits.ci:508: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:508: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:508: warn: adding implicit cast uint16((((x) >> 2) & 13107) | (((x) & 13107) << 2): int32)
cmplStd/lib/math/Bits.ci:509: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:509: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:509: warn: adding implicit cast uint16((((x) >> 4) & 3855) | (((x) & 3855) << 4): int32)
cmplStd/lib/math/Bits.ci:510: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:510: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:518: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:518: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:518: warn: adding implicit cast uint8((((x) >> 1) & 85) | (((x) & 85) << 1): int32)
cmplStd/lib/math/Bits.ci:519: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:519: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:519: warn: adding implicit cast uint8((((x) >> 2) & 51) | (((x) & 51) << 2): int32)
cmplStd/lib/math/Bits.ci:520: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:520: warn: adding implicit cast int32(x: uint8)
cmplStd/lib.ci:25: debug: inline file: `cmplStd/lib/math/Math.ci`
cmplStd/lib/math/Math.ci:17: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:18: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:29: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:29: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:34: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:47: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:47: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:53: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:54: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:55: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:62: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Math.ci:63: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:64: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Math.ci:86: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Math.ci:86: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Math.ci:89: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Math.ci:92: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Math.ci:95: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:95: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:98: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:98: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:103: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:111: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:121: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Math.ci:130: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:133: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:197: warn: adding implicit cast float32(2: int32)
cmplStd/lib/math/Math.ci:197: warn: adding implicit cast float32(3: int32)
cmplStd/lib/math/Math.ci:202: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:202: warn: adding implicit cast float64(3: int32)
cmplStd/lib/math/Math.ci:210: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Math.ci:214: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Math.ci:224: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Math.ci:228: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Math.ci:239: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Math.ci:247: warn: adding implicit cast float64(Bits.signed(values.length): int32)
cmplStd/lib/math/Math.ci:271: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Math.ci:279: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:280: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:285: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:288: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:317: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:328: warn: adding implicit cast float64(1 << 52: int32)
cmplStd/lib/math/Math.ci:337: warn: adding implicit cast uint64(bias: int32)
cmplStd/lib/math/Math.ci:358: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:362: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:369: warn: adding implicit cast float64(1 << 52: int32)
cmplStd/lib/math/Math.ci:374: warn: adding implicit cast uint64(int32(x >> shift): int32)
cmplStd/lib/math/Math.ci:374: warn: adding implicit cast uint64(bias: int32)
cmplStd/lib/math/Math.ci:374: warn: adding implicit cast uint64(exp: int32)
cmplStd/lib/math/Math.ci:374: warn: adding implicit cast int32((exp) + ((int32(x >> shift)) & mask) - (bias): uint64)
cmplStd/lib/math/Math.ci:388: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:398: warn: adding implicit cast pointer(typename(float64.log): typename)
cmplStd/lib/math/Math.ci:398: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:418: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:419: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:428: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:432: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:436: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:436: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:440: warn: adding implicit cast float64(exp: int32)
cmplStd/lib/math/Math.ci:445: warn: adding implicit cast pointer(typename(float32.log): typename)
cmplStd/lib/math/Math.ci:445: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:466: warn: adding implicit cast pointer(typename(float64.exp): typename)
cmplStd/lib/math/Math.ci:466: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:517: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:517: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:522: warn: adding implicit cast pointer(typename(float32.exp): typename)
cmplStd/lib/math/Math.ci:522: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:533: warn: adding implicit cast pointer(typename(float64.sqrt): typename)
cmplStd/lib/math/Math.ci:533: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:544: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:547: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:559: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Math.ci:577: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Math.ci:588: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Math.ci:589: warn: adding implicit cast uint64(1: int32)
cmplStd/lib/math/Math.ci:597: warn: adding implicit cast pointer(typename(float32.sqrt): typename)
cmplStd/lib/math/Math.ci:597: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:608: warn: adding implicit cast pointer(typename(float64.pow): typename)
cmplStd/lib/math/Math.ci:608: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:613: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:618: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:627: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:627: warn: adding implicit cast bool(flip: int32)
cmplStd/lib/math/Math.ci:633: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:634: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:638: warn: adding implicit cast float64(2147483647: int32)
cmplStd/lib/math/Math.ci:639: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:640: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:640: warn: adding implicit cast bool(flip: int32)
cmplStd/lib/math/Math.ci:647: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:663: warn: adding implicit cast int64(1: int32)
cmplStd/lib/math/Math.ci:668: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Math.ci:688: warn: adding implicit cast pointer(typename(float32.pow): typename)
cmplStd/lib/math/Math.ci:688: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:711: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:717: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:718: warn: adding implicit cast float64(32764: int32)
cmplStd/lib/math/Math.ci:721: warn: adding implicit cast float64(quad: int32)
cmplStd/lib/math/Math.ci:725: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math/Math.ci:725: warn: adding implicit cast int32(e - (4) * f: float64)
cmplStd/lib/math/Math.ci:728: warn: adding implicit cast float64(k: int32)
cmplStd/lib/math/Math.ci:733: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:767: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:769: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/math/Math.ci:778: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math/Math.ci:807: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/math/Math.ci:811: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:852: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:852: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:854: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math/Math.ci:854: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:854: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:857: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:866: warn: adding implicit cast pointer(typename(float64.atan2): typename)
cmplStd/lib/math/Math.ci:866: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:872: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:873: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:875: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:879: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:880: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:890: warn: adding implicit cast pointer(typename(float32.atan2): typename)
cmplStd/lib/math/Math.ci:890: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:901: warn: adding implicit cast pointer(typename(float64.sin): typename)
cmplStd/lib/math/Math.ci:901: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:911: warn: adding implicit cast pointer(typename(float32.sin): typename)
cmplStd/lib/math/Math.ci:911: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:920: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:920: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:920: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:923: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:923: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:926: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:931: warn: adding implicit cast pointer(typename(float64.cos): typename)
cmplStd/lib/math/Math.ci:931: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:936: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:944: warn: adding implicit cast pointer(typename(float32.cos): typename)
cmplStd/lib/math/Math.ci:944: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:953: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:953: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:953: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:956: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:956: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:959: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:964: warn: adding implicit cast pointer(typename(float64.tan): typename)
cmplStd/lib/math/Math.ci:964: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:969: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:976: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:986: warn: adding implicit cast pointer(typename(float32.tan): typename)
cmplStd/lib/math/Math.ci:986: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:995: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:995: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:995: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:995: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:998: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:998: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:998: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/math/Math.ci:998: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1003: warn: adding implicit cast pointer(typename(float64.cot): typename)
cmplStd/lib/math/Math.ci:1003: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:1005: verbose: reference `cot` is not defined
cmplStd/lib/math/Math.ci:1005: verbose: reference `cot` is not defined
cmplStd/lib/math/Math.ci:1005: verbose: can not type check expression: `.result := float64.cot(x)`
cmplStd/lib/math/Math.ci:1008: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1015: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1018: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:1018: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1018: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1021: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1021: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1021: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/math/Math.ci:1021: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1025: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1028: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1031: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1031: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1038: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1041: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1044: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1044: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1051: warn: adding implicit cast float64(180: int32)
cmplStd/lib/math/Math.ci:1054: warn: adding implicit cast float64(180: int32)
cmplStd/lib.ci:26: debug: inline file: `cmplStd/lib/math/Fixed.ci`
cmplStd/lib/math/Fixed.ci:9: warn: adding implicit cast int32(2147483648: int64)
cmplStd/lib/math/Fixed.ci:33: verbose: reference `precision_must_be_at_most_26_bits` is not defined
cmplStd/lib/math/Fixed.ci:33: verbose: can not type check expression: `precision_must_be_at_most_26_bits`
cmplStd/lib/math/Fixed.ci:33: verbose: unexpected token `}`, matching `;`
cmplStd/lib/math/Fixed.ci:47: warn: adding implicit cast int64(b.value: int32)
cmplStd/lib/math/Fixed.ci:47: warn: adding implicit cast int32((int64(a.value) * (b.value)) >> precision: int64)
cmplStd/lib/math/Fixed.ci:49: warn: adding implicit cast int64(b: int32)
cmplStd/lib/math/Fixed.ci:49: warn: adding implicit cast int32(int64(a.value) * (b) >> 28: int64)
cmplStd/lib/math/Fixed.ci:59: warn: adding implicit cast int64(b.value: int32)
cmplStd/lib/math/Fixed.ci:59: warn: adding implicit cast int32((int64(a.value) << precision) / (b.value): int64)
cmplStd/lib/math/Fixed.ci:71: warn: adding implicit cast int64(x.value: int32)
cmplStd/lib/math/Fixed.ci:73: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Fixed.ci:75: warn: adding implicit cast int32(value: int64)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(6039313: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(12055173: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(18047761: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(24017256: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(29963835: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(35887674: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(41788946: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(47667822: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(53524472: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(59359063: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(65171760: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(70962727: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(76732127: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(82480119: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(88206861: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(93912510: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(99597221: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(105261147: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(110904439: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(116527248: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(122129720: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(127712004: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(133274243: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(138816582: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(144339162: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(149842123: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(155325605: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(160789745: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(166234678: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(171660540: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(177067464: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(182455580: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(187825021: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(193175914: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(198508387: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(203822568: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(209118580: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(214396547: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(219656593: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(224898838: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(230123403: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(235330406: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(240519966: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(245692198: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(250847217: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(255985139: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(261106076: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(266210140: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(271297442: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(276368091: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(281422197: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(286459866: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(291481206: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(296486322: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(301475318: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(306448299: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(311405365: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(316346620: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(321272163: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(326182094: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(331076512: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(335955515: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(340819198: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(345667659: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(350500992: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(355319292: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(360122651: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(364911161: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(369684916: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(374444004: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(379188516: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(383918541: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(388634167: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(393335482: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(398022572: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(402695523: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(407354419: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(411999346: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(416630387: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(421247625: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(425851141: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(430441017: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(435017333: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(439580170: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(444129606: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(448665721: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(453188591: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(457698295: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(462194907: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(466678505: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(471149164: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(475606957: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(480051958: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(484484242: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(488903880: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(493310944: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(497705506: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(502087636: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(506457405: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(510814881: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(515160135: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(519493235: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(523814247: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(528123240: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(532420281: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(536705434: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(540978766: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(545240343: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(549490227: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(553728484: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(557955177: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(562170369: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(566374122: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(570566498: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(574747559: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(578917365: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(583075977: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(587223454: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(591359857: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(595485245: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(599599675: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(603703206: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(607795895: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(611877800: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(615948977: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(620009483: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(624059372: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(628098702: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(632127526: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(636145899: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(640153876: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(644151509: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(648138852: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(652115958: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(656082880: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(660039669: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(663986377: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(667923055: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(671849754: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(675766525: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(679673417: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(683570481: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(687457765: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(691335319: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(695203191: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(699061430: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(702910083: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(706749198: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(710578821: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(714399001: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(718209783: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(722011213: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(725803337: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(729586201: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(733359850: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(737124328: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(740879680: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(744625950: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(748363182: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(752091420: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(755810706: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(759521084: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(763222596: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(766915284: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(770599191: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(774274358: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(777940826: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(781598636: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(785247830: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(788888447: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(792520529: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(796144114: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(799759243: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(803365955: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(806964288: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(810554283: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(814135977: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(817709409: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(821274616: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(824831638: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(828380510: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(831921270: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(835453956: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(838978604: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(842495250: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(846003931: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(849504683: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(852997541: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(856482541: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(859959719: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(863429109: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(866890746: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(870344665: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(873790900: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(877229485: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(880660455: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(884083842: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(887499680: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(890908002: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(894308843: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(897702233: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(901088206: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(904466794: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(907838029: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(911201943: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(914558569: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(917907937: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(921250078: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(924585025: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(927912807: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(931233455: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(934547001: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(937853474: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(941152904: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(944445322: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(947730757: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(951009239: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(954280797: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(957545460: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(960803257: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(964054217: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(967298369: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(970535741: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(973766362: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(976990259: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(980207460: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(983417994: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(986621888: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(989819169: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(993009864: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(996194001: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(999371606: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1002542706: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1005707329: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1008865499: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1012017244: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1015162589: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1018301561: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1021434184: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1024560486: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1027680491: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1030794225: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1033901713: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1037002979: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1040098049: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1043186947: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1046269698: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1049346327: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1052416857: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1055481313: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1058539719: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1061592098: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1064638475: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1067678872: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1070713314: int32)
cmplStd/lib/math/Fixed.ci:169: warn: adding implicit cast uint32(1073741824: int32)
cmplStd/lib/math/Fixed.ci:184: verbose: reference `error_not_implemented_yet` is not defined
cmplStd/lib/math/Fixed.ci:184: verbose: can not type check expression: `error_not_implemented_yet`
cmplStd/lib/math/Fixed.ci:192: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:192: warn: adding implicit cast uint32(value: int32)
cmplStd/lib/math/Fixed.ci:192: warn: adding implicit cast int32(mix * (tbl_log2[idx + (1)] - (value)) >> 8: uint32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1073741824: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1076653033: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1079572135: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1082499152: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1085434105: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1088377016: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1091327905: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1094286795: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1097253708: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1100228664: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1103211687: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1106202797: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1109202017: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1112209369: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1115224875: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1118248556: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1121280435: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1124320535: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1127368877: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1130425484: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1133490379: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1136563583: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1139645119: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1142735011: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1145833280: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1148939949: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1152055041: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1155178579: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1158310586: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1161451085: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1164600098: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1167757649: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1170923761: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1174098458: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1177281762: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1180473696: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1183674285: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1186883552: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1190101520: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1193328212: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1196563653: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1199807866: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1203060875: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1206322704: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1209593377: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1212872917: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1216161349: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1219458697: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1222764985: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1226080238: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1229404478: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1232737732: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1236080023: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1239431376: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1242791815: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1246161366: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1249540052: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1252927899: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1256324931: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1259731173: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1263146651: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1266571389: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1270005412: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1273448746: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1276901416: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1280363447: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1283834865: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1287315694: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1290805961: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1294305691: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1297814910: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1301333643: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1304861916: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1308399756: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1311947188: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1315504237: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1319070931: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1322647295: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1326233356: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1329829139: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1333434672: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1337049980: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1340675090: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1344310029: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1347954823: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1351609500: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1355274085: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1358948606: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1362633089: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1366327562: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1370032052: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1373746586: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1377471191: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1381205894: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1384950723: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1388705705: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1392470868: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1396246240: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1400031847: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1403827719: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1407633882: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1411450365: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1415277195: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1419114400: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1422962010: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1426820051: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1430688553: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1434567543: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1438457050: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1442357103: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1446267730: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1450188959: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1454120821: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1458063342: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1462016553: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1465980482: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1469955158: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1473940611: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1477936869: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1481943963: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1485961920: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1489990772: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1494030547: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1498081274: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1502142985: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1506215708: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1510299473: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1514394310: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1518500249: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1522617321: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1526745556: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1530884983: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1535035633: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1539197537: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1543370725: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1547555227: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1551751075: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1555958299: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1560176930: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1564406999: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1568648537: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1572901574: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1577166143: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1581442274: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1585729999: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1590029349: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1594340356: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1598663051: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1602997467: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1607343634: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1611701584: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1616071351: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1620452965: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1624846458: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1629251864: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1633669214: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1638098541: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1642539876: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1646993254: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1651458705: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1655936264: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1660425963: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1664927834: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1669441912: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1673968228: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1678506816: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1683057710: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1687620942: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1692196547: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1696784557: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1701385007: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1705997929: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1710623359: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1715261329: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1719911875: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1724575029: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1729250826: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1733939301: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1738640487: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1743354420: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1748081133: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1752820662: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1757573041: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1762338305: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1767116488: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1771907627: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1776711756: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1781528911: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1786359125: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1791202436: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1796058879: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1800928488: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1805811301: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1810707352: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1815616678: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1820539314: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1825475297: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1830424662: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1835387447: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1840363687: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1845353419: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1850356680: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1855373506: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1860403934: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1865448001: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1870505743: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1875577199: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1880662405: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1885761398: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1890874215: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1896000895: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1901141475: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1906295993: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1911464486: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1916646992: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1921843549: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1927054195: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1932278969: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1937517909: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1942771053: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1948038440: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1953320108: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1958616096: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1963926443: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1969251187: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1974590369: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1979944027: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1985312199: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1990694927: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1996092248: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(2001504204: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(2006930832: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2012372173: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2017828268: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2023299155: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2028784876: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2034285470: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2039800977: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2045331439: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2050876895: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2056437386: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2062012953: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2067603638: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2073209480: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2078830521: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2084466802: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2090118365: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2095785251: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2101467501: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2107165158: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2112878262: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2118606856: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2124350982: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2130110682: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2135885998: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2141676972: int32)
cmplStd/lib/math/Fixed.ci:289: warn: adding implicit cast uint32(2147483648: int64)
cmplStd/lib/math/Fixed.ci:307: verbose: reference `error_not_implemented_yet` is not defined
cmplStd/lib/math/Fixed.ci:307: verbose: can not type check expression: `error_not_implemented_yet`
cmplStd/lib/math/Fixed.ci:314: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:368: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Fixed.ci:368: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:372: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:375: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:432: warn: adding implicit cast int64(res: int32)
cmplStd/lib/math/Fixed.ci:432: warn: adding implicit cast int32((res) * sqr >> precision: int64)
cmplStd/lib/math/Fixed.ci:444: warn: adding implicit cast int64(a1: int32)
cmplStd/lib/math/Fixed.ci:458: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:458: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Fixed.ci:459: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:459: warn: adding implicit cast float64(6: int32)
cmplStd/lib/math/Fixed.ci:460: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:460: warn: adding implicit cast float64(120: int32)
cmplStd/lib/math/Fixed.ci:461: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:461: warn: adding implicit cast float64(5040: int32)
cmplStd/lib/math/Fixed.ci:462: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:462: warn: adding implicit cast float64(362880: int32)
cmplStd/lib/math/Fixed.ci:463: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:463: warn: adding implicit cast float64(39916800: int32)
warn: adding implicit cast int32(1048576.000000: float64)
warn: adding implicit cast int32(-174762.666667: float64)
warn: adding implicit cast int32(8738.133333: float64)
warn: adding implicit cast int32(-208.050794: float64)
warn: adding implicit cast int32(2.889594: float64)
warn: adding implicit cast int32(-0.026269: float64)
cmplStd/lib/math/Fixed.ci:484: warn: adding implicit cast int64(x.value: int32)
cmplStd/lib/math/Fixed.ci:536: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:536: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Fixed.ci:537: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:537: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Fixed.ci:538: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:538: warn: adding implicit cast float64(24: int32)
cmplStd/lib/math/Fixed.ci:539: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:539: warn: adding implicit cast float64(720: int32)
cmplStd/lib/math/Fixed.ci:540: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:540: warn: adding implicit cast float64(40320: int32)
cmplStd/lib/math/Fixed.ci:541: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:541: warn: adding implicit cast float64(3628800: int32)
warn: adding implicit cast int32(1048576.000000: float64)
warn: adding implicit cast int32(-524288.000000: float64)
warn: adding implicit cast int32(43690.666667: float64)
warn: adding implicit cast int32(-1456.355556: float64)
warn: adding implicit cast int32(26.006349: float64)
warn: adding implicit cast int32(-0.288959: float64)
cmplStd/lib/math/Fixed.ci:562: warn: adding implicit cast int64(x.value: int32)
cmplStd/lib/math/Fixed.ci:715: warn: adding implicit cast int64(radians.value: int32)
cmplStd/lib/math/Fixed.ci:2: warn: padding `Fixed` with 4 bytes: (4 -> 8)
cmplStd/lib/math/Fixed.ci:733: warn: adding implicit cast float64((1 << Fixed.precision): int32)
cmplStd/lib/math/Fixed.ci:738: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Fixed.ci:741: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Fixed.ci:761: warn: adding implicit cast float64(value.value: int32)
cmplStd/lib.ci:27: debug: inline file: `cmplStd/lib/math/Complex.ci`
cmplStd/lib/math/Complex.ci:12: debug: using default field initializer: Complex.im := 0
cmplStd/lib/math/Complex.ci:8: warn: adding implicit cast float64(0: int32)
cmplStd/lib.ci:28: debug: inline file: `cmplStd/lib/math/Vector4f.ci`
cmplStd/lib.ci:29: debug: inline file: `cmplStd/lib/math/Matrix4f.ci`
cmplStd/lib/math/Matrix4f.ci:111: warn: adding implicit cast float64(len: float32)
cmplStd/lib/math/Matrix4f.ci:135: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:184: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:193: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:193: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:193: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:194: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:194: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:194: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:195: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:195: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:195: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:202: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:202: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:202: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
cmplStd/lib/math/Matrix4f.ci:202: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:205: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:205: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:205: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:206: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:206: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:206: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(1: int32)
cmplStd/lib.ci:30: debug: inline file: `cmplStd/lib/math/Vector2d.ci`
cmplStd/lib.ci:39: debug: inline file: `cmplStd/lib/time/Timeunit.ci`
cmplStd/lib/time/Timeunit.ci:4: warn: adding implicit cast Timeunit(1: int32)
cmplStd/lib/time/Timeunit.ci:5: warn: adding implicit cast int64(1000: int32)
warn: adding implicit cast Timeunit(1000: int64)
cmplStd/lib/time/Timeunit.ci:6: warn: adding implicit cast int64(1000: int32)
warn: adding implicit cast Timeunit(1000000: int64)
cmplStd/lib/time/Timeunit.ci:7: warn: adding implicit cast int64(1000: int32)
warn: adding implicit cast Timeunit(1000000000: int64)
cmplStd/lib/time/Timeunit.ci:8: warn: adding implicit cast int64(60: int32)
warn: adding implicit cast Timeunit(60000000000: int64)
cmplStd/lib/time/Timeunit.ci:9: warn: adding implicit cast int64(60: int32)
warn: adding implicit cast Timeunit(3600000000000: int64)
cmplStd/lib/time/Timeunit.ci:10: warn: adding implicit cast int64(24: int32)
warn: adding implicit cast Timeunit(86400000000000: int64)
cmplStd/lib/time/Timeunit.ci:27: warn: adding implicit cast float64((from / to): int64)
cmplStd/lib/time/Timeunit.ci:30: warn: adding implicit cast float64((to / from): int64)
cmplStd/lib.ci:40: debug: inline file: `cmplStd/lib/time/Duration.ci`
cmplStd/lib/time/Duration.ci:8: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib.ci:41: debug: inline file: `cmplStd/lib/time/Timestamp.ci`
cmplStd/lib/time/Timestamp.ci:9: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib/time/Timestamp.ci:56: warn: adding implicit cast int64(Timestamp.precision: Timeunit)
cmplStd/lib/time/Timestamp.ci:74: warn: adding implicit cast int64(Timestamp.precision: Timeunit)
cmplStd/lib/time/Timestamp.ci:80: warn: adding implicit cast int64(0: int32)
cmplStd/lib/time/Timestamp.ci:96: warn: adding implicit cast int64(0: int32)
cmplStd/lib/time/Timestamp.ci:115: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib.ci:42: debug: inline file: `cmplStd/lib/time/Timezone.ci`
cmplStd/lib/time/Timezone.ci:14: warn: adding implicit cast int64(0: int32)
cmplStd/lib/time/Timezone.ci:18: warn: adding implicit cast char[]("UTC": .cstr)
cmplStd/lib/time/Timezone.ci:29: warn: adding implicit cast Timeunit(Hours: int64)
cmplStd/lib/time/Timezone.ci:33: warn: adding implicit cast char[]("GMT+3": .cstr)
cmplStd/lib/time/Timezone.ci:2: warn: padding `Timezone` with 4 bytes: (12 -> 16)
cmplStd/lib.ci:43: debug: inline file: `cmplStd/lib/time/Datetime.ci`
cmplStd/lib/time/Datetime.ci:3: warn: adding implicit cast Month(1: int32)
warn: adding implicit cast Month(2: int64)
warn: adding implicit cast Month(3: int64)
warn: adding implicit cast Month(4: int64)
warn: adding implicit cast Month(5: int64)
warn: adding implicit cast Month(6: int64)
warn: adding implicit cast Month(7: int64)
warn: adding implicit cast Month(8: int64)
warn: adding implicit cast Month(9: int64)
warn: adding implicit cast Month(10: int64)
warn: adding implicit cast Month(11: int64)
warn: adding implicit cast Month(12: int64)
cmplStd/lib/time/Datetime.ci:17: warn: adding implicit cast Month(January: uint8)
cmplStd/lib/time/Datetime.ci:17: warn: adding implicit cast int32(Month.(January): Month)
cmplStd/lib/time/Datetime.ci:19: warn: adding implicit cast Month(January: uint8)
cmplStd/lib/time/Datetime.ci:19: warn: adding implicit cast uint8(Month.(January): Month)
cmplStd/lib/time/Datetime.ci:23: warn: adding implicit cast Weekday(1: int32)
warn: adding implicit cast Weekday(2: int64)
warn: adding implicit cast Weekday(3: int64)
warn: adding implicit cast Weekday(4: int64)
warn: adding implicit cast Weekday(5: int64)
warn: adding implicit cast Weekday(6: int64)
warn: adding implicit cast Weekday(7: int64)
cmplStd/lib/time/Datetime.ci:32: warn: adding implicit cast Weekday(Monday: uint8)
cmplStd/lib/time/Datetime.ci:32: warn: adding implicit cast int32(Weekday.(Monday): Weekday)
cmplStd/lib/time/Datetime.ci:34: warn: adding implicit cast Weekday(Monday: uint8)
cmplStd/lib/time/Datetime.ci:34: warn: adding implicit cast uint8(Weekday.(Monday): Weekday)
warn: adding implicit cast Calendar(0: int64)
cmplStd/lib/time/Datetime.ci:76: warn: padding `Datetime.millis` with 1 bytes: (9 -> 10)
cmplStd/lib/time/Datetime.ci:79: warn: padding `Datetime.timezone` with 4 bytes: (12 -> 16)
cmplStd/lib/time/Datetime.ci:89: warn: padding `Datetime.dayOfYear` with 1 bytes: (33 -> 34)
cmplStd/lib/time/Datetime.ci:57: warn: padding `Datetime` with 2 bytes: (38 -> 40)
cmplStd/lib/time/Datetime.ci:157: warn: adding implicit cast Month(January: uint8)
cmplStd/lib/time/Datetime.ci:157: warn: adding implicit cast int32(Month.(January): Month)
cmplStd/lib/time/Datetime.ci:157: warn: adding implicit cast Month(December: uint8)
cmplStd/lib/time/Datetime.ci:157: warn: adding implicit cast int32(Month.(December): Month)
cmplStd/lib/time/Datetime.ci:159: warn: adding implicit cast Month(January: uint8)
cmplStd/lib/time/Datetime.ci:159: warn: adding implicit cast Month(December: uint8)
cmplStd/lib/time/Datetime.ci:162: warn: adding implicit cast int32[13](Datetime.DaysToMonth366: int32[13])
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(24: int32)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(value.hour: uint8)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(60: int32)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(value.minute: uint8)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(60: int32)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(value.second: uint8)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(1000: int32)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(value.millis: uint16)
cmplStd/lib/time/Datetime.ci:175: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib/time/Datetime.ci:180: warn: adding implicit cast Calendar(Gregorian: uint8)
cmplStd/lib/time/Datetime.ci:180: warn: adding implicit cast uint8(Calendar.(Gregorian): Calendar)
cmplStd/lib/time/Datetime.ci:198: warn: adding implicit cast Timeunit(Days: int64)
cmplStd/lib/time/Datetime.ci:198: warn: adding implicit cast int64(Datetime.DaysTil1970: int32)
cmplStd/lib/time/Datetime.ci:239: warn: adding implicit cast int32[13](Datetime.DaysToMonth366: int32[13])
cmplStd/lib/time/Datetime.ci:253: warn: adding implicit cast Timeunit(Hours: int64)
cmplStd/lib/time/Datetime.ci:253: warn: adding implicit cast int64(24: int32)
cmplStd/lib/time/Datetime.ci:254: warn: adding implicit cast Timeunit(Minutes: int64)
cmplStd/lib/time/Datetime.ci:254: warn: adding implicit cast int64(60: int32)
cmplStd/lib/time/Datetime.ci:255: warn: adding implicit cast Timeunit(Seconds: int64)
cmplStd/lib/time/Datetime.ci:255: warn: adding implicit cast int64(60: int32)
cmplStd/lib/time/Datetime.ci:256: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib/time/Datetime.ci:256: warn: adding implicit cast int64(1000: int32)
cmplStd/lib/time/Datetime.ci:264: warn: adding implicit cast Weekday(Thursday: uint8)
cmplStd/lib/time/Datetime.ci:265: warn: adding implicit cast int32[13](DaysToMonth: int32[*])
cmplStd/lib/time/Datetime.ci:250: warn: adding implicit cast uint8(n - DaysToMonth[m - 1] + 1: int32)
cmplStd/lib/time/Datetime.ci:253: warn: adding implicit cast uint8(Timestamp.value(timestamp, Timeunit.(Hours)) % (24): int64)
cmplStd/lib/time/Datetime.ci:254: warn: adding implicit cast uint8(Timestamp.value(timestamp, Timeunit.(Minutes)) % (60): int64)
cmplStd/lib/time/Datetime.ci:255: warn: adding implicit cast uint8(Timestamp.value(timestamp, Timeunit.(Seconds)) % (60): int64)
cmplStd/lib/time/Datetime.ci:256: warn: adding implicit cast uint16(Timestamp.value(timestamp, Timeunit.(Millis)) % (1000): int64)
cmplStd/lib/time/Datetime.ci:262: warn: adding implicit cast uint16(n + 1: int32)
cmplStd/lib/time/Datetime.ci:264: warn: adding implicit cast uint8((n - dayOfWeek + indexOf(Weekday.(Thursday))) / 7 + 1: int32)
cmplStd/lib/time/Datetime.ci:270: warn: adding implicit cast Calendar(Gregorian: uint8)
cmplStd/lib/time/Datetime.ci:285: warn: adding implicit cast Weekday(Monday: uint8)
cmplStd/lib/time/Datetime.ci:277: warn: adding implicit cast uint8(day: int32)
cmplStd/lib/time/Datetime.ci:278: warn: adding implicit cast uint8(hour: int32)
cmplStd/lib/time/Datetime.ci:279: warn: adding implicit cast uint8(minute: int32)
cmplStd/lib/time/Datetime.ci:280: warn: adding implicit cast uint8(second: int32)
cmplStd/lib/time/Datetime.ci:281: warn: adding implicit cast uint16(millis: int32)
cmplStd/lib/time/Datetime.ci:283: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/time/Datetime.ci:284: warn: adding implicit cast uint16(0: int32)
cmplStd/lib.ci:47: debug: inline file: `cmplStd/lib/text/cstr.ci`
cmplStd/lib/text/cstr.ci:5: warn: adding implicit cast pointer(str: char[*])
cmplStd/lib/text/cstr.ci:37: warn: adding implicit cast int32(with[i]: char)
cmplStd/lib/text/cstr.ci:65: warn: adding implicit cast int32(str[i]: char)
cmplStd/lib/text/cstr.ci:119: warn: adding implicit cast pointer(typename(float64.parse): typename)
cmplStd/lib/text/cstr.ci:119: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/text/cstr.ci:122: warn: adding implicit cast int32(value.length: uint32)
cmplStd/lib/text/cstr.ci:122: warn: adding implicit cast int32(value[len]: char)
cmplStd/lib/text/cstr.ci:132: warn: adding implicit cast int32(value.length: uint32)
cmplStd/lib/text/cstr.ci:132: warn: adding implicit cast int32(value[i]: char)
cmplStd/lib/text/cstr.ci:135: warn: adding implicit cast float64(10: int32)
cmplStd/lib/text/cstr.ci:135: warn: adding implicit cast float64((chr - '0'): char)
cmplStd/lib/text/cstr.ci:136: warn: adding implicit cast float64(10: int32)
cmplStd/lib/text/cstr.ci:139: warn: adding implicit cast float64(0: int32)
cmplStd/lib/text/cstr.ci:143: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/cstr.ci:146: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/text/cstr.ci:149: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/cstr.ci:157: warn: adding implicit cast float64(0: int32)
cmplStd/lib/text/cstr.ci:158: warn: adding implicit cast uint32(0: int32)
cmplStd/lib.ci:48: debug: inline file: `cmplStd/lib/text/Format.ci`
cmplStd/lib/text/Format.ci:21: warn: adding implicit cast int32('%': char)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.precision := 10
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.width := 0
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/Format.ci:7: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/Format.ci:4: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:26: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:28: warn: adding implicit cast int32('%': char)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.precision := 10
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.width := 0
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/Format.ci:7: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/Format.ci:4: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:33: warn: adding implicit cast int32('-': char)
cmplStd/lib/text/Format.ci:33: warn: adding implicit cast int32('+': char)
cmplStd/lib/text/Format.ci:36: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:40: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:43: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:47: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:47: warn: adding implicit cast int32('9': char)
cmplStd/lib/text/Format.ci:49: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:50: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:54: warn: adding implicit cast int32('.': char)
cmplStd/lib/text/Format.ci:56: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:57: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:57: warn: adding implicit cast int32('9': char)
cmplStd/lib/text/Format.ci:59: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:60: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:65: warn: adding implicit cast char(sgnChr: int32)
cmplStd/lib/text/Format.ci:67: warn: adding implicit cast char(padChr: int32)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:73: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:10: warn: padding `FormatFlags.width` with 2 bytes: (2 -> 4)
cmplStd/lib/text/Format.ci:2: warn: padding `FormatFlags` with 3 bytes: (13 -> 16)
cmplStd/lib/text/Format.ci:88: warn: adding implicit cast pointer(value: char[*])
cmplStd/lib/text/Format.ci:92: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:99: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:100: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:100: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:102: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:115: warn: adding implicit cast int32(radixDigits.length: uint32)
cmplStd/lib/text/Format.ci:118: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/text/Format.ci:118: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/text/Format.ci:119: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/text/Format.ci:133: warn: adding implicit cast int32(format.sign: char)
cmplStd/lib/text/Format.ci:138: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:143: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:150: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:157: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:162: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:163: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:163: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:165: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:171: warn: adding implicit cast int64(0: int32)
cmplStd/lib/text/Format.ci:172: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:186: warn: adding implicit cast float64(0: int32)
cmplStd/lib/text/Format.ci:185: debug: using default field initializer: FormatFlags.precision := 10
cmplStd/lib/text/Format.ci:185: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:192: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:193: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:193: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:206: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:207: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:207: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:211: warn: adding implicit cast float64(2: int32)
cmplStd/lib/text/Format.ci:213: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/Format.ci:214: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/Format.ci:215: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/Format.ci:219: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:220: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:220: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:225: warn: adding implicit cast float64(10: int32)
cmplStd/lib/text/Format.ci:226: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:226: warn: adding implicit cast char(('0') + int32(value): int32)
cmplStd/lib/text/Format.ci:229: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:230: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:230: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:234: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:243: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:246: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:321: warn: adding implicit cast int32(format.length: uint32)
cmplStd/lib/text/Format.ci:322: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:323: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:323: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:324: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:418: warn: adding implicit cast int32(value.millis: uint16)
cmplStd/lib/text/Format.ci:422: warn: adding implicit cast int32(value.hour: uint8)
cmplStd/lib/text/Format.ci:426: warn: adding implicit cast int32(value.hour: uint8)
cmplStd/lib/text/Format.ci:436: warn: adding implicit cast Timeunit(Seconds: int64)
cmplStd/lib/text/Format.ci:487: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:488: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:488: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:490: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:509: warn: adding implicit cast char[]("January": .cstr)
cmplStd/lib/text/Format.ci:510: warn: adding implicit cast char[]("February": .cstr)
cmplStd/lib/text/Format.ci:511: warn: adding implicit cast char[]("March": .cstr)
cmplStd/lib/text/Format.ci:512: warn: adding implicit cast char[]("April": .cstr)
cmplStd/lib/text/Format.ci:513: warn: adding implicit cast char[]("May": .cstr)
cmplStd/lib/text/Format.ci:514: warn: adding implicit cast char[]("June": .cstr)
cmplStd/lib/text/Format.ci:515: warn: adding implicit cast char[]("July": .cstr)
cmplStd/lib/text/Format.ci:516: warn: adding implicit cast char[]("August": .cstr)
cmplStd/lib/text/Format.ci:517: warn: adding implicit cast char[]("September": .cstr)
cmplStd/lib/text/Format.ci:518: warn: adding implicit cast char[]("October": .cstr)
cmplStd/lib/text/Format.ci:519: warn: adding implicit cast char[]("November": .cstr)
cmplStd/lib/text/Format.ci:520: warn: adding implicit cast char[]("December": .cstr)
cmplStd/lib/text/Format.ci:523: warn: adding implicit cast char[]("Jan": .cstr)
cmplStd/lib/text/Format.ci:523: warn: adding implicit cast char[]("Feb": .cstr)
cmplStd/lib/text/Format.ci:523: warn: adding implicit cast char[]("Mar": .cstr)
cmplStd/lib/text/Format.ci:523: warn: adding implicit cast char[]("Apr": .cstr)
cmplStd/lib/text/Format.ci:524: warn: adding implicit cast char[]("May": .cstr)
cmplStd/lib/text/Format.ci:524: warn: adding implicit cast char[]("Jun": .cstr)
cmplStd/lib/text/Format.ci:524: warn: adding implicit cast char[]("Jul": .cstr)
cmplStd/lib/text/Format.ci:524: warn: adding implicit cast char[]("Aug": .cstr)
cmplStd/lib/text/Format.ci:525: warn: adding implicit cast char[]("Sep": .cstr)
cmplStd/lib/text/Format.ci:525: warn: adding implicit cast char[]("Oct": .cstr)
cmplStd/lib/text/Format.ci:525: warn: adding implicit cast char[]("Nov": .cstr)
cmplStd/lib/text/Format.ci:525: warn: adding implicit cast char[]("Dec": .cstr)
cmplStd/lib/text/Format.ci:528: warn: adding implicit cast char[]("Monday": .cstr)
cmplStd/lib/text/Format.ci:529: warn: adding implicit cast char[]("Tuesday": .cstr)
cmplStd/lib/text/Format.ci:530: warn: adding implicit cast char[]("Wednesday": .cstr)
cmplStd/lib/text/Format.ci:531: warn: adding implicit cast char[]("Thursday": .cstr)
cmplStd/lib/text/Format.ci:532: warn: adding implicit cast char[]("Friday": .cstr)
cmplStd/lib/text/Format.ci:533: warn: adding implicit cast char[]("Saturday": .cstr)
cmplStd/lib/text/Format.ci:534: warn: adding implicit cast char[]("Sunday": .cstr)
cmplStd/lib/text/Format.ci:537: warn: adding implicit cast char[]("Mon": .cstr)
cmplStd/lib/text/Format.ci:537: warn: adding implicit cast char[]("Tue": .cstr)
cmplStd/lib/text/Format.ci:537: warn: adding implicit cast char[]("Wed": .cstr)
cmplStd/lib/text/Format.ci:538: warn: adding implicit cast char[]("Thu": .cstr)
cmplStd/lib/text/Format.ci:538: warn: adding implicit cast char[]("Fri": .cstr)
cmplStd/lib/text/Format.ci:538: warn: adding implicit cast char[]("Sat": .cstr)
cmplStd/lib/text/Format.ci:539: warn: adding implicit cast char[]("Sun": .cstr)
cmplStd/lib/text/Format.ci:542: warn: adding implicit cast char[]("AM": .cstr)
cmplStd/lib/text/Format.ci:543: warn: adding implicit cast char[]("PM": .cstr)
cmplStd/lib/text/Format.ci:546: warn: adding implicit cast char[]("am": .cstr)
cmplStd/lib/text/Format.ci:547: warn: adding implicit cast char[]("pm": .cstr)
cmplStd/lib/text/Format.ci:551: warn: adding implicit cast char[][](monthsLongEn: char[][])
cmplStd/lib/text/Format.ci:552: warn: adding implicit cast char[][](monthsShortEn: char[][])
cmplStd/lib/text/Format.ci:553: warn: adding implicit cast char[][](weeksLongEn: char[][])
cmplStd/lib/text/Format.ci:554: warn: adding implicit cast char[][](weeksShortEn: char[][])
cmplStd/lib/text/Format.ci:555: warn: adding implicit cast char[][](amPmUpperEn: char[][])
cmplStd/lib/text/Format.ci:556: warn: adding implicit cast char[][](amPmLowerEn: char[][])
cmplStd/lib/text/Format.ci:550: debug: using default field initializer: DatetimeFormat.dateLong := "%A %d %B %Y"
cmplStd/lib/text/Format.ci:308: warn: adding implicit cast char[]("%A %d %B %Y": .cstr)
cmplStd/lib/text/Format.ci:550: debug: using default field initializer: DatetimeFormat.timeLong := "%r"
cmplStd/lib/text/Format.ci:309: warn: adding implicit cast char[]("%r": .cstr)
cmplStd/lib/text/Format.ci:550: debug: using default field initializer: DatetimeFormat.dateShort := "%x"
cmplStd/lib/text/Format.ci:310: warn: adding implicit cast char[]("%x": .cstr)
cmplStd/lib/text/Format.ci:550: debug: using default field initializer: DatetimeFormat.timeShort := "%I:%M %p"
cmplStd/lib/text/Format.ci:311: warn: adding implicit cast char[]("%I:%M %p": .cstr)
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/Format.ci:4: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/Format.ci:7: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.width := 0
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.precision := 10
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib.ci:49: debug: inline file: `cmplStd/lib/text/stream/ByteStream.ci`
cmplStd/lib/text/stream/ByteStream.ci:8: warn: adding implicit cast pointer(this.close: function)
cmplStd/lib/text/stream/ByteStream.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/text/stream/ByteStream.ci:104: warn: Overriding virtual function: ByteReader.read(this: ByteReader, bytes: uint8[]): int32
cmplStd/lib/text/stream/ByteStream.ci:113: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib/text/stream/ByteStream.ci:126: warn: Creating virtual method for: ByteBuffer.read(this: ByteBuffer, bytes: uint8[]): int32
cmplStd/lib/text/stream/ByteStream.ci:130: warn: adding implicit cast int32(bytes.length: uint32)
cmplStd/lib/text/stream/ByteStream.ci:140: warn: Creating virtual method for: ByteBuffer.read(this: ByteBuffer): int32
cmplStd/lib/text/stream/ByteStream.ci:149: warn: Creating virtual method for: ByteBuffer.write(this: ByteBuffer, bytes: uint8[]): void
cmplStd/lib/text/stream/ByteStream.ci:150: warn: adding implicit cast int32(bytes.length: uint32)
cmplStd/lib/text/stream/ByteStream.ci:165: warn: adding implicit cast uint8[*](new: uint8[*])
cmplStd/lib/text/stream/ByteStream.ci:169: warn: adding implicit cast int32(bytes.length: uint32)
cmplStd/lib/text/stream/ByteStream.ci:175: warn: Creating virtual method for: ByteBuffer.flush(this: ByteBuffer): void
cmplStd/lib/text/stream/ByteStream.ci:179: warn: Creating virtual method for: ByteBuffer.close(this: ByteBuffer): void
cmplStd/lib/text/stream/ByteStream.ci:183: warn: adding implicit cast uint8[*](null: pointer)
cmplStd/lib/text/stream/ByteStream.ci:120: warn: padding `ByteBuffer` with 4 bytes: (36 -> 40)
cmplStd/lib.ci:50: debug: inline file: `cmplStd/lib/text/stream/TextStream.ci`
cmplStd/lib/text/stream/TextStream.ci:19: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib/text/stream/TextStream.ci:26: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/text/stream/TextStream.ci:30: warn: adding implicit cast uint32(16777215: int32)
cmplStd/lib/text/stream/TextStream.ci:67: warn: Creating virtual method for: TextWriter.flush(this: TextWriter): void
cmplStd/lib/text/stream/TextStream.ci:72: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib.ci:51: debug: inline file: `cmplStd/lib/text/encoding/binary/Base64.ci`
cmplStd/lib/text/encoding/binary/Base64.ci:41: warn: Overriding virtual function: ByteWriter.write(this: ByteWriter, bytes: uint8[]): void
cmplStd/lib/text/encoding/binary/Base64.ci:42: warn: adding implicit cast int32(length: uint32)
cmplStd/lib/text/encoding/binary/Base64.ci:50: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:50: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:51: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:52: warn: adding implicit cast uint32(2: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:55: warn: adding implicit cast int32(data[i]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:63: warn: adding implicit cast int32(data[i]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:64: warn: adding implicit cast int32(data[i + 1]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:72: warn: adding implicit cast int32(data[i]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:80: warn: adding implicit cast uint32(2: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:81: warn: adding implicit cast int32(buffer.length: uint32)
cmplStd/lib/text/encoding/binary/Base64.ci:86: warn: adding implicit cast int32(data[i + 0]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:87: warn: adding implicit cast int32(data[i + 1]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:88: warn: adding implicit cast int32(data[i + 2]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:97: warn: adding implicit cast uint32(i: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:98: warn: adding implicit cast int32(buffer.length: uint32)
cmplStd/lib/text/encoding/binary/Base64.ci:103: warn: adding implicit cast int32(data[i + 0]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:104: warn: adding implicit cast int32(data[i + 1]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:108: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:113: warn: adding implicit cast int32(data[i]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:116: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:117: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:124: warn: Overriding virtual function: ByteWriter.flush(this: ByteWriter): void
cmplStd/lib/text/encoding/binary/Base64.ci:129: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib/text/encoding/binary/Base64.ci:162: warn: Overriding virtual function: ByteReader.read(this: ByteReader, bytes: uint8[]): int32
cmplStd/lib/text/encoding/binary/Base64.ci:165: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:169: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/text/encoding/binary/Base64.ci:173: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:190: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib.ci:52: debug: inline file: `cmplStd/lib/text/encoding/Ascii.ci`
cmplStd/lib/text/encoding/Ascii.ci:4: warn: Overriding virtual function: TextReader.decode(this: TextReader, chars: uint32[]): int32
cmplStd/lib/text/encoding/Ascii.ci:6: warn: adding implicit cast int32(chars.length: uint32)
cmplStd/lib/text/encoding/Ascii.ci:12: warn: adding implicit cast uint32(value[0]: uint8)
cmplStd/lib/text/encoding/Ascii.ci:21: warn: Overriding virtual function: TextWriter.encode(this: TextWriter, chars: uint32[]): void
cmplStd/lib/text/encoding/Ascii.ci:23: warn: adding implicit cast int32(chars.length: uint32)
cmplStd/lib/text/encoding/Ascii.ci:24: warn: adding implicit cast uint8(chars[i]: uint32)
cmplStd/lib.ci:53: debug: inline file: `cmplStd/lib/text/encoding/Utf8.ci`
cmplStd/lib/text/encoding/Utf8.ci:4: warn: Overriding virtual function: TextReader.decode(this: TextReader, chars: uint32[]): int32
cmplStd/lib/text/encoding/Utf8.ci:5: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/text/encoding/Utf8.ci:6: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/text/encoding/Utf8.ci:8: warn: adding implicit cast int32(chars.length: uint32)
cmplStd/lib/text/encoding/Utf8.ci:14: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:15: warn: adding implicit cast uint32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:17: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:22: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:23: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:23: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:23: warn: adding implicit cast uint32(((buff[0]) & 31) << 6 | ((ext[0]) & 63): int32)
cmplStd/lib/text/encoding/Utf8.ci:25: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:30: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:31: warn: adding implicit cast int32(ext[1]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:32: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:32: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:32: warn: adding implicit cast int32(ext[1]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:32: warn: adding implicit cast uint32(((buff[0]) & 15) << 12 | ((ext[0]) & 63) << 6 | ((ext[1]) & 63): int32)
cmplStd/lib/text/encoding/Utf8.ci:34: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:39: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:40: warn: adding implicit cast int32(ext[1]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:41: warn: adding implicit cast int32(ext[2]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast int32(ext[1]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast int32(ext[2]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast uint32(((buff[0]) & 7) << 18 | ((ext[0]) & 63) << 12 | ((ext[1]) & 63) << 6 | ((ext[2]) & 63): int32)
cmplStd/lib/text/encoding/Utf8.ci:53: warn: Overriding virtual function: TextWriter.encode(this: TextWriter, chars: uint32[]): void
cmplStd/lib/text/encoding/Utf8.ci:55: warn: adding implicit cast int32(chars.length: uint32)
cmplStd/lib/text/encoding/Utf8.ci:58: warn: adding implicit cast uint32(128: int32)
cmplStd/lib/text/encoding/Utf8.ci:59: warn: adding implicit cast uint8(cp: uint32)
cmplStd/lib/text/encoding/Utf8.ci:62: warn: adding implicit cast uint32(2048: int32)
cmplStd/lib/text/encoding/Utf8.ci:64: warn: adding implicit cast int32((cp >> 6): uint32)
cmplStd/lib/text/encoding/Utf8.ci:65: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:65: warn: adding implicit cast int32((cp & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:64: warn: adding implicit cast uint8(192 | ((cp >> 6)): int32)
cmplStd/lib/text/encoding/Utf8.ci:65: warn: adding implicit cast uint8(128 | ((cp & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:69: warn: adding implicit cast uint32(65536: int32)
cmplStd/lib/text/encoding/Utf8.ci:71: warn: adding implicit cast int32((cp >> 12): uint32)
cmplStd/lib/text/encoding/Utf8.ci:72: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:72: warn: adding implicit cast int32(((cp >> 6) & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:73: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:73: warn: adding implicit cast int32((cp & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:71: warn: adding implicit cast uint8(224 | ((cp >> 12)): int32)
cmplStd/lib/text/encoding/Utf8.ci:72: warn: adding implicit cast uint8(128 | (((cp >> 6) & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:73: warn: adding implicit cast uint8(128 | ((cp & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:79: warn: adding implicit cast int32((cp >> 18): uint32)
cmplStd/lib/text/encoding/Utf8.ci:80: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:80: warn: adding implicit cast int32(((cp >> 12) & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:81: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:81: warn: adding implicit cast int32(((cp >> 6) & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:82: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:82: warn: adding implicit cast int32((cp & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:79: warn: adding implicit cast uint8(240 | ((cp >> 18)): int32)
cmplStd/lib/text/encoding/Utf8.ci:80: warn: adding implicit cast uint8(128 | (((cp >> 12) & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:81: warn: adding implicit cast uint8(128 | (((cp >> 6) & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:82: warn: adding implicit cast uint8(128 | ((cp & (63))): int32)
cmplStd/lib.ci:63: debug: inline file: `cmplStd/lib/math/Easing.ci`
cmplStd/lib/math/Easing.ci:32: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:32: warn: adding implicit cast float64(10: int32)
cmplStd/lib/math/Easing.ci:32: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Easing.ci:32: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Easing.ci:37: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Easing.ci:37: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:42: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:42: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:47: warn: statement should be a block statement {return .result := t;}
cmplStd/lib/math/Easing.ci:55: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:61: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:64: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math/Easing.ci:67: warn: adding implicit cast float64(8: int32)
cmplStd/lib/math/Easing.ci:68: warn: adding implicit cast float64(6: int32)
cmplStd/lib/math/Easing.ci:69: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:71: warn: adding implicit cast float64(10: int32)
cmplStd/lib/math/Easing.ci:72: warn: adding implicit cast float32(9: int32)
cmplStd/lib/math/Easing.ci:72: warn: adding implicit cast float64(((9) / 11.000000): float32)
cmplStd/lib/math/Easing.ci:73: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:75: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math/Easing.ci:76: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:79: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:79: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:85: warn: adding implicit cast pointer(ease: function)
cmplStd/lib/math/Easing.ci:93: warn: adding implicit cast pointer(ease: function)
cmplStd/lib/math/Easing.ci:96: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:101: warn: adding implicit cast pointer(ease: function)
cmplStd/lib/math/Easing.ci:104: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Easing.ci:105: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:105: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:110: warn: adding implicit cast pointer(ease: function)
cmplStd/lib/math/Easing.ci:113: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Easing.ci:114: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:114: warn: adding implicit cast float64(1: int32)
cmplStd/lib.ci:65: debug: inline file: `cmplStd/lib/math/Polynomial.ci`
cmplStd/lib/math/Polynomial.ci:9: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Polynomial.ci:10: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Polynomial.ci:14: warn: Overriding virtual function: TextWriter.Writeable.write(this: Writeable, writer: TextWriter): void
cmplStd/lib/math/Polynomial.ci:54: warn: Creating virtual method for: Polynomial.destroy(this: Polynomial): void
cmplStd/lib/math/Polynomial.ci:61: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Polynomial.ci:65: warn: adding implicit cast float64[*](coefficients: float64[*])
cmplStd/lib/math/Polynomial.ci:63: debug: using default field initializer: Polynomial.destroy(this: Polynomial): void := destroy
cmplStd/lib/math/Polynomial.ci:63: debug: using default type initializer: TextWriter.Writeable.write(this: Writeable, writer: TextWriter): void := write
cmplStd/lib/math/Polynomial.ci:69: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Polynomial.ci:157: warn: adding implicit cast float64((i + 1): int32)
cmplStd/lib/math/Polynomial.ci:167: warn: adding implicit cast float64(i: int32)
cmplStd/lib/math/Polynomial.ci:178: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Polynomial.ci:179: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Polynomial.ci:180: warn: adding implicit cast uint32(i: int32)
cmplStd/lib/math/Polynomial.ci:180: warn: adding implicit cast uint32(1: int32)

---------- Library: `build/linux/libFile.so`
debug: inline file: `cmplFile/lib.ci`
cmplFile/lib.ci:3: warn: adding implicit cast uint8(0: int32)
cmplFile/lib.ci:7: warn: adding implicit cast int32(buff[0]: uint8)
cmplFile/lib.ci:12: warn: adding implicit cast uint8(value: int32)
cmplFile/lib.ci:17: debug: inline file: `cmplFile/lib/FileStream.ci`
cmplFile/lib/FileStream.ci:5: warn: Overriding virtual function: ByteReader.read(this: ByteReader, bytes: uint8[]): int32
cmplFile/lib/FileStream.ci:9: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplFile/lib/FileStream.ci:19: warn: Overriding virtual function: ByteWriter.write(this: ByteWriter, bytes: uint8[]): void
cmplFile/lib/FileStream.ci:21: warn: adding implicit cast int32(bytes.length: uint32)
cmplFile/lib/FileStream.ci:24: warn: Overriding virtual function: ByteWriter.flush(this: ByteWriter): void
cmplFile/lib/FileStream.ci:28: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplFile/lib/FileStream.ci:44: warn: variable `BufferedFileWriter.write(this: BufferedFileWriter, bytes: uint8[]): void` hides previous declaration
cmplFile/lib/FileStream.ci:19: warn: previously defined here as `FileWriter.write(this: FileWriter, bytes: uint8[]): void`
cmplFile/lib/FileStream.ci:44: warn: Overriding virtual function: ByteWriter.write(this: ByteWriter, bytes: uint8[]): void
cmplFile/lib/FileStream.ci:45: warn: adding implicit cast int32(bytes.length: uint32)
cmplFile/lib/FileStream.ci:45: warn: adding implicit cast int32(length: uint32)
cmplFile/lib/FileStream.ci:49: warn: adding implicit cast int32(length: uint32)
cmplFile/lib/FileStream.ci:49: warn: adding implicit cast uint32(this.buffer.(length) / 2: int32)
cmplFile/lib/FileStream.ci:58: warn: adding implicit cast int32(bytes.length: uint32)
cmplFile/lib/FileStream.ci:61: warn: adding implicit cast int32(bytes.length: uint32)
cmplFile/lib/FileStream.ci:64: warn: variable `BufferedFileWriter.flush(this: BufferedFileWriter): void` hides previous declaration
cmplFile/lib/FileStream.ci:24: warn: previously defined here as `FileWriter.flush(this: FileWriter): void`
cmplFile/lib/FileStream.ci:64: warn: Overriding virtual function: ByteWriter.flush(this: ByteWriter): void
cmplFile/lib/FileStream.ci:69: warn: variable `BufferedFileWriter.close(this: BufferedFileWriter): void` hides previous declaration
cmplFile/lib/FileStream.ci:28: warn: previously defined here as `FileWriter.close(this: FileWriter): void`
cmplFile/lib/FileStream.ci:69: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplFile/lib/FileStream.ci:76: debug: using default type initializer: ByteReader.read(this: ByteReader, bytes: uint8[]): int32 := read
cmplFile/lib/FileStream.ci:76: debug: using default type initializer: Closeable.close(this: Closeable): void := close
cmplFile/lib/FileStream.ci:83: debug: using default type initializer: ByteWriter.write(this: ByteWriter, bytes: uint8[]): void := write
cmplFile/lib/FileStream.ci:83: debug: using default type initializer: ByteWriter.flush(this: ByteWriter): void := flush
cmplFile/lib/FileStream.ci:83: debug: using default type initializer: Closeable.close(this: Closeable): void := close
cmplFile/lib/FileStream.ci:92: warn: adding implicit cast uint8[1024](null: pointer)
cmplFile/lib/FileStream.ci:90: debug: using default field initializer: BufferedFileWriter.bufferSize := 0
cmplFile/lib/FileStream.ci:90: debug: using default type initializer: ByteWriter.write(this: ByteWriter, bytes: uint8[]): void := write
cmplFile/lib/FileStream.ci:90: debug: using default type initializer: ByteWriter.flush(this: ByteWriter): void := flush
cmplFile/lib/FileStream.ci:90: debug: using default type initializer: Closeable.close(this: Closeable): void := close

---------- Library: `build/linux/libGfx.so`
warn: multi-line comment: ``
warn: multi-line comment: ``
warn: multi-line comment: ``
warn: multi-line comment: ``
warn: multi-line comment: ``
warn: variable `Image.extra` hides previous declaration
warn: variable `Window.closure` hides previous declaration
debug: inline file: `cmplGfx/lib.ci`
cmplGfx/lib.ci:3: debug: inline file: `cmplGfx/lib/rect.ci`
cmplGfx/lib.ci:4: debug: inline file: `cmplGfx/lib/color.ci`
cmplGfx/lib/color.ci:29: warn: adding implicit cast uint32(255: int32)
cmplGfx/lib/color.ci:29: warn: adding implicit cast int32(c: uint32)
cmplGfx/lib/color.ci:43: warn: adding implicit cast float32(255: int32)
cmplGfx/lib/color.ci:45: warn: adding implicit cast float64(255: int32)
cmplGfx/lib/color.ci:53: warn: adding implicit cast float32(255: int32)
cmplGfx/lib/color.ci:53: warn: adding implicit cast float32(255: int32)
cmplGfx/lib/color.ci:53: warn: adding implicit cast float32(255: int32)
cmplGfx/lib/color.ci:55: warn: adding implicit cast float64(255: int32)
cmplGfx/lib/color.ci:55: warn: adding implicit cast float64(255: int32)
cmplGfx/lib/color.ci:55: warn: adding implicit cast float64(255: int32)
cmplGfx/lib/color.ci:61: warn: adding implicit cast float32(255: int32)
cmplGfx/lib/color.ci:61: warn: adding implicit cast float32(255: int32)
cmplGfx/lib/color.ci:61: warn: adding implicit cast float32(255: int32)
cmplGfx/lib/color.ci:61: warn: adding implicit cast float32(255: int32)
cmplGfx/lib/color.ci:63: warn: adding implicit cast float64(255: int32)
cmplGfx/lib/color.ci:63: warn: adding implicit cast float64(255: int32)
cmplGfx/lib/color.ci:63: warn: adding implicit cast float64(255: int32)
cmplGfx/lib/color.ci:63: warn: adding implicit cast float64(255: int32)
cmplGfx/lib/color.ci:69: warn: adding implicit cast uint32(255: int32)
cmplGfx/lib/color.ci:71: warn: adding implicit cast uint32(255: int32)
cmplGfx/lib/color.ci:73: warn: adding implicit cast uint32(255: int32)
cmplGfx/lib/color.ci:121: warn: adding implicit cast uint32(1: int32)
cmplGfx/lib/color.ci:121: warn: adding implicit cast int32((b - a + (1)): uint32)
cmplGfx/lib/color.ci:121: warn: adding implicit cast uint32((t * ((b - a + (1))) >> 8): int32)
cmplGfx/lib/color.ci:123: warn: adding implicit cast uint32(1: int32)
cmplGfx/lib/color.ci:123: warn: adding implicit cast int32((b - a + (1)): uint32)
cmplGfx/lib/color.ci:123: warn: adding implicit cast uint32((t * ((b - a + (1))) >> 16): int32)
cmplGfx/lib/color.ci:129: warn: adding implicit cast uint32(1: int32)
cmplGfx/lib/color.ci:129: warn: adding implicit cast uint32(1: int32)
cmplGfx/lib/color.ci:130: warn: adding implicit cast int32(lut.length: uint32)
cmplGfx/lib/color.ci:138: warn: adding implicit cast uint32(a << 24 | r << 16 | g << 8 | b: int32)
cmplGfx/lib/color.ci:145: warn: adding implicit cast int32(sat_u8(hardness < 0 ? -hardness : hardness): uint32)
cmplGfx/lib/color.ci:146: warn: adding implicit cast int32(lut.length: uint32)
cmplGfx/lib/color.ci:147: warn: adding implicit cast uint32(1: int32)
cmplGfx/lib/color.ci:147: warn: adding implicit cast int32((lut.length - (1)): uint32)
cmplGfx/lib/color.ci:150: warn: adding implicit cast int32(lut[i]: uint32)
cmplGfx/lib/color.ci:150: warn: adding implicit cast uint32(255 - (255 - (lut[i])) * -alpha / 255: int32)
cmplGfx/lib/color.ci:152: warn: adding implicit cast uint32(alpha: int32)
cmplGfx/lib/color.ci:152: warn: adding implicit cast uint32(255: int32)
cmplGfx/lib/color.ci:152: warn: adding implicit cast int32(lut[i] * (alpha) / (255): uint32)
cmplGfx/lib/color.ci:152: warn: adding implicit cast uint32(255 - (lut[i] * (alpha) / (255)): int32)
cmplGfx/lib/color.ci:156: warn: adding implicit cast uint32(1: int32)
cmplGfx/lib/color.ci:157: warn: variable `alphaLut.mid` hides previous declaration
cmplGfx/lib/color.ci:144: warn: previously defined here as `alphaLut.mid`
cmplGfx/lib/color.ci:157: warn: adding implicit cast uint32(2: int32)
cmplGfx/lib/color.ci:163: warn: adding implicit cast uint32(i: int32)
cmplGfx/lib/color.ci:163: warn: adding implicit cast uint32(1: int32)
cmplGfx/lib/color.ci:168: warn: adding implicit cast pointer(typename(vec4f): typename)
cmplGfx/lib/color.ci:171: warn: adding implicit cast float32(rch(rgb): int32)
cmplGfx/lib/color.ci:171: warn: adding implicit cast float32(gch(rgb): int32)
cmplGfx/lib/color.ci:171: warn: adding implicit cast float32(bch(rgb): int32)
cmplGfx/lib/color.ci:171: warn: adding implicit cast float32(ach(rgb): int32)
cmplGfx/lib/color.ci:179: debug: inline file: `cmplGfx/lib/color.hsl.ci`
cmplGfx/lib/color.hsl.ci:12: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/color.hsl.ci:14: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/color.hsl.ci:17: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/color.hsl.ci:18: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/color.hsl.ci:28: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/color.hsl.ci:31: warn: adding implicit cast float32(6: int32)
cmplGfx/lib/color.hsl.ci:31: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/color.hsl.ci:32: warn: adding implicit cast float32(6: int32)
cmplGfx/lib/color.hsl.ci:32: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/color.hsl.ci:33: warn: adding implicit cast float32(6: int32)
cmplGfx/lib/color.hsl.ci:33: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/color.hsl.ci:40: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/color.hsl.ci:43: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/color.hsl.ci:46: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/color.hsl.ci:47: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/color.hsl.ci:49: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/color.hsl.ci:50: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/color.hsl.ci:63: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/color.hsl.ci:64: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/color.hsl.ci:66: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/color.hsl.ci:67: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/color.hsl.ci:70: warn: adding implicit cast float32(6: int32)
cmplGfx/lib/color.hsl.ci:71: warn: adding implicit cast float32(6: int32)
cmplGfx/lib/color.hsl.ci:73: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/color.hsl.ci:76: warn: adding implicit cast float32(3: int32)
cmplGfx/lib/color.hsl.ci:77: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/color.hsl.ci:77: warn: adding implicit cast float32(6: int32)
cmplGfx/lib/color.hsl.ci:82: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/color.hsl.ci:88: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/color.hsl.ci:94: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/color.hsl.ci:96: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/color.hsl.ci:98: warn: adding implicit cast float32(1: int32)
cmplGfx/lib.ci:5: debug: inline file: `cmplGfx/lib/image.ci`
cmplGfx/lib/image.ci:6: warn: adding implicit cast pointer(typename(Image.openPng): typename)
cmplGfx/lib/image.ci:11: warn: adding implicit cast pointer(typename(Image.openJpg): typename)
cmplGfx/lib/image.ci:19: warn: adding implicit cast pointer(typename(Image.openBmp): typename)
cmplGfx/lib.ci:6: debug: inline file: `cmplGfx/lib/image.draw.ci`
cmplGfx/lib/image.draw.ci:1: warn: adding implicit cast pointer(typename(drawAntiAliased): typename)
cmplGfx/lib/image.draw.ci:5: debug: inline file: `cmplGfx/lib/image.draw.rect.ci`
cmplGfx/lib/image.draw.rect.ci:3: warn: adding implicit cast pointer(typename(Image.fillRect): typename)
cmplGfx/lib/image.draw.rect.ci:3: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/image.draw.ci:6: debug: inline file: `cmplGfx/lib/image.draw.rrect.ci`
cmplGfx/lib/image.draw.rrect.ci:37: warn: adding implicit cast int64(ry: int32)
cmplGfx/lib/image.draw.rrect.ci:39: warn: adding implicit cast int64(2: int32)
cmplGfx/lib/image.draw.rrect.ci:46: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/image.draw.rrect.ci:51: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/image.draw.rrect.ci:96: warn: adding implicit cast int64(ry: int32)
cmplGfx/lib/image.draw.rrect.ci:98: warn: adding implicit cast int64(2: int32)
cmplGfx/lib/image.draw.rrect.ci:109: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/image.draw.rrect.ci:114: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/image.draw.ci:7: debug: inline file: `cmplGfx/lib/image.draw.oval.ci`
cmplGfx/lib/image.draw.ci:8: debug: inline file: `cmplGfx/lib/image.draw.line.ci`
cmplGfx/lib/image.draw.line.ci:34: warn: adding implicit cast int32(alpha: uint32)
cmplGfx/lib/image.draw.line.ci:93: warn: adding implicit cast float64(128: int32)
cmplGfx/lib/image.draw.line.ci:94: warn: adding implicit cast float64(1: int32)
cmplGfx/lib/image.draw.line.ci:95: warn: adding implicit cast float64(px_2: int32)
cmplGfx/lib/image.draw.line.ci:95: warn: adding implicit cast float64(px_1: int32)
cmplGfx/lib/image.draw.line.ci:95: warn: adding implicit cast float64(px_0: int32)
cmplGfx/lib/image.draw.line.ci:95: warn: adding implicit cast int32(((px_2) * t + (px_1)) * t + (px_0): float64)
cmplGfx/lib/image.draw.line.ci:96: warn: adding implicit cast float64(py_2: int32)
cmplGfx/lib/image.draw.line.ci:96: warn: adding implicit cast float64(py_1: int32)
cmplGfx/lib/image.draw.line.ci:96: warn: adding implicit cast float64(py_0: int32)
cmplGfx/lib/image.draw.line.ci:96: warn: adding implicit cast int32(((py_2) * t + (py_1)) * t + (py_0): float64)
cmplGfx/lib/image.draw.line.ci:115: warn: adding implicit cast float64(128: int32)
cmplGfx/lib/image.draw.line.ci:116: warn: adding implicit cast float64(1: int32)
cmplGfx/lib/image.draw.line.ci:117: warn: adding implicit cast float64(px_3: int32)
cmplGfx/lib/image.draw.line.ci:117: warn: adding implicit cast float64(px_2: int32)
cmplGfx/lib/image.draw.line.ci:117: warn: adding implicit cast float64(px_1: int32)
cmplGfx/lib/image.draw.line.ci:117: warn: adding implicit cast float64(px_0: int32)
cmplGfx/lib/image.draw.line.ci:117: warn: adding implicit cast int32((((px_3) * t + (px_2)) * t + (px_1)) * t + (px_0): float64)
cmplGfx/lib/image.draw.line.ci:118: warn: adding implicit cast float64(py_3: int32)
cmplGfx/lib/image.draw.line.ci:118: warn: adding implicit cast float64(py_2: int32)
cmplGfx/lib/image.draw.line.ci:118: warn: adding implicit cast float64(py_1: int32)
cmplGfx/lib/image.draw.line.ci:118: warn: adding implicit cast float64(py_0: int32)
cmplGfx/lib/image.draw.line.ci:118: warn: adding implicit cast int32((((py_3) * t + (py_2)) * t + (py_1)) * t + (py_0): float64)
cmplGfx/lib.ci:7: debug: inline file: `cmplGfx/lib/image.blend.ci`
cmplGfx/lib/image.blend.ci:2: warn: variable `extra` hides previous declaration
cmplGfx/lib/image.blend.ci:2: warn: previously defined here as `extra`
cmplGfx/lib/image.blend.ci:3: warn: adding implicit cast pointer(typename(Image.blend): typename)
cmplGfx/lib/image.blend.ci:3: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/image.blend.ci:9: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:10: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:11: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:12: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:34: warn: adding implicit cast pointer(blend: function)
cmplGfx/lib/image.blend.ci:54: warn: adding implicit cast pointer(typename(Image.blend.blendVec4f): typename)
cmplGfx/lib/image.blend.ci:54: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/image.blend.ci:60: warn: adding implicit cast pointer(blend: function)
cmplGfx/lib/image.blend.ci:68: warn: adding implicit cast pointer(typename(Image.blend.color): typename)
cmplGfx/lib/image.blend.ci:68: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/image.blend.ci:69: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:69: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:74: warn: adding implicit cast uint8(mix_s8(alpha, bch(color), bch(base)): int32)
cmplGfx/lib/image.blend.ci:75: warn: adding implicit cast uint8(mix_s8(alpha, gch(color), gch(base)): int32)
cmplGfx/lib/image.blend.ci:76: warn: adding implicit cast uint8(mix_s8(alpha, rch(color), rch(base)): int32)
cmplGfx/lib/image.blend.ci:77: warn: adding implicit cast uint8(alpha: int32)
cmplGfx/lib/image.blend.ci:80: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:80: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:85: warn: adding implicit cast pointer(typename(Image.blend.alpha): typename)
cmplGfx/lib/image.blend.ci:85: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/image.blend.ci:91: warn: adding implicit cast uint8(sat_s8(mix_s8(alpha, bch(base), bch(with))): uint32)
cmplGfx/lib/image.blend.ci:92: warn: adding implicit cast uint8(sat_s8(mix_s8(alpha, gch(base), gch(with))): uint32)
cmplGfx/lib/image.blend.ci:93: warn: adding implicit cast uint8(sat_s8(mix_s8(alpha, rch(base), rch(with))): uint32)
cmplGfx/lib/image.blend.ci:94: warn: adding implicit cast uint8(alpha: int32)
cmplGfx/lib/image.blend.ci:102: warn: adding implicit cast pointer(typename(Image.blend.dstAlpha): typename)
cmplGfx/lib/image.blend.ci:102: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/image.blend.ci:106: warn: variable `blendDstAlpha.null` hides previous declaration
cmplGfx/lib/image.blend.ci:109: warn: adding implicit cast uint8(mix_s8(alpha, bch(base), bch(with)): int32)
cmplGfx/lib/image.blend.ci:110: warn: adding implicit cast uint8(mix_s8(alpha, gch(base), gch(with)): int32)
cmplGfx/lib/image.blend.ci:111: warn: adding implicit cast uint8(mix_s8(alpha, rch(base), rch(with)): int32)
cmplGfx/lib/image.blend.ci:112: warn: adding implicit cast uint8(alpha: int32)
cmplGfx/lib/image.blend.ci:133: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:134: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:135: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:136: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:161: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:162: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:163: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:164: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.blend.ci:173: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.blend.ci:180: warn: adding implicit cast float32(y: int32)
cmplGfx/lib/image.blend.ci:182: warn: adding implicit cast float32(x: int32)
cmplGfx/lib.ci:8: debug: inline file: `cmplGfx/lib/image.transform.ci`
cmplGfx/lib/image.transform.ci:3: warn: adding implicit cast pointer(typename(Image.transform): typename)
cmplGfx/lib/image.transform.ci:3: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/image.transform.ci:11: warn: adding implicit cast pointer(rect: Rect)
cmplGfx/lib/image.transform.ci:12: warn: adding implicit cast pointer(rect: Rect)
cmplGfx/lib/image.transform.ci:13: warn: adding implicit cast pointer(rect: Rect)
cmplGfx/lib/image.transform.ci:14: warn: adding implicit cast pointer(rect: Rect)
cmplGfx/lib/image.transform.ci:17: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.transform.ci:18: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.transform.ci:19: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.transform.ci:20: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/image.transform.ci:22: warn: adding implicit cast pointer(mat: mat4f)
cmplGfx/lib/image.transform.ci:24: warn: adding implicit cast float32(width(dRec): int32)
cmplGfx/lib/image.transform.ci:25: warn: adding implicit cast float32(height(dRec): int32)
cmplGfx/lib/image.transform.ci:88: warn: adding implicit cast float64(width: int32)
cmplGfx/lib/image.transform.ci:89: warn: adding implicit cast float64(height: int32)
cmplGfx/lib/image.transform.ci:97: warn: adding implicit cast float64(width: int32)
cmplGfx/lib/image.transform.ci:100: warn: adding implicit cast float64(height: int32)
cmplGfx/lib/image.transform.ci:109: warn: adding implicit cast float64(Image.width(image): int32)
cmplGfx/lib/image.transform.ci:109: warn: adding implicit cast float64(width: int32)
cmplGfx/lib/image.transform.ci:109: warn: adding implicit cast float64(2: int32)
cmplGfx/lib/image.transform.ci:112: warn: adding implicit cast float64(Image.width(image): int32)
cmplGfx/lib/image.transform.ci:112: warn: adding implicit cast float64(width: int32)
cmplGfx/lib/image.transform.ci:117: warn: adding implicit cast float64(Image.height(image): int32)
cmplGfx/lib/image.transform.ci:117: warn: adding implicit cast float64(height: int32)
cmplGfx/lib/image.transform.ci:117: warn: adding implicit cast float64(2: int32)
cmplGfx/lib/image.transform.ci:120: warn: adding implicit cast float64(Image.height(image): int32)
cmplGfx/lib/image.transform.ci:120: warn: adding implicit cast float64(height: int32)
cmplGfx/lib/image.transform.ci:124: warn: adding implicit cast float64(1: int32)
cmplGfx/lib/image.transform.ci:125: warn: adding implicit cast float64(1: int32)
cmplGfx/lib/image.transform.ci:126: warn: adding implicit cast float64(1: int32)
cmplGfx/lib/image.transform.ci:124: warn: adding implicit cast float32((1) / scale: float64)
cmplGfx/lib/image.transform.ci:124: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:124: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:124: warn: adding implicit cast float32(-tx / scale: float64)
cmplGfx/lib/image.transform.ci:125: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:125: warn: adding implicit cast float32((1) / scale: float64)
cmplGfx/lib/image.transform.ci:125: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:125: warn: adding implicit cast float32(-ty / scale: float64)
cmplGfx/lib/image.transform.ci:126: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:126: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:126: warn: adding implicit cast float32((1) / scale: float64)
cmplGfx/lib/image.transform.ci:126: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:127: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:127: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:127: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/image.transform.ci:127: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/image.transform.ci:131: warn: adding implicit cast bool(align & highRes: int32)
cmplGfx/lib.ci:10: debug: inline file: `cmplGfx/lib/image.blur.ci`
cmplGfx/lib/image.blur.ci:3: warn: adding implicit cast pointer(typename(Image.blur): typename)
cmplGfx/lib/image.blur.ci:3: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/image.blur.ci:26: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/image.blur.ci:29: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/image.blur.ci:36: warn: adding implicit cast float64(65536: int32)
cmplGfx/lib/image.blur.ci:36: warn: adding implicit cast int32((65536) * (kernelFlt[i] / kernelSum): float64)
cmplGfx/lib.ci:12: debug: inline file: `cmplGfx/lib/color.lookup.ci`
cmplGfx/lib/color.lookup.ci:3: warn: adding implicit cast pointer(typename(Image.colorMap): typename)
cmplGfx/lib/color.lookup.ci:3: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/color.lookup.ci:11: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/color.lookup.ci:12: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/color.lookup.ci:13: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/color.lookup.ci:14: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/color.lookup.ci:47: warn: adding implicit cast float64((1 << fxpBits): int32)
cmplGfx/lib/color.lookup.ci:72: warn: adding implicit cast uint8(sat_s8((l * luv2rgb[0] + u * luv2rgb[1] + v * luv2rgb[2]) >> fxpBits): uint32)
cmplGfx/lib/color.lookup.ci:73: warn: adding implicit cast uint8(sat_s8((l * luv2rgb[4] + u * luv2rgb[5] + v * luv2rgb[6]) >> fxpBits): uint32)
cmplGfx/lib/color.lookup.ci:74: warn: adding implicit cast uint8(sat_s8((l * luv2rgb[8] + u * luv2rgb[9] + v * luv2rgb[10]) >> fxpBits): uint32)
cmplGfx/lib.ci:13: debug: inline file: `cmplGfx/lib/color.matrix.ci`
cmplGfx/lib/color.matrix.ci:3: warn: adding implicit cast pointer(typename(Image.colorMat): typename)
cmplGfx/lib/color.matrix.ci:3: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplGfx/lib/color.matrix.ci:10: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/color.matrix.ci:11: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/color.matrix.ci:12: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/color.matrix.ci:13: warn: adding implicit cast pointer(roi: Rect)
cmplGfx/lib/color.matrix.ci:20: warn: adding implicit cast float32(65536: int32)
cmplGfx/lib/color.matrix.ci:21: warn: adding implicit cast float32(65536: int32)
cmplGfx/lib/color.matrix.ci:22: warn: adding implicit cast float32(65536: int32)
cmplGfx/lib/color.matrix.ci:23: warn: adding implicit cast float32(256 * 65536: int32)
cmplGfx/lib/color.matrix.ci:25: warn: adding implicit cast float32(65536: int32)
cmplGfx/lib/color.matrix.ci:26: warn: adding implicit cast float32(65536: int32)
cmplGfx/lib/color.matrix.ci:27: warn: adding implicit cast float32(65536: int32)
cmplGfx/lib/color.matrix.ci:28: warn: adding implicit cast float32(256 * 65536: int32)
cmplGfx/lib/color.matrix.ci:30: warn: adding implicit cast float32(65536: int32)
cmplGfx/lib/color.matrix.ci:31: warn: adding implicit cast float32(65536: int32)
cmplGfx/lib/color.matrix.ci:32: warn: adding implicit cast float32(65536: int32)
cmplGfx/lib/color.matrix.ci:33: warn: adding implicit cast float32(256 * 65536: int32)
cmplGfx/lib/color.matrix.ci:41: warn: adding implicit cast uint8(sat_s8((r * m00 + g * m01 + b * m02 + m03) >> 16): uint32)
cmplGfx/lib/color.matrix.ci:42: warn: adding implicit cast uint8(sat_s8((r * m10 + g * m11 + b * m12 + m13) >> 16): uint32)
cmplGfx/lib/color.matrix.ci:43: warn: adding implicit cast uint8(sat_s8((r * m20 + g * m21 + b * m22 + m23) >> 16): uint32)
cmplGfx/lib.ci:15: debug: inline file: `cmplGfx/lib/mesh.ci`
cmplGfx/lib.ci:16: debug: inline file: `cmplGfx/lib/camera.ci`
cmplGfx/lib/camera.ci:17: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/camera.ci:20: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/camera.ci:21: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/camera.ci:22: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/camera.ci:28: warn: adding implicit cast float32(Math.tan(Math.radians(fov)): float64)
cmplGfx/lib/camera.ci:34: warn: adding implicit cast float32(-2: int32)
cmplGfx/lib/camera.ci:73: warn: adding implicit cast float32(0: int32)
cmplGfx/lib.ci:18: debug: inline file: `cmplGfx/lib/window.ci`
cmplGfx/lib/window.ci:2: warn: Extending static namespace: Window
cmplGfx/lib/window.ci:6: warn: adding implicit cast float64(1000: int32)
cmplGfx/lib/window.ci:10: warn: adding implicit cast pointer(onEvent: function)
cmplGfx/lib/window.ci:29: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:29: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:33: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:33: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:35: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:87: warn: padding `Window.show.Data.offs` with 7 bytes: (1 -> 8)
cmplGfx/lib/window.ci:96: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:96: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:100: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:103: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:104: warn: adding implicit cast int32(' ': char)
cmplGfx/lib/window.ci:107: warn: adding implicit cast float32((now - start): int64)
cmplGfx/lib/window.ci:113: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:116: warn: adding implicit cast int32('S': char)
cmplGfx/lib/window.ci:123: warn: adding implicit cast float32((System.millis() - start): int64)
cmplGfx/lib/window.ci:130: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/window.ci:140: warn: adding implicit cast float32(width: int32)
cmplGfx/lib/window.ci:151: warn: adding implicit cast float32(width: int32)
cmplGfx/lib/window.ci:148: debug: using default field initializer: Window.show.Data.lerp := true
cmplGfx/lib/window.ci:148: debug: using default field initializer: Window.show.Data.fpsCount := 0
cmplGfx/lib/window.ci:148: debug: using default field initializer: Window.show.Data.fpsTime := 0
cmplGfx/lib/window.ci:91: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/window.ci:171: warn: padding `Window.show.Data.offs` with 4 bytes: (20 -> 24)
cmplGfx/lib/window.ci:166: warn: padding `Window.show.Data` with 4 bytes: (164 -> 168)
cmplGfx/lib/window.ci:209: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/window.ci:210: warn: adding implicit cast float32(5: int32)
cmplGfx/lib/window.ci:212: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:212: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:217: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:220: warn: adding implicit cast float32(dx: int32)
cmplGfx/lib/window.ci:221: warn: adding implicit cast float32(dy: int32)
cmplGfx/lib/window.ci:227: warn: adding implicit cast float32(-dx: int32)
cmplGfx/lib/window.ci:228: warn: adding implicit cast float32(-dy: int32)
cmplGfx/lib/window.ci:233: warn: adding implicit cast float32(dy: int32)
cmplGfx/lib/window.ci:238: warn: adding implicit cast float32(-dx: int32)
cmplGfx/lib/window.ci:239: warn: adding implicit cast float32(dy: int32)
cmplGfx/lib/window.ci:245: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:245: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:250: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:252: warn: adding implicit cast float32(ey: int32)
cmplGfx/lib/window.ci:256: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:256: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:260: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:261: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:265: warn: adding implicit cast int32('w': char)
cmplGfx/lib/window.ci:267: warn: adding implicit cast int64(ey: int32)
cmplGfx/lib/window.ci:271: warn: adding implicit cast int32('s': char)
cmplGfx/lib/window.ci:273: warn: adding implicit cast int64(ey: int32)
cmplGfx/lib/window.ci:277: warn: adding implicit cast int32('a': char)
cmplGfx/lib/window.ci:279: warn: adding implicit cast int64(ey: int32)
cmplGfx/lib/window.ci:283: warn: adding implicit cast int32('d': char)
cmplGfx/lib/window.ci:285: warn: adding implicit cast int64(ey: int32)
cmplGfx/lib/window.ci:290: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:292: warn: adding implicit cast int64(ey: int32)
cmplGfx/lib/window.ci:296: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:298: warn: adding implicit cast int64(ey: int32)
cmplGfx/lib/window.ci:302: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:304: warn: adding implicit cast int64(ey: int32)
cmplGfx/lib/window.ci:308: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:310: warn: adding implicit cast int64(ey: int32)
cmplGfx/lib/window.ci:315: warn: adding implicit cast int32('l': char)
cmplGfx/lib/window.ci:316: warn: adding implicit cast int64(data.mode: int32)
cmplGfx/lib/window.ci:316: warn: adding implicit cast int32((data.mode) ^ Mesh.useLights: int64)
cmplGfx/lib/window.ci:318: warn: adding implicit cast int32('b': char)
cmplGfx/lib/window.ci:319: warn: adding implicit cast int64(data.mode: int32)
cmplGfx/lib/window.ci:319: warn: adding implicit cast int32((data.mode) ^ Mesh.drawBounds: int64)
cmplGfx/lib/window.ci:321: warn: adding implicit cast int32('0': char)
cmplGfx/lib/window.ci:324: warn: adding implicit cast int32('1': char)
cmplGfx/lib/window.ci:327: warn: adding implicit cast int32('2': char)
cmplGfx/lib/window.ci:330: warn: adding implicit cast int32('3': char)
cmplGfx/lib/window.ci:333: warn: adding implicit cast int32('t': char)
cmplGfx/lib/window.ci:334: warn: adding implicit cast int64(data.mode: int32)
cmplGfx/lib/window.ci:334: warn: adding implicit cast int32((data.mode) ^ Mesh.useTexture: int64)
cmplGfx/lib/window.ci:336: warn: adding implicit cast int32('/': char)
cmplGfx/lib/window.ci:339: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/window.ci:344: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/window.ci:346: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/window.ci:346: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/window.ci:346: warn: adding implicit cast float32(2: int32)
cmplGfx/lib/window.ci:346: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/window.ci:347: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/window.ci:347: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/window.ci:347: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/window.ci:347: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/window.ci:348: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/window.ci:348: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/window.ci:348: warn: adding implicit cast float32(0: int32)
cmplGfx/lib/window.ci:348: warn: adding implicit cast float32(1: int32)
cmplGfx/lib/window.ci:368: warn: adding implicit cast int64(1000: int32)
cmplGfx/lib/window.ci:379: warn: adding implicit cast float32(w: int32)
cmplGfx/lib/window.ci:377: warn: adding implicit cast int32(Mesh.useLights | Mesh.cullBack | Mesh.drawFill: int64)
cmplGfx/lib/window.ci:380: debug: using default field initializer: Camera.position := vec4f(0, 0, 0, 1)
cmplGfx/lib/window.ci:380: debug: using default field initializer: Camera.forward := vec4f(0, 0, 0, 1)
cmplGfx/lib/window.ci:380: debug: using default field initializer: Camera.right := vec4f(0, 0, 0, 1)
cmplGfx/lib/window.ci:380: debug: using default field initializer: Camera.up := vec4f(0, 1, 0, 1)
cmplGfx/lib/window.ci:376: debug: using default field initializer: Window.show.Data.fpsCount := 0
cmplGfx/lib/window.ci:376: debug: using default field initializer: Window.show.Data.fpsShow := 0
cmplGfx/lib/window.ci:376: debug: using default field initializer: Window.show.Data.fpsTime := 0
cmplGfx/lib/window.ci:169: warn: adding implicit cast int64(0: int32)
cmplGfx/lib.ci:20: debug: inline file: `cmplGfx/lib/micro.ui.ci`
cmplGfx/lib/micro.ui.ci:1: debug: inline file: `cmplGfx/lib/micro.ui.core.ci`
cmplGfx/lib/micro.ui.core.ci:2: warn: padding `Style` with 4 bytes: (52 -> 56)
cmplGfx/lib/micro.ui.core.ci:151: warn: padding `KeyEvent` with 4 bytes: (12 -> 16)
cmplGfx/lib/micro.ui.core.ci:201: warn: adding implicit cast bool(event.dx: int32)
cmplGfx/lib/micro.ui.core.ci:201: warn: adding implicit cast bool(event.dy: int32)
cmplGfx/lib/micro.ui.core.ci:206: warn: adding implicit cast bool(event.dx: int32)
cmplGfx/lib/micro.ui.core.ci:206: warn: adding implicit cast bool(event.dy: int32)
cmplGfx/lib/micro.ui.core.ci:216: warn: adding implicit cast bool(event.dx: int32)
cmplGfx/lib/micro.ui.core.ci:216: warn: adding implicit cast bool(event.dy: int32)
cmplGfx/lib/micro.ui.core.ci:166: warn: padding `TouchEvent` with 4 bytes: (28 -> 32)
cmplGfx/lib/micro.ui.core.ci:255: warn: Creating virtual method for: View.onClick(this: View): bool
cmplGfx/lib/micro.ui.core.ci:260: warn: Creating virtual method for: View.onReset(this: View): bool
cmplGfx/lib/micro.ui.core.ci:265: warn: Creating virtual method for: View.onCreate(this: View, parent: View): void
cmplGfx/lib/micro.ui.core.ci:266: warn: adding implicit cast pointer(this.parent: View)
cmplGfx/lib/micro.ui.core.ci:268: warn: adding implicit cast pointer(this.style: Style)
cmplGfx/lib/micro.ui.core.ci:269: warn: adding implicit cast pointer(parent.style: Style)
cmplGfx/lib/micro.ui.core.ci:270: warn: statement expected, got: `this.style := emit(pointer(parent.style))`
cmplGfx/lib/micro.ui.core.ci:275: warn: Creating virtual method for: View.onDestroy(this: View): void
cmplGfx/lib/micro.ui.core.ci:278: warn: Creating virtual method for: View.onKeyEvent(this: View, event: KeyEvent): bool
cmplGfx/lib/micro.ui.core.ci:286: warn: adding implicit cast int32(' ': char)
cmplGfx/lib/micro.ui.core.ci:290: warn: adding implicit cast int64(event.key: int32)
cmplGfx/lib/micro.ui.core.ci:298: warn: Creating virtual method for: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
cmplGfx/lib/micro.ui.core.ci:331: warn: Creating virtual method for: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.core.ci:355: warn: adding implicit cast pointer(this.parent.style: Style)
cmplGfx/lib/micro.ui.core.ci:365: warn: adding implicit cast pointer(text: char[*])
cmplGfx/lib/micro.ui.core.ci:371: warn: adding implicit cast pointer(value: char[*])
cmplGfx/lib/micro.ui.core.ci:241: warn: padding `View.parent` with 2 bytes: (14 -> 16)
cmplGfx/lib/micro.ui.core.ci:431: warn: adding implicit cast bool(mode & Style.hovered: int32)
warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.core.ci:439: warn: adding implicit cast bool(mode & Style.pressed: int32)
warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.core.ci:447: warn: adding implicit cast bool(mode & Style.focused: int32)
warn: adding implicit cast pointer(layout: Layout)
warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.core.ci:466: warn: adding implicit cast pointer(child: View)
warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.core.ci:481: warn: adding implicit cast pointer(child: View)
cmplGfx/lib/micro.ui.core.ci:490: warn: adding implicit cast pointer(focus: View)
warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.core.ci:522: warn: adding implicit cast Layout.Item[*](pointer.alloc(null, this.itemCapacity * sizeof(Item)): pointer)
cmplGfx/lib/micro.ui.core.ci:532: warn: adding implicit cast pointer(this.separator: View)
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.width := -5
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.height := -5
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.style := null
cmplGfx/lib/micro.ui.core.ci:244: warn: adding implicit cast Style(null: pointer)
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.data := null
cmplGfx/lib/micro.ui.core.ci:247: warn: adding implicit cast variant(null: pointer)
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.core.ci:535: debug: using default field initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.core.ci:544: warn: adding implicit cast int32(views.length: uint32)
cmplGfx/lib/micro.ui.core.ci:554: warn: adding implicit cast int32(views.length: uint32)
cmplGfx/lib/micro.ui.core.ci:558: warn: adding implicit cast pointer(item.view: View)
cmplGfx/lib/micro.ui.core.ci:593: warn: variable `Layout.onClick(this: Layout): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:255: warn: previously defined here as `View.onClick(this: View): bool`
cmplGfx/lib/micro.ui.core.ci:593: warn: Overriding virtual function: View.onClick(this: View): bool
cmplGfx/lib/micro.ui.core.ci:598: warn: variable `Layout.onReset(this: Layout): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:260: warn: previously defined here as `View.onReset(this: View): bool`
cmplGfx/lib/micro.ui.core.ci:598: warn: Overriding virtual function: View.onReset(this: View): bool
cmplGfx/lib/micro.ui.core.ci:609: warn: variable `Layout.onCreate(this: Layout, parent: View): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:265: warn: previously defined here as `View.onCreate(this: View, parent: View): void`
cmplGfx/lib/micro.ui.core.ci:609: warn: Overriding virtual function: View.onCreate(this: View, parent: View): void
cmplGfx/lib/micro.ui.core.ci:610: warn: adding implicit cast pointer(this.parent: View)
cmplGfx/lib/micro.ui.core.ci:618: warn: variable `Layout.onDestroy(this: Layout): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:275: warn: previously defined here as `View.onDestroy(this: View): void`
cmplGfx/lib/micro.ui.core.ci:618: warn: Overriding virtual function: View.onDestroy(this: View): void
cmplGfx/lib/micro.ui.core.ci:628: warn: variable `Layout.onKeyEvent(this: Layout, event: KeyEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:278: warn: previously defined here as `View.onKeyEvent(this: View, event: KeyEvent): bool`
cmplGfx/lib/micro.ui.core.ci:628: warn: Overriding virtual function: View.onKeyEvent(this: View, event: KeyEvent): bool
cmplGfx/lib/micro.ui.core.ci:643: warn: variable `Layout.onTouchEvent(this: Layout, rect: Rect, event: TouchEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:298: warn: previously defined here as `View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool`
cmplGfx/lib/micro.ui.core.ci:643: warn: Overriding virtual function: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
cmplGfx/lib/micro.ui.core.ci:661: warn: adding implicit cast bool(event.dx: int32)
cmplGfx/lib/micro.ui.core.ci:661: warn: adding implicit cast bool(event.dy: int32)
cmplGfx/lib/micro.ui.core.ci:661: warn: adding implicit cast bool(event.button: int32)
warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.core.ci:749: warn: variable `Layout.onMeasure(this: Layout, measured: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:331: warn: previously defined here as `View.onMeasure(this: View, rect: Rect): bool`
cmplGfx/lib/micro.ui.core.ci:749: warn: Overriding virtual function: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.core.ci:803: warn: Creating virtual method for: Layout.onLayout(this: Layout, measured: Rect): void
warn: adding implicit cast pointer(layout: Layout)
warn: adding implicit cast pointer(layout: Layout)
warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.core.ci:1029: warn: Overriding virtual function: View.onDraw(this: View, offs: Image, rect: Rect): void
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.onLayout(this: Layout, measured: Rect): void := onLayout
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.paddingBottom := 0
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.paddingRight := 0
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.paddingLeft := 0
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.paddingTop := 0
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.focusedIndex := -1
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.pressedIndex := -1
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.hoveredIndex := -1
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.itemCapacity := 0
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.itemCount := 0
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.items := null
cmplGfx/lib/micro.ui.core.ci:398: warn: adding implicit cast Layout.Item[*](null: pointer)
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: Layout.separator := null
cmplGfx/lib/micro.ui.core.ci:396: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: View.width := -5
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: View.height := -5
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: View.enabled := true
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: View.focusable := true
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: View.style := null
cmplGfx/lib/micro.ui.core.ci:244: warn: adding implicit cast Style(null: pointer)
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default field initializer: View.data := null
cmplGfx/lib/micro.ui.core.ci:247: warn: adding implicit cast variant(null: pointer)
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default type initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default type initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default type initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default type initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default type initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default type initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default type initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.core.ci:1056: debug: using default type initializer: View.onDraw(this: View, offs: Image, rect: Rect): void := onDraw
cmplGfx/lib/micro.ui.core.ci:1059: warn: adding implicit cast uint32(0: int32)
cmplGfx/lib/micro.ui.core.ci:1093: warn: adding implicit cast pointer(view: View)
cmplGfx/lib/micro.ui.core.ci:1107: warn: adding implicit cast pointer(this: Layout)
cmplGfx/lib/micro.ui.core.ci:1150: warn: variable `Widget.addItems(this: Widget, align: int32, views: View[]): Widget` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:529: warn: previously defined here as `Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout`
cmplGfx/lib/micro.ui.core.ci:1168: warn: variable `Widget.padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:584: warn: previously defined here as `Layout.padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout`
cmplGfx/lib/micro.ui.core.ci:1185: warn: variable `Widget.onCreate(this: Widget, parent: View): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:609: warn: previously defined here as `Layout.onCreate(this: Layout, parent: View): void`
cmplGfx/lib/micro.ui.core.ci:1185: warn: variable `Widget.onCreate(this: Widget, parent: View): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:265: warn: previously defined here as `View.onCreate(this: View, parent: View): void`
cmplGfx/lib/micro.ui.core.ci:1185: warn: Overriding virtual function: View.onCreate(this: View, parent: View): void
cmplGfx/lib/micro.ui.core.ci:1189: warn: adding implicit cast pointer(this.focus: View)
cmplGfx/lib/micro.ui.core.ci:1191: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.core.ci:1195: warn: variable `Widget.onKeyEvent(this: Widget, event: KeyEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:628: warn: previously defined here as `Layout.onKeyEvent(this: Layout, event: KeyEvent): bool`
cmplGfx/lib/micro.ui.core.ci:1195: warn: variable `Widget.onKeyEvent(this: Widget, event: KeyEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:278: warn: previously defined here as `View.onKeyEvent(this: View, event: KeyEvent): bool`
cmplGfx/lib/micro.ui.core.ci:1195: warn: Overriding virtual function: View.onKeyEvent(this: View, event: KeyEvent): bool
cmplGfx/lib/micro.ui.core.ci:1204: warn: adding implicit cast int64(event.key: int32)
cmplGfx/lib/micro.ui.core.ci:1204: warn: adding implicit cast int64(event.key: int32)
cmplGfx/lib/micro.ui.core.ci:1218: warn: variable `Widget.onMeasure(this: Widget, measured: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:749: warn: previously defined here as `Layout.onMeasure(this: Layout, measured: Rect): bool`
cmplGfx/lib/micro.ui.core.ci:1218: warn: variable `Widget.onMeasure(this: Widget, measured: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:331: warn: previously defined here as `View.onMeasure(this: View, rect: Rect): bool`
cmplGfx/lib/micro.ui.core.ci:1218: warn: Overriding virtual function: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.core.ci:1224: warn: variable `Widget.onDraw(this: Widget, offs: Image, rect: Rect): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:1029: warn: previously defined here as `Layout.onDraw(this: Layout, offs: Image, parent: Rect): void`
cmplGfx/lib/micro.ui.core.ci:1224: warn: Overriding virtual function: View.onDraw(this: View, offs: Image, rect: Rect): void
cmplGfx/lib/micro.ui.core.ci:1087: warn: padding `Widget.focus` with 2 bytes: (118 -> 120)
cmplGfx/lib/micro.ui.core.ci:1232: warn: adding implicit cast pointer(v: View)
warn: adding implicit cast pointer(w: Widget)
cmplGfx/lib/micro.ui.core.ci:1243: warn: Overwriting forward function: focus(view: View): void
warn: adding implicit cast pointer(child: Layout)
cmplGfx/lib/micro.ui.core.ci:1258: warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.core.ci:1266: warn: adding implicit cast pointer(focus: View)
cmplGfx/lib/micro.ui.core.ci:1273: debug: using default field initializer: Rect.x0 := 0
cmplGfx/lib/micro.ui.core.ci:1273: debug: using default field initializer: Rect.y0 := 0
cmplGfx/lib/micro.ui.core.ci:1273: debug: using default field initializer: Rect.x1 := 0
cmplGfx/lib/micro.ui.core.ci:1273: debug: using default field initializer: Rect.y1 := 0
cmplGfx/lib/micro.ui.core.ci:1283: warn: Overwriting forward function: invalidate(view: View, layout: bool): void
cmplGfx/lib/micro.ui.ci:8: warn: variable `Button.onMeasure(this: Button, rect: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:331: warn: previously defined here as `View.onMeasure(this: View, rect: Rect): bool`
cmplGfx/lib/micro.ui.ci:8: warn: Overriding virtual function: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.ci:14: warn: Overriding virtual function: View.onDraw(this: View, offs: Image, rect: Rect): void
cmplGfx/lib/micro.ui.ci:22: warn: adding implicit cast char[*]("off": .cstr)
cmplGfx/lib/micro.ui.ci:23: warn: adding implicit cast char[*]("on": .cstr)
cmplGfx/lib/micro.ui.ci:44: warn: Creating virtual method for: Switch.onUpdate(this: Switch, selected: int32): bool
cmplGfx/lib/micro.ui.ci:65: warn: variable `Switch.onReset(this: Switch): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:260: warn: previously defined here as `View.onReset(this: View): bool`
cmplGfx/lib/micro.ui.ci:65: warn: Overriding virtual function: View.onReset(this: View): bool
cmplGfx/lib/micro.ui.ci:69: warn: variable `Switch.onClick(this: Switch): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:255: warn: previously defined here as `View.onClick(this: View): bool`
cmplGfx/lib/micro.ui.ci:69: warn: Overriding virtual function: View.onClick(this: View): bool
cmplGfx/lib/micro.ui.ci:87: warn: variable `Switch.onCreate(this: Switch, parent: View): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:265: warn: previously defined here as `View.onCreate(this: View, parent: View): void`
cmplGfx/lib/micro.ui.ci:87: warn: Overriding virtual function: View.onCreate(this: View, parent: View): void
cmplGfx/lib/micro.ui.ci:96: warn: variable `Switch.onKeyEvent(this: Switch, event: KeyEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:278: warn: previously defined here as `View.onKeyEvent(this: View, event: KeyEvent): bool`
cmplGfx/lib/micro.ui.ci:96: warn: Overriding virtual function: View.onKeyEvent(this: View, event: KeyEvent): bool
cmplGfx/lib/micro.ui.ci:100: warn: adding implicit cast int32('+': char)
cmplGfx/lib/micro.ui.ci:100: warn: adding implicit cast int32('=': char)
cmplGfx/lib/micro.ui.ci:104: warn: adding implicit cast int32('-': char)
cmplGfx/lib/micro.ui.ci:104: warn: adding implicit cast int32('_': char)
cmplGfx/lib/micro.ui.ci:111: warn: variable `Switch.onTouchEvent(this: Switch, rect: Rect, event: TouchEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:298: warn: previously defined here as `View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool`
cmplGfx/lib/micro.ui.ci:111: warn: Overriding virtual function: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
cmplGfx/lib/micro.ui.ci:122: warn: variable `Switch.onMeasure(this: Switch, rect: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:331: warn: previously defined here as `View.onMeasure(this: View, rect: Rect): bool`
cmplGfx/lib/micro.ui.ci:122: warn: Overriding virtual function: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.ci:125: warn: adding implicit cast int32(this.states.length: uint32)
cmplGfx/lib/micro.ui.ci:126: debug: using default field initializer: Rect.x0 := 0
cmplGfx/lib/micro.ui.ci:126: debug: using default field initializer: Rect.y0 := 0
cmplGfx/lib/micro.ui.ci:126: debug: using default field initializer: Rect.x1 := 0
cmplGfx/lib/micro.ui.ci:126: debug: using default field initializer: Rect.y1 := 0
cmplGfx/lib/micro.ui.ci:133: warn: adding implicit cast uint32(0: int32)
cmplGfx/lib/micro.ui.ci:141: warn: Overriding virtual function: View.onDraw(this: View, offs: Image, rect: Rect): void
cmplGfx/lib/micro.ui.ci:144: warn: adding implicit cast uint32(0: int32)
cmplGfx/lib/micro.ui.ci:173: warn: adding implicit cast char[*](this.states[this.selected]: char[*])
cmplGfx/lib/micro.ui.ci:44: warn: padding `Switch.onUpdate(this: Switch, selected: int32): bool` with 3 bytes: (85 -> 88)
cmplGfx/lib/micro.ui.ci:199: warn: Creating virtual method for: Slider.onUpdate(this: Slider, value: float64): bool
cmplGfx/lib/micro.ui.ci:207: warn: adding implicit cast float64(0: int32)
cmplGfx/lib/micro.ui.ci:217: warn: variable `Slider.onReset(this: Slider): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:260: warn: previously defined here as `View.onReset(this: View): bool`
cmplGfx/lib/micro.ui.ci:217: warn: Overriding virtual function: View.onReset(this: View): bool
cmplGfx/lib/micro.ui.ci:221: warn: variable `Slider.onCreate(this: Slider, parent: View): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:265: warn: previously defined here as `View.onCreate(this: View, parent: View): void`
cmplGfx/lib/micro.ui.ci:221: warn: Overriding virtual function: View.onCreate(this: View, parent: View): void
cmplGfx/lib/micro.ui.ci:230: warn: variable `Slider.onKeyEvent(this: Slider, event: KeyEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:278: warn: previously defined here as `View.onKeyEvent(this: View, event: KeyEvent): bool`
cmplGfx/lib/micro.ui.ci:230: warn: Overriding virtual function: View.onKeyEvent(this: View, event: KeyEvent): bool
cmplGfx/lib/micro.ui.ci:234: warn: adding implicit cast int32(' ': char)
cmplGfx/lib/micro.ui.ci:237: warn: adding implicit cast int32('+': char)
cmplGfx/lib/micro.ui.ci:237: warn: adding implicit cast int32('=': char)
cmplGfx/lib/micro.ui.ci:238: warn: adding implicit cast float64((event.isShift ? 1 : 10): int32)
cmplGfx/lib/micro.ui.ci:240: warn: adding implicit cast int32('-': char)
cmplGfx/lib/micro.ui.ci:240: warn: adding implicit cast int32('_': char)
cmplGfx/lib/micro.ui.ci:241: warn: adding implicit cast float64((event.isShift ? 1 : 10): int32)
cmplGfx/lib/micro.ui.ci:246: warn: variable `Slider.onTouchEvent(this: Slider, rect: Rect, event: TouchEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:298: warn: previously defined here as `View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool`
cmplGfx/lib/micro.ui.ci:246: warn: Overriding virtual function: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
cmplGfx/lib/micro.ui.ci:256: warn: adding implicit cast float64(0: int32)
cmplGfx/lib/micro.ui.ci:257: warn: adding implicit cast float64(width(rect): int32)
cmplGfx/lib/micro.ui.ci:276: warn: adding implicit cast float64(width(rect): int32)
cmplGfx/lib/micro.ui.ci:282: warn: variable `Slider.onMeasure(this: Slider, rect: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:331: warn: previously defined here as `View.onMeasure(this: View, rect: Rect): bool`
cmplGfx/lib/micro.ui.ci:282: warn: Overriding virtual function: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.ci:283: warn: adding implicit cast char(0: int32)
cmplGfx/lib/micro.ui.ci:285: warn: adding implicit cast float64(0: int32)
cmplGfx/lib/micro.ui.ci:285: warn: adding implicit cast float64(1: int32)
cmplGfx/lib/micro.ui.ci:285: warn: adding implicit cast float64(0: int32)
cmplGfx/lib/micro.ui.ci:290: debug: using default field initializer: Rect.x0 := 0
cmplGfx/lib/micro.ui.ci:290: debug: using default field initializer: Rect.y0 := 0
cmplGfx/lib/micro.ui.ci:290: debug: using default field initializer: Rect.x1 := 0
cmplGfx/lib/micro.ui.ci:290: debug: using default field initializer: Rect.y1 := 0
cmplGfx/lib/micro.ui.ci:298: warn: Creating virtual method for: Slider.onDrawSlider(this: Slider, offs: Image, rect: Rect): void
cmplGfx/lib/micro.ui.ci:307: warn: adding implicit cast float64(width(rect): int32)
cmplGfx/lib/micro.ui.ci:307: warn: adding implicit cast float64(x0: int32)
cmplGfx/lib/micro.ui.ci:316: warn: Overriding virtual function: View.onDraw(this: View, offs: Image, rect: Rect): void
cmplGfx/lib/micro.ui.ci:317: warn: adding implicit cast char(0: int32)
cmplGfx/lib/micro.ui.ci:318: warn: adding implicit cast float64(0: int32)
cmplGfx/lib/micro.ui.ci:318: warn: adding implicit cast float64(1: int32)
cmplGfx/lib/micro.ui.ci:318: warn: adding implicit cast float64(0: int32)
cmplGfx/lib/micro.ui.ci:323: warn: adding implicit cast pointer(this.onDrawSlider: function)
cmplGfx/lib/micro.ui.ci:199: warn: padding `Slider.onUpdate(this: Slider, value: float64): bool` with 3 bytes: (117 -> 120)
cmplGfx/lib/micro.ui.ci:338: warn: variable `Histogram.data` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:247: warn: previously defined here as `View.data`
cmplGfx/lib/micro.ui.ci:348: warn: Creating virtual method for: Histogram.onUpdate(this: Histogram, idx: int32, value: int32): bool
cmplGfx/lib/micro.ui.ci:353: warn: variable `Histogram.onReset(this: Histogram): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:260: warn: previously defined here as `View.onReset(this: View): bool`
cmplGfx/lib/micro.ui.ci:353: warn: Overriding virtual function: View.onReset(this: View): bool
cmplGfx/lib/micro.ui.ci:361: warn: variable `Histogram.onCreate(this: Histogram, parent: View): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:265: warn: previously defined here as `View.onCreate(this: View, parent: View): void`
cmplGfx/lib/micro.ui.ci:361: warn: Overriding virtual function: View.onCreate(this: View, parent: View): void
cmplGfx/lib/micro.ui.ci:366: warn: variable `Histogram.onTouchEvent(this: Histogram, rect: Rect, event: TouchEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:298: warn: previously defined here as `View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool`
cmplGfx/lib/micro.ui.ci:366: warn: Overriding virtual function: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
cmplGfx/lib/micro.ui.ci:367: warn: adding implicit cast bool(event.button: int32)
cmplGfx/lib/micro.ui.ci:406: warn: variable `Histogram.onMeasure(this: Histogram, rect: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:331: warn: previously defined here as `View.onMeasure(this: View, rect: Rect): bool`
cmplGfx/lib/micro.ui.ci:406: warn: Overriding virtual function: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.ci:416: warn: Overriding virtual function: View.onDraw(this: View, offs: Image, rect: Rect): void
cmplGfx/lib/micro.ui.ci:432: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/micro.ui.ci:456: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/micro.ui.ci:465: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/micro.ui.ci:473: warn: adding implicit cast int32(uint32(y < bv): uint32)
cmplGfx/lib/micro.ui.ci:474: warn: adding implicit cast int32(uint32(y < gv): uint32)
cmplGfx/lib/micro.ui.ci:475: warn: adding implicit cast int32(uint32(y < rv): uint32)
cmplGfx/lib/micro.ui.ci:476: warn: adding implicit cast int32(uint32(y < lv): uint32)
cmplGfx/lib/micro.ui.ci:338: warn: padding `Histogram.data` with 2 bytes: (66 -> 68)
cmplGfx/lib/micro.ui.ci:500: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:502: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/micro.ui.ci:514: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:520: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:526: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:533: warn: variable `DebugView.onClick(this: DebugView): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:255: warn: previously defined here as `View.onClick(this: View): bool`
cmplGfx/lib/micro.ui.ci:533: warn: Overriding virtual function: View.onClick(this: View): bool
cmplGfx/lib/micro.ui.ci:537: warn: variable `DebugView.onReset(this: DebugView): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:260: warn: previously defined here as `View.onReset(this: View): bool`
cmplGfx/lib/micro.ui.ci:537: warn: Overriding virtual function: View.onReset(this: View): bool
cmplGfx/lib/micro.ui.ci:538: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:539: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:541: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:542: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:544: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/micro.ui.ci:545: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:547: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:548: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:552: warn: variable `DebugView.onCreate(this: DebugView, parent: View): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:265: warn: previously defined here as `View.onCreate(this: View, parent: View): void`
cmplGfx/lib/micro.ui.ci:552: warn: Overriding virtual function: View.onCreate(this: View, parent: View): void
cmplGfx/lib/micro.ui.ci:557: warn: variable `DebugView.onMeasure(this: DebugView, rect: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:331: warn: previously defined here as `View.onMeasure(this: View, rect: Rect): bool`
cmplGfx/lib/micro.ui.ci:557: warn: Overriding virtual function: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.ci:558: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:559: warn: adding implicit cast int64(1: int32)
cmplGfx/lib/micro.ui.ci:567: warn: Overriding virtual function: View.onDraw(this: View, offs: Image, rect: Rect): void
cmplGfx/lib/micro.ui.ci:568: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:574: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:578: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:580: warn: adding implicit cast float64(height(rect): int32)
cmplGfx/lib/micro.ui.ci:581: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/micro.ui.ci:581: warn: adding implicit cast float64(width(rect): int32)
cmplGfx/lib/micro.ui.ci:582: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/micro.ui.ci:583: warn: adding implicit cast float64(this.durations[i]: int64)
cmplGfx/lib/micro.ui.ci:583: warn: adding implicit cast float64(y0: int32)
cmplGfx/lib/micro.ui.ci:584: warn: adding implicit cast int32(length: uint32)
cmplGfx/lib/micro.ui.ci:584: warn: adding implicit cast float64((this.durations.(length) - i): int32)
cmplGfx/lib/micro.ui.ci:584: warn: adding implicit cast float64(rect.x0: int32)
cmplGfx/lib/micro.ui.ci:585: warn: adding implicit cast float64(x1: int32)
cmplGfx/lib/micro.ui.ci:589: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:590: warn: adding implicit cast int64(1: int32)
cmplGfx/lib/micro.ui.ci:614: warn: variable `Panel.onMeasure(this: Panel, rect: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:749: warn: previously defined here as `Layout.onMeasure(this: Layout, measured: Rect): bool`
cmplGfx/lib/micro.ui.ci:614: warn: variable `Panel.onMeasure(this: Panel, rect: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:331: warn: previously defined here as `View.onMeasure(this: View, rect: Rect): bool`
cmplGfx/lib/micro.ui.ci:614: warn: Overriding virtual function: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.ci:599: warn: padding `Panel` with 3 bytes: (117 -> 120)
cmplGfx/lib/micro.ui.ci:634: warn: variable `TabPage.onCreate(this: TabPage, parent: View): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:609: warn: previously defined here as `Layout.onCreate(this: Layout, parent: View): void`
cmplGfx/lib/micro.ui.ci:634: warn: variable `TabPage.onCreate(this: TabPage, parent: View): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:265: warn: previously defined here as `View.onCreate(this: View, parent: View): void`
cmplGfx/lib/micro.ui.ci:634: warn: Overriding virtual function: View.onCreate(this: View, parent: View): void
cmplGfx/lib/micro.ui.ci:636: warn: adding implicit cast Layout(this.items[1].view: View)
cmplGfx/lib/micro.ui.ci:643: warn: adding implicit cast pointer(parent: TabPage)
cmplGfx/lib/micro.ui.ci:666: warn: adding implicit cast pointer(page.active: Layout)
warn: adding implicit cast pointer(page: Layout)
warn: adding implicit cast pointer(tabs: TabPage)
cmplGfx/lib/micro.ui.ci:694: warn: adding implicit cast variant(this: TabPage)
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.separator := null
cmplGfx/lib/micro.ui.core.ci:396: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.items := null
cmplGfx/lib/micro.ui.core.ci:398: warn: adding implicit cast Layout.Item[*](null: pointer)
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.itemCount := 0
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.itemCapacity := 0
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.hoveredIndex := -1
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.pressedIndex := -1
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.focusedIndex := -1
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.paddingTop := 0
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.paddingLeft := 0
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.paddingRight := 0
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.paddingBottom := 0
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.orientation := 1
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: Layout.onLayout(this: Layout, measured: Rect): void := onLayout
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: View.width := -5
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: View.height := -5
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: View.enabled := true
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: View.focusable := true
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:693: debug: using default field initializer: View.style := null
cmplGfx/lib/micro.ui.core.ci:244: warn: adding implicit cast Style(null: pointer)
cmplGfx/lib/micro.ui.ci:693: debug: using default type initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.ci:693: debug: using default type initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.ci:693: debug: using default type initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.ci:693: debug: using default type initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.ci:693: debug: using default type initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.ci:693: debug: using default type initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.ci:700: warn: adding implicit cast char[*](text: char[*])
cmplGfx/lib/micro.ui.ci:701: warn: adding implicit cast variant(page: Layout)
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.width := -5
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.height := -5
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.enabled := true
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.style := null
cmplGfx/lib/micro.ui.core.ci:244: warn: adding implicit cast Style(null: pointer)
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.ci:699: debug: using default field initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.ci:699: debug: using default type initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.ci:707: warn: adding implicit cast pointer(this.tabs: Layout)
cmplGfx/lib/micro.ui.ci:713: warn: adding implicit cast variant(this: TabPage)
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: Layout.separator := null
cmplGfx/lib/micro.ui.core.ci:396: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: Layout.items := null
cmplGfx/lib/micro.ui.core.ci:398: warn: adding implicit cast Layout.Item[*](null: pointer)
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: Layout.itemCount := 0
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: Layout.itemCapacity := 0
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: Layout.hoveredIndex := -1
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: Layout.pressedIndex := -1
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: Layout.focusedIndex := -1
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: Layout.onLayout(this: Layout, measured: Rect): void := onLayout
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: View.width := -5
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: View.height := -5
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: View.enabled := true
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: View.focusable := true
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:708: debug: using default field initializer: View.style := null
cmplGfx/lib/micro.ui.core.ci:244: warn: adding implicit cast Style(null: pointer)
cmplGfx/lib/micro.ui.ci:708: debug: using default type initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.ci:708: debug: using default type initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.ci:708: debug: using default type initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.ci:708: debug: using default type initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.ci:708: debug: using default type initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.ci:708: debug: using default type initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.ci:708: debug: using default type initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.ci:725: warn: adding implicit cast pointer(tabs.separator: View)
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.style := null
cmplGfx/lib/micro.ui.core.ci:244: warn: adding implicit cast Style(null: pointer)
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.data := null
cmplGfx/lib/micro.ui.core.ci:247: warn: adding implicit cast variant(null: pointer)
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.ci:726: debug: using default field initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.ci:757: warn: adding implicit cast pointer(select.selected: Button)
cmplGfx/lib/micro.ui.ci:765: warn: adding implicit cast pointer(select.selected: Button)
cmplGfx/lib/micro.ui.ci:780: warn: adding implicit cast char[*](view.text: char[*])
cmplGfx/lib/micro.ui.ci:791: warn: adding implicit cast pointer(button: Button)
cmplGfx/lib/micro.ui.ci:796: warn: adding implicit cast char[*](button.text: char[*])
cmplGfx/lib/micro.ui.ci:801: warn: variable `Select.addItems(this: Select, align: int32, views: View[]): Select` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:529: warn: previously defined here as `Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout`
cmplGfx/lib/micro.ui.ci:804: warn: variable `Select.addItems.Header.onReset(this: Header): bool` hides previous declaration
cmplGfx/lib/micro.ui.ci:65: warn: previously defined here as `Switch.onReset(this: Switch): bool`
cmplGfx/lib/micro.ui.ci:804: warn: variable `Select.addItems.Header.onReset(this: Header): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:260: warn: previously defined here as `View.onReset(this: View): bool`
cmplGfx/lib/micro.ui.ci:804: warn: Overriding virtual function: View.onReset(this: View): bool
cmplGfx/lib/micro.ui.ci:807: warn: variable `Select.addItems.Header.onClick(this: Header): bool` hides previous declaration
cmplGfx/lib/micro.ui.ci:69: warn: previously defined here as `Switch.onClick(this: Switch): bool`
cmplGfx/lib/micro.ui.ci:807: warn: variable `Select.addItems.Header.onClick(this: Header): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:255: warn: previously defined here as `View.onClick(this: View): bool`
cmplGfx/lib/micro.ui.ci:807: warn: Overriding virtual function: View.onClick(this: View): bool
cmplGfx/lib/micro.ui.ci:817: warn: adding implicit cast char[*](this.text: char[])
cmplGfx/lib/micro.ui.ci:818: warn: adding implicit cast char[*][](this.states: char[*][2])
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: Switch.selected := 0
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: Switch.resetValue := 0
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: Switch.onUpdate(this: Switch, selected: int32): bool := onUpdate
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: View.width := -5
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: View.height := -5
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: View.enabled := true
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: View.focusable := true
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: View.style := null
cmplGfx/lib/micro.ui.core.ci:244: warn: adding implicit cast Style(null: pointer)
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: View.data := null
cmplGfx/lib/micro.ui.core.ci:247: warn: adding implicit cast variant(null: pointer)
cmplGfx/lib/micro.ui.ci:816: debug: using default type initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.ci:816: debug: using default type initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.ci:816: debug: using default type initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.ci:816: debug: using default field initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.ci:816: debug: using default type initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.ci:816: debug: using default type initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.ci:816: debug: using default type initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.ci:816: debug: using default type initializer: View.onDraw(this: View, offs: Image, rect: Rect): void := onDraw
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Panel.visible := false
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.separator := null
cmplGfx/lib/micro.ui.core.ci:396: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.items := null
cmplGfx/lib/micro.ui.core.ci:398: warn: adding implicit cast Layout.Item[*](null: pointer)
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.itemCount := 0
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.itemCapacity := 0
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.hoveredIndex := -1
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.pressedIndex := -1
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.focusedIndex := -1
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.paddingTop := 0
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.paddingLeft := 0
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.paddingRight := 0
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.paddingBottom := 0
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.orientation := 1
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: Layout.onLayout(this: Layout, measured: Rect): void := onLayout
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: View.width := -5
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: View.height := -5
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: View.enabled := true
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: View.focusable := true
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: View.style := null
cmplGfx/lib/micro.ui.core.ci:244: warn: adding implicit cast Style(null: pointer)
cmplGfx/lib/micro.ui.ci:822: debug: using default field initializer: View.data := null
cmplGfx/lib/micro.ui.core.ci:247: warn: adding implicit cast variant(null: pointer)
cmplGfx/lib/micro.ui.ci:822: debug: using default type initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.ci:822: debug: using default type initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.ci:822: debug: using default type initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.ci:822: debug: using default type initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.ci:822: debug: using default type initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.ci:822: debug: using default type initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.ci:822: debug: using default type initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.ci:822: debug: using default type initializer: View.onDraw(this: View, offs: Image, rect: Rect): void := onDraw
cmplGfx/lib/micro.ui.ci:824: warn: adding implicit cast char[*]("<": .cstr)
cmplGfx/lib/micro.ui.ci:825: warn: adding implicit cast char[*]("^": .cstr)
cmplGfx/lib/micro.ui.ci:826: warn: adding implicit cast Switch(header: Select.addItems.Header)
cmplGfx/lib/micro.ui.ci:839: warn: variable `Select.addItem.SelectItem.onClick(this: SelectItem): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:255: warn: previously defined here as `View.onClick(this: View): bool`
cmplGfx/lib/micro.ui.ci:839: warn: Overriding virtual function: View.onClick(this: View): bool
cmplGfx/lib/micro.ui.ci:845: warn: adding implicit cast char[*](text: char[*])
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.width := -5
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.height := -5
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.enabled := true
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.focusable := true
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.style := null
cmplGfx/lib/micro.ui.core.ci:244: warn: adding implicit cast Style(null: pointer)
cmplGfx/lib/micro.ui.ci:843: debug: using default type initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.ci:843: debug: using default field initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.ci:843: debug: using default type initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.ci:843: debug: using default type initializer: View.onDraw(this: View, offs: Image, rect: Rect): void := onDraw
cmplGfx/lib/micro.ui.ci:870: warn: variable `FxWidget.onTouchEvent(this: FxWidget, rect: Rect, event: TouchEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:643: warn: previously defined here as `Layout.onTouchEvent(this: Layout, rect: Rect, event: TouchEvent): bool`
cmplGfx/lib/micro.ui.ci:870: warn: variable `FxWidget.onTouchEvent(this: FxWidget, rect: Rect, event: TouchEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:298: warn: previously defined here as `View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool`
cmplGfx/lib/micro.ui.ci:870: warn: Overriding virtual function: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
cmplGfx/lib/micro.ui.ci:875: warn: adding implicit cast bool(event.dx: int32)
cmplGfx/lib/micro.ui.ci:875: warn: adding implicit cast bool(event.dy: int32)
cmplGfx/lib/micro.ui.ci:875: warn: adding implicit cast bool(event.button: int32)
cmplGfx/lib/micro.ui.ci:886: warn: adding implicit cast pointer(view: View)
cmplGfx/lib/micro.ui.ci:895: warn: variable `FxWidget.onKeyEvent(this: FxWidget, event: KeyEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:1195: warn: previously defined here as `Widget.onKeyEvent(this: Widget, event: KeyEvent): bool`
cmplGfx/lib/micro.ui.ci:895: warn: variable `FxWidget.onKeyEvent(this: FxWidget, event: KeyEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:628: warn: previously defined here as `Layout.onKeyEvent(this: Layout, event: KeyEvent): bool`
cmplGfx/lib/micro.ui.ci:895: warn: variable `FxWidget.onKeyEvent(this: FxWidget, event: KeyEvent): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:278: warn: previously defined here as `View.onKeyEvent(this: View, event: KeyEvent): bool`
cmplGfx/lib/micro.ui.ci:895: warn: Overriding virtual function: View.onKeyEvent(this: View, event: KeyEvent): bool
cmplGfx/lib/micro.ui.ci:896: warn: adding implicit cast int32('[': char)
cmplGfx/lib/micro.ui.ci:896: warn: adding implicit cast int32(']': char)
cmplGfx/lib/micro.ui.ci:911: warn: adding implicit cast int32('[': char)
cmplGfx/lib/micro.ui.ci:919: warn: adding implicit cast int32(']': char)
cmplGfx/lib/micro.ui.ci:933: warn: adding implicit cast int32('\': char)
cmplGfx/lib/micro.ui.ci:942: warn: adding implicit cast int64(event.key: int32)
cmplGfx/lib/micro.ui.ci:949: warn: variable `FxWidget.onMeasure(this: FxWidget, measured: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:1218: warn: previously defined here as `Widget.onMeasure(this: Widget, measured: Rect): bool`
cmplGfx/lib/micro.ui.ci:949: warn: variable `FxWidget.onMeasure(this: FxWidget, measured: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:749: warn: previously defined here as `Layout.onMeasure(this: Layout, measured: Rect): bool`
cmplGfx/lib/micro.ui.ci:949: warn: variable `FxWidget.onMeasure(this: FxWidget, measured: Rect): bool` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:331: warn: previously defined here as `View.onMeasure(this: View, rect: Rect): bool`
cmplGfx/lib/micro.ui.ci:949: warn: Overriding virtual function: View.onMeasure(this: View, rect: Rect): bool
cmplGfx/lib/micro.ui.ci:967: warn: variable `FxWidget.onDraw(this: FxWidget, offs: Image, rect: Rect): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:1224: warn: previously defined here as `Widget.onDraw(this: Widget, offs: Image, rect: Rect): void`
cmplGfx/lib/micro.ui.ci:967: warn: variable `FxWidget.onDraw(this: FxWidget, offs: Image, rect: Rect): void` hides previous declaration
cmplGfx/lib/micro.ui.core.ci:1029: warn: previously defined here as `Layout.onDraw(this: Layout, offs: Image, parent: Rect): void`
cmplGfx/lib/micro.ui.ci:967: warn: Overriding virtual function: View.onDraw(this: View, offs: Image, rect: Rect): void
cmplGfx/lib/micro.ui.ci:970: warn: adding implicit cast uint32(-1: int32)
cmplGfx/lib/micro.ui.ci:979: warn: Creating virtual method for: FxWidget.onProcess(widget: FxWidget): void
cmplGfx/lib/micro.ui.ci:863: warn: padding `FxWidget.align` with 3 bytes: (133 -> 136)
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Widget.measure := true
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Widget.redraw := true
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Widget.focus := null
cmplGfx/lib/micro.ui.core.ci:1087: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Widget.scrollX := 0
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Widget.scrollY := 0
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.separator := null
cmplGfx/lib/micro.ui.core.ci:396: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.items := null
cmplGfx/lib/micro.ui.core.ci:398: warn: adding implicit cast Layout.Item[*](null: pointer)
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.itemCount := 0
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.itemCapacity := 0
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.hoveredIndex := -1
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.pressedIndex := -1
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.focusedIndex := -1
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.paddingTop := 0
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.paddingLeft := 0
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.paddingRight := 0
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.paddingBottom := 0
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.orientation := 1
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: Layout.onLayout(this: Layout, measured: Rect): void := onLayout
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: View.enabled := true
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: View.focusable := true
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:984: debug: using default field initializer: View.data := null
cmplGfx/lib/micro.ui.core.ci:247: warn: adding implicit cast variant(null: pointer)
cmplGfx/lib/micro.ui.ci:984: debug: using default type initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.ci:984: debug: using default type initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.ci:984: debug: using default type initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.ci:984: debug: using default type initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.ci:984: debug: using default type initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.ci:984: debug: using default type initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.ci:984: debug: using default type initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.ci:984: debug: using default type initializer: View.onDraw(this: View, offs: Image, rect: Rect): void := onDraw
cmplGfx/lib/micro.ui.ci:995: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/Format.ci:4: warn: adding implicit cast char(0: int32)
cmplGfx/lib/micro.ui.ci:995: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/Format.ci:7: warn: adding implicit cast char(0: int32)
cmplGfx/lib/micro.ui.ci:995: debug: using default field initializer: FormatFlags.width := 0
cmplGfx/lib/micro.ui.ci:994: debug: using default field initializer: Style.align := 0
cmplGfx/lib/micro.ui.ci:994: debug: using default field initializer: Style.padding := 8
cmplGfx/lib/micro.ui.ci:994: debug: using default field initializer: Style.font := Window.font
cmplGfx/lib/micro.ui.ci:994: debug: using default field initializer: Style.backgroundColor := uint32(theme)
cmplGfx/lib/micro.ui.ci:994: debug: using default field initializer: Style.hoveredColor := uint32(mix_rgb8(16, theme, accent))
cmplGfx/lib/micro.ui.ci:994: debug: using default field initializer: Style.focusedColor := uint32(mix_rgb8(64, theme, accent))
cmplGfx/lib/micro.ui.ci:994: debug: using default field initializer: Style.valueColor := uint32(accent)
cmplGfx/lib/micro.ui.ci:994: debug: using default field initializer: Style.textColor := uint32(lum(theme) > 127 ? dark : light)
cmplGfx/lib/micro.ui.ci:1003: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/Format.ci:4: warn: adding implicit cast char(0: int32)
cmplGfx/lib/micro.ui.ci:1003: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/Format.ci:7: warn: adding implicit cast char(0: int32)
cmplGfx/lib/micro.ui.ci:1003: debug: using default field initializer: FormatFlags.width := 0
cmplGfx/lib/micro.ui.ci:1001: debug: using default field initializer: Style.padding := 8
cmplGfx/lib/micro.ui.ci:1001: debug: using default field initializer: Style.font := Window.font
cmplGfx/lib/micro.ui.ci:1001: debug: using default field initializer: Style.backgroundColor := uint32(theme)
cmplGfx/lib/micro.ui.ci:1001: debug: using default field initializer: Style.hoveredColor := uint32(mix_rgb8(16, theme, accent))
cmplGfx/lib/micro.ui.ci:1001: debug: using default field initializer: Style.focusedColor := uint32(mix_rgb8(64, theme, accent))
cmplGfx/lib/micro.ui.ci:1001: debug: using default field initializer: Style.valueColor := uint32(accent)
cmplGfx/lib/micro.ui.ci:1001: debug: using default field initializer: Style.textColor := uint32(lum(theme) > 127 ? dark : light)
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: FxWidget.showOriginal := false
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Widget.measure := true
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Widget.redraw := true
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Widget.focus := null
cmplGfx/lib/micro.ui.core.ci:1087: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Widget.scrollX := 0
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Widget.scrollY := 0
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Layout.separator := null
cmplGfx/lib/micro.ui.core.ci:396: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Layout.items := null
cmplGfx/lib/micro.ui.core.ci:398: warn: adding implicit cast Layout.Item[*](null: pointer)
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Layout.itemCount := 0
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Layout.itemCapacity := 0
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Layout.hoveredIndex := -1
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Layout.pressedIndex := -1
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Layout.focusedIndex := -1
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Layout.orientation := 1
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: Layout.onLayout(this: Layout, measured: Rect): void := onLayout
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: View.width := -5
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: View.height := -5
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: View.enabled := true
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: View.focusable := true
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: View.parent := null
cmplGfx/lib/micro.ui.core.ci:241: warn: adding implicit cast View(null: pointer)
cmplGfx/lib/micro.ui.ci:1005: debug: using default field initializer: View.data := null
cmplGfx/lib/micro.ui.core.ci:247: warn: adding implicit cast variant(null: pointer)
cmplGfx/lib/micro.ui.ci:1005: debug: using default type initializer: View.onClick(this: View): bool := onClick
cmplGfx/lib/micro.ui.ci:1005: debug: using default type initializer: View.onReset(this: View): bool := onReset
cmplGfx/lib/micro.ui.ci:1005: debug: using default type initializer: View.onCreate(this: View, parent: View): void := onCreate
cmplGfx/lib/micro.ui.ci:1005: debug: using default type initializer: View.onDestroy(this: View): void := onDestroy
cmplGfx/lib/micro.ui.ci:1005: debug: using default type initializer: View.onKeyEvent(this: View, event: KeyEvent): bool := onKeyEvent
cmplGfx/lib/micro.ui.ci:1005: debug: using default type initializer: View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool := onTouchEvent
cmplGfx/lib/micro.ui.ci:1005: debug: using default type initializer: View.onMeasure(this: View, rect: Rect): bool := onMeasure
cmplGfx/lib/micro.ui.ci:1005: debug: using default type initializer: View.onDraw(this: View, offs: Image, rect: Rect): void := onDraw
cmplGfx/lib/micro.ui.ci:1034: warn: adding implicit cast uint32(0: int32)
cmplGfx/lib/micro.ui.ci:1040: warn: adding implicit cast int32(items.length: uint32)
warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.ci:1057: warn: adding implicit cast uint32(0: int32)
cmplGfx/lib/micro.ui.ci:1063: warn: adding implicit cast int32(items.length: uint32)
warn: adding implicit cast pointer(layout: Layout)
cmplGfx/lib/micro.ui.ci:1076: warn: Extending static namespace: Window
cmplGfx/lib/micro.ui.ci:1082: warn: padding `Window.show.WindowData.rect` with 4 bytes: (12 -> 16)
cmplGfx/lib/micro.ui.ci:1088: warn: padding `Window.show.WindowData.time` with 4 bytes: (44 -> 48)
cmplGfx/lib/micro.ui.ci:1097: warn: padding `Window.show.WindowData.key` with 1 bytes: (71 -> 72)
cmplGfx/lib/micro.ui.ci:1102: warn: adding implicit cast pointer(widget.parent: View)
cmplGfx/lib/micro.ui.ci:1106: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1109: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1115: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1119: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1124: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1129: warn: adding implicit cast float64((now - window.time): int64)
cmplGfx/lib/micro.ui.ci:1134: warn: adding implicit cast int64(1000: int32)
cmplGfx/lib/micro.ui.ci:1136: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1147: debug: using default field initializer: TouchEvent.dx := 0
cmplGfx/lib/micro.ui.ci:1147: debug: using default field initializer: TouchEvent.dy := 0
cmplGfx/lib/micro.ui.ci:1159: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1163: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1186: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1188: warn: adding implicit cast float64((now - window.time): int64)
cmplGfx/lib/micro.ui.ci:1191: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1196: debug: using default field initializer: TouchEvent.dx := 0
cmplGfx/lib/micro.ui.ci:1196: debug: using default field initializer: TouchEvent.dy := 0
cmplGfx/lib/micro.ui.ci:1209: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1210: warn: adding implicit cast int64(y: int32)
cmplGfx/lib/micro.ui.ci:1210: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1211: warn: adding implicit cast int64(y: int32)
cmplGfx/lib/micro.ui.ci:1211: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1212: warn: adding implicit cast int64(y: int32)
cmplGfx/lib/micro.ui.ci:1212: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1230: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1231: warn: adding implicit cast int64(y: int32)
cmplGfx/lib/micro.ui.ci:1231: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1232: warn: adding implicit cast int64(y: int32)
cmplGfx/lib/micro.ui.ci:1232: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1233: warn: adding implicit cast int64(y: int32)
cmplGfx/lib/micro.ui.ci:1233: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1247: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1248: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1250: debug: using default field initializer: TouchEvent.dx := 0
cmplGfx/lib/micro.ui.ci:1250: debug: using default field initializer: TouchEvent.dy := 0
cmplGfx/lib/micro.ui.ci:1274: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1276: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1277: warn: adding implicit cast int64(Window.timeoutMax: int32)
cmplGfx/lib/micro.ui.ci:1295: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1295: warn: adding implicit cast int64(button: int32)
cmplGfx/lib/micro.ui.ci:1301: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1303: warn: adding implicit cast int32(Window.MOUSE_PRESS: int64)
cmplGfx/lib/micro.ui.ci:1306: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1308: warn: adding implicit cast int32(Window.MOUSE_MOTION: int64)
cmplGfx/lib/micro.ui.ci:1311: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1313: warn: adding implicit cast int32(Window.MOUSE_RELEASE: int64)
cmplGfx/lib/micro.ui.ci:1324: warn: adding implicit cast int64(action: int32)
cmplGfx/lib/micro.ui.ci:1328: warn: adding implicit cast int64(action: int32)
warn: adding implicit cast pointer(fxWidget: FxWidget)
cmplGfx/lib/micro.ui.ci:1341: debug: using default field initializer: Rect.x0 := 0
cmplGfx/lib/micro.ui.ci:1341: debug: using default field initializer: Rect.y0 := 0
cmplGfx/lib/micro.ui.ci:1341: debug: using default field initializer: Rect.x1 := 0
cmplGfx/lib/micro.ui.ci:1341: debug: using default field initializer: Rect.y1 := 0
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.timeout := 0
cmplGfx/lib/micro.ui.ci:1084: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.clicks := 0
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.time := 0
cmplGfx/lib/micro.ui.ci:1088: warn: adding implicit cast int64(0: int32)
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.button := 0
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.lastX := 0
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.lastY := 0
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.isShift := false
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.isCtrl := false
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.isAlt := false
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.key := 0
cmplGfx/lib/micro.ui.ci:1338: debug: using default field initializer: Window.show.WindowData.repeat := 0
cmplGfx/lib/micro.ui.ci:1348: debug: using default field initializer: Rect.x0 := 0
cmplGfx/lib/micro.ui.ci:1348: debug: using default field initializer: Rect.y0 := 0
cmplGfx/lib/micro.ui.ci:1348: debug: using default field initializer: Rect.x1 := 0
cmplGfx/lib/micro.ui.ci:1348: debug: using default field initializer: Rect.y1 := 0

---------- Compile: `cmplStd/test/test.ci`
cmplStd/test/test.ci:9: debug: inline file: `cmplStd/test/lang/emit.ci`
cmplStd/test/test.ci:10: debug: inline file: `cmplStd/test/lang/inlineMacros.ci`
cmplStd/test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
cmplStd/test/test.ci:11: debug: inline file: `cmplStd/test/lang/overload.inline.ci`
cmplStd/test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
cmplStd/test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
cmplStd/test/test.ci:14: debug: inline file: `cmplStd/test/lang/memory.ci`
cmplStd/test/test.ci:15: debug: inline file: `cmplStd/test/lang/tryExec.ci`
cmplStd/test/lang/tryExec.ci:17: warn: variable `abortExecution.NotEquals` hides previous declaration
cmplStd/lib/lang/Debug.ci:32: warn: previously defined here as `NotEquals`
cmplStd/test/lang/tryExec.ci:17: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
cmplStd/test/lang/tryExec.ci:23: warn: adding implicit cast char[*]("assertion failed": .cstr)
cmplStd/test/test.ci:16: debug: inline file: `cmplStd/test/lang/pointer.ci`
cmplStd/test/lang/pointer.ci:9: warn: adding implicit cast int32[5](ptr: pointer)
cmplStd/test/test.ci:20: debug: inline file: `cmplStd/test/lang/init.reference.ci`
cmplStd/test/lang/init.reference.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:21: debug: inline file: `cmplStd/test/lang/init.variable.ci`
cmplStd/test/lang/init.variable.ci:24: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:24: debug: using default field initializer: ComplexVal.im := 0
cmplStd/test/lang/init.variable.ci:11: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:33: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:33: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:41: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:41: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/test.ci:24: debug: inline file: `cmplStd/test/lang/function.ci`
cmplStd/test/lang/function.ci:33: warn: Overwriting forward function: funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
cmplStd/test/test.ci:25: debug: inline file: `cmplStd/test/lang/reflect.ci`
cmplStd/test/test.ci:29: debug: inline file: `cmplStd/test/lang/init.member.ci`
cmplStd/test/lang/init.member.ci:81: warn: ignoring nested comment
cmplStd/test/lang/init.member.ci:43: debug: using default type initializer: RecordMemberTest.Inner.member := 0
warn: adding implicit cast int32(0: int64)
cmplStd/test/test.ci:30: debug: inline file: `cmplStd/test/lang/init.method.ci`
cmplStd/test/lang/init.method.ci:40: warn: Creating virtual method for: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47: warn: Overwriting forward function: RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
cmplStd/test/lang/init.method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/lang/init.method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/test.ci:33: debug: inline file: `cmplStd/test/lang/recUnion.ci`
cmplStd/test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
cmplStd/test/test.ci:34: debug: inline file: `cmplStd/test/lang/recPacking.ci`
cmplStd/test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
cmplStd/test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
cmplStd/test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
cmplStd/test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
cmplStd/test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
cmplStd/test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
cmplStd/test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
cmplStd/test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
cmplStd/test/test.ci:41: debug: inline file: `cmplStd/test/lang/useOperator.ci`
cmplStd/test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
cmplStd/test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
cmplStd/test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
cmplStd/test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
cmplStd/test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
cmplStd/test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
cmplStd/test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
cmplStd/test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
cmplStd/test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
cmplStd/test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
cmplStd/test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
cmplStd/test/test.ci:45: debug: inline file: `cmplStd/test/lang/stmt.if.ci`
cmplStd/test/lang/stmt.if.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:46: debug: inline file: `cmplStd/test/lang/stmt.for.ci`
cmplStd/test/test.ci:50: debug: inline file: `cmplStd/test/math/test.Bits.ci`
cmplStd/test/math/test.Bits.ci:37: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Bits.ci:38: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Bits.ci:39: warn: adding implicit cast float64(4: int32)
cmplStd/test/math/test.Bits.ci:46: warn: adding implicit cast float32(2: int32)
cmplStd/test/math/test.Bits.ci:47: warn: adding implicit cast float32(2: int32)
cmplStd/test/math/test.Bits.ci:48: warn: adding implicit cast float32(4: int32)
cmplStd/test/test.ci:52: debug: inline file: `cmplStd/test/math/test.Math.ci`
cmplStd/test/math/test.Math.ci:83: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Math.ci:84: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Math.ci:85: warn: adding implicit cast float64(4: int32)
cmplStd/test/math/test.Math.ci:86: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Math.ci:87: warn: adding implicit cast float64(2: int32)
cmplStd/test/test.ci:53: debug: inline file: `cmplStd/test/math/test.Complex.ci`
cmplStd/test/math/test.Complex.ci:8: warn: adding implicit cast float64(9: int32)
cmplStd/test/math/test.Complex.ci:8: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Complex.ci:9: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Complex.ci:9: warn: adding implicit cast float64(3: int32)

---------- Generate: byte-code
cmplStd/lib/math/Math.ci:425: warn: using default type initializer: Math.log.exp := 0
cmplStd/lib/math/Math.ci:622: warn: using default type initializer: Math.pow.ye := 0
cmplStd/lib/math/Math.ci:657: warn: using default type initializer: Math.pow.ex := 0
cmplStd/lib/math/Math.ci:716: warn: using default type initializer: Math.sincos.y := 0
cmplStd/lib/math/Math.ci:719: warn: using default type initializer: e := 0
cmplStd/lib/math/Math.ci:723: warn: using default type initializer: f := 0
cmplStd/lib/math/Fixed.ci:55: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:57: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:94: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:94: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:94: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:99: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:99: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:206: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:211: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:223: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:227: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:233: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:237: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:241: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:297: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:303: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:318: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:330: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:330: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:342: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:342: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:355: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:357: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:378: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:386: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:394: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:399: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:409: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:411: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:437: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:437: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:437: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:440: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:440: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:440: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:486: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:486: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:496: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:564: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:610: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:610: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:610: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:715: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:720: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:733: warn: uninitialized variable `.result`
cmplStd/lib/math/Matrix4f.ci:98: warn: uninitialized variable `.result`
cmplStd/lib/time/Timestamp.ci:23: warn: uninitialized variable `.result`
cmplStd/lib/time/Timestamp.ci:110: warn: uninitialized variable `.result`
cmplStd/lib/time/Timezone.ci:7: warn: using default type initializer: Timezone.offset.isDaylightSaving := 0
cmplStd/lib/time/Timezone.ci:8: warn: uninitialized variable `.result`
cmplStd/lib/time/Timezone.ci:29: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/time/Datetime.ci:153: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:175: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/time/Datetime.ci:196: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:197: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:292: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:292: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:297: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:302: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:307: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:307: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/text/Format.ci:334: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:359: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:359: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:363: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:363: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:371: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, ' ')
cmplStd/lib/text/Format.ci:371: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:385: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:385: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:389: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:389: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:393: debug: adding temporary variable format := FormatFlags.defPad(flags, 3, '0')
cmplStd/lib/text/Format.ci:393: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:397: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, ' ')
cmplStd/lib/text/Format.ci:397: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:401: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, ' ')
cmplStd/lib/text/Format.ci:401: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:405: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:405: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:409: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:409: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:418: debug: adding temporary variable format := FormatFlags.defPad(flags, 9, '0')
cmplStd/lib/text/Format.ci:418: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:436: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:440: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:440: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:459: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:459: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:471: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:471: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:86: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:92: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:94: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:101: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:108: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:115: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:122: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:129: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:136: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:147: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:151: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:151: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/math/Polynomial.ci:26: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:30: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:35: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:39: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:43: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:45: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:46: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/math/Polynomial.ci:106: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:115: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:124: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:135: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:155: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:164: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:178: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplGfx/lib/color.hsl.ci:24: warn: using default type initializer: rgb2hsl.sat := 0
cmplGfx/lib/color.hsl.ci:35: warn: using default type initializer: rgb2hsl.hue := 0
cmplGfx/lib/color.hsl.ci:86: warn: using default type initializer: hsl2rgb.f2 := 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplGfx/lib/image.blend.ci:47: warn: uninitialized variable `.result`
cmplGfx/lib/image.blend.ci:58: debug: adding temporary variable vec := blend(vec4f(base), vec4f(with))
cmplGfx/lib/image.blend.ci:58: warn: uninitialized variable `.result`
cmplGfx/lib/image.blend.ci:183: debug: adding temporary variable vec := eval(in)
cmplGfx/lib/image.blend.ci:183: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplGfx/lib/image.transform.ci:29: debug: adding temporary variable rhs := translation(vec4f(dRec.x0, dRec.y0, 0, 0), -1)
cmplGfx/lib/image.transform.ci:29: debug: adding temporary variable direction := vec4f(dRec.x0, dRec.y0, 0, 0)
cmplGfx/lib/image.transform.ci:29: warn: uninitialized variable `.result`
cmplGfx/lib/image.transform.ci:29: warn: uninitialized variable `.result`
cmplGfx/lib/image.transform.ci:46: debug: adding temporary variable vec := vec4f(x, y, 0, 1)
cmplGfx/lib/image.transform.ci:54: debug: adding temporary variable lhs := scale(vec4f(Image.width(src), Image.height(src), 0, 0), 1)
cmplGfx/lib/image.transform.ci:54: debug: adding temporary variable direction := vec4f(Image.width(src), Image.height(src), 0, 0)
cmplGfx/lib/image.transform.ci:54: warn: uninitialized variable `.result`
cmplGfx/lib/image.transform.ci:54: warn: uninitialized variable `.result`
cmplGfx/lib/image.transform.ci:57: debug: adding temporary variable vec := vec4f(x, y, 0, 1)
cmplGfx/lib/image.transform.ci:58: debug: adding temporary variable vec := Image.tex(src, t.x, t.y)
cmplGfx/lib/image.transform.ci:137: warn: uninitialized variable `.result`
cmplGfx/lib/image.transform.ci:138: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplGfx/lib/camera.ci:41: debug: adding temporary variable v := sub(target, position)
cmplGfx/lib/camera.ci:42: debug: adding temporary variable v := cross(up, forward)
cmplGfx/lib/camera.ci:63: debug: adding temporary variable lhs := projection(fov, asp, n, f)
cmplGfx/lib/camera.ci:63: warn: uninitialized variable `.result`
cmplGfx/lib/camera.ci:63: debug: adding temporary variable rhs := matrix(camera)
cmplGfx/lib/camera.ci:63: warn: uninitialized variable `.result`
cmplGfx/lib/camera.ci:63: warn: uninitialized variable `.result`
cmplGfx/lib/camera.ci:78: warn: uninitialized variable `.result`
cmplGfx/lib/camera.ci:79: debug: adding temporary variable v := dp3(matrix, camera.forward)
cmplGfx/lib/camera.ci:80: debug: adding temporary variable v := dp3(matrix, camera.right)
cmplGfx/lib/window.ci:349: warn: uninitialized variable `.result`
cmplGfx/lib/window.ci:379: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplGfx/lib/micro.ui.core.ci:465: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:480: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplGfx/lib/micro.ui.core.ci:551: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:559: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplGfx/lib/micro.ui.core.ci:1060: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1067: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1072: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1077: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1151: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1157: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1169: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1175: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1181: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplGfx/lib/micro.ui.core.ci:1255: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1265: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1284: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1296: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1297: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1301: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1302: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.core.ci:1306: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:719: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:735: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:738: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:739: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:740: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:828: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:831: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:848: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:854: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:885: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:990: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:997: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:1020: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:1019: warn: uninitialized variable `.result`
cmplGfx/lib/micro.ui.ci:1025: warn: uninitialized variable `.result`
cmplStd/test/lang/init.member.ci:34: warn: using default type initializer: RecordMemberTest.global := 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/test/lang/init.variable.ci:3: warn: using default type initializer: variable := 0
cmplStd/test/lang/useOperator.ci:76: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/useOperator.ci:77: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/useOperator.ci:122: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/useOperator.ci:123: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/useOperator.ci:168: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/useOperator.ci:169: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/useOperator.ci:214: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/useOperator.ci:215: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/stmt.for.ci:12: warn: using default type initializer: forIdx := 0
cmplStd/test/math/test.Complex.ci:3: warn: uninitialized variable `.result`
cmplStd/test/math/test.Complex.ci:4: warn: uninitialized variable `.result`
cmplStd/test/math/test.Complex.ci:5: warn: uninitialized variable `.result`
cmplStd/test/math/test.Complex.ci:6: warn: uninitialized variable `.result`

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 160
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, cast: const variable)
.field offset: int32 (size: 4, cast: const variable)
.field base: function (size: 0, cast: static const inline)
.field file: function (size: 0, cast: static const inline)
.field line: function (size: 0, cast: static const inline)
.field name: function (size: 0, cast: static const inline)
.field size: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:42: referenced as `typename`
	cmplStd/test/lang/reflect.ci:41: referenced as `typename`
	cmplStd/test/lang/reflect.ci:38: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:35: referenced as `typename`
	cmplStd/test/lang/reflect.ci:34: referenced as `typename`
	cmplStd/test/lang/reflect.ci:31: referenced as `typename`
	cmplStd/test/lang/reflect.ci:30: referenced as `typename`
	cmplStd/test/lang/reflect.ci:18: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:92: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:91: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:90: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:89: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:87: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:86: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:85: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:84: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:83: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:82: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:81: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:80: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:79: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:78: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:77: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:76: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:75: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:68: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:48: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:32: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:25: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:19: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:3: referenced as `typename`
	cmplGfx/lib/color.matrix.ci:3: referenced as `typename`
	cmplGfx/lib/color.lookup.ci:3: referenced as `typename`
	cmplGfx/lib/image.blur.ci:3: referenced as `typename`
	cmplGfx/lib/image.transform.ci:3: referenced as `typename`
	cmplGfx/lib/image.blend.ci:102: referenced as `typename`
	cmplGfx/lib/image.blend.ci:85: referenced as `typename`
	cmplGfx/lib/image.blend.ci:68: referenced as `typename`
	cmplGfx/lib/image.blend.ci:54: referenced as `typename`
	cmplGfx/lib/image.blend.ci:3: referenced as `typename`
	cmplGfx/lib/image.draw.rect.ci:3: referenced as `typename`
	cmplGfx/lib/image.draw.ci:1: referenced as `typename`
	cmplGfx/lib/image.ci:19: referenced as `typename`
	cmplGfx/lib/image.ci:11: referenced as `typename`
	cmplGfx/lib/image.ci:6: referenced as `typename`
	cmplGfx/lib/color.ci:168: referenced as `typename`
	cmplFile/lib.ci:16: referenced as `typename`
	cmplStd/lib/text/cstr.ci:119: referenced as `typename`
	cmplStd/lib/math/Math.ci:1003: referenced as `typename`
	cmplStd/lib/math/Math.ci:986: referenced as `typename`
	cmplStd/lib/math/Math.ci:964: referenced as `typename`
	cmplStd/lib/math/Math.ci:944: referenced as `typename`
	cmplStd/lib/math/Math.ci:931: referenced as `typename`
	cmplStd/lib/math/Math.ci:911: referenced as `typename`
	cmplStd/lib/math/Math.ci:901: referenced as `typename`
	cmplStd/lib/math/Math.ci:890: referenced as `typename`
	cmplStd/lib/math/Math.ci:866: referenced as `typename`
	cmplStd/lib/math/Math.ci:688: referenced as `typename`
	cmplStd/lib/math/Math.ci:608: referenced as `typename`
	cmplStd/lib/math/Math.ci:597: referenced as `typename`
	cmplStd/lib/math/Math.ci:533: referenced as `typename`
	cmplStd/lib/math/Math.ci:522: referenced as `typename`
	cmplStd/lib/math/Math.ci:466: referenced as `typename`
	cmplStd/lib/math/Math.ci:445: referenced as `typename`
	cmplStd/lib/math/Math.ci:398: referenced as `typename`
	cmplStd/lib/math/Bits.ci:490: referenced as `typename`
	cmplStd/lib/math/Bits.ci:472: referenced as `typename`
	cmplStd/lib/math/Bits.ci:453: referenced as `typename`
	cmplStd/lib/math/Bits.ci:434: referenced as `typename`
	cmplStd/lib/math/Bits.ci:390: referenced as `typename`
	cmplStd/lib/math/Bits.ci:371: referenced as `typename`
	cmplStd/lib/math/Bits.ci:281: referenced as `typename`
	cmplStd/lib/math/Bits.ci:240: referenced as `typename`
	cmplStd/lib/math/Bits.ci:151: referenced as `typename`
	cmplStd/lib/math/Bits.ci:111: referenced as `typename`
	cmplStd/lib/math/Bits.ci:71: referenced as `typename`
	cmplStd/lib/math/Bits.ci:61: referenced as `typename`
	cmplStd/lib/math/Bits.ci:51: referenced as `typename`
	cmplStd/lib/math/Bits.ci:41: referenced as `typename`
	cmplStd/lib.ci:16: referenced as `typename`
	cmplStd/lib.ci:14: referenced as `typename`
	cmplStd/lib.ci:14: referenced as `typename`
	internal usages: 12
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'size'
.owner: typename
.doc: '@builtin'
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `size`
	cmplStd/test/lang/reflect.ci:46: referenced as `size`
	cmplStd/test/lang/reflect.ci:40: referenced as `size`
	cmplStd/test/lang/reflect.ci:33: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'offset'
.print: '@%06x'
.owner: typename
.doc: '@builtin'
.usages:
	cmplStd/test/lang/reflect.ci:49: referenced as `offset`
	cmplStd/test/lang/reflect.ci:45: referenced as `offset`
	cmplStd/test/lang/reflect.ci:39: referenced as `offset`
	cmplStd/test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'base'
.owner: typename
.param .result: typename (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(2)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `base`
	cmplStd/test/lang/reflect.ci:44: referenced as `base`
	cmplStd/test/lang/reflect.ci:37: referenced as `base`
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(3)
.usages:
	cmplStd/test/lang/reflect.ci:41: referenced as `file`
	cmplStd/test/lang/reflect.ci:34: referenced as `file`
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(4)
.usages:
	cmplStd/test/lang/reflect.ci:42: referenced as `line`
	cmplStd/test/lang/reflect.ci:35: referenced as `line`
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(5)
.usages:
	cmplStd/test/lang/reflect.ci:38: referenced as `name`
	cmplStd/test/lang/reflect.ci:31: referenced as `name`
}
typename.size(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'size'
.owner: typename
.param .result: int32 (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(6)
.usages:
	cmplStd/lib.ci:14: referenced as `size`
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'void'
.doc: '@builtin'
.usages:
	cmplStd/test/lang/init.method.ci:90: referenced as `void`
	cmplStd/test/lang/init.method.ci:84: referenced as `void`
	cmplStd/test/lang/init.method.ci:57: referenced as `void`
	cmplStd/test/lang/init.method.ci:47: referenced as `void`
	cmplStd/test/lang/init.method.ci:40: referenced as `void`
	cmplStd/test/lang/init.method.ci:32: referenced as `void`
	cmplStd/test/lang/init.method.ci:25: referenced as `void`
	cmplStd/test/lang/init.method.ci:18: referenced as `void`
	cmplStd/test/lang/init.method.ci:10: referenced as `void`
	cmplStd/test/lang/reflect.ci:3: referenced as `void`
	cmplStd/test/lang/function.ci:4: referenced as `void`
	cmplStd/test/lang/init.reference.ci:75: referenced as `void`
	cmplStd/test/lang/init.reference.ci:55: referenced as `void`
	cmplStd/test/lang/init.reference.ci:35: referenced as `void`
	cmplStd/test/lang/tryExec.ci:35: referenced as `void`
	cmplStd/test/lang/tryExec.ci:30: referenced as `void`
	cmplStd/test/lang/tryExec.ci:16: referenced as `void`
	cmplStd/test/lang/tryExec.ci:12: referenced as `void`
	cmplStd/test/lang/tryExec.ci:6: referenced as `void`
	cmplStd/test/lang/tryExec.ci:3: referenced as `void`
	cmplGfx/lib/micro.ui.ci:1347: referenced as `void`
	cmplGfx/lib/micro.ui.ci:1078: referenced as `void`
	cmplGfx/lib/micro.ui.ci:1000: referenced as `void`
	cmplGfx/lib/micro.ui.ci:979: referenced as `void`
	cmplGfx/lib/micro.ui.ci:967: referenced as `void`
	cmplGfx/lib/micro.ui.ci:675: referenced as `void`
	cmplGfx/lib/micro.ui.ci:663: referenced as `void`
	cmplGfx/lib/micro.ui.ci:657: referenced as `void`
	cmplGfx/lib/micro.ui.ci:651: referenced as `void`
	cmplGfx/lib/micro.ui.ci:634: referenced as `void`
	cmplGfx/lib/micro.ui.ci:567: referenced as `void`
	cmplGfx/lib/micro.ui.ci:552: referenced as `void`
	cmplGfx/lib/micro.ui.ci:512: referenced as `void`
	cmplGfx/lib/micro.ui.ci:498: referenced as `void`
	cmplGfx/lib/micro.ui.ci:416: referenced as `void`
	cmplGfx/lib/micro.ui.ci:361: referenced as `void`
	cmplGfx/lib/micro.ui.ci:341: referenced as `void`
	cmplGfx/lib/micro.ui.ci:316: referenced as `void`
	cmplGfx/lib/micro.ui.ci:298: referenced as `void`
	cmplGfx/lib/micro.ui.ci:221: referenced as `void`
	cmplGfx/lib/micro.ui.ci:141: referenced as `void`
	cmplGfx/lib/micro.ui.ci:87: referenced as `void`
	cmplGfx/lib/micro.ui.ci:14: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:1283: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:1244: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:1243: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:1224: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:1185: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:1029: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:974: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:889: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:804: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:803: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:618: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:609: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:578: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:531: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:383: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:382: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:363: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:347: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:344: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:275: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:265: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:139: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:134: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:119: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:113: referenced as `void`
	cmplGfx/lib/micro.ui.core.ci:80: referenced as `void`
	cmplGfx/lib/window.ci:176: referenced as `void`
	cmplGfx/lib/window.ci:165: referenced as `void`
	cmplGfx/lib/window.ci:160: referenced as `void`
	cmplGfx/lib/window.ci:83: referenced as `void`
	cmplGfx/lib/window.ci:78: referenced as `void`
	cmplGfx/lib/window.ci:73: referenced as `void`
	cmplGfx/lib/window.ci:66: referenced as `void`
	cmplGfx/lib/window.ci:20: referenced as `void`
	cmplGfx/lib/window.ci:9: referenced as `void`
	cmplGfx/lib/camera.ci:72: referenced as `void`
	cmplGfx/lib/camera.ci:67: referenced as `void`
	cmplGfx/lib/color.matrix.ci:2: referenced as `void`
	cmplGfx/lib/color.lookup.ci:2: referenced as `void`
	cmplGfx/lib/image.blur.ci:2: referenced as `void`
	cmplGfx/lib/image.transform.ci:2: referenced as `void`
	cmplGfx/lib/image.blend.ci:159: referenced as `void`
	cmplGfx/lib/image.blend.ci:131: referenced as `void`
	cmplGfx/lib/image.blend.ci:119: referenced as `void`
	cmplGfx/lib/image.blend.ci:101: referenced as `void`
	cmplGfx/lib/image.blend.ci:84: referenced as `void`
	cmplGfx/lib/image.blend.ci:67: referenced as `void`
	cmplGfx/lib/image.blend.ci:53: referenced as `void`
	cmplGfx/lib/image.blend.ci:2: referenced as `void`
	cmplGfx/lib/image.draw.ci:20: referenced as `void`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `void`
	cmplGfx/lib/image.draw.line.ci:85: referenced as `void`
	cmplGfx/lib/image.draw.line.ci:79: referenced as `void`
	cmplGfx/lib/image.draw.line.ci:2: referenced as `void`
	cmplGfx/lib/image.draw.oval.ci:16: referenced as `void`
	cmplGfx/lib/image.draw.oval.ci:8: referenced as `void`
	cmplGfx/lib/image.draw.rrect.ci:131: referenced as `void`
	cmplGfx/lib/image.draw.rrect.ci:61: referenced as `void`
	cmplGfx/lib/image.draw.rrect.ci:2: referenced as `void`
	cmplGfx/lib/image.draw.rect.ci:73: referenced as `void`
	cmplGfx/lib/image.draw.rect.ci:65: referenced as `void`
	cmplGfx/lib/image.draw.rect.ci:31: referenced as `void`
	cmplGfx/lib/image.draw.rect.ci:2: referenced as `void`
	cmplGfx/lib/color.ci:143: referenced as `void`
	cmplGfx/lib/color.ci:128: referenced as `void`
	cmplGfx/lib/rect.ci:73: referenced as `void`
	cmplGfx/lib/rect.ci:68: referenced as `void`
	cmplGfx/lib/rect.ci:58: referenced as `void`
	cmplGfx/lib/rect.ci:50: referenced as `void`
	cmplGfx/lib/rect.ci:44: referenced as `void`
	cmplGfx/lib/rect.ci:38: referenced as `void`
	cmplGfx/lib/rect.ci:33: referenced as `void`
	cmplGfx/lib/rect.ci:27: referenced as `void`
	cmplGfx/lib/rect.ci:22: referenced as `void`
	cmplGfx/lib/rect.ci:15: referenced as `void`
	cmplFile/lib/FileStream.ci:69: referenced as `void`
	cmplFile/lib/FileStream.ci:64: referenced as `void`
	cmplFile/lib/FileStream.ci:44: referenced as `void`
	cmplFile/lib/FileStream.ci:38: referenced as `void`
	cmplFile/lib/FileStream.ci:28: referenced as `void`
	cmplFile/lib/FileStream.ci:24: referenced as `void`
	cmplFile/lib/FileStream.ci:19: referenced as `void`
	cmplFile/lib/FileStream.ci:9: referenced as `void`
	cmplStd/lib/math/Polynomial.ci:54: referenced as `void`
	cmplStd/lib/math/Polynomial.ci:14: referenced as `void`
	cmplStd/lib/text/encoding/Utf8.ci:53: referenced as `void`
	cmplStd/lib/text/encoding/Ascii.ci:21: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:190: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:129: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:124: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:41: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:16: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:72: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:67: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:64: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:52: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:19: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:179: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:175: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:149: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:113: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:56: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:53: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:48: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:7: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:5: referenced as `void`
	cmplStd/lib/lang/Debug.ci:59: referenced as `void`
	cmplStd/lib/lang/Debug.ci:55: referenced as `void`
	cmplStd/lib/lang/Debug.ci:55: referenced as `void`
	cmplStd/lib/lang/Debug.ci:29: referenced as `void`
	cmplStd/lib/lang/Debug.ci:29: referenced as `void`
	cmplStd/lib/lang/Debug.ci:27: referenced as `void`
	cmplStd/lib/lang/Debug.ci:27: referenced as `void`
	internal usages: 41
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.name: 'bool'
.print: '%d'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:299: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:281: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:280: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:279: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:278: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:277: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:276: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:275: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:258: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:257: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:256: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:255: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:254: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:253: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:252: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:235: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:234: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:233: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:232: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:231: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:230: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:229: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:212: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:211: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:210: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:209: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:208: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:207: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:206: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:189: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:188: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:187: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:186: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:185: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:184: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:183: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:166: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:165: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:164: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:163: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:162: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:161: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:160: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:143: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:142: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:141: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:140: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:139: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:138: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:137: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:120: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:119: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:118: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:117: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:116: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:115: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:114: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:97: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:96: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:95: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:94: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:93: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:92: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:91: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:74: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:73: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:72: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:71: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:70: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:69: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:68: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:51: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:50: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:49: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:48: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:47: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:46: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:45: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:28: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:27: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:26: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:25: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:24: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:23: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:22: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:19: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:18: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:17: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:8: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:7: referenced as `bool`
	cmplStd/test/lang/reflect.ci:4: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:76: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:56: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:36: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:1101: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:1096: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:1095: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:1094: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:1052: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:1029: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:949: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:897: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:895: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:870: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:861: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:839: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:807: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:804: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:777: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:763: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:763: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:677: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:641: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:614: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:604: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:604: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:601: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:557: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:537: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:533: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:406: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:366: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:354: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:353: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:348: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:336: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:333: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:282: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:246: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:230: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:217: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:199: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:196: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:122: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:111: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:96: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:69: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:65: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:44: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:39: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:36: referenced as `bool`
	cmplGfx/lib/micro.ui.ci:8: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1305: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1300: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1295: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1283: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1218: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1195: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1092: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1092: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1086: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:1085: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:749: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:718: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:692: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:659: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:643: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:628: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:599: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:598: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:593: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:489: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:430: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:429: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:383: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:331: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:298: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:278: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:260: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:255: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:238: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:235: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:215: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:210: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:205: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:200: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:189: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:174: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:172: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:170: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:168: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:159: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:157: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:155: referenced as `bool`
	cmplGfx/lib/micro.ui.core.ci:153: referenced as `bool`
	cmplGfx/lib/window.ci:310: referenced as `bool`
	cmplGfx/lib/window.ci:310: referenced as `bool`
	cmplGfx/lib/window.ci:304: referenced as `bool`
	cmplGfx/lib/window.ci:304: referenced as `bool`
	cmplGfx/lib/window.ci:298: referenced as `bool`
	cmplGfx/lib/window.ci:298: referenced as `bool`
	cmplGfx/lib/window.ci:292: referenced as `bool`
	cmplGfx/lib/window.ci:292: referenced as `bool`
	cmplGfx/lib/window.ci:285: referenced as `bool`
	cmplGfx/lib/window.ci:285: referenced as `bool`
	cmplGfx/lib/window.ci:279: referenced as `bool`
	cmplGfx/lib/window.ci:279: referenced as `bool`
	cmplGfx/lib/window.ci:273: referenced as `bool`
	cmplGfx/lib/window.ci:273: referenced as `bool`
	cmplGfx/lib/window.ci:267: referenced as `bool`
	cmplGfx/lib/window.ci:267: referenced as `bool`
	cmplGfx/lib/window.ci:86: referenced as `bool`
	cmplGfx/lib/color.lookup.ci:21: referenced as `bool`
	cmplGfx/lib/image.transform.ci:84: referenced as `bool`
	cmplGfx/lib/image.transform.ci:83: referenced as `bool`
	cmplGfx/lib/image.ci:31: referenced as `bool`
	cmplGfx/lib/color.ci:143: referenced as `bool`
	cmplGfx/lib/rect.ci:8: referenced as `bool`
	cmplGfx/lib/rect.ci:2: referenced as `bool`
	cmplFile/lib/FileStream.ci:90: referenced as `bool`
	cmplFile/lib/FileStream.ci:83: referenced as `bool`
	cmplStd/lib/math/Polynomial.ci:15: referenced as `bool`
	cmplStd/lib/text/stream/TextStream.ci:90: referenced as `bool`
	cmplStd/lib/text/Format.ci:16: referenced as `bool`
	cmplStd/lib/text/cstr.ci:46: referenced as `bool`
	cmplStd/lib/text/cstr.ci:36: referenced as `bool`
	cmplStd/lib/time/Datetime.ci:102: referenced as `bool`
	cmplStd/lib/time/Datetime.ci:95: referenced as `bool`
	cmplStd/lib/time/Timezone.ci:27: referenced as `bool`
	cmplStd/lib/time/Timezone.ci:12: referenced as `bool`
	cmplStd/lib/time/Timezone.ci:7: referenced as `bool`
	cmplStd/lib/time/Timezone.ci:4: referenced as `bool`
	cmplStd/lib/time/Timestamp.ci:37: referenced as `bool`
	cmplStd/lib/time/Timestamp.ci:32: referenced as `bool`
	cmplStd/lib/math/Fixed.ci:116: referenced as `bool`
	cmplStd/lib/math/Fixed.ci:103: referenced as `bool`
	cmplStd/lib/math/Math.ci:40: referenced as `bool`
	cmplStd/lib/math/Math.ci:34: referenced as `bool`
	cmplStd/lib/math/Math.ci:29: referenced as `bool`
	cmplStd/lib/math/Math.ci:23: referenced as `bool`
	cmplStd/lib/lang/Debug.ci:55: referenced as `bool`
	cmplStd/lib/lang/Debug.ci:29: referenced as `bool`
	cmplStd/lib/lang/Debug.ci:27: referenced as `bool`
	cmplStd/lib.ci:4: referenced as `bool`
	internal usages: 6
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'char'
.print: '%c'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:44: referenced as `char`
	cmplStd/test/lang/useOperator.ci:43: referenced as `char`
	cmplStd/test/lang/useOperator.ci:42: referenced as `char`
	cmplStd/test/lang/useOperator.ci:41: referenced as `char`
	cmplStd/test/lang/useOperator.ci:40: referenced as `char`
	cmplStd/test/lang/useOperator.ci:39: referenced as `char`
	cmplStd/test/lang/useOperator.ci:38: referenced as `char`
	cmplStd/test/lang/useOperator.ci:37: referenced as `char`
	cmplStd/test/lang/useOperator.ci:36: referenced as `char`
	cmplStd/test/lang/useOperator.ci:35: referenced as `char`
	cmplStd/test/lang/useOperator.ci:34: referenced as `char`
	cmplStd/test/lang/useOperator.ci:33: referenced as `char`
	cmplStd/test/lang/useOperator.ci:32: referenced as `char`
	cmplStd/test/lang/useOperator.ci:31: referenced as `char`
	cmplStd/test/lang/useOperator.ci:30: referenced as `char`
	cmplStd/test/lang/reflect.ci:41: referenced as `char`
	cmplStd/test/lang/reflect.ci:38: referenced as `char`
	cmplStd/test/lang/reflect.ci:34: referenced as `char`
	cmplStd/test/lang/reflect.ci:31: referenced as `char`
	cmplStd/test/lang/reflect.ci:5: referenced as `char`
	cmplStd/test/lang/init.reference.ci:77: referenced as `char`
	cmplStd/test/lang/init.reference.ci:57: referenced as `char`
	cmplStd/test/lang/init.reference.ci:37: referenced as `char`
	cmplStd/test/lang/tryExec.ci:18: referenced as `char`
	cmplStd/test/lang/emit.ci:30: referenced as `char`
	cmplGfx/lib/micro.ui.ci:853: referenced as `char`
	cmplGfx/lib/micro.ui.ci:836: referenced as `char`
	cmplGfx/lib/micro.ui.ci:749: referenced as `char`
	cmplGfx/lib/micro.ui.ci:748: referenced as `char`
	cmplGfx/lib/micro.ui.ci:691: referenced as `char`
	cmplGfx/lib/micro.ui.ci:486: referenced as `char`
	cmplGfx/lib/micro.ui.ci:317: referenced as `char`
	cmplGfx/lib/micro.ui.ci:283: referenced as `char`
	cmplGfx/lib/micro.ui.ci:182: referenced as `char`
	cmplGfx/lib/micro.ui.ci:142: referenced as `char`
	cmplGfx/lib/micro.ui.ci:29: referenced as `char`
	cmplGfx/lib/micro.ui.ci:27: referenced as `char`
	cmplGfx/lib/micro.ui.ci:21: referenced as `char`
	cmplGfx/lib/micro.ui.ci:6: referenced as `char`
	cmplGfx/lib/micro.ui.core.ci:363: referenced as `char`
	cmplGfx/lib/micro.ui.core.ci:363: referenced as `char`
	cmplGfx/lib/micro.ui.core.ci:134: referenced as `char`
	cmplGfx/lib/micro.ui.core.ci:119: referenced as `char`
	cmplGfx/lib/micro.ui.core.ci:113: referenced as `char`
	cmplGfx/lib/window.ci:355: referenced as `char`
	cmplGfx/lib/window.ci:127: referenced as `char`
	cmplGfx/lib/window.ci:105: referenced as `char`
	cmplGfx/lib/mesh.ci:2: referenced as `char`
	cmplGfx/lib/image.transform.ci:147: referenced as `char`
	cmplGfx/lib/image.transform.ci:144: referenced as `char`
	cmplGfx/lib/image.transform.ci:136: referenced as `char`
	cmplGfx/lib/image.draw.ci:20: referenced as `char`
	cmplGfx/lib/image.ci:28: referenced as `char`
	cmplGfx/lib/image.ci:5: referenced as `char`
	cmplFile/lib/FileStream.ci:90: referenced as `char`
	cmplFile/lib/FileStream.ci:83: referenced as `char`
	cmplFile/lib/FileStream.ci:76: referenced as `char`
	cmplStd/lib/text/encoding/binary/Base64.ci:163: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:134: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:127: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:120: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:113: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:106: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:99: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:85: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:84: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:78: referenced as `char`
	cmplStd/lib/text/Format.ci:563: referenced as `char`
	cmplStd/lib/text/Format.ci:545: referenced as `char`
	cmplStd/lib/text/Format.ci:541: referenced as `char`
	cmplStd/lib/text/Format.ci:536: referenced as `char`
	cmplStd/lib/text/Format.ci:527: referenced as `char`
	cmplStd/lib/text/Format.ci:522: referenced as `char`
	cmplStd/lib/text/Format.ci:508: referenced as `char`
	cmplStd/lib/text/Format.ci:507: referenced as `char`
	cmplStd/lib/text/Format.ci:507: referenced as `char`
	cmplStd/lib/text/Format.ci:501: referenced as `char`
	cmplStd/lib/text/Format.ci:501: referenced as `char`
	cmplStd/lib/text/Format.ci:320: referenced as `char`
	cmplStd/lib/text/Format.ci:313: referenced as `char`
	cmplStd/lib/text/Format.ci:313: referenced as `char`
	cmplStd/lib/text/Format.ci:311: referenced as `char`
	cmplStd/lib/text/Format.ci:310: referenced as `char`
	cmplStd/lib/text/Format.ci:309: referenced as `char`
	cmplStd/lib/text/Format.ci:308: referenced as `char`
	cmplStd/lib/text/Format.ci:307: referenced as `char`
	cmplStd/lib/text/Format.ci:306: referenced as `char`
	cmplStd/lib/text/Format.ci:305: referenced as `char`
	cmplStd/lib/text/Format.ci:304: referenced as `char`
	cmplStd/lib/text/Format.ci:303: referenced as `char`
	cmplStd/lib/text/Format.ci:302: referenced as `char`
	cmplStd/lib/text/Format.ci:279: referenced as `char`
	cmplStd/lib/text/Format.ci:276: referenced as `char`
	cmplStd/lib/text/Format.ci:273: referenced as `char`
	cmplStd/lib/text/Format.ci:270: referenced as `char`
	cmplStd/lib/text/Format.ci:267: referenced as `char`
	cmplStd/lib/text/Format.ci:264: referenced as `char`
	cmplStd/lib/text/Format.ci:261: referenced as `char`
	cmplStd/lib/text/Format.ci:258: referenced as `char`
	cmplStd/lib/text/Format.ci:255: referenced as `char`
	cmplStd/lib/text/Format.ci:184: referenced as `char`
	cmplStd/lib/text/Format.ci:170: referenced as `char`
	cmplStd/lib/text/Format.ci:127: referenced as `char`
	cmplStd/lib/text/Format.ci:112: referenced as `char`
	cmplStd/lib/text/Format.ci:109: referenced as `char`
	cmplStd/lib/text/Format.ci:108: referenced as `char`
	cmplStd/lib/text/Format.ci:107: referenced as `char`
	cmplStd/lib/text/Format.ci:87: referenced as `char`
	cmplStd/lib/text/Format.ci:87: referenced as `char`
	cmplStd/lib/text/Format.ci:73: referenced as `char`
	cmplStd/lib/text/Format.ci:19: referenced as `char`
	cmplStd/lib/text/Format.ci:7: referenced as `char`
	cmplStd/lib/text/Format.ci:4: referenced as `char`
	cmplStd/lib/text/cstr.ci:133: referenced as `char`
	cmplStd/lib/text/cstr.ci:117: referenced as `char`
	cmplStd/lib/text/cstr.ci:105: referenced as `char`
	cmplStd/lib/text/cstr.ci:105: referenced as `char`
	cmplStd/lib/text/cstr.ci:102: referenced as `char`
	cmplStd/lib/text/cstr.ci:102: referenced as `char`
	cmplStd/lib/text/cstr.ci:100: referenced as `char`
	cmplStd/lib/text/cstr.ci:100: referenced as `char`
	cmplStd/lib/text/cstr.ci:98: referenced as `char`
	cmplStd/lib/text/cstr.ci:98: referenced as `char`
	cmplStd/lib/text/cstr.ci:96: referenced as `char`
	cmplStd/lib/text/cstr.ci:96: referenced as `char`
	cmplStd/lib/text/cstr.ci:88: referenced as `char`
	cmplStd/lib/text/cstr.ci:88: referenced as `char`
	cmplStd/lib/text/cstr.ci:74: referenced as `char`
	cmplStd/lib/text/cstr.ci:74: referenced as `char`
	cmplStd/lib/text/cstr.ci:73: referenced as `char`
	cmplStd/lib/text/cstr.ci:73: referenced as `char`
	cmplStd/lib/text/cstr.ci:61: referenced as `char`
	cmplStd/lib/text/cstr.ci:61: referenced as `char`
	cmplStd/lib/text/cstr.ci:61: referenced as `char`
	cmplStd/lib/text/cstr.ci:61: referenced as `char`
	cmplStd/lib/text/cstr.ci:46: referenced as `char`
	cmplStd/lib/text/cstr.ci:46: referenced as `char`
	cmplStd/lib/text/cstr.ci:46: referenced as `char`
	cmplStd/lib/text/cstr.ci:46: referenced as `char`
	cmplStd/lib/text/cstr.ci:36: referenced as `char`
	cmplStd/lib/text/cstr.ci:36: referenced as `char`
	cmplStd/lib/text/cstr.ci:36: referenced as `char`
	cmplStd/lib/text/cstr.ci:36: referenced as `char`
	cmplStd/lib/text/cstr.ci:25: referenced as `char`
	cmplStd/lib/text/cstr.ci:25: referenced as `char`
	cmplStd/lib/text/cstr.ci:15: referenced as `char`
	cmplStd/lib/text/cstr.ci:15: referenced as `char`
	cmplStd/lib/text/cstr.ci:4: referenced as `char`
	cmplStd/lib/time/Timezone.ci:22: referenced as `char`
	cmplStd/lib/time/Timezone.ci:3: referenced as `char`
	cmplStd/lib/lang/Debug.ci:59: referenced as `char`
	cmplStd/lib/lang/Debug.ci:55: referenced as `char`
	cmplStd/lib/lang/Debug.ci:53: referenced as `char`
	cmplStd/lib/lang/Debug.ci:27: referenced as `char`
	cmplStd/lib/lang/Debug.ci:22: referenced as `char`
	cmplStd/lib/lang/Debug.ci:19: referenced as `char`
	cmplStd/lib/lang/Debug.ci:16: referenced as `char`
	cmplStd/lib/lang/Debug.ci:13: referenced as `char`
	cmplStd/lib/lang/Debug.ci:10: referenced as `char`
	cmplStd/lib/lang/Debug.ci:7: referenced as `char`
	cmplStd/lib/lang/Debug.ci:4: referenced as `char`
	internal usages: 20
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'int8'
.print: '%d'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:67: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:66: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:65: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:64: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:63: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:62: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:61: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:60: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:59: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:58: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:57: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:56: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:55: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:54: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:53: referenced as `int8`
	cmplStd/test/lang/reflect.ci:6: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:78: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:58: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:38: referenced as `int8`
	cmplStd/lib/text/Format.ci:276: referenced as `int8`
	cmplStd/lib/math/Bits.ci:524: referenced as `int8`
	cmplStd/lib/math/Bits.ci:429: referenced as `int8`
	cmplStd/lib/math/Bits.ci:366: referenced as `int8`
	cmplStd/lib/math/Bits.ci:235: referenced as `int8`
	cmplStd/lib/math/Bits.ci:16: referenced as `int8`
	cmplStd/lib/math/Bits.ci:4: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.name: 'int16'
.print: '%d'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:113: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:112: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:111: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:110: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:109: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:108: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:107: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:106: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:105: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:104: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:103: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:102: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:101: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:100: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:99: referenced as `int16`
	cmplStd/test/lang/reflect.ci:7: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:79: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:59: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:39: referenced as `int16`
	cmplStd/lib/text/Format.ci:273: referenced as `int16`
	cmplStd/lib/math/Bits.ci:514: referenced as `int16`
	cmplStd/lib/math/Bits.ci:423: referenced as `int16`
	cmplStd/lib/math/Bits.ci:342: referenced as `int16`
	cmplStd/lib/math/Bits.ci:211: referenced as `int16`
	cmplStd/lib/math/Bits.ci:106: referenced as `int16`
	cmplStd/lib/math/Bits.ci:106: referenced as `int16`
	cmplStd/lib/math/Bits.ci:19: referenced as `int16`
	cmplStd/lib/math/Bits.ci:7: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.name: 'int32'
.print: '%d'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/math/test.Bits.ci:66: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:65: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:63: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:62: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:60: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:59: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:58: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:57: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:55: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:35: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:34: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:33: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:31: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:30: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:29: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:27: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:26: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:25: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:23: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:22: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:21: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:19: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:18: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:16: referenced as `int`
	cmplStd/test/math/test.Bits.ci:15: referenced as `int`
	cmplStd/test/math/test.Bits.ci:14: referenced as `int`
	cmplStd/test/math/test.Bits.ci:12: referenced as `int`
	cmplStd/test/math/test.Bits.ci:12: referenced as `int`
	cmplStd/test/math/test.Bits.ci:12: referenced as `int`
	cmplStd/test/math/test.Bits.ci:10: referenced as `int`
	cmplStd/test/math/test.Bits.ci:10: referenced as `int`
	cmplStd/test/math/test.Bits.ci:10: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:24: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:17: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:12: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:8: referenced as `int`
	cmplStd/test/lang/stmt.if.ci:26: referenced as `int`
	cmplStd/test/lang/useOperator.ci:159: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:158: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:157: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:156: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:155: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:154: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:153: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:152: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:151: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:150: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:149: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:148: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:147: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:146: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:145: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:5: referenced as `int32`
	cmplStd/test/lang/init.method.ci:90: referenced as `int`
	cmplStd/test/lang/init.method.ci:84: referenced as `int`
	cmplStd/test/lang/init.method.ci:57: referenced as `int`
	cmplStd/test/lang/init.method.ci:47: referenced as `int`
	cmplStd/test/lang/init.method.ci:40: referenced as `int`
	cmplStd/test/lang/init.method.ci:32: referenced as `int`
	cmplStd/test/lang/init.method.ci:25: referenced as `int`
	cmplStd/test/lang/init.method.ci:18: referenced as `int`
	cmplStd/test/lang/init.method.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:40: referenced as `int`
	cmplStd/test/lang/init.member.ci:37: referenced as `int`
	cmplStd/test/lang/init.member.ci:34: referenced as `int`
	cmplStd/test/lang/init.member.ci:19: referenced as `int`
	cmplStd/test/lang/init.member.ci:16: referenced as `int`
	cmplStd/test/lang/init.member.ci:13: referenced as `int`
	cmplStd/test/lang/init.member.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:6: referenced as `int`
	cmplStd/test/lang/init.member.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:50: referenced as `int`
	cmplStd/test/lang/reflect.ci:49: referenced as `int`
	cmplStd/test/lang/reflect.ci:46: referenced as `int`
	cmplStd/test/lang/reflect.ci:45: referenced as `int`
	cmplStd/test/lang/reflect.ci:42: referenced as `int`
	cmplStd/test/lang/reflect.ci:40: referenced as `int`
	cmplStd/test/lang/reflect.ci:39: referenced as `int`
	cmplStd/test/lang/reflect.ci:35: referenced as `int`
	cmplStd/test/lang/reflect.ci:33: referenced as `int`
	cmplStd/test/lang/reflect.ci:32: referenced as `int`
	cmplStd/test/lang/reflect.ci:27: referenced as `int32`
	cmplStd/test/lang/reflect.ci:20: referenced as `int`
	cmplStd/test/lang/reflect.ci:19: referenced as `int`
	cmplStd/test/lang/reflect.ci:18: referenced as `int`
	cmplStd/test/lang/reflect.ci:17: referenced as `int`
	cmplStd/test/lang/reflect.ci:16: referenced as `int`
	cmplStd/test/lang/reflect.ci:15: referenced as `int`
	cmplStd/test/lang/reflect.ci:14: referenced as `int`
	cmplStd/test/lang/reflect.ci:13: referenced as `int`
	cmplStd/test/lang/reflect.ci:12: referenced as `int`
	cmplStd/test/lang/reflect.ci:11: referenced as `int`
	cmplStd/test/lang/reflect.ci:10: referenced as `int`
	cmplStd/test/lang/reflect.ci:9: referenced as `int`
	cmplStd/test/lang/reflect.ci:8: referenced as `int32`
	cmplStd/test/lang/reflect.ci:8: referenced as `int`
	cmplStd/test/lang/reflect.ci:7: referenced as `int`
	cmplStd/test/lang/reflect.ci:6: referenced as `int`
	cmplStd/test/lang/reflect.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:4: referenced as `int`
	cmplStd/test/lang/reflect.ci:3: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:30: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:24: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:18: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:12: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:3: referenced as `int`
	cmplStd/test/lang/init.reference.ci:80: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:60: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:40: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:4: referenced as `int32`
	cmplStd/test/lang/pointer.ci:14: referenced as `int32`
	cmplStd/test/lang/pointer.ci:13: referenced as `int32`
	cmplStd/test/lang/pointer.ci:12: referenced as `int32`
	cmplStd/test/lang/pointer.ci:11: referenced as `int32`
	cmplStd/test/lang/pointer.ci:10: referenced as `int32`
	cmplStd/test/lang/pointer.ci:7: referenced as `int32`
	cmplStd/test/lang/pointer.ci:6: referenced as `int32`
	cmplStd/test/lang/pointer.ci:5: referenced as `int32`
	cmplStd/test/lang/pointer.ci:4: referenced as `int32`
	cmplStd/test/lang/pointer.ci:3: referenced as `int32`
	cmplStd/test/lang/pointer.ci:1: referenced as `int32`
	cmplStd/test/lang/tryExec.ci:45: referenced as `int`
	cmplStd/test/lang/tryExec.ci:44: referenced as `int`
	cmplStd/test/lang/tryExec.ci:43: referenced as `int`
	cmplStd/test/lang/tryExec.ci:42: referenced as `int`
	cmplStd/test/lang/tryExec.ci:41: referenced as `int`
	cmplStd/test/lang/tryExec.ci:40: referenced as `int`
	cmplStd/test/lang/tryExec.ci:39: referenced as `int`
	cmplStd/test/lang/tryExec.ci:32: referenced as `int`
	cmplStd/test/lang/tryExec.ci:31: referenced as `int32`
	cmplStd/test/lang/tryExec.ci:20: referenced as `int`
	cmplStd/test/lang/tryExec.ci:19: referenced as `int`
	cmplStd/test/lang/tryExec.ci:13: referenced as `int`
	cmplStd/test/lang/memory.ci:4: referenced as `int`
	cmplStd/test/lang/memory.ci:3: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:5: referenced as `int32`
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:13: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:12: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:11: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:10: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/emit.ci:30: referenced as `int`
	cmplStd/test/lang/emit.ci:25: referenced as `int32`
	cmplStd/test/lang/emit.ci:23: referenced as `int32`
	cmplStd/test/lang/emit.ci:19: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:7: referenced as `int32`
	cmplStd/test/lang/emit.ci:6: referenced as `int32`
	cmplStd/test/lang/emit.ci:3: referenced as `int32`
	cmplGfx/lib/micro.ui.ci:1294: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1294: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1294: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1294: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1294: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1268: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1161: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1160: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1101: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1101: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1101: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1101: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1098: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1097: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1091: referenced as `int32`
	cmplGfx/lib/micro.ui.ci:1090: referenced as `int32`
	cmplGfx/lib/micro.ui.ci:1089: referenced as `int32`
	cmplGfx/lib/micro.ui.ci:1087: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1063: referenced as `int`
	cmplGfx/lib/micro.ui.ci:1040: referenced as `int`
	cmplGfx/lib/micro.ui.ci:993: referenced as `int`
	cmplGfx/lib/micro.ui.ci:993: referenced as `int`
	cmplGfx/lib/micro.ui.ci:983: referenced as `int`
	cmplGfx/lib/micro.ui.ci:983: referenced as `int`
	cmplGfx/lib/micro.ui.ci:951: referenced as `int`
	cmplGfx/lib/micro.ui.ci:950: referenced as `int`
	cmplGfx/lib/micro.ui.ci:867: referenced as `int`
	cmplGfx/lib/micro.ui.ci:865: referenced as `int`
	cmplGfx/lib/micro.ui.ci:863: referenced as `int`
	cmplGfx/lib/micro.ui.ci:801: referenced as `int`
	cmplGfx/lib/micro.ui.ci:785: referenced as `int`
	cmplGfx/lib/micro.ui.ci:771: referenced as `int`
	cmplGfx/lib/micro.ui.ci:691: referenced as `int`
	cmplGfx/lib/micro.ui.ci:584: referenced as `int`
	cmplGfx/lib/micro.ui.ci:583: referenced as `int`
	cmplGfx/lib/micro.ui.ci:582: referenced as `int`
	cmplGfx/lib/micro.ui.ci:579: referenced as `int`
	cmplGfx/lib/micro.ui.ci:544: referenced as `int`
	cmplGfx/lib/micro.ui.ci:513: referenced as `int`
	cmplGfx/lib/micro.ui.ci:502: referenced as `int`
	cmplGfx/lib/micro.ui.ci:472: referenced as `int`
	cmplGfx/lib/micro.ui.ci:471: referenced as `int`
	cmplGfx/lib/micro.ui.ci:470: referenced as `int`
	cmplGfx/lib/micro.ui.ci:469: referenced as `int`
	cmplGfx/lib/micro.ui.ci:468: referenced as `int`
	cmplGfx/lib/micro.ui.ci:466: referenced as `int`
	cmplGfx/lib/micro.ui.ci:465: referenced as `int`
	cmplGfx/lib/micro.ui.ci:461: referenced as `int`
	cmplGfx/lib/micro.ui.ci:460: referenced as `int`
	cmplGfx/lib/micro.ui.ci:459: referenced as `int`
	cmplGfx/lib/micro.ui.ci:458: referenced as `int`
	cmplGfx/lib/micro.ui.ci:456: referenced as `int`
	cmplGfx/lib/micro.ui.ci:446: referenced as `int`
	cmplGfx/lib/micro.ui.ci:445: referenced as `int`
	cmplGfx/lib/micro.ui.ci:444: referenced as `int`
	cmplGfx/lib/micro.ui.ci:443: referenced as `int`
	cmplGfx/lib/micro.ui.ci:441: referenced as `int`
	cmplGfx/lib/micro.ui.ci:438: referenced as `int`
	cmplGfx/lib/micro.ui.ci:437: referenced as `int`
	cmplGfx/lib/micro.ui.ci:436: referenced as `int`
	cmplGfx/lib/micro.ui.ci:435: referenced as `int`
	cmplGfx/lib/micro.ui.ci:433: referenced as `int`
	cmplGfx/lib/micro.ui.ci:432: referenced as `int`
	cmplGfx/lib/micro.ui.ci:430: referenced as `int`
	cmplGfx/lib/micro.ui.ci:429: referenced as `int`
	cmplGfx/lib/micro.ui.ci:428: referenced as `int`
	cmplGfx/lib/micro.ui.ci:427: referenced as `int`
	cmplGfx/lib/micro.ui.ci:426: referenced as `int`
	cmplGfx/lib/micro.ui.ci:424: referenced as `int`
	cmplGfx/lib/micro.ui.ci:423: referenced as `int`
	cmplGfx/lib/micro.ui.ci:399: referenced as `int`
	cmplGfx/lib/micro.ui.ci:398: referenced as `int`
	cmplGfx/lib/micro.ui.ci:397: referenced as `int`
	cmplGfx/lib/micro.ui.ci:386: referenced as `int`
	cmplGfx/lib/micro.ui.ci:385: referenced as `int`
	cmplGfx/lib/micro.ui.ci:381: referenced as `int`
	cmplGfx/lib/micro.ui.ci:378: referenced as `int`
	cmplGfx/lib/micro.ui.ci:375: referenced as `int`
	cmplGfx/lib/micro.ui.ci:374: referenced as `int`
	cmplGfx/lib/micro.ui.ci:373: referenced as `int`
	cmplGfx/lib/micro.ui.ci:372: referenced as `int`
	cmplGfx/lib/micro.ui.ci:371: referenced as `int`
	cmplGfx/lib/micro.ui.ci:355: referenced as `int`
	cmplGfx/lib/micro.ui.ci:348: referenced as `int`
	cmplGfx/lib/micro.ui.ci:348: referenced as `int`
	cmplGfx/lib/micro.ui.ci:307: referenced as `int`
	cmplGfx/lib/micro.ui.ci:306: referenced as `int`
	cmplGfx/lib/micro.ui.ci:305: referenced as `int`
	cmplGfx/lib/micro.ui.ci:304: referenced as `int`
	cmplGfx/lib/micro.ui.ci:303: referenced as `int`
	cmplGfx/lib/micro.ui.ci:125: referenced as `int`
	cmplGfx/lib/micro.ui.ci:123: referenced as `int`
	cmplGfx/lib/micro.ui.ci:116: referenced as `int`
	cmplGfx/lib/micro.ui.ci:105: referenced as `int`
	cmplGfx/lib/micro.ui.ci:101: referenced as `int`
	cmplGfx/lib/micro.ui.ci:90: referenced as `int`
	cmplGfx/lib/micro.ui.ci:76: referenced as `int`
	cmplGfx/lib/micro.ui.ci:75: referenced as `int`
	cmplGfx/lib/micro.ui.ci:45: referenced as `int`
	cmplGfx/lib/micro.ui.ci:44: referenced as `int`
	cmplGfx/lib/micro.ui.ci:33: referenced as `int`
	cmplGfx/lib/micro.ui.ci:32: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1245: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1180: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1174: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1174: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1168: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1168: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1168: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1168: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1150: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1132: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1117: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1112: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1090: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1089: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1055: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1055: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1038: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1030: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:1013: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:974: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:955: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:932: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:930: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:899: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:898: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:897: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:896: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:895: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:892: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:891: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:890: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:889: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:870: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:847: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:845: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:814: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:813: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:812: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:811: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:810: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:807: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:806: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:805: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:804: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:770: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:769: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:767: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:766: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:759: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:758: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:757: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:756: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:755: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:754: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:753: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:752: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:751: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:750: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:678: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:667: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:660: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:645: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:644: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:644: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:644: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:634: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:620: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:612: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:600: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:584: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:584: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:584: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:584: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:578: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:578: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:572: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:567: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:554: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:547: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:544: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:529: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:513: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:493: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:429: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:419: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:412: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:410: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:408: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:406: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:403: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:402: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:401: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:400: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:399: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:393: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:347: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:336: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:332: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:232: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:229: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:215: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:186: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:184: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:182: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:180: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:178: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:176: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:163: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:161: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:148: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:147: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:119: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:96: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:81: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:80: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:73: referenced as `int32`
	cmplGfx/lib/micro.ui.core.ci:50: referenced as `int32`
	cmplGfx/lib/micro.ui.core.ci:30: referenced as `int`
	cmplGfx/lib/micro.ui.core.ci:27: referenced as `int`
	cmplGfx/lib/window.ci:356: referenced as `int`
	cmplGfx/lib/window.ci:353: referenced as `int`
	cmplGfx/lib/window.ci:215: referenced as `int`
	cmplGfx/lib/window.ci:214: referenced as `int`
	cmplGfx/lib/window.ci:208: referenced as `int`
	cmplGfx/lib/window.ci:207: referenced as `int`
	cmplGfx/lib/window.ci:206: referenced as `int`
	cmplGfx/lib/window.ci:206: referenced as `int`
	cmplGfx/lib/window.ci:206: referenced as `int`
	cmplGfx/lib/window.ci:206: referenced as `int`
	cmplGfx/lib/window.ci:206: referenced as `int`
	cmplGfx/lib/window.ci:194: referenced as `int`
	cmplGfx/lib/window.ci:193: referenced as `int`
	cmplGfx/lib/window.ci:193: referenced as `int32`
	cmplGfx/lib/window.ci:193: referenced as `int`
	cmplGfx/lib/window.ci:183: referenced as `int`
	cmplGfx/lib/window.ci:182: referenced as `int`
	cmplGfx/lib/window.ci:182: referenced as `int32`
	cmplGfx/lib/window.ci:182: referenced as `int`
	cmplGfx/lib/window.ci:170: referenced as `int`
	cmplGfx/lib/window.ci:168: referenced as `int32`
	cmplGfx/lib/window.ci:167: referenced as `int32`
	cmplGfx/lib/window.ci:165: referenced as `int`
	cmplGfx/lib/window.ci:165: referenced as `int`
	cmplGfx/lib/window.ci:160: referenced as `int`
	cmplGfx/lib/window.ci:160: referenced as `int`
	cmplGfx/lib/window.ci:125: referenced as `int`
	cmplGfx/lib/window.ci:95: referenced as `int`
	cmplGfx/lib/window.ci:95: referenced as `int`
	cmplGfx/lib/window.ci:95: referenced as `int`
	cmplGfx/lib/window.ci:95: referenced as `int`
	cmplGfx/lib/window.ci:95: referenced as `int`
	cmplGfx/lib/window.ci:90: referenced as `int32`
	cmplGfx/lib/window.ci:83: referenced as `int`
	cmplGfx/lib/window.ci:83: referenced as `int`
	cmplGfx/lib/window.ci:83: referenced as `int`
	cmplGfx/lib/window.ci:68: referenced as `int`
	cmplGfx/lib/window.ci:67: referenced as `int`
	cmplGfx/lib/window.ci:28: referenced as `int`
	cmplGfx/lib/window.ci:28: referenced as `int`
	cmplGfx/lib/window.ci:28: referenced as `int`
	cmplGfx/lib/window.ci:28: referenced as `int`
	cmplGfx/lib/window.ci:28: referenced as `int`
	cmplGfx/lib/window.ci:20: referenced as `int`
	cmplGfx/lib/window.ci:20: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:13: referenced as `int`
	cmplGfx/lib/window.ci:9: referenced as `int`
	cmplGfx/lib/window.ci:9: referenced as `int`
	cmplGfx/lib/window.ci:9: referenced as `int`
	cmplGfx/lib/window.ci:9: referenced as `int`
	cmplGfx/lib/window.ci:9: referenced as `int`
	cmplGfx/lib/color.matrix.ci:40: referenced as `int`
	cmplGfx/lib/color.matrix.ci:39: referenced as `int`
	cmplGfx/lib/color.matrix.ci:38: referenced as `int`
	cmplGfx/lib/color.matrix.ci:36: referenced as `int`
	cmplGfx/lib/color.matrix.ci:35: referenced as `int`
	cmplGfx/lib/color.matrix.ci:33: referenced as `int`
	cmplGfx/lib/color.matrix.ci:32: referenced as `int`
	cmplGfx/lib/color.matrix.ci:31: referenced as `int`
	cmplGfx/lib/color.matrix.ci:30: referenced as `int`
	cmplGfx/lib/color.matrix.ci:28: referenced as `int`
	cmplGfx/lib/color.matrix.ci:27: referenced as `int`
	cmplGfx/lib/color.matrix.ci:26: referenced as `int`
	cmplGfx/lib/color.matrix.ci:25: referenced as `int`
	cmplGfx/lib/color.matrix.ci:23: referenced as `int`
	cmplGfx/lib/color.matrix.ci:22: referenced as `int`
	cmplGfx/lib/color.matrix.ci:21: referenced as `int`
	cmplGfx/lib/color.matrix.ci:20: referenced as `int`
	cmplGfx/lib/color.lookup.ci:68: referenced as `int32`
	cmplGfx/lib/color.lookup.ci:67: referenced as `int32`
	cmplGfx/lib/color.lookup.ci:66: referenced as `int32`
	cmplGfx/lib/color.lookup.ci:64: referenced as `int32`
	cmplGfx/lib/color.lookup.ci:63: referenced as `int32`
	cmplGfx/lib/color.lookup.ci:62: referenced as `int32`
	cmplGfx/lib/color.lookup.ci:60: referenced as `int`
	cmplGfx/lib/color.lookup.ci:59: referenced as `int`
	cmplGfx/lib/color.lookup.ci:53: referenced as `int32`
	cmplGfx/lib/color.lookup.ci:48: referenced as `int32`
	cmplGfx/lib/color.lookup.ci:47: referenced as `int32`
	cmplGfx/lib/color.lookup.ci:32: referenced as `int`
	cmplGfx/lib/color.lookup.ci:31: referenced as `int`
	cmplGfx/lib/color.lookup.ci:22: referenced as `int`
	cmplGfx/lib/image.blur.ci:73: referenced as `int32`
	cmplGfx/lib/image.blur.ci:70: referenced as `int`
	cmplGfx/lib/image.blur.ci:69: referenced as `int`
	cmplGfx/lib/image.blur.ci:68: referenced as `int32`
	cmplGfx/lib/image.blur.ci:67: referenced as `int32`
	cmplGfx/lib/image.blur.ci:66: referenced as `int32`
	cmplGfx/lib/image.blur.ci:65: referenced as `int`
	cmplGfx/lib/image.blur.ci:64: referenced as `int`
	cmplGfx/lib/image.blur.ci:53: referenced as `int32`
	cmplGfx/lib/image.blur.ci:50: referenced as `int`
	cmplGfx/lib/image.blur.ci:49: referenced as `int`
	cmplGfx/lib/image.blur.ci:48: referenced as `int32`
	cmplGfx/lib/image.blur.ci:47: referenced as `int32`
	cmplGfx/lib/image.blur.ci:46: referenced as `int32`
	cmplGfx/lib/image.blur.ci:45: referenced as `int`
	cmplGfx/lib/image.blur.ci:44: referenced as `int`
	cmplGfx/lib/image.blur.ci:40: referenced as `int`
	cmplGfx/lib/image.blur.ci:39: referenced as `int`
	cmplGfx/lib/image.blur.ci:35: referenced as `int`
	cmplGfx/lib/image.blur.ci:30: referenced as `int`
	cmplGfx/lib/image.blur.ci:25: referenced as `int`
	cmplGfx/lib/image.blur.ci:24: referenced as `int32`
	cmplGfx/lib/image.blur.ci:2: referenced as `int`
	cmplGfx/lib/image.transform.ci:147: referenced as `int`
	cmplGfx/lib/image.transform.ci:147: referenced as `int`
	cmplGfx/lib/image.transform.ci:147: referenced as `int`
	cmplGfx/lib/image.transform.ci:144: referenced as `int`
	cmplGfx/lib/image.transform.ci:144: referenced as `int`
	cmplGfx/lib/image.transform.ci:144: referenced as `int`
	cmplGfx/lib/image.transform.ci:144: referenced as `int`
	cmplGfx/lib/image.transform.ci:136: referenced as `int`
	cmplGfx/lib/image.transform.ci:136: referenced as `int`
	cmplGfx/lib/image.transform.ci:136: referenced as `int`
	cmplGfx/lib/image.transform.ci:136: referenced as `int`
	cmplGfx/lib/image.transform.ci:82: referenced as `int`
	cmplGfx/lib/image.transform.ci:81: referenced as `int`
	cmplGfx/lib/image.transform.ci:69: referenced as `int`
	cmplGfx/lib/image.transform.ci:67: referenced as `int`
	cmplGfx/lib/image.transform.ci:67: referenced as `int`
	cmplGfx/lib/image.transform.ci:67: referenced as `int`
	cmplGfx/lib/image.transform.ci:64: referenced as `int`
	cmplGfx/lib/image.transform.ci:56: referenced as `int`
	cmplGfx/lib/image.transform.ci:55: referenced as `int`
	cmplGfx/lib/image.transform.ci:45: referenced as `int`
	cmplGfx/lib/image.transform.ci:44: referenced as `int`
	cmplGfx/lib/image.transform.ci:2: referenced as `int32`
	cmplGfx/lib/image.blend.ci:181: referenced as `int`
	cmplGfx/lib/image.blend.ci:179: referenced as `int`
	cmplGfx/lib/image.blend.ci:152: referenced as `int`
	cmplGfx/lib/image.blend.ci:151: referenced as `int`
	cmplGfx/lib/image.blend.ci:150: referenced as `int`
	cmplGfx/lib/image.blend.ci:149: referenced as `int`
	cmplGfx/lib/image.blend.ci:131: referenced as `int`
	cmplGfx/lib/image.blend.ci:131: referenced as `int`
	cmplGfx/lib/image.blend.ci:119: referenced as `int32`
	cmplGfx/lib/image.blend.ci:119: referenced as `int32`
	cmplGfx/lib/image.blend.ci:107: referenced as `int`
	cmplGfx/lib/image.blend.ci:101: referenced as `int32`
	cmplGfx/lib/image.blend.ci:101: referenced as `int32`
	cmplGfx/lib/image.blend.ci:89: referenced as `int32`
	cmplGfx/lib/image.blend.ci:84: referenced as `int32`
	cmplGfx/lib/image.blend.ci:84: referenced as `int32`
	cmplGfx/lib/image.blend.ci:84: referenced as `int32`
	cmplGfx/lib/image.blend.ci:72: referenced as `int`
	cmplGfx/lib/image.blend.ci:53: referenced as `int32`
	cmplGfx/lib/image.blend.ci:53: referenced as `int32`
	cmplGfx/lib/image.blend.ci:44: referenced as `int`
	cmplGfx/lib/image.blend.ci:43: referenced as `int`
	cmplGfx/lib/image.blend.ci:36: referenced as `int`
	cmplGfx/lib/image.blend.ci:35: referenced as `int`
	cmplGfx/lib/image.blend.ci:2: referenced as `int32`
	cmplGfx/lib/image.blend.ci:2: referenced as `int32`
	cmplGfx/lib/image.draw.ci:20: referenced as `int32`
	cmplGfx/lib/image.draw.ci:20: referenced as `int32`
	cmplGfx/lib/image.draw.ci:20: referenced as `int32`
	cmplGfx/lib/image.draw.line.ci:113: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:112: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:111: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:110: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:109: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:108: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:107: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:106: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:91: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:90: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:89: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:88: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:87: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:86: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:85: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:85: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:85: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:85: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:85: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:85: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:80: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:80: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:80: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:79: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:79: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:79: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:79: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:70: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:63: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:62: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:51: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:46: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:39: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:31: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:20: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:15: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:11: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:10: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.line.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `int`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `int`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `int`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `int`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:139: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:131: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:131: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:128: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:128: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:128: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:128: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:128: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:125: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:125: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:125: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:125: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:125: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:91: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:91: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:90: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:90: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:83: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:82: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:76: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:75: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:73: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:72: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:68: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:63: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:61: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:61: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:61: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:61: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:61: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:61: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:32: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:32: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:31: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:31: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:24: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:23: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:17: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:16: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:14: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:13: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:9: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:4: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rrect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:62: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:62: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:62: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:62: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:44: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:43: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:38: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:33: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:31: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:31: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:31: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:31: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:31: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:28: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:28: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:28: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:28: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:21: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:20: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:13: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:8: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:2: referenced as `int`
	cmplGfx/lib/image.draw.rect.ci:2: referenced as `int`
	cmplGfx/lib/image.ci:54: referenced as `int32`
	cmplGfx/lib/image.ci:54: referenced as `int32`
	cmplGfx/lib/image.ci:45: referenced as `int`
	cmplGfx/lib/image.ci:40: referenced as `int`
	cmplGfx/lib/image.ci:5: referenced as `int`
	cmplGfx/lib/image.ci:2: referenced as `int`
	cmplGfx/lib/image.ci:2: referenced as `int`
	cmplGfx/lib/image.ci:2: referenced as `int`
	cmplGfx/lib/color.ci:162: referenced as `int`
	cmplGfx/lib/color.ci:158: referenced as `int`
	cmplGfx/lib/color.ci:157: referenced as `int`
	cmplGfx/lib/color.ci:156: referenced as `int`
	cmplGfx/lib/color.ci:147: referenced as `int`
	cmplGfx/lib/color.ci:146: referenced as `int`
	cmplGfx/lib/color.ci:145: referenced as `int`
	cmplGfx/lib/color.ci:144: referenced as `int`
	cmplGfx/lib/color.ci:143: referenced as `int`
	cmplGfx/lib/color.ci:143: referenced as `int`
	cmplGfx/lib/color.ci:137: referenced as `int32`
	cmplGfx/lib/color.ci:136: referenced as `int32`
	cmplGfx/lib/color.ci:135: referenced as `int32`
	cmplGfx/lib/color.ci:134: referenced as `int32`
	cmplGfx/lib/color.ci:131: referenced as `int`
	cmplGfx/lib/color.ci:130: referenced as `int`
	cmplGfx/lib/color.ci:129: referenced as `int`
	cmplGfx/lib/color.ci:125: referenced as `int32`
	cmplGfx/lib/color.ci:123: referenced as `int32`
	cmplGfx/lib/color.ci:123: referenced as `int32`
	cmplGfx/lib/color.ci:121: referenced as `int32`
	cmplGfx/lib/color.ci:121: referenced as `int32`
	cmplGfx/lib/color.ci:104: referenced as `int`
	cmplGfx/lib/color.ci:85: referenced as `int`
	cmplGfx/lib/color.ci:84: referenced as `int`
	cmplGfx/lib/color.ci:83: referenced as `int`
	cmplGfx/lib/color.ci:82: referenced as `int`
	cmplGfx/lib/color.ci:81: referenced as `int`
	cmplGfx/lib/color.ci:76: referenced as `int32`
	cmplGfx/lib/color.ci:73: referenced as `int32`
	cmplGfx/lib/color.ci:71: referenced as `int32`
	cmplGfx/lib/color.ci:69: referenced as `int32`
	cmplGfx/lib/color.ci:67: referenced as `int32`
	cmplGfx/lib/color.ci:63: referenced as `int32`
	cmplGfx/lib/color.ci:63: referenced as `int32`
	cmplGfx/lib/color.ci:63: referenced as `int32`
	cmplGfx/lib/color.ci:63: referenced as `int32`
	cmplGfx/lib/color.ci:61: referenced as `int32`
	cmplGfx/lib/color.ci:61: referenced as `int32`
	cmplGfx/lib/color.ci:61: referenced as `int32`
	cmplGfx/lib/color.ci:61: referenced as `int32`
	cmplGfx/lib/color.ci:57: referenced as `int32`
	cmplGfx/lib/color.ci:57: referenced as `int32`
	cmplGfx/lib/color.ci:57: referenced as `int32`
	cmplGfx/lib/color.ci:57: referenced as `int32`
	cmplGfx/lib/color.ci:55: referenced as `int32`
	cmplGfx/lib/color.ci:55: referenced as `int32`
	cmplGfx/lib/color.ci:55: referenced as `int32`
	cmplGfx/lib/color.ci:53: referenced as `int32`
	cmplGfx/lib/color.ci:53: referenced as `int32`
	cmplGfx/lib/color.ci:53: referenced as `int32`
	cmplGfx/lib/color.ci:49: referenced as `int32`
	cmplGfx/lib/color.ci:49: referenced as `int32`
	cmplGfx/lib/color.ci:49: referenced as `int32`
	cmplGfx/lib/color.ci:45: referenced as `int32`
	cmplGfx/lib/color.ci:43: referenced as `int32`
	cmplGfx/lib/color.ci:39: referenced as `int32`
	cmplGfx/lib/color.ci:27: referenced as `int32`
	cmplGfx/lib/rect.ci:73: referenced as `int`
	cmplGfx/lib/rect.ci:68: referenced as `int`
	cmplGfx/lib/rect.ci:66: referenced as `int`
	cmplGfx/lib/rect.ci:66: referenced as `int`
	cmplGfx/lib/rect.ci:58: referenced as `int`
	cmplGfx/lib/rect.ci:50: referenced as `int`
	cmplGfx/lib/rect.ci:50: referenced as `int`
	cmplGfx/lib/rect.ci:50: referenced as `int`
	cmplGfx/lib/rect.ci:50: referenced as `int`
	cmplGfx/lib/rect.ci:44: referenced as `int`
	cmplGfx/lib/rect.ci:44: referenced as `int`
	cmplGfx/lib/rect.ci:38: referenced as `int`
	cmplGfx/lib/rect.ci:33: referenced as `int`
	cmplGfx/lib/rect.ci:27: referenced as `int`
	cmplGfx/lib/rect.ci:27: referenced as `int`
	cmplGfx/lib/rect.ci:22: referenced as `int`
	cmplGfx/lib/rect.ci:15: referenced as `int`
	cmplGfx/lib/rect.ci:8: referenced as `int`
	cmplGfx/lib/rect.ci:8: referenced as `int`
	cmplFile/lib/FileStream.ci:58: referenced as `int`
	cmplFile/lib/FileStream.ci:57: referenced as `int`
	cmplFile/lib/FileStream.ci:39: referenced as `int`
	cmplFile/lib/FileStream.ci:36: referenced as `int`
	cmplFile/lib/FileStream.ci:20: referenced as `int`
	cmplFile/lib/FileStream.ci:5: referenced as `int`
	cmplFile/lib.ci:11: referenced as `int`
	cmplFile/lib.ci:11: referenced as `int`
	cmplFile/lib.ci:2: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:179: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:166: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:156: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:147: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:137: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:136: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:134: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:133: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:125: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:116: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:107: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:98: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:89: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:80: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:79: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:72: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:69: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:60: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:59: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:16: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:6: referenced as `int`
	cmplStd/lib/text/encoding/Utf8.ci:55: referenced as `int`
	cmplStd/lib/text/encoding/Utf8.ci:8: referenced as `int`
	cmplStd/lib/text/encoding/Utf8.ci:4: referenced as `int`
	cmplStd/lib/text/encoding/Ascii.ci:23: referenced as `int`
	cmplStd/lib/text/encoding/Ascii.ci:6: referenced as `int`
	cmplStd/lib/text/encoding/Ascii.ci:4: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:169: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:162: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:160: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:159: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:136: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:113: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:103: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:97: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:86: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:80: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:71: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:62: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:54: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:47: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:46: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:32: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:20: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:18: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:14: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:13: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:10: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:9: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:172: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:170: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:168: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:135: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:128: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:121: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:114: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:107: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:100: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:98: referenced as `int32`
	cmplStd/lib/text/stream/TextStream.ci:25: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:16: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:169: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:161: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:150: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:144: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:140: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:130: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:126: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:123: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:122: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:121: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:105: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:104: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:80: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:78: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:76: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:26: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:23: referenced as `int`
	cmplStd/lib/text/Format.ci:563: referenced as `int`
	cmplStd/lib/text/Format.ci:563: referenced as `int`
	cmplStd/lib/text/Format.ci:563: referenced as `int`
	cmplStd/lib/text/Format.ci:507: referenced as `int`
	cmplStd/lib/text/Format.ci:501: referenced as `int`
	cmplStd/lib/text/Format.ci:426: referenced as `int`
	cmplStd/lib/text/Format.ci:422: referenced as `int`
	cmplStd/lib/text/Format.ci:321: referenced as `int`
	cmplStd/lib/text/Format.ci:314: referenced as `int`
	cmplStd/lib/text/Format.ci:313: referenced as `int`
	cmplStd/lib/text/Format.ci:313: referenced as `int`
	cmplStd/lib/text/Format.ci:279: referenced as `int`
	cmplStd/lib/text/Format.ci:276: referenced as `int`
	cmplStd/lib/text/Format.ci:273: referenced as `int`
	cmplStd/lib/text/Format.ci:270: referenced as `int32`
	cmplStd/lib/text/Format.ci:270: referenced as `int`
	cmplStd/lib/text/Format.ci:267: referenced as `int`
	cmplStd/lib/text/Format.ci:264: referenced as `int`
	cmplStd/lib/text/Format.ci:261: referenced as `int`
	cmplStd/lib/text/Format.ci:258: referenced as `int`
	cmplStd/lib/text/Format.ci:255: referenced as `int`
	cmplStd/lib/text/Format.ci:239: referenced as `int`
	cmplStd/lib/text/Format.ci:226: referenced as `int`
	cmplStd/lib/text/Format.ci:203: referenced as `int`
	cmplStd/lib/text/Format.ci:196: referenced as `int`
	cmplStd/lib/text/Format.ci:191: referenced as `int`
	cmplStd/lib/text/Format.ci:184: referenced as `int`
	cmplStd/lib/text/Format.ci:184: referenced as `int`
	cmplStd/lib/text/Format.ci:170: referenced as `int`
	cmplStd/lib/text/Format.ci:170: referenced as `int`
	cmplStd/lib/text/Format.ci:170: referenced as `int`
	cmplStd/lib/text/Format.ci:156: referenced as `int`
	cmplStd/lib/text/Format.ci:125: referenced as `int`
	cmplStd/lib/text/Format.ci:111: referenced as `int`
	cmplStd/lib/text/Format.ci:107: referenced as `int`
	cmplStd/lib/text/Format.ci:107: referenced as `int`
	cmplStd/lib/text/Format.ci:107: referenced as `int`
	cmplStd/lib/text/Format.ci:91: referenced as `int`
	cmplStd/lib/text/Format.ci:87: referenced as `int`
	cmplStd/lib/text/Format.ci:87: referenced as `int`
	cmplStd/lib/text/Format.ci:73: referenced as `int`
	cmplStd/lib/text/Format.ci:53: referenced as `int`
	cmplStd/lib/text/Format.ci:46: referenced as `int`
	cmplStd/lib/text/Format.ci:39: referenced as `int`
	cmplStd/lib/text/Format.ci:32: referenced as `int`
	cmplStd/lib/text/Format.ci:20: referenced as `int`
	cmplStd/lib/text/Format.ci:19: referenced as `int`
	cmplStd/lib/text/Format.ci:13: referenced as `int`
	cmplStd/lib/text/Format.ci:10: referenced as `int`
	cmplStd/lib/text/cstr.ci:132: referenced as `int`
	cmplStd/lib/text/cstr.ci:121: referenced as `int`
	cmplStd/lib/text/cstr.ci:93: referenced as `int`
	cmplStd/lib/text/cstr.ci:93: referenced as `int`
	cmplStd/lib/text/cstr.ci:88: referenced as `int`
	cmplStd/lib/text/cstr.ci:73: referenced as `int`
	cmplStd/lib/text/cstr.ci:63: referenced as `int`
	cmplStd/lib/text/cstr.ci:62: referenced as `int`
	cmplStd/lib/text/cstr.ci:61: referenced as `int`
	cmplStd/lib/text/cstr.ci:61: referenced as `int`
	cmplStd/lib/text/cstr.ci:52: referenced as `int`
	cmplStd/lib/text/cstr.ci:48: referenced as `int`
	cmplStd/lib/text/cstr.ci:47: referenced as `int`
	cmplStd/lib/text/cstr.ci:46: referenced as `int`
	cmplStd/lib/text/cstr.ci:37: referenced as `int`
	cmplStd/lib/text/cstr.ci:36: referenced as `int`
	cmplStd/lib/text/cstr.ci:27: referenced as `int`
	cmplStd/lib/text/cstr.ci:26: referenced as `int`
	cmplStd/lib/text/cstr.ci:25: referenced as `int`
	cmplStd/lib/text/cstr.ci:16: referenced as `int`
	cmplStd/lib/text/cstr.ci:15: referenced as `int`
	cmplStd/lib/text/cstr.ci:8: referenced as `int`
	cmplStd/lib/text/cstr.ci:4: referenced as `int`
	cmplStd/lib/time/Datetime.ci:306: referenced as `int`
	cmplStd/lib/time/Datetime.ci:306: referenced as `int`
	cmplStd/lib/time/Datetime.ci:306: referenced as `int`
	cmplStd/lib/time/Datetime.ci:301: referenced as `int`
	cmplStd/lib/time/Datetime.ci:301: referenced as `int`
	cmplStd/lib/time/Datetime.ci:301: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:239: referenced as `int`
	cmplStd/lib/time/Datetime.ci:238: referenced as `int`
	cmplStd/lib/time/Datetime.ci:231: referenced as `int`
	cmplStd/lib/time/Datetime.ci:224: referenced as `int`
	cmplStd/lib/time/Datetime.ci:219: referenced as `int`
	cmplStd/lib/time/Datetime.ci:209: referenced as `int`
	cmplStd/lib/time/Datetime.ci:204: referenced as `int`
	cmplStd/lib/time/Datetime.ci:201: referenced as `int`
	cmplStd/lib/time/Datetime.ci:198: referenced as `int`
	cmplStd/lib/time/Datetime.ci:181: referenced as `int`
	cmplStd/lib/time/Datetime.ci:172: referenced as `int`
	cmplStd/lib/time/Datetime.ci:166: referenced as `int`
	cmplStd/lib/time/Datetime.ci:165: referenced as `int`
	cmplStd/lib/time/Datetime.ci:164: referenced as `int`
	cmplStd/lib/time/Datetime.ci:162: referenced as `int`
	cmplStd/lib/time/Datetime.ci:159: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:159: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:156: referenced as `int`
	cmplStd/lib/time/Datetime.ci:150: referenced as `int`
	cmplStd/lib/time/Datetime.ci:119: referenced as `int`
	cmplStd/lib/time/Datetime.ci:117: referenced as `int`
	cmplStd/lib/time/Datetime.ci:116: referenced as `int`
	cmplStd/lib/time/Datetime.ci:116: referenced as `int`
	cmplStd/lib/time/Datetime.ci:116: referenced as `int`
	cmplStd/lib/time/Datetime.ci:102: referenced as `int`
	cmplStd/lib/time/Datetime.ci:99: referenced as `int`
	cmplStd/lib/time/Datetime.ci:98: referenced as `int`
	cmplStd/lib/time/Datetime.ci:97: referenced as `int`
	cmplStd/lib/time/Datetime.ci:61: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:34: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:32: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:32: referenced as `int`
	cmplStd/lib/time/Datetime.ci:19: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:17: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:17: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:27: referenced as `int`
	cmplStd/lib/math/Fixed.ci:725: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:563: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:562: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:555: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:535: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:485: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:484: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:472: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:457: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:445: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:445: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:445: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:445: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:428: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:426: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:317: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:186: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:183: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:122: referenced as `int`
	cmplStd/lib/math/Fixed.ci:122: referenced as `int`
	cmplStd/lib/math/Fixed.ci:121: referenced as `int`
	cmplStd/lib/math/Fixed.ci:61: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:49: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:48: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:35: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:5: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:3: referenced as `int32`
	cmplStd/lib/math/Math.ci:786: referenced as `int`
	cmplStd/lib/math/Math.ci:746: referenced as `int`
	cmplStd/lib/math/Math.ci:727: referenced as `int`
	cmplStd/lib/math/Math.ci:698: referenced as `int`
	cmplStd/lib/math/Math.ci:659: referenced as `int`
	cmplStd/lib/math/Math.ci:657: referenced as `int`
	cmplStd/lib/math/Math.ci:617: referenced as `int`
	cmplStd/lib/math/Math.ci:557: referenced as `int`
	cmplStd/lib/math/Math.ci:557: referenced as `int`
	cmplStd/lib/math/Math.ci:425: referenced as `int`
	cmplStd/lib/math/Math.ci:374: referenced as `int`
	cmplStd/lib/math/Math.ci:350: referenced as `int`
	cmplStd/lib/math/Math.ci:335: referenced as `int`
	cmplStd/lib/math/Math.ci:309: referenced as `int`
	cmplStd/lib/math/Math.ci:271: referenced as `int`
	cmplStd/lib/math/Math.ci:239: referenced as `int`
	cmplStd/lib/math/Math.ci:228: referenced as `int`
	cmplStd/lib/math/Math.ci:214: referenced as `int`
	cmplStd/lib/math/Math.ci:174: referenced as `int32`
	cmplStd/lib/math/Math.ci:174: referenced as `int32`
	cmplStd/lib/math/Math.ci:174: referenced as `int32`
	cmplStd/lib/math/Math.ci:155: referenced as `int32`
	cmplStd/lib/math/Math.ci:155: referenced as `int32`
	cmplStd/lib/math/Math.ci:137: referenced as `int32`
	cmplStd/lib/math/Math.ci:137: referenced as `int32`
	cmplStd/lib/math/Math.ci:118: referenced as `int32`
	cmplStd/lib/math/Math.ci:98: referenced as `int`
	cmplStd/lib/math/Math.ci:98: referenced as `int`
	cmplStd/lib/math/Math.ci:95: referenced as `int`
	cmplStd/lib/math/Math.ci:95: referenced as `int`
	cmplStd/lib/math/Math.ci:92: referenced as `int`
	cmplStd/lib/math/Math.ci:89: referenced as `int`
	cmplStd/lib/math/Math.ci:86: referenced as `int`
	cmplStd/lib/math/Math.ci:86: referenced as `int`
	cmplStd/lib/math/Math.ci:83: referenced as `int`
	cmplStd/lib/math/Math.ci:83: referenced as `int`
	cmplStd/lib/math/Math.ci:83: referenced as `int32`
	cmplStd/lib/math/Math.ci:40: referenced as `int`
	cmplStd/lib/math/Bits.ci:537: referenced as `int32`
	cmplStd/lib/math/Bits.ci:537: referenced as `int32`
	cmplStd/lib/math/Bits.ci:537: referenced as `int32`
	cmplStd/lib/math/Bits.ci:537: referenced as `int32`
	cmplStd/lib/math/Bits.ci:528: referenced as `int32`
	cmplStd/lib/math/Bits.ci:528: referenced as `int32`
	cmplStd/lib/math/Bits.ci:528: referenced as `int32`
	cmplStd/lib/math/Bits.ci:503: referenced as `int32`
	cmplStd/lib/math/Bits.ci:467: referenced as `int32`
	cmplStd/lib/math/Bits.ci:452: referenced as `int`
	cmplStd/lib/math/Bits.ci:433: referenced as `int`
	cmplStd/lib/math/Bits.ci:417: referenced as `int32`
	cmplStd/lib/math/Bits.ci:404: referenced as `int32`
	cmplStd/lib/math/Bits.ci:350: referenced as `int`
	cmplStd/lib/math/Bits.ci:345: referenced as `int`
	cmplStd/lib/math/Bits.ci:322: referenced as `int`
	cmplStd/lib/math/Bits.ci:317: referenced as `int`
	cmplStd/lib/math/Bits.ci:314: referenced as `int32`
	cmplStd/lib/math/Bits.ci:290: referenced as `int`
	cmplStd/lib/math/Bits.ci:280: referenced as `int`
	cmplStd/lib/math/Bits.ci:249: referenced as `int`
	cmplStd/lib/math/Bits.ci:239: referenced as `int`
	cmplStd/lib/math/Bits.ci:219: referenced as `int`
	cmplStd/lib/math/Bits.ci:214: referenced as `int`
	cmplStd/lib/math/Bits.ci:191: referenced as `int`
	cmplStd/lib/math/Bits.ci:186: referenced as `int`
	cmplStd/lib/math/Bits.ci:183: referenced as `int32`
	cmplStd/lib/math/Bits.ci:159: referenced as `int`
	cmplStd/lib/math/Bits.ci:150: referenced as `int`
	cmplStd/lib/math/Bits.ci:119: referenced as `int`
	cmplStd/lib/math/Bits.ci:110: referenced as `int`
	cmplStd/lib/math/Bits.ci:103: referenced as `int32`
	cmplStd/lib/math/Bits.ci:103: referenced as `int32`
	cmplStd/lib/math/Bits.ci:70: referenced as `int32`
	cmplStd/lib/math/Bits.ci:70: referenced as `int32`
	cmplStd/lib/math/Bits.ci:60: referenced as `int32`
	cmplStd/lib/math/Bits.ci:60: referenced as `int32`
	cmplStd/lib/math/Bits.ci:56: referenced as `int32`
	cmplStd/lib/math/Bits.ci:50: referenced as `int32`
	cmplStd/lib/math/Bits.ci:50: referenced as `int32`
	cmplStd/lib/math/Bits.ci:50: referenced as `int32`
	cmplStd/lib/math/Bits.ci:50: referenced as `int32`
	cmplStd/lib/math/Bits.ci:40: referenced as `int32`
	cmplStd/lib/math/Bits.ci:40: referenced as `int32`
	cmplStd/lib/math/Bits.ci:40: referenced as `int32`
	cmplStd/lib/math/Bits.ci:40: referenced as `int32`
	cmplStd/lib/math/Bits.ci:22: referenced as `int32`
	cmplStd/lib/math/Bits.ci:10: referenced as `int32`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:5: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:1: referenced as `int32`
	cmplStd/lib/lang/Pointer.ci:1: referenced as `int`
	cmplStd/lib/lang/Debug.ci:72: referenced as `int`
	cmplStd/lib/lang/Debug.ci:72: referenced as `int`
	cmplStd/lib/lang/Debug.ci:59: referenced as `int`
	cmplStd/lib/lang/Debug.ci:59: referenced as `int`
	internal usages: 121
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.name: 'int64'
.print: '%D'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `integer`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `integer`
	cmplStd/test/lang/useOperator.ci:205: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:204: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:203: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:202: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:201: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:200: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:199: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:198: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:197: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:196: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:195: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:194: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:193: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:192: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:191: referenced as `int64`
	cmplStd/test/lang/reflect.ci:23: referenced as `int64`
	cmplStd/test/lang/reflect.ci:9: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:81: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:61: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:41: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:29: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:28: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:27: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:25: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:24: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:16: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:14: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:13: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:12: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:8: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:7: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:3: referenced as `integer`
	cmplStd/test/lang/memory.ci:30: referenced as `int64`
	cmplStd/test/lang/memory.ci:29: referenced as `int64`
	cmplStd/test/lang/memory.ci:24: referenced as `int64`
	cmplStd/test/lang/memory.ci:23: referenced as `int64`
	cmplStd/test/lang/emit.ci:26: referenced as `int64`
	cmplStd/test/lang/emit.ci:24: referenced as `int64`
	cmplStd/test/lang/emit.ci:21: referenced as `int64`
	cmplStd/test/lang/emit.ci:4: referenced as `int64`
	cmplStd/test/test.ci:5: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:1273: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:1187: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:1128: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:1088: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:1084: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:569: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:503: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:495: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:493: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:490: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:489: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:488: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:319: referenced as `int64`
	cmplGfx/lib/micro.ui.ci:286: referenced as `int64`
	cmplGfx/lib/window.ci:366: referenced as `int64`
	cmplGfx/lib/window.ci:169: referenced as `int64`
	cmplGfx/lib/window.ci:106: referenced as `int64`
	cmplGfx/lib/window.ci:84: referenced as `int64`
	cmplGfx/lib/window.ci:6: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:98: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:97: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:96: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:95: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:94: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:39: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:38: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:37: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:36: referenced as `int64`
	cmplGfx/lib/image.draw.rrect.ci:35: referenced as `int64`
	cmplStd/lib/text/stream/TextStream.ci:105: referenced as `int64`
	cmplStd/lib/text/Format.ci:276: referenced as `int64`
	cmplStd/lib/text/Format.ci:273: referenced as `int64`
	cmplStd/lib/text/Format.ci:270: referenced as `int64`
	cmplStd/lib/text/Format.ci:267: referenced as `int64`
	cmplStd/lib/text/Format.ci:267: referenced as `int64`
	cmplStd/lib/text/Format.ci:215: referenced as `int64`
	cmplStd/lib/text/Format.ci:200: referenced as `int64`
	cmplStd/lib/text/Format.ci:170: referenced as `int64`
	cmplStd/lib/time/Datetime.ci:174: referenced as `int64`
	cmplStd/lib/time/Datetime.ci:173: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:120: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:79: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:78: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:60: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:42: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:17: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:12: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:6: referenced as `int64`
	cmplStd/lib/time/Duration.ci:22: referenced as `int64`
	cmplStd/lib/time/Duration.ci:11: referenced as `int64`
	cmplStd/lib/time/Duration.ci:6: referenced as `int64`
	cmplStd/lib/time/Timeunit.ci:14: referenced as `int64`
	cmplStd/lib/time/Timeunit.ci:14: referenced as `int64`
	cmplStd/lib/time/Timeunit.ci:2: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:715: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:562: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:484: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:427: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:71: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:71: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:59: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:49: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:47: referenced as `int64`
	cmplStd/lib/math/Math.ci:660: referenced as `int64`
	cmplStd/lib/math/Math.ci:177: referenced as `int64`
	cmplStd/lib/math/Math.ci:177: referenced as `int64`
	cmplStd/lib/math/Math.ci:177: referenced as `int64`
	cmplStd/lib/math/Math.ci:158: referenced as `int64`
	cmplStd/lib/math/Math.ci:158: referenced as `int64`
	cmplStd/lib/math/Math.ci:140: referenced as `int64`
	cmplStd/lib/math/Math.ci:140: referenced as `int64`
	cmplStd/lib/math/Math.ci:121: referenced as `int64`
	cmplStd/lib/math/Math.ci:86: referenced as `int64`
	cmplStd/lib/math/Bits.ci:486: referenced as `int64`
	cmplStd/lib/math/Bits.ci:449: referenced as `int64`
	cmplStd/lib/math/Bits.ci:411: referenced as `int64`
	cmplStd/lib/math/Bits.ci:386: referenced as `int64`
	cmplStd/lib/math/Bits.ci:277: referenced as `int64`
	cmplStd/lib/math/Bits.ci:147: referenced as `int64`
	cmplStd/lib/math/Bits.ci:100: referenced as `int64`
	cmplStd/lib/math/Bits.ci:100: referenced as `int64`
	cmplStd/lib/math/Bits.ci:76: referenced as `int64`
	cmplStd/lib/math/Bits.ci:70: referenced as `int64`
	cmplStd/lib/math/Bits.ci:70: referenced as `int64`
	cmplStd/lib/math/Bits.ci:60: referenced as `int64`
	cmplStd/lib/math/Bits.ci:60: referenced as `int64`
	cmplStd/lib/math/Bits.ci:25: referenced as `int64`
	cmplStd/lib/math/Bits.ci:13: referenced as `int64`
	cmplStd/lib/lang/Pointer.ci:5: referenced as `int64`
	internal usages: 10
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.name: 'uint8'
.print: '%u'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:90: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:89: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:88: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:87: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:86: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:85: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:84: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:83: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:82: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:81: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:80: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:79: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:78: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:77: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:76: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:57: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:55: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:53: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:47: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:45: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:43: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:37: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:35: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:33: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:27: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:25: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:23: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:17: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:15: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:13: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:7: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:5: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:3: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:12: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:11: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:10: referenced as `uint8`
	cmplStd/test/lang/reflect.ci:10: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:82: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:62: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:42: referenced as `uint8`
	cmplStd/test/lang/tryExec.ci:8: referenced as `byte`
	cmplGfx/lib/color.ci:16: referenced as `uint8`
	cmplGfx/lib/color.ci:13: referenced as `uint8`
	cmplGfx/lib/color.ci:10: referenced as `uint8`
	cmplGfx/lib/color.ci:7: referenced as `uint8`
	cmplFile/lib/FileStream.ci:56: referenced as `byte`
	cmplFile/lib/FileStream.ci:44: referenced as `byte`
	cmplFile/lib/FileStream.ci:35: referenced as `byte`
	cmplFile/lib/FileStream.ci:19: referenced as `byte`
	cmplFile/lib/FileStream.ci:5: referenced as `uint8`
	cmplFile/lib.ci:12: referenced as `uint8`
	cmplFile/lib.ci:3: referenced as `uint8`
	cmplStd/lib/text/encoding/Utf8.ci:78: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:70: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:63: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:59: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:6: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:5: referenced as `byte`
	cmplStd/lib/text/encoding/Ascii.ci:24: referenced as `byte`
	cmplStd/lib/text/encoding/Ascii.ci:7: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:182: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:165: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:162: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:45: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:41: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:33: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:8: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:3: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:149: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:126: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:104: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:77: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:57: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:56: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:48: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:27: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:23: referenced as `byte`
	cmplStd/lib/text/Format.ci:264: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:86: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:74: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:72: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:70: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:65: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:37: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:22: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:2: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:524: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:517: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:517: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:429: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:426: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:426: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:366: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:345: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:235: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:214: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:16: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:4: referenced as `uint8`
	cmplStd/lib.ci:9: referenced as `uint8`
	internal usages: 3
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.name: 'uint16'
.print: '%u'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:136: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:135: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:134: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:133: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:132: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:131: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:130: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:129: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:128: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:127: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:126: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:125: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:124: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:123: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:122: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:58: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:48: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:38: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:28: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:18: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:8: referenced as `uint16`
	cmplStd/test/lang/reflect.ci:11: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:83: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:63: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:43: referenced as `uint16`
	cmplStd/lib/text/Format.ci:261: referenced as `uint16`
	cmplStd/lib/time/Datetime.ci:89: referenced as `uint16`
	cmplStd/lib/time/Datetime.ci:76: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:514: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:506: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:506: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:423: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:420: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:420: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:342: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:317: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:211: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:186: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:106: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:95: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:95: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:19: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:7: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.field pop: function (size: 0, cast: static const inline)
.field swap: function (size: 0, cast: static const inline)
.field bsr: function (size: 0, cast: static const inline)
.field bsf: function (size: 0, cast: static const inline)
.field hib: function (size: 0, cast: static const inline)
.field lob: function (size: 0, cast: static const inline)
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/math/test.Bits.ci:56: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:182: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:181: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:180: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:179: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:178: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:177: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:176: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:175: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:174: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:173: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:172: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:171: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:170: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:169: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:168: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:56: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:46: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:36: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:26: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:16: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:6: referenced as `uint32`
	cmplStd/test/lang/recUnion.ci:17: referenced as `uint32`
	cmplStd/test/lang/reflect.ci:12: referenced as `uint32`
	cmplStd/test/lang/function.ci:46: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:84: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:64: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:44: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:476: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:476: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:475: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:475: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:474: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:474: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:473: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:473: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:342: referenced as `uint32`
	cmplGfx/lib/micro.ui.ci:155: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:48: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:46: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:44: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:42: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:39: referenced as `uint32`
	cmplGfx/lib/image.draw.ci:14: referenced as `uint32`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `uint32`
	cmplGfx/lib/image.draw.line.ci:85: referenced as `uint32`
	cmplGfx/lib/image.draw.line.ci:79: referenced as `uint32`
	cmplGfx/lib/image.draw.line.ci:32: referenced as `uint32`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `uint32`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `uint32`
	cmplGfx/lib/image.draw.line.ci:2: referenced as `uint32`
	cmplGfx/lib/image.draw.oval.ci:16: referenced as `uint32`
	cmplGfx/lib/image.draw.oval.ci:8: referenced as `uint32`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `uint32`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `uint32`
	cmplGfx/lib/image.draw.rrect.ci:139: referenced as `uint32`
	cmplGfx/lib/image.draw.rrect.ci:131: referenced as `uint32`
	cmplGfx/lib/image.draw.rrect.ci:128: referenced as `uint32`
	cmplGfx/lib/image.draw.rrect.ci:125: referenced as `uint32`
	cmplGfx/lib/image.draw.rrect.ci:61: referenced as `uint32`
	cmplGfx/lib/image.draw.rrect.ci:2: referenced as `uint32`
	cmplGfx/lib/image.draw.rect.ci:73: referenced as `uint32`
	cmplGfx/lib/image.draw.rect.ci:65: referenced as `uint32`
	cmplGfx/lib/image.draw.rect.ci:62: referenced as `uint32`
	cmplGfx/lib/image.draw.rect.ci:31: referenced as `uint32`
	cmplGfx/lib/image.draw.rect.ci:28: referenced as `uint32`
	cmplGfx/lib/image.draw.rect.ci:2: referenced as `uint32`
	cmplGfx/lib/color.ci:143: referenced as `uint32`
	cmplGfx/lib/color.ci:123: referenced as `uint32`
	cmplGfx/lib/color.ci:123: referenced as `uint32`
	cmplGfx/lib/color.ci:121: referenced as `uint32`
	cmplGfx/lib/color.ci:121: referenced as `uint32`
	cmplGfx/lib/color.ci:80: referenced as `uint32`
	cmplGfx/lib/color.ci:59: referenced as `uint32`
	cmplGfx/lib/color.ci:59: referenced as `uint32`
	cmplGfx/lib/color.ci:59: referenced as `uint32`
	cmplGfx/lib/color.ci:59: referenced as `uint32`
	cmplGfx/lib/color.ci:51: referenced as `uint32`
	cmplGfx/lib/color.ci:51: referenced as `uint32`
	cmplGfx/lib/color.ci:51: referenced as `uint32`
	cmplGfx/lib/color.ci:41: referenced as `uint32`
	cmplGfx/lib/color.ci:36: referenced as `uint32`
	cmplGfx/lib/color.ci:36: referenced as `uint32`
	cmplGfx/lib/color.ci:36: referenced as `uint32`
	cmplGfx/lib/color.ci:36: referenced as `uint32`
	cmplGfx/lib/color.ci:34: referenced as `uint32`
	cmplGfx/lib/color.ci:34: referenced as `uint32`
	cmplGfx/lib/color.ci:34: referenced as `uint32`
	cmplGfx/lib/color.ci:32: referenced as `uint32`
	cmplGfx/lib/color.ci:29: referenced as `uint32`
	cmplGfx/lib/color.ci:29: referenced as `uint32`
	cmplGfx/lib/color.ci:27: referenced as `uint32`
	cmplGfx/lib/color.ci:23: referenced as `uint32`
	cmplGfx/lib/color.ci:21: referenced as `uint32`
	cmplGfx/lib/color.ci:4: referenced as `uint32`
	cmplStd/lib/text/encoding/Utf8.ci:56: referenced as `unicode`
	cmplStd/lib/text/encoding/Utf8.ci:53: referenced as `unicode`
	cmplStd/lib/text/encoding/Utf8.ci:4: referenced as `unicode`
	cmplStd/lib/text/encoding/Ascii.ci:21: referenced as `unicode`
	cmplStd/lib/text/encoding/Ascii.ci:4: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:169: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:112: referenced as `uint32`
	cmplStd/lib/text/stream/TextStream.ci:64: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:26: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:16: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:3: referenced as `uint32`
	cmplStd/lib/text/Format.ci:258: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:372: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:368: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:367: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:366: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:365: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:310: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:308: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:306: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:255: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:188: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:185: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:135: referenced as `uint32`
	cmplStd/lib/math/Math.ci:180: referenced as `uint32`
	cmplStd/lib/math/Math.ci:180: referenced as `uint32`
	cmplStd/lib/math/Math.ci:180: referenced as `uint32`
	cmplStd/lib/math/Math.ci:161: referenced as `uint32`
	cmplStd/lib/math/Math.ci:161: referenced as `uint32`
	cmplStd/lib/math/Math.ci:143: referenced as `uint32`
	cmplStd/lib/math/Math.ci:143: referenced as `uint32`
	cmplStd/lib/math/Math.ci:124: referenced as `uint32`
	cmplStd/lib/math/Math.ci:89: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:503: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:492: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:490: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:489: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:489: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:467: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:455: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:453: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:452: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:417: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:414: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:414: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:404: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:392: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:390: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:389: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:389: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:314: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:283: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:281: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:280: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:183: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:153: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:151: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:150: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:103: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:88: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:88: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:53: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:51: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:46: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:43: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:41: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:37: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:37: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:33: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:33: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:28: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:22: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:10: referenced as `uint32`
	internal usages: 10
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(24)
.usages:
	cmplStd/lib/math/Bits.ci:43: referenced as `zxt`
	cmplStd/lib/math/Bits.ci:41: referenced as `zxt`
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(25)
.usages:
	cmplStd/lib/math/Bits.ci:53: referenced as `sxt`
	cmplStd/lib/math/Bits.ci:51: referenced as `sxt`
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(26)
.usages:
	cmplStd/lib/math/Bits.ci:455: referenced as `pop`
	cmplStd/lib/math/Bits.ci:453: referenced as `pop`
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(27)
.usages:
	cmplStd/lib/math/Bits.ci:492: referenced as `swap`
	cmplStd/lib/math/Bits.ci:490: referenced as `swap`
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(28)
.usages:
	cmplStd/lib/math/Bits.ci:153: referenced as `bsr`
	cmplStd/lib/math/Bits.ci:151: referenced as `bsr`
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(29)
.usages:
	cmplStd/lib/math/Bits.ci:283: referenced as `bsf`
	cmplStd/lib/math/Bits.ci:281: referenced as `bsf`
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(30)
.usages:
	cmplStd/lib/math/Bits.ci:392: referenced as `hib`
	cmplStd/lib/math/Bits.ci:390: referenced as `hib`
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(31)
.usages:
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:228: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:227: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:226: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:225: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:224: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:223: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:222: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:221: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:220: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:219: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:218: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:217: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:216: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:215: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:214: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:54: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:44: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:34: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:24: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:14: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:4: referenced as `uint64`
	cmplStd/test/lang/reflect.ci:13: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:85: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:65: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:45: referenced as `uint64`
	cmplStd/lib/text/stream/TextStream.ci:119: referenced as `uint64`
	cmplStd/lib/text/Format.ci:264: referenced as `uint64`
	cmplStd/lib/text/Format.ci:261: referenced as `uint64`
	cmplStd/lib/text/Format.ci:258: referenced as `uint64`
	cmplStd/lib/text/Format.ci:255: referenced as `uint64`
	cmplStd/lib/text/Format.ci:255: referenced as `uint64`
	cmplStd/lib/text/Format.ci:215: referenced as `uint64`
	cmplStd/lib/text/Format.ci:200: referenced as `uint64`
	cmplStd/lib/text/Format.ci:180: referenced as `uint64`
	cmplStd/lib/text/Format.ci:178: referenced as `uint64`
	cmplStd/lib/text/Format.ci:107: referenced as `uint64`
	cmplStd/lib/time/Timestamp.ci:94: referenced as `uint64`
	cmplStd/lib/math/Math.ci:591: referenced as `uint64`
	cmplStd/lib/math/Math.ci:578: referenced as `uint64`
	cmplStd/lib/math/Math.ci:576: referenced as `uint64`
	cmplStd/lib/math/Math.ci:575: referenced as `uint64`
	cmplStd/lib/math/Math.ci:574: referenced as `uint64`
	cmplStd/lib/math/Math.ci:555: referenced as `uint64`
	cmplStd/lib/math/Math.ci:391: referenced as `uint64`
	cmplStd/lib/math/Math.ci:373: referenced as `uint64`
	cmplStd/lib/math/Math.ci:334: referenced as `uint64`
	cmplStd/lib/math/Math.ci:295: referenced as `uint64`
	cmplStd/lib/math/Math.ci:294: referenced as `uint64`
	cmplStd/lib/math/Math.ci:183: referenced as `uint64`
	cmplStd/lib/math/Math.ci:183: referenced as `uint64`
	cmplStd/lib/math/Math.ci:183: referenced as `uint64`
	cmplStd/lib/math/Math.ci:164: referenced as `uint64`
	cmplStd/lib/math/Math.ci:164: referenced as `uint64`
	cmplStd/lib/math/Math.ci:146: referenced as `uint64`
	cmplStd/lib/math/Math.ci:146: referenced as `uint64`
	cmplStd/lib/math/Math.ci:127: referenced as `uint64`
	cmplStd/lib/math/Math.ci:92: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:486: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:474: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:472: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:471: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:471: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:449: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:436: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:434: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:433: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:411: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:408: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:408: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:386: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:373: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:371: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:370: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:370: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:277: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:242: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:240: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:239: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:147: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:113: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:111: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:110: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:100: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:80: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:80: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:73: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:71: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:66: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:63: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:61: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:37: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:37: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:35: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:35: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:30: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:25: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:13: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(32)
.usages:
	cmplStd/lib/math/Bits.ci:63: referenced as `zxt`
	cmplStd/lib/math/Bits.ci:61: referenced as `zxt`
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(33)
.usages:
	cmplStd/lib/math/Bits.ci:73: referenced as `sxt`
	cmplStd/lib/math/Bits.ci:71: referenced as `sxt`
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/math/test.Math.ci:119: referenced as `float32`
	cmplStd/test/math/test.Math.ci:118: referenced as `float32`
	cmplStd/test/math/test.Math.ci:117: referenced as `float32`
	cmplStd/test/math/test.Math.ci:116: referenced as `float32`
	cmplStd/test/math/test.Math.ci:114: referenced as `float32`
	cmplStd/test/math/test.Math.ci:113: referenced as `float32`
	cmplStd/test/math/test.Math.ci:112: referenced as `float32`
	cmplStd/test/math/test.Math.ci:111: referenced as `float32`
	cmplStd/test/math/test.Math.ci:109: referenced as `float32`
	cmplStd/test/math/test.Math.ci:108: referenced as `float32`
	cmplStd/test/math/test.Math.ci:107: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:53: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:52: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:51: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:50: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:49: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:48: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:47: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:46: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:7: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:6: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:246: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:245: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:244: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:243: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:242: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:240: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:239: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:238: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:237: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:5: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:4: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:3: referenced as `float32`
	cmplStd/test/lang/reflect.ci:14: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:86: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:66: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:46: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:13: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:12: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:11: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:10: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:9: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:6: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplGfx/lib/window.ci:379: referenced as `float32`
	cmplGfx/lib/window.ci:210: referenced as `float32`
	cmplGfx/lib/window.ci:209: referenced as `float32`
	cmplGfx/lib/window.ci:165: referenced as `float32`
	cmplGfx/lib/window.ci:151: referenced as `float32`
	cmplGfx/lib/window.ci:140: referenced as `float32`
	cmplGfx/lib/window.ci:140: referenced as `float32`
	cmplGfx/lib/window.ci:123: referenced as `float32`
	cmplGfx/lib/window.ci:107: referenced as `float32`
	cmplGfx/lib/window.ci:91: referenced as `float32`
	cmplGfx/lib/window.ci:89: referenced as `float32`
	cmplGfx/lib/camera.ci:72: referenced as `float32`
	cmplGfx/lib/camera.ci:67: referenced as `float32`
	cmplGfx/lib/camera.ci:62: referenced as `float32`
	cmplGfx/lib/camera.ci:62: referenced as `float32`
	cmplGfx/lib/camera.ci:62: referenced as `float32`
	cmplGfx/lib/camera.ci:62: referenced as `float32`
	cmplGfx/lib/camera.ci:15: referenced as `float32`
	cmplGfx/lib/camera.ci:14: referenced as `float32`
	cmplGfx/lib/camera.ci:13: referenced as `float32`
	cmplGfx/lib/camera.ci:13: referenced as `float32`
	cmplGfx/lib/camera.ci:13: referenced as `float32`
	cmplGfx/lib/camera.ci:13: referenced as `float32`
	cmplGfx/lib/image.transform.ci:25: referenced as `float32`
	cmplGfx/lib/image.transform.ci:24: referenced as `float32`
	cmplGfx/lib/image.blend.ci:172: referenced as `float32`
	cmplGfx/lib/image.blend.ci:171: referenced as `float32`
	cmplGfx/lib/image.blend.ci:159: referenced as `float32`
	cmplGfx/lib/image.blend.ci:159: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:94: referenced as `float`
	cmplGfx/lib/color.hsl.ci:86: referenced as `float`
	cmplGfx/lib/color.hsl.ci:62: referenced as `float`
	cmplGfx/lib/color.hsl.ci:62: referenced as `float`
	cmplGfx/lib/color.hsl.ci:62: referenced as `float`
	cmplGfx/lib/color.hsl.ci:62: referenced as `float`
	cmplGfx/lib/color.hsl.ci:35: referenced as `float`
	cmplGfx/lib/color.hsl.ci:33: referenced as `float`
	cmplGfx/lib/color.hsl.ci:32: referenced as `float`
	cmplGfx/lib/color.hsl.ci:31: referenced as `float`
	cmplGfx/lib/color.hsl.ci:24: referenced as `float`
	cmplGfx/lib/color.hsl.ci:12: referenced as `float`
	cmplGfx/lib/color.hsl.ci:9: referenced as `float`
	cmplGfx/lib/color.hsl.ci:8: referenced as `float`
	cmplGfx/lib/color.hsl.ci:7: referenced as `float`
	cmplGfx/lib/color.hsl.ci:6: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:6: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:6: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:5: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:5: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:4: referenced as `float32`
	cmplGfx/lib/color.hsl.ci:4: referenced as `float32`
	cmplGfx/lib/color.ci:61: referenced as `float32`
	cmplGfx/lib/color.ci:61: referenced as `float32`
	cmplGfx/lib/color.ci:61: referenced as `float32`
	cmplGfx/lib/color.ci:61: referenced as `float32`
	cmplGfx/lib/color.ci:53: referenced as `float32`
	cmplGfx/lib/color.ci:53: referenced as `float32`
	cmplGfx/lib/color.ci:53: referenced as `float32`
	cmplGfx/lib/color.ci:43: referenced as `float32`
	cmplStd/lib/text/stream/TextStream.ci:126: referenced as `float32`
	cmplStd/lib/text/Format.ci:279: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:247: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:245: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:244: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:243: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:242: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:241: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:240: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:239: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:238: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:237: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:236: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:235: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:234: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:232: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:231: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:230: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:229: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:227: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:226: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:225: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:224: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:222: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:221: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:220: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:219: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:217: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:216: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:215: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:214: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:202: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:201: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:191: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:164: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:162: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:161: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:159: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:158: referenced as `float`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:134: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:130: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:129: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:128: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:121: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:120: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:110: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:109: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:57: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:55: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:53: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:51: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:48: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:46: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:44: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:42: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:39: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:37: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:33: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:30: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:28: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:24: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:4: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:114: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:14: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:11: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:9: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:5: referenced as `float32`
	cmplStd/lib/math/Math.ci:991: referenced as `float32`
	cmplStd/lib/math/Math.ci:988: referenced as `float32`
	cmplStd/lib/math/Math.ci:986: referenced as `float32`
	cmplStd/lib/math/Math.ci:985: referenced as `float32`
	cmplStd/lib/math/Math.ci:985: referenced as `float32`
	cmplStd/lib/math/Math.ci:949: referenced as `float32`
	cmplStd/lib/math/Math.ci:946: referenced as `float32`
	cmplStd/lib/math/Math.ci:944: referenced as `float32`
	cmplStd/lib/math/Math.ci:943: referenced as `float32`
	cmplStd/lib/math/Math.ci:943: referenced as `float32`
	cmplStd/lib/math/Math.ci:916: referenced as `float32`
	cmplStd/lib/math/Math.ci:913: referenced as `float32`
	cmplStd/lib/math/Math.ci:911: referenced as `float32`
	cmplStd/lib/math/Math.ci:910: referenced as `float32`
	cmplStd/lib/math/Math.ci:910: referenced as `float32`
	cmplStd/lib/math/Math.ci:895: referenced as `float32`
	cmplStd/lib/math/Math.ci:892: referenced as `float32`
	cmplStd/lib/math/Math.ci:890: referenced as `float32`
	cmplStd/lib/math/Math.ci:889: referenced as `float32`
	cmplStd/lib/math/Math.ci:889: referenced as `float32`
	cmplStd/lib/math/Math.ci:889: referenced as `float32`
	cmplStd/lib/math/Math.ci:693: referenced as `float32`
	cmplStd/lib/math/Math.ci:690: referenced as `float32`
	cmplStd/lib/math/Math.ci:688: referenced as `float32`
	cmplStd/lib/math/Math.ci:687: referenced as `float32`
	cmplStd/lib/math/Math.ci:687: referenced as `float32`
	cmplStd/lib/math/Math.ci:687: referenced as `float32`
	cmplStd/lib/math/Math.ci:602: referenced as `float32`
	cmplStd/lib/math/Math.ci:599: referenced as `float32`
	cmplStd/lib/math/Math.ci:597: referenced as `float32`
	cmplStd/lib/math/Math.ci:596: referenced as `float32`
	cmplStd/lib/math/Math.ci:596: referenced as `float32`
	cmplStd/lib/math/Math.ci:527: referenced as `float32`
	cmplStd/lib/math/Math.ci:524: referenced as `float32`
	cmplStd/lib/math/Math.ci:522: referenced as `float32`
	cmplStd/lib/math/Math.ci:521: referenced as `float32`
	cmplStd/lib/math/Math.ci:521: referenced as `float32`
	cmplStd/lib/math/Math.ci:450: referenced as `float32`
	cmplStd/lib/math/Math.ci:447: referenced as `float32`
	cmplStd/lib/math/Math.ci:445: referenced as `float32`
	cmplStd/lib/math/Math.ci:444: referenced as `float32`
	cmplStd/lib/math/Math.ci:444: referenced as `float32`
	cmplStd/lib/math/Math.ci:200: referenced as `float32`
	cmplStd/lib/math/Math.ci:200: referenced as `float32`
	cmplStd/lib/math/Math.ci:200: referenced as `float32`
	cmplStd/lib/math/Math.ci:197: referenced as `float32`
	cmplStd/lib/math/Math.ci:192: referenced as `float32`
	cmplStd/lib/math/Math.ci:192: referenced as `float32`
	cmplStd/lib/math/Math.ci:192: referenced as `float32`
	cmplStd/lib/math/Math.ci:186: referenced as `float32`
	cmplStd/lib/math/Math.ci:186: referenced as `float32`
	cmplStd/lib/math/Math.ci:186: referenced as `float32`
	cmplStd/lib/math/Math.ci:167: referenced as `float32`
	cmplStd/lib/math/Math.ci:167: referenced as `float32`
	cmplStd/lib/math/Math.ci:149: referenced as `float32`
	cmplStd/lib/math/Math.ci:149: referenced as `float32`
	cmplStd/lib/math/Math.ci:130: referenced as `float32`
	cmplStd/lib/math/Math.ci:102: referenced as `float32`
	cmplStd/lib/math/Math.ci:102: referenced as `float32`
	cmplStd/lib/math/Math.ci:102: referenced as `float32`
	cmplStd/lib/math/Math.ci:95: referenced as `float32`
	cmplStd/lib/math/Math.ci:79: referenced as `float32`
	cmplStd/lib/math/Math.ci:73: referenced as `float32`
	cmplStd/lib/math/Math.ci:62: referenced as `float32`
	cmplStd/lib/math/Math.ci:61: referenced as `float32`
	cmplStd/lib/math/Math.ci:61: referenced as `float32`
	cmplStd/lib/math/Bits.ci:33: referenced as `float32`
	cmplStd/lib/math/Bits.ci:28: referenced as `float32`
	cmplStd/lib/math/Bits.ci:28: referenced as `float32`
	cmplStd/lib.ci:10: referenced as `float32`
	internal usages: 66
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(34)
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `sin`
	cmplStd/lib/math/Math.ci:913: referenced as `sin`
	cmplStd/lib/math/Math.ci:911: referenced as `sin`
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(35)
.usages:
	cmplStd/lib/math/Math.ci:946: referenced as `cos`
	cmplStd/lib/math/Math.ci:944: referenced as `cos`
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(36)
.usages:
	cmplStd/lib/math/Math.ci:988: referenced as `tan`
	cmplStd/lib/math/Math.ci:986: referenced as `tan`
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(37)
.usages:
	cmplStd/lib/math/Math.ci:447: referenced as `log`
	cmplStd/lib/math/Math.ci:445: referenced as `log`
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(38)
.usages:
	cmplStd/lib/math/Math.ci:524: referenced as `exp`
	cmplStd/lib/math/Math.ci:522: referenced as `exp`
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(39)
.usages:
	cmplStd/lib/math/Math.ci:690: referenced as `pow`
	cmplStd/lib/math/Math.ci:688: referenced as `pow`
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(40)
.usages:
	cmplStd/lib/math/Math.ci:599: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:597: referenced as `sqrt`
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(41)
.usages:
	cmplStd/lib/math/Math.ci:892: referenced as `atan2`
	cmplStd/lib/math/Math.ci:890: referenced as `atan2`
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.field ldexp: function (size: 0, cast: static const inline)
.field frexp: function (size: 0, cast: static const inline)
.field parse: function (size: 0, cast: static const inline)
.field print: function (size: 0, cast: static const inline)
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/math/test.Math.ci:105: referenced as `float64`
	cmplStd/test/math/test.Math.ci:104: referenced as `float64`
	cmplStd/test/math/test.Math.ci:103: referenced as `float64`
	cmplStd/test/math/test.Math.ci:102: referenced as `float64`
	cmplStd/test/math/test.Math.ci:100: referenced as `float64`
	cmplStd/test/math/test.Math.ci:99: referenced as `float64`
	cmplStd/test/math/test.Math.ci:98: referenced as `float64`
	cmplStd/test/math/test.Math.ci:97: referenced as `float64`
	cmplStd/test/math/test.Math.ci:95: referenced as `float64`
	cmplStd/test/math/test.Math.ci:94: referenced as `float64`
	cmplStd/test/math/test.Math.ci:93: referenced as `float64`
	cmplStd/test/math/test.Math.ci:90: referenced as `float64`
	cmplStd/test/math/test.Math.ci:89: referenced as `float64`
	cmplStd/test/math/test.Math.ci:87: referenced as `float64`
	cmplStd/test/math/test.Math.ci:86: referenced as `float64`
	cmplStd/test/math/test.Math.ci:85: referenced as `float64`
	cmplStd/test/math/test.Math.ci:84: referenced as `float64`
	cmplStd/test/math/test.Math.ci:83: referenced as `float64`
	cmplStd/test/math/test.Math.ci:81: referenced as `float64`
	cmplStd/test/math/test.Math.ci:80: referenced as `float64`
	cmplStd/test/math/test.Math.ci:79: referenced as `float64`
	cmplStd/test/math/test.Math.ci:78: referenced as `float64`
	cmplStd/test/math/test.Math.ci:77: referenced as `float64`
	cmplStd/test/math/test.Math.ci:76: referenced as `float64`
	cmplStd/test/math/test.Math.ci:75: referenced as `float64`
	cmplStd/test/math/test.Math.ci:74: referenced as `float64`
	cmplStd/test/math/test.Math.ci:72: referenced as `float64`
	cmplStd/test/math/test.Math.ci:71: referenced as `float64`
	cmplStd/test/math/test.Math.ci:70: referenced as `float64`
	cmplStd/test/math/test.Math.ci:69: referenced as `float64`
	cmplStd/test/math/test.Math.ci:67: referenced as `float64`
	cmplStd/test/math/test.Math.ci:66: referenced as `float64`
	cmplStd/test/math/test.Math.ci:65: referenced as `float64`
	cmplStd/test/math/test.Math.ci:64: referenced as `float64`
	cmplStd/test/math/test.Math.ci:62: referenced as `float64`
	cmplStd/test/math/test.Math.ci:61: referenced as `float64`
	cmplStd/test/math/test.Math.ci:59: referenced as `float64`
	cmplStd/test/math/test.Math.ci:58: referenced as `float64`
	cmplStd/test/math/test.Math.ci:56: referenced as `float64`
	cmplStd/test/math/test.Math.ci:55: referenced as `float64`
	cmplStd/test/math/test.Math.ci:53: referenced as `float64`
	cmplStd/test/math/test.Math.ci:52: referenced as `float64`
	cmplStd/test/math/test.Math.ci:51: referenced as `float64`
	cmplStd/test/math/test.Math.ci:50: referenced as `float64`
	cmplStd/test/math/test.Math.ci:48: referenced as `float64`
	cmplStd/test/math/test.Math.ci:47: referenced as `float64`
	cmplStd/test/math/test.Math.ci:46: referenced as `float64`
	cmplStd/test/math/test.Math.ci:45: referenced as `float64`
	cmplStd/test/math/test.Math.ci:44: referenced as `float64`
	cmplStd/test/math/test.Math.ci:43: referenced as `float64`
	cmplStd/test/math/test.Math.ci:41: referenced as `float64`
	cmplStd/test/math/test.Math.ci:40: referenced as `float64`
	cmplStd/test/math/test.Math.ci:39: referenced as `float64`
	cmplStd/test/math/test.Math.ci:38: referenced as `float64`
	cmplStd/test/math/test.Math.ci:37: referenced as `float64`
	cmplStd/test/math/test.Math.ci:36: referenced as `float64`
	cmplStd/test/math/test.Math.ci:34: referenced as `float64`
	cmplStd/test/math/test.Math.ci:33: referenced as `float64`
	cmplStd/test/math/test.Math.ci:32: referenced as `float64`
	cmplStd/test/math/test.Math.ci:31: referenced as `float64`
	cmplStd/test/math/test.Math.ci:30: referenced as `float64`
	cmplStd/test/math/test.Math.ci:29: referenced as `float64`
	cmplStd/test/math/test.Math.ci:28: referenced as `float64`
	cmplStd/test/math/test.Math.ci:27: referenced as `float64`
	cmplStd/test/math/test.Math.ci:26: referenced as `float64`
	cmplStd/test/math/test.Math.ci:25: referenced as `float64`
	cmplStd/test/math/test.Math.ci:23: referenced as `float64`
	cmplStd/test/math/test.Math.ci:22: referenced as `float64`
	cmplStd/test/math/test.Math.ci:21: referenced as `float64`
	cmplStd/test/math/test.Math.ci:20: referenced as `float64`
	cmplStd/test/math/test.Math.ci:19: referenced as `float64`
	cmplStd/test/math/test.Math.ci:18: referenced as `float64`
	cmplStd/test/math/test.Math.ci:17: referenced as `float64`
	cmplStd/test/math/test.Math.ci:16: referenced as `float64`
	cmplStd/test/math/test.Math.ci:15: referenced as `float64`
	cmplStd/test/math/test.Math.ci:14: referenced as `float64`
	cmplStd/test/math/test.Math.ci:12: referenced as `float64`
	cmplStd/test/math/test.Math.ci:11: referenced as `float64`
	cmplStd/test/math/test.Math.ci:10: referenced as `float64`
	cmplStd/test/math/test.Math.ci:9: referenced as `float64`
	cmplStd/test/math/test.Math.ci:8: referenced as `float64`
	cmplStd/test/math/test.Math.ci:7: referenced as `float64`
	cmplStd/test/math/test.Math.ci:6: referenced as `float64`
	cmplStd/test/math/test.Math.ci:5: referenced as `float64`
	cmplStd/test/math/test.Math.ci:4: referenced as `float64`
	cmplStd/test/math/test.Math.ci:3: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:44: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:43: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:42: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:41: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:40: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:39: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:38: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:37: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:4: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:3: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:269: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:268: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:267: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:266: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:265: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:263: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:262: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:261: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:260: referenced as `float64`
	cmplStd/test/lang/reflect.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:14: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:11: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:10: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:87: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:67: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:47: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:16: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:15: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:581: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:581: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:580: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:580: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:276: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:275: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:257: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:255: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:224: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:199: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:193: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:192: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:190: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:188: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:186: referenced as `float64`
	cmplGfx/lib/micro.ui.ci:185: referenced as `float64`
	cmplGfx/lib/window.ci:6: referenced as `float64`
	cmplGfx/lib/color.lookup.ci:47: referenced as `float64`
	cmplGfx/lib/image.blur.ci:29: referenced as `float64`
	cmplGfx/lib/image.blur.ci:28: referenced as `float64`
	cmplGfx/lib/image.blur.ci:8: referenced as `double`
	cmplGfx/lib/image.blur.ci:6: referenced as `double`
	cmplGfx/lib/image.blur.ci:6: referenced as `double`
	cmplGfx/lib/image.blur.ci:6: referenced as `double`
	cmplGfx/lib/image.blur.ci:2: referenced as `float64`
	cmplGfx/lib/image.transform.ci:136: referenced as `float64`
	cmplGfx/lib/image.transform.ci:115: referenced as `float64`
	cmplGfx/lib/image.transform.ci:107: referenced as `float64`
	cmplGfx/lib/image.transform.ci:100: referenced as `float64`
	cmplGfx/lib/image.transform.ci:97: referenced as `float64`
	cmplGfx/lib/image.transform.ci:89: referenced as `float64`
	cmplGfx/lib/image.transform.ci:89: referenced as `float64`
	cmplGfx/lib/image.transform.ci:88: referenced as `float64`
	cmplGfx/lib/image.transform.ci:88: referenced as `float64`
	cmplGfx/lib/image.transform.ci:86: referenced as `float64`
	cmplGfx/lib/image.transform.ci:67: referenced as `float64`
	cmplGfx/lib/image.draw.line.ci:116: referenced as `double`
	cmplGfx/lib/image.draw.line.ci:115: referenced as `double`
	cmplGfx/lib/image.draw.line.ci:94: referenced as `double`
	cmplGfx/lib/image.draw.line.ci:93: referenced as `double`
	cmplGfx/lib/color.ci:63: referenced as `float64`
	cmplGfx/lib/color.ci:63: referenced as `float64`
	cmplGfx/lib/color.ci:63: referenced as `float64`
	cmplGfx/lib/color.ci:63: referenced as `float64`
	cmplGfx/lib/color.ci:55: referenced as `float64`
	cmplGfx/lib/color.ci:55: referenced as `float64`
	cmplGfx/lib/color.ci:55: referenced as `float64`
	cmplGfx/lib/color.ci:45: referenced as `float64`
	cmplStd/lib/math/Polynomial.ci:177: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:163: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:146: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:145: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:145: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:98: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:98: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:89: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:59: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:21: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:8: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:5: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:1: referenced as `float64`
	cmplStd/lib/math/Easing.ci:109: referenced as `float64`
	cmplStd/lib/math/Easing.ci:109: referenced as `float64`
	cmplStd/lib/math/Easing.ci:109: referenced as `float64`
	cmplStd/lib/math/Easing.ci:109: referenced as `float64`
	cmplStd/lib/math/Easing.ci:100: referenced as `float64`
	cmplStd/lib/math/Easing.ci:100: referenced as `float64`
	cmplStd/lib/math/Easing.ci:100: referenced as `float64`
	cmplStd/lib/math/Easing.ci:100: referenced as `float64`
	cmplStd/lib/math/Easing.ci:92: referenced as `float64`
	cmplStd/lib/math/Easing.ci:92: referenced as `float64`
	cmplStd/lib/math/Easing.ci:92: referenced as `float64`
	cmplStd/lib/math/Easing.ci:92: referenced as `float64`
	cmplStd/lib/math/Easing.ci:84: referenced as `float64`
	cmplStd/lib/math/Easing.ci:84: referenced as `float64`
	cmplStd/lib/math/Easing.ci:84: referenced as `float64`
	cmplStd/lib/math/Easing.ci:84: referenced as `float64`
	cmplStd/lib/math/Easing.ci:60: referenced as `float64`
	cmplStd/lib/math/Easing.ci:60: referenced as `float64`
	cmplStd/lib/math/Easing.ci:60: referenced as `float64`
	cmplStd/lib/math/Easing.ci:60: referenced as `float64`
	cmplStd/lib/math/Easing.ci:59: referenced as `float64`
	cmplStd/lib/math/Easing.ci:59: referenced as `float64`
	cmplStd/lib/math/Easing.ci:53: referenced as `float64`
	cmplStd/lib/math/Easing.ci:53: referenced as `float64`
	cmplStd/lib/math/Easing.ci:46: referenced as `float64`
	cmplStd/lib/math/Easing.ci:46: referenced as `float64`
	cmplStd/lib/math/Easing.ci:41: referenced as `float64`
	cmplStd/lib/math/Easing.ci:41: referenced as `float64`
	cmplStd/lib/math/Easing.ci:36: referenced as `float64`
	cmplStd/lib/math/Easing.ci:36: referenced as `float64`
	cmplStd/lib/math/Easing.ci:31: referenced as `float64`
	cmplStd/lib/math/Easing.ci:31: referenced as `float64`
	cmplStd/lib/math/Easing.ci:26: referenced as `float64`
	cmplStd/lib/math/Easing.ci:26: referenced as `float64`
	cmplStd/lib/math/Easing.ci:21: referenced as `float64`
	cmplStd/lib/math/Easing.ci:21: referenced as `float64`
	cmplStd/lib/math/Easing.ci:16: referenced as `float64`
	cmplStd/lib/math/Easing.ci:16: referenced as `float64`
	cmplStd/lib/math/Easing.ci:11: referenced as `float64`
	cmplStd/lib/math/Easing.ci:11: referenced as `float64`
	cmplStd/lib/math/Easing.ci:6: referenced as `float64`
	cmplStd/lib/math/Easing.ci:6: referenced as `float64`
	cmplStd/lib/text/stream/TextStream.ci:133: referenced as `float64`
	cmplStd/lib/text/Format.ci:279: referenced as `float64`
	cmplStd/lib/text/Format.ci:211: referenced as `float64`
	cmplStd/lib/text/Format.ci:197: referenced as `float64`
	cmplStd/lib/text/Format.ci:184: referenced as `float64`
	cmplStd/lib/text/cstr.ci:130: referenced as `float64`
	cmplStd/lib/text/cstr.ci:129: referenced as `float64`
	cmplStd/lib/text/cstr.ci:121: referenced as `float64`
	cmplStd/lib/text/cstr.ci:119: referenced as `float64`
	cmplStd/lib/text/cstr.ci:118: referenced as `float64`
	cmplStd/lib/text/cstr.ci:117: referenced as `float64`
	cmplStd/lib/time/Timeunit.ci:24: referenced as `float64`
	cmplStd/lib/time/Timeunit.ci:24: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:10: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:7: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:5: referenced as `float64`
	cmplStd/lib/math/Complex.ci:113: referenced as `float64`
	cmplStd/lib/math/Complex.ci:106: referenced as `float64`
	cmplStd/lib/math/Complex.ci:105: referenced as `float64`
	cmplStd/lib/math/Complex.ci:104: referenced as `float64`
	cmplStd/lib/math/Complex.ci:103: referenced as `float64`
	cmplStd/lib/math/Complex.ci:85: referenced as `float64`
	cmplStd/lib/math/Complex.ci:76: referenced as `float64`
	cmplStd/lib/math/Complex.ci:74: referenced as `float64`
	cmplStd/lib/math/Complex.ci:67: referenced as `float64`
	cmplStd/lib/math/Complex.ci:66: referenced as `float64`
	cmplStd/lib/math/Complex.ci:60: referenced as `float64`
	cmplStd/lib/math/Complex.ci:59: referenced as `float64`
	cmplStd/lib/math/Complex.ci:51: referenced as `float64`
	cmplStd/lib/math/Complex.ci:49: referenced as `float64`
	cmplStd/lib/math/Complex.ci:41: referenced as `float64`
	cmplStd/lib/math/Complex.ci:39: referenced as `float64`
	cmplStd/lib/math/Complex.ci:34: referenced as `float64`
	cmplStd/lib/math/Complex.ci:32: referenced as `float64`
	cmplStd/lib/math/Complex.ci:19: referenced as `float64`
	cmplStd/lib/math/Complex.ci:19: referenced as `float64`
	cmplStd/lib/math/Complex.ci:12: referenced as `float64`
	cmplStd/lib/math/Complex.ci:8: referenced as `float64`
	cmplStd/lib/math/Complex.ci:5: referenced as `float64`
	cmplStd/lib/math/Fixed.ci:761: referenced as `float64`
	cmplStd/lib/math/Fixed.ci:750: referenced as `float64`
	cmplStd/lib/math/Fixed.ci:732: referenced as `float64`
	cmplStd/lib/math/Math.ci:1054: referenced as `float64`
	cmplStd/lib/math/Math.ci:1054: referenced as `float64`
	cmplStd/lib/math/Math.ci:1051: referenced as `float64`
	cmplStd/lib/math/Math.ci:1051: referenced as `float64`
	cmplStd/lib/math/Math.ci:1047: referenced as `float64`
	cmplStd/lib/math/Math.ci:1044: referenced as `float64`
	cmplStd/lib/math/Math.ci:1041: referenced as `float64`
	cmplStd/lib/math/Math.ci:1038: referenced as `float64`
	cmplStd/lib/math/Math.ci:1034: referenced as `float64`
	cmplStd/lib/math/Math.ci:1031: referenced as `float64`
	cmplStd/lib/math/Math.ci:1028: referenced as `float64`
	cmplStd/lib/math/Math.ci:1025: referenced as `float64`
	cmplStd/lib/math/Math.ci:1021: referenced as `float64`
	cmplStd/lib/math/Math.ci:1018: referenced as `float64`
	cmplStd/lib/math/Math.ci:1015: referenced as `float64`
	cmplStd/lib/math/Math.ci:1005: referenced as `float64`
	cmplStd/lib/math/Math.ci:1003: referenced as `float64`
	cmplStd/lib/math/Math.ci:1002: referenced as `float64`
	cmplStd/lib/math/Math.ci:1002: referenced as `float64`
	cmplStd/lib/math/Math.ci:998: referenced as `float64`
	cmplStd/lib/math/Math.ci:995: referenced as `float64`
	cmplStd/lib/math/Math.ci:991: referenced as `float64`
	cmplStd/lib/math/Math.ci:966: referenced as `float64`
	cmplStd/lib/math/Math.ci:964: referenced as `float64`
	cmplStd/lib/math/Math.ci:963: referenced as `float64`
	cmplStd/lib/math/Math.ci:963: referenced as `float64`
	cmplStd/lib/math/Math.ci:959: referenced as `float64`
	cmplStd/lib/math/Math.ci:956: referenced as `float64`
	cmplStd/lib/math/Math.ci:953: referenced as `float64`
	cmplStd/lib/math/Math.ci:949: referenced as `float64`
	cmplStd/lib/math/Math.ci:933: referenced as `float64`
	cmplStd/lib/math/Math.ci:931: referenced as `float64`
	cmplStd/lib/math/Math.ci:930: referenced as `float64`
	cmplStd/lib/math/Math.ci:930: referenced as `float64`
	cmplStd/lib/math/Math.ci:926: referenced as `float64`
	cmplStd/lib/math/Math.ci:923: referenced as `float64`
	cmplStd/lib/math/Math.ci:920: referenced as `float64`
	cmplStd/lib/math/Math.ci:916: referenced as `float64`
	cmplStd/lib/math/Math.ci:903: referenced as `float64`
	cmplStd/lib/math/Math.ci:901: referenced as `float64`
	cmplStd/lib/math/Math.ci:900: referenced as `float64`
	cmplStd/lib/math/Math.ci:900: referenced as `float64`
	cmplStd/lib/math/Math.ci:895: referenced as `float64`
	cmplStd/lib/math/Math.ci:895: referenced as `float64`
	cmplStd/lib/math/Math.ci:868: referenced as `float64`
	cmplStd/lib/math/Math.ci:866: referenced as `float64`
	cmplStd/lib/math/Math.ci:865: referenced as `float64`
	cmplStd/lib/math/Math.ci:865: referenced as `float64`
	cmplStd/lib/math/Math.ci:865: referenced as `float64`
	cmplStd/lib/math/Math.ci:847: referenced as `float64`
	cmplStd/lib/math/Math.ci:847: referenced as `float64`
	cmplStd/lib/math/Math.ci:842: referenced as `float64`
	cmplStd/lib/math/Math.ci:841: referenced as `float64`
	cmplStd/lib/math/Math.ci:840: referenced as `float64`
	cmplStd/lib/math/Math.ci:839: referenced as `float64`
	cmplStd/lib/math/Math.ci:839: referenced as `float64`
	cmplStd/lib/math/Math.ci:821: referenced as `float64`
	cmplStd/lib/math/Math.ci:820: referenced as `float64`
	cmplStd/lib/math/Math.ci:820: referenced as `float64`
	cmplStd/lib/math/Math.ci:796: referenced as `float64`
	cmplStd/lib/math/Math.ci:781: referenced as `float64`
	cmplStd/lib/math/Math.ci:778: referenced as `float64`
	cmplStd/lib/math/Math.ci:766: referenced as `float64`
	cmplStd/lib/math/Math.ci:747: referenced as `float64`
	cmplStd/lib/math/Math.ci:746: referenced as `float64`
	cmplStd/lib/math/Math.ci:746: referenced as `float64`
	cmplStd/lib/math/Math.ci:741: referenced as `float64`
	cmplStd/lib/math/Math.ci:740: referenced as `float64`
	cmplStd/lib/math/Math.ci:739: referenced as `float64`
	cmplStd/lib/math/Math.ci:723: referenced as `float64`
	cmplStd/lib/math/Math.ci:719: referenced as `float64`
	cmplStd/lib/math/Math.ci:716: referenced as `float64`
	cmplStd/lib/math/Math.ci:699: referenced as `float64`
	cmplStd/lib/math/Math.ci:698: referenced as `float64`
	cmplStd/lib/math/Math.ci:698: referenced as `float64`
	cmplStd/lib/math/Math.ci:693: referenced as `float64`
	cmplStd/lib/math/Math.ci:693: referenced as `float64`
	cmplStd/lib/math/Math.ci:624: referenced as `float64`
	cmplStd/lib/math/Math.ci:623: referenced as `float64`
	cmplStd/lib/math/Math.ci:622: referenced as `float64`
	cmplStd/lib/math/Math.ci:610: referenced as `float64`
	cmplStd/lib/math/Math.ci:608: referenced as `float64`
	cmplStd/lib/math/Math.ci:607: referenced as `float64`
	cmplStd/lib/math/Math.ci:607: referenced as `float64`
	cmplStd/lib/math/Math.ci:607: referenced as `float64`
	cmplStd/lib/math/Math.ci:602: referenced as `float64`
	cmplStd/lib/math/Math.ci:535: referenced as `float64`
	cmplStd/lib/math/Math.ci:533: referenced as `float64`
	cmplStd/lib/math/Math.ci:532: referenced as `float64`
	cmplStd/lib/math/Math.ci:532: referenced as `float64`
	cmplStd/lib/math/Math.ci:527: referenced as `float64`
	cmplStd/lib/math/Math.ci:514: referenced as `float64`
	cmplStd/lib/math/Math.ci:513: referenced as `float64`
	cmplStd/lib/math/Math.ci:512: referenced as `float64`
	cmplStd/lib/math/Math.ci:505: referenced as `float64`
	cmplStd/lib/math/Math.ci:471: referenced as `float64`
	cmplStd/lib/math/Math.ci:468: referenced as `float64`
	cmplStd/lib/math/Math.ci:466: referenced as `float64`
	cmplStd/lib/math/Math.ci:465: referenced as `float64`
	cmplStd/lib/math/Math.ci:465: referenced as `float64`
	cmplStd/lib/math/Math.ci:460: referenced as `float64`
	cmplStd/lib/math/Math.ci:460: referenced as `float64`
	cmplStd/lib/math/Math.ci:457: referenced as `float64`
	cmplStd/lib/math/Math.ci:454: referenced as `float64`
	cmplStd/lib/math/Math.ci:450: referenced as `float64`
	cmplStd/lib/math/Math.ci:439: referenced as `float64`
	cmplStd/lib/math/Math.ci:438: referenced as `float64`
	cmplStd/lib/math/Math.ci:437: referenced as `float64`
	cmplStd/lib/math/Math.ci:436: referenced as `float64`
	cmplStd/lib/math/Math.ci:403: referenced as `float64`
	cmplStd/lib/math/Math.ci:400: referenced as `float64`
	cmplStd/lib/math/Math.ci:398: referenced as `float64`
	cmplStd/lib/math/Math.ci:397: referenced as `float64`
	cmplStd/lib/math/Math.ci:397: referenced as `float64`
	cmplStd/lib/math/Math.ci:388: referenced as `float64`
	cmplStd/lib/math/Math.ci:384: referenced as `float64`
	cmplStd/lib/math/Math.ci:350: referenced as `float64`
	cmplStd/lib/math/Math.ci:350: referenced as `float64`
	cmplStd/lib/math/Math.ci:309: referenced as `float64`
	cmplStd/lib/math/Math.ci:309: referenced as `float64`
	cmplStd/lib/math/Math.ci:293: referenced as `float64`
	cmplStd/lib/math/Math.ci:293: referenced as `float64`
	cmplStd/lib/math/Math.ci:293: referenced as `float64`
	cmplStd/lib/math/Math.ci:288: referenced as `float64`
	cmplStd/lib/math/Math.ci:281: referenced as `float64`
	cmplStd/lib/math/Math.ci:278: referenced as `float64`
	cmplStd/lib/math/Math.ci:278: referenced as `float64`
	cmplStd/lib/math/Math.ci:278: referenced as `float64`
	cmplStd/lib/math/Math.ci:270: referenced as `float64`
	cmplStd/lib/math/Math.ci:269: referenced as `float64`
	cmplStd/lib/math/Math.ci:269: referenced as `float64`
	cmplStd/lib/math/Math.ci:269: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:257: referenced as `float64`
	cmplStd/lib/math/Math.ci:257: referenced as `float64`
	cmplStd/lib/math/Math.ci:257: referenced as `float64`
	cmplStd/lib/math/Math.ci:257: referenced as `float64`
	cmplStd/lib/math/Math.ci:254: referenced as `float64`
	cmplStd/lib/math/Math.ci:254: referenced as `float64`
	cmplStd/lib/math/Math.ci:254: referenced as `float64`
	cmplStd/lib/math/Math.ci:251: referenced as `float64`
	cmplStd/lib/math/Math.ci:251: referenced as `float64`
	cmplStd/lib/math/Math.ci:246: referenced as `float64`
	cmplStd/lib/math/Math.ci:246: referenced as `float64`
	cmplStd/lib/math/Math.ci:238: referenced as `float64`
	cmplStd/lib/math/Math.ci:237: referenced as `float64`
	cmplStd/lib/math/Math.ci:237: referenced as `float64`
	cmplStd/lib/math/Math.ci:227: referenced as `float64`
	cmplStd/lib/math/Math.ci:223: referenced as `float64`
	cmplStd/lib/math/Math.ci:223: referenced as `float64`
	cmplStd/lib/math/Math.ci:213: referenced as `float64`
	cmplStd/lib/math/Math.ci:209: referenced as `float64`
	cmplStd/lib/math/Math.ci:209: referenced as `float64`
	cmplStd/lib/math/Math.ci:205: referenced as `float64`
	cmplStd/lib/math/Math.ci:205: referenced as `float64`
	cmplStd/lib/math/Math.ci:205: referenced as `float64`
	cmplStd/lib/math/Math.ci:202: referenced as `float64`
	cmplStd/lib/math/Math.ci:195: referenced as `float64`
	cmplStd/lib/math/Math.ci:195: referenced as `float64`
	cmplStd/lib/math/Math.ci:195: referenced as `float64`
	cmplStd/lib/math/Math.ci:189: referenced as `float64`
	cmplStd/lib/math/Math.ci:189: referenced as `float64`
	cmplStd/lib/math/Math.ci:189: referenced as `float64`
	cmplStd/lib/math/Math.ci:170: referenced as `float64`
	cmplStd/lib/math/Math.ci:170: referenced as `float64`
	cmplStd/lib/math/Math.ci:152: referenced as `float64`
	cmplStd/lib/math/Math.ci:152: referenced as `float64`
	cmplStd/lib/math/Math.ci:133: referenced as `float64`
	cmplStd/lib/math/Math.ci:110: referenced as `float64`
	cmplStd/lib/math/Math.ci:110: referenced as `float64`
	cmplStd/lib/math/Math.ci:110: referenced as `float64`
	cmplStd/lib/math/Math.ci:98: referenced as `float64`
	cmplStd/lib/math/Math.ci:76: referenced as `float64`
	cmplStd/lib/math/Math.ci:70: referenced as `float64`
	cmplStd/lib/math/Math.ci:53: referenced as `float64`
	cmplStd/lib/math/Math.ci:52: referenced as `float64`
	cmplStd/lib/math/Math.ci:52: referenced as `float64`
	cmplStd/lib/math/Math.ci:40: referenced as `float64`
	cmplStd/lib/math/Math.ci:34: referenced as `float64`
	cmplStd/lib/math/Math.ci:29: referenced as `float64`
	cmplStd/lib/math/Math.ci:23: referenced as `float64`
	cmplStd/lib/math/Math.ci:5: referenced as `float64`
	cmplStd/lib/math/Bits.ci:37: referenced as `float64`
	cmplStd/lib/math/Bits.ci:35: referenced as `float64`
	cmplStd/lib/math/Bits.ci:30: referenced as `float64`
	cmplStd/lib/math/Bits.ci:30: referenced as `float64`
	cmplStd/lib.ci:11: referenced as `float64`
	internal usages: 25
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(42)
.usages:
	cmplStd/lib/math/Math.ci:903: referenced as `sin`
	cmplStd/lib/math/Math.ci:901: referenced as `sin`
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(43)
.usages:
	cmplStd/lib/math/Math.ci:933: referenced as `cos`
	cmplStd/lib/math/Math.ci:931: referenced as `cos`
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(44)
.usages:
	cmplStd/lib/math/Math.ci:966: referenced as `tan`
	cmplStd/lib/math/Math.ci:964: referenced as `tan`
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(45)
.usages:
	cmplStd/lib/math/Math.ci:400: referenced as `log`
	cmplStd/lib/math/Math.ci:398: referenced as `log`
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(46)
.usages:
	cmplStd/lib/math/Math.ci:468: referenced as `exp`
	cmplStd/lib/math/Math.ci:466: referenced as `exp`
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(47)
.usages:
	cmplStd/lib/math/Math.ci:610: referenced as `pow`
	cmplStd/lib/math/Math.ci:608: referenced as `pow`
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(48)
.usages:
	cmplStd/lib/math/Math.ci:535: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:533: referenced as `sqrt`
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(49)
.usages:
	cmplStd/lib/math/Math.ci:868: referenced as `atan2`
	cmplStd/lib/math/Math.ci:866: referenced as `atan2`
}
float64.ldexp(x: float64, exp: int32): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ldexp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param exp: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(50)
.usages:
}
float64.frexp(x: float64, exp: int32): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'frexp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param exp: int32 (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(51)
.usages:
}
float64.parse(value: char[], out: float64): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'parse'
.owner: float64
.param .result: int32 (size: 4, cast: inline)
.param value: char[] (size: 8, cast: const variable(arr))
.param out: float64 (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(52)
.usages:
	cmplStd/lib/text/cstr.ci:121: referenced as `parse`
	cmplStd/lib/text/cstr.ci:119: referenced as `parse`
}
float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'print'
.owner: float64
.field flagMinus: int64 (size: 0, cast: static const i64)
.field flagPlus: int64 (size: 0, cast: static const i64)
.field flagSpace: int64 (size: 0, cast: static const i64)
.field flagHash: int64 (size: 0, cast: static const i64)
.field flagZero: int64 (size: 0, cast: static const i64)
.param .result: int32 (size: 4, cast: inline)
.param out: char[] (size: 8, cast: variable(arr))
.param value: float64 (size: 8, cast: variable(f64))
.param flags: int32 (size: 4, cast: variable(i32))
.param width: int32 (size: 4, cast: variable(i32))
.param precision: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(53)
.usages:
}
float64.print.flagMinus: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagMinus'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 1
}
float64.print.flagPlus: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagPlus'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 2
}
float64.print.flagSpace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagSpace'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 4
}
float64.print.flagHash: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagHash'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 8
}
float64.print.flagZero: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagZero'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 16
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'pointer'
.field alloc: function (size: 0, cast: static const inline)
.field fill: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field move: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:283: referenced as `pointer`
	cmplStd/test/lang/reflect.ci:16: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:108: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:90: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:70: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:52: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:51: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:49: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:48: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:47: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:46: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:45: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:44: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:43: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:42: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:41: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:40: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:39: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:38: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:37: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:36: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:35: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:30: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:17: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:9: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:14: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:13: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:12: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:11: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:10: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:2: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:35: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:30: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:16: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:12: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:6: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:3: referenced as `pointer`
	cmplStd/test/lang/memory.ci:30: referenced as `pointer`
	cmplStd/test/lang/memory.ci:30: referenced as `pointer`
	cmplStd/test/lang/memory.ci:29: referenced as `pointer`
	cmplStd/test/lang/memory.ci:29: referenced as `pointer`
	cmplStd/test/lang/memory.ci:29: referenced as `pointer`
	cmplStd/test/lang/memory.ci:14: referenced as `pointer`
	cmplStd/test/lang/memory.ci:13: referenced as `pointer`
	cmplStd/test/lang/memory.ci:10: referenced as `pointer`
	cmplStd/test/lang/memory.ci:9: referenced as `pointer`
	cmplStd/test/lang/memory.ci:8: referenced as `pointer`
	cmplStd/test/lang/memory.ci:7: referenced as `pointer`
	cmplStd/test/lang/memory.ci:5: referenced as `pointer`
	cmplStd/test/lang/memory.ci:5: referenced as `pointer`
	cmplStd/test/lang/memory.ci:4: referenced as `pointer`
	cmplStd/test/lang/memory.ci:3: referenced as `pointer`
	cmplStd/test/lang/memory.ci:3: referenced as `pointer`
	cmplStd/test/lang/emit.ci:30: referenced as `pointer`
	cmplGfx/lib/micro.ui.ci:342: referenced as `pointer`
	cmplGfx/lib/micro.ui.ci:224: referenced as `pointer`
	cmplGfx/lib/micro.ui.ci:90: referenced as `pointer`
	cmplGfx/lib/micro.ui.core.ci:625: referenced as `pointer`
	cmplGfx/lib/micro.ui.core.ci:524: referenced as `pointer`
	cmplGfx/lib/micro.ui.core.ci:523: referenced as `pointer`
	cmplGfx/lib/micro.ui.core.ci:522: referenced as `pointer`
	cmplGfx/lib/micro.ui.core.ci:355: referenced as `pointer`
	cmplGfx/lib/micro.ui.core.ci:270: referenced as `pointer`
	cmplGfx/lib/color.lookup.ci:4: referenced as `pointer`
	cmplGfx/lib/image.transform.ci:4: referenced as `pointer`
	cmplGfx/lib/image.blend.ci:106: referenced as `pointer`
	cmplGfx/lib/image.blend.ci:4: referenced as `pointer`
	cmplGfx/lib/image.blend.ci:2: referenced as `pointer`
	cmplGfx/lib/image.blend.ci:2: referenced as `pointer`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `pointer`
	cmplStd/lib/math/Polynomial.ci:55: referenced as `pointer`
	cmplStd/lib/text/stream/ByteStream.ci:181: referenced as `pointer`
	cmplStd/lib/text/stream/ByteStream.ci:164: referenced as `pointer`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `pointer`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `pointer`
	cmplStd/lib/text/Format.ci:316: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `pointer`
	internal usages: 19
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param ptr: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(13)
.usages:
	cmplStd/test/lang/memory.ci:5: referenced as `alloc`
	cmplStd/test/lang/memory.ci:4: referenced as `alloc`
	cmplStd/test/lang/memory.ci:3: referenced as `alloc`
	cmplGfx/lib/micro.ui.core.ci:625: referenced as `alloc`
	cmplGfx/lib/micro.ui.core.ci:524: referenced as `alloc`
	cmplGfx/lib/micro.ui.core.ci:522: referenced as `alloc`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `alloc`
	cmplStd/lib/math/Polynomial.ci:55: referenced as `alloc`
	cmplStd/lib/text/stream/ByteStream.ci:181: referenced as `alloc`
	cmplStd/lib/text/stream/ByteStream.ci:164: referenced as `alloc`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `alloc`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `alloc`
}
pointer.fill(dst: pointer, value: uint8, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param value: uint8 (size: 4, cast: variable(u32))
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(14)
.usages:
	cmplStd/test/lang/memory.ci:30: referenced as `fill`
	cmplStd/test/lang/memory.ci:13: referenced as `fill`
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(15)
.usages:
	cmplStd/test/lang/memory.ci:14: referenced as `copy`
	cmplGfx/lib/micro.ui.core.ci:523: referenced as `copy`
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(16)
.usages:
	cmplStd/test/lang/memory.ci:29: referenced as `move`
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.name: 'variant'
.field as: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/reflect.ci:17: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:105: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:91: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:72: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:70: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:69: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:68: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:67: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:66: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:65: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:64: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:63: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:62: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:61: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:60: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:59: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:58: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:57: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:56: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:55: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:51: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:31: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:24: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:18: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:10: referenced as `variant`
	cmplGfx/lib/micro.ui.ci:836: referenced as `variant`
	cmplGfx/lib/micro.ui.ci:756: referenced as `variant`
	cmplGfx/lib/micro.ui.core.ci:247: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:63: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:44: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:44: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:40: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:37: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:34: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:29: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:27: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:22: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:19: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:16: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:13: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:10: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:7: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:4: referenced as `variant`
	internal usages: 2
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, cast: inline)
.param var: variant (size: 8, cast: variable(var))
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(1)
.usages:
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'function'
.doc: '@builtin'
.usages:
	cmplStd/test/lang/reflect.ci:19: referenced as `function`
	cmplStd/test/lang/init.reference.ci:89: referenced as `function`
	cmplStd/test/lang/init.reference.ci:69: referenced as `function`
	cmplStd/test/lang/init.reference.ci:49: referenced as `function`
	cmplStd/test/lang/init.reference.ci:20: referenced as `function`
	cmplStd/lib.ci:16: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'object'
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/recUnion.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:20: referenced as `object`
	cmplStd/test/lang/init.variable.ci:41: referenced as `object`
	cmplStd/test/lang/init.variable.ci:13: referenced as `object`
	cmplStd/test/lang/init.reference.ci:92: referenced as `object`
	cmplStd/test/lang/init.reference.ci:72: referenced as `object`
	cmplStd/test/lang/init.reference.ci:52: referenced as `object`
	cmplStd/test/lang/init.reference.ci:21: referenced as `object`
	cmplGfx/lib/micro.ui.core.ci:227: referenced as `object`
	cmplFile/lib.ci:16: referenced as `object`
	cmplStd/lib/text/stream/TextStream.ci:50: referenced as `object`
	cmplStd/lib/text/stream/ByteStream.ci:2: referenced as `object`
	internal usages: 3
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: object
.param .result: pointer (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: object
.param .result: void (size: 0, cast: inline)
.param this: object (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(8)
.usages:
	cmplGfx/lib/micro.ui.ci:1112: referenced as `destroy`
	cmplGfx/lib/micro.ui.core.ci:623: referenced as `destroy`
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'as'
.owner: object
.param .result: pointer (size: 4, cast: inline)
.param this: object (size: 4, cast: variable(ref))
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(9)
.usages:
	cmplGfx/lib/micro.ui.ci:1332: referenced as `as`
	cmplGfx/lib/micro.ui.ci:1069: referenced as `as`
	cmplGfx/lib/micro.ui.ci:1046: referenced as `as`
	cmplGfx/lib/micro.ui.ci:890: referenced as `as`
	cmplGfx/lib/micro.ui.ci:790: referenced as `as`
	cmplGfx/lib/micro.ui.ci:679: referenced as `as`
	cmplGfx/lib/micro.ui.ci:678: referenced as `as`
	cmplGfx/lib/micro.ui.ci:666: referenced as `as`
	cmplGfx/lib/micro.ui.ci:664: referenced as `as`
	cmplGfx/lib/micro.ui.ci:658: referenced as `as`
	cmplGfx/lib/micro.ui.ci:652: referenced as `as`
	cmplGfx/lib/micro.ui.ci:642: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:1257: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:1247: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:1233: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:1137: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:1122: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:1106: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:1039: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:1022: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:966: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:881: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:731: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:502: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:479: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:464: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:449: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:441: referenced as `as`
	cmplGfx/lib/micro.ui.core.ci:433: referenced as `as`
}
object.type(this: object): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'type'
.owner: object
.param .result: typename (size: 4, cast: inline)
.param this: object (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(10)
.usages:
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.name: 'null'
.doc: '@builtin'
.value: {pointer @0}
.usages:
	cmplStd/test/lang/stmt.if.ci:73: referenced as `null`
	cmplStd/test/lang/useOperator.ci:283: referenced as `null`
	cmplStd/test/lang/init.method.ci:92: referenced as `null`
	cmplStd/test/lang/init.method.ci:86: referenced as `null`
	cmplStd/test/lang/init.reference.ci:21: referenced as `null`
	cmplStd/test/lang/init.reference.ci:20: referenced as `null`
	cmplStd/test/lang/init.reference.ci:19: referenced as `null`
	cmplStd/test/lang/init.reference.ci:18: referenced as `null`
	cmplStd/test/lang/init.reference.ci:17: referenced as `null`
	cmplStd/test/lang/init.reference.ci:16: referenced as `null`
	cmplStd/test/lang/init.reference.ci:3: referenced as `null`
	cmplStd/test/lang/tryExec.ci:45: referenced as `null`
	cmplStd/test/lang/tryExec.ci:44: referenced as `null`
	cmplStd/test/lang/tryExec.ci:43: referenced as `null`
	cmplStd/test/lang/tryExec.ci:42: referenced as `null`
	cmplStd/test/lang/tryExec.ci:41: referenced as `null`
	cmplStd/test/lang/tryExec.ci:40: referenced as `null`
	cmplStd/test/lang/tryExec.ci:40: referenced as `null`
	cmplStd/test/lang/tryExec.ci:39: referenced as `null`
	cmplStd/test/lang/tryExec.ci:31: referenced as `null`
	cmplStd/test/lang/memory.ci:4: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.ci:1102: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.ci:886: referenced as `null`
	cmplGfx/lib/micro.ui.ci:791: referenced as `null`
	cmplGfx/lib/micro.ui.ci:765: referenced as `null`
	cmplGfx/lib/micro.ui.ci:758: referenced as `null`
	cmplGfx/lib/micro.ui.ci:757: referenced as `null`
	cmplGfx/lib/micro.ui.ci:753: referenced as `null`
	cmplGfx/lib/micro.ui.ci:752: referenced as `null`
	cmplGfx/lib/micro.ui.ci:751: referenced as `null`
	cmplGfx/lib/micro.ui.ci:725: referenced as `null`
	cmplGfx/lib/micro.ui.ci:707: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.ci:643: referenced as `null`
	cmplGfx/lib/micro.ui.ci:631: referenced as `null`
	cmplGfx/lib/micro.ui.ci:630: referenced as `null`
	cmplGfx/lib/micro.ui.ci:343: referenced as `null`
	cmplGfx/lib/micro.ui.ci:323: referenced as `null`
	cmplGfx/lib/micro.ui.ci:142: referenced as `null`
	cmplGfx/lib/micro.ui.ci:15: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1266: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1258: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1239: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1232: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1191: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1189: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1137: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1122: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1107: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1093: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1087: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1039: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:610: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:558: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:532: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:522: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:490: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:481: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:476: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:466: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:461: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:1309: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:398: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:396: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:371: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:365: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:269: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:268: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:266: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:247: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:244: referenced as `null`
	cmplGfx/lib/micro.ui.core.ci:241: referenced as `null`
	cmplGfx/lib/window.ci:142: referenced as `null`
	cmplGfx/lib/window.ci:125: referenced as `null`
	cmplGfx/lib/window.ci:125: referenced as `null`
	cmplGfx/lib/window.ci:124: referenced as `null`
	cmplGfx/lib/window.ci:108: referenced as `null`
	cmplGfx/lib/window.ci:47: referenced as `null`
	cmplGfx/lib/window.ci:45: referenced as `null`
	cmplGfx/lib/window.ci:45: referenced as `null`
	cmplGfx/lib/window.ci:45: referenced as `null`
	cmplGfx/lib/window.ci:11: referenced as `null`
	cmplGfx/lib/window.ci:11: referenced as `null`
	cmplGfx/lib/window.ci:10: referenced as `null`
	cmplGfx/lib/color.matrix.ci:13: referenced as `null`
	cmplGfx/lib/color.matrix.ci:12: referenced as `null`
	cmplGfx/lib/color.matrix.ci:11: referenced as `null`
	cmplGfx/lib/color.matrix.ci:10: referenced as `null`
	cmplGfx/lib/color.matrix.ci:3: referenced as `null`
	cmplGfx/lib/color.lookup.ci:14: referenced as `null`
	cmplGfx/lib/color.lookup.ci:13: referenced as `null`
	cmplGfx/lib/color.lookup.ci:12: referenced as `null`
	cmplGfx/lib/color.lookup.ci:11: referenced as `null`
	cmplGfx/lib/color.lookup.ci:3: referenced as `null`
	cmplGfx/lib/image.blur.ci:3: referenced as `null`
	cmplGfx/lib/image.transform.ci:131: referenced as `null`
	cmplGfx/lib/image.transform.ci:131: referenced as `null`
	cmplGfx/lib/image.transform.ci:64: referenced as `null`
	cmplGfx/lib/image.transform.ci:22: referenced as `null`
	cmplGfx/lib/image.transform.ci:20: referenced as `null`
	cmplGfx/lib/image.transform.ci:19: referenced as `null`
	cmplGfx/lib/image.transform.ci:18: referenced as `null`
	cmplGfx/lib/image.transform.ci:17: referenced as `null`
	cmplGfx/lib/image.transform.ci:14: referenced as `null`
	cmplGfx/lib/image.transform.ci:13: referenced as `null`
	cmplGfx/lib/image.transform.ci:12: referenced as `null`
	cmplGfx/lib/image.transform.ci:11: referenced as `null`
	cmplGfx/lib/image.transform.ci:3: referenced as `null`
	cmplGfx/lib/image.blend.ci:164: referenced as `null`
	cmplGfx/lib/image.blend.ci:163: referenced as `null`
	cmplGfx/lib/image.blend.ci:162: referenced as `null`
	cmplGfx/lib/image.blend.ci:161: referenced as `null`
	cmplGfx/lib/image.blend.ci:136: referenced as `null`
	cmplGfx/lib/image.blend.ci:135: referenced as `null`
	cmplGfx/lib/image.blend.ci:134: referenced as `null`
	cmplGfx/lib/image.blend.ci:133: referenced as `null`
	cmplGfx/lib/image.blend.ci:126: referenced as `null`
	cmplGfx/lib/image.blend.ci:120: referenced as `null`
	cmplGfx/lib/image.blend.ci:120: referenced as `null`
	cmplGfx/lib/image.blend.ci:115: referenced as `null`
	cmplGfx/lib/image.blend.ci:103: referenced as `null`
	cmplGfx/lib/image.blend.ci:102: referenced as `null`
	cmplGfx/lib/image.blend.ci:85: referenced as `null`
	cmplGfx/lib/image.blend.ci:80: referenced as `null`
	cmplGfx/lib/image.blend.ci:80: referenced as `null`
	cmplGfx/lib/image.blend.ci:69: referenced as `null`
	cmplGfx/lib/image.blend.ci:69: referenced as `null`
	cmplGfx/lib/image.blend.ci:68: referenced as `null`
	cmplGfx/lib/image.blend.ci:61: referenced as `null`
	cmplGfx/lib/image.blend.ci:61: referenced as `null`
	cmplGfx/lib/image.blend.ci:60: referenced as `null`
	cmplGfx/lib/image.blend.ci:54: referenced as `null`
	cmplGfx/lib/image.blend.ci:34: referenced as `null`
	cmplGfx/lib/image.blend.ci:12: referenced as `null`
	cmplGfx/lib/image.blend.ci:11: referenced as `null`
	cmplGfx/lib/image.blend.ci:10: referenced as `null`
	cmplGfx/lib/image.blend.ci:9: referenced as `null`
	cmplGfx/lib/image.blend.ci:3: referenced as `null`
	cmplGfx/lib/image.draw.rect.ci:3: referenced as `null`
	cmplGfx/lib/image.draw.ci:1: referenced as `null`
	cmplGfx/lib/image.ci:19: referenced as `null`
	cmplGfx/lib/image.ci:11: referenced as `null`
	cmplGfx/lib/image.ci:6: referenced as `null`
	cmplGfx/lib/color.ci:168: referenced as `null`
	cmplFile/lib/FileStream.ci:92: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:178: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:164: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:155: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:135: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:106: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `null`
	cmplStd/lib/math/Easing.ci:110: referenced as `null`
	cmplStd/lib/math/Easing.ci:101: referenced as `null`
	cmplStd/lib/math/Easing.ci:93: referenced as `null`
	cmplStd/lib/math/Easing.ci:85: referenced as `null`
	cmplStd/lib/text/stream/ByteStream.ci:183: referenced as `null`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `null`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `null`
	cmplStd/lib/text/stream/ByteStream.ci:8: referenced as `null`
	cmplStd/lib/text/Format.ci:316: referenced as `null`
	cmplStd/lib/text/Format.ci:88: referenced as `null`
	cmplStd/lib/text/cstr.ci:119: referenced as `null`
	cmplStd/lib/text/cstr.ci:5: referenced as `null`
	cmplStd/lib/math/Math.ci:1003: referenced as `null`
	cmplStd/lib/math/Math.ci:986: referenced as `null`
	cmplStd/lib/math/Math.ci:964: referenced as `null`
	cmplStd/lib/math/Math.ci:944: referenced as `null`
	cmplStd/lib/math/Math.ci:931: referenced as `null`
	cmplStd/lib/math/Math.ci:911: referenced as `null`
	cmplStd/lib/math/Math.ci:901: referenced as `null`
	cmplStd/lib/math/Math.ci:890: referenced as `null`
	cmplStd/lib/math/Math.ci:866: referenced as `null`
	cmplStd/lib/math/Math.ci:688: referenced as `null`
	cmplStd/lib/math/Math.ci:608: referenced as `null`
	cmplStd/lib/math/Math.ci:597: referenced as `null`
	cmplStd/lib/math/Math.ci:533: referenced as `null`
	cmplStd/lib/math/Math.ci:522: referenced as `null`
	cmplStd/lib/math/Math.ci:466: referenced as `null`
	cmplStd/lib/math/Math.ci:445: referenced as `null`
	cmplStd/lib/math/Math.ci:398: referenced as `null`
	cmplStd/lib/math/Bits.ci:490: referenced as `null`
	cmplStd/lib/math/Bits.ci:472: referenced as `null`
	cmplStd/lib/math/Bits.ci:453: referenced as `null`
	cmplStd/lib/math/Bits.ci:434: referenced as `null`
	cmplStd/lib/math/Bits.ci:390: referenced as `null`
	cmplStd/lib/math/Bits.ci:371: referenced as `null`
	cmplStd/lib/math/Bits.ci:281: referenced as `null`
	cmplStd/lib/math/Bits.ci:240: referenced as `null`
	cmplStd/lib/math/Bits.ci:151: referenced as `null`
	cmplStd/lib/math/Bits.ci:111: referenced as `null`
	cmplStd/lib/math/Bits.ci:71: referenced as `null`
	cmplStd/lib/math/Bits.ci:61: referenced as `null`
	cmplStd/lib/math/Bits.ci:51: referenced as `null`
	cmplStd/lib/math/Bits.ci:41: referenced as `null`
	cmplStd/lib/lang/Debug.ci:72: referenced as `null`
	cmplStd/lib/lang/Debug.ci:48: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.name: 'emit'
.field nop: void (size: 0, cast: static const inline)
.field not: bool (size: 0, cast: static const inline)
.field set: void (size: 0, cast: static const inline)
.field ret: void (size: 0, cast: static const inline)
.field call: void (size: 0, cast: static const inline)
.field p4x: typename (size: 16, cast: static const typename(val))
.field dup: typename (size: 0, cast: static const typename(void))
.field load: typename (size: 0, cast: static const typename(void))
.field store: typename (size: 0, cast: static const typename(void))
.field cmt: typename (size: 0, cast: static const typename(void))
.field and: typename (size: 0, cast: static const typename(void))
.field or: typename (size: 0, cast: static const typename(void))
.field xor: typename (size: 0, cast: static const typename(void))
.field shl: typename (size: 0, cast: static const typename(void))
.field shr: typename (size: 0, cast: static const typename(void))
.field neg: typename (size: 0, cast: static const typename(void))
.field add: typename (size: 0, cast: static const typename(void))
.field sub: typename (size: 0, cast: static const typename(void))
.field mul: typename (size: 0, cast: static const typename(void))
.field div: typename (size: 0, cast: static const typename(void))
.field mod: typename (size: 0, cast: static const typename(void))
.field ceq: typename (size: 0, cast: static const typename(void))
.field clt: typename (size: 0, cast: static const typename(void))
.field cgt: typename (size: 0, cast: static const typename(void))
.field min: typename (size: 0, cast: static const typename(void))
.field max: typename (size: 0, cast: static const typename(void))
.field swz: typename (size: 0, cast: static const typename(void))
.doc: '@builtin'
.usages:
	cmplStd/test/lang/tryExec.ci:36: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:30: referenced as `emit`
	cmplStd/test/lang/emit.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:19: referenced as `emit`
	cmplStd/test/lang/emit.ci:16: referenced as `emit`
	cmplStd/test/lang/emit.ci:13: referenced as `emit`
	cmplStd/test/lang/emit.ci:10: referenced as `emit`
	cmplStd/test/lang/emit.ci:4: referenced as `emit`
	cmplStd/test/lang/emit.ci:3: referenced as `emit`
	cmplGfx/lib/micro.ui.core.ci:270: referenced as `emit`
	cmplGfx/lib/color.ci:23: referenced as `emit`
	cmplGfx/lib/color.ci:21: referenced as `emit`
	cmplStd/lib/time/Datetime.ci:32: referenced as `emit`
	cmplStd/lib/time/Datetime.ci:17: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:103: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `emit`
	cmplStd/lib/math/Complex.ci:44: referenced as `emit`
	cmplStd/lib/math/Complex.ci:37: referenced as `emit`
	cmplStd/lib/math/Complex.ci:30: referenced as `emit`
	cmplStd/lib/math/Complex.ci:27: referenced as `emit`
	cmplStd/lib/math/Bits.ci:37: referenced as `emit`
	cmplStd/lib/math/Bits.ci:35: referenced as `emit`
	cmplStd/lib/math/Bits.ci:33: referenced as `emit`
	cmplStd/lib/math/Bits.ci:30: referenced as `emit`
	cmplStd/lib/math/Bits.ci:28: referenced as `emit`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `emit`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'nop'
.owner: emit
.doc: '@builtin'
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'not'
.owner: emit
.doc: '@builtin'
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'set'
.owner: emit
.doc: '@builtin'
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'ret'
.owner: emit
.doc: '@builtin'
.value: ret
.usages:
	cmplStd/test/lang/tryExec.ci:36: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'call'
.owner: emit
.doc: '@builtin'
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, cast: static const inline)
.field dp4: float32 (size: 0, cast: static const inline)
.field dph: float32 (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector4f.ci:131: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp3'
.owner: emit.p4x
.doc: '@builtin'
.value: dp3.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:123: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp4'
.owner: emit.p4x
.doc: '@builtin'
.value: dp4.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:131: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dph'
.owner: emit.p4x
.doc: '@builtin'
.value: dph.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:127: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, cast: static const inline)
.field x2: int64 (size: 0, cast: static const inline)
.field x4: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x1'
.owner: emit.dup
.doc: '@builtin'
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'x2'
.owner: emit.dup
.doc: '@builtin'
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'x4'
.owner: emit.dup
.doc: '@builtin'
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, cast: static const inline)
.field z64: int64 (size: 0, cast: static const inline)
.field z128: emit.p4x (size: 0, cast: static const inline)
.field i8: int32 (size: 0, cast: static const inline)
.field u8: int32 (size: 0, cast: static const inline)
.field i16: int32 (size: 0, cast: static const inline)
.field u16: int32 (size: 0, cast: static const inline)
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field i128: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/tryExec.ci:36: referenced as `load`
	cmplStd/test/lang/emit.ci:4: referenced as `load`
	cmplStd/test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'z32'
.owner: emit.load
.doc: '@builtin'
.value: load.z32
.usages:
	cmplStd/test/lang/tryExec.ci:36: referenced as `z32`
	cmplStd/test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'z64'
.owner: emit.load
.doc: '@builtin'
.value: load.z64
.usages:
	cmplStd/test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'z128'
.owner: emit.load
.doc: '@builtin'
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i8'
.owner: emit.load
.doc: '@builtin'
.value: load.is8
}
emit.load.u8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'u8'
.owner: emit.load
.doc: '@builtin'
.value: load.iu8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i16'
.owner: emit.load
.doc: '@builtin'
.value: load.is16
}
emit.load.u16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'u16'
.owner: emit.load
.doc: '@builtin'
.value: load.iu16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.load
.doc: '@builtin'
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.load
.doc: '@builtin'
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'i128'
.owner: emit.load
.doc: '@builtin'
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'store'
.owner: emit
.field i8: void (size: 0, cast: static const inline)
.field i16: void (size: 0, cast: static const inline)
.field i32: void (size: 0, cast: static const inline)
.field i64: void (size: 0, cast: static const inline)
.field i128: void (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i8'
.owner: emit.store
.doc: '@builtin'
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i16'
.owner: emit.store
.doc: '@builtin'
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i32'
.owner: emit.store
.doc: '@builtin'
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i64'
.owner: emit.store
.doc: '@builtin'
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i128'
.owner: emit.store
.doc: '@builtin'
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.cmt
.doc: '@builtin'
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.cmt
.doc: '@builtin'
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.and
.doc: '@builtin'
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.and
.doc: '@builtin'
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.or
.doc: '@builtin'
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.or
.doc: '@builtin'
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.xor
.doc: '@builtin'
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.xor
.doc: '@builtin'
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shl
.doc: '@builtin'
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shl
.doc: '@builtin'
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.shr
.doc: '@builtin'
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.shr
.doc: '@builtin'
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shr
.doc: '@builtin'
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shr
.doc: '@builtin'
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Complex.ci:27: referenced as `neg`
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.neg
.doc: '@builtin'
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.neg
.doc: '@builtin'
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.neg
.doc: '@builtin'
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.neg
.doc: '@builtin'
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.neg
.doc: '@builtin'
.value: neg.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.neg
.doc: '@builtin'
.value: neg.v2d
.usages:
	cmplStd/lib/math/Complex.ci:27: referenced as `p2d`
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `add`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `add`
	cmplStd/lib/math/Complex.ci:45: referenced as `add`
	cmplStd/lib/math/Complex.ci:30: referenced as `add`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `add`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.add
.doc: '@builtin'
.value: add.i32
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `i32`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.add
.doc: '@builtin'
.value: add.i64
.usages:
	cmplStd/lib/lang/Pointer.ci:7: referenced as `i64`
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.add
.doc: '@builtin'
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.add
.doc: '@builtin'
.value: add.f64
.usages:
	cmplStd/lib/math/Complex.ci:45: referenced as `f64`
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.add
.doc: '@builtin'
.value: add.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:71: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.add
.doc: '@builtin'
.value: add.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:22: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:30: referenced as `p2d`
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `sub`
	cmplStd/lib/math/Complex.ci:46: referenced as `sub`
	cmplStd/lib/math/Complex.ci:37: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.sub
.doc: '@builtin'
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.sub
.doc: '@builtin'
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.sub
.doc: '@builtin'
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.sub
.doc: '@builtin'
.value: sub.f64
.usages:
	cmplStd/lib/math/Complex.ci:46: referenced as `f64`
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.sub
.doc: '@builtin'
.value: sub.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:73: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.sub
.doc: '@builtin'
.value: sub.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:37: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `mul`
	cmplStd/lib/math/Complex.ci:46: referenced as `mul`
	cmplStd/lib/math/Complex.ci:45: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mul
.doc: '@builtin'
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mul
.doc: '@builtin'
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mul
.doc: '@builtin'
.value: mul.u32
}
emit.mul.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.mul
.doc: '@builtin'
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mul
.doc: '@builtin'
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mul
.doc: '@builtin'
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.mul
.doc: '@builtin'
.value: mul.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:75: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.mul
.doc: '@builtin'
.value: mul.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:46: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:45: referenced as `p2d`
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `div`
	cmplStd/test/lang/emit.ci:13: referenced as `div`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.div
.doc: '@builtin'
.value: div.i32
.usages:
	cmplStd/test/lang/emit.ci:13: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.div
.doc: '@builtin'
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.div
.doc: '@builtin'
.value: div.u32
}
emit.div.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.div
.doc: '@builtin'
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.div
.doc: '@builtin'
.value: div.f32
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `f32`
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.div
.doc: '@builtin'
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.div
.doc: '@builtin'
.value: div.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:77: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.div
.doc: '@builtin'
.value: div.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:31: referenced as `p2d`
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mod
.doc: '@builtin'
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mod
.doc: '@builtin'
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mod
.doc: '@builtin'
.value: mod.u32
}
emit.mod.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.mod
.doc: '@builtin'
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mod
.doc: '@builtin'
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mod
.doc: '@builtin'
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.field p4f: bool (size: 0, cast: static const inline)
.field p2d: bool (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `ceq`
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p4f'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p2d'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `p2d`
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.clt
.doc: '@builtin'
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.clt
.doc: '@builtin'
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.clt
.doc: '@builtin'
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.clt
.doc: '@builtin'
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.clt
.doc: '@builtin'
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.clt
.doc: '@builtin'
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector4f.ci:103: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.min
.doc: '@builtin'
.value: min.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:103: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.min
.doc: '@builtin'
.value: min.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `p2d`
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector4f.ci:105: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.max
.doc: '@builtin'
.value: max.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:105: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.max
.doc: '@builtin'
.value: max.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `p2d`
}
emit.swz: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'swz'
.owner: emit
.field x2: int32 (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Complex.ci:46: referenced as `swz`
	cmplStd/lib/math/Complex.ci:45: referenced as `swz`
}
emit.swz.x2: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x2'
.owner: emit.swz
.doc: '@builtin'
.value: swz.p4x zwxy(4e)
.usages:
	cmplStd/lib/math/Complex.ci:46: referenced as `x2`
	cmplStd/lib/math/Complex.ci:45: referenced as `x2`
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'halt'
.param .result: void (size: 0, cast: inline)
.doc: '@builtin'
.value: nfc(0)
.usages:
}
preferNativeCalls: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'preferNativeCalls'
.doc: '@builtin'
.value: 1
.usages:
	cmplGfx/lib/color.matrix.ci:3: referenced as `preferNativeCalls`
	cmplGfx/lib/color.lookup.ci:3: referenced as `preferNativeCalls`
	cmplGfx/lib/image.blur.ci:3: referenced as `preferNativeCalls`
	cmplGfx/lib/image.transform.ci:3: referenced as `preferNativeCalls`
	cmplGfx/lib/image.blend.ci:102: referenced as `preferNativeCalls`
	cmplGfx/lib/image.blend.ci:85: referenced as `preferNativeCalls`
	cmplGfx/lib/image.blend.ci:68: referenced as `preferNativeCalls`
	cmplGfx/lib/image.blend.ci:54: referenced as `preferNativeCalls`
	cmplGfx/lib/image.blend.ci:3: referenced as `preferNativeCalls`
	cmplGfx/lib/image.draw.rect.ci:3: referenced as `preferNativeCalls`
	cmplStd/lib/text/cstr.ci:119: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:1003: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:986: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:964: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:944: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:931: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:911: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:901: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:890: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:866: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:688: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:608: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:597: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:533: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:522: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:466: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:445: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:398: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:490: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:472: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:453: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:434: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:390: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:371: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:281: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:240: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:151: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:111: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:71: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:61: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:51: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:41: referenced as `preferNativeCalls`
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'raise'
.field abort: int64 (size: 0, cast: static const i64)
.field error: int64 (size: 0, cast: static const i64)
.field warn: int64 (size: 0, cast: static const i64)
.field info: int64 (size: 0, cast: static const i64)
.field debug: int64 (size: 0, cast: static const i64)
.field verbose: int64 (size: 0, cast: static const i64)
.field noTrace: int64 (size: 0, cast: static const i64)
.field defTrace: int64 (size: 0, cast: static const i64)
.param .result: void (size: 0, cast: inline)
.param file: char[*] (size: 4, cast: const variable(ref))
.param line: int32 (size: 4, cast: variable(i32))
.param level: int32 (size: 4, cast: variable(i32))
.param trace: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: const variable(ref))
.param details: variant[] (size: 8, cast: const variable(arr))
.doc: 'Report messages or raise errors.'
.value: nfc(11)
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:69: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:69: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:69: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:53: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:53: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:53: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:29: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:29: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:29: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:27: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:27: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:27: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:24: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:24: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:24: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:22: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:22: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:22: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:19: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:19: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:19: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:16: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:16: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:16: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:13: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:13: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:13: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:10: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:10: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:10: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:7: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:7: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:7: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:4: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:4: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:4: referenced as `raise`
	cmplStd/lib.ci:16: referenced as `raise`
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: -2
.usages:
	cmplStd/lib/lang/Debug.ci:69: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:53: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:29: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:27: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:24: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:22: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: -1
.usages:
	cmplStd/lib/lang/Debug.ci:19: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 1
.usages:
	cmplStd/lib/lang/Debug.ci:16: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 13
.usages:
	cmplStd/lib/lang/Debug.ci:13: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 14
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `debug`
	cmplStd/lib/lang/Debug.ci:10: referenced as `debug`
	cmplStd/lib/lang/Debug.ci:7: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 15
.usages:
	cmplStd/lib/lang/Debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/lib/lang/Debug.ci:16: referenced as `noTrace`
	cmplStd/lib/lang/Debug.ci:13: referenced as `noTrace`
	cmplStd/lib/lang/Debug.ci:7: referenced as `noTrace`
	cmplStd/lib/lang/Debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 128
.usages:
	cmplStd/lib/lang/Debug.ci:69: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:53: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:29: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:27: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:24: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:22: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:19: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:10: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tryExec'
.param .result: int32 (size: 4, cast: inline)
.param args: pointer (size: 4, cast: variable(ref))
.param action: function (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(12)
.usages:
	cmplStd/test/lang/tryExec.ci:45: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:44: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:43: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:42: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:41: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:40: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:39: referenced as `tryExec`
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'System'
.field exit: function (size: 0, cast: static const inline)
.field srand: function (size: 0, cast: static const inline)
.field time: function (size: 0, cast: static const inline)
.field millis: function (size: 0, cast: static const inline)
.field sleep: function (size: 0, cast: static const inline)
.field rand: function (size: 0, cast: static const inline)
.field clock: function (size: 0, cast: static const inline)
.field Platform: typename (size: 0, cast: static const typename(void))
.doc: '@builtin'
.usages:
	cmplGfx/lib/micro.ui.ci:1275: referenced as `System`
	cmplGfx/lib/micro.ui.ci:1187: referenced as `System`
	cmplGfx/lib/micro.ui.ci:1162: referenced as `System`
	cmplGfx/lib/micro.ui.ci:1128: referenced as `System`
	cmplGfx/lib/micro.ui.ci:569: referenced as `System`
	cmplGfx/lib/micro.ui.ci:499: referenced as `System`
	cmplGfx/lib/window.ci:366: referenced as `System`
	cmplGfx/lib/window.ci:123: referenced as `System`
	cmplGfx/lib/window.ci:109: referenced as `System`
	cmplGfx/lib/window.ci:106: referenced as `System`
	cmplGfx/lib/window.ci:84: referenced as `System`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `System`
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exit'
.owner: System
.param .result: void (size: 0, cast: inline)
.param code: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(17)
.usages:
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'srand'
.owner: System
.param .result: void (size: 0, cast: inline)
.param seed: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(18)
.usages:
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'time'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.doc: '@builtin'
.value: nfc(19)
.usages:
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, cast: inline)
.doc: '@builtin'
.value: nfc(20)
.usages:
	cmplGfx/lib/micro.ui.ci:1275: referenced as `millis`
	cmplGfx/lib/micro.ui.ci:1187: referenced as `millis`
	cmplGfx/lib/micro.ui.ci:1162: referenced as `millis`
	cmplGfx/lib/micro.ui.ci:1128: referenced as `millis`
	cmplGfx/lib/micro.ui.ci:569: referenced as `millis`
	cmplGfx/lib/micro.ui.ci:499: referenced as `millis`
	cmplGfx/lib/window.ci:366: referenced as `millis`
	cmplGfx/lib/window.ci:123: referenced as `millis`
	cmplGfx/lib/window.ci:109: referenced as `millis`
	cmplGfx/lib/window.ci:106: referenced as `millis`
	cmplGfx/lib/window.ci:84: referenced as `millis`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `millis`
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sleep'
.owner: System
.param .result: void (size: 0, cast: inline)
.param millis: int64 (size: 8, cast: variable(i64))
.doc: '@builtin'
.value: nfc(21)
.usages:
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rand'
.owner: System
.field max: int64 (size: 0, cast: static const i64)
.param .result: int32 (size: 4, cast: inline)
.doc: '@builtin'
.value: nfc(22)
.usages:
}
System.rand.max: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'max'
.owner: System.rand(): int32
.doc: '@builtin'
.value: 2147483647
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clock'
.owner: System
.field perSec: int64 (size: 0, cast: static const i64)
.param .result: int32 (size: 4, cast: inline)
.doc: '@builtin'
.value: nfc(23)
.usages:
}
System.clock.perSec: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'perSec'
.owner: System.clock(): int32
.doc: '@builtin'
.value: 1000000
}
System.Platform: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Platform'
.owner: System
.field WebAssembly: int64 (size: 0, cast: static const i64)
.field Windows: int64 (size: 0, cast: static const i64)
.field MacOS: int64 (size: 0, cast: static const i64)
.field Linux: int64 (size: 0, cast: static const i64)
.field Unix: int64 (size: 0, cast: static const i64)
.doc: '@builtin'
}
System.Platform.WebAssembly: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WebAssembly'
.owner: System.Platform
.doc: '@builtin'
.value: 0
}
System.Platform.Windows: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Windows'
.owner: System.Platform
.doc: '@builtin'
.value: 0
}
System.Platform.MacOS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MacOS'
.owner: System.Platform
.doc: '@builtin'
.value: 0
}
System.Platform.Linux: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Linux'
.owner: System.Platform
.doc: '@builtin'
.value: 64
}
System.Platform.Unix: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Unix'
.owner: System.Platform
.doc: '@builtin'
.value: 64
}
true: bool {
.kind: static const val
.base: `bool`
.size: 0
.name: 'true'
.file: 'cmplStd/lib.ci:5'
.doc: 'true'
.value: 1
.usages:
	cmplStd/test/lang/useOperator.ci:7: referenced as `true`
	cmplGfx/lib/micro.ui.ci:1251: referenced as `true`
	cmplGfx/lib/micro.ui.ci:1235: referenced as `true`
	cmplGfx/lib/micro.ui.ci:1197: referenced as `true`
	cmplGfx/lib/micro.ui.ci:1107: referenced as `true`
	cmplGfx/lib/micro.ui.ci:1065: referenced as `true`
	cmplGfx/lib/micro.ui.ci:1059: referenced as `true`
	cmplGfx/lib/micro.ui.ci:1042: referenced as `true`
	cmplGfx/lib/micro.ui.ci:1036: referenced as `true`
	cmplGfx/lib/micro.ui.ci:964: referenced as `true`
	cmplGfx/lib/micro.ui.ci:930: referenced as `true`
	cmplGfx/lib/micro.ui.ci:928: referenced as `true`
	cmplGfx/lib/micro.ui.ci:923: referenced as `true`
	cmplGfx/lib/micro.ui.ci:915: referenced as `true`
	cmplGfx/lib/micro.ui.ci:872: referenced as `true`
	cmplGfx/lib/micro.ui.ci:812: referenced as `true`
	cmplGfx/lib/micro.ui.ci:781: referenced as `true`
	cmplGfx/lib/micro.ui.ci:774: referenced as `true`
	cmplGfx/lib/micro.ui.ci:688: referenced as `true`
	cmplGfx/lib/micro.ui.ci:611: referenced as `true`
	cmplGfx/lib/micro.ui.ci:549: referenced as `true`
	cmplGfx/lib/micro.ui.ci:403: referenced as `true`
	cmplGfx/lib/micro.ui.ci:350: referenced as `true`
	cmplGfx/lib/micro.ui.ci:272: referenced as `true`
	cmplGfx/lib/micro.ui.ci:214: referenced as `true`
	cmplGfx/lib/micro.ui.ci:196: referenced as `true`
	cmplGfx/lib/micro.ui.ci:72: referenced as `true`
	cmplGfx/lib/micro.ui.ci:62: referenced as `true`
	cmplGfx/lib/micro.ui.ci:36: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1292: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1288: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1286: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1279: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1221: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1210: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1197: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1187: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1139: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1124: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1109: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1086: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:1085: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:894: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:809: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:744: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:741: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:711: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:700: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:696: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:689: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:603: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:589: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:506: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:500: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:453: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:445: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:437: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:340: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:324: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:256: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:238: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:235: referenced as `true`
	cmplGfx/lib/micro.ui.core.ci:196: referenced as `true`
	cmplGfx/lib/window.ci:86: referenced as `true`
	cmplGfx/lib/color.lookup.ci:24: referenced as `true`
	cmplGfx/lib/image.draw.line.ci:61: referenced as `drawAntiAliased`
	cmplGfx/lib/image.draw.line.ci:30: referenced as `drawAntiAliased`
	cmplGfx/lib/image.draw.ci:3: referenced as `true`
	cmplStd/lib/math/Polynomial.ci:15: referenced as `true`
	cmplStd/lib/text/Format.ci:16: referenced as `true`
	cmplStd/lib/text/cstr.ci:57: referenced as `true`
	cmplStd/lib/text/cstr.ci:42: referenced as `true`
	cmplStd/lib/time/Datetime.ci:112: referenced as `true`
	cmplStd/lib/time/Datetime.ci:107: referenced as `true`
	cmplStd/lib/math/Fixed.ci:113: referenced as `true`
	cmplStd/lib/math/Math.ci:45: referenced as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 0
.name: 'false'
.file: 'cmplStd/lib.ci:6'
.doc: 'false'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:8: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1290: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1286: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1265: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1221: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1193: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1173: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1170: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1148: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1144: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1117: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1113: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1096: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1095: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1094: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1072: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1055: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1049: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1032: referenced as `false`
	cmplGfx/lib/micro.ui.ci:1003: referenced as `false`
	cmplGfx/lib/micro.ui.ci:995: referenced as `false`
	cmplGfx/lib/micro.ui.ci:888: referenced as `false`
	cmplGfx/lib/micro.ui.ci:882: referenced as `false`
	cmplGfx/lib/micro.ui.ci:877: referenced as `false`
	cmplGfx/lib/micro.ui.ci:861: referenced as `false`
	cmplGfx/lib/micro.ui.ci:819: referenced as `false`
	cmplGfx/lib/micro.ui.ci:809: referenced as `false`
	cmplGfx/lib/micro.ui.ci:805: referenced as `false`
	cmplGfx/lib/micro.ui.ci:779: referenced as `false`
	cmplGfx/lib/micro.ui.ci:730: referenced as `false`
	cmplGfx/lib/micro.ui.ci:729: referenced as `false`
	cmplGfx/lib/micro.ui.ci:702: referenced as `false`
	cmplGfx/lib/micro.ui.ci:681: referenced as `false`
	cmplGfx/lib/micro.ui.ci:646: referenced as `false`
	cmplGfx/lib/micro.ui.ci:618: referenced as `false`
	cmplGfx/lib/micro.ui.ci:606: referenced as `false`
	cmplGfx/lib/micro.ui.ci:601: referenced as `false`
	cmplGfx/lib/micro.ui.ci:354: referenced as `false`
	cmplGfx/lib/micro.ui.ci:344: referenced as `false`
	cmplGfx/lib/micro.ui.ci:336: referenced as `false`
	cmplGfx/lib/micro.ui.ci:333: referenced as `false`
	cmplGfx/lib/micro.ui.ci:248: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:1278: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:1213: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:1201: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:1146: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:1103: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:1099: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:1095: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:734: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:729: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:725: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:720: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:659: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:656: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:636: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:631: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:599: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:595: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:537: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:536: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:510: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:430: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:313: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:309: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:294: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:284: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:281: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:261: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:217: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:194: referenced as `false`
	cmplGfx/lib/micro.ui.core.ci:191: referenced as `false`
	cmplGfx/lib/color.lookup.ci:21: referenced as `false`
	cmplStd/lib/math/Polynomial.ci:49: referenced as `false`
	cmplStd/lib/text/cstr.ci:54: referenced as `false`
	cmplStd/lib/text/cstr.ci:50: referenced as `false`
	cmplStd/lib/text/cstr.ci:39: referenced as `false`
	cmplStd/lib/time/Datetime.ci:110: referenced as `false`
	cmplStd/lib/time/Datetime.ci:104: referenced as `false`
	cmplStd/lib/time/Timezone.ci:28: referenced as `false`
	cmplStd/lib/time/Timezone.ci:13: referenced as `false`
	cmplStd/lib/math/Fixed.ci:111: referenced as `false`
	cmplStd/lib/math/Fixed.ci:108: referenced as `false`
	cmplStd/lib/math/Fixed.ci:105: referenced as `false`
	cmplStd/lib/math/Math.ci:42: referenced as `false`
}
byte: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'byte'
.file: 'cmplStd/lib.ci:9'
.value: uint8
.usages:
}
float: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'float'
.file: 'cmplStd/lib.ci:10'
.value: float32
.usages:
}
double: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'double'
.file: 'cmplStd/lib.ci:11'
.value: float64
.usages:
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sizeof'
.file: 'cmplStd/lib.ci:14'
.param .result: int32 (size: 4, cast: i32)
.param type: typename (size: 4, cast: ref)
.doc: 'Returns the size of the given type'
.value: typename.size(type)
.usages:
	cmplStd/test/lang/reflect.ci:20: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:19: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:18: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:17: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:16: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:15: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:14: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:13: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:12: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:11: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:10: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:9: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:8: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:7: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:6: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:5: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:4: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:3: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:14: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:13: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:12: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:11: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:10: referenced as `sizeof`
	cmplStd/test/lang/memory.ci:30: referenced as `sizeof`
	cmplStd/test/lang/memory.ci:29: referenced as `sizeof`
	cmplGfx/lib/micro.ui.core.ci:523: referenced as `sizeof`
	cmplGfx/lib/micro.ui.core.ci:522: referenced as `sizeof`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `sizeof`
}
verbose(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'cmplStd/lib/lang/Debug.ci:4'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message at `verbose` logging level'
.value: raise(raise.verbose, raise.noTrace, message, ...details)
.usages:
}
debug(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'cmplStd/lib/lang/Debug.ci:7'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message at `debug` logging level'
.value: raise(raise.debug, raise.noTrace, message, ...details)
.usages:
	cmplStd/test/lang/stmt.for.ci:28: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:21: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:14: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:9: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:4: referenced as `debug`
	cmplStd/test/lang/init.method.ci:91: referenced as `debug`
	cmplStd/test/lang/init.method.ci:85: referenced as `debug`
	cmplStd/test/lang/memory.ci:33: referenced as `debug`
	cmplStd/test/lang/memory.ci:32: referenced as `debug`
	cmplStd/test/lang/memory.ci:27: referenced as `debug`
	cmplStd/test/lang/memory.ci:26: referenced as `debug`
	cmplGfx/lib/micro.ui.ci:1264: referenced as `debug`
}
trace(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'cmplStd/lib/lang/Debug.ci:10'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(raise.debug, raise.defTrace, message, ...details)
.usages:
	cmplStd/test/lang/init.method.ci:58: referenced as `trace`
	cmplStd/test/lang/init.method.ci:48: referenced as `trace`
	cmplStd/test/lang/init.method.ci:41: referenced as `trace`
	cmplStd/test/lang/init.method.ci:11: referenced as `trace`
	cmplGfx/lib/window.ci:117: referenced as `trace`
	cmplStd/lib/time/Datetime.ci:168: referenced as `trace`
	cmplStd/lib/time/Datetime.ci:158: referenced as `trace`
	cmplStd/lib/time/Datetime.ci:152: referenced as `trace`
	cmplStd/lib/time/Timestamp.ci:75: referenced as `trace`
	cmplStd/lib/time/Timestamp.ci:57: referenced as `trace`
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `trace`
}
info(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'cmplStd/lib/lang/Debug.ci:13'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message at `info` logging level'
.value: raise(raise.info, raise.noTrace, message, ...details)
.usages:
}
warn(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'cmplStd/lib/lang/Debug.ci:16'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message at `warn` logging level'
.value: raise(raise.warn, raise.noTrace, message, ...details)
.usages:
	cmplStd/lib/time/Timezone.ci:25: referenced as `warn`
}
error(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'cmplStd/lib/lang/Debug.ci:19'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(raise.error, raise.defTrace, message, ...details)
.usages:
	cmplStd/test/lang/stmt.if.ci:78: referenced as `error`
	cmplStd/test/lang/stmt.if.ci:74: referenced as `error`
	cmplGfx/lib/micro.ui.ci:787: referenced as `error`
	cmplGfx/lib/micro.ui.core.ci:594: referenced as `error`
	cmplStd/lib/text/encoding/Utf8.ci:36: referenced as `error`
	cmplStd/lib/text/encoding/Utf8.ci:27: referenced as `error`
	cmplStd/lib/text/encoding/Utf8.ci:19: referenced as `error`
}
abort(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'cmplStd/lib/lang/Debug.ci:22'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, message, ...details)
.usages:
	cmplStd/test/lang/tryExec.ci:27: referenced as `abort`
	cmplGfx/lib/mesh.ci:9: referenced as `abort`
	cmplStd/lib/text/Format.ci:483: referenced as `abort`
	cmplStd/lib/time/Timezone.ci:22: referenced as `abort`
	cmplStd/lib/time/Timestamp.ci:95: referenced as `abort`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'cmplStd/lib/lang/Debug.ci:24'
.param .result: void (size: 0, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, "execution aborted!")
.usages:
}
assert(condition: bool, message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'cmplStd/lib/lang/Debug.ci:27'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : raise(raise.abort, raise.defTrace, message, ...details))
.usages:
	cmplGfx/lib/micro.ui.core.ci:610: referenced as `assert`
	cmplGfx/lib/micro.ui.core.ci:269: referenced as `assert`
	cmplGfx/lib/micro.ui.core.ci:266: referenced as `assert`
	cmplStd/lib/math/Polynomial.ci:100: referenced as `assert`
	cmplStd/lib/math/Polynomial.ci:99: referenced as `assert`
	cmplStd/lib/math/Polynomial.ci:90: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:41: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:40: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:39: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:31: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:30: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:22: referenced as `assert`
	cmplStd/lib/text/encoding/binary/Base64.ci:191: referenced as `assert`
	cmplStd/lib/text/Format.ci:115: referenced as `assert`
	cmplStd/lib/text/Format.ci:114: referenced as `assert`
}
assert(condition: bool, details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'cmplStd/lib/lang/Debug.ci:29'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : raise(raise.abort, raise.defTrace, "assertion failed!", ...details))
.usages:
	cmplStd/test/lang/pointer.ci:14: referenced as `assert`
	cmplStd/test/lang/pointer.ci:13: referenced as `assert`
	cmplStd/test/lang/pointer.ci:12: referenced as `assert`
	cmplStd/test/lang/pointer.ci:11: referenced as `assert`
	cmplStd/test/lang/pointer.ci:10: referenced as `assert`
	cmplStd/test/lang/pointer.ci:9: referenced as `assert`
	cmplGfx/lib/micro.ui.core.ci:1237: referenced as `assert`
	cmplGfx/lib/micro.ui.core.ci:579: referenced as `assert`
	cmplGfx/lib/micro.ui.core.ci:573: referenced as `assert`
	cmplGfx/lib/micro.ui.core.ci:514: referenced as `assert`
	cmplGfx/lib/color.matrix.ci:6: referenced as `assert`
	cmplGfx/lib/color.lookup.ci:7: referenced as `assert`
	cmplGfx/lib/image.blur.ci:26: referenced as `assert`
	cmplGfx/lib/image.transform.ci:8: referenced as `assert`
	cmplGfx/lib/image.transform.ci:7: referenced as `assert`
	cmplGfx/lib/image.blend.ci:33: referenced as `assert`
	cmplFile/lib/FileStream.ci:40: referenced as `assert`
	cmplFile/lib/FileStream.ci:21: referenced as `assert`
	cmplStd/lib/math/Polynomial.ci:61: referenced as `assert`
	cmplStd/lib/text/encoding/binary/Base64.ci:42: referenced as `assert`
	cmplStd/lib/text/Format.ci:157: referenced as `assert`
	cmplStd/lib/text/Format.ci:150: referenced as `assert`
	cmplStd/lib/text/Format.ci:143: referenced as `assert`
	cmplStd/lib/text/Format.ci:138: referenced as `assert`
	cmplStd/lib/time/Datetime.ci:180: referenced as `assert`
	cmplStd/lib/time/Datetime.ci:129: referenced as `assert`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'NotEquals'
.file: 'cmplStd/lib/lang/Debug.ci:32'
.field expected: variant (size: 8, cast: const variable(var))
.field returned: variant (size: 8, cast: const variable(var))
.field extras: variant[] (size: 8, cast: const variable(arr))
.doc: 'Record used for debugging purposes, containing expected, returned and an array of extra values'
.usages:
	cmplStd/lib/lang/Debug.ci:64: referenced as `NotEquals`
	cmplStd/lib/lang/Debug.ci:55: referenced as `NotEquals`
	cmplStd/lib/lang/Debug.ci:53: referenced as `NotEquals`
	cmplStd/lib/lang/Debug.ci:44: referenced as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'expected'
.file: 'cmplStd/lib/lang/Debug.ci:34'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	cmplStd/lib/lang/Debug.ci:65: referenced as `expected`
	cmplStd/lib/lang/Debug.ci:46: referenced as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'returned'
.file: 'cmplStd/lib/lang/Debug.ci:37'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	cmplStd/lib/lang/Debug.ci:66: referenced as `returned`
	cmplStd/lib/lang/Debug.ci:47: referenced as `returned`
}
NotEquals.extras: variant[] {
.kind: const variable(arr)
.base: `variant[]`
.size: 8
.name: 'extras'
.file: 'cmplStd/lib/lang/Debug.ci:40'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.usages:
	cmplStd/lib/lang/Debug.ci:67: referenced as `extras`
	cmplStd/lib/lang/Debug.ci:48: referenced as `extras`
}
NotEquals(expected: variant, returned: variant): NotEquals: function {
.kind: static function
.base: `function`
.size: 15
.name: 'NotEquals'
.file: 'cmplStd/lib/lang/Debug.ci:44'
.param .result: NotEquals (size: 24, cast: variable(val))
.param expected: variant (size: 8, cast: const variable(var))
.param returned: variant (size: 8, cast: const variable(var))
.doc: 'Create a not equals record for inspection from expected and returned'
.value: {
	return .result := {
			.result.expected := expected;
			.result.returned := returned;
			.result.extras := (null);
		};
}
.instructions: (15 bytes)
	cmplStd/lib/lang/Debug.ci:45: (15 bytes): return .result := {...};
	cmplStd/lib/lang/Debug.ci:46: (3 bytes): .result.expected := expected;
	<NotEquals>  : mov.x64 sp(5, 3)
	cmplStd/lib/lang/Debug.ci:47: (3 bytes): .result.returned := returned;
	<NotEquals+?>: mov.x64 sp(7, 1)
	cmplStd/lib/lang/Debug.ci:48: (8 bytes): .result.extras := (null);
	<NotEquals+?>: load.z32
	<NotEquals+?>: load.ref <?> ;null
	<NotEquals+?>: set.x64 sp(11)
	<NotEquals+?>: ret
.usages:
}
abort(message: char[*], detail: NotEquals): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'cmplStd/lib/lang/Debug.ci:53'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param detail: NotEquals (size: 4, cast: const ref)
.doc: 'abort execution displaying the expected and returned values'
.value: raise(raise.abort, raise.defTrace, message, detail)
.usages:
	cmplStd/lib/lang/Debug.ci:55: referenced as `abort`
}
assert(condition: bool, message: char[*], detail: NotEquals): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'cmplStd/lib/lang/Debug.ci:55'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: const ref)
.param detail: NotEquals (size: 4, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message, detail))
.usages:
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static function
.base: `function`
.size: 118
.name: 'assertEq'
.file: 'cmplStd/lib/lang/Debug.ci:59'
.param .result: void (size: 0, cast: variable(void))
.param expected: int32 (size: 4, cast: variable(i32))
.param returned: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (returned == expected) {
		return;
	}
	extras: variant[1] := {
		extras[0] := (message);
	};
	detail: NotEquals := {
		detail.expected := (expected);
		detail.returned := (returned);
		detail.extras := (extras);
	};
	raise(raise.abort, raise.defTrace, "assertion failed", detail);
}
.instructions: (118 bytes)
	cmplStd/lib/lang/Debug.ci:60: (10 bytes): if (returned == expected)
	<assertEq>  : dup.x32 sp(2)
	<assertEq+?>: dup.x32 sp(4)
	<assertEq+?>: ceq.i32
	<assertEq+?>: jz +5
	cmplStd/lib/lang/Debug.ci:61: (1 byte): return;
	<assertEq+?>: ret
	cmplStd/lib/lang/Debug.ci:63: (13 bytes): extras: variant[1] := {...}
	<assertEq+?>: inc.sp(+8)
	cmplStd/lib/lang/Debug.ci:63: (9 bytes): extras[0] := (message);
	<assertEq+?>: load.ref <?>
	<assertEq+?>: dup.x32 sp(4)
	<assertEq+?>: set.x64 sp(2)
	cmplStd/lib/lang/Debug.ci:64: (37 bytes): detail: NotEquals := {...}
	<assertEq+?>: inc.sp(+24)
	cmplStd/lib/lang/Debug.ci:65: (11 bytes): detail.expected := (expected);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+48)
	<assertEq+?>: set.x64 sp(2)
	cmplStd/lib/lang/Debug.ci:66: (11 bytes): detail.returned := (returned);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+44)
	<assertEq+?>: set.x64 sp(4)
	cmplStd/lib/lang/Debug.ci:67: (11 bytes): detail.extras := (extras);
	<assertEq+?>: load.c32 1
	<assertEq+?>: load.sp(+28)
	<assertEq+?>: set.x64 sp(6)
	cmplStd/lib/lang/Debug.ci:69: (53 bytes): raise(raise.abort, raise.defTrace, "assertion failed", detail);
	<assertEq+?>: load.ref <?> ;NotEquals
	<assertEq+?>: load.sp(+4)
	<assertEq+?>: load.c32 1
	<assertEq+?>: load.sp(+4)
	<assertEq+?>: load.ref <?> ;"cmplStd/lib/lang/Debug.ci"
	<assertEq+?>: load.c32 69
	<assertEq+?>: load.c32 -2
	<assertEq+?>: load.c32 128
	<assertEq+?>: load.ref <?> ;"assertion failed"
	<assertEq+?>: dup.x64 sp(5)
	<assertEq+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<assertEq+?>: inc.sp(-16)
	<assertEq+?>: inc.sp(-32)
	<assertEq+?>: ret
.usages:
	cmplStd/lib/lang/Debug.ci:72: referenced as `assertEq`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assertEq'
.file: 'cmplStd/lib/lang/Debug.ci:72'
.param .result: void (size: 0, cast: void)
.param expected: int32 (size: 4, cast: i32)
.param returned: int32 (size: 4, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(expected, returned, null)
.usages:
}
inc(ptr: pointer, val: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'inc'
.file: 'cmplStd/lib/lang/Pointer.ci:3'
.param .result: pointer (size: 4, cast: ref)
.param ptr: pointer (size: 4, cast: ref)
.param val: int32 (size: 4, cast: i32)
.doc: 'Returns the pointer incremented with the given value'
.value: pointer(emit(pointer(ptr), int32(val), add.i32))
.usages:
	cmplStd/test/lang/pointer.ci:14: referenced as `inc`
	cmplStd/test/lang/pointer.ci:13: referenced as `inc`
	cmplStd/test/lang/pointer.ci:12: referenced as `inc`
	cmplStd/test/lang/pointer.ci:11: referenced as `inc`
	cmplStd/test/lang/pointer.ci:10: referenced as `inc`
	cmplStd/lib/text/encoding/binary/Base64.ci:33: referenced as `inc`
}
Bits: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Bits'
.file: 'cmplStd/lib/math/Bits.ci:2'
.field signed: function (size: 0, cast: static inline)
.field signed: function (size: 0, cast: static inline)
.field signed: function (size: 0, cast: static inline)
.field signed: function (size: 0, cast: static inline)
.field unsigned: function (size: 0, cast: static inline)
.field unsigned: function (size: 0, cast: static inline)
.field unsigned: function (size: 0, cast: static inline)
.field unsigned: function (size: 0, cast: static inline)
.field fromFloat32: function (size: 0, cast: static inline)
.field fromFloat64: function (size: 0, cast: static inline)
.field asFloat32: function (size: 0, cast: static inline)
.field asFloat64: function (size: 0, cast: static inline)
.field asFloat64: function (size: 0, cast: static inline)
.field zxt32: function (size: 39, cast: static function)
.field sxt32: function (size: 39, cast: static function)
.field zxt64: function (size: 39, cast: static function)
.field sxt64: function (size: 39, cast: static function)
.field swapBytes: function (size: 121, cast: static function)
.field swapBytes: function (size: 68, cast: static function)
.field swapBytes: function (size: 29, cast: static function)
.field swapBytes: function (size: 0, cast: static inline)
.field swapBytes: function (size: 0, cast: static inline)
.field swapBytes: function (size: 0, cast: static inline)
.field scanReverse: function (size: 196, cast: static function)
.field scanReverse: function (size: 0, cast: static inline)
.field scanReverse: function (size: 139, cast: static function)
.field scanReverse: function (size: 0, cast: static inline)
.field scanReverse: function (size: 135, cast: static function)
.field scanReverse: function (size: 0, cast: static inline)
.field scanReverse: function (size: 104, cast: static function)
.field scanReverse: function (size: 0, cast: static inline)
.field scanForward: function (size: 202, cast: static function)
.field scanForward: function (size: 0, cast: static inline)
.field scanForward: function (size: 123, cast: static function)
.field scanForward: function (size: 0, cast: static inline)
.field scanForward: function (size: 127, cast: static function)
.field scanForward: function (size: 0, cast: static inline)
.field scanForward: function (size: 98, cast: static function)
.field scanForward: function (size: 0, cast: static inline)
.field keepMsb: function (size: 92, cast: static function)
.field keepMsb: function (size: 0, cast: static inline)
.field keepMsb: function (size: 64, cast: static function)
.field keepMsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field countOnes: function (size: 134, cast: static function)
.field countOnes: function (size: 0, cast: static inline)
.field countOnes: function (size: 85, cast: static function)
.field countOnes: function (size: 0, cast: static inline)
.field swapBits: function (size: 215, cast: static function)
.field swapBits: function (size: 0, cast: static inline)
.field swapBits: function (size: 113, cast: static function)
.field swapBits: function (size: 0, cast: static inline)
.field swapBits: function (size: 117, cast: static function)
.field swapBits: function (size: 0, cast: static inline)
.field swapBits: function (size: 85, cast: static function)
.field swapBits: function (size: 0, cast: static inline)
.field clamp: function (size: 37, cast: static function)
.field clamp: function (size: 27, cast: static function)
.doc: 'Utility functions manipulating binary representations'
.usages:
	cmplStd/test/math/test.Bits.ci:66: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:65: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:63: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:62: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:60: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:59: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:58: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:57: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:56: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:55: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:35: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:34: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:33: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:31: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:30: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:29: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:27: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:26: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:25: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:23: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:22: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:21: referenced as `Bits`
	cmplStd/lib/math/Fixed.ci:183: referenced as `Bits`
	cmplStd/lib/math/Math.ci:592: referenced as `Bits`
	cmplStd/lib/math/Math.ci:555: referenced as `Bits`
	cmplStd/lib/math/Math.ci:392: referenced as `Bits`
	cmplStd/lib/math/Math.ci:373: referenced as `Bits`
	cmplStd/lib/math/Math.ci:338: referenced as `Bits`
	cmplStd/lib/math/Math.ci:334: referenced as `Bits`
	cmplStd/lib/math/Math.ci:296: referenced as `Bits`
	cmplStd/lib/math/Math.ci:295: referenced as `Bits`
	cmplStd/lib/math/Math.ci:294: referenced as `Bits`
	cmplStd/lib/math/Math.ci:247: referenced as `Bits`
}
Bits.signed(value: uint8): int8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/lib/math/Bits.ci:4'
.owner: Bits
.param .result: int8 (size: 1, cast: i32)
.param value: uint8 (size: 4, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int8(value)
.usages:
}
Bits.signed(value: uint16): int16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/lib/math/Bits.ci:7'
.owner: Bits
.param .result: int16 (size: 2, cast: i32)
.param value: uint16 (size: 4, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int16(value)
.usages:
}
Bits.signed(value: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/lib/math/Bits.ci:10'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param value: uint32 (size: 4, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int32(value)
.usages:
	cmplStd/lib/math/Math.ci:247: referenced as `signed`
}
Bits.signed(value: uint64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/lib/math/Bits.ci:13'
.owner: Bits
.param .result: int64 (size: 8, cast: i64)
.param value: uint64 (size: 8, cast: u64)
.doc: 'convert unsigned to signed integer'
.value: int64(value)
.usages:
}
Bits.unsigned(value: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/lib/math/Bits.ci:16'
.owner: Bits
.param .result: uint8 (size: 1, cast: u32)
.param value: int8 (size: 4, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint8(value)
.usages:
}
Bits.unsigned(value: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/lib/math/Bits.ci:19'
.owner: Bits
.param .result: uint16 (size: 2, cast: u32)
.param value: int16 (size: 4, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint16(value)
.usages:
}
Bits.unsigned(value: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/lib/math/Bits.ci:22'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param value: int32 (size: 4, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint32(value)
.usages:
}
Bits.unsigned(value: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/lib/math/Bits.ci:25'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param value: int64 (size: 8, cast: i64)
.doc: 'convert signed to unsigned integer'
.value: uint64(value)
.usages:
}
Bits.fromFloat32(value: float32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'fromFloat32'
.file: 'cmplStd/lib/math/Bits.ci:28'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param value: float32 (size: 4, cast: f32)
.doc: 'return the 32 bit floating point value as an integer'
.value: uint32(emit(float32(value)))
.usages:
}
Bits.fromFloat64(value: float64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'fromFloat64'
.file: 'cmplStd/lib/math/Bits.ci:30'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param value: float64 (size: 8, cast: f64)
.doc: 'return the 64 bit floating point value as an integer'
.value: uint64(emit(float64(value)))
.usages:
	cmplStd/lib/math/Math.ci:555: referenced as `fromFloat64`
	cmplStd/lib/math/Math.ci:373: referenced as `fromFloat64`
	cmplStd/lib/math/Math.ci:334: referenced as `fromFloat64`
	cmplStd/lib/math/Math.ci:295: referenced as `fromFloat64`
	cmplStd/lib/math/Math.ci:294: referenced as `fromFloat64`
}
Bits.asFloat32(value: uint32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asFloat32'
.file: 'cmplStd/lib/math/Bits.ci:33'
.owner: Bits
.param .result: float32 (size: 4, cast: f32)
.param value: uint32 (size: 4, cast: u32)
.doc: 'return the 32 bit integer as a floating point value'
.value: float32(emit(uint32(value)))
.usages:
}
Bits.asFloat64(value: uint64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asFloat64'
.file: 'cmplStd/lib/math/Bits.ci:35'
.owner: Bits
.param .result: float64 (size: 8, cast: f64)
.param value: uint64 (size: 8, cast: u64)
.doc: 'return the 64 bit integer as a floating point value'
.value: float64(emit(uint64(value)))
.usages:
	cmplStd/lib/math/Math.ci:592: referenced as `asFloat64`
	cmplStd/lib/math/Math.ci:392: referenced as `asFloat64`
	cmplStd/lib/math/Math.ci:338: referenced as `asFloat64`
	cmplStd/lib/math/Math.ci:296: referenced as `asFloat64`
}
Bits.asFloat64(hi: uint32, lo: uint32): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asFloat64'
.file: 'cmplStd/lib/math/Bits.ci:37'
.owner: Bits
.param .result: float64 (size: 8, cast: f64)
.param hi: uint32 (size: 4, cast: u32)
.param lo: uint32 (size: 4, cast: u32)
.doc: 'return the two 32 bit integers merged as a floating point value'
.value: float64(emit(uint64(uint64(hi) << 32 | (lo))))
.usages:
}
Bits.zxt32(value: int32, offs: int32, count: int32): int32: function {
.kind: static function
.base: `function`
.size: 39
.name: 'zxt32'
.file: 'cmplStd/lib/math/Bits.ci:40'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.zxt)) != null) {
		return .result := uint32.zxt(value, offs, count);
	}
	return .result := uint32(value << (32 - (offs + count))) >> (32 - count);
}
.instructions: (39 bytes)
	cmplStd/lib/math/Bits.ci:43: (13 bytes): return .result := uint32.zxt(value, offs, count);
	<zxt32>  : dup.x32 sp(3)
	<zxt32+?>: dup.x32 sp(3)
	<zxt32+?>: dup.x32 sp(3)
	<zxt32+?>: nfc(24) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<zxt32+?>: set.x32 sp(5)
	<zxt32+?>: ret
	cmplStd/lib/math/Bits.ci:46: (26 bytes): return .result := uint32(value << (32 - (offs + count))) >> (32 - count);
	<zxt32+?>: dup.x32 sp(3)
	<zxt32+?>: load.c32 32
	<zxt32+?>: dup.x32 sp(4)
	<zxt32+?>: dup.x32 sp(4)
	<zxt32+?>: add.i32
	<zxt32+?>: sub.i32
	<zxt32+?>: shl.b32
	<zxt32+?>: load.c32 32
	<zxt32+?>: dup.x32 sp(3)
	<zxt32+?>: sub.i32
	<zxt32+?>: shr.b32
	<zxt32+?>: set.x32 sp(5)
	<zxt32+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:62: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:31: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:30: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:29: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:23: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:22: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:21: referenced as `zxt32`
}
Bits.sxt32(value: int32, offs: int32, count: int32): int32: function {
.kind: static function
.base: `function`
.size: 39
.name: 'sxt32'
.file: 'cmplStd/lib/math/Bits.ci:50'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.sxt)) != null) {
		return .result := uint32.sxt(value, offs, count);
	}
	return .result := int32(value << (32 - (offs + count))) >> (32 - count);
}
.instructions: (39 bytes)
	cmplStd/lib/math/Bits.ci:53: (13 bytes): return .result := uint32.sxt(value, offs, count);
	<sxt32>  : dup.x32 sp(3)
	<sxt32+?>: dup.x32 sp(3)
	<sxt32+?>: dup.x32 sp(3)
	<sxt32+?>: nfc(25) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<sxt32+?>: set.x32 sp(5)
	<sxt32+?>: ret
	cmplStd/lib/math/Bits.ci:56: (26 bytes): return .result := int32(value << (32 - (offs + count))) >> (32 - count);
	<sxt32+?>: dup.x32 sp(3)
	<sxt32+?>: load.c32 32
	<sxt32+?>: dup.x32 sp(4)
	<sxt32+?>: dup.x32 sp(4)
	<sxt32+?>: add.i32
	<sxt32+?>: sub.i32
	<sxt32+?>: shl.b32
	<sxt32+?>: load.c32 32
	<sxt32+?>: dup.x32 sp(3)
	<sxt32+?>: sub.i32
	<sxt32+?>: sar.b32
	<sxt32+?>: set.x32 sp(5)
	<sxt32+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:63: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:35: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:34: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:33: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:27: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:26: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:25: referenced as `sxt32`
}
Bits.zxt64(value: int64, offs: int32, count: int32): int64: function {
.kind: static function
.base: `function`
.size: 39
.name: 'zxt64'
.file: 'cmplStd/lib/math/Bits.ci:60'
.owner: Bits
.param .result: int64 (size: 8, cast: variable(i64))
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.zxt)) != null) {
		return .result := uint64.zxt(value, offs, count);
	}
	return .result := uint64(value << (64 - (offs + count))) >> (64 - count);
}
.instructions: (39 bytes)
	cmplStd/lib/math/Bits.ci:63: (13 bytes): return .result := uint64.zxt(value, offs, count);
	<zxt64>  : dup.x64 sp(3)
	<zxt64+?>: dup.x32 sp(4)
	<zxt64+?>: dup.x32 sp(4)
	<zxt64+?>: nfc(32) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<zxt64+?>: set.x64 sp(7)
	<zxt64+?>: ret
	cmplStd/lib/math/Bits.ci:66: (26 bytes): return .result := uint64(value << (64 - (offs + count))) >> (64 - count);
	<zxt64+?>: dup.x64 sp(3)
	<zxt64+?>: load.c32 64
	<zxt64+?>: dup.x32 sp(5)
	<zxt64+?>: dup.x32 sp(5)
	<zxt64+?>: add.i32
	<zxt64+?>: sub.i32
	<zxt64+?>: shl.b64
	<zxt64+?>: load.c32 64
	<zxt64+?>: dup.x32 sp(4)
	<zxt64+?>: sub.i32
	<zxt64+?>: shr.b64
	<zxt64+?>: set.x64 sp(7)
	<zxt64+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:65: referenced as `zxt64`
}
Bits.sxt64(value: int64, offs: int32, count: int32): int64: function {
.kind: static function
.base: `function`
.size: 39
.name: 'sxt64'
.file: 'cmplStd/lib/math/Bits.ci:70'
.owner: Bits
.param .result: int64 (size: 8, cast: variable(i64))
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.sxt)) != null) {
		return .result := uint64.sxt(value, offs, count);
	}
	return .result := int64(value << (64 - (offs + count))) >> (64 - count);
}
.instructions: (39 bytes)
	cmplStd/lib/math/Bits.ci:73: (13 bytes): return .result := uint64.sxt(value, offs, count);
	<sxt64>  : dup.x64 sp(3)
	<sxt64+?>: dup.x32 sp(4)
	<sxt64+?>: dup.x32 sp(4)
	<sxt64+?>: nfc(33) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<sxt64+?>: set.x64 sp(7)
	<sxt64+?>: ret
	cmplStd/lib/math/Bits.ci:76: (26 bytes): return .result := int64(value << (64 - (offs + count))) >> (64 - count);
	<sxt64+?>: dup.x64 sp(3)
	<sxt64+?>: load.c32 64
	<sxt64+?>: dup.x32 sp(5)
	<sxt64+?>: dup.x32 sp(5)
	<sxt64+?>: add.i32
	<sxt64+?>: sub.i32
	<sxt64+?>: shl.b64
	<sxt64+?>: load.c32 64
	<sxt64+?>: dup.x32 sp(4)
	<sxt64+?>: sub.i32
	<sxt64+?>: sar.b64
	<sxt64+?>: set.x64 sp(7)
	<sxt64+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:66: referenced as `sxt64`
}
Bits.swapBytes(x: uint64): uint64: function {
.kind: static function
.base: `function`
.size: 121
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:80'
.owner: Bits
.param .result: uint64 (size: 8, cast: variable(u64))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'convert a 64 bit value between Little endian and Big endian'
.value: {
	x := (x & (4294967295)) << 32 | (x & (-4294967296)) >> 32;
	x := (x & (281470681808895)) << 16 | (x & (-281470681808896)) >> 16;
	x := (x & (71777214294589695)) << 8 | (x & (-71777214294589696)) >> 8;
	return .result := x;
}
.instructions: (121 bytes)
	cmplStd/lib/math/Bits.ci:81: (39 bytes): x := (x & (4294967295)) << 32 | (x & (-4294967296)) >> 32;
	<swapBytes>  : dup.x64 sp(1)
	<swapBytes+?>: load.c64 4294967295
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 32
	<swapBytes+?>: shl.b64
	<swapBytes+?>: dup.x64 sp(3)
	<swapBytes+?>: load.c64 -4294967296
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 32
	<swapBytes+?>: shr.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:82: (39 bytes): x := (x & (281470681808895)) << 16 | (x & (-281470681808896)) >> 16;
	<swapBytes+?>: dup.x64 sp(1)
	<swapBytes+?>: load.c64 281470681808895
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 16
	<swapBytes+?>: shl.b64
	<swapBytes+?>: dup.x64 sp(3)
	<swapBytes+?>: load.c64 -281470681808896
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 16
	<swapBytes+?>: shr.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:83: (39 bytes): x := (x & (71777214294589695)) << 8 | (x & (-71777214294589696)) >> 8;
	<swapBytes+?>: dup.x64 sp(1)
	<swapBytes+?>: load.c64 71777214294589695
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 8
	<swapBytes+?>: shl.b64
	<swapBytes+?>: dup.x64 sp(3)
	<swapBytes+?>: load.c64 -71777214294589696
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 8
	<swapBytes+?>: shr.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:84: (4 bytes): return .result := x;
	<swapBytes+?>: mov.x64 sp(3, 1)
	<swapBytes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:100: referenced as `swapBytes`
}
Bits.swapBytes(x: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 68
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:88'
.owner: Bits
.param .result: uint32 (size: 4, cast: variable(u32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'convert a 32 bit value between Little endian and Big endian'
.value: {
	x := (((x & (65535)) << 16) | ((x) & 4294901760) >> 16);
	x := (((x & (16711935)) << 8) | ((x) & 4278255360) >> 8);
	return .result := x;
}
.instructions: (68 bytes)
	cmplStd/lib/math/Bits.ci:89: (30 bytes): x := (((x & (65535)) << 16) | ((x) & 4294901760) >> 16);
	<swapBytes>  : dup.x32 sp(1)
	<swapBytes+?>: b32.and 0xffff
	<swapBytes+?>: b32.shl 0x10
	<swapBytes+?>: u32.2i64
	<swapBytes+?>: dup.x32 sp(3)
	<swapBytes+?>: u32.2i64
	<swapBytes+?>: load.c64 4294901760
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 16
	<swapBytes+?>: sar.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: i64.2i32
	<swapBytes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:90: (34 bytes): x := (((x & (16711935)) << 8) | ((x) & 4278255360) >> 8);
	<swapBytes+?>: dup.x32 sp(1)
	<swapBytes+?>: load.c32 16711935
	<swapBytes+?>: and.b32
	<swapBytes+?>: b32.shl 0x08
	<swapBytes+?>: u32.2i64
	<swapBytes+?>: dup.x32 sp(3)
	<swapBytes+?>: u32.2i64
	<swapBytes+?>: load.c64 4278255360
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 8
	<swapBytes+?>: sar.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: i64.2i32
	<swapBytes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:91: (4 bytes): return .result := x;
	<swapBytes+?>: mov.x32 sp(2, 1)
	<swapBytes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:103: referenced as `swapBytes`
}
Bits.swapBytes(x: uint16): uint16: function {
.kind: static function
.base: `function`
.size: 29
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:95'
.owner: Bits
.param .result: uint16 (size: 4, cast: variable(u32))
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'convert a 16 bit value between Little endian and Big endian'
.value: {
	return .result := ((x) & 255) << 8 | ((x) & 65280) >> 8;
}
.instructions: (29 bytes)
	cmplStd/lib/math/Bits.ci:96: (29 bytes): return .result := ((x) & 255) << 8 | ((x) & 65280) >> 8;
	<swapBytes>  : load.sp(+4)
	<swapBytes+?>: load.iu16
	<swapBytes+?>: b32.and 0xff
	<swapBytes+?>: b32.shl 0x08
	<swapBytes+?>: load.sp(+8)
	<swapBytes+?>: load.iu16
	<swapBytes+?>: load.c32 65280
	<swapBytes+?>: and.b32
	<swapBytes+?>: b32.sar 0x08
	<swapBytes+?>: or.b32
	<swapBytes+?>: load.sp(+12)
	<swapBytes+?>: store.i16
	<swapBytes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:106: referenced as `swapBytes`
}
Bits.swapBytes(x: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:100'
.owner: Bits
.param .result: int64 (size: 8, cast: i64)
.param x: int64 (size: 8, cast: i64)
.doc: 'convert a 64 bit value between Little endian and Big endian'
.value: int64(swapBytes(uint64(x)))
.usages:
}
Bits.swapBytes(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:103'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.doc: 'convert a 32 bit value between Little endian and Big endian'
.value: int32(swapBytes(uint32(x)))
.usages:
}
Bits.swapBytes(x: int16): int16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:106'
.owner: Bits
.param .result: int16 (size: 2, cast: i32)
.param x: int16 (size: 4, cast: i32)
.doc: 'convert a 16 bit value between Little endian and Big endian'
.value: int16(swapBytes(uint16(x)))
.usages:
}
Bits.scanReverse(x: uint64): int32: function {
.kind: static function
.base: `function`
.size: 196
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:110'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'find the index of the most significant(highest) bit'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.bsr)) != null) {
		return .result := uint64.bsr(x);
	}
	if (x == (0)) {
		return .result := -1;
	}
	result: int32 := 0;
	if (x & (-4294967296)) {
		result := result + 32;
		x := x >> 32;
	}
	if (x & (4294901760)) {
		result := result + 16;
		x := x >> 16;
	}
	if (x & (65280)) {
		result := result + 8;
		x := x >> 8;
	}
	if (x & (240)) {
		result := result + 4;
		x := x >> 4;
	}
	if (x & (12)) {
		result := result + 2;
		x := x >> 2;
	}
	if (x & (2)) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (196 bytes)
	cmplStd/lib/math/Bits.ci:115: (16 bytes): if (x == (0))
	<scanReverse>  : dup.x64 sp(1)
	<scanReverse+?>: load.z64
	<scanReverse+?>: ceq.i64
	<scanReverse+?>: jz +12
	cmplStd/lib/math/Bits.ci:116: (8 bytes): return .result := -1;
	<scanReverse+?>: load.c32 -1
	<scanReverse+?>: set.x32 sp(4)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:119: (1 byte): result: int32 := 0
	<scanReverse+?>: load.z32
	cmplStd/lib/math/Bits.ci:120: (31 bytes): if (x & (-4294967296))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 -4294967296
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:121: (4 bytes): result := result + 32;
	<scanReverse+?>: inc.i32(+32)
	cmplStd/lib/math/Bits.ci:122: (10 bytes): x := x >> 32;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 32
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:124: (31 bytes): if (x & (4294901760))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 4294901760
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:125: (4 bytes): result := result + 16;
	<scanReverse+?>: inc.i32(+16)
	cmplStd/lib/math/Bits.ci:126: (10 bytes): x := x >> 16;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 16
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:128: (31 bytes): if (x & (65280))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 65280
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:129: (4 bytes): result := result + 8;
	<scanReverse+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:130: (10 bytes): x := x >> 8;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 8
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:132: (31 bytes): if (x & (240))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 240
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:133: (4 bytes): result := result + 4;
	<scanReverse+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:134: (10 bytes): x := x >> 4;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 4
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:136: (31 bytes): if (x & (12))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 12
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:137: (4 bytes): result := result + 2;
	<scanReverse+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:138: (10 bytes): x := x >> 2;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 2
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:140: (21 bytes): if (x & (2))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 2
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +8
	cmplStd/lib/math/Bits.ci:141: (4 bytes): result := result + 1;
	<scanReverse+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:143: (3 bytes): return .result := result;
	<scanReverse+?>: set.x32 sp(4)
	<scanReverse+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:147: referenced as `scanReverse`
}
Bits.scanReverse(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:147'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int64 (size: 8, cast: i64)
.doc: 'find the index of the most significant(highest) bit'
.value: scanReverse(uint64(x))
.usages:
}
Bits.scanReverse(x: uint32): int32: function {
.kind: static function
.base: `function`
.size: 139
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:150'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'find the index of the most significant(highest) bit'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.bsr)) != null) {
		return .result := uint32.bsr(x);
	}
	if (x == (0)) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x) & 4294901760) {
		result := result + 16;
		x := x >> 16;
	}
	if (x & (65280)) {
		result := result + 8;
		x := x >> 8;
	}
	if (x & (240)) {
		result := result + 4;
		x := x >> 4;
	}
	if (x & (12)) {
		result := result + 2;
		x := x >> 2;
	}
	if (x & (2)) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (139 bytes)
	cmplStd/lib/math/Bits.ci:153: (9 bytes): return .result := uint32.bsr(x);
	<scanReverse>  : dup.x32 sp(1)
	<scanReverse+?>: nfc(28) ;uint32.bsr(value: int32): int32
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:155: (16 bytes): if (x == (0))
	<scanReverse+?>: dup.x32 sp(1)
	<scanReverse+?>: load.z32
	<scanReverse+?>: ceq.i32
	<scanReverse+?>: jz +12
	cmplStd/lib/math/Bits.ci:156: (8 bytes): return .result := -1;
	<scanReverse+?>: load.c32 -1
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:159: (1 byte): result: int32 := 0
	<scanReverse+?>: load.z32
	cmplStd/lib/math/Bits.ci:160: (28 bytes): if ((x) & 4294901760)
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: u32.2i64
	<scanReverse+?>: load.c64 4294901760
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +14
	cmplStd/lib/math/Bits.ci:161: (4 bytes): result := result + 16;
	<scanReverse+?>: inc.i32(+16)
	cmplStd/lib/math/Bits.ci:162: (6 bytes): x := x >> 16;
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: b32.shr 0x10
	<scanReverse+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:164: (22 bytes): if (x & (65280))
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: load.c32 65280
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +14
	cmplStd/lib/math/Bits.ci:165: (4 bytes): result := result + 8;
	<scanReverse+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:166: (6 bytes): x := x >> 8;
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: b32.shr 0x08
	<scanReverse+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:168: (22 bytes): if (x & (240))
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: load.c32 240
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +14
	cmplStd/lib/math/Bits.ci:169: (4 bytes): result := result + 4;
	<scanReverse+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:170: (6 bytes): x := x >> 4;
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: b32.shr 0x04
	<scanReverse+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:172: (22 bytes): if (x & (12))
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: load.c32 12
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +14
	cmplStd/lib/math/Bits.ci:173: (4 bytes): result := result + 2;
	<scanReverse+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:174: (6 bytes): x := x >> 2;
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: b32.shr 0x02
	<scanReverse+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:176: (16 bytes): if (x & (2))
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: load.c32 2
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +8
	cmplStd/lib/math/Bits.ci:177: (4 bytes): result := result + 1;
	<scanReverse+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:179: (3 bytes): return .result := result;
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:183: referenced as `scanReverse`
}
Bits.scanReverse(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:183'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.doc: 'find the index of the most significant(highest) bit'
.value: scanReverse(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:57: referenced as `scanReverse`
	cmplStd/lib/math/Fixed.ci:183: referenced as `scanReverse`
}
Bits.scanReverse(x: uint16): int32: function {
.kind: static function
.base: `function`
.size: 135
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:186'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'find the index of the most significant(highest) bit'
.value: {
	if ((x) == 0) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x) & 65280) {
		result := result + 8;
		x := ((x) >> 8);
	}
	if ((x) & 240) {
		result := result + 4;
		x := ((x) >> 4);
	}
	if ((x) & 12) {
		result := result + 2;
		x := ((x) >> 2);
	}
	if ((x) & 2) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (135 bytes)
	cmplStd/lib/math/Bits.ci:187: (19 bytes): if ((x) == 0)
	<scanReverse>  : load.sp(+4)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.z32
	<scanReverse+?>: ceq.i32
	<scanReverse+?>: jz +12
	cmplStd/lib/math/Bits.ci:188: (8 bytes): return .result := -1;
	<scanReverse+?>: load.c32 -1
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:191: (1 byte): result: int32 := 0
	<scanReverse+?>: load.z32
	cmplStd/lib/math/Bits.ci:192: (31 bytes): if ((x) & 65280)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.c32 65280
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:193: (4 bytes): result := result + 8;
	<scanReverse+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:194: (12 bytes): x := ((x) >> 8);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: b32.sar 0x08
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i16
	cmplStd/lib/math/Bits.ci:196: (31 bytes): if ((x) & 240)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.c32 240
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:197: (4 bytes): result := result + 4;
	<scanReverse+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:198: (12 bytes): x := ((x) >> 4);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: b32.sar 0x04
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i16
	cmplStd/lib/math/Bits.ci:200: (31 bytes): if ((x) & 12)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.c32 12
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:201: (4 bytes): result := result + 2;
	<scanReverse+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:202: (12 bytes): x := ((x) >> 2);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: b32.sar 0x02
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i16
	cmplStd/lib/math/Bits.ci:204: (19 bytes): if ((x) & 2)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.c32 2
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +8
	cmplStd/lib/math/Bits.ci:205: (4 bytes): result := result + 1;
	<scanReverse+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:207: (3 bytes): return .result := result;
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:211: referenced as `scanReverse`
}
Bits.scanReverse(x: int16): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:211'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int16 (size: 4, cast: i32)
.doc: 'find the index of the most significant(highest) bit'
.value: scanReverse(uint16(x))
.usages:
}
Bits.scanReverse(x: uint8): int32: function {
.kind: static function
.base: `function`
.size: 104
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:214'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint8 (size: 4, cast: variable(u32))
.doc: 'find the index of the most significant(highest) bit'
.value: {
	if ((x) == 0) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x) & 240) {
		result := result + 4;
		x := ((x) >> 4);
	}
	if ((x) & 12) {
		result := result + 2;
		x := ((x) >> 2);
	}
	if ((x) & 2) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (104 bytes)
	cmplStd/lib/math/Bits.ci:215: (19 bytes): if ((x) == 0)
	<scanReverse>  : load.sp(+4)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: load.z32
	<scanReverse+?>: ceq.i32
	<scanReverse+?>: jz +12
	cmplStd/lib/math/Bits.ci:216: (8 bytes): return .result := -1;
	<scanReverse+?>: load.c32 -1
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:219: (1 byte): result: int32 := 0
	<scanReverse+?>: load.z32
	cmplStd/lib/math/Bits.ci:220: (31 bytes): if ((x) & 240)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: load.c32 240
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:221: (4 bytes): result := result + 4;
	<scanReverse+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:222: (12 bytes): x := ((x) >> 4);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: b32.sar 0x04
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i8
	cmplStd/lib/math/Bits.ci:224: (31 bytes): if ((x) & 12)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: load.c32 12
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:225: (4 bytes): result := result + 2;
	<scanReverse+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:226: (12 bytes): x := ((x) >> 2);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: b32.sar 0x02
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i8
	cmplStd/lib/math/Bits.ci:228: (19 bytes): if ((x) & 2)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: load.c32 2
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +8
	cmplStd/lib/math/Bits.ci:229: (4 bytes): result := result + 1;
	<scanReverse+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:231: (3 bytes): return .result := result;
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:235: referenced as `scanReverse`
}
Bits.scanReverse(x: int8): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:235'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int8 (size: 4, cast: i32)
.doc: 'find the index of the most significant(highest) bit'
.value: scanReverse(uint8(x))
.usages:
}
Bits.scanForward(x: uint64): int32: function {
.kind: static function
.base: `function`
.size: 202
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:239'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'find the index of the least significant(lowest) bit'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.bsf)) != null) {
		return .result := uint64.bsf(x);
	}
	if (x == (0)) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x & (4294967295)) == (0)) {
		result := result + 32;
		x := x >> 32;
	}
	if ((x & (65535)) == (0)) {
		result := result + 16;
		x := x >> 16;
	}
	if ((x & (255)) == (0)) {
		result := result + 8;
		x := x >> 8;
	}
	if ((x & (15)) == (0)) {
		result := result + 4;
		x := x >> 4;
	}
	if ((x & (3)) == (0)) {
		result := result + 2;
		x := x >> 2;
	}
	if ((x & (1)) == (0)) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (202 bytes)
	cmplStd/lib/math/Bits.ci:245: (16 bytes): if (x == (0))
	<scanForward>  : dup.x64 sp(1)
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +12
	cmplStd/lib/math/Bits.ci:246: (8 bytes): return .result := -1;
	<scanForward+?>: load.c32 -1
	<scanForward+?>: set.x32 sp(4)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:249: (1 byte): result: int32 := 0
	<scanForward+?>: load.z32
	cmplStd/lib/math/Bits.ci:250: (32 bytes): if ((x & (4294967295)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 4294967295
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:251: (4 bytes): result := result + 32;
	<scanForward+?>: inc.i32(+32)
	cmplStd/lib/math/Bits.ci:252: (10 bytes): x := x >> 32;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 32
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:254: (32 bytes): if ((x & (65535)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 65535
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:255: (4 bytes): result := result + 16;
	<scanForward+?>: inc.i32(+16)
	cmplStd/lib/math/Bits.ci:256: (10 bytes): x := x >> 16;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 16
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:258: (32 bytes): if ((x & (255)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 255
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:259: (4 bytes): result := result + 8;
	<scanForward+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:260: (10 bytes): x := x >> 8;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 8
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:262: (32 bytes): if ((x & (15)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 15
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:263: (4 bytes): result := result + 4;
	<scanForward+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:264: (10 bytes): x := x >> 4;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 4
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:266: (32 bytes): if ((x & (3)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 3
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:267: (4 bytes): result := result + 2;
	<scanForward+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:268: (10 bytes): x := x >> 2;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 2
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:270: (22 bytes): if ((x & (1)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 1
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +8
	cmplStd/lib/math/Bits.ci:271: (4 bytes): result := result + 1;
	<scanForward+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:273: (3 bytes): return .result := result;
	<scanForward+?>: set.x32 sp(4)
	<scanForward+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:277: referenced as `scanForward`
}
Bits.scanForward(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:277'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int64 (size: 8, cast: i64)
.doc: 'find the index of the least significant(lowest) bit'
.value: scanForward(uint64(x))
.usages:
}
Bits.scanForward(x: uint32): int32: function {
.kind: static function
.base: `function`
.size: 123
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:280'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'find the index of the least significant(lowest) bit'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.bsf)) != null) {
		return .result := uint32.bsf(x);
	}
	if (x == (0)) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x & (65535)) == (0)) {
		result := result + 16;
		x := x >> 16;
	}
	if ((x & (255)) == (0)) {
		result := result + 8;
		x := x >> 8;
	}
	if ((x & (15)) == (0)) {
		result := result + 4;
		x := x >> 4;
	}
	if ((x & (3)) == (0)) {
		result := result + 2;
		x := x >> 2;
	}
	if ((x & (1)) == (0)) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (123 bytes)
	cmplStd/lib/math/Bits.ci:283: (9 bytes): return .result := uint32.bsf(x);
	<scanForward>  : dup.x32 sp(1)
	<scanForward+?>: nfc(29) ;uint32.bsf(value: int32): int32
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:286: (16 bytes): if (x == (0))
	<scanForward+?>: dup.x32 sp(1)
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +12
	cmplStd/lib/math/Bits.ci:287: (8 bytes): return .result := -1;
	<scanForward+?>: load.c32 -1
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:290: (1 byte): result: int32 := 0
	<scanForward+?>: load.z32
	cmplStd/lib/math/Bits.ci:291: (20 bytes): if ((x & (65535)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0xffff
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +14
	cmplStd/lib/math/Bits.ci:292: (4 bytes): result := result + 16;
	<scanForward+?>: inc.i32(+16)
	cmplStd/lib/math/Bits.ci:293: (6 bytes): x := x >> 16;
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.shr 0x10
	<scanForward+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:295: (20 bytes): if ((x & (255)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0xff
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +14
	cmplStd/lib/math/Bits.ci:296: (4 bytes): result := result + 8;
	<scanForward+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:297: (6 bytes): x := x >> 8;
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.shr 0x08
	<scanForward+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:299: (20 bytes): if ((x & (15)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0x0f
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +14
	cmplStd/lib/math/Bits.ci:300: (4 bytes): result := result + 4;
	<scanForward+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:301: (6 bytes): x := x >> 4;
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.shr 0x04
	<scanForward+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:303: (20 bytes): if ((x & (3)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0x03
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +14
	cmplStd/lib/math/Bits.ci:304: (4 bytes): result := result + 2;
	<scanForward+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:305: (6 bytes): x := x >> 2;
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.shr 0x02
	<scanForward+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:307: (14 bytes): if ((x & (1)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0x01
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +8
	cmplStd/lib/math/Bits.ci:308: (4 bytes): result := result + 1;
	<scanForward+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:310: (3 bytes): return .result := result;
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:314: referenced as `scanForward`
}
Bits.scanForward(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:314'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.doc: 'find the index of the least significant(lowest) bit'
.value: scanForward(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:58: referenced as `scanForward`
}
Bits.scanForward(x: uint16): int32: function {
.kind: static function
.base: `function`
.size: 127
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:317'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'find the index of the least significant(lowest) bit'
.value: {
	if ((x) == 0) {
		return .result := -1;
	}
	result: int32 := 0;
	if (((x) & 255) == 0) {
		result := result + 8;
		x := ((x) >> 8);
	}
	if (((x) & 15) == 0) {
		result := result + 4;
		x := ((x) >> 4);
	}
	if (((x) & 3) == 0) {
		result := result + 2;
		x := ((x) >> 2);
	}
	if (((x) & 1) == 0) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (127 bytes)
	cmplStd/lib/math/Bits.ci:318: (19 bytes): if ((x) == 0)
	<scanForward>  : load.sp(+4)
	<scanForward+?>: load.iu16
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +12
	cmplStd/lib/math/Bits.ci:319: (8 bytes): return .result := -1;
	<scanForward+?>: load.c32 -1
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:322: (1 byte): result: int32 := 0
	<scanForward+?>: load.z32
	cmplStd/lib/math/Bits.ci:323: (29 bytes): if (((x) & 255) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.and 0xff
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:324: (4 bytes): result := result + 8;
	<scanForward+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:325: (12 bytes): x := ((x) >> 8);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.sar 0x08
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i16
	cmplStd/lib/math/Bits.ci:327: (29 bytes): if (((x) & 15) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.and 0x0f
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:328: (4 bytes): result := result + 4;
	<scanForward+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:329: (12 bytes): x := ((x) >> 4);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.sar 0x04
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i16
	cmplStd/lib/math/Bits.ci:331: (29 bytes): if (((x) & 3) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.and 0x03
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:332: (4 bytes): result := result + 2;
	<scanForward+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:333: (12 bytes): x := ((x) >> 2);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.sar 0x02
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i16
	cmplStd/lib/math/Bits.ci:335: (17 bytes): if (((x) & 1) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.and 0x01
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +8
	cmplStd/lib/math/Bits.ci:336: (4 bytes): result := result + 1;
	<scanForward+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:338: (3 bytes): return .result := result;
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:342: referenced as `scanForward`
}
Bits.scanForward(x: int16): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:342'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int16 (size: 4, cast: i32)
.doc: 'find the index of the least significant(lowest) bit'
.value: scanForward(uint16(x))
.usages:
}
Bits.scanForward(x: uint8): int32: function {
.kind: static function
.base: `function`
.size: 98
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:345'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint8 (size: 4, cast: variable(u32))
.doc: 'find the index of the least significant(lowest) bit'
.value: {
	if ((x) == 0) {
		return .result := -1;
	}
	result: int32 := 0;
	if (((x) & 15) == 0) {
		result := result + 4;
		x := ((x) >> 4);
	}
	if (((x) & 3) == 0) {
		result := result + 2;
		x := ((x) >> 2);
	}
	if (((x) & 1) == 0) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (98 bytes)
	cmplStd/lib/math/Bits.ci:346: (19 bytes): if ((x) == 0)
	<scanForward>  : load.sp(+4)
	<scanForward+?>: load.iu8
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +12
	cmplStd/lib/math/Bits.ci:347: (8 bytes): return .result := -1;
	<scanForward+?>: load.c32 -1
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:350: (1 byte): result: int32 := 0
	<scanForward+?>: load.z32
	cmplStd/lib/math/Bits.ci:351: (29 bytes): if (((x) & 15) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.and 0x0f
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:352: (4 bytes): result := result + 4;
	<scanForward+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:353: (12 bytes): x := ((x) >> 4);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.sar 0x04
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i8
	cmplStd/lib/math/Bits.ci:355: (29 bytes): if (((x) & 3) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.and 0x03
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:356: (4 bytes): result := result + 2;
	<scanForward+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:357: (12 bytes): x := ((x) >> 2);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.sar 0x02
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i8
	cmplStd/lib/math/Bits.ci:359: (17 bytes): if (((x) & 1) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.and 0x01
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +8
	cmplStd/lib/math/Bits.ci:360: (4 bytes): result := result + 1;
	<scanForward+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:362: (3 bytes): return .result := result;
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:366: referenced as `scanForward`
}
Bits.scanForward(x: int8): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:366'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int8 (size: 4, cast: i32)
.doc: 'find the index of the least significant(lowest) bit'
.value: scanForward(uint8(x))
.usages:
}
Bits.keepMsb(x: uint64): uint64: function {
.kind: static function
.base: `function`
.size: 92
.name: 'keepMsb'
.file: 'cmplStd/lib/math/Bits.ci:370'
.owner: Bits
.param .result: uint64 (size: 8, cast: variable(u64))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'keep the highest bit set'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.hib)) != null) {
		return .result := uint64.hib(x);
	}
	x := x | x >> 1;
	x := x | x >> 2;
	x := x | x >> 4;
	x := x | x >> 8;
	x := x | x >> 16;
	x := x | x >> 32;
	return .result := x - (x >> 1);
}
.instructions: (92 bytes)
	cmplStd/lib/math/Bits.ci:376: (13 bytes): x := x | x >> 1;
	<keepMsb>  : dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 1
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:377: (13 bytes): x := x | x >> 2;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 2
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:378: (13 bytes): x := x | x >> 4;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 4
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:379: (13 bytes): x := x | x >> 8;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 8
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:380: (13 bytes): x := x | x >> 16;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 16
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:381: (13 bytes): x := x | x >> 32;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 32
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:382: (14 bytes): return .result := x - (x >> 1);
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 1
	<keepMsb+?>: shr.b64
	<keepMsb+?>: sub.i64
	<keepMsb+?>: set.x64 sp(5)
	<keepMsb+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:386: referenced as `keepMsb`
}
Bits.keepMsb(x: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepMsb'
.file: 'cmplStd/lib/math/Bits.ci:386'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param x: int64 (size: 8, cast: i64)
.doc: 'keep the highest bit set'
.value: keepMsb(uint64(x))
.usages:
}
Bits.keepMsb(x: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 64
.name: 'keepMsb'
.file: 'cmplStd/lib/math/Bits.ci:389'
.owner: Bits
.param .result: uint32 (size: 4, cast: variable(u32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'keep the highest bit set'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.hib)) != null) {
		return .result := uint32.hib(x);
	}
	x := x | x >> 1;
	x := x | x >> 2;
	x := x | x >> 4;
	x := x | x >> 8;
	x := x | x >> 16;
	return .result := x - (x >> 1);
}
.instructions: (64 bytes)
	cmplStd/lib/math/Bits.ci:392: (9 bytes): return .result := uint32.hib(x);
	<keepMsb>  : dup.x32 sp(1)
	<keepMsb+?>: nfc(30) ;uint32.hib(value: int32): int32
	<keepMsb+?>: set.x32 sp(3)
	<keepMsb+?>: ret
	cmplStd/lib/math/Bits.ci:395: (9 bytes): x := x | x >> 1;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x01
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:396: (9 bytes): x := x | x >> 2;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x02
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:397: (9 bytes): x := x | x >> 4;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x04
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:398: (9 bytes): x := x | x >> 8;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x08
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:399: (9 bytes): x := x | x >> 16;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x10
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:400: (10 bytes): return .result := x - (x >> 1);
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x01
	<keepMsb+?>: sub.i32
	<keepMsb+?>: set.x32 sp(3)
	<keepMsb+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:404: referenced as `keepMsb`
}
Bits.keepMsb(x: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepMsb'
.file: 'cmplStd/lib/math/Bits.ci:404'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param x: int32 (size: 4, cast: i32)
.doc: 'keep the highest bit set'
.value: keepMsb(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:59: referenced as `keepMsb`
}
Bits.keepLsb(x: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:408'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'keep the lowest bit set'
.value: uint64(x & -x)
.usages:
	cmplStd/lib/math/Bits.ci:411: referenced as `keepLsb`
}
Bits.keepLsb(x: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:411'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param x: int64 (size: 8, cast: i64)
.doc: 'keep the lowest bit set'
.value: keepLsb(uint64(x))
.usages:
}
Bits.keepLsb(x: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:414'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'keep the lowest bit set'
.value: uint32(x & -x)
.usages:
	cmplStd/lib/math/Bits.ci:417: referenced as `keepLsb`
}
Bits.keepLsb(x: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:417'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param x: int32 (size: 4, cast: i32)
.doc: 'keep the lowest bit set'
.value: keepLsb(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:60: referenced as `keepLsb`
}
Bits.keepLsb(x: uint16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:420'
.owner: Bits
.param .result: uint16 (size: 2, cast: u32)
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'keep the lowest bit set'
.value: uint16(x & -x)
.usages:
	cmplStd/lib/math/Bits.ci:423: referenced as `keepLsb`
}
Bits.keepLsb(x: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:423'
.owner: Bits
.param .result: uint16 (size: 2, cast: u32)
.param x: int16 (size: 4, cast: i32)
.doc: 'keep the lowest bit set'
.value: keepLsb(uint16(x))
.usages:
}
Bits.keepLsb(x: uint8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:426'
.owner: Bits
.param .result: uint8 (size: 1, cast: u32)
.param x: uint8 (size: 4, cast: variable(u32))
.doc: 'keep the lowest bit set'
.value: uint8(x & -x)
.usages:
	cmplStd/lib/math/Bits.ci:429: referenced as `keepLsb`
}
Bits.keepLsb(x: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:429'
.owner: Bits
.param .result: uint8 (size: 1, cast: u32)
.param x: int8 (size: 4, cast: i32)
.doc: 'keep the lowest bit set'
.value: keepLsb(uint8(x))
.usages:
}
Bits.countOnes(x: uint64): int32: function {
.kind: static function
.base: `function`
.size: 134
.name: 'countOnes'
.file: 'cmplStd/lib/math/Bits.ci:433'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'count bits set to one'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.pop)) != null) {
		return .result := uint64.pop(x);
	}
	x := x - ((x >> 1) & (6148914691236517205));
	x := (x & (3689348814741910323)) + ((x >> 2) & (3689348814741910323));
	x := (x + (x >> 4)) & (1085102592571150095);
	x := x + (x >> 8);
	x := x + (x >> 16);
	x := x + (x >> 32);
	return .result := x & (63);
}
.instructions: (134 bytes)
	cmplStd/lib/math/Bits.ci:439: (23 bytes): x := x - ((x >> 1) & (6148914691236517205));
	<countOnes>  : dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 1
	<countOnes+?>: shr.b64
	<countOnes+?>: load.c64 6148914691236517205
	<countOnes+?>: and.b64
	<countOnes+?>: sub.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:440: (33 bytes): x := (x & (3689348814741910323)) + ((x >> 2) & (3689348814741910323));
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: load.c64 3689348814741910323
	<countOnes+?>: and.b64
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 2
	<countOnes+?>: shr.b64
	<countOnes+?>: load.c64 3689348814741910323
	<countOnes+?>: and.b64
	<countOnes+?>: add.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:441: (23 bytes): x := (x + (x >> 4)) & (1085102592571150095);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 4
	<countOnes+?>: shr.b64
	<countOnes+?>: add.i64
	<countOnes+?>: load.c64 1085102592571150095
	<countOnes+?>: and.b64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:442: (13 bytes): x := x + (x >> 8);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 8
	<countOnes+?>: shr.b64
	<countOnes+?>: add.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:443: (13 bytes): x := x + (x >> 16);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 16
	<countOnes+?>: shr.b64
	<countOnes+?>: add.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:444: (13 bytes): x := x + (x >> 32);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 32
	<countOnes+?>: shr.b64
	<countOnes+?>: add.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:445: (16 bytes): return .result := x & (63);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: load.c64 63
	<countOnes+?>: and.b64
	<countOnes+?>: i64.2i32
	<countOnes+?>: set.x32 sp(4)
	<countOnes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:449: referenced as `countOnes`
}
Bits.countOnes(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'countOnes'
.file: 'cmplStd/lib/math/Bits.ci:449'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int64 (size: 8, cast: i64)
.doc: 'count bits set to one'
.value: countOnes(uint64(x))
.usages:
}
Bits.countOnes(x: uint32): int32: function {
.kind: static function
.base: `function`
.size: 85
.name: 'countOnes'
.file: 'cmplStd/lib/math/Bits.ci:452'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'count bits set to one'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.pop)) != null) {
		return .result := uint32.pop(x);
	}
	x := x - ((x >> 1) & (1431655765));
	x := (x & (858993459)) + ((x >> 2) & (858993459));
	x := (x + (x >> 4)) & (252645135);
	x := x + (x >> 8);
	x := x + (x >> 16);
	return .result := x & (63);
}
.instructions: (85 bytes)
	cmplStd/lib/math/Bits.ci:455: (9 bytes): return .result := uint32.pop(x);
	<countOnes>  : dup.x32 sp(1)
	<countOnes+?>: nfc(26) ;uint32.pop(value: int32): int32
	<countOnes+?>: set.x32 sp(3)
	<countOnes+?>: ret
	cmplStd/lib/math/Bits.ci:458: (15 bytes): x := x - ((x >> 1) & (1431655765));
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x01
	<countOnes+?>: load.c32 1431655765
	<countOnes+?>: and.b32
	<countOnes+?>: sub.i32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:459: (21 bytes): x := (x & (858993459)) + ((x >> 2) & (858993459));
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: load.c32 858993459
	<countOnes+?>: and.b32
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x02
	<countOnes+?>: load.c32 858993459
	<countOnes+?>: and.b32
	<countOnes+?>: add.i32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:460: (15 bytes): x := (x + (x >> 4)) & (252645135);
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x04
	<countOnes+?>: add.i32
	<countOnes+?>: load.c32 252645135
	<countOnes+?>: and.b32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:461: (9 bytes): x := x + (x >> 8);
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x08
	<countOnes+?>: add.i32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:462: (9 bytes): x := x + (x >> 16);
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x10
	<countOnes+?>: add.i32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:463: (7 bytes): return .result := x & (63);
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: b32.and 0x3f
	<countOnes+?>: set.x32 sp(3)
	<countOnes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:467: referenced as `countOnes`
}
Bits.countOnes(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'countOnes'
.file: 'cmplStd/lib/math/Bits.ci:467'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.doc: 'count bits set to one'
.value: countOnes(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:55: referenced as `countOnes`
}
Bits.swapBits(x: uint64): uint64: function {
.kind: static function
.base: `function`
.size: 215
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:471'
.owner: Bits
.param .result: uint64 (size: 8, cast: variable(u64))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'reverse all the bits'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.swap)) != null) {
		return .result := uint64.swap(x);
	}
	x := ((x >> 1) & (6148914691236517205)) | ((x & (6148914691236517205)) << 1);
	x := ((x >> 2) & (3689348814741910323)) | ((x & (3689348814741910323)) << 2);
	x := ((x >> 4) & (1085102592571150095)) | ((x & (1085102592571150095)) << 4);
	x := ((x >> 8) & (71777214294589695)) | ((x & (71777214294589695)) << 8);
	x := ((x >> 16) & (281470681808895)) | ((x & (281470681808895)) << 16);
	return .result := (x >> 32) | (x << 32);
}
.instructions: (215 bytes)
	cmplStd/lib/math/Bits.ci:477: (39 bytes): x := ((x >> 1) & (6148914691236517205)) | ((x & (6148914691236517205)) << 1);
	<swapBits>  : dup.x64 sp(1)
	<swapBits+?>: load.c32 1
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 6148914691236517205
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 6148914691236517205
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 1
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:478: (39 bytes): x := ((x >> 2) & (3689348814741910323)) | ((x & (3689348814741910323)) << 2);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 2
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 3689348814741910323
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 3689348814741910323
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 2
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:479: (39 bytes): x := ((x >> 4) & (1085102592571150095)) | ((x & (1085102592571150095)) << 4);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 4
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 1085102592571150095
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 1085102592571150095
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 4
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:480: (39 bytes): x := ((x >> 8) & (71777214294589695)) | ((x & (71777214294589695)) << 8);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 8
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 71777214294589695
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 71777214294589695
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 8
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:481: (39 bytes): x := ((x >> 16) & (281470681808895)) | ((x & (281470681808895)) << 16);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 16
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 281470681808895
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 281470681808895
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 16
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:482: (20 bytes): return .result := (x >> 32) | (x << 32);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 32
	<swapBits+?>: shr.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c32 32
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(5)
	<swapBits+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:486: referenced as `swapBits`
}
Bits.swapBits(x: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:486'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param x: int64 (size: 8, cast: i64)
.doc: 'reverse all the bits'
.value: swapBits(uint64(x))
.usages:
}
Bits.swapBits(x: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 113
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:489'
.owner: Bits
.param .result: uint32 (size: 4, cast: variable(u32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'reverse all the bits'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.swap)) != null) {
		return .result := uint32.swap(x);
	}
	x := ((x >> 1) & (1431655765)) | ((x & (1431655765)) << 1);
	x := ((x >> 2) & (858993459)) | ((x & (858993459)) << 2);
	x := ((x >> 4) & (252645135)) | ((x & (252645135)) << 4);
	x := ((x >> 8) & (16711935)) | ((x & (16711935)) << 8);
	return .result := (x >> 16) | (x << 16);
}
.instructions: (113 bytes)
	cmplStd/lib/math/Bits.ci:492: (9 bytes): return .result := uint32.swap(x);
	<swapBits>  : dup.x32 sp(1)
	<swapBits+?>: nfc(27) ;uint32.swap(value: int32): int32
	<swapBits+?>: set.x32 sp(3)
	<swapBits+?>: ret
	cmplStd/lib/math/Bits.ci:495: (23 bytes): x := ((x >> 1) & (1431655765)) | ((x & (1431655765)) << 1);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x01
	<swapBits+?>: load.c32 1431655765
	<swapBits+?>: and.b32
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: load.c32 1431655765
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x01
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:496: (23 bytes): x := ((x >> 2) & (858993459)) | ((x & (858993459)) << 2);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x02
	<swapBits+?>: load.c32 858993459
	<swapBits+?>: and.b32
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: load.c32 858993459
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x02
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:497: (23 bytes): x := ((x >> 4) & (252645135)) | ((x & (252645135)) << 4);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x04
	<swapBits+?>: load.c32 252645135
	<swapBits+?>: and.b32
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: load.c32 252645135
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x04
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:498: (23 bytes): x := ((x >> 8) & (16711935)) | ((x & (16711935)) << 8);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x08
	<swapBits+?>: load.c32 16711935
	<swapBits+?>: and.b32
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: load.c32 16711935
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x08
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:499: (12 bytes): return .result := (x >> 16) | (x << 16);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x10
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: b32.shl 0x10
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(3)
	<swapBits+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:503: referenced as `swapBits`
}
Bits.swapBits(x: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:503'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param x: int32 (size: 4, cast: i32)
.doc: 'reverse all the bits'
.value: swapBits(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:56: referenced as `swapBits`
}
Bits.swapBits(x: uint16): uint16: function {
.kind: static function
.base: `function`
.size: 117
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:506'
.owner: Bits
.param .result: uint16 (size: 4, cast: variable(u32))
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'reverse all the bits'
.value: {
	x := ((((x) >> 1) & 21845) | (((x) & 21845) << 1));
	x := ((((x) >> 2) & 13107) | (((x) & 13107) << 2));
	x := ((((x) >> 4) & 3855) | (((x) & 3855) << 4));
	return .result := ((x) >> 8) | ((x) << 8);
}
.instructions: (117 bytes)
	cmplStd/lib/math/Bits.ci:507: (32 bytes): x := ((((x) >> 1) & 21845) | (((x) & 21845) << 1));
	<swapBits>  : load.sp(+4)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.sar 0x01
	<swapBits+?>: load.c32 21845
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu16
	<swapBits+?>: load.c32 21845
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x01
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i16
	cmplStd/lib/math/Bits.ci:508: (32 bytes): x := ((((x) >> 2) & 13107) | (((x) & 13107) << 2));
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.sar 0x02
	<swapBits+?>: load.c32 13107
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu16
	<swapBits+?>: load.c32 13107
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x02
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i16
	cmplStd/lib/math/Bits.ci:509: (32 bytes): x := ((((x) >> 4) & 3855) | (((x) & 3855) << 4));
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.sar 0x04
	<swapBits+?>: load.c32 3855
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu16
	<swapBits+?>: load.c32 3855
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x04
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i16
	cmplStd/lib/math/Bits.ci:510: (21 bytes): return .result := ((x) >> 8) | ((x) << 8);
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.sar 0x08
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.shl 0x08
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+12)
	<swapBits+?>: store.i16
	<swapBits+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:514: referenced as `swapBits`
}
Bits.swapBits(x: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:514'
.owner: Bits
.param .result: uint16 (size: 2, cast: u32)
.param x: int16 (size: 4, cast: i32)
.doc: 'reverse all the bits'
.value: swapBits(uint16(x))
.usages:
}
Bits.swapBits(x: uint8): uint8: function {
.kind: static function
.base: `function`
.size: 85
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:517'
.owner: Bits
.param .result: uint8 (size: 4, cast: variable(u32))
.param x: uint8 (size: 4, cast: variable(u32))
.doc: 'reverse all the bits'
.value: {
	x := ((((x) >> 1) & 85) | (((x) & 85) << 1));
	x := ((((x) >> 2) & 51) | (((x) & 51) << 2));
	return .result := ((x) >> 4) | ((x) << 4);
}
.instructions: (85 bytes)
	cmplStd/lib/math/Bits.ci:518: (32 bytes): x := ((((x) >> 1) & 85) | (((x) & 85) << 1));
	<swapBits>  : load.sp(+4)
	<swapBits+?>: load.iu8
	<swapBits+?>: b32.sar 0x01
	<swapBits+?>: load.c32 85
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu8
	<swapBits+?>: load.c32 85
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x01
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i8
	cmplStd/lib/math/Bits.ci:519: (32 bytes): x := ((((x) >> 2) & 51) | (((x) & 51) << 2));
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu8
	<swapBits+?>: b32.sar 0x02
	<swapBits+?>: load.c32 51
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu8
	<swapBits+?>: load.c32 51
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x02
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i8
	cmplStd/lib/math/Bits.ci:520: (21 bytes): return .result := ((x) >> 4) | ((x) << 4);
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu8
	<swapBits+?>: b32.sar 0x04
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu8
	<swapBits+?>: b32.shl 0x04
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+12)
	<swapBits+?>: store.i8
	<swapBits+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:524: referenced as `swapBits`
}
Bits.swapBits(x: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:524'
.owner: Bits
.param .result: uint8 (size: 1, cast: u32)
.param x: int8 (size: 4, cast: i32)
.doc: 'reverse all the bits'
.value: swapBits(uint8(x))
.usages:
}
Bits.clamp(value: int32, max: int32): int32: function {
.kind: static function
.base: `function`
.size: 37
.name: 'clamp'
.file: 'cmplStd/lib/math/Bits.ci:528'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param max: int32 (size: 4, cast: variable(i32))
.doc: 'branch-less clamp'
.value: {
	value := value & ~(value >> 31);
	value := value - max;
	value := value & (value >> 31);
	value := value + max;
	return .result := value;
}
.instructions: (37 bytes)
	cmplStd/lib/math/Bits.ci:529: (10 bytes): value := value & ~(value >> 31);
	<clamp>  : dup.x32 sp(2)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: b32.sar 0x1f
	<clamp+?>: cmt.b32
	<clamp+?>: and.b32
	<clamp+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:530: (7 bytes): value := value - max;
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: sub.i32
	<clamp+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:531: (9 bytes): value := value & (value >> 31);
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: b32.sar 0x1f
	<clamp+?>: and.b32
	<clamp+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:532: (7 bytes): value := value + max;
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: add.i32
	<clamp+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:533: (4 bytes): return .result := value;
	<clamp+?>: mov.x32 sp(3, 2)
	<clamp+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:538: referenced as `clamp`
}
Bits.clamp(value: int32, min: int32, max: int32): int32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'clamp'
.file: 'cmplStd/lib/math/Bits.ci:537'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param min: int32 (size: 4, cast: variable(i32))
.param max: int32 (size: 4, cast: variable(i32))
.doc: 'branch-less clamp'
.value: {
	return .result := clamp(value - min, max - min) + min;
}
.instructions: (27 bytes)
	cmplStd/lib/math/Bits.ci:538: (27 bytes): return .result := clamp(value - min, max - min) + min;
	<clamp>  : load.z32
	<clamp+?>: dup.x32 sp(4)
	<clamp+?>: dup.x32 sp(4)
	<clamp+?>: sub.i32
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: dup.x32 sp(5)
	<clamp+?>: sub.i32
	<clamp+?>: load.ref <?> ;Bits.clamp(value: int32, max: int32): int32
	<clamp+?>: call
	<clamp+?>: inc.sp(-8)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: add.i32
	<clamp+?>: set.x32 sp(5)
	<clamp+?>: ret
.usages:
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Math'
.file: 'cmplStd/lib/math/Math.ci:2'
.field pi: float64 (size: 0, cast: static const val)
.field e: float64 (size: 0, cast: static const val)
.field ln2: float64 (size: 0, cast: static const val)
.field log2E: float64 (size: 0, cast: static const val)
.field ln10: float64 (size: 0, cast: static const val)
.field log10E: float64 (size: 0, cast: static const val)
.field phi: float64 (size: 0, cast: static const val)
.field sqrt2: float64 (size: 0, cast: static const val)
.field sqrtE: float64 (size: 0, cast: static const val)
.field sqrtPi: float64 (size: 0, cast: static const val)
.field sqrtPhi: float64 (size: 0, cast: static const val)
.field nan: float64 (size: 0, cast: static const val)
.field inf: float64 (size: 0, cast: static const val)
.field smallestNormal: float64 (size: 0, cast: static const val)
.field isNan: function (size: 12, cast: static function)
.field isInf: function (size: 36, cast: static function)
.field isFinite: function (size: 13, cast: static function)
.field isInf: function (size: 69, cast: static function)
.field floor: function (size: 42, cast: static function)
.field floor: function (size: 34, cast: static function)
.field ceil: function (size: 0, cast: static inline)
.field ceil: function (size: 0, cast: static inline)
.field round: function (size: 0, cast: static inline)
.field round: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field absMod: function (size: 27, cast: static function)
.field absMod: function (size: 27, cast: static function)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field mix: function (size: 0, cast: static inline)
.field mix: function (size: 0, cast: static inline)
.field smoothstep: function (size: 0, cast: static inline)
.field smoothstep: function (size: 0, cast: static inline)
.field smoothstep: function (size: 0, cast: static inline)
.field smoothstep: function (size: 0, cast: static inline)
.field min: function (size: 79, cast: static function)
.field max: function (size: 79, cast: static function)
.field sum: function (size: 40, cast: static function)
.field mean: function (size: 20, cast: static function)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 47, cast: static function)
.field modf: function (size: 92, cast: static function)
.field copysign: function (size: 49, cast: static function)
.field frexp: function (size: 236, cast: static function)
.field ldexp: function (size: 336, cast: static function)
.field log: function (size: 298, cast: static function)
.field log: function (size: 27, cast: static function)
.field log2: function (size: 0, cast: static inline)
.field log10: function (size: 0, cast: static inline)
.field log: function (size: 0, cast: static inline)
.field exp: function (size: 297, cast: static function)
.field exp: function (size: 27, cast: static function)
.field sqrt: function (size: 448, cast: static function)
.field sqrt: function (size: 27, cast: static function)
.field pow: function (size: 590, cast: static function)
.field pow: function (size: 32, cast: static function)
.field sincos: function (size: 357, cast: static function)
.field tancot: function (size: 447, cast: static function)
.field atan: function (size: 42, cast: static function)
.field atan2: function (size: 143, cast: static function)
.field atan2: function (size: 32, cast: static function)
.field sin: function (size: 26, cast: static function)
.field sin: function (size: 27, cast: static function)
.field sinh: function (size: 0, cast: static inline)
.field asin: function (size: 0, cast: static inline)
.field asinh: function (size: 0, cast: static inline)
.field cos: function (size: 43, cast: static function)
.field cos: function (size: 27, cast: static function)
.field cosh: function (size: 0, cast: static inline)
.field acos: function (size: 0, cast: static inline)
.field acosh: function (size: 0, cast: static inline)
.field tan: function (size: 82, cast: static function)
.field tan: function (size: 27, cast: static function)
.field tanh: function (size: 0, cast: static inline)
.field atanh: function (size: 0, cast: static inline)
.field cot: function (size: 41, cast: static function)
.field coth: function (size: 0, cast: static inline)
.field acot: function (size: 0, cast: static inline)
.field acoth: function (size: 0, cast: static inline)
.field sec: function (size: 0, cast: static inline)
.field sech: function (size: 0, cast: static inline)
.field asec: function (size: 0, cast: static inline)
.field asech: function (size: 0, cast: static inline)
.field csc: function (size: 0, cast: static inline)
.field csch: function (size: 0, cast: static inline)
.field acsc: function (size: 0, cast: static inline)
.field acsch: function (size: 0, cast: static inline)
.field radians: function (size: 0, cast: static inline)
.field degrees: function (size: 0, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	cmplStd/test/math/test.Math.ci:119: referenced as `Math`
	cmplStd/test/math/test.Math.ci:118: referenced as `Math`
	cmplStd/test/math/test.Math.ci:117: referenced as `Math`
	cmplStd/test/math/test.Math.ci:116: referenced as `Math`
	cmplStd/test/math/test.Math.ci:114: referenced as `Math`
	cmplStd/test/math/test.Math.ci:113: referenced as `Math`
	cmplStd/test/math/test.Math.ci:112: referenced as `Math`
	cmplStd/test/math/test.Math.ci:111: referenced as `Math`
	cmplStd/test/math/test.Math.ci:109: referenced as `Math`
	cmplStd/test/math/test.Math.ci:108: referenced as `Math`
	cmplStd/test/math/test.Math.ci:107: referenced as `Math`
	cmplStd/test/math/test.Math.ci:105: referenced as `Math`
	cmplStd/test/math/test.Math.ci:104: referenced as `Math`
	cmplStd/test/math/test.Math.ci:103: referenced as `Math`
	cmplStd/test/math/test.Math.ci:102: referenced as `Math`
	cmplStd/test/math/test.Math.ci:100: referenced as `Math`
	cmplStd/test/math/test.Math.ci:99: referenced as `Math`
	cmplStd/test/math/test.Math.ci:98: referenced as `Math`
	cmplStd/test/math/test.Math.ci:97: referenced as `Math`
	cmplStd/test/math/test.Math.ci:95: referenced as `Math`
	cmplStd/test/math/test.Math.ci:94: referenced as `Math`
	cmplStd/test/math/test.Math.ci:93: referenced as `Math`
	cmplStd/test/math/test.Math.ci:90: referenced as `Math`
	cmplStd/test/math/test.Math.ci:89: referenced as `Math`
	cmplStd/test/math/test.Math.ci:87: referenced as `Math`
	cmplStd/test/math/test.Math.ci:87: referenced as `Math`
	cmplStd/test/math/test.Math.ci:86: referenced as `Math`
	cmplStd/test/math/test.Math.ci:86: referenced as `Math`
	cmplStd/test/math/test.Math.ci:85: referenced as `Math`
	cmplStd/test/math/test.Math.ci:85: referenced as `Math`
	cmplStd/test/math/test.Math.ci:84: referenced as `Math`
	cmplStd/test/math/test.Math.ci:84: referenced as `Math`
	cmplStd/test/math/test.Math.ci:83: referenced as `Math`
	cmplStd/test/math/test.Math.ci:83: referenced as `Math`
	cmplStd/test/math/test.Math.ci:81: referenced as `Math`
	cmplStd/test/math/test.Math.ci:80: referenced as `Math`
	cmplStd/test/math/test.Math.ci:79: referenced as `Math`
	cmplStd/test/math/test.Math.ci:78: referenced as `Math`
	cmplStd/test/math/test.Math.ci:77: referenced as `Math`
	cmplStd/test/math/test.Math.ci:76: referenced as `Math`
	cmplStd/test/math/test.Math.ci:75: referenced as `Math`
	cmplStd/test/math/test.Math.ci:72: referenced as `Math`
	cmplStd/test/math/test.Math.ci:71: referenced as `Math`
	cmplStd/test/math/test.Math.ci:70: referenced as `Math`
	cmplStd/test/math/test.Math.ci:69: referenced as `Math`
	cmplStd/test/math/test.Math.ci:67: referenced as `Math`
	cmplStd/test/math/test.Math.ci:66: referenced as `Math`
	cmplStd/test/math/test.Math.ci:65: referenced as `Math`
	cmplStd/test/math/test.Math.ci:64: referenced as `Math`
	cmplStd/test/math/test.Math.ci:62: referenced as `Math`
	cmplStd/test/math/test.Math.ci:61: referenced as `Math`
	cmplStd/test/math/test.Math.ci:59: referenced as `Math`
	cmplStd/test/math/test.Math.ci:58: referenced as `Math`
	cmplStd/test/math/test.Math.ci:56: referenced as `Math`
	cmplStd/test/math/test.Math.ci:55: referenced as `Math`
	cmplStd/test/math/test.Math.ci:53: referenced as `Math`
	cmplStd/test/math/test.Math.ci:52: referenced as `Math`
	cmplStd/test/math/test.Math.ci:51: referenced as `Math`
	cmplStd/test/math/test.Math.ci:50: referenced as `Math`
	cmplStd/test/math/test.Math.ci:48: referenced as `Math`
	cmplStd/test/math/test.Math.ci:47: referenced as `Math`
	cmplStd/test/math/test.Math.ci:46: referenced as `Math`
	cmplStd/test/math/test.Math.ci:45: referenced as `Math`
	cmplStd/test/math/test.Math.ci:44: referenced as `Math`
	cmplStd/test/math/test.Math.ci:43: referenced as `Math`
	cmplStd/test/math/test.Math.ci:41: referenced as `Math`
	cmplStd/test/math/test.Math.ci:40: referenced as `Math`
	cmplStd/test/math/test.Math.ci:39: referenced as `Math`
	cmplStd/test/math/test.Math.ci:38: referenced as `Math`
	cmplStd/test/math/test.Math.ci:37: referenced as `Math`
	cmplStd/test/math/test.Math.ci:36: referenced as `Math`
	cmplStd/test/math/test.Math.ci:34: referenced as `Math`
	cmplStd/test/math/test.Math.ci:33: referenced as `Math`
	cmplStd/test/math/test.Math.ci:32: referenced as `Math`
	cmplStd/test/math/test.Math.ci:31: referenced as `Math`
	cmplStd/test/math/test.Math.ci:30: referenced as `Math`
	cmplStd/test/math/test.Math.ci:29: referenced as `Math`
	cmplStd/test/math/test.Math.ci:28: referenced as `Math`
	cmplStd/test/math/test.Math.ci:27: referenced as `Math`
	cmplStd/test/math/test.Math.ci:26: referenced as `Math`
	cmplStd/test/math/test.Math.ci:25: referenced as `Math`
	cmplStd/test/math/test.Math.ci:23: referenced as `Math`
	cmplStd/test/math/test.Math.ci:22: referenced as `Math`
	cmplStd/test/math/test.Math.ci:21: referenced as `Math`
	cmplStd/test/math/test.Math.ci:20: referenced as `Math`
	cmplStd/test/math/test.Math.ci:19: referenced as `Math`
	cmplStd/test/math/test.Math.ci:18: referenced as `Math`
	cmplStd/test/math/test.Math.ci:17: referenced as `Math`
	cmplStd/test/math/test.Math.ci:16: referenced as `Math`
	cmplStd/test/math/test.Math.ci:15: referenced as `Math`
	cmplStd/test/math/test.Math.ci:14: referenced as `Math`
	cmplStd/test/math/test.Math.ci:12: referenced as `Math`
	cmplStd/test/math/test.Math.ci:11: referenced as `Math`
	cmplStd/test/math/test.Math.ci:10: referenced as `Math`
	cmplStd/test/math/test.Math.ci:9: referenced as `Math`
	cmplStd/test/math/test.Math.ci:8: referenced as `Math`
	cmplStd/test/math/test.Math.ci:7: referenced as `Math`
	cmplStd/test/math/test.Math.ci:6: referenced as `Math`
	cmplStd/test/math/test.Math.ci:5: referenced as `Math`
	cmplStd/test/math/test.Math.ci:4: referenced as `Math`
	cmplStd/test/math/test.Math.ci:3: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:53: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:52: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:51: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:50: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:49: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:48: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:47: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:46: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:44: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:43: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:42: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:41: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:40: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:39: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:38: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:37: referenced as `Math`
	cmplGfx/lib/micro.ui.ci:371: referenced as `Math`
	cmplGfx/lib/micro.ui.ci:208: referenced as `Math`
	cmplGfx/lib/micro.ui.core.ci:751: referenced as `Math`
	cmplGfx/lib/micro.ui.core.ci:336: referenced as `Math`
	cmplGfx/lib/micro.ui.core.ci:332: referenced as `Math`
	cmplGfx/lib/camera.ci:28: referenced as `Math`
	cmplGfx/lib/camera.ci:28: referenced as `Math`
	cmplGfx/lib/image.blur.ci:21: referenced as `Math`
	cmplGfx/lib/image.transform.ci:147: referenced as `Math`
	cmplGfx/lib/image.transform.ci:144: referenced as `Math`
	cmplGfx/lib/image.transform.ci:93: referenced as `Math`
	cmplGfx/lib/image.transform.ci:91: referenced as `Math`
	cmplGfx/lib/image.draw.line.ci:13: referenced as `Math`
	cmplGfx/lib/image.draw.line.ci:13: referenced as `Math`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `Math`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `Math`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `Math`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `Math`
	cmplGfx/lib/image.draw.rrect.ci:83: referenced as `Math`
	cmplGfx/lib/image.draw.rrect.ci:82: referenced as `Math`
	cmplGfx/lib/image.draw.rrect.ci:24: referenced as `Math`
	cmplGfx/lib/image.draw.rrect.ci:23: referenced as `Math`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `Math`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `Math`
	cmplStd/lib/math/Polynomial.ci:60: referenced as `Math`
	cmplStd/lib/math/Easing.ci:49: referenced as `Math`
	cmplStd/lib/math/Easing.ci:49: referenced as `Math`
	cmplStd/lib/math/Easing.ci:49: referenced as `Math`
	cmplStd/lib/math/Easing.ci:42: referenced as `Math`
	cmplStd/lib/math/Easing.ci:37: referenced as `Math`
	cmplStd/lib/math/Easing.ci:37: referenced as `Math`
	cmplStd/lib/math/Easing.ci:32: referenced as `Math`
	cmplStd/lib/text/encoding/binary/Base64.ci:32: referenced as `Math`
	cmplStd/lib/text/Format.ci:225: referenced as `Math`
	cmplStd/lib/text/Format.ci:218: referenced as `Math`
	cmplStd/lib/text/Format.ci:211: referenced as `Math`
	cmplStd/lib/text/Format.ci:205: referenced as `Math`
	cmplStd/lib/text/Format.ci:197: referenced as `Math`
	cmplStd/lib/text/Format.ci:197: referenced as `Math`
	cmplStd/lib/text/cstr.ci:153: referenced as `Math`
	cmplStd/lib/text/cstr.ci:141: referenced as `Math`
	cmplStd/lib/text/cstr.ci:126: referenced as `Math`
	cmplStd/lib/time/Datetime.ci:169: referenced as `Math`
	cmplStd/lib/time/Datetime.ci:159: referenced as `Math`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `Math`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `Math`
	cmplStd/lib/math/Matrix4f.ci:134: referenced as `Math`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:137: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:118: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:117: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:115: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `Math`
	cmplStd/lib/math/Complex.ci:142: referenced as `Math`
	cmplStd/lib/math/Complex.ci:142: referenced as `Math`
	cmplStd/lib/math/Complex.ci:118: referenced as `Math`
	cmplStd/lib/math/Complex.ci:118: referenced as `Math`
	cmplStd/lib/math/Complex.ci:118: referenced as `Math`
	cmplStd/lib/math/Complex.ci:118: referenced as `Math`
	cmplStd/lib/math/Complex.ci:116: referenced as `Math`
	cmplStd/lib/math/Complex.ci:116: referenced as `Math`
	cmplStd/lib/math/Complex.ci:116: referenced as `Math`
	cmplStd/lib/math/Complex.ci:116: referenced as `Math`
	cmplStd/lib/math/Complex.ci:109: referenced as `Math`
	cmplStd/lib/math/Complex.ci:108: referenced as `Math`
	cmplStd/lib/math/Complex.ci:106: referenced as `Math`
	cmplStd/lib/math/Complex.ci:106: referenced as `Math`
	cmplStd/lib/math/Complex.ci:105: referenced as `Math`
	cmplStd/lib/math/Complex.ci:99: referenced as `Math`
	cmplStd/lib/math/Complex.ci:96: referenced as `Math`
	cmplStd/lib/math/Complex.ci:96: referenced as `Math`
	cmplStd/lib/math/Complex.ci:96: referenced as `Math`
	cmplStd/lib/math/Complex.ci:96: referenced as `Math`
	cmplStd/lib/math/Complex.ci:81: referenced as `Math`
	cmplStd/lib/math/Complex.ci:79: referenced as `Math`
	cmplStd/lib/math/Complex.ci:58: referenced as `Math`
	cmplStd/lib/math/Complex.ci:58: referenced as `Math`
	cmplStd/lib/math/Fixed.ci:758: referenced as `Math`
	cmplStd/lib/math/Fixed.ci:755: referenced as `Math`
	cmplStd/lib/math/Fixed.ci:752: referenced as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'pi'
.file: 'cmplStd/lib/math/Math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	cmplStd/test/math/test.Math.ci:87: referenced as `pi`
	cmplStd/test/math/test.Math.ci:86: referenced as `pi`
	cmplStd/test/math/test.Math.ci:85: referenced as `pi`
	cmplStd/test/math/test.Math.ci:84: referenced as `pi`
	cmplStd/test/math/test.Math.ci:83: referenced as `pi`
	cmplStd/lib/math/Easing.ci:49: referenced as `pi`
	cmplStd/lib/math/Easing.ci:37: referenced as `pi`
	cmplStd/lib/math/Math.ci:1054: referenced as `pi`
	cmplStd/lib/math/Math.ci:1051: referenced as `pi`
	cmplStd/lib/math/Math.ci:1018: referenced as `pi`
	cmplStd/lib/math/Math.ci:883: referenced as `pi`
	cmplStd/lib/math/Math.ci:881: referenced as `pi`
	cmplStd/lib/math/Math.ci:875: referenced as `pi`
	cmplStd/lib/math/Math.ci:873: referenced as `pi`
	cmplStd/lib/math/Math.ci:854: referenced as `pi`
	cmplStd/lib/math/Math.ci:852: referenced as `pi`
	cmplStd/lib/math/Math.ci:778: referenced as `pi`
	cmplStd/lib/math/Math.ci:717: referenced as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'e'
.file: 'cmplStd/lib/math/Math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'ln2'
.file: 'cmplStd/lib/math/Math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	cmplStd/lib/math/Math.ci:454: referenced as `ln2`
	cmplStd/lib/math/Math.ci:9: referenced as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'log2E'
.file: 'cmplStd/lib/math/Math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'ln10'
.file: 'cmplStd/lib/math/Math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	cmplStd/lib/math/Math.ci:457: referenced as `ln10`
	cmplStd/lib/math/Math.ci:11: referenced as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'log10E'
.file: 'cmplStd/lib/math/Math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'phi'
.file: 'cmplStd/lib/math/Math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrt2'
.file: 'cmplStd/lib/math/Math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrtE'
.file: 'cmplStd/lib/math/Math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrtPi'
.file: 'cmplStd/lib/math/Math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrtPhi'
.file: 'cmplStd/lib/math/Math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'nan'
.file: 'cmplStd/lib/math/Math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	cmplStd/lib/text/cstr.ci:153: referenced as `nan`
	cmplStd/lib/text/cstr.ci:141: referenced as `nan`
	cmplStd/lib/text/cstr.ci:126: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:752: referenced as `nan`
	cmplStd/lib/math/Math.ci:978: referenced as `nan`
	cmplStd/lib/math/Math.ci:643: referenced as `nan`
	cmplStd/lib/math/Math.ci:630: referenced as `nan`
	cmplStd/lib/math/Math.ci:548: referenced as `nan`
	cmplStd/lib/math/Math.ci:422: referenced as `nan`
	cmplStd/lib/math/Math.ci:225: referenced as `nan`
	cmplStd/lib/math/Math.ci:211: referenced as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'inf'
.file: 'cmplStd/lib/math/Math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
	cmplGfx/lib/image.transform.ci:147: referenced as `inf`
	cmplGfx/lib/image.transform.ci:144: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:758: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:755: referenced as `inf`
	cmplStd/lib/math/Math.ci:1047: referenced as `inf`
	cmplStd/lib/math/Math.ci:1044: referenced as `inf`
	cmplStd/lib/math/Math.ci:1034: referenced as `inf`
	cmplStd/lib/math/Math.ci:1031: referenced as `inf`
	cmplStd/lib/math/Math.ci:1021: referenced as `inf`
	cmplStd/lib/math/Math.ci:1021: referenced as `inf`
	cmplStd/lib/math/Math.ci:1009: referenced as `inf`
	cmplStd/lib/math/Math.ci:998: referenced as `inf`
	cmplStd/lib/math/Math.ci:998: referenced as `inf`
	cmplStd/lib/math/Math.ci:493: referenced as `inf`
	cmplStd/lib/math/Math.ci:420: referenced as `inf`
	cmplStd/lib/math/Math.ci:382: referenced as `inf`
}
Math.smallestNormal: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'smallestNormal'
.file: 'cmplStd/lib/math/Math.ci:19'
.owner: Math
.doc: 'smallestNormal'
.value: 0.000000
.usages:
	cmplStd/lib/math/Math.ci:367: referenced as `smallestNormal`
	cmplStd/lib/math/Math.ci:326: referenced as `smallestNormal`
}
Math.isNan(x: float64): bool: function {
.kind: static function
.base: `function`
.size: 12
.name: 'isNan'
.file: 'cmplStd/lib/math/Math.ci:23'
.owner: Math
.param .result: bool (size: 4, cast: variable(bool))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Determines whether the given floating point value is not-a-number'
.value: {
	return .result := x != x;
}
.instructions: (12 bytes)
	cmplStd/lib/math/Math.ci:23: (12 bytes): return .result := x != x;
	<isNan>  : dup.x64 sp(1)
	<isNan+?>: dup.x64 sp(3)
	<isNan+?>: ceq.f64
	<isNan+?>: not.b32
	<isNan+?>: load.sp(+16)
	<isNan+?>: store.i8
	<isNan+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:544: referenced as `isNan`
	cmplStd/lib/math/Math.ci:489: referenced as `isNan`
	cmplStd/lib/math/Math.ci:321: referenced as `isNan`
}
Math.isInf(x: float64): bool: function {
.kind: static function
.base: `function`
.size: 36
.name: 'isInf'
.file: 'cmplStd/lib/math/Math.ci:29'
.owner: Math
.param .result: bool (size: 4, cast: variable(bool))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Determines whether the given floating point value is infinity'
.value: {
	return .result := x != (0) && x == (2) * x;
}
.instructions: (36 bytes)
	cmplStd/lib/math/Math.ci:29: (36 bytes): return .result := x != (0) && x == (2) * x;
	<isInf>  : dup.x64 sp(1)
	<isInf+?>: load.z64
	<isInf+?>: ceq.f64
	<isInf+?>: not.b32
	<isInf+?>: dup.x32 sp(0)
	<isInf+?>: jz +23
	<isInf+?>: inc.sp(-4)
	<isInf+?>: dup.x64 sp(1)
	<isInf+?>: load.f64 2.000000
	<isInf+?>: dup.x64 sp(5)
	<isInf+?>: mul.f64
	<isInf+?>: ceq.f64
	<isInf+?>: load.sp(+16)
	<isInf+?>: store.i8
	<isInf+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:321: referenced as `isInf`
}
Math.isFinite(x: float64): bool: function {
.kind: static function
.base: `function`
.size: 13
.name: 'isFinite'
.file: 'cmplStd/lib/math/Math.ci:34'
.owner: Math
.param .result: bool (size: 4, cast: variable(bool))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Determines whether the given floating point value is finite: `!isNan(x) && !isInf(x)`'
.value: {
	return .result := x - x == (0);
}
.instructions: (13 bytes)
	cmplStd/lib/math/Math.ci:34: (13 bytes): return .result := x - x == (0);
	<isFinite>  : dup.x64 sp(1)
	<isFinite+?>: dup.x64 sp(3)
	<isFinite+?>: sub.f64
	<isFinite+?>: load.z64
	<isFinite+?>: ceq.f64
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:41: referenced as `isFinite`
}
Math.isInf(x: float64, sign: int32): bool: function {
.kind: static function
.base: `function`
.size: 69
.name: 'isInf'
.file: 'cmplStd/lib/math/Math.ci:40'
.owner: Math
.param .result: bool (size: 4, cast: variable(bool))
.param x: float64 (size: 8, cast: variable(f64))
.param sign: int32 (size: 4, cast: variable(i32))
.doc: 'Determines whether the given floating point value is finite: `!isNan(x) && !isInf(x)`'
.value: {
	if (isFinite(x)) {
		return .result := false;
	}
	if (sign == 0) {
		return .result := true;
	}
	return .result := sign < 0 ? x < (0) : x > (0);
}
.instructions: (69 bytes)
	cmplStd/lib/math/Math.ci:41: (24 bytes): if (isFinite(x))
	<isInf>  : load.z32
	<isInf+?>: dup.x64 sp(3)
	<isInf+?>: load.ref <?> ;Math.isFinite(x: float64): bool
	<isInf+?>: call
	<isInf+?>: inc.sp(-8)
	<isInf+?>: jz +11
	cmplStd/lib/math/Math.ci:42: (7 bytes): return .result := false;
	<isInf+?>: load.z32
	<isInf+?>: load.sp(+20)
	<isInf+?>: store.i8
	<isInf+?>: ret
	cmplStd/lib/math/Math.ci:44: (19 bytes): if (sign == 0)
	<isInf+?>: dup.x32 sp(1)
	<isInf+?>: load.z32
	<isInf+?>: ceq.i32
	<isInf+?>: jz +15
	cmplStd/lib/math/Math.ci:45: (11 bytes): return .result := true;
	<isInf+?>: load.c32 1
	<isInf+?>: load.sp(+20)
	<isInf+?>: store.i8
	<isInf+?>: ret
	cmplStd/lib/math/Math.ci:47: (26 bytes): return .result := sign < 0 ? x < (0) : x > (0);
	<isInf+?>: dup.x32 sp(1)
	<isInf+?>: load.z32
	<isInf+?>: clt.i32
	<isInf+?>: jz +12
	<isInf+?>: dup.x64 sp(2)
	<isInf+?>: load.z64
	<isInf+?>: clt.f64
	<isInf+?>: jmp +8
	<isInf+?>: dup.x64 sp(2)
	<isInf+?>: load.z64
	<isInf+?>: cgt.f64
	<isInf+?>: load.sp(+20)
	<isInf+?>: store.i8
	<isInf+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:544: referenced as `isInf`
}
Math.floor(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 42
.name: 'floor'
.file: 'cmplStd/lib/math/Math.ci:52'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	mod: float64 := x % (1);
	if (mod < (0)) {
		mod := mod + (1);
	}
	return .result := x - mod;
}
.instructions: (42 bytes)
	cmplStd/lib/math/Math.ci:53: (12 bytes): mod: float64 := x % (1)
	<floor>  : dup.x64 sp(1)
	<floor+?>: load.f64 1.000000
	<floor+?>: mod.f64
	cmplStd/lib/math/Math.ci:54: (18 bytes): if (mod < (0))
	<floor+?>: dup.x64 sp(0)
	<floor+?>: load.z64
	<floor+?>: clt.f64
	<floor+?>: jz +14
	cmplStd/lib/math/Math.ci:55: (10 bytes): mod := mod + (1);
	<floor+?>: load.f64 1.000000
	<floor+?>: add.f64
	cmplStd/lib/math/Math.ci:57: (12 bytes): return .result := x - mod;
	<floor+?>: dup.x64 sp(3)
	<floor+?>: dup.x64 sp(2)
	<floor+?>: sub.f64
	<floor+?>: set.x64 sp(7)
	<floor+?>: inc.sp(-8)
	<floor+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:12: referenced as `floor`
	cmplStd/test/math/test.Math.ci:11: referenced as `floor`
	cmplStd/test/math/test.Math.ci:10: referenced as `floor`
	cmplStd/test/math/test.Math.ci:9: referenced as `floor`
	cmplStd/test/math/test.Math.ci:8: referenced as `floor`
	cmplStd/test/math/test.Math.ci:7: referenced as `floor`
	cmplStd/test/math/test.Math.ci:6: referenced as `floor`
	cmplStd/test/math/test.Math.ci:5: referenced as `floor`
	cmplStd/test/math/test.Math.ci:4: referenced as `floor`
	cmplStd/test/math/test.Math.ci:3: referenced as `floor`
	cmplStd/lib/math/Math.ci:782: referenced as `floor`
	cmplStd/lib/math/Math.ci:778: referenced as `floor`
	cmplStd/lib/math/Math.ci:505: referenced as `floor`
	cmplStd/lib/math/Math.ci:76: referenced as `floor`
	cmplStd/lib/math/Math.ci:70: referenced as `floor`
}
Math.floor(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 34
.name: 'floor'
.file: 'cmplStd/lib/math/Math.ci:61'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	mod: float32 := x % (1);
	if (mod < (0)) {
		mod := mod + (1);
	}
	return .result := x - mod;
}
.instructions: (34 bytes)
	cmplStd/lib/math/Math.ci:62: (8 bytes): mod: float32 := x % (1)
	<floor>  : dup.x32 sp(1)
	<floor+?>: load.f32 1.000000
	<floor+?>: mod.f32
	cmplStd/lib/math/Math.ci:63: (14 bytes): if (mod < (0))
	<floor+?>: dup.x32 sp(0)
	<floor+?>: load.z32
	<floor+?>: clt.f32
	<floor+?>: jz +10
	cmplStd/lib/math/Math.ci:64: (6 bytes): mod := mod + (1);
	<floor+?>: load.f32 1.000000
	<floor+?>: add.f32
	cmplStd/lib/math/Math.ci:66: (12 bytes): return .result := x - mod;
	<floor+?>: dup.x32 sp(2)
	<floor+?>: dup.x32 sp(1)
	<floor+?>: sub.f32
	<floor+?>: set.x32 sp(4)
	<floor+?>: inc.sp(-4)
	<floor+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:79: referenced as `floor`
	cmplStd/lib/math/Math.ci:73: referenced as `floor`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'cmplStd/lib/math/Math.ci:70'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: -floor(-x)
.usages:
	cmplStd/test/math/test.Math.ci:34: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:33: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:32: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:31: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:30: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:29: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:28: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:27: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:26: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:25: referenced as `ceil`
}
Math.ceil(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'cmplStd/lib/math/Math.ci:73'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param x: float32 (size: 4, cast: f32)
.doc: 'Computes the smallest integer not less than the input'
.value: -floor(-x)
.usages:
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'cmplStd/lib/math/Math.ci:76'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(x + 0.500000)
.usages:
	cmplStd/test/math/test.Math.ci:23: referenced as `round`
	cmplStd/test/math/test.Math.ci:22: referenced as `round`
	cmplStd/test/math/test.Math.ci:21: referenced as `round`
	cmplStd/test/math/test.Math.ci:20: referenced as `round`
	cmplStd/test/math/test.Math.ci:19: referenced as `round`
	cmplStd/test/math/test.Math.ci:18: referenced as `round`
	cmplStd/test/math/test.Math.ci:17: referenced as `round`
	cmplStd/test/math/test.Math.ci:16: referenced as `round`
	cmplStd/test/math/test.Math.ci:15: referenced as `round`
	cmplStd/test/math/test.Math.ci:14: referenced as `round`
	cmplGfx/lib/micro.ui.ci:208: referenced as `round`
}
Math.round(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'cmplStd/lib/math/Math.ci:79'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param x: float32 (size: 4, cast: f32)
.doc: 'Computes the nearest integer to the input'
.value: floor(x + 0.500000)
.usages:
}
Math.sign(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:83'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > 0) - int32(x < 0)
.usages:
}
Math.sign(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:86'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
}
Math.sign(x: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:89'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: uint32 (size: 4, cast: u32)
.doc: 'Returns the signum of the input (`0` if zero, `1` if positive)'
.value: int32(x > (0))
.usages:
}
Math.sign(x: uint64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:92'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: uint64 (size: 8, cast: u64)
.doc: 'Returns the signum of the input (`0` if zero, `1` if positive)'
.value: int32(x > (0))
.usages:
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:95'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
	cmplStd/test/math/test.Math.ci:41: referenced as `sign`
	cmplStd/test/math/test.Math.ci:40: referenced as `sign`
	cmplStd/test/math/test.Math.ci:39: referenced as `sign`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:98'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
	cmplStd/test/math/test.Math.ci:38: referenced as `sign`
	cmplStd/test/math/test.Math.ci:37: referenced as `sign`
	cmplStd/test/math/test.Math.ci:36: referenced as `sign`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'cmplStd/lib/math/Math.ci:102'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param val: float32 (size: 4, cast: variable(f32))
.param mod: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:103: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x32 sp(2)
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: mod.f32
	<absMod+?>: dup.x32 sp(0)
	<absMod+?>: set.x32 sp(4)
	<absMod+?>: load.z32
	<absMod+?>: clt.f32
	<absMod+?>: jz +12
	cmplStd/lib/math/Math.ci:104: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: add.f32
	<absMod+?>: set.x32 sp(4)
	<absMod+?>: ret
	cmplStd/lib/math/Math.ci:106: (4 bytes): return .result := val;
	<absMod+?>: mov.x32 sp(3, 2)
	<absMod+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:119: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:118: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:117: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:116: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:114: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:113: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:112: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:111: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:109: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:108: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:107: referenced as `absMod`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'cmplStd/lib/math/Math.ci:110'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param val: float64 (size: 8, cast: variable(f64))
.param mod: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:111: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x64 sp(3)
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: mod.f64
	<absMod+?>: dup.x64 sp(0)
	<absMod+?>: set.x64 sp(7)
	<absMod+?>: load.z64
	<absMod+?>: clt.f64
	<absMod+?>: jz +12
	cmplStd/lib/math/Math.ci:112: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: add.f64
	<absMod+?>: set.x64 sp(7)
	<absMod+?>: ret
	cmplStd/lib/math/Math.ci:114: (4 bytes): return .result := val;
	<absMod+?>: mov.x64 sp(5, 3)
	<absMod+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:105: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:104: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:103: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:102: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:100: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:99: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:98: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:97: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:95: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:94: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:93: referenced as `absMod`
}
Math.abs(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:118'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the absolute value of the input'
.value: x < 0 ? -x : x
.usages:
	cmplGfx/lib/micro.ui.core.ci:751: referenced as `abs`
	cmplGfx/lib/micro.ui.core.ci:336: referenced as `abs`
	cmplGfx/lib/micro.ui.core.ci:332: referenced as `abs`
	cmplGfx/lib/image.draw.line.ci:13: referenced as `abs`
	cmplGfx/lib/image.draw.line.ci:13: referenced as `abs`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `abs`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `abs`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `abs`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `abs`
}
Math.abs(x: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:121'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param x: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the absolute value of the input'
.value: x < (0) ? -x : x
.usages:
}
Math.abs(x: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:124'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param x: uint32 (size: 4, cast: u32)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:127'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param x: uint64 (size: 8, cast: u64)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:130'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: x < (0) ? -x : x
.usages:
	cmplStd/test/math/test.Math.ci:48: referenced as `abs`
	cmplStd/test/math/test.Math.ci:47: referenced as `abs`
	cmplStd/test/math/test.Math.ci:46: referenced as `abs`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `abs`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `abs`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `abs`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `abs`
}
Math.abs(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:133'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: x < (0) ? -x : x
.usages:
	cmplStd/test/math/test.Math.ci:45: referenced as `abs`
	cmplStd/test/math/test.Math.ci:44: referenced as `abs`
	cmplStd/test/math/test.Math.ci:43: referenced as `abs`
	cmplStd/lib/text/Format.ci:197: referenced as `abs`
	cmplStd/lib/math/Complex.ci:58: referenced as `abs`
	cmplStd/lib/math/Complex.ci:58: referenced as `abs`
	cmplStd/lib/math/Math.ci:367: referenced as `abs`
	cmplStd/lib/math/Math.ci:326: referenced as `abs`
}
Math.min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:137'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplGfx/lib/image.draw.rrect.ci:83: referenced as `min`
	cmplGfx/lib/image.draw.rrect.ci:82: referenced as `min`
	cmplGfx/lib/image.draw.rrect.ci:24: referenced as `min`
	cmplGfx/lib/image.draw.rrect.ci:23: referenced as `min`
	cmplStd/lib/text/encoding/binary/Base64.ci:32: referenced as `min`
	cmplStd/lib/math/Math.ci:174: referenced as `min`
}
Math.min(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:140'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param a: int64 (size: 8, cast: variable(i64))
.param b: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:177: referenced as `min`
}
Math.min(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:143'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param a: uint32 (size: 4, cast: variable(u32))
.param b: uint32 (size: 4, cast: variable(u32))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:180: referenced as `min`
}
Math.min(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:146'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param a: uint64 (size: 8, cast: variable(u64))
.param b: uint64 (size: 8, cast: variable(u64))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:183: referenced as `min`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:149'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/test/math/test.Math.ci:50: referenced as `min`
	cmplStd/lib/math/Math.ci:186: referenced as `min`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:152'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/test/math/test.Math.ci:52: referenced as `min`
	cmplGfx/lib/image.transform.ci:93: referenced as `min`
	cmplStd/lib/math/Math.ci:189: referenced as `min`
}
Math.max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:155'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplGfx/lib/micro.ui.ci:371: referenced as `max`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `max`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `max`
	cmplStd/lib/math/Polynomial.ci:60: referenced as `max`
	cmplStd/lib/text/Format.ci:218: referenced as `max`
	cmplStd/lib/text/Format.ci:205: referenced as `max`
	cmplStd/lib/math/Math.ci:174: referenced as `max`
}
Math.max(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:158'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param a: int64 (size: 8, cast: variable(i64))
.param b: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:177: referenced as `max`
}
Math.max(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:161'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param a: uint32 (size: 4, cast: variable(u32))
.param b: uint32 (size: 4, cast: variable(u32))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:180: referenced as `max`
}
Math.max(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:164'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param a: uint64 (size: 8, cast: variable(u64))
.param b: uint64 (size: 8, cast: variable(u64))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:183: referenced as `max`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:167'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/test/math/test.Math.ci:51: referenced as `max`
	cmplStd/lib/math/Math.ci:186: referenced as `max`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:170'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/test/math/test.Math.ci:53: referenced as `max`
	cmplGfx/lib/image.transform.ci:91: referenced as `max`
	cmplStd/lib/math/Math.ci:189: referenced as `max`
}
Math.clamp(value: int32, min: int32, max: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:174'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param value: int32 (size: 4, cast: i32)
.param min: int32 (size: 4, cast: i32)
.param max: int32 (size: 4, cast: i32)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
	cmplStd/lib/time/Datetime.ci:169: referenced as `clamp`
	cmplStd/lib/time/Datetime.ci:159: referenced as `clamp`
}
Math.clamp(value: int64, min: int64, max: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:177'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param value: int64 (size: 8, cast: i64)
.param min: int64 (size: 8, cast: i64)
.param max: int64 (size: 8, cast: i64)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
}
Math.clamp(value: uint32, min: uint32, max: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:180'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param value: uint32 (size: 4, cast: u32)
.param min: uint32 (size: 4, cast: u32)
.param max: uint32 (size: 4, cast: u32)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
}
Math.clamp(value: uint64, min: uint64, max: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:183'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param value: uint64 (size: 8, cast: u64)
.param min: uint64 (size: 8, cast: u64)
.param max: uint64 (size: 8, cast: u64)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
}
Math.clamp(value: float32, min: float32, max: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:186'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param value: float32 (size: 4, cast: f32)
.param min: float32 (size: 4, cast: f32)
.param max: float32 (size: 4, cast: f32)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
	cmplStd/test/math/test.Math.ci:55: referenced as `clamp`
	cmplStd/lib/math/Math.ci:200: referenced as `clamp`
}
Math.clamp(value: float64, min: float64, max: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:189'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param value: float64 (size: 8, cast: f64)
.param min: float64 (size: 8, cast: f64)
.param max: float64 (size: 8, cast: f64)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
	cmplStd/test/math/test.Math.ci:56: referenced as `clamp`
	cmplStd/lib/math/Math.ci:205: referenced as `clamp`
}
Math.mix(a: float32, b: float32, t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'mix'
.file: 'cmplStd/lib/math/Math.ci:192'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
	cmplStd/test/math/test.Math.ci:58: referenced as `mix`
	cmplStd/lib/math/Vector4f.ci:118: referenced as `mix`
	cmplStd/lib/math/Vector4f.ci:117: referenced as `mix`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `mix`
	cmplStd/lib/math/Vector4f.ci:115: referenced as `mix`
}
Math.mix(a: float64, b: float64, t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'mix'
.file: 'cmplStd/lib/math/Math.ci:195'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
	cmplStd/test/math/test.Math.ci:59: referenced as `mix`
}
Math.smoothstep(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smoothstep'
.file: 'cmplStd/lib/math/Math.ci:197'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: variable(f32))
.value: t * t * ((3) - (2) * t)
.usages:
	cmplStd/lib/math/Math.ci:200: referenced as `smoothstep`
}
Math.smoothstep(min: float32, max: float32, t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smoothstep'
.file: 'cmplStd/lib/math/Math.ci:200'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param min: float32 (size: 4, cast: variable(f32))
.param max: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.doc: 'Returns the Hermite interpolation between two values'
.value: smoothstep(clamp((t - min) / (max - min), 0.000000, 1.000000))
.usages:
	cmplStd/test/math/test.Math.ci:61: referenced as `smoothstep`
}
Math.smoothstep(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smoothstep'
.file: 'cmplStd/lib/math/Math.ci:202'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: variable(f64))
.value: t * t * ((3) - (2) * t)
.usages:
	cmplStd/lib/math/Math.ci:205: referenced as `smoothstep`
}
Math.smoothstep(min: float64, max: float64, t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smoothstep'
.file: 'cmplStd/lib/math/Math.ci:205'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param min: float64 (size: 8, cast: variable(f64))
.param max: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.doc: 'Returns the Hermite interpolation between two values'
.value: smoothstep(clamp((t - min) / (max - min), 0.000000, 1.000000))
.usages:
	cmplStd/test/math/test.Math.ci:62: referenced as `smoothstep`
}
Math.min(values: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:209'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (values.length == (0)) {
		return .result := nan;
	}
	result: float64 := values[0];
	for (i: int32 := 1; i < (values.length); i := i + 1) {
		if (result > values[i]) {
			result := values[i];
		}
	}
	return .result := result;
}
.instructions: (79 bytes)
	cmplStd/lib/math/Math.ci:210: (20 bytes): if (values.length == (0))
	<min>  : dup.x32 sp(2)
	<min+?>: load.z32
	<min+?>: ceq.i32
	<min+?>: jz +16
	cmplStd/lib/math/Math.ci:211: (12 bytes): return .result := nan;
	<min+?>: load.f64 -nan
	<min+?>: set.x64 sp(5)
	<min+?>: ret
	cmplStd/lib/math/Math.ci:213: (3 bytes): result: float64 := values[0]
	<min+?>: dup.x32 sp(1)
	<min+?>: load.i64
	cmplStd/lib/math/Math.ci:214: (53 bytes): for (i: int32 := 1; i < (values.length); i := i + 1)
	<min+?>: load.c32 1
	<min+?>: jmp +35
	cmplStd/lib/math/Math.ci:215: (27 bytes): if (result > values[i])
	<min+?>: dup.x64 sp(1)
	<min+?>: dup.x32 sp(6)
	<min+?>: dup.x32 sp(3)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: cgt.f64
	<min+?>: jz +15
	cmplStd/lib/math/Math.ci:216: (11 bytes): result := values[i];
	<min+?>: dup.x32 sp(4)
	<min+?>: dup.x32 sp(1)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:214: (4 bytes): i := i + 1
	<min+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:214: (9 bytes): i < (values.length)
	<min+?>: dup.x32 sp(0)
	<min+?>: dup.x32 sp(6)
	<min+?>: clt.i32
	<min+?>: jnz -36
	<min+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:219: (3 bytes): return .result := result;
	<min+?>: set.x64 sp(5)
	<min+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:65: referenced as `min`
	cmplStd/test/math/test.Math.ci:64: referenced as `min`
}
Math.max(values: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:223'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (values.length == (0)) {
		return .result := nan;
	}
	result: float64 := values[0];
	for (i: int32 := 1; i < (values.length); i := i + 1) {
		if (result < values[i]) {
			result := values[i];
		}
	}
	return .result := result;
}
.instructions: (79 bytes)
	cmplStd/lib/math/Math.ci:224: (20 bytes): if (values.length == (0))
	<max>  : dup.x32 sp(2)
	<max+?>: load.z32
	<max+?>: ceq.i32
	<max+?>: jz +16
	cmplStd/lib/math/Math.ci:225: (12 bytes): return .result := nan;
	<max+?>: load.f64 -nan
	<max+?>: set.x64 sp(5)
	<max+?>: ret
	cmplStd/lib/math/Math.ci:227: (3 bytes): result: float64 := values[0]
	<max+?>: dup.x32 sp(1)
	<max+?>: load.i64
	cmplStd/lib/math/Math.ci:228: (53 bytes): for (i: int32 := 1; i < (values.length); i := i + 1)
	<max+?>: load.c32 1
	<max+?>: jmp +35
	cmplStd/lib/math/Math.ci:229: (27 bytes): if (result < values[i])
	<max+?>: dup.x64 sp(1)
	<max+?>: dup.x32 sp(6)
	<max+?>: dup.x32 sp(3)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: clt.f64
	<max+?>: jz +15
	cmplStd/lib/math/Math.ci:230: (11 bytes): result := values[i];
	<max+?>: dup.x32 sp(4)
	<max+?>: dup.x32 sp(1)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:228: (4 bytes): i := i + 1
	<max+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:228: (9 bytes): i < (values.length)
	<max+?>: dup.x32 sp(0)
	<max+?>: dup.x32 sp(6)
	<max+?>: clt.i32
	<max+?>: jnz -36
	<max+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:233: (3 bytes): return .result := result;
	<max+?>: set.x64 sp(5)
	<max+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:67: referenced as `max`
	cmplStd/test/math/test.Math.ci:66: referenced as `max`
}
Math.sum(values: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 40
.name: 'sum'
.file: 'cmplStd/lib/math/Math.ci:237'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; i < (values.length); i := i + 1) {
		result := result + values[i];
	}
	return .result := result;
}
.instructions: (40 bytes)
	cmplStd/lib/math/Math.ci:238: (1 byte): result: float64 := 0
	<sum>  : load.z128
	cmplStd/lib/math/Math.ci:239: (36 bytes): for (i: int32 := 0; i < (values.length); i := i + 1)
	<sum+?>: i64.2i32
	<sum+?>: jmp +22
	cmplStd/lib/math/Math.ci:240: (14 bytes): result := result + values[i];
	<sum+?>: dup.x64 sp(1)
	<sum+?>: dup.x32 sp(6)
	<sum+?>: dup.x32 sp(3)
	<sum+?>: mad.u32 8
	<sum+?>: load.i64
	<sum+?>: add.f64
	<sum+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:239: (4 bytes): i := i + 1
	<sum+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:239: (9 bytes): i < (values.length)
	<sum+?>: dup.x32 sp(0)
	<sum+?>: dup.x32 sp(6)
	<sum+?>: clt.i32
	<sum+?>: jnz -23
	<sum+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:242: (3 bytes): return .result := result;
	<sum+?>: set.x64 sp(5)
	<sum+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:72: referenced as `sum`
	cmplStd/test/math/test.Math.ci:71: referenced as `sum`
	cmplStd/test/math/test.Math.ci:70: referenced as `sum`
	cmplStd/test/math/test.Math.ci:69: referenced as `sum`
	cmplStd/lib/math/Math.ci:247: referenced as `sum`
}
Math.mean(values: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 20
.name: 'mean'
.file: 'cmplStd/lib/math/Math.ci:246'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the mean of the input values'
.value: {
	return .result := sum(...values) / (Bits.signed(values.length));
}
.instructions: (20 bytes)
	cmplStd/lib/math/Math.ci:247: (20 bytes): return .result := sum(...values) / (Bits.signed(values.length));
	<mean>  : load.z64
	<mean+?>: dup.x64 sp(3)
	<mean+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<mean+?>: call
	<mean+?>: inc.sp(-8)
	<mean+?>: dup.x32 sp(4)
	<mean+?>: i32.2f64
	<mean+?>: div.f64
	<mean+?>: set.x64 sp(5)
	<mean+?>: ret
.usages:
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:251'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0
.usages:
	cmplStd/test/math/test.Math.ci:76: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:254'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * a1
.usages:
	cmplStd/test/math/test.Math.ci:77: referenced as `eval`
	cmplStd/lib/math/Math.ci:257: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:257'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * eval(x, a1, a2)
.usages:
	cmplStd/test/math/test.Math.ci:78: referenced as `eval`
	cmplStd/lib/math/Math.ci:798: referenced as `eval`
	cmplStd/lib/math/Math.ci:513: referenced as `eval`
	cmplStd/lib/math/Math.ci:439: referenced as `eval`
	cmplStd/lib/math/Math.ci:260: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:260'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * eval(x, a1, a2, a3)
.usages:
	cmplStd/test/math/test.Math.ci:79: referenced as `eval`
	cmplStd/lib/math/Math.ci:741: referenced as `eval`
	cmplStd/lib/math/Math.ci:514: referenced as `eval`
	cmplStd/lib/math/Math.ci:438: referenced as `eval`
	cmplStd/lib/math/Math.ci:263: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64, a4: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:263'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.param a4: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * eval(x, a1, a2, a3, a4)
.usages:
	cmplStd/test/math/test.Math.ci:80: referenced as `eval`
	cmplStd/lib/math/Math.ci:842: referenced as `eval`
	cmplStd/lib/math/Math.ci:841: referenced as `eval`
	cmplStd/lib/math/Math.ci:798: referenced as `eval`
	cmplStd/lib/math/Math.ci:740: referenced as `eval`
	cmplStd/lib/math/Math.ci:266: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64, a4: float64, a5: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:266'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.param a4: float64 (size: 8, cast: f64)
.param a5: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * eval(x, a1, a2, a3, a4, a5)
.usages:
	cmplStd/test/math/test.Math.ci:81: referenced as `eval`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 47
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:269'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param polynomial: float64[] (size: 8, cast: variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
		result := result * x + polynomial[i];
	}
	return .result := result;
}
.instructions: (47 bytes)
	cmplStd/lib/math/Math.ci:270: (1 byte): result: float64 := 0
	<eval>  : load.z64
	cmplStd/lib/math/Math.ci:271: (43 bytes): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+?>: dup.x32 sp(4)
	<eval+?>: inc.i32(-1)
	<eval+?>: jmp +25
	cmplStd/lib/math/Math.ci:272: (17 bytes): result := result * x + polynomial[i];
	<eval+?>: dup.x64 sp(1)
	<eval+?>: dup.x64 sp(8)
	<eval+?>: mul.f64
	<eval+?>: dup.x32 sp(6)
	<eval+?>: dup.x32 sp(3)
	<eval+?>: mad.u32 8
	<eval+?>: load.i64
	<eval+?>: add.f64
	<eval+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:271: (4 bytes): i := i - 1
	<eval+?>: inc.i32(-1)
	cmplStd/lib/math/Math.ci:271: (8 bytes): i >= 0
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz -25
	<eval+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:274: (3 bytes): return .result := result;
	<eval+?>: set.x64 sp(7)
	<eval+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:75: referenced as `eval`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static function
.base: `function`
.size: 92
.name: 'modf'
.file: 'cmplStd/lib/math/Math.ci:278'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param intPart: float64 (size: 4, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (x < (1)) {
		if (x < (0)) {
			result: float64 := modf(-x, &intPart);
			intPart := -intPart;
			return .result := -result;
		}
		intPart := (0);
		return .result := x;
	}
	result: float64 := x % (1);
	intPart := x - result;
	return .result := result;
}
.instructions: (92 bytes)
	cmplStd/lib/math/Math.ci:279: (69 bytes): if (x < (1))
	<modf>  : dup.x64 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: clt.f64
	<modf+?>: jz +57
	cmplStd/lib/math/Math.ci:280: (45 bytes): if (x < (0))
	<modf+?>: dup.x64 sp(2)
	<modf+?>: load.z64
	<modf+?>: clt.f64
	<modf+?>: jz +41
	cmplStd/lib/math/Math.ci:281: (16 bytes): result: float64 := modf(-x, &intPart)
	<modf+?>: load.z64
	<modf+?>: dup.x64 sp(4)
	<modf+?>: neg.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<modf+?>: call
	<modf+?>: inc.sp(-12)
	cmplStd/lib/math/Math.ci:282: (7 bytes): intPart := -intPart;
	<modf+?>: dup.x32 sp(3)
	<modf+?>: load.i64
	<modf+?>: neg.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: store.i64
	cmplStd/lib/math/Math.ci:283: (10 bytes): return .result := -result;
	<modf+?>: dup.x64 sp(0)
	<modf+?>: neg.f64
	<modf+?>: set.x64 sp(8)
	<modf+?>: inc.sp(-8)
	<modf+?>: ret
	<modf+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:285: (4 bytes): intPart := (0);
	<modf+?>: load.z64
	<modf+?>: dup.x32 sp(3)
	<modf+?>: store.i64
	cmplStd/lib/math/Math.ci:286: (4 bytes): return .result := x;
	<modf+?>: mov.x64 sp(4, 2)
	<modf+?>: ret
	cmplStd/lib/math/Math.ci:288: (12 bytes): result: float64 := x % (1)
	<modf+?>: dup.x64 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: mod.f64
	cmplStd/lib/math/Math.ci:289: (8 bytes): intPart := x - result;
	<modf+?>: dup.x64 sp(4)
	<modf+?>: dup.x64 sp(2)
	<modf+?>: sub.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: store.i64
	cmplStd/lib/math/Math.ci:290: (3 bytes): return .result := result;
	<modf+?>: set.x64 sp(6)
	<modf+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:225: referenced as `modf`
	cmplStd/lib/text/Format.ci:197: referenced as `modf`
	cmplStd/lib/math/Math.ci:724: referenced as `modf`
	cmplStd/lib/math/Math.ci:720: referenced as `modf`
	cmplStd/lib/math/Math.ci:624: referenced as `modf`
	cmplStd/lib/math/Math.ci:281: referenced as `modf`
}
Math.copysign(x: float64, y: float64): float64: function {
.kind: static function
.base: `function`
.size: 49
.name: 'copysign'
.file: 'cmplStd/lib/math/Math.ci:293'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: {
	sign: uint64 := Bits.fromFloat64(y) & (1 << 63);
	val: uint64 := Bits.fromFloat64(x) & ~(1 << 63);
	return .result := Bits.asFloat64(sign | val);
}
.instructions: (49 bytes)
	cmplStd/lib/math/Math.ci:294: (18 bytes): sign: uint64 := Bits.fromFloat64(y) & (1 << 63)
	<copysign>  : dup.x64 sp(1)
	<copysign+?>: load.c64 1
	<copysign+?>: load.c32 63
	<copysign+?>: shl.b64
	<copysign+?>: and.b64
	cmplStd/lib/math/Math.ci:295: (19 bytes): val: uint64 := Bits.fromFloat64(x) & ~(1 << 63)
	<copysign+?>: dup.x64 sp(5)
	<copysign+?>: load.c64 1
	<copysign+?>: load.c32 63
	<copysign+?>: shl.b64
	<copysign+?>: cmt.b64
	<copysign+?>: and.b64
	cmplStd/lib/math/Math.ci:296: (12 bytes): return .result := Bits.asFloat64(sign | val);
	<copysign+?>: dup.x64 sp(2)
	<copysign+?>: dup.x64 sp(2)
	<copysign+?>: or.b64
	<copysign+?>: set.x64 sp(11)
	<copysign+?>: inc.sp(-16)
	<copysign+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:382: referenced as `copysign`
	cmplStd/lib/math/Math.ci:378: referenced as `copysign`
}
Math.frexp(f: float64, exp: int32): float64: function {
.kind: static function
.base: `function`
.size: 236
.name: 'frexp'
.file: 'cmplStd/lib/math/Math.ci:309'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param f: float64 (size: 8, cast: variable(f64))
.param exp: int32 (size: 4, cast: variable(ref))
.value: {
	mask: typename := 2047;
	shift: typename := 64 - 11 - 1;
	bias: typename := 1023;
	signMask: typename := 1 << 63;
	fracMask: typename := 1 << shift - 1;
	if (f == (0)) {
		exp := 0;
		return .result := f;
	}
	if (isInf(f) || isNan(f)) {
		exp := 0;
		return .result := f;
	}
	if (abs(f) < smallestNormal) {
		f := f * (1 << 52);
		exp := exp - 52;
	}
	else {
		exp := 0;
	}
	x: uint64 := Bits.fromFloat64(f);
	exp := exp + int32((x >> shift) & mask) - bias + 1;
	x := x & ~(mask << shift);
	x := x | (-1 + (bias)) << shift;
	return .result := Bits.asFloat64(x);
}
.instructions: (236 bytes)
	cmplStd/lib/math/Math.ci:317: (16 bytes): if (f == (0))
	<frexp>  : dup.x64 sp(2)
	<frexp+?>: load.z64
	<frexp+?>: ceq.f64
	<frexp+?>: jz +12
	cmplStd/lib/math/Math.ci:318: (4 bytes): exp := 0;
	<frexp+?>: load.z32
	<frexp+?>: dup.x32 sp(2)
	<frexp+?>: store.i32
	cmplStd/lib/math/Math.ci:319: (4 bytes): return .result := f;
	<frexp+?>: mov.x64 sp(4, 2)
	<frexp+?>: ret
	cmplStd/lib/math/Math.ci:321: (48 bytes): if (isInf(f) || isNan(f))
	<frexp+?>: load.z32
	<frexp+?>: dup.x64 sp(3)
	<frexp+?>: load.ref <?> ;Math.isInf(x: float64): bool
	<frexp+?>: call
	<frexp+?>: inc.sp(-8)
	<frexp+?>: dup.x32 sp(0)
	<frexp+?>: jnz +21
	<frexp+?>: inc.sp(-4)
	<frexp+?>: load.z32
	<frexp+?>: dup.x64 sp(3)
	<frexp+?>: load.ref <?> ;Math.isNan(x: float64): bool
	<frexp+?>: call
	<frexp+?>: inc.sp(-8)
	<frexp+?>: jz +12
	cmplStd/lib/math/Math.ci:322: (4 bytes): exp := 0;
	<frexp+?>: load.z32
	<frexp+?>: dup.x32 sp(2)
	<frexp+?>: store.i32
	cmplStd/lib/math/Math.ci:323: (4 bytes): return .result := f;
	<frexp+?>: mov.x64 sp(4, 2)
	<frexp+?>: ret
	cmplStd/lib/math/Math.ci:326: (66 bytes): if (abs(f) < smallestNormal)
	<frexp+?>: dup.x64 sp(2)
	<frexp+?>: dup.x64 sp(0)
	<frexp+?>: load.z64
	<frexp+?>: clt.f64
	<frexp+?>: jz +11
	<frexp+?>: dup.x64 sp(0)
	<frexp+?>: neg.f64
	<frexp+?>: jmp +6
	<frexp+?>: dup.x64 sp(0)
	<frexp+?>: set.x64 sp(2)
	<frexp+?>: load.f64 0.000000
	<frexp+?>: clt.f64
	<frexp+?>: jz +31
	cmplStd/lib/math/Math.ci:328: (13 bytes): f := f * (1 << 52);
	<frexp+?>: dup.x64 sp(2)
	<frexp+?>: load.c32 1
	<frexp+?>: b32.shl 0x34
	<frexp+?>: i32.2f64
	<frexp+?>: mul.f64
	<frexp+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:329: (10 bytes): exp := exp - 52;
	<frexp+?>: dup.x32 sp(1)
	<frexp+?>: load.i32
	<frexp+?>: inc.i32(-52)
	<frexp+?>: dup.x32 sp(2)
	<frexp+?>: store.i32
	<frexp+?>: jmp +8
	cmplStd/lib/math/Math.ci:331: (4 bytes): exp := 0;
	<frexp+?>: load.z32
	<frexp+?>: dup.x32 sp(2)
	<frexp+?>: store.i32
	cmplStd/lib/math/Math.ci:334: (2 bytes): x: uint64 := Bits.fromFloat64(f)
	<frexp+?>: dup.x64 sp(2)
	cmplStd/lib/math/Math.ci:335: (42 bytes): exp := exp + int32((x >> shift) & mask) - bias + 1;
	<frexp+?>: dup.x32 sp(3)
	<frexp+?>: load.i32
	<frexp+?>: dup.x64 sp(1)
	<frexp+?>: load.c32 64
	<frexp+?>: inc.i32(-11)
	<frexp+?>: inc.i32(-1)
	<frexp+?>: shr.b64
	<frexp+?>: load.c64 2047
	<frexp+?>: and.b64
	<frexp+?>: i64.2i32
	<frexp+?>: inc.i32(-1023)
	<frexp+?>: inc.i32(+1)
	<frexp+?>: add.i32
	<frexp+?>: dup.x32 sp(4)
	<frexp+?>: store.i32
	cmplStd/lib/math/Math.ci:336: (25 bytes): x := x & ~(mask << shift);
	<frexp+?>: load.c64 2047
	<frexp+?>: load.c32 64
	<frexp+?>: inc.i32(-11)
	<frexp+?>: inc.i32(-1)
	<frexp+?>: shl.b64
	<frexp+?>: cmt.b64
	<frexp+?>: and.b64
	cmplStd/lib/math/Math.ci:337: (34 bytes): x := x | (-1 + (bias)) << shift;
	<frexp+?>: load.c64 -1
	<frexp+?>: load.c64 1023
	<frexp+?>: add.i64
	<frexp+?>: load.c32 64
	<frexp+?>: inc.i32(-11)
	<frexp+?>: inc.i32(-1)
	<frexp+?>: shl.b64
	<frexp+?>: or.b64
	cmplStd/lib/math/Math.ci:338: (3 bytes): return .result := Bits.asFloat64(x);
	<frexp+?>: set.x64 sp(6)
	<frexp+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:658: referenced as `frexp`
	cmplStd/lib/math/Math.ci:426: referenced as `frexp`
}
Math.ldexp(f: float64, exp: int32): float64: function {
.kind: static function
.base: `function`
.size: 336
.name: 'ldexp'
.file: 'cmplStd/lib/math/Math.ci:350'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param f: float64 (size: 8, cast: variable(f64))
.param exp: int32 (size: 4, cast: variable(i32))
.value: {
	mask: typename := 2047;
	shift: typename := 64 - 11 - 1;
	bias: typename := 1023;
	signMask: typename := 1 << 63;
	fracMask: typename := 1 << shift - 1;
	if (f == (0)) {
		return .result := f;
	}
	if (f != f || f - f != (0)) {
		return .result := f;
	}
	if (abs(f) < smallestNormal) {
		f := f * (1 << 52);
		exp := exp - 52;
	}
	x: uint64 := Bits.fromFloat64(f);
	exp := ((exp) + ((int32(x >> shift)) & mask) - (bias));
	if (exp < -1075) {
		return .result := copysign(0.000000, f);
	}
	if (exp > 1023) {
		return .result := copysign(inf, f);
	}
	m: float64 := 1;
	if (exp < -1022) {
		exp := exp + 53;
		m := (1) / float64(1 << 53);
	}
	x := x & ~(mask << shift);
	x := x | uint64(exp + bias) << shift;
	return .result := m * Bits.asFloat64(x);
}
.instructions: (336 bytes)
	cmplStd/lib/math/Math.ci:358: (12 bytes): if (f == (0))
	<ldexp>  : dup.x64 sp(2)
	<ldexp+?>: load.z64
	<ldexp+?>: ceq.f64
	<ldexp+?>: jz +8
	cmplStd/lib/math/Math.ci:360: (4 bytes): return .result := f;
	<ldexp+?>: mov.x64 sp(4, 2)
	<ldexp+?>: ret
	cmplStd/lib/math/Math.ci:362: (32 bytes): if (f != f || f - f != (0))
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: dup.x64 sp(4)
	<ldexp+?>: ceq.f64
	<ldexp+?>: not.b32
	<ldexp+?>: dup.x32 sp(0)
	<ldexp+?>: jnz +16
	<ldexp+?>: inc.sp(-4)
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: dup.x64 sp(4)
	<ldexp+?>: sub.f64
	<ldexp+?>: load.z64
	<ldexp+?>: ceq.f64
	<ldexp+?>: not.b32
	<ldexp+?>: jz +8
	cmplStd/lib/math/Math.ci:364: (4 bytes): return .result := f;
	<ldexp+?>: mov.x64 sp(4, 2)
	<ldexp+?>: ret
	cmplStd/lib/math/Math.ci:367: (56 bytes): if (abs(f) < smallestNormal)
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: dup.x64 sp(0)
	<ldexp+?>: load.z64
	<ldexp+?>: clt.f64
	<ldexp+?>: jz +11
	<ldexp+?>: dup.x64 sp(0)
	<ldexp+?>: neg.f64
	<ldexp+?>: jmp +6
	<ldexp+?>: dup.x64 sp(0)
	<ldexp+?>: set.x64 sp(2)
	<ldexp+?>: load.f64 0.000000
	<ldexp+?>: clt.f64
	<ldexp+?>: jz +25
	cmplStd/lib/math/Math.ci:369: (13 bytes): f := f * (1 << 52);
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: load.c32 1
	<ldexp+?>: b32.shl 0x34
	<ldexp+?>: i32.2f64
	<ldexp+?>: mul.f64
	<ldexp+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:370: (8 bytes): exp := exp - 52;
	<ldexp+?>: dup.x32 sp(1)
	<ldexp+?>: inc.i32(-52)
	<ldexp+?>: set.x32 sp(2)
	cmplStd/lib/math/Math.ci:373: (2 bytes): x: uint64 := Bits.fromFloat64(f)
	<ldexp+?>: dup.x64 sp(2)
	cmplStd/lib/math/Math.ci:374: (45 bytes): exp := ((exp) + ((int32(x >> shift)) & mask) - (bias));
	<ldexp+?>: dup.x32 sp(3)
	<ldexp+?>: i32.2i64
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: load.c32 64
	<ldexp+?>: inc.i32(-11)
	<ldexp+?>: inc.i32(-1)
	<ldexp+?>: shr.b64
	<ldexp+?>: i64.2i32
	<ldexp+?>: i32.2i64
	<ldexp+?>: load.c64 2047
	<ldexp+?>: and.b64
	<ldexp+?>: load.c64 1023
	<ldexp+?>: sub.i64
	<ldexp+?>: add.i64
	<ldexp+?>: i64.2i32
	<ldexp+?>: set.x32 sp(4)
	cmplStd/lib/math/Math.ci:376: (32 bytes): if (exp < -1075)
	<ldexp+?>: dup.x32 sp(3)
	<ldexp+?>: load.c32 -1075
	<ldexp+?>: clt.i32
	<ldexp+?>: jz +24
	cmplStd/lib/math/Math.ci:378: (20 bytes): return .result := copysign(0.000000, f);
	<ldexp+?>: load.z128
	<ldexp+?>: dup.x64 sp(8)
	<ldexp+?>: load.ref <?> ;Math.copysign(x: float64, y: float64): float64
	<ldexp+?>: call
	<ldexp+?>: inc.sp(-16)
	<ldexp+?>: set.x64 sp(8)
	<ldexp+?>: inc.sp(-8)
	<ldexp+?>: ret
	cmplStd/lib/math/Math.ci:380: (41 bytes): if (exp > 1023)
	<ldexp+?>: dup.x32 sp(3)
	<ldexp+?>: load.c32 1023
	<ldexp+?>: cgt.i32
	<ldexp+?>: jz +33
	cmplStd/lib/math/Math.ci:382: (29 bytes): return .result := copysign(inf, f);
	<ldexp+?>: load.z64
	<ldexp+?>: load.f64 inf
	<ldexp+?>: dup.x64 sp(8)
	<ldexp+?>: load.ref <?> ;Math.copysign(x: float64, y: float64): float64
	<ldexp+?>: call
	<ldexp+?>: inc.sp(-16)
	<ldexp+?>: set.x64 sp(8)
	<ldexp+?>: inc.sp(-8)
	<ldexp+?>: ret
	cmplStd/lib/math/Math.ci:384: (9 bytes): m: float64 := 1
	<ldexp+?>: load.f64 1.000000
	cmplStd/lib/math/Math.ci:385: (40 bytes): if (exp < -1022)
	<ldexp+?>: dup.x32 sp(5)
	<ldexp+?>: load.c32 -1022
	<ldexp+?>: clt.i32
	<ldexp+?>: jz +32
	cmplStd/lib/math/Math.ci:387: (8 bytes): exp := exp + 53;
	<ldexp+?>: dup.x32 sp(5)
	<ldexp+?>: inc.i32(+53)
	<ldexp+?>: set.x32 sp(6)
	cmplStd/lib/math/Math.ci:388: (20 bytes): m := (1) / float64(1 << 53);
	<ldexp+?>: load.f64 1.000000
	<ldexp+?>: load.c32 1
	<ldexp+?>: b32.shl 0x35
	<ldexp+?>: i32.2f64
	<ldexp+?>: div.f64
	<ldexp+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:390: (29 bytes): x := x & ~(mask << shift);
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: load.c64 2047
	<ldexp+?>: load.c32 64
	<ldexp+?>: inc.i32(-11)
	<ldexp+?>: inc.i32(-1)
	<ldexp+?>: shl.b64
	<ldexp+?>: cmt.b64
	<ldexp+?>: and.b64
	<ldexp+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:391: (26 bytes): x := x | uint64(exp + bias) << shift;
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: dup.x32 sp(7)
	<ldexp+?>: inc.i32(+1023)
	<ldexp+?>: i32.2i64
	<ldexp+?>: load.c32 64
	<ldexp+?>: inc.i32(-11)
	<ldexp+?>: inc.i32(-1)
	<ldexp+?>: shl.b64
	<ldexp+?>: or.b64
	<ldexp+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:392: (12 bytes): return .result := m * Bits.asFloat64(x);
	<ldexp+?>: dup.x64 sp(0)
	<ldexp+?>: dup.x64 sp(4)
	<ldexp+?>: mul.f64
	<ldexp+?>: set.x64 sp(10)
	<ldexp+?>: inc.sp(-16)
	<ldexp+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:783: referenced as `ldexp`
	cmplStd/lib/math/Math.ci:781: referenced as `ldexp`
	cmplStd/lib/math/Math.ci:683: referenced as `ldexp`
	cmplStd/lib/math/Math.ci:517: referenced as `ldexp`
}
Math.log(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 298
.name: 'log'
.file: 'cmplStd/lib/math/Math.ci:397'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the natural logarithm of the argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.log)) != null) {
		return .result := float64.log(x);
	}
	if (x <= (0)) {
		if (x == (0)) {
			return .result := -inf;
		}
		return .result := nan;
	}
	exp: int32;
	x := frexp(x, &exp);
	for ( ; x < 0.500000; ) {
		x := x * (2);
		exp := exp - 1;
	}
	if (x < sqrto2) {
		x := x * (2);
		exp := exp - 1;
	}
	z: float64 := (x - (1)) / (x + (1));
	zsq: float64 := z * z;
	p: float64 := eval(zsq, p0, p1, p2, p3);
	q: float64 := eval(zsq, q0, q1, q2 + zsq);
	return .result := p / q * z + (exp) * log2;
}
.instructions: (298 bytes)
	cmplStd/lib/math/Math.ci:400: (9 bytes): return .result := float64.log(x);
	<log>  : dup.x64 sp(1)
	<log+?>: nfc(45) ;float64.log(x: float64): float64
	<log+?>: set.x64 sp(5)
	<log+?>: ret
	cmplStd/lib/math/Math.ci:418: (40 bytes): if (x <= (0))
	<log+?>: dup.x64 sp(1)
	<log+?>: load.z64
	<log+?>: cgt.f64
	<log+?>: jnz +36
	cmplStd/lib/math/Math.ci:419: (20 bytes): if (x == (0))
	<log+?>: dup.x64 sp(1)
	<log+?>: load.z64
	<log+?>: ceq.f64
	<log+?>: jz +16
	cmplStd/lib/math/Math.ci:420: (12 bytes): return .result := -inf;
	<log+?>: load.f64 -inf
	<log+?>: set.x64 sp(5)
	<log+?>: ret
	cmplStd/lib/math/Math.ci:422: (12 bytes): return .result := nan;
	<log+?>: load.f64 -nan
	<log+?>: set.x64 sp(5)
	<log+?>: ret
	cmplStd/lib/math/Math.ci:425: (1 byte): exp: int32
	<log+?>: load.z32
	cmplStd/lib/math/Math.ci:426: (19 bytes): x := frexp(x, &exp);
	<log+?>: load.z64
	<log+?>: dup.x64 sp(4)
	<log+?>: load.sp(+16)
	<log+?>: load.ref <?> ;Math.frexp(f: float64, exp: int32): float64
	<log+?>: call
	<log+?>: inc.sp(-12)
	<log+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:427: (38 bytes): for ( ; x < 0.500000; )
	<log+?>: jmp +22
	cmplStd/lib/math/Math.ci:428: (14 bytes): x := x * (2);
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 2.000000
	<log+?>: mul.f64
	<log+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:429: (4 bytes): exp := exp - 1;
	<log+?>: inc.i32(-1)
	cmplStd/lib/math/Math.ci:427: (16 bytes): x < 0.500000
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 0.500000
	<log+?>: clt.f64
	<log+?>: jnz -30
	cmplStd/lib/math/Math.ci:431: (34 bytes): if (x < sqrto2)
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 0.707107
	<log+?>: clt.f64
	<log+?>: jz +22
	cmplStd/lib/math/Math.ci:432: (14 bytes): x := x * (2);
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 2.000000
	<log+?>: mul.f64
	<log+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:433: (4 bytes): exp := exp - 1;
	<log+?>: inc.i32(-1)
	cmplStd/lib/math/Math.ci:436: (25 bytes): z: float64 := (x - (1)) / (x + (1))
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 1.000000
	<log+?>: sub.f64
	<log+?>: dup.x64 sp(4)
	<log+?>: load.f64 1.000000
	<log+?>: add.f64
	<log+?>: div.f64
	cmplStd/lib/math/Math.ci:437: (5 bytes): zsq: float64 := z * z
	<log+?>: dup.x64 sp(0)
	<log+?>: dup.x64 sp(2)
	<log+?>: mul.f64
	cmplStd/lib/math/Math.ci:438: (56 bytes): p: float64 := eval(zsq, p0, p1, p2, p3)
	<log+?>: dup.x64 sp(0)
	<log+?>: load.f64 -24.013918
	<log+?>: dup.x64 sp(2)
	<log+?>: dup.x64 sp(4)
	<log+?>: load.f64 30.957293
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 -9.637691
	<log+?>: dup.x64 sp(6)
	<log+?>: load.f64 0.421087
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: set.x64 sp(2)
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:439: (42 bytes): q: float64 := eval(zsq, q0, q1, q2 + zsq)
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 -12.006959
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 19.480966
	<log+?>: dup.x64 sp(6)
	<log+?>: load.f64 -8.911109
	<log+?>: dup.x64 sp(14)
	<log+?>: add.f64
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:440: (29 bytes): return .result := p / q * z + (exp) * log2;
	<log+?>: dup.x64 sp(2)
	<log+?>: dup.x64 sp(2)
	<log+?>: div.f64
	<log+?>: dup.x64 sp(8)
	<log+?>: mul.f64
	<log+?>: dup.x32 sp(10)
	<log+?>: i32.2f64
	<log+?>: load.f64 0.693147
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: set.x64 sp(14)
	<log+?>: inc.sp(-36)
	<log+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:40: referenced as `log`
	cmplStd/lib/math/Complex.ci:105: referenced as `log`
	cmplStd/lib/math/Complex.ci:99: referenced as `log`
	cmplStd/lib/math/Math.ci:1047: referenced as `log`
	cmplStd/lib/math/Math.ci:1047: referenced as `log`
	cmplStd/lib/math/Math.ci:1034: referenced as `log`
	cmplStd/lib/math/Math.ci:1021: referenced as `log`
	cmplStd/lib/math/Math.ci:998: referenced as `log`
	cmplStd/lib/math/Math.ci:959: referenced as `log`
	cmplStd/lib/math/Math.ci:926: referenced as `log`
	cmplStd/lib/math/Math.ci:654: referenced as `log`
	cmplStd/lib/math/Math.ci:636: referenced as `log`
	cmplStd/lib/math/Math.ci:460: referenced as `log`
	cmplStd/lib/math/Math.ci:460: referenced as `log`
	cmplStd/lib/math/Math.ci:457: referenced as `log`
	cmplStd/lib/math/Math.ci:454: referenced as `log`
	cmplStd/lib/math/Math.ci:450: referenced as `log`
}
Math.log(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'log'
.file: 'cmplStd/lib/math/Math.ci:444'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the natural logarithm of the argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.log)) != null) {
		return .result := float32.log(x);
	}
	return .result := float32(log(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:447: (9 bytes): return .result := float32.log(x);
	<log>  : dup.x32 sp(1)
	<log+?>: nfc(37) ;float32.log(x: float32): float32
	<log+?>: set.x32 sp(3)
	<log+?>: ret
	cmplStd/lib/math/Math.ci:450: (18 bytes): return .result := float32(log(float64(x)));
	<log+?>: load.z64
	<log+?>: dup.x32 sp(3)
	<log+?>: f32.2f64
	<log+?>: load.ref <?> ;Math.log(x: float64): float64
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: f64.2f32
	<log+?>: set.x32 sp(3)
	<log+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:49: referenced as `log`
}
Math.log2(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'log2'
.file: 'cmplStd/lib/math/Math.ci:454'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the base 2 logarithm of the argument `x`.'
.value: log(x) / ln2
.usages:
}
Math.log10(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'log10'
.file: 'cmplStd/lib/math/Math.ci:457'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the base 10 logarithm of the argument `x`.'
.value: log(x) / ln10
.usages:
}
Math.log(x: float64, base: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'log'
.file: 'cmplStd/lib/math/Math.ci:460'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param base: float64 (size: 8, cast: f64)
.doc: 'Returns the logarithm of the specified `base` of the argument `x`.'
.value: log(x) / log(base)
.usages:
}
Math.exp(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 297
.name: 'exp'
.file: 'cmplStd/lib/math/Math.ci:465'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the base-e exponential: $ e^x $.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.exp)) != null) {
		return .result := float64.exp(x);
	}
	if (isNan(x)) {
		return .result := x;
	}
	if (x > MAXLOG) {
		return .result := inf;
	}
	if (x < MINLOG) {
		return .result := 0;
	}
	px: float64 := floor(LOG2E * x + 0.500000);
	x := x - px * c1;
	x := x - px * c2;
	xx: float64 := x * x;
	p: float64 := x * eval(xx, p2, p1, p0);
	q: float64 := eval(xx, q3, q2, q1, q0);
	return .result := ldexp((1) + (2) * p / (q - p), px);
}
.instructions: (297 bytes)
	cmplStd/lib/math/Math.ci:468: (9 bytes): return .result := float64.exp(x);
	<exp>  : dup.x64 sp(1)
	<exp+?>: nfc(46) ;float64.exp(x: float64): float64
	<exp+?>: set.x64 sp(5)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:489: (21 bytes): if (isNan(x))
	<exp+?>: load.z32
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.ref <?> ;Math.isNan(x: float64): bool
	<exp+?>: call
	<exp+?>: inc.sp(-8)
	<exp+?>: jz +8
	cmplStd/lib/math/Math.ci:490: (4 bytes): return .result := x;
	<exp+?>: mov.x64 sp(3, 1)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:492: (28 bytes): if (x > MAXLOG)
	<exp+?>: dup.x64 sp(1)
	<exp+?>: load.f64 708.396419
	<exp+?>: cgt.f64
	<exp+?>: jz +16
	cmplStd/lib/math/Math.ci:493: (12 bytes): return .result := inf;
	<exp+?>: load.f64 inf
	<exp+?>: set.x64 sp(5)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:496: (20 bytes): if (x < MINLOG)
	<exp+?>: dup.x64 sp(1)
	<exp+?>: load.f64 -708.396419
	<exp+?>: clt.f64
	<exp+?>: jz +8
	cmplStd/lib/math/Math.ci:497: (4 bytes): return .result := 0;
	<exp+?>: load.z64
	<exp+?>: set.x64 sp(5)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:505: (33 bytes): px: float64 := floor(LOG2E * x + 0.500000)
	<exp+?>: load.z64
	<exp+?>: load.f64 1.442695
	<exp+?>: dup.x64 sp(5)
	<exp+?>: mul.f64
	<exp+?>: load.f64 0.500000
	<exp+?>: add.f64
	<exp+?>: load.ref <?> ;Math.floor(x: float64): float64
	<exp+?>: call
	<exp+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:506: (17 bytes): x := x - px * c1;
	<exp+?>: dup.x64 sp(3)
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 0.693146
	<exp+?>: mul.f64
	<exp+?>: sub.f64
	<exp+?>: set.x64 sp(5)
	cmplStd/lib/math/Math.ci:507: (17 bytes): x := x - px * c2;
	<exp+?>: dup.x64 sp(3)
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 0.000001
	<exp+?>: mul.f64
	<exp+?>: sub.f64
	<exp+?>: set.x64 sp(5)
	cmplStd/lib/math/Math.ci:512: (5 bytes): xx: float64 := x * x
	<exp+?>: dup.x64 sp(3)
	<exp+?>: dup.x64 sp(5)
	<exp+?>: mul.f64
	cmplStd/lib/math/Math.ci:513: (42 bytes): p: float64 := x * eval(xx, p2, p1, p0)
	<exp+?>: dup.x64 sp(5)
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 1.000000
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 0.030299
	<exp+?>: dup.x64 sp(6)
	<exp+?>: load.f64 0.000126
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: set.x64 sp(2)
	<exp+?>: mul.f64
	cmplStd/lib/math/Math.ci:514: (56 bytes): q: float64 := eval(xx, q3, q2, q1, q0)
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 2.000000
	<exp+?>: dup.x64 sp(2)
	<exp+?>: dup.x64 sp(4)
	<exp+?>: load.f64 0.227266
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 0.002524
	<exp+?>: dup.x64 sp(6)
	<exp+?>: load.f64 0.000003
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: set.x64 sp(2)
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:517: (49 bytes): return .result := ldexp((1) + (2) * p / (q - p), px);
	<exp+?>: load.z64
	<exp+?>: load.f64 1.000000
	<exp+?>: load.f64 2.000000
	<exp+?>: dup.x64 sp(8)
	<exp+?>: mul.f64
	<exp+?>: dup.x64 sp(6)
	<exp+?>: dup.x64 sp(10)
	<exp+?>: sub.f64
	<exp+?>: div.f64
	<exp+?>: add.f64
	<exp+?>: dup.x64 sp(10)
	<exp+?>: f64.2i32
	<exp+?>: load.ref <?> ;Math.ldexp(f: float64, exp: int32): float64
	<exp+?>: call
	<exp+?>: inc.sp(-12)
	<exp+?>: set.x64 sp(13)
	<exp+?>: inc.sp(-32)
	<exp+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:41: referenced as `exp`
	cmplGfx/lib/image.blur.ci:21: referenced as `exp`
	cmplStd/lib/math/Complex.ci:106: referenced as `exp`
	cmplStd/lib/math/Complex.ci:96: referenced as `exp`
	cmplStd/lib/math/Complex.ci:96: referenced as `exp`
	cmplStd/lib/math/Math.ci:995: referenced as `exp`
	cmplStd/lib/math/Math.ci:953: referenced as `exp`
	cmplStd/lib/math/Math.ci:953: referenced as `exp`
	cmplStd/lib/math/Math.ci:920: referenced as `exp`
	cmplStd/lib/math/Math.ci:920: referenced as `exp`
	cmplStd/lib/math/Math.ci:654: referenced as `exp`
	cmplStd/lib/math/Math.ci:636: referenced as `exp`
	cmplStd/lib/math/Math.ci:527: referenced as `exp`
}
Math.exp(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'exp'
.file: 'cmplStd/lib/math/Math.ci:521'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the base-e exponential: $ e^x $.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.exp)) != null) {
		return .result := float32.exp(x);
	}
	return .result := float32(exp(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:524: (9 bytes): return .result := float32.exp(x);
	<exp>  : dup.x32 sp(1)
	<exp+?>: nfc(38) ;float32.exp(x: float32): float32
	<exp+?>: set.x32 sp(3)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:527: (18 bytes): return .result := float32(exp(float64(x)));
	<exp+?>: load.z64
	<exp+?>: dup.x32 sp(3)
	<exp+?>: f32.2f64
	<exp+?>: load.ref <?> ;Math.exp(x: float64): float64
	<exp+?>: call
	<exp+?>: inc.sp(-8)
	<exp+?>: f64.2f32
	<exp+?>: set.x32 sp(3)
	<exp+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:50: referenced as `exp`
}
Math.sqrt(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 448
.name: 'sqrt'
.file: 'cmplStd/lib/math/Math.ci:532'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the square root of the parameter `x`: $\sqrt{x}$.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.sqrt)) != null) {
		return .result := float64.sqrt(x);
	}
	if (x == (0) || isNan(x) || isInf(x, 1)) {
		return .result := x;
	}
	if (x < (0)) {
		return .result := nan;
	}
	mask: typename := 2047;
	shift: typename := 64 - 11 - 1;
	bias: typename := 1023;
	ix: uint64 := Bits.fromFloat64(x);
	exp: int32 := int32((ix >> shift) & mask);
	if (exp == 0) {
		for ( ; (ix & (1 << shift)) == (0); ) {
			ix := ix << 1;
			exp := exp - 1;
		}
		exp := exp + 1;
	}
	exp := exp - bias;
	ix := ix & ~(mask << shift);
	ix := ix | 1 << shift;
	if ((exp & 1) == 1) {
		ix := ix << 1;
	}
	exp := exp >> 1;
	ix := ix << 1;
	s: uint64 := 0;
	q: uint64 := 0;
	r: uint64 := 1 << (shift + 1);
	for ( ; r != (0); ) {
		t: uint64 := s + r;
		if (t <= ix) {
			s := t + r;
			ix := ix - t;
			q := q + r;
		}
		ix := ix << 1;
		r := r >> 1;
	}
	if (ix != (0)) {
		q := q + (q & (1));
	}
	ix := (q >> 1) + (uint64(exp - 1 + bias) << shift);
	return .result := Bits.asFloat64(ix);
}
.instructions: (448 bytes)
	cmplStd/lib/math/Math.ci:535: (9 bytes): return .result := float64.sqrt(x);
	<sqrt>  : dup.x64 sp(1)
	<sqrt+?>: nfc(48) ;float64.sqrt(x: float64): float64
	<sqrt+?>: set.x64 sp(5)
	<sqrt+?>: ret
	cmplStd/lib/math/Math.ci:544: (63 bytes): if (x == (0) || isNan(x) || isInf(x, 1))
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.z64
	<sqrt+?>: ceq.f64
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: jnz +21
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: load.z32
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: load.ref <?> ;Math.isNan(x: float64): bool
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-8)
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: jnz +26
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: load.z32
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: load.c32 1
	<sqrt+?>: load.ref <?> ;Math.isInf(x: float64, sign: int32): bool
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-12)
	<sqrt+?>: jz +8
	cmplStd/lib/math/Math.ci:545: (4 bytes): return .result := x;
	<sqrt+?>: mov.x64 sp(3, 1)
	<sqrt+?>: ret
	cmplStd/lib/math/Math.ci:547: (20 bytes): if (x < (0))
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.z64
	<sqrt+?>: clt.f64
	<sqrt+?>: jz +16
	cmplStd/lib/math/Math.ci:548: (12 bytes): return .result := nan;
	<sqrt+?>: load.f64 -nan
	<sqrt+?>: set.x64 sp(5)
	<sqrt+?>: ret
	cmplStd/lib/math/Math.ci:555: (2 bytes): ix: uint64 := Bits.fromFloat64(x)
	<sqrt+?>: dup.x64 sp(1)
	cmplStd/lib/math/Math.ci:557: (27 bytes): exp: int32 := int32((ix >> shift) & mask)
	<sqrt+?>: dup.x64 sp(0)
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shr.b64
	<sqrt+?>: load.c64 2047
	<sqrt+?>: and.b64
	<sqrt+?>: i64.2i32
	cmplStd/lib/math/Math.ci:558: (62 bytes): if (exp == 0)
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: load.z32
	<sqrt+?>: ceq.i32
	<sqrt+?>: jz +58
	cmplStd/lib/math/Math.ci:559: (50 bytes): for ( ; (ix & (1 << shift)) == (0); )
	<sqrt+?>: jmp +18
	cmplStd/lib/math/Math.ci:560: (10 bytes): ix := ix << 1;
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shl.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:561: (4 bytes): exp := exp - 1;
	<sqrt+?>: inc.i32(-1)
	cmplStd/lib/math/Math.ci:559: (32 bytes): (ix & (1 << shift)) == (0)
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c64 1
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shl.b64
	<sqrt+?>: and.b64
	<sqrt+?>: load.z64
	<sqrt+?>: ceq.i64
	<sqrt+?>: jnz -42
	cmplStd/lib/math/Math.ci:563: (4 bytes): exp := exp + 1;
	<sqrt+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:565: (4 bytes): exp := exp - bias;
	<sqrt+?>: inc.i32(-1023)
	cmplStd/lib/math/Math.ci:566: (29 bytes): ix := ix & ~(mask << shift);
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c64 2047
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shl.b64
	<sqrt+?>: cmt.b64
	<sqrt+?>: and.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:567: (28 bytes): ix := ix | 1 << shift;
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c64 1
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shl.b64
	<sqrt+?>: or.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:568: (24 bytes): if ((exp & 1) == 1)
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: b32.and 0x01
	<sqrt+?>: load.c32 1
	<sqrt+?>: ceq.i32
	<sqrt+?>: jz +14
	cmplStd/lib/math/Math.ci:569: (10 bytes): ix := ix << 1;
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shl.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:571: (2 bytes): exp := exp >> 1;
	<sqrt+?>: b32.sar 0x01
	cmplStd/lib/math/Math.ci:573: (10 bytes): ix := ix << 1;
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shl.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:574: (1 byte): s: uint64 := 0
	<sqrt+?>: load.z128
	cmplStd/lib/math/Math.ci:576: (27 bytes): r: uint64 := 1 << (shift + 1)
	<sqrt+?>: load.c64 1
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: inc.i32(+1)
	<sqrt+?>: shl.b64
	cmplStd/lib/math/Math.ci:577: (71 bytes): for ( ; r != (0); )
	<sqrt+?>: jmp +63
	cmplStd/lib/math/Math.ci:578: (5 bytes): t: uint64 := s + r
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: add.i64
	cmplStd/lib/math/Math.ci:579: (30 bytes): if (t <= ix)
	<sqrt+?>: dup.x64 sp(0)
	<sqrt+?>: dup.x64 sp(11)
	<sqrt+?>: cgt.u64
	<sqrt+?>: jnz +25
	cmplStd/lib/math/Math.ci:580: (7 bytes): s := t + r;
	<sqrt+?>: dup.x64 sp(0)
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: add.i64
	<sqrt+?>: set.x64 sp(8)
	cmplStd/lib/math/Math.ci:581: (7 bytes): ix := ix - t;
	<sqrt+?>: dup.x64 sp(9)
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: sub.i64
	<sqrt+?>: set.x64 sp(11)
	cmplStd/lib/math/Math.ci:582: (7 bytes): q := q + r;
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: add.i64
	<sqrt+?>: set.x64 sp(6)
	cmplStd/lib/math/Math.ci:584: (10 bytes): ix := ix << 1;
	<sqrt+?>: dup.x64 sp(9)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shl.b64
	<sqrt+?>: set.x64 sp(11)
	cmplStd/lib/math/Math.ci:585: (10 bytes): r := r >> 1;
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shr.b64
	<sqrt+?>: set.x64 sp(4)
	<sqrt+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:577: (8 bytes): r != (0)
	<sqrt+?>: dup.x64 sp(0)
	<sqrt+?>: load.z64
	<sqrt+?>: ceq.i64
	<sqrt+?>: jz -63
	cmplStd/lib/math/Math.ci:588: (25 bytes): if (ix != (0))
	<sqrt+?>: dup.x64 sp(7)
	<sqrt+?>: load.z64
	<sqrt+?>: ceq.i64
	<sqrt+?>: jnz +21
	cmplStd/lib/math/Math.ci:589: (17 bytes): q := q + (q & (1));
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: load.c64 1
	<sqrt+?>: and.b64
	<sqrt+?>: add.i64
	<sqrt+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:591: (36 bytes): ix := (q >> 1) + (uint64(exp - 1 + bias) << shift);
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shr.b64
	<sqrt+?>: dup.x32 sp(8)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: inc.i32(+1023)
	<sqrt+?>: i32.2i64
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shl.b64
	<sqrt+?>: add.i64
	<sqrt+?>: set.x64 sp(9)
	cmplStd/lib/math/Math.ci:592: (8 bytes): return .result := Bits.asFloat64(ix);
	<sqrt+?>: mov.x64 sp(12, 7)
	<sqrt+?>: inc.sp(-36)
	<sqrt+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:43: referenced as `sqrt`
	cmplStd/lib/math/Easing.ci:42: referenced as `sqrt`
	cmplStd/lib/math/Complex.ci:79: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:1047: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:1047: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:1034: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:959: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:956: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:926: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:923: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:652: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:647: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:602: referenced as `sqrt`
}
Math.sqrt(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'sqrt'
.file: 'cmplStd/lib/math/Math.ci:596'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the square root of the parameter `x`: $\sqrt{x}$.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.sqrt)) != null) {
		return .result := float32.sqrt(x);
	}
	return .result := float32(sqrt(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:599: (9 bytes): return .result := float32.sqrt(x);
	<sqrt>  : dup.x32 sp(1)
	<sqrt+?>: nfc(40) ;float32.sqrt(x: float32): float32
	<sqrt+?>: set.x32 sp(3)
	<sqrt+?>: ret
	cmplStd/lib/math/Math.ci:602: (18 bytes): return .result := float32(sqrt(float64(x)));
	<sqrt+?>: load.z64
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: f32.2f64
	<sqrt+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-8)
	<sqrt+?>: f64.2f32
	<sqrt+?>: set.x32 sp(3)
	<sqrt+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:52: referenced as `sqrt`
	cmplStd/lib/math/Vector4f.ci:137: referenced as `sqrt`
}
Math.pow(x: float64, y: float64): float64: function {
.kind: static function
.base: `function`
.size: 590
.name: 'pow'
.file: 'cmplStd/lib/math/Math.ci:607'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: 'Returns `x` raised to the power of `y`: $ x^y $.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.pow)) != null) {
		return .result := float64.pow(x, y);
	}
	if (y == (0)) {
		return .result := 1;
	}
	flip: int32 := 0;
	if (y < (0)) {
		y := -y;
		flip := 1;
	}
	ye: float64;
	xy: float64 := 1;
	y1: float64 := modf(y, &ye);
	if (y1 != 0.000000) {
		if (x <= 0.000000) {
			if (x == (0) && !(flip)) {
				return .result := 0;
			}
			return .result := nan;
		}
		if (y1 > 0.500000) {
			y1 := y1 - (1);
			ye := ye + (1);
		}
		xy := exp(y1 * log(x));
	}
	if (ye > (2147483647)) {
		if (x <= (0)) {
			if (x == (0) && !(flip)) {
				return .result := 0;
			}
			return .result := nan;
		}
		if (flip) {
			if (y == 0.500000) {
				return .result := (1) / sqrt(x);
			}
			y := -y;
		}
		else if (y == 0.500000) {
			return .result := sqrt(x);
		}
		return .result := exp(y * log(x));
	}
	ex: int32;
	x := frexp(x, &ex);
	ey: int32 := 0;
	i: int64 := ye;
	if (i) {
		for ( ; ; ) {
			if (i & (1)) {
				xy := xy * x;
				ey := ey + ex;
			}
			i := i >> 1;
			if (i == (0)) {
				break;
			}
			x := x * x;
			ex := ex << 1;
			if (x < 0.500000) {
				x := x + x;
				ex := ex - 1;
			}
		}
	}
	if (flip) {
		xy := 1.000000 / xy;
		ey := -ey;
	}
	return .result := ldexp(xy, ey);
}
.instructions: (590 bytes)
	cmplStd/lib/math/Math.ci:610: (11 bytes): return .result := float64.pow(x, y);
	<pow>  : dup.x64 sp(3)
	<pow+?>: dup.x64 sp(3)
	<pow+?>: nfc(47) ;float64.pow(x: float64, y: float64): float64
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:613: (20 bytes): if (y == (0))
	<pow+?>: dup.x64 sp(1)
	<pow+?>: load.z64
	<pow+?>: ceq.f64
	<pow+?>: jz +16
	cmplStd/lib/math/Math.ci:614: (12 bytes): return .result := 1;
	<pow+?>: load.f64 1.000000
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:617: (1 byte): flip: int32 := 0
	<pow+?>: load.z32
	cmplStd/lib/math/Math.ci:618: (20 bytes): if (y < (0))
	<pow+?>: dup.x64 sp(2)
	<pow+?>: load.z64
	<pow+?>: clt.f64
	<pow+?>: jz +16
	cmplStd/lib/math/Math.ci:619: (5 bytes): y := -y;
	<pow+?>: dup.x64 sp(2)
	<pow+?>: neg.f64
	<pow+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:620: (7 bytes): flip := 1;
	<pow+?>: load.c32 1
	<pow+?>: set.x32 sp(1)
	cmplStd/lib/math/Math.ci:622: (1 byte): ye: float64
	<pow+?>: load.z64
	cmplStd/lib/math/Math.ci:623: (9 bytes): xy: float64 := 1
	<pow+?>: load.f64 1.000000
	cmplStd/lib/math/Math.ci:624: (17 bytes): y1: float64 := modf(y, &ye)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(8)
	<pow+?>: load.sp(+24)
	<pow+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-12)
	cmplStd/lib/math/Math.ci:625: (131 bytes): if (y1 != 0.000000)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.z64
	<pow+?>: ceq.f64
	<pow+?>: jnz +127
	cmplStd/lib/math/Math.ci:626: (54 bytes): if (x <= 0.000000)
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: cgt.f64
	<pow+?>: jnz +50
	cmplStd/lib/math/Math.ci:627: (30 bytes): if (x == (0) && !(flip))
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: ceq.f64
	<pow+?>: dup.x32 sp(0)
	<pow+?>: jz +12
	<pow+?>: inc.sp(-4)
	<pow+?>: dup.x32 sp(6)
	<pow+?>: i32.2bool
	<pow+?>: not.b32
	<pow+?>: jz +12
	cmplStd/lib/math/Math.ci:628: (8 bytes): return .result := 0;
	<pow+?>: load.z64
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:630: (16 bytes): return .result := nan;
	<pow+?>: load.f64 -nan
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:632: (40 bytes): if (y1 > 0.500000)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.f64 0.500000
	<pow+?>: cgt.f64
	<pow+?>: jz +28
	cmplStd/lib/math/Math.ci:633: (10 bytes): y1 := y1 - (1);
	<pow+?>: load.f64 1.000000
	<pow+?>: sub.f64
	cmplStd/lib/math/Math.ci:634: (14 bytes): ye := ye + (1);
	<pow+?>: dup.x64 sp(4)
	<pow+?>: load.f64 1.000000
	<pow+?>: add.f64
	<pow+?>: set.x64 sp(6)
	cmplStd/lib/math/Math.ci:636: (29 bytes): xy := exp(y1 * log(x));
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(2)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(16)
	<pow+?>: load.ref <?> ;Math.log(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: load.ref <?> ;Math.exp(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:638: (201 bytes): if (ye > (2147483647))
	<pow+?>: dup.x64 sp(4)
	<pow+?>: load.f64 2147483647.000000
	<pow+?>: cgt.f64
	<pow+?>: jz +189
	cmplStd/lib/math/Math.ci:639: (54 bytes): if (x <= (0))
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: cgt.f64
	<pow+?>: jnz +50
	cmplStd/lib/math/Math.ci:640: (30 bytes): if (x == (0) && !(flip))
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: ceq.f64
	<pow+?>: dup.x32 sp(0)
	<pow+?>: jz +12
	<pow+?>: inc.sp(-4)
	<pow+?>: dup.x32 sp(6)
	<pow+?>: i32.2bool
	<pow+?>: not.b32
	<pow+?>: jz +12
	cmplStd/lib/math/Math.ci:641: (8 bytes): return .result := 0;
	<pow+?>: load.z64
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:643: (16 bytes): return .result := nan;
	<pow+?>: load.f64 -nan
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:645: (97 bytes): if (flip)
	<pow+?>: dup.x32 sp(6)
	<pow+?>: jz +59
	cmplStd/lib/math/Math.ci:646: (46 bytes): if (y == 0.500000)
	<pow+?>: dup.x64 sp(8)
	<pow+?>: load.f64 0.500000
	<pow+?>: ceq.f64
	<pow+?>: jz +34
	cmplStd/lib/math/Math.ci:647: (30 bytes): return .result := (1) / sqrt(x);
	<pow+?>: load.f64 1.000000
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(14)
	<pow+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: div.f64
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:649: (5 bytes): y := -y;
	<pow+?>: dup.x64 sp(8)
	<pow+?>: neg.f64
	<pow+?>: set.x64 sp(10)
	<pow+?>: jmp +40
	cmplStd/lib/math/Math.ci:651: (36 bytes): if (y == 0.500000)
	<pow+?>: dup.x64 sp(8)
	<pow+?>: load.f64 0.500000
	<pow+?>: ceq.f64
	<pow+?>: jz +24
	cmplStd/lib/math/Math.ci:652: (20 bytes): return .result := sqrt(x);
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(12)
	<pow+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:654: (34 bytes): return .result := exp(y * log(x));
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(16)
	<pow+?>: load.ref <?> ;Math.log(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: load.ref <?> ;Math.exp(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:657: (1 byte): ex: int32
	<pow+?>: load.z32
	cmplStd/lib/math/Math.ci:658: (19 bytes): x := frexp(x, &ex);
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(13)
	<pow+?>: load.sp(+16)
	<pow+?>: load.ref <?> ;Math.frexp(f: float64, exp: int32): float64
	<pow+?>: call
	<pow+?>: inc.sp(-12)
	<pow+?>: set.x64 sp(13)
	cmplStd/lib/math/Math.ci:659: (1 byte): ey: int32 := 0
	<pow+?>: load.z32
	cmplStd/lib/math/Math.ci:660: (3 bytes): i: int64 := ye
	<pow+?>: dup.x64 sp(6)
	<pow+?>: f64.2i64
	cmplStd/lib/math/Math.ci:661: (108 bytes): if (i)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: i64.2bool
	<pow+?>: jz +105
	cmplStd/lib/math/Math.ci:662: (101 bytes): for ( ; ; )
	<pow+?>: jmp +97
	cmplStd/lib/math/Math.ci:663: (31 bytes): if (i & (1))
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.c64 1
	<pow+?>: and.b64
	<pow+?>: i64.2bool
	<pow+?>: jz +18
	cmplStd/lib/math/Math.ci:664: (7 bytes): xy := xy * x;
	<pow+?>: dup.x64 sp(6)
	<pow+?>: dup.x64 sp(16)
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(8)
	cmplStd/lib/math/Math.ci:665: (7 bytes): ey := ey + ex;
	<pow+?>: dup.x32 sp(2)
	<pow+?>: dup.x32 sp(4)
	<pow+?>: add.i32
	<pow+?>: set.x32 sp(3)
	cmplStd/lib/math/Math.ci:667: (6 bytes): i := i >> 1;
	<pow+?>: load.c32 1
	<pow+?>: sar.b64
	cmplStd/lib/math/Math.ci:668: (12 bytes): if (i == (0))
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.z64
	<pow+?>: ceq.i64
	<pow+?>: jz +8
	cmplStd/lib/math/Math.ci:669: (4 bytes): break;
	<pow+?>: jmp +52
	cmplStd/lib/math/Math.ci:671: (7 bytes): x := x * x;
	<pow+?>: dup.x64 sp(14)
	<pow+?>: dup.x64 sp(16)
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(16)
	cmplStd/lib/math/Math.ci:672: (6 bytes): ex := ex << 1;
	<pow+?>: dup.x32 sp(3)
	<pow+?>: b32.shl 0x01
	<pow+?>: set.x32 sp(4)
	cmplStd/lib/math/Math.ci:673: (31 bytes): if (x < 0.500000)
	<pow+?>: dup.x64 sp(14)
	<pow+?>: load.f64 0.500000
	<pow+?>: clt.f64
	<pow+?>: jz +19
	cmplStd/lib/math/Math.ci:674: (7 bytes): x := x + x;
	<pow+?>: dup.x64 sp(14)
	<pow+?>: dup.x64 sp(16)
	<pow+?>: add.f64
	<pow+?>: set.x64 sp(16)
	cmplStd/lib/math/Math.ci:675: (8 bytes): ex := ex - 1;
	<pow+?>: dup.x32 sp(3)
	<pow+?>: inc.i32(-1)
	<pow+?>: set.x32 sp(4)
	:: (4 bytes)
	<pow+?>: jmp -93
	cmplStd/lib/math/Math.ci:679: (25 bytes): if (flip)
	<pow+?>: dup.x32 sp(10)
	<pow+?>: jz +23
	cmplStd/lib/math/Math.ci:680: (14 bytes): xy := 1.000000 / xy;
	<pow+?>: load.f64 1.000000
	<pow+?>: dup.x64 sp(8)
	<pow+?>: div.f64
	<pow+?>: set.x64 sp(8)
	cmplStd/lib/math/Math.ci:681: (5 bytes): ey := -ey;
	<pow+?>: dup.x32 sp(2)
	<pow+?>: neg.i32
	<pow+?>: set.x32 sp(3)
	cmplStd/lib/math/Math.ci:683: (22 bytes): return .result := ldexp(xy, ey);
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(8)
	<pow+?>: dup.x32 sp(6)
	<pow+?>: load.ref <?> ;Math.ldexp(f: float64, exp: int32): float64
	<pow+?>: call
	<pow+?>: inc.sp(-12)
	<pow+?>: set.x64 sp(18)
	<pow+?>: inc.sp(-44)
	<pow+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:42: referenced as `pow`
	cmplStd/lib/math/Easing.ci:49: referenced as `pow`
	cmplStd/lib/math/Easing.ci:32: referenced as `pow`
	cmplStd/lib/text/Format.ci:211: referenced as `pow`
	cmplStd/lib/math/Complex.ci:106: referenced as `pow`
	cmplStd/lib/math/Math.ci:693: referenced as `pow`
}
Math.pow(x: float32, y: float32): float32: function {
.kind: static function
.base: `function`
.size: 32
.name: 'pow'
.file: 'cmplStd/lib/math/Math.ci:687'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.doc: 'Returns `x` raised to the power of `y`: $ x^y $.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.pow)) != null) {
		return .result := float32.pow(x, y);
	}
	return .result := float32(pow(float64(x), float64(y)));
}
.instructions: (32 bytes)
	cmplStd/lib/math/Math.ci:690: (11 bytes): return .result := float32.pow(x, y);
	<pow>  : dup.x32 sp(2)
	<pow+?>: dup.x32 sp(2)
	<pow+?>: nfc(39) ;float32.pow(x: float32, y: float32): float32
	<pow+?>: set.x32 sp(4)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:693: (21 bytes): return .result := float32(pow(float64(x), float64(y)));
	<pow+?>: load.z64
	<pow+?>: dup.x32 sp(4)
	<pow+?>: f32.2f64
	<pow+?>: dup.x32 sp(5)
	<pow+?>: f32.2f64
	<pow+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-16)
	<pow+?>: f64.2f32
	<pow+?>: set.x32 sp(4)
	<pow+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:51: referenced as `pow`
}
Math.sincos(x: float64, quad: int32): float64: function {
.kind: static function
.base: `function`
.size: 357
.name: 'sincos'
.file: 'cmplStd/lib/math/Math.ci:698'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param quad: int32 (size: 4, cast: variable(i32))
.value: {
	if (x < (0)) {
		x := -x;
		quad := quad + 2;
	}
	y: float64;
	x := x * (2) / pi;
	if (x > (32764)) {
		e: float64;
		y := modf(x, &e);
		e := e + (quad);
		f: float64;
		modf(0.250000 * e, &f);
		quad := (e - (4) * f);
	}
	else {
		k: int32 := x;
		y := x - (k);
		quad := quad + k;
		quad := quad & 3;
	}
	if (quad & 1) {
		y := (1) - y;
	}
	if (quad > 1) {
		y := -y;
	}
	ysq: float64 := y * y;
	p: float64 := y * eval(ysq, p0, p1, p2, p3, p4);
	q: float64 := eval(ysq, q0, q1, q2, q3 + ysq);
	return .result := p / q;
}
.instructions: (357 bytes)
	cmplStd/lib/math/Math.ci:711: (21 bytes): if (x < (0))
	<sincos>  : dup.x64 sp(2)
	<sincos+?>: load.z64
	<sincos+?>: clt.f64
	<sincos+?>: jz +17
	cmplStd/lib/math/Math.ci:712: (5 bytes): x := -x;
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: neg.f64
	<sincos+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:713: (8 bytes): quad := quad + 2;
	<sincos+?>: dup.x32 sp(1)
	<sincos+?>: inc.i32(+2)
	<sincos+?>: set.x32 sp(2)
	cmplStd/lib/math/Math.ci:716: (1 byte): y: float64
	<sincos+?>: load.z64
	cmplStd/lib/math/Math.ci:717: (24 bytes): x := x * (2) / pi;
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 2.000000
	<sincos+?>: load.f64 3.141593
	<sincos+?>: div.f64
	<sincos+?>: mul.f64
	<sincos+?>: set.x64 sp(6)
	cmplStd/lib/math/Math.ci:718: (124 bytes): if (x > (32764))
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 32764.000000
	<sincos+?>: cgt.f64
	<sincos+?>: jz +84
	cmplStd/lib/math/Math.ci:719: (1 byte): e: float64
	<sincos+?>: load.z128
	cmplStd/lib/math/Math.ci:720: (18 bytes): y := modf(x, &e);
	<sincos+?>: dup.x64 sp(8)
	<sincos+?>: load.sp(+16)
	<sincos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sincos+?>: call
	<sincos+?>: inc.sp(-12)
	<sincos+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:721: (4 bytes): e := e + (quad);
	<sincos+?>: dup.x32 sp(5)
	<sincos+?>: i32.2f64
	<sincos+?>: add.f64
	cmplStd/lib/math/Math.ci:723: (1 byte): f: float64
	<sincos+?>: load.z128
	cmplStd/lib/math/Math.ci:724: (30 bytes): modf(0.250000 * e, &f);
	<sincos+?>: load.f64 0.250000
	<sincos+?>: dup.x64 sp(6)
	<sincos+?>: mul.f64
	<sincos+?>: load.sp(+16)
	<sincos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sincos+?>: call
	<sincos+?>: inc.sp(-12)
	<sincos+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:725: (18 bytes): quad := (e - (4) * f);
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 4.000000
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: mul.f64
	<sincos+?>: sub.f64
	<sincos+?>: f64.2i32
	<sincos+?>: set.x32 sp(8)
	<sincos+?>: inc.sp(-16)
	<sincos+?>: jmp +32
	cmplStd/lib/math/Math.ci:727: (3 bytes): k: int32 := x
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: f64.2i32
	cmplStd/lib/math/Math.ci:728: (8 bytes): y := x - (k);
	<sincos+?>: dup.x64 sp(5)
	<sincos+?>: dup.x32 sp(2)
	<sincos+?>: i32.2f64
	<sincos+?>: sub.f64
	<sincos+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:729: (7 bytes): quad := quad + k;
	<sincos+?>: dup.x32 sp(4)
	<sincos+?>: dup.x32 sp(1)
	<sincos+?>: add.i32
	<sincos+?>: set.x32 sp(5)
	cmplStd/lib/math/Math.ci:730: (6 bytes): quad := quad & 3;
	<sincos+?>: dup.x32 sp(4)
	<sincos+?>: b32.and 0x03
	<sincos+?>: set.x32 sp(5)
	<sincos+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:732: (22 bytes): if (quad & 1)
	<sincos+?>: dup.x32 sp(3)
	<sincos+?>: b32.and 0x01
	<sincos+?>: jz +18
	cmplStd/lib/math/Math.ci:733: (14 bytes): y := (1) - y;
	<sincos+?>: load.f64 1.000000
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: sub.f64
	<sincos+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:735: (13 bytes): if (quad > 1)
	<sincos+?>: dup.x32 sp(3)
	<sincos+?>: load.c32 1
	<sincos+?>: cgt.i32
	<sincos+?>: jz +5
	cmplStd/lib/math/Math.ci:736: (1 byte): y := -y;
	<sincos+?>: neg.f64
	cmplStd/lib/math/Math.ci:739: (5 bytes): ysq: float64 := y * y
	<sincos+?>: dup.x64 sp(0)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: mul.f64
	cmplStd/lib/math/Math.ci:740: (76 bytes): p: float64 := y * eval(ysq, p0, p1, p2, p3, p4)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 13578840.978774
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 -4942908.100903
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 440103.053538
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 -13847.272500
	<sincos+?>: dup.x64 sp(6)
	<sincos+?>: load.f64 145.968841
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	<sincos+?>: mul.f64
	cmplStd/lib/math/Math.ci:741: (59 bytes): q: float64 := eval(ysq, q0, q1, q2, q3 + ysq)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 8644558.652923
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 408179.225234
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 9463.096102
	<sincos+?>: dup.x64 sp(6)
	<sincos+?>: load.f64 132.653491
	<sincos+?>: dup.x64 sp(20)
	<sincos+?>: add.f64
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:742: (12 bytes): return .result := p / q;
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: div.f64
	<sincos+?>: set.x64 sp(14)
	<sincos+?>: inc.sp(-32)
	<sincos+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:939: referenced as `sincos`
	cmplStd/lib/math/Math.ci:906: referenced as `sincos`
}
Math.tancot(x: float64, flag: int32): float64: function {
.kind: static function
.base: `function`
.size: 447
.name: 'tancot'
.file: 'cmplStd/lib/math/Math.ci:746'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param flag: int32 (size: 4, cast: variable(i32))
.value: {
	sign: float64 := 1;
	if (x < (0)) {
		x := -x;
		sign := (-1);
	}
	if (x > lossth) {
		return .result := 0;
	}
	y: float64 := floor(x / (pi / (4)));
	z: float64 := ldexp(y, -3);
	z := floor(z);
	z := y - ldexp(z, 3);
	j: int32 := z;
	if (j & 1) {
		j := j + 1;
		y := y + 1.000000;
	}
	z := ((x - y * dp1) - y * dp2) - y * dp3;
	zz: float64 := z * z;
	if (zz > 0.000000) {
		y := z + z * (zz * eval(zz, p2, p1, p0) / eval(zz, q4, q3, q2, q1, q0));
	}
	else {
		y := z;
	}
	if (j & 2) {
		if (flag) {
			y := -y;
		}
		else {
			y := (-1) / y;
		}
	}
	else if (flag) {
		y := (1) / y;
	}
	return .result := sign * y;
}
.instructions: (447 bytes)
	cmplStd/lib/math/Math.ci:766: (9 bytes): sign: float64 := 1
	<tancot>  : load.f64 1.000000
	cmplStd/lib/math/Math.ci:767: (24 bytes): if (x < (0))
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.z64
	<tancot+?>: clt.f64
	<tancot+?>: jz +20
	cmplStd/lib/math/Math.ci:768: (5 bytes): x := -x;
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: neg.f64
	<tancot+?>: set.x64 sp(6)
	cmplStd/lib/math/Math.ci:769: (11 bytes): sign := (-1);
	<tancot+?>: load.f64 -1.000000
	<tancot+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:772: (24 bytes): if (x > lossth)
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.f64 1073741824.000000
	<tancot+?>: cgt.f64
	<tancot+?>: jz +12
	cmplStd/lib/math/Math.ci:774: (8 bytes): return .result := 0;
	<tancot+?>: load.z64
	<tancot+?>: set.x64 sp(8)
	<tancot+?>: inc.sp(-8)
	<tancot+?>: ret
	cmplStd/lib/math/Math.ci:778: (33 bytes): y: float64 := floor(x / (pi / (4)))
	<tancot+?>: load.z64
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 3.141593
	<tancot+?>: load.f64 4.000000
	<tancot+?>: div.f64
	<tancot+?>: div.f64
	<tancot+?>: load.ref <?> ;Math.floor(x: float64): float64
	<tancot+?>: call
	<tancot+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:781: (18 bytes): z: float64 := ldexp(y, -3)
	<tancot+?>: load.z64
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.c32 -3
	<tancot+?>: load.ref <?> ;Math.ldexp(f: float64, exp: int32): float64
	<tancot+?>: call
	<tancot+?>: inc.sp(-12)
	cmplStd/lib/math/Math.ci:782: (15 bytes): z := floor(z);
	<tancot+?>: load.z64
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.ref <?> ;Math.floor(x: float64): float64
	<tancot+?>: call
	<tancot+?>: inc.sp(-8)
	<tancot+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:783: (23 bytes): z := y - ldexp(z, 3);
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.z64
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.c32 3
	<tancot+?>: load.ref <?> ;Math.ldexp(f: float64, exp: int32): float64
	<tancot+?>: call
	<tancot+?>: inc.sp(-12)
	<tancot+?>: sub.f64
	<tancot+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:786: (3 bytes): j: int32 := z
	<tancot+?>: dup.x64 sp(0)
	<tancot+?>: f64.2i32
	cmplStd/lib/math/Math.ci:789: (26 bytes): if (j & 1)
	<tancot+?>: dup.x32 sp(0)
	<tancot+?>: b32.and 0x01
	<tancot+?>: jz +22
	cmplStd/lib/math/Math.ci:790: (4 bytes): j := j + 1;
	<tancot+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:791: (14 bytes): y := y + 1.000000;
	<tancot+?>: dup.x64 sp(3)
	<tancot+?>: load.f64 1.000000
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(5)
	cmplStd/lib/math/Math.ci:794: (43 bytes): z := ((x - y * dp1) - y * dp2) - y * dp3;
	<tancot+?>: dup.x64 sp(9)
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: load.f64 0.785398
	<tancot+?>: mul.f64
	<tancot+?>: sub.f64
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: load.f64 0.000000
	<tancot+?>: mul.f64
	<tancot+?>: sub.f64
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: load.f64 0.000000
	<tancot+?>: mul.f64
	<tancot+?>: sub.f64
	<tancot+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:796: (5 bytes): zz: float64 := z * z
	<tancot+?>: dup.x64 sp(1)
	<tancot+?>: dup.x64 sp(3)
	<tancot+?>: mul.f64
	cmplStd/lib/math/Math.ci:797: (147 bytes): if (zz > 0.000000)
	<tancot+?>: dup.x64 sp(0)
	<tancot+?>: load.f64 0.000000
	<tancot+?>: cgt.f64
	<tancot+?>: jz +132
	cmplStd/lib/math/Math.ci:798: (124 bytes): y := z + z * (zz * eval(zz, p2, p1, p0) / eval(zz, q4, q3, q2, q1, q0));
	<tancot+?>: dup.x64 sp(3)
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 -17956525.197648
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.f64 1153516.648386
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 -13093.693918
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(2)
	<tancot+?>: mul.f64
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 -53869575.592945
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.f64 25008380.182336
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.f64 -1320892.344402
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.f64 13681.296347
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 1.000000
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(2)
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(2)
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(2)
	<tancot+?>: div.f64
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(7)
	<tancot+?>: jmp +7
	cmplStd/lib/math/Math.ci:800: (3 bytes): y := z;
	<tancot+?>: mov.x64 sp(5, 3)
	cmplStd/lib/math/Math.ci:803: (65 bytes): if (j & 2)
	<tancot+?>: dup.x32 sp(2)
	<tancot+?>: load.c32 2
	<tancot+?>: and.b32
	<tancot+?>: jz +37
	cmplStd/lib/math/Math.ci:804: (29 bytes): if (flag)
	<tancot+?>: dup.x32 sp(10)
	<tancot+?>: jz +13
	cmplStd/lib/math/Math.ci:805: (5 bytes): y := -y;
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: neg.f64
	<tancot+?>: set.x64 sp(7)
	<tancot+?>: jmp +18
	cmplStd/lib/math/Math.ci:807: (14 bytes): y := (-1) / y;
	<tancot+?>: load.f64 -1.000000
	<tancot+?>: dup.x64 sp(7)
	<tancot+?>: div.f64
	<tancot+?>: set.x64 sp(7)
	<tancot+?>: jmp +24
	cmplStd/lib/math/Math.ci:810: (20 bytes): if (flag)
	<tancot+?>: dup.x32 sp(10)
	<tancot+?>: jz +18
	cmplStd/lib/math/Math.ci:811: (14 bytes): y := (1) / y;
	<tancot+?>: load.f64 1.000000
	<tancot+?>: dup.x64 sp(7)
	<tancot+?>: div.f64
	<tancot+?>: set.x64 sp(7)
	cmplStd/lib/math/Math.ci:815: (12 bytes): return .result := sign * y;
	<tancot+?>: dup.x64 sp(7)
	<tancot+?>: dup.x64 sp(7)
	<tancot+?>: mul.f64
	<tancot+?>: set.x64 sp(15)
	<tancot+?>: inc.sp(-36)
	<tancot+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:1011: referenced as `tancot`
	cmplStd/lib/math/Math.ci:981: referenced as `tancot`
}
Math.atan(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 42
.name: 'atan'
.file: 'cmplStd/lib/math/Math.ci:820'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse tangent of the radian argument `x`.'
.value: {
	static xatan(x: float64): float64 := {
		z: float64 := x * x;
		p: float64 := eval(z, p0, p1, p2, p3, p4);
		q: float64 := eval(z, q0, q1, q2, q3, q4 + z);
		return .result := p / q * x;
	};
	static satan(x: float64): float64 := {
		if (x < sq2m1) {
			return .result := xatan(x);
		}
		if (x > sq2p1) {
			return .result := pi / (2) - xatan((1) / x);
		}
		return .result := pi / (4) + xatan((x - (1)) / (x + (1)));
	};
	if (x > (0)) {
		return .result := satan(x);
	}
	return .result := -satan(-x);
}
.instructions: (42 bytes)
	cmplStd/lib/math/Math.ci:857: (24 bytes): if (x > (0))
	<atan>  : dup.x64 sp(1)
	<atan+?>: load.z64
	<atan+?>: cgt.f64
	<atan+?>: jz +20
	cmplStd/lib/math/Math.ci:858: (16 bytes): return .result := satan(x);
	<atan+?>: load.z64
	<atan+?>: dup.x64 sp(3)
	<atan+?>: load.ref <?> ;Math.atan.satan(x: float64): float64
	<atan+?>: call
	<atan+?>: inc.sp(-8)
	<atan+?>: set.x64 sp(5)
	<atan+?>: ret
	cmplStd/lib/math/Math.ci:860: (18 bytes): return .result := -satan(-x);
	<atan+?>: load.z64
	<atan+?>: dup.x64 sp(3)
	<atan+?>: neg.f64
	<atan+?>: load.ref <?> ;Math.atan.satan(x: float64): float64
	<atan+?>: call
	<atan+?>: inc.sp(-8)
	<atan+?>: neg.f64
	<atan+?>: set.x64 sp(5)
	<atan+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:1018: referenced as `atan`
	cmplStd/lib/math/Math.ci:878: referenced as `atan`
}
Math.atan2(arg1: float64, arg2: float64): float64: function {
.kind: static function
.base: `function`
.size: 143
.name: 'atan2'
.file: 'cmplStd/lib/math/Math.ci:865'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg1: float64 (size: 8, cast: variable(f64))
.param arg2: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse tangent of y/x.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.atan2)) != null) {
		return .result := float64.atan2(arg1, arg2);
	}
	if (arg1 + arg2 == arg1) {
		if (arg1 >= (0)) {
			return .result := pi / (2);
		}
		return .result := -pi / (2);
	}
	arg1 := atan(arg1 / arg2);
	if (arg2 < (0)) {
		if (arg1 <= (0)) {
			return .result := arg1 + pi;
		}
		return .result := arg1 - pi;
	}
	return .result := arg1;
}
.instructions: (143 bytes)
	cmplStd/lib/math/Math.ci:868: (11 bytes): return .result := float64.atan2(arg1, arg2);
	<atan2>  : dup.x64 sp(3)
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: nfc(49) ;float64.atan2(x: float64, y: float64): float64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:871: (64 bytes): if (arg1 + arg2 == arg1)
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: add.f64
	<atan2+?>: dup.x64 sp(5)
	<atan2+?>: ceq.f64
	<atan2+?>: jz +56
	cmplStd/lib/math/Math.ci:872: (30 bytes): if (arg1 >= (0))
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: load.z64
	<atan2+?>: clt.f64
	<atan2+?>: jnz +26
	cmplStd/lib/math/Math.ci:873: (22 bytes): return .result := pi / (2);
	<atan2+?>: load.f64 3.141593
	<atan2+?>: load.f64 2.000000
	<atan2+?>: div.f64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:875: (22 bytes): return .result := -pi / (2);
	<atan2+?>: load.f64 -3.141593
	<atan2+?>: load.f64 2.000000
	<atan2+?>: div.f64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:878: (18 bytes): arg1 := atan(arg1 / arg2);
	<atan2+?>: load.z64
	<atan2+?>: dup.x64 sp(5)
	<atan2+?>: dup.x64 sp(5)
	<atan2+?>: div.f64
	<atan2+?>: load.ref <?> ;Math.atan(x: float64): float64
	<atan2+?>: call
	<atan2+?>: inc.sp(-8)
	<atan2+?>: set.x64 sp(5)
	cmplStd/lib/math/Math.ci:879: (46 bytes): if (arg2 < (0))
	<atan2+?>: dup.x64 sp(1)
	<atan2+?>: load.z64
	<atan2+?>: clt.f64
	<atan2+?>: jz +42
	cmplStd/lib/math/Math.ci:880: (23 bytes): if (arg1 <= (0))
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: load.z64
	<atan2+?>: cgt.f64
	<atan2+?>: jnz +19
	cmplStd/lib/math/Math.ci:881: (15 bytes): return .result := arg1 + pi;
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: load.f64 3.141593
	<atan2+?>: add.f64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:883: (15 bytes): return .result := arg1 - pi;
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: load.f64 3.141593
	<atan2+?>: sub.f64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:885: (4 bytes): return .result := arg1;
	<atan2+?>: mov.x64 sp(5, 3)
	<atan2+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:44: referenced as `atan2`
	cmplStd/lib/math/Complex.ci:81: referenced as `atan2`
	cmplStd/lib/math/Math.ci:956: referenced as `atan2`
	cmplStd/lib/math/Math.ci:923: referenced as `atan2`
	cmplStd/lib/math/Math.ci:895: referenced as `atan2`
}
Math.atan2(y: float32, x: float32): float32: function {
.kind: static function
.base: `function`
.size: 32
.name: 'atan2'
.file: 'cmplStd/lib/math/Math.ci:889'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the inverse tangent of y/x.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.atan2)) != null) {
		return .result := float32.atan2(y, x);
	}
	return .result := float32(atan2(float64(y), float64(x)));
}
.instructions: (32 bytes)
	cmplStd/lib/math/Math.ci:892: (11 bytes): return .result := float32.atan2(y, x);
	<atan2>  : dup.x32 sp(2)
	<atan2+?>: dup.x32 sp(2)
	<atan2+?>: nfc(41) ;float32.atan2(x: float32, y: float32): float32
	<atan2+?>: set.x32 sp(4)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:895: (21 bytes): return .result := float32(atan2(float64(y), float64(x)));
	<atan2+?>: load.z64
	<atan2+?>: dup.x32 sp(4)
	<atan2+?>: f32.2f64
	<atan2+?>: dup.x32 sp(5)
	<atan2+?>: f32.2f64
	<atan2+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<atan2+?>: call
	<atan2+?>: inc.sp(-16)
	<atan2+?>: f64.2f32
	<atan2+?>: set.x32 sp(4)
	<atan2+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:53: referenced as `atan2`
}
Math.sin(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 26
.name: 'sin'
.file: 'cmplStd/lib/math/Math.ci:900'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the sine of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.sin)) != null) {
		return .result := float64.sin(x);
	}
	return .result := sincos(x, 0);
}
.instructions: (26 bytes)
	cmplStd/lib/math/Math.ci:903: (9 bytes): return .result := float64.sin(x);
	<sin>  : dup.x64 sp(1)
	<sin+?>: nfc(42) ;float64.sin(x: float64): float64
	<sin+?>: set.x64 sp(5)
	<sin+?>: ret
	cmplStd/lib/math/Math.ci:906: (17 bytes): return .result := sincos(x, 0);
	<sin+?>: load.z64
	<sin+?>: dup.x64 sp(3)
	<sin+?>: load.z32
	<sin+?>: load.ref <?> ;Math.sincos(x: float64, quad: int32): float64
	<sin+?>: call
	<sin+?>: inc.sp(-12)
	<sin+?>: set.x64 sp(5)
	<sin+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:83: referenced as `sin`
	cmplStd/test/math/test.Bits.ci:37: referenced as `sin`
	cmplStd/lib/math/Easing.ci:49: referenced as `sin`
	cmplStd/lib/math/Complex.ci:142: referenced as `sin`
	cmplStd/lib/math/Complex.ci:118: referenced as `sin`
	cmplStd/lib/math/Complex.ci:116: referenced as `sin`
	cmplStd/lib/math/Complex.ci:109: referenced as `sin`
	cmplStd/lib/math/Complex.ci:96: referenced as `sin`
	cmplStd/lib/math/Math.ci:1038: referenced as `sin`
	cmplStd/lib/math/Math.ci:916: referenced as `sin`
}
Math.sin(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'sin'
.file: 'cmplStd/lib/math/Math.ci:910'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the sine of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.sin)) != null) {
		return .result := float32.sin(x);
	}
	return .result := float32(sin(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:913: (9 bytes): return .result := float32.sin(x);
	<sin>  : dup.x32 sp(1)
	<sin+?>: nfc(34) ;float32.sin(x: float32): float32
	<sin+?>: set.x32 sp(3)
	<sin+?>: ret
	cmplStd/lib/math/Math.ci:916: (18 bytes): return .result := float32(sin(float64(x)));
	<sin+?>: load.z64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: f32.2f64
	<sin+?>: load.ref <?> ;Math.sin(x: float64): float64
	<sin+?>: call
	<sin+?>: inc.sp(-8)
	<sin+?>: f64.2f32
	<sin+?>: set.x32 sp(3)
	<sin+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:46: referenced as `sin`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `sin`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `sin`
}
Math.sinh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'cmplStd/lib/math/Math.ci:920'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the radian argument `x`.'
.value: x == (0) ? (0) : (exp(x) - exp(-x)) / (2)
.usages:
	cmplStd/test/math/test.Math.ci:86: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:118: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:116: referenced as `sinh`
	cmplStd/lib/math/Math.ci:1041: referenced as `sinh`
}
Math.asin(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asin'
.file: 'cmplStd/lib/math/Math.ci:923'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse sine of the radian argument `x`.'
.value: atan2(x, sqrt(((1) + x) * ((1) - x)))
.usages:
	cmplStd/test/math/test.Math.ci:89: referenced as `asin`
	cmplStd/lib/math/Math.ci:1044: referenced as `asin`
}
Math.asinh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asinh'
.file: 'cmplStd/lib/math/Math.ci:926'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic sine of the radian argument `x`.'
.value: log(x + sqrt((x * x) + (1)))
.usages:
}
Math.cos(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 43
.name: 'cos'
.file: 'cmplStd/lib/math/Math.ci:930'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the cosine of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.cos)) != null) {
		return .result := float64.cos(x);
	}
	if (x < (0)) {
		x := -x;
	}
	return .result := sincos(x, 1);
}
.instructions: (43 bytes)
	cmplStd/lib/math/Math.ci:933: (9 bytes): return .result := float64.cos(x);
	<cos>  : dup.x64 sp(1)
	<cos+?>: nfc(43) ;float64.cos(x: float64): float64
	<cos+?>: set.x64 sp(5)
	<cos+?>: ret
	cmplStd/lib/math/Math.ci:936: (13 bytes): if (x < (0))
	<cos+?>: dup.x64 sp(1)
	<cos+?>: load.z64
	<cos+?>: clt.f64
	<cos+?>: jz +9
	cmplStd/lib/math/Math.ci:937: (5 bytes): x := -x;
	<cos+?>: dup.x64 sp(1)
	<cos+?>: neg.f64
	<cos+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:939: (21 bytes): return .result := sincos(x, 1);
	<cos+?>: load.z64
	<cos+?>: dup.x64 sp(3)
	<cos+?>: load.c32 1
	<cos+?>: load.ref <?> ;Math.sincos(x: float64, quad: int32): float64
	<cos+?>: call
	<cos+?>: inc.sp(-12)
	<cos+?>: set.x64 sp(5)
	<cos+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:84: referenced as `cos`
	cmplStd/test/math/test.Bits.ci:38: referenced as `cos`
	cmplStd/lib/math/Easing.ci:37: referenced as `cos`
	cmplStd/lib/math/Complex.ci:142: referenced as `cos`
	cmplStd/lib/math/Complex.ci:118: referenced as `cos`
	cmplStd/lib/math/Complex.ci:116: referenced as `cos`
	cmplStd/lib/math/Complex.ci:108: referenced as `cos`
	cmplStd/lib/math/Complex.ci:96: referenced as `cos`
	cmplStd/lib/math/Math.ci:1025: referenced as `cos`
	cmplStd/lib/math/Math.ci:949: referenced as `cos`
}
Math.cos(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'cos'
.file: 'cmplStd/lib/math/Math.ci:943'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the sine of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.cos)) != null) {
		return .result := float32.cos(x);
	}
	return .result := float32(cos(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:946: (9 bytes): return .result := float32.cos(x);
	<cos>  : dup.x32 sp(1)
	<cos+?>: nfc(35) ;float32.cos(x: float32): float32
	<cos+?>: set.x32 sp(3)
	<cos+?>: ret
	cmplStd/lib/math/Math.ci:949: (18 bytes): return .result := float32(cos(float64(x)));
	<cos+?>: load.z64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: f32.2f64
	<cos+?>: load.ref <?> ;Math.cos(x: float64): float64
	<cos+?>: call
	<cos+?>: inc.sp(-8)
	<cos+?>: f64.2f32
	<cos+?>: set.x32 sp(3)
	<cos+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:47: referenced as `cos`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `cos`
	cmplStd/lib/math/Matrix4f.ci:134: referenced as `cos`
}
Math.cosh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'cmplStd/lib/math/Math.ci:953'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the radian argument `x`.'
.value: x == (0) ? (1) : (exp(x) + exp(-x)) / (2)
.usages:
	cmplStd/test/math/test.Math.ci:87: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:118: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:116: referenced as `cosh`
	cmplStd/lib/math/Math.ci:1028: referenced as `cosh`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acos'
.file: 'cmplStd/lib/math/Math.ci:956'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse cosine of the radian argument `x`.'
.value: atan2(sqrt(((1) + x) * ((1) - x)), x)
.usages:
	cmplStd/test/math/test.Math.ci:90: referenced as `acos`
	cmplStd/lib/math/Math.ci:1031: referenced as `acos`
}
Math.acosh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acosh'
.file: 'cmplStd/lib/math/Math.ci:959'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic cosine of the radian argument `x`.'
.value: log(x + sqrt(x * x - (1)))
.usages:
}
Math.tan(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 82
.name: 'tan'
.file: 'cmplStd/lib/math/Math.ci:963'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the tangent of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.tan)) != null) {
		return .result := float64.tan(x);
	}
	if (x == (0)) {
		return .result := x;
	}
	if (x != x) {
		return .result := x;
	}
	if (x == (2) * x) {
		return .result := nan;
	}
	return .result := tancot(x, 0);
}
.instructions: (82 bytes)
	cmplStd/lib/math/Math.ci:966: (9 bytes): return .result := float64.tan(x);
	<tan>  : dup.x64 sp(1)
	<tan+?>: nfc(44) ;float64.tan(x: float64): float64
	<tan+?>: set.x64 sp(5)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:969: (12 bytes): if (x == (0))
	<tan+?>: dup.x64 sp(1)
	<tan+?>: load.z64
	<tan+?>: ceq.f64
	<tan+?>: jz +8
	cmplStd/lib/math/Math.ci:970: (4 bytes): return .result := x;
	<tan+?>: mov.x64 sp(3, 1)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:972: (13 bytes): if (x != x)
	<tan+?>: dup.x64 sp(1)
	<tan+?>: dup.x64 sp(3)
	<tan+?>: ceq.f64
	<tan+?>: jnz +8
	cmplStd/lib/math/Math.ci:974: (4 bytes): return .result := x;
	<tan+?>: mov.x64 sp(3, 1)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:976: (31 bytes): if (x == (2) * x)
	<tan+?>: dup.x64 sp(1)
	<tan+?>: load.f64 2.000000
	<tan+?>: dup.x64 sp(5)
	<tan+?>: mul.f64
	<tan+?>: ceq.f64
	<tan+?>: jz +16
	cmplStd/lib/math/Math.ci:978: (12 bytes): return .result := nan;
	<tan+?>: load.f64 -nan
	<tan+?>: set.x64 sp(5)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:981: (17 bytes): return .result := tancot(x, 0);
	<tan+?>: load.z64
	<tan+?>: dup.x64 sp(3)
	<tan+?>: load.z32
	<tan+?>: load.ref <?> ;Math.tancot(x: float64, flag: int32): float64
	<tan+?>: call
	<tan+?>: inc.sp(-12)
	<tan+?>: set.x64 sp(5)
	<tan+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:85: referenced as `tan`
	cmplStd/test/math/test.Bits.ci:39: referenced as `tan`
	cmplGfx/lib/camera.ci:28: referenced as `tan`
	cmplStd/lib/math/Math.ci:991: referenced as `tan`
}
Math.tan(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'tan'
.file: 'cmplStd/lib/math/Math.ci:985'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the tangent of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.tan)) != null) {
		return .result := float32.tan(x);
	}
	return .result := float32(tan(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:988: (9 bytes): return .result := float32.tan(x);
	<tan>  : dup.x32 sp(1)
	<tan+?>: nfc(36) ;float32.tan(x: float32): float32
	<tan+?>: set.x32 sp(3)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:991: (18 bytes): return .result := float32(tan(float64(x)));
	<tan+?>: load.z64
	<tan+?>: dup.x32 sp(3)
	<tan+?>: f32.2f64
	<tan+?>: load.ref <?> ;Math.tan(x: float64): float64
	<tan+?>: call
	<tan+?>: inc.sp(-8)
	<tan+?>: f64.2f32
	<tan+?>: set.x32 sp(3)
	<tan+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:48: referenced as `tan`
}
Math.tanh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'cmplStd/lib/math/Math.ci:995'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the hyperbolic tangent of the radian argument `x`.'
.value: (1) - (2) / (exp((2) * x) + (1))
.usages:
	cmplStd/lib/math/Math.ci:1015: referenced as `tanh`
}
Math.atanh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'atanh'
.file: 'cmplStd/lib/math/Math.ci:998'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic tangent of the radian argument `x`.'
.value: x >= (1) ? inf : x <= (-1) ? -inf : 0.500000 * log(((1) + x) / ((1) - x))
.usages:
}
Math.cot(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 41
.name: 'cot'
.file: 'cmplStd/lib/math/Math.ci:1002'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the cotangent of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.cot)) != null) {
		return .result := float64.cot(x);
	}
	if (x == (0)) {
		return .result := inf;
	}
	return .result := tancot(x, 1);
}
.instructions: (41 bytes)
	cmplStd/lib/math/Math.ci:1008: (20 bytes): if (x == (0))
	<cot>  : dup.x64 sp(1)
	<cot+?>: load.z64
	<cot+?>: ceq.f64
	<cot+?>: jz +16
	cmplStd/lib/math/Math.ci:1009: (12 bytes): return .result := inf;
	<cot+?>: load.f64 inf
	<cot+?>: set.x64 sp(5)
	<cot+?>: ret
	cmplStd/lib/math/Math.ci:1011: (21 bytes): return .result := tancot(x, 1);
	<cot+?>: load.z64
	<cot+?>: dup.x64 sp(3)
	<cot+?>: load.c32 1
	<cot+?>: load.ref <?> ;Math.tancot(x: float64, flag: int32): float64
	<cot+?>: call
	<cot+?>: inc.sp(-12)
	<cot+?>: set.x64 sp(5)
	<cot+?>: ret
.usages:
}
Math.coth(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'cmplStd/lib/math/Math.ci:1015'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the hyperbolic cotangent of the radian argument `x`.'
.value: (1) / tanh(x)
.usages:
}
Math.acot(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acot'
.file: 'cmplStd/lib/math/Math.ci:1018'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse cotangent of the radian argument `x`.'
.value: x == (0) ? pi / (2) : atan((1) / x)
.usages:
}
Math.acoth(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acoth'
.file: 'cmplStd/lib/math/Math.ci:1021'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic cotangent of the radian argument `x`.'
.value: x == (1) ? inf : x == (-1) ? -inf : 0.500000 * log((x + (1)) / (x - (1)))
.usages:
}
Math.sec(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'cmplStd/lib/math/Math.ci:1025'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the secant of the radian argument `x`.'
.value: (1) / cos(x)
.usages:
}
Math.sech(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'cmplStd/lib/math/Math.ci:1028'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the hyperbolic secant of the radian argument `x`.'
.value: (1) / cosh(x)
.usages:
}
Math.asec(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asec'
.file: 'cmplStd/lib/math/Math.ci:1031'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse secant of the radian argument `x`.'
.value: x == (0) ? inf : acos((1) / x)
.usages:
}
Math.asech(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asech'
.file: 'cmplStd/lib/math/Math.ci:1034'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic secant of the radian argument `x`.'
.value: x == (0) ? inf : x == (1) ? (0) : log((sqrt((1) - x * x) + (1)) / x)
.usages:
}
Math.csc(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'cmplStd/lib/math/Math.ci:1038'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the cosecant of the radian argument `x`.'
.value: (1) / sin(x)
.usages:
}
Math.csch(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'cmplStd/lib/math/Math.ci:1041'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the hyperbolic cosecant of the radian argument `x`.'
.value: (1) / sinh(x)
.usages:
}
Math.acsc(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acsc'
.file: 'cmplStd/lib/math/Math.ci:1044'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse cosecant of the radian argument `x`.'
.value: x == (0) ? inf : asin((1) / x)
.usages:
}
Math.acsch(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acsch'
.file: 'cmplStd/lib/math/Math.ci:1047'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic cosecant of the radian argument `x`.'
.value: x == (0) ? inf : x < (0) ? log(((1) - sqrt((1) + x * x)) / x) : log(((1) + sqrt((1) + x * x)) / x)
.usages:
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'radians'
.file: 'cmplStd/lib/math/Math.ci:1051'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param degrees: float64 (size: 8, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(degrees * pi / (180))
.usages:
	cmplGfx/lib/camera.ci:28: referenced as `radians`
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'degrees'
.file: 'cmplStd/lib/math/Math.ci:1054'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param radians: float64 (size: 8, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(radians * (180) / pi)
.usages:
}
Fixed: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Fixed'
.file: 'cmplStd/lib/math/Fixed.ci:2'
.field value: int32 (size: 4, cast: variable(i32))
.field precision: int32 (size: 0, cast: static const val)
.field one: int32 (size: 0, cast: static const val)
.field nan: int32 (size: 0, cast: static const val)
.field inf: int32 (size: 0, cast: static const val)
.field half: int32 (size: 0, cast: static const val)
.field mask: int32 (size: 0, cast: static const val)
.field pow2max: int32 (size: 0, cast: static const val)
.field mpi_28: int32 (size: 0, cast: static const val)
.field ln2_28: int32 (size: 0, cast: static const val)
.field lg2_28: int32 (size: 0, cast: static const val)
.field l2e_28: int32 (size: 0, cast: static const val)
.field l2t_28: int32 (size: 0, cast: static const val)
.field d2r_28: int32 (size: 0, cast: static const val)
.field r2d_24: int32 (size: 0, cast: static const val)
.field piMul2: int32 (size: 0, cast: static const val)
.field piDiv2: int32 (size: 0, cast: static const val)
.field pi: int32 (size: 0, cast: static const val)
.field ln2: int32 (size: 0, cast: static const val)
.field lg2: int32 (size: 0, cast: static const val)
.field l2e: int32 (size: 0, cast: static const val)
.field l2t: int32 (size: 0, cast: static const val)
.field as: function (size: 4, cast: static function)
.field neg: function (size: 6, cast: static function)
.field add: function (size: 8, cast: static function)
.field sub: function (size: 8, cast: static function)
.field mul: function (size: 17, cast: static function)
.field mul: function (size: 8, cast: static function)
.field mul_28: function (size: 17, cast: static function)
.field div: function (size: 94, cast: static function)
.field div: function (size: 8, cast: static function)
.field mod: function (size: 8, cast: static function)
.field inv: function (size: 95, cast: static function)
.field fract: function (size: 34, cast: static function)
.field floor: function (size: 12, cast: static function)
.field ceil: function (size: 47, cast: static function)
.field round: function (size: 37, cast: static function)
.field isFinite: function (size: 68, cast: static function)
.field isNan: function (size: 14, cast: static function)
.field compare: function (size: 14, cast: static function)
.field log2: function (size: 194, cast: static function)
.field log: function (size: 63, cast: static function)
.field log10: function (size: 63, cast: static function)
.field log: function (size: 99, cast: static function)
.field pow2: function (size: 216, cast: static function)
.field exp: function (size: 38, cast: static function)
.field exp10: function (size: 38, cast: static function)
.field sqrt: function (size: 175, cast: static function)
.field pow: function (size: 410, cast: static function)
.field horner: function (size: 0, cast: static inline)
.field horner: function (size: 0, cast: static inline)
.field horner: function (size: 0, cast: static inline)
.field horner: function (size: 0, cast: static inline)
.field horner: function (size: 0, cast: static inline)
.field sin: function (size: 250, cast: static function)
.field sinh: function (size: 129, cast: static function)
.field cos: function (size: 234, cast: static function)
.field tan: function (size: 49, cast: static function)
.field degrees: function (size: 37, cast: static function)
.field radians: function (size: 24, cast: static function)
.doc: 'simple fixed point, `precision` bits used for decimal part, the rest for integer part'
.usages:
	cmplStd/lib/math/Fixed.ci:761: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:757: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:754: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:751: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:750: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:742: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:739: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:736: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:734: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:733: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:733: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:733: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:732: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:728: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:728: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:725: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:725: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:719: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:719: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:714: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:714: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:605: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:605: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:530: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:530: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:490: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:490: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:451: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:451: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:382: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:382: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:382: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:346: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:346: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:334: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:334: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:322: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:322: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:254: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:254: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:231: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:231: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:231: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:215: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:215: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:198: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:198: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:134: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:134: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:121: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:121: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:116: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:103: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:98: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:98: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:93: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:93: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:88: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:88: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:80: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:80: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:67: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:67: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:64: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:64: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:64: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:61: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:61: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:52: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:52: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:52: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:49: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:49: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:48: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:48: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:47: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:47: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:47: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:44: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:44: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:44: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:41: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:41: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:41: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:38: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:38: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:35: referenced as `Fixed`
}
Fixed.value: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'value'
.file: 'cmplStd/lib/math/Fixed.ci:3'
.owner: Fixed
.value: 0
.usages:
	cmplStd/lib/math/Fixed.ci:761: referenced as `value`
	cmplStd/lib/math/Fixed.ci:757: referenced as `value`
	cmplStd/lib/math/Fixed.ci:754: referenced as `value`
	cmplStd/lib/math/Fixed.ci:751: referenced as `value`
	cmplStd/lib/math/Fixed.ci:742: referenced as `value`
	cmplStd/lib/math/Fixed.ci:739: referenced as `value`
	cmplStd/lib/math/Fixed.ci:736: referenced as `value`
	cmplStd/lib/math/Fixed.ci:734: referenced as `value`
	cmplStd/lib/math/Fixed.ci:728: referenced as `value`
	cmplStd/lib/math/Fixed.ci:715: referenced as `value`
	cmplStd/lib/math/Fixed.ci:562: referenced as `value`
	cmplStd/lib/math/Fixed.ci:562: referenced as `value`
	cmplStd/lib/math/Fixed.ci:557: referenced as `value`
	cmplStd/lib/math/Fixed.ci:556: referenced as `value`
	cmplStd/lib/math/Fixed.ci:551: referenced as `value`
	cmplStd/lib/math/Fixed.ci:551: referenced as `value`
	cmplStd/lib/math/Fixed.ci:550: referenced as `value`
	cmplStd/lib/math/Fixed.ci:546: referenced as `value`
	cmplStd/lib/math/Fixed.ci:545: referenced as `value`
	cmplStd/lib/math/Fixed.ci:544: referenced as `value`
	cmplStd/lib/math/Fixed.ci:495: referenced as `value`
	cmplStd/lib/math/Fixed.ci:484: referenced as `value`
	cmplStd/lib/math/Fixed.ci:484: referenced as `value`
	cmplStd/lib/math/Fixed.ci:480: referenced as `value`
	cmplStd/lib/math/Fixed.ci:480: referenced as `value`
	cmplStd/lib/math/Fixed.ci:479: referenced as `value`
	cmplStd/lib/math/Fixed.ci:474: referenced as `value`
	cmplStd/lib/math/Fixed.ci:473: referenced as `value`
	cmplStd/lib/math/Fixed.ci:468: referenced as `value`
	cmplStd/lib/math/Fixed.ci:467: referenced as `value`
	cmplStd/lib/math/Fixed.ci:466: referenced as `value`
	cmplStd/lib/math/Fixed.ci:437: referenced as `value`
	cmplStd/lib/math/Fixed.ci:428: referenced as `value`
	cmplStd/lib/math/Fixed.ci:428: referenced as `value`
	cmplStd/lib/math/Fixed.ci:428: referenced as `value`
	cmplStd/lib/math/Fixed.ci:427: referenced as `value`
	cmplStd/lib/math/Fixed.ci:425: referenced as `value`
	cmplStd/lib/math/Fixed.ci:408: referenced as `value`
	cmplStd/lib/math/Fixed.ci:401: referenced as `value`
	cmplStd/lib/math/Fixed.ci:396: referenced as `value`
	cmplStd/lib/math/Fixed.ci:396: referenced as `value`
	cmplStd/lib/math/Fixed.ci:392: referenced as `value`
	cmplStd/lib/math/Fixed.ci:388: referenced as `value`
	cmplStd/lib/math/Fixed.ci:383: referenced as `value`
	cmplStd/lib/math/Fixed.ci:383: referenced as `value`
	cmplStd/lib/math/Fixed.ci:367: referenced as `value`
	cmplStd/lib/math/Fixed.ci:354: referenced as `value`
	cmplStd/lib/math/Fixed.ci:353: referenced as `value`
	cmplStd/lib/math/Fixed.ci:317: referenced as `value`
	cmplStd/lib/math/Fixed.ci:312: referenced as `value`
	cmplStd/lib/math/Fixed.ci:311: referenced as `value`
	cmplStd/lib/math/Fixed.ci:306: referenced as `value`
	cmplStd/lib/math/Fixed.ci:299: referenced as `value`
	cmplStd/lib/math/Fixed.ci:296: referenced as `value`
	cmplStd/lib/math/Fixed.ci:194: referenced as `value`
	cmplStd/lib/math/Fixed.ci:190: referenced as `value`
	cmplStd/lib/math/Fixed.ci:189: referenced as `value`
	cmplStd/lib/math/Fixed.ci:185: referenced as `value`
	cmplStd/lib/math/Fixed.ci:185: referenced as `value`
	cmplStd/lib/math/Fixed.ci:183: referenced as `value`
	cmplStd/lib/math/Fixed.ci:180: referenced as `value`
	cmplStd/lib/math/Fixed.ci:178: referenced as `value`
	cmplStd/lib/math/Fixed.ci:177: referenced as `value`
	cmplStd/lib/math/Fixed.ci:176: referenced as `value`
	cmplStd/lib/math/Fixed.ci:122: referenced as `value`
	cmplStd/lib/math/Fixed.ci:122: referenced as `value`
	cmplStd/lib/math/Fixed.ci:122: referenced as `value`
	cmplStd/lib/math/Fixed.ci:122: referenced as `value`
	cmplStd/lib/math/Fixed.ci:117: referenced as `value`
	cmplStd/lib/math/Fixed.ci:110: referenced as `value`
	cmplStd/lib/math/Fixed.ci:107: referenced as `value`
	cmplStd/lib/math/Fixed.ci:104: referenced as `value`
	cmplStd/lib/math/Fixed.ci:99: referenced as `value`
	cmplStd/lib/math/Fixed.ci:89: referenced as `value`
	cmplStd/lib/math/Fixed.ci:89: referenced as `value`
	cmplStd/lib/math/Fixed.ci:84: referenced as `value`
	cmplStd/lib/math/Fixed.ci:84: referenced as `value`
	cmplStd/lib/math/Fixed.ci:82: referenced as `value`
	cmplStd/lib/math/Fixed.ci:82: referenced as `value`
	cmplStd/lib/math/Fixed.ci:81: referenced as `value`
	cmplStd/lib/math/Fixed.ci:75: referenced as `value`
	cmplStd/lib/math/Fixed.ci:73: referenced as `value`
	cmplStd/lib/math/Fixed.ci:71: referenced as `value`
	cmplStd/lib/math/Fixed.ci:69: referenced as `value`
	cmplStd/lib/math/Fixed.ci:68: referenced as `value`
	cmplStd/lib/math/Fixed.ci:64: referenced as `value`
	cmplStd/lib/math/Fixed.ci:64: referenced as `value`
	cmplStd/lib/math/Fixed.ci:64: referenced as `value`
	cmplStd/lib/math/Fixed.ci:61: referenced as `value`
	cmplStd/lib/math/Fixed.ci:61: referenced as `value`
	cmplStd/lib/math/Fixed.ci:59: referenced as `value`
	cmplStd/lib/math/Fixed.ci:59: referenced as `value`
	cmplStd/lib/math/Fixed.ci:59: referenced as `value`
	cmplStd/lib/math/Fixed.ci:57: referenced as `value`
	cmplStd/lib/math/Fixed.ci:54: referenced as `value`
	cmplStd/lib/math/Fixed.ci:53: referenced as `value`
	cmplStd/lib/math/Fixed.ci:49: referenced as `value`
	cmplStd/lib/math/Fixed.ci:49: referenced as `value`
	cmplStd/lib/math/Fixed.ci:48: referenced as `value`
	cmplStd/lib/math/Fixed.ci:48: referenced as `value`
	cmplStd/lib/math/Fixed.ci:47: referenced as `value`
	cmplStd/lib/math/Fixed.ci:47: referenced as `value`
	cmplStd/lib/math/Fixed.ci:47: referenced as `value`
	cmplStd/lib/math/Fixed.ci:44: referenced as `value`
	cmplStd/lib/math/Fixed.ci:44: referenced as `value`
	cmplStd/lib/math/Fixed.ci:44: referenced as `value`
	cmplStd/lib/math/Fixed.ci:41: referenced as `value`
	cmplStd/lib/math/Fixed.ci:41: referenced as `value`
	cmplStd/lib/math/Fixed.ci:41: referenced as `value`
	cmplStd/lib/math/Fixed.ci:38: referenced as `value`
	cmplStd/lib/math/Fixed.ci:38: referenced as `value`
	cmplStd/lib/math/Fixed.ci:35: referenced as `value`
}
Fixed.precision: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'precision'
.file: 'cmplStd/lib/math/Fixed.ci:6'
.owner: Fixed
.doc: 'precision'
.value: 20
.usages:
	cmplStd/lib/math/Fixed.ci:761: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:733: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:728: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:725: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:562: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:484: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:444: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:434: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:432: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:428: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:368: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:360: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:317: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:317: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:310: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:312: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:311: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:309: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:307: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:306: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:194: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:194: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:194: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:187: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:184: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:71: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:59: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:47: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:33: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:30: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:29: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:28: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:27: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:26: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:24: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:23: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:13: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:13: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:8: referenced as `precision`
}
Fixed.one: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'one'
.file: 'cmplStd/lib/math/Fixed.ci:8'
.owner: Fixed
.doc: 'one'
.value: 1048576
.usages:
	cmplStd/lib/math/Fixed.ci:541: referenced as `one`
	cmplStd/lib/math/Fixed.ci:540: referenced as `one`
	cmplStd/lib/math/Fixed.ci:539: referenced as `one`
	cmplStd/lib/math/Fixed.ci:538: referenced as `one`
	cmplStd/lib/math/Fixed.ci:537: referenced as `one`
	cmplStd/lib/math/Fixed.ci:536: referenced as `one`
	cmplStd/lib/math/Fixed.ci:463: referenced as `one`
	cmplStd/lib/math/Fixed.ci:462: referenced as `one`
	cmplStd/lib/math/Fixed.ci:461: referenced as `one`
	cmplStd/lib/math/Fixed.ci:460: referenced as `one`
	cmplStd/lib/math/Fixed.ci:459: referenced as `one`
	cmplStd/lib/math/Fixed.ci:458: referenced as `one`
	cmplStd/lib/math/Fixed.ci:426: referenced as `one`
	cmplStd/lib/math/Fixed.ci:388: referenced as `one`
	cmplStd/lib/math/Fixed.ci:386: referenced as `one`
	cmplStd/lib/math/Fixed.ci:383: referenced as `one`
	cmplStd/lib/math/Fixed.ci:71: referenced as `one`
	cmplStd/lib/math/Fixed.ci:12: referenced as `one`
	cmplStd/lib/math/Fixed.ci:11: referenced as `one`
}
Fixed.nan: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'nan'
.file: 'cmplStd/lib/math/Fixed.ci:9'
.owner: Fixed
.doc: 'nan'
.value: (2147483648)
.usages:
	cmplStd/lib/math/Fixed.ci:751: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:736: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:734: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:399: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:396: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:396: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:355: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:180: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:117: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:104: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:84: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:55: referenced as `nan`
}
Fixed.inf: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'inf'
.file: 'cmplStd/lib/math/Fixed.ci:10'
.owner: Fixed
.doc: 'inf'
.value: 2147483647
.usages:
	cmplStd/lib/math/Fixed.ci:757: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:754: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:742: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:739: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:409: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:297: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:178: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:110: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:107: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:73: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:73: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:69: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:57: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:57: referenced as `inf`
}
Fixed.half: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'half'
.file: 'cmplStd/lib/math/Fixed.ci:11'
.owner: Fixed
.doc: 'half'
.value: 524288
.usages:
	cmplStd/lib/math/Fixed.ci:392: referenced as `half`
	cmplStd/lib/math/Fixed.ci:99: referenced as `half`
}
Fixed.mask: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'mask'
.file: 'cmplStd/lib/math/Fixed.ci:12'
.owner: Fixed
.doc: 'mask'
.value: 1048575
.usages:
	cmplStd/lib/math/Fixed.ci:425: referenced as `mask`
	cmplStd/lib/math/Fixed.ci:89: referenced as `mask`
	cmplStd/lib/math/Fixed.ci:84: referenced as `mask`
	cmplStd/lib/math/Fixed.ci:82: referenced as `mask`
}
Fixed.pow2max: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'pow2max'
.file: 'cmplStd/lib/math/Fixed.ci:13'
.owner: Fixed
.doc: 'pow2max'
.value: 11534336
.usages:
	cmplStd/lib/math/Fixed.ci:299: referenced as `pow2max`
	cmplStd/lib/math/Fixed.ci:296: referenced as `pow2max`
}
Fixed.mpi_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'mpi_28'
.file: 'cmplStd/lib/math/Fixed.ci:15'
.owner: Fixed
.doc: 'mpi_28'
.value: 843314856
.usages:
	cmplStd/lib/math/Fixed.ci:26: referenced as `mpi_28`
	cmplStd/lib/math/Fixed.ci:24: referenced as `mpi_28`
	cmplStd/lib/math/Fixed.ci:23: referenced as `mpi_28`
}
Fixed.ln2_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'ln2_28'
.file: 'cmplStd/lib/math/Fixed.ci:16'
.owner: Fixed
.doc: 'ln2_28'
.value: 186065279
.usages:
	cmplStd/lib/math/Fixed.ci:211: referenced as `ln2_28`
	cmplStd/lib/math/Fixed.ci:27: referenced as `ln2_28`
}
Fixed.lg2_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'lg2_28'
.file: 'cmplStd/lib/math/Fixed.ci:17'
.owner: Fixed
.doc: 'lg2_28'
.value: 80807124
.usages:
	cmplStd/lib/math/Fixed.ci:227: referenced as `lg2_28`
	cmplStd/lib/math/Fixed.ci:28: referenced as `lg2_28`
}
Fixed.l2e_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'l2e_28'
.file: 'cmplStd/lib/math/Fixed.ci:18'
.owner: Fixed
.doc: 'l2e_28'
.value: 387270501
.usages:
	cmplStd/lib/math/Fixed.ci:330: referenced as `l2e_28`
	cmplStd/lib/math/Fixed.ci:29: referenced as `l2e_28`
}
Fixed.l2t_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'l2t_28'
.file: 'cmplStd/lib/math/Fixed.ci:19'
.owner: Fixed
.doc: 'l2t_28'
.value: 891723282
.usages:
	cmplStd/lib/math/Fixed.ci:342: referenced as `l2t_28`
	cmplStd/lib/math/Fixed.ci:30: referenced as `l2t_28`
}
Fixed.d2r_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'd2r_28'
.file: 'cmplStd/lib/math/Fixed.ci:20'
.owner: Fixed
.doc: 'd2r_28'
.value: 4685082
.usages:
	cmplStd/lib/math/Fixed.ci:720: referenced as `d2r_28`
}
Fixed.r2d_24: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'r2d_24'
.file: 'cmplStd/lib/math/Fixed.ci:21'
.owner: Fixed
.doc: 'r2d_24'
.value: 961263668
.usages:
	cmplStd/lib/math/Fixed.ci:715: referenced as `r2d_24`
}
Fixed.piMul2: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'piMul2'
.file: 'cmplStd/lib/math/Fixed.ci:23'
.owner: Fixed
.doc: 'piMul2'
.value: 6588397
.usages:
	cmplStd/lib/math/Fixed.ci:551: referenced as `piMul2`
	cmplStd/lib/math/Fixed.ci:546: referenced as `piMul2`
	cmplStd/lib/math/Fixed.ci:544: referenced as `piMul2`
	cmplStd/lib/math/Fixed.ci:468: referenced as `piMul2`
	cmplStd/lib/math/Fixed.ci:466: referenced as `piMul2`
}
Fixed.piDiv2: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'piDiv2'
.file: 'cmplStd/lib/math/Fixed.ci:24'
.owner: Fixed
.doc: 'piDiv2'
.value: 1647099
.usages:
	cmplStd/lib/math/Fixed.ci:556: referenced as `piDiv2`
	cmplStd/lib/math/Fixed.ci:479: referenced as `piDiv2`
}
Fixed.pi: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'pi'
.file: 'cmplStd/lib/math/Fixed.ci:26'
.owner: Fixed
.doc: 'pi'
.value: 3294198
.usages:
	cmplStd/lib/math/Fixed.ci:557: referenced as `pi`
	cmplStd/lib/math/Fixed.ci:550: referenced as `pi`
	cmplStd/lib/math/Fixed.ci:480: referenced as `pi`
	cmplStd/lib/math/Fixed.ci:474: referenced as `pi`
	cmplStd/lib/math/Fixed.ci:473: referenced as `pi`
}
Fixed.ln2: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'ln2'
.file: 'cmplStd/lib/math/Fixed.ci:27'
.owner: Fixed
.doc: 'ln2'
.value: 726817
.usages:
}
Fixed.lg2: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'lg2'
.file: 'cmplStd/lib/math/Fixed.ci:28'
.owner: Fixed
.doc: 'lg2'
.value: 315652
.usages:
}
Fixed.l2e: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'l2e'
.file: 'cmplStd/lib/math/Fixed.ci:29'
.owner: Fixed
.doc: 'l2e'
.value: 1512775
.usages:
}
Fixed.l2t: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'l2t'
.file: 'cmplStd/lib/math/Fixed.ci:30'
.owner: Fixed
.doc: 'l2t'
.value: 3483294
.usages:
}
Fixed.as(value: int32): Fixed: function {
.kind: static function
.base: `function`
.size: 4
.name: 'as'
.file: 'cmplStd/lib/math/Fixed.ci:35'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param value: int32 (size: 4, cast: variable(i32))
.value: {
	return .result := {
			.result.value := value;
		};
}
.instructions: (4 bytes)
	cmplStd/lib/math/Fixed.ci:35: (4 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:35: (3 bytes): .result.value := value;
	<as>  : mov.x32 sp(2, 1)
	<as+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:733: referenced as `as`
	cmplStd/lib/math/Fixed.ci:725: referenced as `as`
	cmplStd/lib/math/Fixed.ci:715: referenced as `as`
	cmplStd/lib/math/Fixed.ci:564: referenced as `as`
	cmplStd/lib/math/Fixed.ci:496: referenced as `as`
	cmplStd/lib/math/Fixed.ci:486: referenced as `as`
	cmplStd/lib/math/Fixed.ci:437: referenced as `as`
	cmplStd/lib/math/Fixed.ci:437: referenced as `as`
	cmplStd/lib/math/Fixed.ci:411: referenced as `as`
	cmplStd/lib/math/Fixed.ci:409: referenced as `as`
	cmplStd/lib/math/Fixed.ci:399: referenced as `as`
	cmplStd/lib/math/Fixed.ci:386: referenced as `as`
	cmplStd/lib/math/Fixed.ci:378: referenced as `as`
	cmplStd/lib/math/Fixed.ci:357: referenced as `as`
	cmplStd/lib/math/Fixed.ci:355: referenced as `as`
	cmplStd/lib/math/Fixed.ci:318: referenced as `as`
	cmplStd/lib/math/Fixed.ci:303: referenced as `as`
	cmplStd/lib/math/Fixed.ci:297: referenced as `as`
	cmplStd/lib/math/Fixed.ci:99: referenced as `as`
	cmplStd/lib/math/Fixed.ci:57: referenced as `as`
	cmplStd/lib/math/Fixed.ci:55: referenced as `as`
}
Fixed.neg(a: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 6
.name: 'neg'
.file: 'cmplStd/lib/math/Fixed.ci:38'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.doc: 'Computes the negated value of the given number.'
.value: {
	return .result := {
			.result.value := -a.value;
		};
}
.instructions: (6 bytes)
	cmplStd/lib/math/Fixed.ci:38: (6 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:38: (5 bytes): .result.value := -a.value;
	<neg>  : dup.x32 sp(1)
	<neg+?>: neg.i32
	<neg+?>: set.x32 sp(4)
	<neg+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:503: referenced as `neg`
	cmplStd/lib/math/Fixed.ci:94: referenced as `neg`
	cmplStd/lib/math/Fixed.ci:94: referenced as `neg`
}
Fixed.add(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'add'
.file: 'cmplStd/lib/math/Fixed.ci:41'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Adds the two fixed point numbers.'
.value: {
	return .result := {
			.result.value := a.value + b.value;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:41: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:41: (7 bytes): .result.value := a.value + b.value;
	<add>  : dup.x32 sp(3)
	<add+?>: dup.x32 sp(2)
	<add+?>: add.i32
	<add+?>: set.x32 sp(6)
	<add+?>: ret
.usages:
}
Fixed.sub(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'sub'
.file: 'cmplStd/lib/math/Fixed.ci:44'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Subtract one from another fixed point number.'
.value: {
	return .result := {
			.result.value := a.value - b.value;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:44: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:44: (7 bytes): .result.value := a.value - b.value;
	<sub>  : dup.x32 sp(3)
	<sub+?>: dup.x32 sp(2)
	<sub+?>: sub.i32
	<sub+?>: set.x32 sp(6)
	<sub+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:503: referenced as `sub`
}
Fixed.mul(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 17
.name: 'mul'
.file: 'cmplStd/lib/math/Fixed.ci:47'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Multiply two fixed-point numbers.'
.value: {
	return .result := {
			.result.value := ((int64(a.value) * (b.value)) >> precision);
		};
}
.instructions: (17 bytes)
	cmplStd/lib/math/Fixed.ci:47: (17 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:47: (16 bytes): .result.value := ((int64(a.value) * (b.value)) >> precision);
	<mul>  : dup.x32 sp(3)
	<mul+?>: i32.2i64
	<mul+?>: dup.x32 sp(3)
	<mul+?>: i32.2i64
	<mul+?>: mul.i64
	<mul+?>: load.c32 20
	<mul+?>: sar.b64
	<mul+?>: i64.2i32
	<mul+?>: set.x32 sp(6)
	<mul+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:486: referenced as `mul`
	cmplStd/lib/math/Fixed.ci:440: referenced as `mul`
}
Fixed.mul(a: Fixed, b: int32): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'mul'
.file: 'cmplStd/lib/math/Fixed.ci:48'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: int32 (size: 4, cast: variable(i32))
.value: {
	return .result := {
			.result.value := a.value * b;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:48: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:48: (7 bytes): .result.value := a.value * b;
	<mul>  : dup.x32 sp(2)
	<mul+?>: dup.x32 sp(2)
	<mul+?>: mul.i32
	<mul+?>: set.x32 sp(5)
	<mul+?>: ret
.usages:
}
Fixed.mul_28(a: Fixed, b: int32): Fixed: function {
.kind: static function
.base: `function`
.size: 17
.name: 'mul_28'
.file: 'cmplStd/lib/math/Fixed.ci:49'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: int32 (size: 4, cast: variable(i32))
.value: {
	return .result := {
			.result.value := (int64(a.value) * (b) >> 28);
		};
}
.instructions: (17 bytes)
	cmplStd/lib/math/Fixed.ci:49: (17 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:49: (16 bytes): .result.value := (int64(a.value) * (b) >> 28);
	<mul_28>  : dup.x32 sp(2)
	<mul_28+?>: i32.2i64
	<mul_28+?>: dup.x32 sp(3)
	<mul_28+?>: i32.2i64
	<mul_28+?>: mul.i64
	<mul_28+?>: load.c32 28
	<mul_28+?>: sar.b64
	<mul_28+?>: i64.2i32
	<mul_28+?>: set.x32 sp(5)
	<mul_28+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:720: referenced as `mul_28`
	cmplStd/lib/math/Fixed.ci:342: referenced as `mul_28`
	cmplStd/lib/math/Fixed.ci:330: referenced as `mul_28`
	cmplStd/lib/math/Fixed.ci:227: referenced as `mul_28`
	cmplStd/lib/math/Fixed.ci:211: referenced as `mul_28`
}
Fixed.div(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 94
.name: 'div'
.file: 'cmplStd/lib/math/Fixed.ci:52'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Divide one fixed-point number with another one.'
.value: {
	if (b.value == 0) {
		if (a.value == 0) {
			return .result := as(nan);
		}
		return .result := as(a.value < 0 ? -inf : inf);
	}
	return .result := {
			.result.value := ((int64(a.value) << precision) / (b.value));
		};
}
.instructions: (94 bytes)
	cmplStd/lib/math/Fixed.ci:53: (77 bytes): if (b.value == 0)
	<div>  : dup.x32 sp(1)
	<div+?>: load.z32
	<div+?>: ceq.i32
	<div+?>: jz +73
	cmplStd/lib/math/Fixed.ci:54: (30 bytes): if (a.value == 0)
	<div+?>: dup.x32 sp(3)
	<div+?>: load.z32
	<div+?>: ceq.i32
	<div+?>: jz +26
	cmplStd/lib/math/Fixed.ci:55: (22 bytes): return .result := as(nan);
	<div+?>: inc.sp(+8)
	<div+?>: load.c32 -2147483648
	<div+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<div+?>: call
	<div+?>: inc.sp(-4)
	<div+?>: set.x64 sp(7)
	<div+?>: ret
	cmplStd/lib/math/Fixed.ci:57: (39 bytes): return .result := as(a.value < 0 ? -inf : inf);
	<div+?>: inc.sp(+8)
	<div+?>: dup.x32 sp(5)
	<div+?>: load.z32
	<div+?>: clt.i32
	<div+?>: jz +13
	<div+?>: load.c32 -2147483647
	<div+?>: jmp +9
	<div+?>: load.c32 2147483647
	<div+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<div+?>: call
	<div+?>: inc.sp(-4)
	<div+?>: set.x64 sp(7)
	<div+?>: ret
	cmplStd/lib/math/Fixed.ci:59: (17 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:59: (16 bytes): .result.value := ((int64(a.value) << precision) / (b.value));
	<div+?>: dup.x32 sp(3)
	<div+?>: i32.2i64
	<div+?>: load.c32 20
	<div+?>: shl.b64
	<div+?>: dup.x32 sp(3)
	<div+?>: i32.2i64
	<div+?>: div.i64
	<div+?>: i64.2i32
	<div+?>: set.x32 sp(6)
	<div+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:610: referenced as `div`
	cmplStd/lib/math/Fixed.ci:241: referenced as `div`
}
Fixed.div(a: Fixed, b: int32): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'div'
.file: 'cmplStd/lib/math/Fixed.ci:61'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: int32 (size: 4, cast: variable(i32))
.value: {
	return .result := {
			.result.value := a.value / b;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:61: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:61: (7 bytes): .result.value := a.value / b;
	<div>  : dup.x32 sp(2)
	<div+?>: dup.x32 sp(2)
	<div+?>: div.i32
	<div+?>: set.x32 sp(5)
	<div+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:503: referenced as `div`
	cmplStd/lib/math/Fixed.ci:361: referenced as `div`
}
Fixed.mod(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'mod'
.file: 'cmplStd/lib/math/Fixed.ci:64'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the remainder of the division of `a` by `b`.'
.value: {
	return .result := {
			.result.value := a.value % b.value;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:64: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:64: (7 bytes): .result.value := a.value % b.value;
	<mod>  : dup.x32 sp(3)
	<mod+?>: dup.x32 sp(2)
	<mod+?>: mod.i32
	<mod+?>: set.x32 sp(6)
	<mod+?>: ret
.usages:
}
Fixed.inv(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 95
.name: 'inv'
.file: 'cmplStd/lib/math/Fixed.ci:67'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Compute the reciprocal of a complex number (1 / a)'
.value: {
	if (x.value == 0) {
		return .result := {
			.result.value := inf;
		};
	}
	value: int64 := (int64(one) << precision) / (x.value);
	if (value >> 31 != value >> 63) {
		return .result := {
			.result.value := value < (0) ? -inf : inf;
		};
	}
	return .result := {
			.result.value := (value);
		};
}
.instructions: (95 bytes)
	cmplStd/lib/math/Fixed.ci:68: (16 bytes): if (x.value == 0)
	<inv>  : dup.x32 sp(1)
	<inv+?>: load.z32
	<inv+?>: ceq.i32
	<inv+?>: jz +12
	cmplStd/lib/math/Fixed.ci:69: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:69: (7 bytes): .result.value := inf;
	<inv+?>: load.c32 2147483647
	<inv+?>: set.x32 sp(4)
	<inv+?>: ret
	cmplStd/lib/math/Fixed.ci:71: (19 bytes): value: int64 := (int64(one) << precision) / (x.value)
	<inv+?>: load.c64 1048576
	<inv+?>: load.c32 20
	<inv+?>: shl.b64
	<inv+?>: dup.x32 sp(3)
	<inv+?>: i32.2i64
	<inv+?>: div.i64
	cmplStd/lib/math/Fixed.ci:72: (50 bytes): if (value >> 31 != value >> 63)
	<inv+?>: dup.x64 sp(0)
	<inv+?>: load.c32 31
	<inv+?>: sar.b64
	<inv+?>: dup.x64 sp(2)
	<inv+?>: load.c32 63
	<inv+?>: sar.b64
	<inv+?>: ceq.i64
	<inv+?>: jnz +33
	cmplStd/lib/math/Fixed.ci:73: (29 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:73: (24 bytes): .result.value := value < (0) ? -inf : inf;
	<inv+?>: dup.x64 sp(0)
	<inv+?>: load.z64
	<inv+?>: clt.i64
	<inv+?>: jz +13
	<inv+?>: load.c32 -2147483647
	<inv+?>: jmp +9
	<inv+?>: load.c32 2147483647
	<inv+?>: set.x32 sp(6)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
	cmplStd/lib/math/Fixed.ci:75: (10 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:75: (5 bytes): .result.value := (value);
	<inv+?>: dup.x64 sp(0)
	<inv+?>: i64.2i32
	<inv+?>: set.x32 sp(6)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:437: referenced as `inv`
}
Fixed.fract(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 34
.name: 'fract'
.file: 'cmplStd/lib/math/Fixed.ci:80'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the fractional part of the fixed point number'
.value: {
	if (x.value < 0) {
		return .result := {
			.result.value := -(-x.value & mask);
		};
	}
	return .result := {
			.result.value := x.value & (nan | mask);
		};
}
.instructions: (34 bytes)
	cmplStd/lib/math/Fixed.ci:81: (17 bytes): if (x.value < 0)
	<fract>  : dup.x32 sp(1)
	<fract+?>: load.z32
	<fract+?>: clt.i32
	<fract+?>: jz +13
	cmplStd/lib/math/Fixed.ci:82: (9 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:82: (8 bytes): .result.value := -(-x.value & mask);
	<fract+?>: dup.x32 sp(1)
	<fract+?>: neg.i32
	<fract+?>: b32.and 0xfffff
	<fract+?>: neg.i32
	<fract+?>: set.x32 sp(4)
	<fract+?>: ret
	cmplStd/lib/math/Fixed.ci:84: (17 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:84: (16 bytes): .result.value := x.value & (nan | mask);
	<fract+?>: dup.x32 sp(1)
	<fract+?>: load.c32 -2147483648
	<fract+?>: load.c32 1048575
	<fract+?>: or.b32
	<fract+?>: and.b32
	<fract+?>: set.x32 sp(4)
	<fract+?>: ret
.usages:
}
Fixed.floor(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 12
.name: 'floor'
.file: 'cmplStd/lib/math/Fixed.ci:88'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Computes the largest integer that is less than or equal to `x`.'
.value: {
	return .result := {
			.result.value := x.value & ~mask;
		};
}
.instructions: (12 bytes)
	cmplStd/lib/math/Fixed.ci:89: (12 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:89: (11 bytes): .result.value := x.value & ~mask;
	<floor>  : dup.x32 sp(1)
	<floor+?>: load.c32 1048575
	<floor+?>: cmt.b32
	<floor+?>: and.b32
	<floor+?>: set.x32 sp(4)
	<floor+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:99: referenced as `floor`
	cmplStd/lib/math/Fixed.ci:94: referenced as `floor`
}
Fixed.ceil(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 47
.name: 'ceil'
.file: 'cmplStd/lib/math/Fixed.ci:93'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Computes the smallest integer that is greater than or equal to `x`.'
.value: {
	return .result := neg(floor(neg(x)));
}
.instructions: (47 bytes)
	cmplStd/lib/math/Fixed.ci:94: (47 bytes): return .result := neg(floor(neg(x)));
	<ceil>  : inc.sp(+8)
	<ceil+?>: inc.sp(+8)
	<ceil+?>: inc.sp(+8)
	<ceil+?>: dup.x64 sp(7)
	<ceil+?>: load.ref <?> ;Fixed.neg(a: Fixed): Fixed
	<ceil+?>: call
	<ceil+?>: inc.sp(-8)
	<ceil+?>: load.ref <?> ;Fixed.floor(x: Fixed): Fixed
	<ceil+?>: call
	<ceil+?>: inc.sp(-8)
	<ceil+?>: load.ref <?> ;Fixed.neg(a: Fixed): Fixed
	<ceil+?>: call
	<ceil+?>: inc.sp(-8)
	<ceil+?>: set.x64 sp(5)
	<ceil+?>: ret
.usages:
}
Fixed.round(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 37
.name: 'round'
.file: 'cmplStd/lib/math/Fixed.ci:98'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Computes the nearest integer to `x`.'
.value: {
	return .result := floor(as(x.value + half));
}
.instructions: (37 bytes)
	cmplStd/lib/math/Fixed.ci:99: (37 bytes): return .result := floor(as(x.value + half));
	<round>  : inc.sp(+8)
	<round+?>: inc.sp(+8)
	<round+?>: dup.x32 sp(5)
	<round+?>: inc.i32(+524288)
	<round+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<round+?>: call
	<round+?>: inc.sp(-4)
	<round+?>: load.ref <?> ;Fixed.floor(x: Fixed): Fixed
	<round+?>: call
	<round+?>: inc.sp(-8)
	<round+?>: set.x64 sp(5)
	<round+?>: ret
.usages:
}
Fixed.isFinite(x: Fixed): bool: function {
.kind: static function
.base: `function`
.size: 68
.name: 'isFinite'
.file: 'cmplStd/lib/math/Fixed.ci:103'
.owner: Fixed
.param .result: bool (size: 4, cast: variable(bool))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Determines whether the given fixed point value is finite: `!isNan(x) && !isInf(x)`'
.value: {
	if (x.value == nan) {
		return .result := false;
	}
	if (x.value == inf) {
		return .result := false;
	}
	if (x.value == -inf) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (68 bytes)
	cmplStd/lib/math/Fixed.ci:104: (19 bytes): if (x.value == nan)
	<isFinite>  : dup.x32 sp(1)
	<isFinite+?>: load.c32 -2147483648
	<isFinite+?>: ceq.i32
	<isFinite+?>: jz +11
	cmplStd/lib/math/Fixed.ci:105: (7 bytes): return .result := false;
	<isFinite+?>: load.z32
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
	cmplStd/lib/math/Fixed.ci:107: (19 bytes): if (x.value == inf)
	<isFinite+?>: dup.x32 sp(1)
	<isFinite+?>: load.c32 2147483647
	<isFinite+?>: ceq.i32
	<isFinite+?>: jz +11
	cmplStd/lib/math/Fixed.ci:108: (7 bytes): return .result := false;
	<isFinite+?>: load.z32
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
	cmplStd/lib/math/Fixed.ci:110: (19 bytes): if (x.value == -inf)
	<isFinite+?>: dup.x32 sp(1)
	<isFinite+?>: load.c32 -2147483647
	<isFinite+?>: ceq.i32
	<isFinite+?>: jz +11
	cmplStd/lib/math/Fixed.ci:111: (7 bytes): return .result := false;
	<isFinite+?>: load.z32
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
	cmplStd/lib/math/Fixed.ci:113: (11 bytes): return .result := true;
	<isFinite+?>: load.c32 1
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:498: referenced as `isFinite`
	cmplStd/lib/math/Fixed.ci:238: referenced as `isFinite`
	cmplStd/lib/math/Fixed.ci:234: referenced as `isFinite`
	cmplStd/lib/math/Fixed.ci:224: referenced as `isFinite`
	cmplStd/lib/math/Fixed.ci:207: referenced as `isFinite`
}
Fixed.isNan(x: Fixed): bool: function {
.kind: static function
.base: `function`
.size: 14
.name: 'isNan'
.file: 'cmplStd/lib/math/Fixed.ci:116'
.owner: Fixed
.param .result: bool (size: 4, cast: variable(bool))
.param x: Fixed (size: 8, cast: variable(val))
.value: {
	return .result := x.value == nan;
}
.instructions: (14 bytes)
	cmplStd/lib/math/Fixed.ci:117: (14 bytes): return .result := x.value == nan;
	<isNan>  : dup.x32 sp(1)
	<isNan+?>: load.c32 -2147483648
	<isNan+?>: ceq.i32
	<isNan+?>: load.sp(+16)
	<isNan+?>: store.i8
	<isNan+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:300: referenced as `isNan`
}
Fixed.compare(a: Fixed, b: Fixed): int32: function {
.kind: static function
.base: `function`
.size: 14
.name: 'compare'
.file: 'cmplStd/lib/math/Fixed.ci:121'
.owner: Fixed
.param .result: int32 (size: 4, cast: variable(i32))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Determines whether the given fixed point is less than the other one.'
.value: {
	return .result := int32(a.value < b.value) - int32(a.value > b.value);
}
.instructions: (14 bytes)
	cmplStd/lib/math/Fixed.ci:122: (14 bytes): return .result := int32(a.value < b.value) - int32(a.value > b.value);
	<compare>  : dup.x32 sp(3)
	<compare+?>: dup.x32 sp(2)
	<compare+?>: clt.i32
	<compare+?>: dup.x32 sp(4)
	<compare+?>: dup.x32 sp(3)
	<compare+?>: cgt.i32
	<compare+?>: sub.i32
	<compare+?>: set.x32 sp(6)
	<compare+?>: ret
.usages:
}
Fixed.log2(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 194
.name: 'log2'
.file: 'cmplStd/lib/math/Fixed.ci:134'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the binary logarithm of the argument `x`.
	log2(x) = log2((2 ** n) * ((x / 2) ** n)) =
	= log2(2 ** n) + log2((x / 2) ** n) = n + log2(q)
	n = most significant bit of x (BSR (bit scan reverse))
	q = (x / 2) ** n = (x > 1) ? (x >> n) : (x << -n)
	x > 1 <=> n - precision > 0
	log2(q) = look up from table'
.value: {
	static const tbl_log2: uint32[257] := {
		tbl_log2[0] := (0);
		tbl_log2[1] := (6039313);
		tbl_log2[2] := (12055173);
		tbl_log2[3] := (18047761);
		tbl_log2[4] := (24017256);
		tbl_log2[5] := (29963835);
		tbl_log2[6] := (35887674);
		tbl_log2[7] := (41788946);
		tbl_log2[8] := (47667822);
		tbl_log2[9] := (53524472);
		tbl_log2[10] := (59359063);
		tbl_log2[11] := (65171760);
		tbl_log2[12] := (70962727);
		tbl_log2[13] := (76732127);
		tbl_log2[14] := (82480119);
		tbl_log2[15] := (88206861);
		tbl_log2[16] := (93912510);
		tbl_log2[17] := (99597221);
		tbl_log2[18] := (105261147);
		tbl_log2[19] := (110904439);
		tbl_log2[20] := (116527248);
		tbl_log2[21] := (122129720);
		tbl_log2[22] := (127712004);
		tbl_log2[23] := (133274243);
		tbl_log2[24] := (138816582);
		tbl_log2[25] := (144339162);
		tbl_log2[26] := (149842123);
		tbl_log2[27] := (155325605);
		tbl_log2[28] := (160789745);
		tbl_log2[29] := (166234678);
		tbl_log2[30] := (171660540);
		tbl_log2[31] := (177067464);
		tbl_log2[32] := (182455580);
		tbl_log2[33] := (187825021);
		tbl_log2[34] := (193175914);
		tbl_log2[35] := (198508387);
		tbl_log2[36] := (203822568);
		tbl_log2[37] := (209118580);
		tbl_log2[38] := (214396547);
		tbl_log2[39] := (219656593);
		tbl_log2[40] := (224898838);
		tbl_log2[41] := (230123403);
		tbl_log2[42] := (235330406);
		tbl_log2[43] := (240519966);
		tbl_log2[44] := (245692198);
		tbl_log2[45] := (250847217);
		tbl_log2[46] := (255985139);
		tbl_log2[47] := (261106076);
		tbl_log2[48] := (266210140);
		tbl_log2[49] := (271297442);
		tbl_log2[50] := (276368091);
		tbl_log2[51] := (281422197);
		tbl_log2[52] := (286459866);
		tbl_log2[53] := (291481206);
		tbl_log2[54] := (296486322);
		tbl_log2[55] := (301475318);
		tbl_log2[56] := (306448299);
		tbl_log2[57] := (311405365);
		tbl_log2[58] := (316346620);
		tbl_log2[59] := (321272163);
		tbl_log2[60] := (326182094);
		tbl_log2[61] := (331076512);
		tbl_log2[62] := (335955515);
		tbl_log2[63] := (340819198);
		tbl_log2[64] := (345667659);
		tbl_log2[65] := (350500992);
		tbl_log2[66] := (355319292);
		tbl_log2[67] := (360122651);
		tbl_log2[68] := (364911161);
		tbl_log2[69] := (369684916);
		tbl_log2[70] := (374444004);
		tbl_log2[71] := (379188516);
		tbl_log2[72] := (383918541);
		tbl_log2[73] := (388634167);
		tbl_log2[74] := (393335482);
		tbl_log2[75] := (398022572);
		tbl_log2[76] := (402695523);
		tbl_log2[77] := (407354419);
		tbl_log2[78] := (411999346);
		tbl_log2[79] := (416630387);
		tbl_log2[80] := (421247625);
		tbl_log2[81] := (425851141);
		tbl_log2[82] := (430441017);
		tbl_log2[83] := (435017333);
		tbl_log2[84] := (439580170);
		tbl_log2[85] := (444129606);
		tbl_log2[86] := (448665721);
		tbl_log2[87] := (453188591);
		tbl_log2[88] := (457698295);
		tbl_log2[89] := (462194907);
		tbl_log2[90] := (466678505);
		tbl_log2[91] := (471149164);
		tbl_log2[92] := (475606957);
		tbl_log2[93] := (480051958);
		tbl_log2[94] := (484484242);
		tbl_log2[95] := (488903880);
		tbl_log2[96] := (493310944);
		tbl_log2[97] := (497705506);
		tbl_log2[98] := (502087636);
		tbl_log2[99] := (506457405);
		tbl_log2[100] := (510814881);
		tbl_log2[101] := (515160135);
		tbl_log2[102] := (519493235);
		tbl_log2[103] := (523814247);
		tbl_log2[104] := (528123240);
		tbl_log2[105] := (532420281);
		tbl_log2[106] := (536705434);
		tbl_log2[107] := (540978766);
		tbl_log2[108] := (545240343);
		tbl_log2[109] := (549490227);
		tbl_log2[110] := (553728484);
		tbl_log2[111] := (557955177);
		tbl_log2[112] := (562170369);
		tbl_log2[113] := (566374122);
		tbl_log2[114] := (570566498);
		tbl_log2[115] := (574747559);
		tbl_log2[116] := (578917365);
		tbl_log2[117] := (583075977);
		tbl_log2[118] := (587223454);
		tbl_log2[119] := (591359857);
		tbl_log2[120] := (595485245);
		tbl_log2[121] := (599599675);
		tbl_log2[122] := (603703206);
		tbl_log2[123] := (607795895);
		tbl_log2[124] := (611877800);
		tbl_log2[125] := (615948977);
		tbl_log2[126] := (620009483);
		tbl_log2[127] := (624059372);
		tbl_log2[128] := (628098702);
		tbl_log2[129] := (632127526);
		tbl_log2[130] := (636145899);
		tbl_log2[131] := (640153876);
		tbl_log2[132] := (644151509);
		tbl_log2[133] := (648138852);
		tbl_log2[134] := (652115958);
		tbl_log2[135] := (656082880);
		tbl_log2[136] := (660039669);
		tbl_log2[137] := (663986377);
		tbl_log2[138] := (667923055);
		tbl_log2[139] := (671849754);
		tbl_log2[140] := (675766525);
		tbl_log2[141] := (679673417);
		tbl_log2[142] := (683570481);
		tbl_log2[143] := (687457765);
		tbl_log2[144] := (691335319);
		tbl_log2[145] := (695203191);
		tbl_log2[146] := (699061430);
		tbl_log2[147] := (702910083);
		tbl_log2[148] := (706749198);
		tbl_log2[149] := (710578821);
		tbl_log2[150] := (714399001);
		tbl_log2[151] := (718209783);
		tbl_log2[152] := (722011213);
		tbl_log2[153] := (725803337);
		tbl_log2[154] := (729586201);
		tbl_log2[155] := (733359850);
		tbl_log2[156] := (737124328);
		tbl_log2[157] := (740879680);
		tbl_log2[158] := (744625950);
		tbl_log2[159] := (748363182);
		tbl_log2[160] := (752091420);
		tbl_log2[161] := (755810706);
		tbl_log2[162] := (759521084);
		tbl_log2[163] := (763222596);
		tbl_log2[164] := (766915284);
		tbl_log2[165] := (770599191);
		tbl_log2[166] := (774274358);
		tbl_log2[167] := (777940826);
		tbl_log2[168] := (781598636);
		tbl_log2[169] := (785247830);
		tbl_log2[170] := (788888447);
		tbl_log2[171] := (792520529);
		tbl_log2[172] := (796144114);
		tbl_log2[173] := (799759243);
		tbl_log2[174] := (803365955);
		tbl_log2[175] := (806964288);
		tbl_log2[176] := (810554283);
		tbl_log2[177] := (814135977);
		tbl_log2[178] := (817709409);
		tbl_log2[179] := (821274616);
		tbl_log2[180] := (824831638);
		tbl_log2[181] := (828380510);
		tbl_log2[182] := (831921270);
		tbl_log2[183] := (835453956);
		tbl_log2[184] := (838978604);
		tbl_log2[185] := (842495250);
		tbl_log2[186] := (846003931);
		tbl_log2[187] := (849504683);
		tbl_log2[188] := (852997541);
		tbl_log2[189] := (856482541);
		tbl_log2[190] := (859959719);
		tbl_log2[191] := (863429109);
		tbl_log2[192] := (866890746);
		tbl_log2[193] := (870344665);
		tbl_log2[194] := (873790900);
		tbl_log2[195] := (877229485);
		tbl_log2[196] := (880660455);
		tbl_log2[197] := (884083842);
		tbl_log2[198] := (887499680);
		tbl_log2[199] := (890908002);
		tbl_log2[200] := (894308843);
		tbl_log2[201] := (897702233);
		tbl_log2[202] := (901088206);
		tbl_log2[203] := (904466794);
		tbl_log2[204] := (907838029);
		tbl_log2[205] := (911201943);
		tbl_log2[206] := (914558569);
		tbl_log2[207] := (917907937);
		tbl_log2[208] := (921250078);
		tbl_log2[209] := (924585025);
		tbl_log2[210] := (927912807);
		tbl_log2[211] := (931233455);
		tbl_log2[212] := (934547001);
		tbl_log2[213] := (937853474);
		tbl_log2[214] := (941152904);
		tbl_log2[215] := (944445322);
		tbl_log2[216] := (947730757);
		tbl_log2[217] := (951009239);
		tbl_log2[218] := (954280797);
		tbl_log2[219] := (957545460);
		tbl_log2[220] := (960803257);
		tbl_log2[221] := (964054217);
		tbl_log2[222] := (967298369);
		tbl_log2[223] := (970535741);
		tbl_log2[224] := (973766362);
		tbl_log2[225] := (976990259);
		tbl_log2[226] := (980207460);
		tbl_log2[227] := (983417994);
		tbl_log2[228] := (986621888);
		tbl_log2[229] := (989819169);
		tbl_log2[230] := (993009864);
		tbl_log2[231] := (996194001);
		tbl_log2[232] := (999371606);
		tbl_log2[233] := (1002542706);
		tbl_log2[234] := (1005707329);
		tbl_log2[235] := (1008865499);
		tbl_log2[236] := (1012017244);
		tbl_log2[237] := (1015162589);
		tbl_log2[238] := (1018301561);
		tbl_log2[239] := (1021434184);
		tbl_log2[240] := (1024560486);
		tbl_log2[241] := (1027680491);
		tbl_log2[242] := (1030794225);
		tbl_log2[243] := (1033901713);
		tbl_log2[244] := (1037002979);
		tbl_log2[245] := (1040098049);
		tbl_log2[246] := (1043186947);
		tbl_log2[247] := (1046269698);
		tbl_log2[248] := (1049346327);
		tbl_log2[249] := (1052416857);
		tbl_log2[250] := (1055481313);
		tbl_log2[251] := (1058539719);
		tbl_log2[252] := (1061592098);
		tbl_log2[253] := (1064638475);
		tbl_log2[254] := (1067678872);
		tbl_log2[255] := (1070713314);
		tbl_log2[256] := (1073741824);
	};
	if (x.value <= 0) {
		if (x.value == 0) {
			return .result := {
			.result.value := -inf;
		};
		}
		return .result := {
			.result.value := nan;
		};
	}
	n: int32 := Bits.scanReverse(x.value);
	static if (precision < 8) {
		error_not_implemented_yet
	}
	idx: uint32 := (n > 8 ? x.value >> n - 8 : x.value << 8 - n) & 255;
	value: int32 := tbl_log2[idx];
	static if (precision > 8) {
		mix: uint32 := (n > 16 ? x.value >> n - 16 : x.value << 16 - n) & 255;
		value := value + (mix * (tbl_log2[idx + (1)] - (value)) >> 8);
	}
	return .result := {
			.result.value := (n - precision << precision) + (value >> 30 - precision);
		};
}
.instructions: (194 bytes)
	cmplStd/lib/math/Fixed.ci:176: (32 bytes): if (x.value <= 0)
	<log2>  : dup.x32 sp(1)
	<log2+?>: load.z32
	<log2+?>: cgt.i32
	<log2+?>: jnz +28
	cmplStd/lib/math/Fixed.ci:177: (16 bytes): if (x.value == 0)
	<log2+?>: dup.x32 sp(1)
	<log2+?>: load.z32
	<log2+?>: ceq.i32
	<log2+?>: jz +12
	cmplStd/lib/math/Fixed.ci:178: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:178: (7 bytes): .result.value := -inf;
	<log2+?>: load.c32 -2147483647
	<log2+?>: set.x32 sp(4)
	<log2+?>: ret
	cmplStd/lib/math/Fixed.ci:180: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:180: (7 bytes): .result.value := nan;
	<log2+?>: load.c32 -2147483648
	<log2+?>: set.x32 sp(4)
	<log2+?>: ret
	cmplStd/lib/math/Fixed.ci:183: (13 bytes): n: int32 := Bits.scanReverse(x.value)
	<log2+?>: load.z32
	<log2+?>: dup.x32 sp(2)
	<log2+?>: load.ref <?> ;Bits.scanReverse(x: uint32): int32
	<log2+?>: call
	<log2+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:185: (38 bytes): idx: uint32 := (n > 8 ? x.value >> n - 8 : x.value << 8 - n) & 255
	<log2+?>: dup.x32 sp(0)
	<log2+?>: load.c32 8
	<log2+?>: cgt.i32
	<log2+?>: jz +17
	<log2+?>: dup.x32 sp(2)
	<log2+?>: dup.x32 sp(1)
	<log2+?>: inc.i32(-8)
	<log2+?>: sar.b32
	<log2+?>: jmp +15
	<log2+?>: dup.x32 sp(2)
	<log2+?>: load.c32 8
	<log2+?>: dup.x32 sp(2)
	<log2+?>: sub.i32
	<log2+?>: shl.b32
	<log2+?>: b32.and 0xff
	cmplStd/lib/math/Fixed.ci:186: (12 bytes): value: int32 := tbl_log2[idx]
	<log2+?>: load.ref <?> ;Fixed.log2.tbl_log2
	<log2+?>: dup.x32 sp(1)
	<log2+?>: mad.u32 4
	<log2+?>: load.i32
	cmplStd/lib/math/Fixed.ci:188: (38 bytes): mix: uint32 := (n > 16 ? x.value >> n - 16 : x.value << 16 - n) & 255
	<log2+?>: dup.x32 sp(2)
	<log2+?>: load.c32 16
	<log2+?>: cgt.i32
	<log2+?>: jz +17
	<log2+?>: dup.x32 sp(4)
	<log2+?>: dup.x32 sp(3)
	<log2+?>: inc.i32(-16)
	<log2+?>: sar.b32
	<log2+?>: jmp +15
	<log2+?>: dup.x32 sp(4)
	<log2+?>: load.c32 16
	<log2+?>: dup.x32 sp(4)
	<log2+?>: sub.i32
	<log2+?>: shl.b32
	<log2+?>: b32.and 0xff
	cmplStd/lib/math/Fixed.ci:192: (29 bytes): value := value + (mix * (tbl_log2[idx + (1)] - (value)) >> 8);
	<log2+?>: dup.x32 sp(1)
	<log2+?>: dup.x32 sp(1)
	<log2+?>: load.ref <?> ;Fixed.log2.tbl_log2
	<log2+?>: dup.x32 sp(5)
	<log2+?>: inc.i32(+1)
	<log2+?>: mad.u32 4
	<log2+?>: load.i32
	<log2+?>: dup.x32 sp(4)
	<log2+?>: sub.i32
	<log2+?>: mul.u32
	<log2+?>: b32.shr 0x08
	<log2+?>: add.i32
	<log2+?>: set.x32 sp(2)
	<log2+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:194: (28 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:194: (23 bytes): .result.value := (n - precision << precision) + (value >> 30 - precision);
	<log2+?>: dup.x32 sp(2)
	<log2+?>: inc.i32(-20)
	<log2+?>: b32.shl 0x14
	<log2+?>: dup.x32 sp(1)
	<log2+?>: load.c32 30
	<log2+?>: inc.i32(-20)
	<log2+?>: sar.b32
	<log2+?>: add.i32
	<log2+?>: set.x32 sp(7)
	<log2+?>: inc.sp(-12)
	<log2+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:440: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:361: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:237: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:233: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:223: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:206: referenced as `log2`
}
Fixed.log(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 63
.name: 'log'
.file: 'cmplStd/lib/math/Fixed.ci:198'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the natural logarithm of the argument `x`.'
.value: {
	x := log2(x);
	if (!isFinite(x)) {
		return .result := x;
	}
	return .result := mul_28(x, ln2_28);
}
.instructions: (63 bytes)
	cmplStd/lib/math/Fixed.ci:206: (18 bytes): x := log2(x);
	<log>  : inc.sp(+8)
	<log+?>: dup.x64 sp(3)
	<log+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: set.x64 sp(3)
	cmplStd/lib/math/Fixed.ci:207: (21 bytes): if (!isFinite(x))
	<log+?>: load.z32
	<log+?>: dup.x64 sp(2)
	<log+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:208: (4 bytes): return .result := x;
	<log+?>: mov.x64 sp(3, 1)
	<log+?>: ret
	cmplStd/lib/math/Fixed.ci:211: (24 bytes): return .result := mul_28(x, ln2_28);
	<log+?>: inc.sp(+8)
	<log+?>: dup.x64 sp(3)
	<log+?>: load.c32 186065279
	<log+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<log+?>: call
	<log+?>: inc.sp(-12)
	<log+?>: set.x64 sp(5)
	<log+?>: ret
.usages:
}
Fixed.log10(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 63
.name: 'log10'
.file: 'cmplStd/lib/math/Fixed.ci:215'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the decimal logarithm of the argument `x`.'
.value: {
	x := log2(x);
	if (!isFinite(x)) {
		return .result := x;
	}
	return .result := mul_28(x, lg2_28);
}
.instructions: (63 bytes)
	cmplStd/lib/math/Fixed.ci:223: (18 bytes): x := log2(x);
	<log10>  : inc.sp(+8)
	<log10+?>: dup.x64 sp(3)
	<log10+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<log10+?>: call
	<log10+?>: inc.sp(-8)
	<log10+?>: set.x64 sp(3)
	cmplStd/lib/math/Fixed.ci:224: (21 bytes): if (!isFinite(x))
	<log10+?>: load.z32
	<log10+?>: dup.x64 sp(2)
	<log10+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<log10+?>: call
	<log10+?>: inc.sp(-8)
	<log10+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:225: (4 bytes): return .result := x;
	<log10+?>: mov.x64 sp(3, 1)
	<log10+?>: ret
	cmplStd/lib/math/Fixed.ci:227: (24 bytes): return .result := mul_28(x, lg2_28);
	<log10+?>: inc.sp(+8)
	<log10+?>: dup.x64 sp(3)
	<log10+?>: load.c32 80807124
	<log10+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<log10+?>: call
	<log10+?>: inc.sp(-12)
	<log10+?>: set.x64 sp(5)
	<log10+?>: ret
.usages:
}
Fixed.log(x: Fixed, base: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 99
.name: 'log'
.file: 'cmplStd/lib/math/Fixed.ci:231'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.param base: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the logarithm of the argument `x`.'
.value: {
	x := log2(x);
	if (!isFinite(x)) {
		return .result := x;
	}
	base := log2(base);
	if (!isFinite(base)) {
		return .result := base;
	}
	return .result := div(x, base);
}
.instructions: (99 bytes)
	cmplStd/lib/math/Fixed.ci:233: (18 bytes): x := log2(x);
	<log>  : inc.sp(+8)
	<log+?>: dup.x64 sp(5)
	<log+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: set.x64 sp(5)
	cmplStd/lib/math/Fixed.ci:234: (21 bytes): if (!isFinite(x))
	<log+?>: load.z32
	<log+?>: dup.x64 sp(4)
	<log+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:235: (4 bytes): return .result := x;
	<log+?>: mov.x64 sp(5, 3)
	<log+?>: ret
	cmplStd/lib/math/Fixed.ci:237: (18 bytes): base := log2(base);
	<log+?>: inc.sp(+8)
	<log+?>: dup.x64 sp(3)
	<log+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: set.x64 sp(3)
	cmplStd/lib/math/Fixed.ci:238: (21 bytes): if (!isFinite(base))
	<log+?>: load.z32
	<log+?>: dup.x64 sp(2)
	<log+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:239: (4 bytes): return .result := base;
	<log+?>: mov.x64 sp(5, 1)
	<log+?>: ret
	cmplStd/lib/math/Fixed.ci:241: (21 bytes): return .result := div(x, base);
	<log+?>: inc.sp(+8)
	<log+?>: dup.x64 sp(5)
	<log+?>: dup.x64 sp(5)
	<log+?>: load.ref <?> ;Fixed.div(a: Fixed, b: Fixed): Fixed
	<log+?>: call
	<log+?>: inc.sp(-16)
	<log+?>: set.x64 sp(7)
	<log+?>: ret
.usages:
}
Fixed.pow2(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 216
.name: 'pow2'
.file: 'cmplStd/lib/math/Fixed.ci:254'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'pow2(x) <=> 2 ** x
pow2(x) = pow2(n + q) = pow2(n) * pow2(q)
let n = floor(x);
 let q = fract(x);
 pow2(n) = 2 ** n = 1 << n
pow2(q) = 1 + look up from table
pow2(x) = (x >= 0) ? (pow2(q) << n) : (pow2(q) >> -n)
---------------------------------------------------'
.value: {
	static const tbl_pow2: uint32[257] := {
		tbl_pow2[0] := (1073741824);
		tbl_pow2[1] := (1076653033);
		tbl_pow2[2] := (1079572135);
		tbl_pow2[3] := (1082499152);
		tbl_pow2[4] := (1085434105);
		tbl_pow2[5] := (1088377016);
		tbl_pow2[6] := (1091327905);
		tbl_pow2[7] := (1094286795);
		tbl_pow2[8] := (1097253708);
		tbl_pow2[9] := (1100228664);
		tbl_pow2[10] := (1103211687);
		tbl_pow2[11] := (1106202797);
		tbl_pow2[12] := (1109202017);
		tbl_pow2[13] := (1112209369);
		tbl_pow2[14] := (1115224875);
		tbl_pow2[15] := (1118248556);
		tbl_pow2[16] := (1121280435);
		tbl_pow2[17] := (1124320535);
		tbl_pow2[18] := (1127368877);
		tbl_pow2[19] := (1130425484);
		tbl_pow2[20] := (1133490379);
		tbl_pow2[21] := (1136563583);
		tbl_pow2[22] := (1139645119);
		tbl_pow2[23] := (1142735011);
		tbl_pow2[24] := (1145833280);
		tbl_pow2[25] := (1148939949);
		tbl_pow2[26] := (1152055041);
		tbl_pow2[27] := (1155178579);
		tbl_pow2[28] := (1158310586);
		tbl_pow2[29] := (1161451085);
		tbl_pow2[30] := (1164600098);
		tbl_pow2[31] := (1167757649);
		tbl_pow2[32] := (1170923761);
		tbl_pow2[33] := (1174098458);
		tbl_pow2[34] := (1177281762);
		tbl_pow2[35] := (1180473696);
		tbl_pow2[36] := (1183674285);
		tbl_pow2[37] := (1186883552);
		tbl_pow2[38] := (1190101520);
		tbl_pow2[39] := (1193328212);
		tbl_pow2[40] := (1196563653);
		tbl_pow2[41] := (1199807866);
		tbl_pow2[42] := (1203060875);
		tbl_pow2[43] := (1206322704);
		tbl_pow2[44] := (1209593377);
		tbl_pow2[45] := (1212872917);
		tbl_pow2[46] := (1216161349);
		tbl_pow2[47] := (1219458697);
		tbl_pow2[48] := (1222764985);
		tbl_pow2[49] := (1226080238);
		tbl_pow2[50] := (1229404478);
		tbl_pow2[51] := (1232737732);
		tbl_pow2[52] := (1236080023);
		tbl_pow2[53] := (1239431376);
		tbl_pow2[54] := (1242791815);
		tbl_pow2[55] := (1246161366);
		tbl_pow2[56] := (1249540052);
		tbl_pow2[57] := (1252927899);
		tbl_pow2[58] := (1256324931);
		tbl_pow2[59] := (1259731173);
		tbl_pow2[60] := (1263146651);
		tbl_pow2[61] := (1266571389);
		tbl_pow2[62] := (1270005412);
		tbl_pow2[63] := (1273448746);
		tbl_pow2[64] := (1276901416);
		tbl_pow2[65] := (1280363447);
		tbl_pow2[66] := (1283834865);
		tbl_pow2[67] := (1287315694);
		tbl_pow2[68] := (1290805961);
		tbl_pow2[69] := (1294305691);
		tbl_pow2[70] := (1297814910);
		tbl_pow2[71] := (1301333643);
		tbl_pow2[72] := (1304861916);
		tbl_pow2[73] := (1308399756);
		tbl_pow2[74] := (1311947188);
		tbl_pow2[75] := (1315504237);
		tbl_pow2[76] := (1319070931);
		tbl_pow2[77] := (1322647295);
		tbl_pow2[78] := (1326233356);
		tbl_pow2[79] := (1329829139);
		tbl_pow2[80] := (1333434672);
		tbl_pow2[81] := (1337049980);
		tbl_pow2[82] := (1340675090);
		tbl_pow2[83] := (1344310029);
		tbl_pow2[84] := (1347954823);
		tbl_pow2[85] := (1351609500);
		tbl_pow2[86] := (1355274085);
		tbl_pow2[87] := (1358948606);
		tbl_pow2[88] := (1362633089);
		tbl_pow2[89] := (1366327562);
		tbl_pow2[90] := (1370032052);
		tbl_pow2[91] := (1373746586);
		tbl_pow2[92] := (1377471191);
		tbl_pow2[93] := (1381205894);
		tbl_pow2[94] := (1384950723);
		tbl_pow2[95] := (1388705705);
		tbl_pow2[96] := (1392470868);
		tbl_pow2[97] := (1396246240);
		tbl_pow2[98] := (1400031847);
		tbl_pow2[99] := (1403827719);
		tbl_pow2[100] := (1407633882);
		tbl_pow2[101] := (1411450365);
		tbl_pow2[102] := (1415277195);
		tbl_pow2[103] := (1419114400);
		tbl_pow2[104] := (1422962010);
		tbl_pow2[105] := (1426820051);
		tbl_pow2[106] := (1430688553);
		tbl_pow2[107] := (1434567543);
		tbl_pow2[108] := (1438457050);
		tbl_pow2[109] := (1442357103);
		tbl_pow2[110] := (1446267730);
		tbl_pow2[111] := (1450188959);
		tbl_pow2[112] := (1454120821);
		tbl_pow2[113] := (1458063342);
		tbl_pow2[114] := (1462016553);
		tbl_pow2[115] := (1465980482);
		tbl_pow2[116] := (1469955158);
		tbl_pow2[117] := (1473940611);
		tbl_pow2[118] := (1477936869);
		tbl_pow2[119] := (1481943963);
		tbl_pow2[120] := (1485961920);
		tbl_pow2[121] := (1489990772);
		tbl_pow2[122] := (1494030547);
		tbl_pow2[123] := (1498081274);
		tbl_pow2[124] := (1502142985);
		tbl_pow2[125] := (1506215708);
		tbl_pow2[126] := (1510299473);
		tbl_pow2[127] := (1514394310);
		tbl_pow2[128] := (1518500249);
		tbl_pow2[129] := (1522617321);
		tbl_pow2[130] := (1526745556);
		tbl_pow2[131] := (1530884983);
		tbl_pow2[132] := (1535035633);
		tbl_pow2[133] := (1539197537);
		tbl_pow2[134] := (1543370725);
		tbl_pow2[135] := (1547555227);
		tbl_pow2[136] := (1551751075);
		tbl_pow2[137] := (1555958299);
		tbl_pow2[138] := (1560176930);
		tbl_pow2[139] := (1564406999);
		tbl_pow2[140] := (1568648537);
		tbl_pow2[141] := (1572901574);
		tbl_pow2[142] := (1577166143);
		tbl_pow2[143] := (1581442274);
		tbl_pow2[144] := (1585729999);
		tbl_pow2[145] := (1590029349);
		tbl_pow2[146] := (1594340356);
		tbl_pow2[147] := (1598663051);
		tbl_pow2[148] := (1602997467);
		tbl_pow2[149] := (1607343634);
		tbl_pow2[150] := (1611701584);
		tbl_pow2[151] := (1616071351);
		tbl_pow2[152] := (1620452965);
		tbl_pow2[153] := (1624846458);
		tbl_pow2[154] := (1629251864);
		tbl_pow2[155] := (1633669214);
		tbl_pow2[156] := (1638098541);
		tbl_pow2[157] := (1642539876);
		tbl_pow2[158] := (1646993254);
		tbl_pow2[159] := (1651458705);
		tbl_pow2[160] := (1655936264);
		tbl_pow2[161] := (1660425963);
		tbl_pow2[162] := (1664927834);
		tbl_pow2[163] := (1669441912);
		tbl_pow2[164] := (1673968228);
		tbl_pow2[165] := (1678506816);
		tbl_pow2[166] := (1683057710);
		tbl_pow2[167] := (1687620942);
		tbl_pow2[168] := (1692196547);
		tbl_pow2[169] := (1696784557);
		tbl_pow2[170] := (1701385007);
		tbl_pow2[171] := (1705997929);
		tbl_pow2[172] := (1710623359);
		tbl_pow2[173] := (1715261329);
		tbl_pow2[174] := (1719911875);
		tbl_pow2[175] := (1724575029);
		tbl_pow2[176] := (1729250826);
		tbl_pow2[177] := (1733939301);
		tbl_pow2[178] := (1738640487);
		tbl_pow2[179] := (1743354420);
		tbl_pow2[180] := (1748081133);
		tbl_pow2[181] := (1752820662);
		tbl_pow2[182] := (1757573041);
		tbl_pow2[183] := (1762338305);
		tbl_pow2[184] := (1767116488);
		tbl_pow2[185] := (1771907627);
		tbl_pow2[186] := (1776711756);
		tbl_pow2[187] := (1781528911);
		tbl_pow2[188] := (1786359125);
		tbl_pow2[189] := (1791202436);
		tbl_pow2[190] := (1796058879);
		tbl_pow2[191] := (1800928488);
		tbl_pow2[192] := (1805811301);
		tbl_pow2[193] := (1810707352);
		tbl_pow2[194] := (1815616678);
		tbl_pow2[195] := (1820539314);
		tbl_pow2[196] := (1825475297);
		tbl_pow2[197] := (1830424662);
		tbl_pow2[198] := (1835387447);
		tbl_pow2[199] := (1840363687);
		tbl_pow2[200] := (1845353419);
		tbl_pow2[201] := (1850356680);
		tbl_pow2[202] := (1855373506);
		tbl_pow2[203] := (1860403934);
		tbl_pow2[204] := (1865448001);
		tbl_pow2[205] := (1870505743);
		tbl_pow2[206] := (1875577199);
		tbl_pow2[207] := (1880662405);
		tbl_pow2[208] := (1885761398);
		tbl_pow2[209] := (1890874215);
		tbl_pow2[210] := (1896000895);
		tbl_pow2[211] := (1901141475);
		tbl_pow2[212] := (1906295993);
		tbl_pow2[213] := (1911464486);
		tbl_pow2[214] := (1916646992);
		tbl_pow2[215] := (1921843549);
		tbl_pow2[216] := (1927054195);
		tbl_pow2[217] := (1932278969);
		tbl_pow2[218] := (1937517909);
		tbl_pow2[219] := (1942771053);
		tbl_pow2[220] := (1948038440);
		tbl_pow2[221] := (1953320108);
		tbl_pow2[222] := (1958616096);
		tbl_pow2[223] := (1963926443);
		tbl_pow2[224] := (1969251187);
		tbl_pow2[225] := (1974590369);
		tbl_pow2[226] := (1979944027);
		tbl_pow2[227] := (1985312199);
		tbl_pow2[228] := (1990694927);
		tbl_pow2[229] := (1996092248);
		tbl_pow2[230] := (2001504204);
		tbl_pow2[231] := (2006930832);
		tbl_pow2[232] := (2012372173);
		tbl_pow2[233] := (2017828268);
		tbl_pow2[234] := (2023299155);
		tbl_pow2[235] := (2028784876);
		tbl_pow2[236] := (2034285470);
		tbl_pow2[237] := (2039800977);
		tbl_pow2[238] := (2045331439);
		tbl_pow2[239] := (2050876895);
		tbl_pow2[240] := (2056437386);
		tbl_pow2[241] := (2062012953);
		tbl_pow2[242] := (2067603638);
		tbl_pow2[243] := (2073209480);
		tbl_pow2[244] := (2078830521);
		tbl_pow2[245] := (2084466802);
		tbl_pow2[246] := (2090118365);
		tbl_pow2[247] := (2095785251);
		tbl_pow2[248] := (2101467501);
		tbl_pow2[249] := (2107165158);
		tbl_pow2[250] := (2112878262);
		tbl_pow2[251] := (2118606856);
		tbl_pow2[252] := (2124350982);
		tbl_pow2[253] := (2130110682);
		tbl_pow2[254] := (2135885998);
		tbl_pow2[255] := (2141676972);
		tbl_pow2[256] := (2147483648);
	};
	if (x.value > pow2max) {
		return .result := as(inf);
	}
	if (x.value <= -pow2max) {
		if (isNan(x)) {
			return .result := x;
		}
		return .result := as(0);
	}
	idx: uint32 := (x.value >> (precision - 8)) & 255;
	static if (precision < 8) {
		error_not_implemented_yet
	}
	q: uint32 := tbl_pow2[idx];
	static if (precision > 8) {
		mix: uint32 := (precision > 16 ? x.value >> (precision - 16) : x.value << (16 - precision)) & 255;
		q := q + (mix * (tbl_pow2[idx + (1)] - q) >> 8);
	}
	n: int32 := (x.value >> precision) - (30 - precision);
	return .result := as(n < 0 ? q >> -n : q << n);
}
.instructions: (216 bytes)
	cmplStd/lib/math/Fixed.ci:296: (34 bytes): if (x.value > pow2max)
	<pow2>  : dup.x32 sp(1)
	<pow2+?>: load.c32 11534336
	<pow2+?>: cgt.i32
	<pow2+?>: jz +26
	cmplStd/lib/math/Fixed.ci:297: (22 bytes): return .result := as(inf);
	<pow2+?>: inc.sp(+8)
	<pow2+?>: load.c32 2147483647
	<pow2+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow2+?>: call
	<pow2+?>: inc.sp(-4)
	<pow2+?>: set.x64 sp(5)
	<pow2+?>: ret
	cmplStd/lib/math/Fixed.ci:299: (51 bytes): if (x.value <= -pow2max)
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: load.c32 -11534336
	<pow2+?>: cgt.i32
	<pow2+?>: jnz +43
	cmplStd/lib/math/Fixed.ci:300: (21 bytes): if (isNan(x))
	<pow2+?>: load.z32
	<pow2+?>: dup.x64 sp(2)
	<pow2+?>: load.ref <?> ;Fixed.isNan(x: Fixed): bool
	<pow2+?>: call
	<pow2+?>: inc.sp(-8)
	<pow2+?>: jz +8
	cmplStd/lib/math/Fixed.ci:301: (4 bytes): return .result := x;
	<pow2+?>: mov.x64 sp(3, 1)
	<pow2+?>: ret
	cmplStd/lib/math/Fixed.ci:303: (18 bytes): return .result := as(0);
	<pow2+?>: inc.sp(+8)
	<pow2+?>: load.z32
	<pow2+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow2+?>: call
	<pow2+?>: inc.sp(-4)
	<pow2+?>: set.x64 sp(5)
	<pow2+?>: ret
	cmplStd/lib/math/Fixed.ci:306: (14 bytes): idx: uint32 := (x.value >> (precision - 8)) & 255
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: load.c32 20
	<pow2+?>: inc.i32(-8)
	<pow2+?>: sar.b32
	<pow2+?>: b32.and 0xff
	cmplStd/lib/math/Fixed.ci:308: (12 bytes): q: uint32 := tbl_pow2[idx]
	<pow2+?>: load.ref <?> ;Fixed.pow2.tbl_pow2
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: mad.u32 4
	<pow2+?>: load.i32
	cmplStd/lib/math/Fixed.ci:310: (14 bytes): mix: uint32 := (precision > 16 ? x.value >> (precision - 16) : x.value << (16 - precision)) & 255
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: load.c32 20
	<pow2+?>: inc.i32(-16)
	<pow2+?>: sar.b32
	<pow2+?>: b32.and 0xff
	cmplStd/lib/math/Fixed.ci:314: (29 bytes): q := q + (mix * (tbl_pow2[idx + (1)] - q) >> 8);
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: load.ref <?> ;Fixed.pow2.tbl_pow2
	<pow2+?>: dup.x32 sp(5)
	<pow2+?>: inc.i32(+1)
	<pow2+?>: mad.u32 4
	<pow2+?>: load.i32
	<pow2+?>: dup.x32 sp(4)
	<pow2+?>: sub.i32
	<pow2+?>: mul.u32
	<pow2+?>: b32.shr 0x08
	<pow2+?>: add.i32
	<pow2+?>: set.x32 sp(2)
	<pow2+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:317: (14 bytes): n: int32 := (x.value >> precision) - (30 - precision)
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: b32.sar 0x14
	<pow2+?>: load.c32 30
	<pow2+?>: inc.i32(-20)
	<pow2+?>: sub.i32
	cmplStd/lib/math/Fixed.ci:318: (44 bytes): return .result := as(n < 0 ? q >> -n : q << n);
	<pow2+?>: inc.sp(+8)
	<pow2+?>: dup.x32 sp(2)
	<pow2+?>: load.z32
	<pow2+?>: clt.i32
	<pow2+?>: jz +14
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: neg.i32
	<pow2+?>: shr.b32
	<pow2+?>: jmp +9
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: shl.b32
	<pow2+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow2+?>: call
	<pow2+?>: inc.sp(-4)
	<pow2+?>: set.x64 sp(8)
	<pow2+?>: inc.sp(-12)
	<pow2+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:440: referenced as `pow2`
	cmplStd/lib/math/Fixed.ci:361: referenced as `pow2`
	cmplStd/lib/math/Fixed.ci:342: referenced as `pow2`
	cmplStd/lib/math/Fixed.ci:330: referenced as `pow2`
}
Fixed.exp(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 38
.name: 'exp'
.file: 'cmplStd/lib/math/Fixed.ci:322'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the base-e exponential: $ e^x $.'
.value: {
	return .result := pow2(mul_28(x, l2e_28));
}
.instructions: (38 bytes)
	cmplStd/lib/math/Fixed.ci:330: (38 bytes): return .result := pow2(mul_28(x, l2e_28));
	<exp>  : inc.sp(+8)
	<exp+?>: inc.sp(+8)
	<exp+?>: dup.x64 sp(5)
	<exp+?>: load.c32 387270501
	<exp+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<exp+?>: call
	<exp+?>: inc.sp(-12)
	<exp+?>: load.ref <?> ;Fixed.pow2(x: Fixed): Fixed
	<exp+?>: call
	<exp+?>: inc.sp(-8)
	<exp+?>: set.x64 sp(5)
	<exp+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:503: referenced as `exp`
	cmplStd/lib/math/Fixed.ci:503: referenced as `exp`
}
Fixed.exp10(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 38
.name: 'exp10'
.file: 'cmplStd/lib/math/Fixed.ci:334'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the base 10 exponential: $ 10^x $.'
.value: {
	return .result := pow2(mul_28(x, l2t_28));
}
.instructions: (38 bytes)
	cmplStd/lib/math/Fixed.ci:342: (38 bytes): return .result := pow2(mul_28(x, l2t_28));
	<exp10>  : inc.sp(+8)
	<exp10+?>: inc.sp(+8)
	<exp10+?>: dup.x64 sp(5)
	<exp10+?>: load.c32 891723282
	<exp10+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<exp10+?>: call
	<exp10+?>: inc.sp(-12)
	<exp10+?>: load.ref <?> ;Fixed.pow2(x: Fixed): Fixed
	<exp10+?>: call
	<exp10+?>: inc.sp(-8)
	<exp10+?>: set.x64 sp(5)
	<exp10+?>: ret
.usages:
}
Fixed.sqrt(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 175
.name: 'sqrt'
.file: 'cmplStd/lib/math/Fixed.ci:346'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the square root of the parameter `x`: $\sqrt{x}$.'
.value: {
	if (x.value <= 0) {
		if (x.value < 0) {
			return .result := as(nan);
		}
		return .result := as(0);
	}
	static if ((precision & 1) != 0) {
		return .result := pow2(div(log2(x), 2));
	}
	root: uint32 := 0;
	remHi: uint32 := 0;
	remLo: uint32 := x.value;
	for (count: uint32 := 16 + (precision >> 1); count != (0); count := count - (1)) {
		remHi := (remHi << 2) | (remLo >> 30);
		remLo := remLo << 2;
		root := root << 1;
		testDiv: uint32 := (root << 1) + (1);
		if (remHi >= testDiv) {
			remHi := remHi - testDiv;
			root := root + (1);
		}
	}
	return .result := as(root);
}
.instructions: (175 bytes)
	cmplStd/lib/math/Fixed.ci:353: (56 bytes): if (x.value <= 0)
	<sqrt>  : dup.x32 sp(1)
	<sqrt+?>: load.z32
	<sqrt+?>: cgt.i32
	<sqrt+?>: jnz +52
	cmplStd/lib/math/Fixed.ci:354: (30 bytes): if (x.value < 0)
	<sqrt+?>: dup.x32 sp(1)
	<sqrt+?>: load.z32
	<sqrt+?>: clt.i32
	<sqrt+?>: jz +26
	cmplStd/lib/math/Fixed.ci:355: (22 bytes): return .result := as(nan);
	<sqrt+?>: inc.sp(+8)
	<sqrt+?>: load.c32 -2147483648
	<sqrt+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: set.x64 sp(5)
	<sqrt+?>: ret
	cmplStd/lib/math/Fixed.ci:357: (18 bytes): return .result := as(0);
	<sqrt+?>: inc.sp(+8)
	<sqrt+?>: load.z32
	<sqrt+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: set.x64 sp(5)
	<sqrt+?>: ret
	cmplStd/lib/math/Fixed.ci:365: (1 byte): root: uint32 := 0
	<sqrt+?>: load.z32
	cmplStd/lib/math/Fixed.ci:366: (1 byte): remHi: uint32 := 0
	<sqrt+?>: load.z32
	cmplStd/lib/math/Fixed.ci:367: (2 bytes): remLo: uint32 := x.value
	<sqrt+?>: dup.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:368: (92 bytes): for (count: uint32 := 16 + (precision >> 1); count != (0); count := count - (1))
	<sqrt+?>: load.c32 16
	<sqrt+?>: load.c32 20
	<sqrt+?>: b32.sar 0x01
	<sqrt+?>: add.i32
	<sqrt+?>: jmp +67
	cmplStd/lib/math/Fixed.ci:369: (11 bytes): remHi := (remHi << 2) | (remLo >> 30);
	<sqrt+?>: dup.x32 sp(2)
	<sqrt+?>: b32.shl 0x02
	<sqrt+?>: dup.x32 sp(2)
	<sqrt+?>: b32.shr 0x1e
	<sqrt+?>: or.b32
	<sqrt+?>: set.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:370: (6 bytes): remLo := remLo << 2;
	<sqrt+?>: dup.x32 sp(1)
	<sqrt+?>: b32.shl 0x02
	<sqrt+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:371: (6 bytes): root := root << 1;
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: b32.shl 0x01
	<sqrt+?>: set.x32 sp(4)
	cmplStd/lib/math/Fixed.ci:372: (8 bytes): testDiv: uint32 := (root << 1) + (1)
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: b32.shl 0x01
	<sqrt+?>: inc.i32(+1)
	cmplStd/lib/math/Fixed.ci:373: (24 bytes): if (remHi >= testDiv)
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: dup.x32 sp(1)
	<sqrt+?>: clt.u32
	<sqrt+?>: jnz +19
	cmplStd/lib/math/Fixed.ci:374: (7 bytes): remHi := remHi - testDiv;
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: dup.x32 sp(1)
	<sqrt+?>: sub.i32
	<sqrt+?>: set.x32 sp(4)
	cmplStd/lib/math/Fixed.ci:375: (8 bytes): root := root + (1);
	<sqrt+?>: dup.x32 sp(4)
	<sqrt+?>: inc.i32(+1)
	<sqrt+?>: set.x32 sp(5)
	<sqrt+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:368: (4 bytes): count := count - (1)
	<sqrt+?>: inc.i32(-1)
	cmplStd/lib/math/Fixed.ci:368: (8 bytes): count != (0)
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: load.z32
	<sqrt+?>: ceq.i32
	<sqrt+?>: jz -67
	<sqrt+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:378: (23 bytes): return .result := as(root);
	<sqrt+?>: inc.sp(+8)
	<sqrt+?>: dup.x32 sp(4)
	<sqrt+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: set.x64 sp(8)
	<sqrt+?>: inc.sp(-12)
	<sqrt+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:394: referenced as `sqrt`
}
Fixed.pow(x: Fixed, y: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 410
.name: 'pow'
.file: 'cmplStd/lib/math/Fixed.ci:382'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.param y: Fixed (size: 8, cast: variable(val))
.doc: 'Returns `x` raised to the power of `y`: $ x^y $.'
.value: {
	if (y.value == 0 || x.value == one) {
		return .result := as(one);
	}
	if (y.value == one) {
		return .result := x;
	}
	if (y.value == half) {
		return .result := sqrt(x);
	}
	if (x.value == nan || y.value == nan) {
		return .result := as(nan);
	}
	if (x.value == 0) {
		if (y.value < 0) {
			return .result := as(inf);
		}
		return .result := as(0);
	}
	if ((y.value & mask) == 0) {
		res: int32 := one;
		sqr: int64 := x.value;
		pow: int32 := (y.value < 0 ? -y.value : y.value) >> precision;
		for ( ; pow != 0; ) {
			if ((pow & 1) != 0) {
				res := ((res) * sqr >> precision);
			}
			sqr := sqr * sqr >> precision;
			pow := pow >> 1;
		}
		return .result := y.value < 0 ? inv(as(res)) : as(res);
	}
	return .result := pow2(mul(y, log2(x)));
}
.instructions: (410 bytes)
	cmplStd/lib/math/Fixed.ci:383: (48 bytes): if (y.value == 0 || x.value == one)
	<pow>  : dup.x32 sp(1)
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: dup.x32 sp(0)
	<pow+?>: jnz +16
	<pow+?>: inc.sp(-4)
	<pow+?>: dup.x32 sp(3)
	<pow+?>: load.c32 1048576
	<pow+?>: ceq.i32
	<pow+?>: jz +26
	cmplStd/lib/math/Fixed.ci:386: (22 bytes): return .result := as(one);
	<pow+?>: inc.sp(+8)
	<pow+?>: load.c32 1048576
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:388: (16 bytes): if (y.value == one)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: load.c32 1048576
	<pow+?>: ceq.i32
	<pow+?>: jz +8
	cmplStd/lib/math/Fixed.ci:390: (4 bytes): return .result := x;
	<pow+?>: mov.x64 sp(5, 3)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:392: (31 bytes): if (y.value == half)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: load.c32 524288
	<pow+?>: ceq.i32
	<pow+?>: jz +23
	cmplStd/lib/math/Fixed.ci:394: (19 bytes): return .result := sqrt(x);
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x64 sp(5)
	<pow+?>: load.ref <?> ;Fixed.sqrt(x: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:396: (52 bytes): if (x.value == nan || y.value == nan)
	<pow+?>: dup.x32 sp(3)
	<pow+?>: load.c32 -2147483648
	<pow+?>: ceq.i32
	<pow+?>: dup.x32 sp(0)
	<pow+?>: jnz +16
	<pow+?>: inc.sp(-4)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: load.c32 -2147483648
	<pow+?>: ceq.i32
	<pow+?>: jz +26
	cmplStd/lib/math/Fixed.ci:399: (22 bytes): return .result := as(nan);
	<pow+?>: inc.sp(+8)
	<pow+?>: load.c32 -2147483648
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:401: (56 bytes): if (x.value == 0)
	<pow+?>: dup.x32 sp(3)
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: jz +52
	cmplStd/lib/math/Fixed.ci:408: (30 bytes): if (y.value < 0)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: load.z32
	<pow+?>: clt.i32
	<pow+?>: jz +26
	cmplStd/lib/math/Fixed.ci:409: (22 bytes): return .result := as(inf);
	<pow+?>: inc.sp(+8)
	<pow+?>: load.c32 2147483647
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:411: (18 bytes): return .result := as(0);
	<pow+?>: inc.sp(+8)
	<pow+?>: load.z32
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:425: (158 bytes): if ((y.value & mask) == 0)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: b32.and 0xfffff
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: jz +152
	cmplStd/lib/math/Fixed.ci:426: (5 bytes): res: int32 := one
	<pow+?>: load.c32 1048576
	cmplStd/lib/math/Fixed.ci:427: (3 bytes): sqr: int64 := x.value
	<pow+?>: dup.x32 sp(4)
	<pow+?>: i32.2i64
	cmplStd/lib/math/Fixed.ci:428: (19 bytes): pow: int32 := (y.value < 0 ? -y.value : y.value) >> precision
	<pow+?>: dup.x32 sp(4)
	<pow+?>: load.z32
	<pow+?>: clt.i32
	<pow+?>: jz +11
	<pow+?>: dup.x32 sp(4)
	<pow+?>: neg.i32
	<pow+?>: jmp +6
	<pow+?>: dup.x32 sp(4)
	<pow+?>: b32.sar 0x14
	cmplStd/lib/math/Fixed.ci:430: (52 bytes): for ( ; pow != 0; )
	<pow+?>: jmp +44
	cmplStd/lib/math/Fixed.ci:431: (25 bytes): if ((pow & 1) != 0)
	<pow+?>: dup.x32 sp(0)
	<pow+?>: b32.and 0x01
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: jnz +19
	cmplStd/lib/math/Fixed.ci:432: (15 bytes): res := ((res) * sqr >> precision);
	<pow+?>: dup.x32 sp(3)
	<pow+?>: i32.2i64
	<pow+?>: dup.x64 sp(3)
	<pow+?>: mul.i64
	<pow+?>: load.c32 20
	<pow+?>: sar.b64
	<pow+?>: i64.2i32
	<pow+?>: set.x32 sp(4)
	cmplStd/lib/math/Fixed.ci:434: (13 bytes): sqr := sqr * sqr >> precision;
	<pow+?>: dup.x64 sp(1)
	<pow+?>: dup.x64 sp(3)
	<pow+?>: mul.i64
	<pow+?>: load.c32 20
	<pow+?>: sar.b64
	<pow+?>: set.x64 sp(3)
	cmplStd/lib/math/Fixed.ci:435: (2 bytes): pow := pow >> 1;
	<pow+?>: b32.sar 0x01
	cmplStd/lib/math/Fixed.ci:430: (8 bytes): pow != 0
	<pow+?>: dup.x32 sp(0)
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: jz -44
	cmplStd/lib/math/Fixed.ci:437: (65 bytes): return .result := y.value < 0 ? inv(as(res)) : as(res);
	<pow+?>: dup.x32 sp(5)
	<pow+?>: load.z32
	<pow+?>: clt.i32
	<pow+?>: jz +38
	<pow+?>: inc.sp(+8)
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x32 sp(7)
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: load.ref <?> ;Fixed.inv(x: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: jmp +20
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x32 sp(5)
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(11)
	<pow+?>: inc.sp(-16)
	<pow+?>: ret
	<pow+?>: inc.sp(-16)
	cmplStd/lib/math/Fixed.ci:440: (49 bytes): return .result := pow2(mul(y, log2(x)));
	<pow+?>: inc.sp(+8)
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x64 sp(5)
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x64 sp(11)
	<pow+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: load.ref <?> ;Fixed.mul(a: Fixed, b: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-16)
	<pow+?>: load.ref <?> ;Fixed.pow2(x: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
.usages:
}
Fixed.horner(x: int32, a0: int32, a1: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:444'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.value: a0 + int32((a1) * int64(x) >> precision)
.usages:
	cmplStd/lib/math/Fixed.ci:448: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:447: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:446: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:445: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:445: referenced as `horner`
}
Fixed.horner(x: int32, a0: int32, a1: int32, a2: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:445'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.param a2: int32 (size: 4, cast: i32)
.value: horner(x, a0, horner(x, a1, a2))
.usages:
	cmplStd/lib/math/Fixed.ci:446: referenced as `horner`
}
Fixed.horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:446'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.param a2: int32 (size: 4, cast: i32)
.param a3: int32 (size: 4, cast: i32)
.value: horner(x, a0, horner(x, a1, a2, a3))
.usages:
	cmplStd/lib/math/Fixed.ci:447: referenced as `horner`
}
Fixed.horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32, a4: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:447'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.param a2: int32 (size: 4, cast: i32)
.param a3: int32 (size: 4, cast: i32)
.param a4: int32 (size: 4, cast: i32)
.value: horner(x, a0, horner(x, a1, a2, a3, a4))
.usages:
	cmplStd/lib/math/Fixed.ci:448: referenced as `horner`
}
Fixed.horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32, a4: int32, a5: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:448'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.param a2: int32 (size: 4, cast: i32)
.param a3: int32 (size: 4, cast: i32)
.param a4: int32 (size: 4, cast: i32)
.param a5: int32 (size: 4, cast: i32)
.value: horner(x, a0, horner(x, a1, a2, a3, a4, a5))
.usages:
	cmplStd/lib/math/Fixed.ci:563: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:485: referenced as `horner`
}
Fixed.sin(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 250
.name: 'sin'
.file: 'cmplStd/lib/math/Fixed.ci:451'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the sine of the radian argument `x`.'
.value: {
	x.value := x.value % piMul2;
	if (x.value < 0) {
		x.value := x.value + piMul2;
	}
	sign: int32 := 1;
	if (x.value >= pi) {
		x.value := x.value - pi;
		sign := -1;
	}
	if (x.value >= piDiv2) {
		x.value := pi - x.value;
	}
	xsq: int32 := int64(x.value) * (x.value) >> precision;
	res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5);
	return .result := mul(x, as(sign * res));
}
.instructions: (250 bytes)
	cmplStd/lib/math/Fixed.ci:466: (10 bytes): x.value := x.value % piMul2;
	<sin>  : dup.x32 sp(1)
	<sin+?>: load.c32 6588397
	<sin+?>: mod.i32
	<sin+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:467: (16 bytes): if (x.value < 0)
	<sin+?>: dup.x32 sp(1)
	<sin+?>: load.z32
	<sin+?>: clt.i32
	<sin+?>: jz +12
	cmplStd/lib/math/Fixed.ci:468: (8 bytes): x.value := x.value + piMul2;
	<sin+?>: dup.x32 sp(1)
	<sin+?>: inc.i32(+6588397)
	<sin+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:472: (5 bytes): sign: int32 := 1
	<sin+?>: load.c32 1
	cmplStd/lib/math/Fixed.ci:473: (27 bytes): if (x.value >= pi)
	<sin+?>: dup.x32 sp(2)
	<sin+?>: load.c32 3294198
	<sin+?>: clt.i32
	<sin+?>: jnz +19
	cmplStd/lib/math/Fixed.ci:474: (8 bytes): x.value := x.value - pi;
	<sin+?>: dup.x32 sp(2)
	<sin+?>: inc.i32(-3294198)
	<sin+?>: set.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:475: (7 bytes): sign := -1;
	<sin+?>: load.c32 -1
	<sin+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:479: (22 bytes): if (x.value >= piDiv2)
	<sin+?>: dup.x32 sp(2)
	<sin+?>: load.c32 1647099
	<sin+?>: clt.i32
	<sin+?>: jnz +14
	cmplStd/lib/math/Fixed.ci:480: (10 bytes): x.value := pi - x.value;
	<sin+?>: load.c32 3294198
	<sin+?>: dup.x32 sp(3)
	<sin+?>: sub.i32
	<sin+?>: set.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:484: (14 bytes): xsq: int32 := int64(x.value) * (x.value) >> precision
	<sin+?>: dup.x32 sp(2)
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(4)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	cmplStd/lib/math/Fixed.ci:485: (114 bytes): res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5)
	<sin+?>: dup.x32 sp(0)
	<sin+?>: load.c32 1048576
	<sin+?>: dup.x32 sp(1)
	<sin+?>: load.c32 -174762
	<sin+?>: dup.x32 sp(1)
	<sin+?>: load.c32 8738
	<sin+?>: dup.x32 sp(1)
	<sin+?>: load.c32 -208
	<sin+?>: load.c32 2
	<sin+?>: load.c64 0
	<sin+?>: dup.x32 sp(4)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: set.x32 sp(1)
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: set.x32 sp(1)
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: set.x32 sp(1)
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:486: (42 bytes): return .result := mul(x, as(sign * res));
	<sin+?>: inc.sp(+8)
	<sin+?>: dup.x64 sp(6)
	<sin+?>: inc.sp(+8)
	<sin+?>: dup.x32 sp(8)
	<sin+?>: dup.x32 sp(7)
	<sin+?>: mul.i32
	<sin+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sin+?>: call
	<sin+?>: inc.sp(-4)
	<sin+?>: load.ref <?> ;Fixed.mul(a: Fixed, b: Fixed): Fixed
	<sin+?>: call
	<sin+?>: inc.sp(-16)
	<sin+?>: set.x64 sp(8)
	<sin+?>: inc.sp(-12)
	<sin+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:610: referenced as `sin`
}
Fixed.sinh(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 129
.name: 'sinh'
.file: 'cmplStd/lib/math/Fixed.ci:490'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the hyperbolic sine of the radian argument `x`.'
.value: {
	if (x.value == 0) {
		return .result := as(0);
	}
	if (!isFinite(x)) {
		return .result := x;
	}
	return .result := div(sub(exp(x), exp(neg(x))), 2);
}
.instructions: (129 bytes)
	cmplStd/lib/math/Fixed.ci:495: (26 bytes): if (x.value == 0)
	<sinh>  : dup.x32 sp(1)
	<sinh+?>: load.z32
	<sinh+?>: ceq.i32
	<sinh+?>: jz +22
	cmplStd/lib/math/Fixed.ci:496: (18 bytes): return .result := as(0);
	<sinh+?>: inc.sp(+8)
	<sinh+?>: load.z32
	<sinh+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-4)
	<sinh+?>: set.x64 sp(5)
	<sinh+?>: ret
	cmplStd/lib/math/Fixed.ci:498: (21 bytes): if (!isFinite(x))
	<sinh+?>: load.z32
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<sinh+?>: call
	<sinh+?>: inc.sp(-8)
	<sinh+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:499: (4 bytes): return .result := x;
	<sinh+?>: mov.x64 sp(3, 1)
	<sinh+?>: ret
	cmplStd/lib/math/Fixed.ci:503: (82 bytes): return .result := div(sub(exp(x), exp(neg(x))), 2);
	<sinh+?>: inc.sp(+8)
	<sinh+?>: inc.sp(+8)
	<sinh+?>: inc.sp(+8)
	<sinh+?>: dup.x64 sp(7)
	<sinh+?>: load.ref <?> ;Fixed.exp(x: Fixed): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-8)
	<sinh+?>: inc.sp(+8)
	<sinh+?>: inc.sp(+8)
	<sinh+?>: dup.x64 sp(11)
	<sinh+?>: load.ref <?> ;Fixed.neg(a: Fixed): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-8)
	<sinh+?>: load.ref <?> ;Fixed.exp(x: Fixed): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-8)
	<sinh+?>: load.ref <?> ;Fixed.sub(a: Fixed, b: Fixed): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-16)
	<sinh+?>: load.c32 2
	<sinh+?>: load.ref <?> ;Fixed.div(a: Fixed, b: int32): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-12)
	<sinh+?>: set.x64 sp(5)
	<sinh+?>: ret
.usages:
}
Fixed.cos(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 234
.name: 'cos'
.file: 'cmplStd/lib/math/Fixed.ci:530'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the cosine of the radian argument `x`.'
.value: {
	x.value := x.value % piMul2;
	if (x.value < 0) {
		x.value := x.value + piMul2;
	}
	if (x.value > pi) {
		x.value := piMul2 - x.value;
	}
	sign: int32 := 1;
	if (x.value >= piDiv2) {
		x.value := x.value - pi;
		sign := -1;
	}
	xsq: int32 := int64(x.value) * (x.value) >> precision;
	res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5);
	return .result := as(sign * res);
}
.instructions: (234 bytes)
	cmplStd/lib/math/Fixed.ci:544: (10 bytes): x.value := x.value % piMul2;
	<cos>  : dup.x32 sp(1)
	<cos+?>: load.c32 6588397
	<cos+?>: mod.i32
	<cos+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:545: (16 bytes): if (x.value < 0)
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.z32
	<cos+?>: clt.i32
	<cos+?>: jz +12
	cmplStd/lib/math/Fixed.ci:546: (8 bytes): x.value := x.value + piMul2;
	<cos+?>: dup.x32 sp(1)
	<cos+?>: inc.i32(+6588397)
	<cos+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:550: (22 bytes): if (x.value > pi)
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.c32 3294198
	<cos+?>: cgt.i32
	<cos+?>: jz +14
	cmplStd/lib/math/Fixed.ci:551: (10 bytes): x.value := piMul2 - x.value;
	<cos+?>: load.c32 6588397
	<cos+?>: dup.x32 sp(2)
	<cos+?>: sub.i32
	<cos+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:555: (5 bytes): sign: int32 := 1
	<cos+?>: load.c32 1
	cmplStd/lib/math/Fixed.ci:556: (27 bytes): if (x.value >= piDiv2)
	<cos+?>: dup.x32 sp(2)
	<cos+?>: load.c32 1647099
	<cos+?>: clt.i32
	<cos+?>: jnz +19
	cmplStd/lib/math/Fixed.ci:557: (8 bytes): x.value := x.value - pi;
	<cos+?>: dup.x32 sp(2)
	<cos+?>: inc.i32(-3294198)
	<cos+?>: set.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:558: (7 bytes): sign := -1;
	<cos+?>: load.c32 -1
	<cos+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:562: (14 bytes): xsq: int32 := int64(x.value) * (x.value) >> precision
	<cos+?>: dup.x32 sp(2)
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(4)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	cmplStd/lib/math/Fixed.ci:563: (114 bytes): res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5)
	<cos+?>: dup.x32 sp(0)
	<cos+?>: load.c32 1048576
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.c32 -524288
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.c32 43690
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.c32 -1456
	<cos+?>: load.c32 26
	<cos+?>: load.c64 0
	<cos+?>: dup.x32 sp(4)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: set.x32 sp(1)
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: set.x32 sp(1)
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: set.x32 sp(1)
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:564: (26 bytes): return .result := as(sign * res);
	<cos+?>: inc.sp(+8)
	<cos+?>: dup.x32 sp(4)
	<cos+?>: dup.x32 sp(3)
	<cos+?>: mul.i32
	<cos+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<cos+?>: call
	<cos+?>: inc.sp(-4)
	<cos+?>: set.x64 sp(8)
	<cos+?>: inc.sp(-12)
	<cos+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:610: referenced as `cos`
}
Fixed.tan(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 49
.name: 'tan'
.file: 'cmplStd/lib/math/Fixed.ci:605'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the tangent of the radian argument `x`.'
.value: {
	return .result := div(sin(x), cos(x));
}
.instructions: (49 bytes)
	cmplStd/lib/math/Fixed.ci:610: (49 bytes): return .result := div(sin(x), cos(x));
	<tan>  : inc.sp(+8)
	<tan+?>: inc.sp(+8)
	<tan+?>: dup.x64 sp(5)
	<tan+?>: load.ref <?> ;Fixed.sin(x: Fixed): Fixed
	<tan+?>: call
	<tan+?>: inc.sp(-8)
	<tan+?>: inc.sp(+8)
	<tan+?>: dup.x64 sp(7)
	<tan+?>: load.ref <?> ;Fixed.cos(x: Fixed): Fixed
	<tan+?>: call
	<tan+?>: inc.sp(-8)
	<tan+?>: load.ref <?> ;Fixed.div(a: Fixed, b: Fixed): Fixed
	<tan+?>: call
	<tan+?>: inc.sp(-16)
	<tan+?>: set.x64 sp(5)
	<tan+?>: ret
.usages:
}
Fixed.degrees(radians: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 37
.name: 'degrees'
.file: 'cmplStd/lib/math/Fixed.ci:714'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param radians: Fixed (size: 8, cast: variable(val))
.doc: 'Converts the input to degrees from radians: $radians * 180 / pi$'
.value: {
	return .result := as((radians.value) * int64(r2d_24) >> 24);
}
.instructions: (37 bytes)
	cmplStd/lib/math/Fixed.ci:715: (37 bytes): return .result := as((radians.value) * int64(r2d_24) >> 24);
	<degrees>  : inc.sp(+8)
	<degrees+?>: dup.x32 sp(3)
	<degrees+?>: i32.2i64
	<degrees+?>: load.c64 961263668
	<degrees+?>: mul.i64
	<degrees+?>: load.c32 24
	<degrees+?>: sar.b64
	<degrees+?>: i64.2i32
	<degrees+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<degrees+?>: call
	<degrees+?>: inc.sp(-4)
	<degrees+?>: set.x64 sp(5)
	<degrees+?>: ret
.usages:
}
Fixed.radians(degrees: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 24
.name: 'radians'
.file: 'cmplStd/lib/math/Fixed.ci:719'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param degrees: Fixed (size: 8, cast: variable(val))
.doc: 'Converts the input to radians from degrees: $degrees * pi / 180$'
.value: {
	return .result := mul_28(degrees, d2r_28);
}
.instructions: (24 bytes)
	cmplStd/lib/math/Fixed.ci:720: (24 bytes): return .result := mul_28(degrees, d2r_28);
	<radians>  : inc.sp(+8)
	<radians+?>: dup.x64 sp(3)
	<radians+?>: load.c32 4685082
	<radians+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<radians+?>: call
	<radians+?>: inc.sp(-12)
	<radians+?>: set.x64 sp(5)
	<radians+?>: ret
.usages:
}
Fixed(value: int32): Fixed: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fixed'
.file: 'cmplStd/lib/math/Fixed.ci:725'
.param .result: Fixed (size: 8, cast: val)
.param value: int32 (size: 4, cast: i32)
.doc: 'Convert the integer `value` to fixed-point value'
.value: Fixed.as(value << Fixed.precision)
.usages:
}
int32(value: Fixed): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'int32'
.file: 'cmplStd/lib/math/Fixed.ci:728'
.param .result: int32 (size: 4, cast: i32)
.param value: Fixed (size: 4, cast: const ref)
.doc: 'Convert the fixed point `value` to integer value'
.value: value.value >> Fixed.precision
.usages:
}
Fixed(value: float64): Fixed: function {
.kind: static function
.base: `function`
.size: 95
.name: 'Fixed'
.file: 'cmplStd/lib/math/Fixed.ci:732'
.param .result: Fixed (size: 8, cast: variable(val))
.param value: float64 (size: 8, cast: variable(f64))
.doc: 'Convert the floating point `value` to fixed-point value'
.value: {
	result: Fixed := Fixed.as(value * ((1 << Fixed.precision)));
	if (result.value == Fixed.nan) {
		if (value != value) {
			result.value := Fixed.nan;
		}
		else if (value > (0)) {
			result.value := Fixed.inf;
		}
		else if (value < (0)) {
			result.value := -Fixed.inf;
		}
	}
	return .result := result;
}
.instructions: (95 bytes)
	cmplStd/lib/math/Fixed.ci:733: (26 bytes): result: Fixed := Fixed.as(value * ((1 << Fixed.precision)))
	<Fixed>  : inc.sp(+8)
	<Fixed+?>: dup.x64 sp(3)
	<Fixed+?>: load.c32 1
	<Fixed+?>: b32.shl 0x14
	<Fixed+?>: i32.2f64
	<Fixed+?>: mul.f64
	<Fixed+?>: f64.2i32
	<Fixed+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<Fixed+?>: call
	<Fixed+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:734: (66 bytes): if (result.value == Fixed.nan)
	<Fixed+?>: dup.x32 sp(0)
	<Fixed+?>: load.c32 -2147483648
	<Fixed+?>: ceq.i32
	<Fixed+?>: jz +58
	cmplStd/lib/math/Fixed.ci:735: (54 bytes): if (value != value)
	<Fixed+?>: dup.x64 sp(3)
	<Fixed+?>: dup.x64 sp(5)
	<Fixed+?>: ceq.f64
	<Fixed+?>: jnz +15
	cmplStd/lib/math/Fixed.ci:736: (7 bytes): result.value := Fixed.nan;
	<Fixed+?>: load.c32 -2147483648
	<Fixed+?>: set.x32 sp(1)
	<Fixed+?>: jmp +38
	cmplStd/lib/math/Fixed.ci:738: (34 bytes): if (value > (0))
	<Fixed+?>: dup.x64 sp(3)
	<Fixed+?>: load.z64
	<Fixed+?>: cgt.f64
	<Fixed+?>: jz +15
	cmplStd/lib/math/Fixed.ci:739: (7 bytes): result.value := Fixed.inf;
	<Fixed+?>: load.c32 2147483647
	<Fixed+?>: set.x32 sp(1)
	<Fixed+?>: jmp +19
	cmplStd/lib/math/Fixed.ci:741: (15 bytes): if (value < (0))
	<Fixed+?>: dup.x64 sp(3)
	<Fixed+?>: load.z64
	<Fixed+?>: clt.f64
	<Fixed+?>: jz +11
	cmplStd/lib/math/Fixed.ci:742: (7 bytes): result.value := -Fixed.inf;
	<Fixed+?>: load.c32 -2147483647
	<Fixed+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:745: (3 bytes): return .result := result;
	<Fixed+?>: set.x64 sp(5)
	<Fixed+?>: ret
.usages:
}
float64(value: Fixed): float64: function {
.kind: static function
.base: `function`
.size: 87
.name: 'float64'
.file: 'cmplStd/lib/math/Fixed.ci:750'
.param .result: float64 (size: 8, cast: variable(f64))
.param value: Fixed (size: 8, cast: variable(val))
.doc: 'Convert the fixed point `value` to floating point value'
.value: {
	if (value.value == Fixed.nan) {
		return .result := Math.nan;
	}
	if (value.value == Fixed.inf) {
		return .result := Math.inf;
	}
	if (value.value == -Fixed.inf) {
		return .result := -Math.inf;
	}
	return .result := (value.value) / float64(1 << Fixed.precision);
}
.instructions: (87 bytes)
	cmplStd/lib/math/Fixed.ci:751: (24 bytes): if (value.value == Fixed.nan)
	<float64>  : dup.x32 sp(1)
	<float64+?>: load.c32 -2147483648
	<float64+?>: ceq.i32
	<float64+?>: jz +16
	cmplStd/lib/math/Fixed.ci:752: (12 bytes): return .result := Math.nan;
	<float64+?>: load.f64 -nan
	<float64+?>: set.x64 sp(5)
	<float64+?>: ret
	cmplStd/lib/math/Fixed.ci:754: (24 bytes): if (value.value == Fixed.inf)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: load.c32 2147483647
	<float64+?>: ceq.i32
	<float64+?>: jz +16
	cmplStd/lib/math/Fixed.ci:755: (12 bytes): return .result := Math.inf;
	<float64+?>: load.f64 inf
	<float64+?>: set.x64 sp(5)
	<float64+?>: ret
	cmplStd/lib/math/Fixed.ci:757: (24 bytes): if (value.value == -Fixed.inf)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: load.c32 -2147483647
	<float64+?>: ceq.i32
	<float64+?>: jz +16
	cmplStd/lib/math/Fixed.ci:758: (12 bytes): return .result := -Math.inf;
	<float64+?>: load.f64 -inf
	<float64+?>: set.x64 sp(5)
	<float64+?>: ret
	cmplStd/lib/math/Fixed.ci:761: (15 bytes): return .result := (value.value) / float64(1 << Fixed.precision);
	<float64+?>: dup.x32 sp(1)
	<float64+?>: i32.2f64
	<float64+?>: load.c32 1
	<float64+?>: b32.shl 0x14
	<float64+?>: i32.2f64
	<float64+?>: div.f64
	<float64+?>: set.x64 sp(5)
	<float64+?>: ret
.usages:
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:2'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	cmplStd/test/math/test.Complex.ci:21: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:20: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:18: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:17: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:15: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:14: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:12: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:11: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:9: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:8: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:6: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:6: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:5: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:5: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:4: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:4: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:3: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:144: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:142: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:139: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:137: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:133: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:131: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:124: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:122: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:120: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:118: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:116: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:113: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:102: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:102: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:102: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:99: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:96: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:93: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:84: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:84: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:79: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:74: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:54: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:54: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:54: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:51: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:49: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:44: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:44: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:44: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:41: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:39: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:37: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:37: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:37: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:34: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:32: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:30: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:30: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:30: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:27: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:27: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:19: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:12: referenced as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'cmplStd/lib/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	cmplStd/test/math/test.Complex.ci:9: referenced as `re`
	cmplStd/test/math/test.Complex.ci:8: referenced as `re`
	cmplStd/test/math/test.Complex.ci:6: referenced as `re`
	cmplStd/test/math/test.Complex.ci:6: referenced as `re`
	cmplStd/test/math/test.Complex.ci:6: referenced as `re`
	cmplStd/test/math/test.Complex.ci:6: referenced as `re`
	cmplStd/test/math/test.Complex.ci:5: referenced as `re`
	cmplStd/test/math/test.Complex.ci:5: referenced as `re`
	cmplStd/test/math/test.Complex.ci:4: referenced as `re`
	cmplStd/test/math/test.Complex.ci:4: referenced as `re`
	cmplStd/test/math/test.Complex.ci:3: referenced as `re`
	cmplStd/lib/math/Complex.ci:142: referenced as `re`
	cmplStd/lib/math/Complex.ci:142: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:116: referenced as `re`
	cmplStd/lib/math/Complex.ci:116: referenced as `re`
	cmplStd/lib/math/Complex.ci:108: referenced as `re`
	cmplStd/lib/math/Complex.ci:106: referenced as `re`
	cmplStd/lib/math/Complex.ci:105: referenced as `re`
	cmplStd/lib/math/Complex.ci:96: referenced as `re`
	cmplStd/lib/math/Complex.ci:96: referenced as `re`
	cmplStd/lib/math/Complex.ci:93: referenced as `re`
	cmplStd/lib/math/Complex.ci:87: referenced as `re`
	cmplStd/lib/math/Complex.ci:87: referenced as `re`
	cmplStd/lib/math/Complex.ci:85: referenced as `re`
	cmplStd/lib/math/Complex.ci:85: referenced as `re`
	cmplStd/lib/math/Complex.ci:81: referenced as `re`
	cmplStd/lib/math/Complex.ci:79: referenced as `re`
	cmplStd/lib/math/Complex.ci:79: referenced as `re`
	cmplStd/lib/math/Complex.ci:69: referenced as `re`
	cmplStd/lib/math/Complex.ci:70: referenced as `re`
	cmplStd/lib/math/Complex.ci:69: referenced as `re`
	cmplStd/lib/math/Complex.ci:67: referenced as `re`
	cmplStd/lib/math/Complex.ci:66: referenced as `re`
	cmplStd/lib/math/Complex.ci:62: referenced as `re`
	cmplStd/lib/math/Complex.ci:63: referenced as `re`
	cmplStd/lib/math/Complex.ci:62: referenced as `re`
	cmplStd/lib/math/Complex.ci:60: referenced as `re`
	cmplStd/lib/math/Complex.ci:59: referenced as `re`
	cmplStd/lib/math/Complex.ci:58: referenced as `re`
	cmplStd/lib/math/Complex.ci:51: referenced as `re`
	cmplStd/lib/math/Complex.ci:49: referenced as `re`
	cmplStd/lib/math/Complex.ci:41: referenced as `re`
	cmplStd/lib/math/Complex.ci:39: referenced as `re`
	cmplStd/lib/math/Complex.ci:34: referenced as `re`
	cmplStd/lib/math/Complex.ci:32: referenced as `re`
	cmplStd/lib/math/Complex.ci:21: referenced as `re`
	cmplStd/lib/math/Complex.ci:14: referenced as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'cmplStd/lib/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	cmplStd/test/math/test.Complex.ci:9: referenced as `im`
	cmplStd/test/math/test.Complex.ci:8: referenced as `im`
	cmplStd/test/math/test.Complex.ci:6: referenced as `im`
	cmplStd/test/math/test.Complex.ci:6: referenced as `im`
	cmplStd/test/math/test.Complex.ci:6: referenced as `im`
	cmplStd/test/math/test.Complex.ci:6: referenced as `im`
	cmplStd/test/math/test.Complex.ci:5: referenced as `im`
	cmplStd/test/math/test.Complex.ci:5: referenced as `im`
	cmplStd/test/math/test.Complex.ci:4: referenced as `im`
	cmplStd/test/math/test.Complex.ci:4: referenced as `im`
	cmplStd/test/math/test.Complex.ci:3: referenced as `im`
	cmplStd/lib/math/Complex.ci:142: referenced as `im`
	cmplStd/lib/math/Complex.ci:142: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:116: referenced as `im`
	cmplStd/lib/math/Complex.ci:116: referenced as `im`
	cmplStd/lib/math/Complex.ci:109: referenced as `im`
	cmplStd/lib/math/Complex.ci:106: referenced as `im`
	cmplStd/lib/math/Complex.ci:105: referenced as `im`
	cmplStd/lib/math/Complex.ci:96: referenced as `im`
	cmplStd/lib/math/Complex.ci:96: referenced as `im`
	cmplStd/lib/math/Complex.ci:93: referenced as `im`
	cmplStd/lib/math/Complex.ci:88: referenced as `im`
	cmplStd/lib/math/Complex.ci:88: referenced as `im`
	cmplStd/lib/math/Complex.ci:85: referenced as `im`
	cmplStd/lib/math/Complex.ci:85: referenced as `im`
	cmplStd/lib/math/Complex.ci:81: referenced as `im`
	cmplStd/lib/math/Complex.ci:79: referenced as `im`
	cmplStd/lib/math/Complex.ci:79: referenced as `im`
	cmplStd/lib/math/Complex.ci:70: referenced as `im`
	cmplStd/lib/math/Complex.ci:70: referenced as `im`
	cmplStd/lib/math/Complex.ci:69: referenced as `im`
	cmplStd/lib/math/Complex.ci:67: referenced as `im`
	cmplStd/lib/math/Complex.ci:66: referenced as `im`
	cmplStd/lib/math/Complex.ci:63: referenced as `im`
	cmplStd/lib/math/Complex.ci:63: referenced as `im`
	cmplStd/lib/math/Complex.ci:62: referenced as `im`
	cmplStd/lib/math/Complex.ci:60: referenced as `im`
	cmplStd/lib/math/Complex.ci:59: referenced as `im`
	cmplStd/lib/math/Complex.ci:58: referenced as `im`
	cmplStd/lib/math/Complex.ci:51: referenced as `im`
	cmplStd/lib/math/Complex.ci:49: referenced as `im`
	cmplStd/lib/math/Complex.ci:41: referenced as `im`
	cmplStd/lib/math/Complex.ci:39: referenced as `im`
	cmplStd/lib/math/Complex.ci:34: referenced as `im`
	cmplStd/lib/math/Complex.ci:32: referenced as `im`
	cmplStd/lib/math/Complex.ci:22: referenced as `im`
	internal usages: 1
}
Complex(value: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:12'
.param .result: Complex (size: 16, cast: variable(val))
.param value: float64 (size: 8, cast: variable(f64))
.doc: 'Create a Complex number from the given `value`'
.value: {
	return .result := {
			.result.re := value;
			.result.im := (0);
		};
}
.instructions: (7 bytes)
	cmplStd/lib/math/Complex.ci:13: (7 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:14: (3 bytes): .result.re := value;
	<Complex>  : mov.x64 sp(3, 1)
	:: (3 bytes): .result.im := (0);
	<Complex+?>: load.z64
	<Complex+?>: set.x64 sp(7)
	<Complex+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:113: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:74: referenced as `Complex`
}
Complex(real: float64, imaginary: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:19'
.param .result: Complex (size: 16, cast: variable(val))
.param real: float64 (size: 8, cast: variable(f64))
.param imaginary: float64 (size: 8, cast: variable(f64))
.doc: 'Create a Complex number from the given `real` and `imaginary` values'
.value: {
	return .result := {
			.result.re := real;
			.result.im := imaginary;
		};
}
.instructions: (7 bytes)
	cmplStd/lib/math/Complex.ci:20: (7 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:21: (3 bytes): .result.re := real;
	<Complex>  : mov.x64 sp(5, 3)
	cmplStd/lib/math/Complex.ci:22: (3 bytes): .result.im := imaginary;
	<Complex+?>: mov.x64 sp(7, 1)
	<Complex+?>: ret
.usages:
	cmplStd/test/math/test.Complex.ci:6: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:5: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:4: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:3: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:144: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:142: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:118: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:116: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:99: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:96: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:93: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:51: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:49: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:41: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:39: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:34: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:32: referenced as `Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'cmplStd/lib/math/Complex.ci:27'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Unary negation of a complex number: -a := Complex(-a.re, -a.im);'
.value: Complex(emit(struct(a), neg.p2d))
.usages:
	cmplStd/test/math/test.Complex.ci:12: referenced as `neg`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `neg`
	cmplStd/lib/math/Complex.ci:131: referenced as `neg`
	cmplStd/lib/math/Complex.ci:129: referenced as `neg`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:30'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: Complex (size: 16, cast: val)
.doc: 'Add two complex numbers: a + b := Complex(a.re + b.re, a.im + b.im);'
.value: Complex(emit(struct(a), struct(b), add.p2d))
.usages:
	cmplStd/test/math/test.Complex.ci:15: referenced as `add`
	cmplStd/lib/math/Complex.ci:131: referenced as `add`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:32'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: 'Add a complex number `a` to a real number `b`'
.value: Complex(a.re + b, a.im)
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `add`
	cmplStd/lib/math/Complex.ci:133: referenced as `add`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:34'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Add a complex number `b` to a real number `a`'
.value: Complex(a + b.re, b.im)
.usages:
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:37'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: Complex (size: 16, cast: val)
.doc: 'Subtract two complex numbers: a - b := Complex(a.re - b.re, a.im - b.im);'
.value: Complex(emit(struct(a), struct(b), sub.p2d))
.usages:
	cmplStd/test/math/test.Complex.ci:18: referenced as `sub`
	cmplStd/lib/math/Complex.ci:129: referenced as `sub`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:39'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: 'Subtract the real number `b` from the complex number `a`'
.value: Complex(a.re - b, a.im)
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `sub`
	cmplStd/lib/math/Complex.ci:133: referenced as `sub`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:41'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Subtract the complex number `b` from the real number `a`'
.value: Complex(a - b.re, b.im)
.usages:
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:44'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Multiply two complex numbers: a * b := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);'
.value: Complex(emit(struct(a), struct(b), swz.x2, mul.p2d, add.f64, struct(a), struct(b), mul.p2d, swz.x2, sub.f64))
.usages:
	cmplStd/test/math/test.Complex.ci:21: referenced as `mul`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:49'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Multiply a complex number `a` with a real number `b`'
.value: Complex(a.re * b, a.im * b)
.usages:
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:51'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: variable(f64))
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Multiply a complex number `b` with a real number `a`'
.value: Complex(a * b.re, a * b.im)
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `mul`
	cmplStd/lib/math/Complex.ci:135: referenced as `mul`
	cmplStd/lib/math/Complex.ci:133: referenced as `mul`
	cmplStd/lib/math/Complex.ci:133: referenced as `mul`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 139
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:54'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Divide two complex numbers'
.value: {
	if (Math.abs(b.re) >= Math.abs(b.im)) {
		r: float64 := b.im / b.re;
		den: float64 := b.re + r * b.im;
		return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
	}
	r: float64 := b.re / b.im;
	den: float64 := b.im + r * b.re;
	return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
}
.instructions: (139 bytes)
	cmplStd/lib/math/Complex.ci:58: (95 bytes): if (Math.abs(b.re) >= Math.abs(b.im))
	<div>  : dup.x64 sp(1)
	<div+?>: dup.x64 sp(0)
	<div+?>: load.z64
	<div+?>: clt.f64
	<div+?>: jz +11
	<div+?>: dup.x64 sp(0)
	<div+?>: neg.f64
	<div+?>: jmp +6
	<div+?>: dup.x64 sp(0)
	<div+?>: set.x64 sp(2)
	<div+?>: dup.x64 sp(5)
	<div+?>: dup.x64 sp(0)
	<div+?>: load.z64
	<div+?>: clt.f64
	<div+?>: jz +11
	<div+?>: dup.x64 sp(0)
	<div+?>: neg.f64
	<div+?>: jmp +6
	<div+?>: dup.x64 sp(0)
	<div+?>: set.x64 sp(2)
	<div+?>: clt.f64
	<div+?>: jnz +52
	cmplStd/lib/math/Complex.ci:59: (5 bytes): r: float64 := b.im / b.re
	<div+?>: dup.x64 sp(3)
	<div+?>: dup.x64 sp(3)
	<div+?>: div.f64
	cmplStd/lib/math/Complex.ci:60: (8 bytes): den: float64 := b.re + r * b.im
	<div+?>: dup.x64 sp(3)
	<div+?>: dup.x64 sp(2)
	<div+?>: dup.x64 sp(9)
	<div+?>: mul.f64
	<div+?>: add.f64
	cmplStd/lib/math/Complex.ci:61: (31 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:62: (13 bytes): .result.re := (a.re + r * a.im) / den;
	<div+?>: dup.x64 sp(9)
	<div+?>: dup.x64 sp(4)
	<div+?>: dup.x64 sp(15)
	<div+?>: mul.f64
	<div+?>: add.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:63: (13 bytes): .result.im := (a.im - r * a.re) / den;
	<div+?>: dup.x64 sp(11)
	<div+?>: dup.x64 sp(4)
	<div+?>: dup.x64 sp(13)
	<div+?>: mul.f64
	<div+?>: sub.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
	<div+?>: inc.sp(-16)
	cmplStd/lib/math/Complex.ci:66: (5 bytes): r: float64 := b.re / b.im
	<div+?>: dup.x64 sp(1)
	<div+?>: dup.x64 sp(5)
	<div+?>: div.f64
	cmplStd/lib/math/Complex.ci:67: (8 bytes): den: float64 := b.im + r * b.re
	<div+?>: dup.x64 sp(5)
	<div+?>: dup.x64 sp(2)
	<div+?>: dup.x64 sp(7)
	<div+?>: mul.f64
	<div+?>: add.f64
	cmplStd/lib/math/Complex.ci:68: (31 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:69: (13 bytes): .result.re := (a.re * r + a.im) / den;
	<div+?>: dup.x64 sp(9)
	<div+?>: dup.x64 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x64 sp(13)
	<div+?>: add.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:70: (13 bytes): .result.im := (a.im * r - a.re) / den;
	<div+?>: dup.x64 sp(11)
	<div+?>: dup.x64 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x64 sp(11)
	<div+?>: sub.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `div`
	cmplStd/lib/math/Complex.ci:133: referenced as `div`
	cmplStd/lib/math/Complex.ci:122: referenced as `div`
	cmplStd/lib/math/Complex.ci:120: referenced as `div`
	cmplStd/lib/math/Complex.ci:76: referenced as `div`
	cmplStd/lib/math/Complex.ci:74: referenced as `div`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:74'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: 'Divide the complex number `a` by the real number `b`'
.value: div(a, Complex(b))
.usages:
	cmplStd/lib/math/Complex.ci:131: referenced as `div`
	cmplStd/lib/math/Complex.ci:129: referenced as `div`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:76'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: val)
.doc: 'Divide the real number `a` by the complex number `b`'
.value: div(Complex(a), b)
.usages:
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Complex.ci:79'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the absolute value of the complex number `a`'
.value: Math.sqrt(a.re * a.re + a.im * a.im)
.usages:
	cmplStd/lib/math/Complex.ci:144: referenced as `abs`
	cmplStd/lib/math/Complex.ci:103: referenced as `abs`
	cmplStd/lib/math/Complex.ci:99: referenced as `abs`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'arg'
.file: 'cmplStd/lib/math/Complex.ci:81'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the argument of the complex number `a`'
.value: Math.atan2(a.re, a.im)
.usages:
	cmplStd/lib/math/Complex.ci:144: referenced as `arg`
	cmplStd/lib/math/Complex.ci:104: referenced as `arg`
	cmplStd/lib/math/Complex.ci:99: referenced as `arg`
}
inv(a: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 31
.name: 'inv'
.file: 'cmplStd/lib/math/Complex.ci:84'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := a.re * a.re + a.im * a.im;
	return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
}
.instructions: (31 bytes)
	cmplStd/lib/math/Complex.ci:85: (11 bytes): d: float64 := a.re * a.re + a.im * a.im
	<inv>  : dup.x64 sp(1)
	<inv+?>: dup.x64 sp(3)
	<inv+?>: mul.f64
	<inv+?>: dup.x64 sp(5)
	<inv+?>: dup.x64 sp(7)
	<inv+?>: mul.f64
	<inv+?>: add.f64
	cmplStd/lib/math/Complex.ci:86: (20 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:87: (7 bytes): .result.re := +a.re / d;
	<inv+?>: dup.x64 sp(3)
	<inv+?>: dup.x64 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x64 sp(9)
	cmplStd/lib/math/Complex.ci:88: (8 bytes): .result.im := -a.im / d;
	<inv+?>: dup.x64 sp(5)
	<inv+?>: neg.f64
	<inv+?>: dup.x64 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x64 sp(11)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:139: referenced as `inv`
	cmplStd/lib/math/Complex.ci:137: referenced as `inv`
	cmplStd/lib/math/Complex.ci:126: referenced as `inv`
	cmplStd/lib/math/Complex.ci:124: referenced as `inv`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'conj'
.file: 'cmplStd/lib/math/Complex.ci:93'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the conjugate of the complex number `a`'
.value: Complex(a.re, -a.im)
.usages:
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'exp'
.file: 'cmplStd/lib/math/Complex.ci:96'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the exponential of a complex number: $ e^a $.'
.value: Complex(Math.exp(a.re) * Math.cos(a.im), Math.exp(a.re) * Math.sin(a.im))
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `exp`
	cmplStd/lib/math/Complex.ci:135: referenced as `exp`
	cmplStd/lib/math/Complex.ci:133: referenced as `exp`
	cmplStd/lib/math/Complex.ci:133: referenced as `exp`
	cmplStd/lib/math/Complex.ci:131: referenced as `exp`
	cmplStd/lib/math/Complex.ci:131: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'log'
.file: 'cmplStd/lib/math/Complex.ci:99'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the natural logarithm of the complex number `a`.'
.value: Complex(Math.log(abs(a)), arg(a))
.usages:
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 151
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:102'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Compute the complex number `a` raised to the power of `b`: $ a^b $.'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := b.re * t + b.im * Math.log(r);
	v: float64 := Math.pow(r, b.re) * Math.exp(-b.im * t);
	return .result := {
			.result.re := v * Math.cos(u);
			.result.im := v * Math.sin(u);
		};
}
.instructions: (151 bytes)
	cmplStd/lib/math/Complex.ci:103: (31 bytes): r: float64 := abs(a)
	<pow>  : dup.x128 sp(5)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(2)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: mul.f64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: dup.x64 sp(8)
	<pow+?>: mul.f64
	<pow+?>: add.f64
	<pow+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mov.x64 sp(4, 0)
	<pow+?>: inc.sp(-16)
	cmplStd/lib/math/Complex.ci:104: (24 bytes): t: float64 := arg(a)
	<pow+?>: dup.x128 sp(7)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(2)
	<pow+?>: dup.x64 sp(6)
	<pow+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-16)
	<pow+?>: mov.x64 sp(4, 0)
	<pow+?>: inc.sp(-16)
	cmplStd/lib/math/Complex.ci:105: (22 bytes): u: float64 := b.re * t + b.im * Math.log(r)
	<pow+?>: dup.x64 sp(5)
	<pow+?>: dup.x64 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x64 sp(9)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(8)
	<pow+?>: load.ref <?> ;Math.log(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: add.f64
	cmplStd/lib/math/Complex.ci:106: (33 bytes): v: float64 := Math.pow(r, b.re) * Math.exp(-b.im * t)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: dup.x64 sp(11)
	<pow+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-16)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(13)
	<pow+?>: neg.f64
	<pow+?>: dup.x64 sp(8)
	<pow+?>: mul.f64
	<pow+?>: load.ref <?> ;Math.exp(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	cmplStd/lib/math/Complex.ci:107: (41 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:108: (18 bytes): .result.re := v * Math.cos(u);
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: load.ref <?> ;Math.cos(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(19)
	cmplStd/lib/math/Complex.ci:109: (18 bytes): .result.im := v * Math.sin(u);
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: load.ref <?> ;Math.sin(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(21)
	<pow+?>: inc.sp(-32)
	<pow+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:113: referenced as `pow`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:113'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: 'Compute the complex number `a` raised to the power of `b`: $ a^b $.'
.value: pow(a, Complex(b))
.usages:
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'cmplStd/lib/math/Complex.ci:116'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the sine of the complex number `a`.'
.value: Complex(Math.sin(a.re) * Math.cosh(a.im), +Math.cos(a.re) * Math.sinh(a.im))
.usages:
	cmplStd/lib/math/Complex.ci:126: referenced as `sin`
	cmplStd/lib/math/Complex.ci:122: referenced as `sin`
	cmplStd/lib/math/Complex.ci:120: referenced as `sin`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'cmplStd/lib/math/Complex.ci:118'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the cosine of the complex number `a`.'
.value: Complex(Math.cos(a.re) * Math.cosh(a.im), -Math.sin(a.re) * Math.sinh(a.im))
.usages:
	cmplStd/lib/math/Complex.ci:124: referenced as `cos`
	cmplStd/lib/math/Complex.ci:122: referenced as `cos`
	cmplStd/lib/math/Complex.ci:120: referenced as `cos`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tan'
.file: 'cmplStd/lib/math/Complex.ci:120'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the tangent of the complex number `a`.'
.value: div(sin(a), cos(a))
.usages:
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cot'
.file: 'cmplStd/lib/math/Complex.ci:122'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the cotangent of the complex number `a`.'
.value: div(cos(a), sin(a))
.usages:
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'cmplStd/lib/math/Complex.ci:124'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Compute the secant of the complex number `a`.'
.value: inv(cos(a))
.usages:
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'cmplStd/lib/math/Complex.ci:126'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Compute the cosecant of the complex number `a`.'
.value: inv(sin(a))
.usages:
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'cmplStd/lib/math/Complex.ci:129'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the hyperbolic sine of the complex number `a`.'
.value: div(sub(exp(a), exp(neg(a))), 2)
.usages:
	cmplStd/lib/math/Complex.ci:139: referenced as `sinh`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'cmplStd/lib/math/Complex.ci:131'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the hyperbolic cosine of the complex number `a`.'
.value: div(add(exp(a), exp(neg(a))), 2)
.usages:
	cmplStd/lib/math/Complex.ci:137: referenced as `cosh`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'cmplStd/lib/math/Complex.ci:133'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the hyperbolic tangent of the complex number `a`.'
.value: div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1))
.usages:
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'cmplStd/lib/math/Complex.ci:135'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the hyperbolic cotangent of the complex number `a`.'
.value: div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1))
.usages:
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'cmplStd/lib/math/Complex.ci:137'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Compute the hyperbolic secant of the complex number `a`.'
.value: inv(cosh(a))
.usages:
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'cmplStd/lib/math/Complex.ci:139'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Compute the hyperbolic cosecant of the complex number `a`.'
.value: inv(sinh(a))
.usages:
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toCartesian'
.file: 'cmplStd/lib/math/Complex.ci:142'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: 'Convert the from polar(r,) to cartesian(x,y) coordinates'
.value: Complex(x.re * Math.cos(x.im), x.re * Math.sin(x.im))
.usages:
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toPolar'
.file: 'cmplStd/lib/math/Complex.ci:144'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: 'Convert the from cartesian(x,y) to polar(r,) coordinates'
.value: Complex(abs(x), arg(x))
.usages:
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:2'
.field <?>: vec4f.<?> (size: 16, cast: variable(val))
.field x: float32 (size: 0, cast: inline)
.field y: float32 (size: 0, cast: inline)
.field z: float32 (size: 0, cast: inline)
.field w: float32 (size: 0, cast: inline)
.field data: float32[4] (size: 16, cast: variable(val))
.doc: 'A 4d vector (4x float32)'
.usages:
	cmplGfx/lib/window.ci:348: referenced as `vec4f`
	cmplGfx/lib/window.ci:347: referenced as `vec4f`
	cmplGfx/lib/window.ci:346: referenced as `vec4f`
	cmplGfx/lib/window.ci:226: referenced as `vec4f`
	cmplGfx/lib/window.ci:219: referenced as `vec4f`
	cmplGfx/lib/window.ci:160: referenced as `vec4f`
	cmplGfx/lib/window.ci:160: referenced as `vec4f`
	cmplGfx/lib/window.ci:92: referenced as `vec4f`
	cmplGfx/lib/window.ci:92: referenced as `vec4f`
	cmplGfx/lib/window.ci:83: referenced as `vec4f`
	cmplGfx/lib/window.ci:83: referenced as `vec4f`
	cmplGfx/lib/camera.ci:72: referenced as `vec4f`
	cmplGfx/lib/camera.ci:72: referenced as `vec4f`
	cmplGfx/lib/camera.ci:67: referenced as `vec4f`
	cmplGfx/lib/camera.ci:42: referenced as `vec4f`
	cmplGfx/lib/camera.ci:41: referenced as `vec4f`
	cmplGfx/lib/camera.ci:40: referenced as `vec4f`
	cmplGfx/lib/camera.ci:40: referenced as `vec4f`
	cmplGfx/lib/camera.ci:40: referenced as `vec4f`
	cmplGfx/lib/camera.ci:10: referenced as `vec4f`
	cmplGfx/lib/camera.ci:8: referenced as `vec4f`
	cmplGfx/lib/camera.ci:6: referenced as `vec4f`
	cmplGfx/lib/camera.ci:4: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:57: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:46: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:178: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:159: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:159: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:57: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:57: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:57: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:53: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:53: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:53: referenced as `vec4f`
	cmplGfx/lib/color.hsl.ci:61: referenced as `vec4f`
	cmplGfx/lib/color.hsl.ci:61: referenced as `vec4f`
	cmplGfx/lib/color.hsl.ci:3: referenced as `vec4f`
	cmplGfx/lib/color.hsl.ci:3: referenced as `vec4f`
	cmplGfx/lib/color.ci:177: referenced as `vec4f`
	cmplGfx/lib/color.ci:174: referenced as `vec4f`
	cmplGfx/lib/color.ci:168: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:201: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:191: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:158: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:109: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:109: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:20: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:18: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:16: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:14: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:10: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:139: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:137: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:114: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:114: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:103: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:103: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:103: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `vec4f`
	internal usages: 1
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.name: '<?>'
.file: 'cmplStd/lib/math/Vector4f.ci:153'
.owner: vec4f
.field x: float32 (size: 4, cast: variable(f32))
.field y: float32 (size: 4, cast: variable(f32))
.field z: float32 (size: 4, cast: variable(f32))
.field w: float32 (size: 4, cast: variable(f32))
.usages:
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	cmplGfx/lib/window.ci:348: referenced as `x`
	cmplGfx/lib/window.ci:347: referenced as `x`
	cmplGfx/lib/window.ci:346: referenced as `x`
	cmplGfx/lib/image.transform.ci:127: referenced as `x`
	cmplGfx/lib/image.transform.ci:126: referenced as `x`
	cmplGfx/lib/image.transform.ci:125: referenced as `x`
	cmplGfx/lib/image.transform.ci:124: referenced as `x`
	cmplGfx/lib/image.transform.ci:58: referenced as `x`
	cmplGfx/lib/image.transform.ci:47: referenced as `x`
	cmplGfx/lib/image.blend.ci:182: referenced as `x`
	cmplGfx/lib/color.hsl.ci:96: referenced as `x`
	cmplGfx/lib/color.hsl.ci:98: referenced as `x`
	cmplGfx/lib/color.hsl.ci:97: referenced as `x`
	cmplGfx/lib/color.hsl.ci:96: referenced as `x`
	cmplGfx/lib/color.hsl.ci:54: referenced as `x`
	cmplGfx/lib/color.hsl.ci:36: referenced as `x`
	cmplGfx/lib/color.hsl.ci:31: referenced as `x`
	cmplGfx/lib/color.hsl.ci:17: referenced as `x`
	cmplGfx/lib/color.hsl.ci:8: referenced as `x`
	cmplGfx/lib/color.hsl.ci:7: referenced as `x`
	cmplGfx/lib/color.ci:177: referenced as `x`
	cmplGfx/lib/color.ci:174: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:182: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:162: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:159: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:159: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:120: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:115: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:115: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	cmplGfx/lib/window.ci:348: referenced as `y`
	cmplGfx/lib/window.ci:347: referenced as `y`
	cmplGfx/lib/window.ci:346: referenced as `y`
	cmplGfx/lib/image.transform.ci:127: referenced as `y`
	cmplGfx/lib/image.transform.ci:126: referenced as `y`
	cmplGfx/lib/image.transform.ci:125: referenced as `y`
	cmplGfx/lib/image.transform.ci:124: referenced as `y`
	cmplGfx/lib/image.transform.ci:58: referenced as `y`
	cmplGfx/lib/image.transform.ci:47: referenced as `y`
	cmplGfx/lib/image.blend.ci:180: referenced as `y`
	cmplGfx/lib/color.hsl.ci:97: referenced as `y`
	cmplGfx/lib/color.hsl.ci:91: referenced as `y`
	cmplGfx/lib/color.hsl.ci:91: referenced as `y`
	cmplGfx/lib/color.hsl.ci:88: referenced as `y`
	cmplGfx/lib/color.hsl.ci:82: referenced as `y`
	cmplGfx/lib/color.hsl.ci:55: referenced as `y`
	cmplGfx/lib/color.hsl.ci:39: referenced as `y`
	cmplGfx/lib/color.hsl.ci:32: referenced as `y`
	cmplGfx/lib/color.hsl.ci:18: referenced as `y`
	cmplGfx/lib/color.hsl.ci:8: referenced as `y`
	cmplGfx/lib/color.hsl.ci:7: referenced as `y`
	cmplGfx/lib/color.ci:177: referenced as `y`
	cmplGfx/lib/color.ci:174: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:181: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:164: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:162: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:121: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	cmplGfx/lib/window.ci:348: referenced as `z`
	cmplGfx/lib/window.ci:347: referenced as `z`
	cmplGfx/lib/window.ci:346: referenced as `z`
	cmplGfx/lib/image.transform.ci:127: referenced as `z`
	cmplGfx/lib/image.transform.ci:126: referenced as `z`
	cmplGfx/lib/image.transform.ci:125: referenced as `z`
	cmplGfx/lib/image.transform.ci:124: referenced as `z`
	cmplGfx/lib/color.hsl.ci:98: referenced as `z`
	cmplGfx/lib/color.hsl.ci:94: referenced as `z`
	cmplGfx/lib/color.hsl.ci:91: referenced as `z`
	cmplGfx/lib/color.hsl.ci:91: referenced as `z`
	cmplGfx/lib/color.hsl.ci:88: referenced as `z`
	cmplGfx/lib/color.hsl.ci:87: referenced as `z`
	cmplGfx/lib/color.hsl.ci:83: referenced as `z`
	cmplGfx/lib/color.hsl.ci:56: referenced as `z`
	cmplGfx/lib/color.hsl.ci:42: referenced as `z`
	cmplGfx/lib/color.hsl.ci:33: referenced as `z`
	cmplGfx/lib/color.hsl.ci:19: referenced as `z`
	cmplGfx/lib/color.hsl.ci:8: referenced as `z`
	cmplGfx/lib/color.hsl.ci:7: referenced as `z`
	cmplGfx/lib/color.ci:177: referenced as `z`
	cmplGfx/lib/color.ci:174: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:172: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:164: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:161: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:161: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:117: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:117: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	cmplGfx/lib/window.ci:348: referenced as `w`
	cmplGfx/lib/window.ci:347: referenced as `w`
	cmplGfx/lib/window.ci:346: referenced as `w`
	cmplGfx/lib/image.transform.ci:127: referenced as `w`
	cmplGfx/lib/image.transform.ci:126: referenced as `w`
	cmplGfx/lib/image.transform.ci:125: referenced as `w`
	cmplGfx/lib/image.transform.ci:124: referenced as `w`
	cmplGfx/lib/color.ci:174: referenced as `w`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `w`
	cmplStd/lib/math/Vector4f.ci:118: referenced as `w`
	cmplStd/lib/math/Vector4f.ci:118: referenced as `w`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.name: 'data'
.file: 'cmplStd/lib/math/Vector4f.ci:14'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
	cmplGfx/lib/window.ci:178: referenced as `data`
	cmplGfx/lib/window.ci:178: referenced as `data`
	cmplGfx/lib/window.ci:178: referenced as `data`
	cmplGfx/lib/window.ci:178: referenced as `data`
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.param z: float32 (size: 4, cast: f32)
.param w: float32 (size: 4, cast: f32)
.doc: 'Initialize with given x, y, z, w components'
.value: vec4f(emit(struct(w), struct(z), struct(y), struct(x)))
.usages:
	cmplGfx/lib/camera.ci:57: referenced as `vec4f`
	cmplGfx/lib/camera.ci:35: referenced as `vec4f`
	cmplGfx/lib/camera.ci:34: referenced as `vec4f`
	cmplGfx/lib/camera.ci:33: referenced as `vec4f`
	cmplGfx/lib/camera.ci:32: referenced as `vec4f`
	cmplGfx/lib/camera.ci:23: referenced as `vec4f`
	cmplGfx/lib/camera.ci:22: referenced as `vec4f`
	cmplGfx/lib/camera.ci:21: referenced as `vec4f`
	cmplGfx/lib/camera.ci:20: referenced as `vec4f`
	cmplGfx/lib/camera.ci:10: referenced as `vec4f`
	cmplGfx/lib/camera.ci:8: referenced as `vec4f`
	cmplGfx/lib/camera.ci:6: referenced as `vec4f`
	cmplGfx/lib/camera.ci:4: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:57: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:54: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:46: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:29: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:27: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:26: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:25: referenced as `vec4f`
	cmplGfx/lib/image.transform.ci:24: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:178: referenced as `vec4f`
	cmplGfx/lib/color.ci:171: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:186: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:153: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:115: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:114: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:114: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:29'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.param z: float32 (size: 4, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(x, y, z, 1.000000)
.usages:
	cmplGfx/lib/window.ci:219: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:32'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(x, y, 0.000000, 1.000000)
.usages:
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:35'
.param .result: vec4f (size: 16, cast: val)
.param xyz: vec4f (size: 16, cast: variable(val))
.param w: float32 (size: 4, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(xyz.x, xyz.y, xyz.z, w)
.usages:
	cmplGfx/lib/camera.ci:56: referenced as `vec4f`
	cmplGfx/lib/camera.ci:55: referenced as `vec4f`
	cmplGfx/lib/camera.ci:54: referenced as `vec4f`
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:38'
.param .result: vec4f (size: 16, cast: val)
.param val: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(val, val, val, val)
.usages:
	cmplGfx/lib/color.hsl.ci:83: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:139: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'cmplStd/lib/math/Vector4f.ci:69'
.param .result: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(struct(rhs), neg.p4f))
.usages:
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), add.p4f))
.usages:
	cmplGfx/lib/camera.ci:68: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `add`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), sub.p4f))
.usages:
	cmplGfx/lib/camera.ci:41: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `sub`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), mul.p4f))
.usages:
	cmplStd/lib/math/Vector4f.ci:92: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `mul`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), div.p4f))
.usages:
	cmplStd/lib/math/Vector4f.ci:139: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `div`
}
add(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:80'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise add vector and scalar.'
.value: add(vec4f(a), b)
.usages:
}
add(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:82'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise add vector and scalar.'
.value: add(a, vec4f(b))
.usages:
}
sub(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:85'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(vec4f(a), b)
.usages:
}
sub(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:87'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(a, vec4f(b))
.usages:
}
mul(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:90'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(vec4f(a), b)
.usages:
}
mul(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:92'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(a, vec4f(b))
.usages:
	cmplGfx/lib/camera.ci:68: referenced as `mul`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `mul`
}
div(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:95'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise divide vector and scalar.'
.value: div(vec4f(a), b)
.usages:
}
div(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:97'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise divide vector and scalar.'
.value: div(a, vec4f(b))
.usages:
}
abs(a: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Vector4f.ci:100'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: variable(val))
.doc: 'Component wise absolute value of a vector.'
.value: vec4f(Math.abs(a.x), Math.abs(a.y), Math.abs(a.z), Math.abs(a.w))
.usages:
}
min(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Vector4f.ci:103'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), min.p4f))
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `min`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `min`
}
max(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Vector4f.ci:105'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), max.p4f))
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `max`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `max`
}
clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:108'
.param .result: vec4f (size: 16, cast: val)
.param vec: vec4f (size: 16, cast: val)
.param min: vec4f (size: 16, cast: val)
.param max: vec4f (size: 16, cast: val)
.doc: 'Clamp the vector component wise to the range [min ... max]'
.value: min(max(vec, min), max)
.usages:
	cmplStd/lib/math/Vector4f.ci:111: referenced as `clamp`
}
clamp(vec: vec4f, min: float32, max: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:111'
.param .result: vec4f (size: 16, cast: val)
.param vec: vec4f (size: 16, cast: val)
.param min: float32 (size: 4, cast: f32)
.param max: float32 (size: 4, cast: f32)
.doc: 'Clamp each component of the vector to the range [min ... max]'
.value: clamp(vec, vec4f(min), vec4f(max))
.usages:
}
mix(a: vec4f, b: vec4f, t: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mix'
.file: 'cmplStd/lib/math/Vector4f.ci:114'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: variable(val))
.param b: vec4f (size: 16, cast: variable(val))
.param t: float32 (size: 4, cast: variable(f32))
.doc: 'linear interpolate'
.value: vec4f(Math.mix(a.x, b.x, t), Math.mix(a.y, b.y, t), Math.mix(a.z, b.z, t), Math.mix(a.w, b.w, t))
.usages:
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'cmplStd/lib/math/Vector4f.ci:123'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dp3))
.usages:
	cmplGfx/lib/camera.ci:56: referenced as `dp3`
	cmplGfx/lib/camera.ci:55: referenced as `dp3`
	cmplGfx/lib/camera.ci:54: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Vector4f.ci:137: referenced as `dp3`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'cmplStd/lib/math/Vector4f.ci:127'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dph))
.usages:
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'cmplStd/lib/math/Vector4f.ci:131'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dp4))
.usages:
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cross'
.file: 'cmplStd/lib/math/Vector4f.ci:134'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 4, cast: const variable(ref))
.param b: vec4f (size: 4, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
.usages:
	cmplGfx/lib/camera.ci:81: referenced as `cross`
	cmplGfx/lib/camera.ci:47: referenced as `cross`
	cmplGfx/lib/camera.ci:42: referenced as `cross`
}
length(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'length'
.file: 'cmplStd/lib/math/Vector4f.ci:137'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 16, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: Math.sqrt(dp3(v, v))
.usages:
	cmplStd/lib/math/Matrix4f.ci:110: referenced as `length`
	cmplStd/lib/math/Vector4f.ci:139: referenced as `length`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'normalize'
.file: 'cmplStd/lib/math/Vector4f.ci:139'
.param .result: vec4f (size: 16, cast: val)
.param v: vec4f (size: 4, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(v, vec4f(length(v)))
.usages:
	cmplGfx/lib/camera.ci:80: referenced as `normalize`
	cmplGfx/lib/camera.ci:79: referenced as `normalize`
	cmplGfx/lib/camera.ci:42: referenced as `normalize`
	cmplGfx/lib/camera.ci:41: referenced as `normalize`
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Vector4f.ci:142'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 4, cast: const variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32((((v.w * x + v.z) * x + v.y) * x) + v.x)
.usages:
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:2'
.field m: float32[4][4] (size: 64, cast: variable(val))
.field data: float32[16] (size: 64, cast: variable(val))
.field v: vec4f[4] (size: 64, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, cast: variable(val))
.field x: vec4f (size: 0, cast: inline)
.field y: vec4f (size: 0, cast: inline)
.field z: vec4f (size: 0, cast: inline)
.field w: vec4f (size: 0, cast: inline)
.field <?>: mat4f.<?> (size: 64, cast: variable(val))
.field xx: float32 (size: 0, cast: inline)
.field xy: float32 (size: 0, cast: inline)
.field xz: float32 (size: 0, cast: inline)
.field xw: float32 (size: 0, cast: inline)
.field yx: float32 (size: 0, cast: inline)
.field yy: float32 (size: 0, cast: inline)
.field yz: float32 (size: 0, cast: inline)
.field yw: float32 (size: 0, cast: inline)
.field zx: float32 (size: 0, cast: inline)
.field zy: float32 (size: 0, cast: inline)
.field zz: float32 (size: 0, cast: inline)
.field zw: float32 (size: 0, cast: inline)
.field wx: float32 (size: 0, cast: inline)
.field wy: float32 (size: 0, cast: inline)
.field wz: float32 (size: 0, cast: inline)
.field ww: float32 (size: 0, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	cmplGfx/lib/window.ci:172: referenced as `mat4f`
	cmplGfx/lib/camera.ci:78: referenced as `mat4f`
	cmplGfx/lib/camera.ci:62: referenced as `mat4f`
	cmplGfx/lib/camera.ci:52: referenced as `mat4f`
	cmplGfx/lib/camera.ci:13: referenced as `mat4f`
	cmplGfx/lib/color.matrix.ci:2: referenced as `mat4f`
	cmplGfx/lib/image.transform.ci:123: referenced as `mat4f`
	cmplGfx/lib/image.transform.ci:54: referenced as `mat4f`
	cmplGfx/lib/image.transform.ci:23: referenced as `mat4f`
	cmplGfx/lib/image.transform.ci:2: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:213: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:213: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:201: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:191: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:158: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:109: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.name: 'm'
.file: 'cmplStd/lib/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.name: 'data'
.file: 'cmplStd/lib/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
	cmplGfx/lib/window.ci:178: referenced as `data`
	cmplGfx/lib/color.matrix.ci:4: referenced as `data`
	cmplGfx/lib/image.transform.ci:4: referenced as `data`
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.name: 'v'
.file: 'cmplStd/lib/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:268'
.owner: mat4f
.field x: vec4f (size: 16, cast: variable(val))
.field y: vec4f (size: 16, cast: variable(val))
.field z: vec4f (size: 16, cast: variable(val))
.field w: vec4f (size: 16, cast: variable(val))
.usages:
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: 'The first row as a vector'
.usages:
	cmplGfx/lib/camera.ci:54: referenced as `x`
	cmplGfx/lib/camera.ci:32: referenced as `x`
	cmplGfx/lib/camera.ci:20: referenced as `x`
	cmplGfx/lib/image.transform.ci:124: referenced as `x`
	cmplGfx/lib/image.transform.ci:24: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:114: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: 'The second row as a vector'
.usages:
	cmplGfx/lib/camera.ci:55: referenced as `y`
	cmplGfx/lib/camera.ci:33: referenced as `y`
	cmplGfx/lib/camera.ci:21: referenced as `y`
	cmplGfx/lib/image.transform.ci:125: referenced as `y`
	cmplGfx/lib/image.transform.ci:25: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:115: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: 'The third row as a vector'
.usages:
	cmplGfx/lib/camera.ci:56: referenced as `z`
	cmplGfx/lib/camera.ci:34: referenced as `z`
	cmplGfx/lib/camera.ci:22: referenced as `z`
	cmplGfx/lib/image.transform.ci:126: referenced as `z`
	cmplGfx/lib/image.transform.ci:26: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: 'The fourth row as a vector'
.usages:
	cmplGfx/lib/camera.ci:57: referenced as `w`
	cmplGfx/lib/camera.ci:35: referenced as `w`
	cmplGfx/lib/camera.ci:23: referenced as `w`
	cmplGfx/lib/image.transform.ci:127: referenced as `w`
	cmplGfx/lib/image.transform.ci:27: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:186: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:153: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f
.doc: 'The first row as a vector'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f
.doc: 'The second row as a vector'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f
.doc: 'The third row as a vector'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f
.doc: 'The fourth row as a vector'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:268'
.owner: mat4f
.field xx: float32 (size: 4, cast: variable(f32))
.field xy: float32 (size: 4, cast: variable(f32))
.field xz: float32 (size: 4, cast: variable(f32))
.field xw: float32 (size: 4, cast: variable(f32))
.field yx: float32 (size: 4, cast: variable(f32))
.field yy: float32 (size: 4, cast: variable(f32))
.field yz: float32 (size: 4, cast: variable(f32))
.field yw: float32 (size: 4, cast: variable(f32))
.field zx: float32 (size: 4, cast: variable(f32))
.field zy: float32 (size: 4, cast: variable(f32))
.field zz: float32 (size: 4, cast: variable(f32))
.field zw: float32 (size: 4, cast: variable(f32))
.field wx: float32 (size: 4, cast: variable(f32))
.field wy: float32 (size: 4, cast: variable(f32))
.field wz: float32 (size: 4, cast: variable(f32))
.field ww: float32 (size: 4, cast: variable(f32))
.usages:
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: 'The first element of the first row'
.usages:
	cmplGfx/lib/color.matrix.ci:20: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:250: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:214: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:171: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:138: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: 'The second element of the first row'
.usages:
	cmplGfx/lib/color.matrix.ci:21: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:251: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:215: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:172: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:139: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: 'The third element of the first row'
.usages:
	cmplGfx/lib/color.matrix.ci:22: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:252: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:216: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:140: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: 'The fourth element of the first row'
.usages:
	cmplGfx/lib/color.matrix.ci:23: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:253: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:217: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:174: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:141: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: 'The first element of the second row'
.usages:
	cmplGfx/lib/color.matrix.ci:25: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:254: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:219: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:143: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: 'The second element of the second row'
.usages:
	cmplGfx/lib/color.matrix.ci:26: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:255: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:220: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:144: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: 'The third element of the second row'
.usages:
	cmplGfx/lib/color.matrix.ci:27: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:256: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:221: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:145: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: 'The fourth element of the second row'
.usages:
	cmplGfx/lib/color.matrix.ci:28: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:257: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:222: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:146: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: 'The first element of the third row'
.usages:
	cmplGfx/lib/color.matrix.ci:30: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:258: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:224: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:181: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:148: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: 'The second element of the third row'
.usages:
	cmplGfx/lib/color.matrix.ci:31: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:259: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:225: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:182: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:149: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: 'The third element of the third row'
.usages:
	cmplGfx/lib/color.matrix.ci:32: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:260: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:226: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:183: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:150: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: 'The fourth element of the third row'
.usages:
	cmplGfx/lib/color.matrix.ci:33: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:261: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:227: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:184: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:151: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: 'The first element of the fourth row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:262: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:229: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: 'The second element of the fourth row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:263: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:230: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: 'The third element of the fourth row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:264: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:231: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: 'The fourth element of the fourth row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:265: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:232: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f
.doc: 'The first element of the first row'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f
.doc: 'The second element of the first row'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f
.doc: 'The third element of the first row'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f
.doc: 'The fourth element of the first row'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f
.doc: 'The first element of the second row'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f
.doc: 'The second element of the second row'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f
.doc: 'The third element of the second row'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f
.doc: 'The fourth element of the second row'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f
.doc: 'The first element of the third row'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f
.doc: 'The second element of the third row'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f
.doc: 'The third element of the third row'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f
.doc: 'The fourth element of the third row'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f
.doc: 'The first element of the fourth row'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f
.doc: 'The second element of the fourth row'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f
.doc: 'The third element of the fourth row'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f
.doc: 'The fourth element of the fourth row'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, cast: variable(val))
.param xx: float32 (size: 4, cast: variable(f32))
.param xy: float32 (size: 4, cast: variable(f32))
.param xz: float32 (size: 4, cast: variable(f32))
.param xw: float32 (size: 4, cast: variable(f32))
.param yx: float32 (size: 4, cast: variable(f32))
.param yy: float32 (size: 4, cast: variable(f32))
.param yz: float32 (size: 4, cast: variable(f32))
.param yw: float32 (size: 4, cast: variable(f32))
.param zx: float32 (size: 4, cast: variable(f32))
.param zy: float32 (size: 4, cast: variable(f32))
.param zz: float32 (size: 4, cast: variable(f32))
.param zw: float32 (size: 4, cast: variable(f32))
.param wx: float32 (size: 4, cast: variable(f32))
.param wy: float32 (size: 4, cast: variable(f32))
.param wz: float32 (size: 4, cast: variable(f32))
.param ww: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return .result := {
			.result.xx := xx;
			.result.xy := xy;
			.result.xz := xz;
			.result.xw := xw;
			.result.yx := yx;
			.result.yy := yy;
			.result.yz := yz;
			.result.yw := yw;
			.result.zx := zx;
			.result.zy := zy;
			.result.zz := zz;
			.result.zw := zw;
			.result.wx := wx;
			.result.wy := wy;
			.result.wz := wz;
			.result.ww := ww;
		};
}
.instructions: (49 bytes)
	cmplStd/lib/math/Matrix4f.ci:66: (49 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xx := xx;
	<mat4f>  : mov.x32 sp(17, 16)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xy := xy;
	<mat4f+?>: mov.x32 sp(18, 15)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xz := xz;
	<mat4f+?>: mov.x32 sp(19, 14)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xw := xw;
	<mat4f+?>: mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yx := yx;
	<mat4f+?>: mov.x32 sp(21, 12)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yy := yy;
	<mat4f+?>: mov.x32 sp(22, 11)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yz := yz;
	<mat4f+?>: mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yw := yw;
	<mat4f+?>: mov.x32 sp(24, 9)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zx := zx;
	<mat4f+?>: mov.x32 sp(25, 8)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zy := zy;
	<mat4f+?>: mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zz := zz;
	<mat4f+?>: mov.x32 sp(27, 6)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zw := zw;
	<mat4f+?>: mov.x32 sp(28, 5)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.wx := wx;
	<mat4f+?>: mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.wy := wy;
	<mat4f+?>: mov.x32 sp(30, 3)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.wz := wz;
	<mat4f+?>: mov.x32 sp(31, 2)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.ww := ww;
	<mat4f+?>: mov.x32 sp(32, 1)
	<mat4f+?>: ret
.usages:
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static function
.base: `function`
.size: 21
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, cast: variable(val))
.param x: vec4f (size: 4, cast: const variable(ref))
.param y: vec4f (size: 4, cast: const variable(ref))
.param z: vec4f (size: 4, cast: const variable(ref))
.param w: vec4f (size: 4, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (21 bytes)
	cmplStd/lib/math/Matrix4f.ci:76: (21 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.x := x;
	<mat4f>  : dup.x32 sp(4)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.y := y;
	<mat4f+?>: dup.x32 sp(3)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.z := z;
	<mat4f+?>: dup.x32 sp(2)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.w := w;
	<mat4f+?>: dup.x32 sp(1)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(21)
	<mat4f+?>: ret
.usages:
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'cmplStd/lib/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000)
.usages:
	cmplGfx/lib/camera.ci:80: referenced as `dp3`
	cmplGfx/lib/camera.ci:79: referenced as `dp3`
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'cmplStd/lib/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec))
.usages:
	cmplGfx/lib/camera.ci:82: referenced as `dph`
	cmplGfx/lib/image.transform.ci:57: referenced as `dph`
	cmplGfx/lib/image.transform.ci:46: referenced as `dph`
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'cmplStd/lib/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: full dot product'
.value: vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec))
.usages:
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `dp4`
}
transpose(mat: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.name: 'transpose'
.file: 'cmplStd/lib/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, cast: variable(val))
.param mat: mat4f (size: 64, cast: const variable(val))
.doc: 'Transpose the matrix'
.value: {
	return .result := {
			.result.xx := mat.xx;
			.result.xy := mat.yx;
			.result.xz := mat.zx;
			.result.xw := mat.wx;
			.result.yx := mat.xy;
			.result.yy := mat.yy;
			.result.yz := mat.zy;
			.result.yw := mat.wy;
			.result.zx := mat.xz;
			.result.zy := mat.yz;
			.result.zz := mat.zz;
			.result.zw := mat.wz;
			.result.wx := mat.xw;
			.result.wy := mat.yw;
			.result.wz := mat.zw;
			.result.ww := mat.ww;
		};
}
.instructions: (49 bytes)
	cmplStd/lib/math/Matrix4f.ci:88: (49 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xx := mat.xx;
	<transpose>  : mov.x32 sp(17, 1)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xy := mat.yx;
	<transpose+?>: mov.x32 sp(18, 5)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xz := mat.zx;
	<transpose+?>: mov.x32 sp(19, 9)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xw := mat.wx;
	<transpose+?>: mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yx := mat.xy;
	<transpose+?>: mov.x32 sp(21, 2)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yy := mat.yy;
	<transpose+?>: mov.x32 sp(22, 6)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yz := mat.zy;
	<transpose+?>: mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yw := mat.wy;
	<transpose+?>: mov.x32 sp(24, 14)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zx := mat.xz;
	<transpose+?>: mov.x32 sp(25, 3)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zy := mat.yz;
	<transpose+?>: mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zz := mat.zz;
	<transpose+?>: mov.x32 sp(27, 11)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zw := mat.wz;
	<transpose+?>: mov.x32 sp(28, 15)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.wx := mat.xw;
	<transpose+?>: mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.wy := mat.yw;
	<transpose+?>: mov.x32 sp(30, 8)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.wz := mat.zw;
	<transpose+?>: mov.x32 sp(31, 12)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.ww := mat.ww;
	<transpose+?>: mov.x32 sp(32, 16)
	<transpose+?>: ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `transpose`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 265
.name: 'mul'
.file: 'cmplStd/lib/math/Matrix4f.ci:97'
.param .result: mat4f (size: 64, cast: variable(val))
.param lhs: mat4f (size: 4, cast: const variable(ref))
.param rhs: mat4f (size: 4, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := transpose(rhs);
	return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
}
.instructions: (265 bytes)
	cmplStd/lib/math/Matrix4f.ci:98: (28 bytes): transposed: mat4f := transpose(rhs)
	<mul>  : inc.sp(+64)
	<mul+?>: dup.x32 sp(17)
	<mul+?>: load.sp(-60)
	<mul+?>: copy.mem -64
	<mul+?>: inc.sp(+64)
	<mul+?>: load.ref <?> ;transpose(mat: mat4f): mat4f
	<mul+?>: call
	<mul+?>: inc.sp(-64)
	cmplStd/lib/math/Matrix4f.ci:99: (237 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:100: (55 bytes): .result.x := dp4(transposed, lhs.x);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: mov.x128 sp(2, 0)
	<mul+?>: inc.sp(-8)
	<mul+?>: set.x128 sp(23)
	cmplStd/lib/math/Matrix4f.ci:101: (59 bytes): .result.y := dp4(transposed, lhs.y);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+16)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: mov.x128 sp(2, 0)
	<mul+?>: inc.sp(-8)
	<mul+?>: set.x128 sp(27)
	cmplStd/lib/math/Matrix4f.ci:102: (59 bytes): .result.z := dp4(transposed, lhs.z);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+32)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: mov.x128 sp(2, 0)
	<mul+?>: inc.sp(-8)
	<mul+?>: set.x128 sp(31)
	cmplStd/lib/math/Matrix4f.ci:103: (59 bytes): .result.w := dp4(transposed, lhs.w);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+48)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: mov.x128 sp(2, 0)
	<mul+?>: inc.sp(-8)
	<mul+?>: set.x128 sp(35)
	<mul+?>: inc.sp(-64)
	<mul+?>: ret
.usages:
	cmplGfx/lib/camera.ci:63: referenced as `mul`
	cmplGfx/lib/image.transform.ci:54: referenced as `mul`
	cmplGfx/lib/image.transform.ci:29: referenced as `mul`
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 491
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:109'
.param .result: mat4f (size: 64, cast: variable(val))
.param center: vec4f (size: 4, cast: const variable(ref))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param angle: float32 (size: 4, cast: variable(f32))
.doc: 'Build a rotation matrix'
.value: {
	len: float32 := length(direction);
	if ((len) < 0.000000) {
		trace("invalid direction of rotation", direction);
		return .result := {
			.result.x := vec4f(0, 0, 0, 0);
			.result.y := vec4f(0, 0, 0, 0);
			.result.z := vec4f(0, 0, 0, 0);
			.result.w := vec4f(0, 0, 0, 0);
		};
	}
	x: float32 := direction.x / len;
	y: float32 := direction.y / len;
	z: float32 := direction.z / len;
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := x * x;
	xy: float32 := x * y;
	xz: float32 := x * z;
	yy: float32 := y * y;
	yz: float32 := y * z;
	zz: float32 := z * z;
	s: float32 := Math.sin(angle);
	c: float32 := Math.cos(angle);
	k: float32 := (1) - c;
	return .result := {
			.result.xx := xx + (yy + zz) * c;
			.result.xy := xy * k - z * s;
			.result.xz := xz * k + y * s;
			.result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
			.result.yx := xy * k + z * s;
			.result.yy := yy + (xx + zz) * c;
			.result.yz := yz * k - x * s;
			.result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
			.result.zx := xz * k - y * s;
			.result.zy := yz * k + x * s;
			.result.zz := zz + (xx + yy) * c;
			.result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
			.result.w := vec4f(0, 0, 0, 1);
		};
}
.instructions: (491 bytes)
	cmplStd/lib/math/Matrix4f.ci:110: (26 bytes): len: float32 := length(direction)
	<rotation>  : dup.x32 sp(2)
	<rotation+?>: load.i128
	<rotation+?>: load.z32
	<rotation+?>: dup.x128 sp(1)
	<rotation+?>: dup.x128 sp(5)
	<rotation+?>: dp3.v4f
	<rotation+?>: load.ref <?> ;Math.sqrt(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	<rotation+?>: mov.x32 sp(4, 0)
	<rotation+?>: inc.sp(-16)
	cmplStd/lib/math/Matrix4f.ci:111: (97 bytes): if ((len) < 0.000000)
	<rotation+?>: dup.x32 sp(0)
	<rotation+?>: f32.2f64
	<rotation+?>: load.f64 0.000000
	<rotation+?>: clt.f64
	<rotation+?>: jz +84
	cmplStd/lib/math/Matrix4f.ci:112: (51 bytes): trace("invalid direction of rotation", direction);
	<rotation+?>: load.ref <?> ;vec4f
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: load.c32 1
	<rotation+?>: load.sp(+4)
	<rotation+?>: load.ref <?> ;"cmplStd/lib/math/Matrix4f.ci"
	<rotation+?>: load.c32 112
	<rotation+?>: load.c32 14
	<rotation+?>: load.c32 128
	<rotation+?>: load.ref <?> ;"invalid direction of rotation"
	<rotation+?>: dup.x64 sp(5)
	<rotation+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<rotation+?>: inc.sp(-16)
	cmplStd/lib/math/Matrix4f.ci:113: (29 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:114: (6 bytes): .result.x := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:115: (6 bytes): .result.y := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:116: (6 bytes): .result.z := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:117: (6 bytes): .result.w := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(21)
	<rotation+?>: inc.sp(-4)
	<rotation+?>: ret
	cmplStd/lib/math/Matrix4f.ci:120: (6 bytes): x: float32 := direction.x / len
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: div.f32
	cmplStd/lib/math/Matrix4f.ci:121: (10 bytes): y: float32 := direction.y / len
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: div.f32
	cmplStd/lib/math/Matrix4f.ci:122: (10 bytes): z: float32 := direction.z / len
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: div.f32
	cmplStd/lib/math/Matrix4f.ci:123: (3 bytes): cx: float32 := center.x
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:124: (7 bytes): cy: float32 := center.y
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:125: (7 bytes): cz: float32 := center.z
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:126: (5 bytes): xx: float32 := x * x
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:127: (5 bytes): xy: float32 := x * y
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:128: (5 bytes): xz: float32 := x * z
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:129: (5 bytes): yy: float32 := y * y
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:130: (5 bytes): yz: float32 := y * z
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:131: (5 bytes): zz: float32 := z * z
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:133: (13 bytes): s: float32 := Math.sin(angle)
	<rotation+?>: load.z32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: load.ref <?> ;Math.sin(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	cmplStd/lib/math/Matrix4f.ci:134: (13 bytes): c: float32 := Math.cos(angle)
	<rotation+?>: load.z32
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: load.ref <?> ;Math.cos(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	cmplStd/lib/math/Matrix4f.ci:135: (8 bytes): k: float32 := (1) - c
	<rotation+?>: load.f32 1.000000
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:137: (261 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:138: (13 bytes): .result.xx := xx + (yy + zz) * c;
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:139: (13 bytes): .result.xy := xy * k - z * s;
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:140: (13 bytes): .result.xz := xz * k + y * s;
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:141: (43 bytes): .result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:143: (13 bytes): .result.yx := xy * k + z * s;
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:144: (13 bytes): .result.yy := yy + (xx + zz) * c;
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:145: (13 bytes): .result.yz := yz * k - x * s;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:146: (43 bytes): .result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:148: (13 bytes): .result.zx := xz * k - y * s;
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(29)
	cmplStd/lib/math/Matrix4f.ci:149: (13 bytes): .result.zy := yz * k + x * s;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(30)
	cmplStd/lib/math/Matrix4f.ci:150: (13 bytes): .result.zz := zz + (xx + yy) * c;
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(31)
	cmplStd/lib/math/Matrix4f.ci:151: (43 bytes): .result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(32)
	cmplStd/lib/math/Matrix4f.ci:153: (10 bytes): .result.w := vec4f(0, 0, 0, 1);
	<rotation+?>: load.f32 1.000000
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(36)
	<rotation+?>: inc.sp(-64)
	<rotation+?>: ret
.usages:
	cmplGfx/lib/camera.ci:78: referenced as `rotation`
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 243
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:158'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param angle: float32 (size: 4, cast: variable(f32))
.doc: 'Build a rotation matrix'
.value: {
	xx: float32 := direction.x * direction.x;
	yy: float32 := direction.y * direction.y;
	zz: float32 := direction.z * direction.z;
	xy: float32 := direction.x * direction.y;
	xz: float32 := direction.x * direction.z;
	yz: float32 := direction.y * direction.z;
	s: float32 := Math.sin(angle);
	c: float32 := Math.cos(angle);
	k: float32 := (1) - c;
	tmp: vec4f := mul(direction, s);
	return .result := {
			.result.xx := k * xx + c;
			.result.xy := k * xy - tmp.z;
			.result.xz := k * xz + tmp.y;
			.result.xw := (0);
			.result.yx := k * xy + tmp.z;
			.result.yy := k * yy + c;
			.result.yz := k * yz - tmp.x;
			.result.yw := (0);
			.result.zx := k * xz - tmp.y;
			.result.zy := k * yz + tmp.x;
			.result.zz := k * zz + c;
			.result.zw := (0);
			.result.w := vec4f(0, 0, 0, 1);
		};
}
.instructions: (243 bytes)
	cmplStd/lib/math/Matrix4f.ci:159: (7 bytes): xx: float32 := direction.x * direction.x
	<rotation>  : dup.x32 sp(2)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:160: (15 bytes): yy: float32 := direction.y * direction.y
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:161: (15 bytes): zz: float32 := direction.z * direction.z
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:162: (11 bytes): xy: float32 := direction.x * direction.y
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:163: (11 bytes): xz: float32 := direction.x * direction.z
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:164: (15 bytes): yz: float32 := direction.y * direction.z
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:165: (13 bytes): s: float32 := Math.sin(angle)
	<rotation+?>: load.z32
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: load.ref <?> ;Math.sin(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	cmplStd/lib/math/Matrix4f.ci:166: (13 bytes): c: float32 := Math.cos(angle)
	<rotation+?>: load.z32
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: load.ref <?> ;Math.cos(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	cmplStd/lib/math/Matrix4f.ci:167: (8 bytes): k: float32 := (1) - c
	<rotation+?>: load.f32 1.000000
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:168: (21 bytes): tmp: vec4f := mul(direction, s)
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: load.i128
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(0)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mov.x128 sp(1, 0)
	<rotation+?>: inc.sp(-4)
	<rotation+?>: mul.v4f
	cmplStd/lib/math/Matrix4f.ci:170: (114 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:171: (10 bytes): .result.xx := k * xx + c;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:172: (10 bytes): .result.xy := k * xy - tmp.z;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:173: (10 bytes): .result.xz := k * xz + tmp.y;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(19)
	cmplStd/lib/math/Matrix4f.ci:174: (3 bytes): .result.xw := (0);
	<rotation+?>: load.z32
	<rotation+?>: set.x32 sp(20)
	cmplStd/lib/math/Matrix4f.ci:176: (10 bytes): .result.yx := k * xy + tmp.z;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:177: (10 bytes): .result.yy := k * yy + c;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:178: (10 bytes): .result.yz := k * yz - tmp.x;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes): .result.yw := (0);
	<rotation+?>: load.z32
	<rotation+?>: set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:181: (10 bytes): .result.zx := k * xz - tmp.y;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:182: (10 bytes): .result.zy := k * yz + tmp.x;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:183: (10 bytes): .result.zz := k * zz + c;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:184: (3 bytes): .result.zw := (0);
	<rotation+?>: load.z32
	<rotation+?>: set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:186: (10 bytes): .result.w := vec4f(0, 0, 0, 1);
	<rotation+?>: load.f32 1.000000
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(32)
	<rotation+?>: inc.sp(-52)
	<rotation+?>: ret
.usages:
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 88
.name: 'translation'
.file: 'cmplStd/lib/math/Matrix4f.ci:191'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return .result := {
			.result.xx := (1);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := direction.x * amount;
			.result.yx := (0);
			.result.yy := (1);
			.result.yz := (0);
			.result.yw := direction.y * amount;
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := (1);
			.result.zw := direction.z * amount;
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
}
.instructions: (88 bytes)
	cmplStd/lib/math/Matrix4f.ci:192: (88 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:193: (7 bytes): .result.xx := (1);
	<translation>  : load.f32 1.000000
	<translation+?>: set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:193: (3 bytes): .result.xy := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:193: (3 bytes): .result.xz := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:193: (8 bytes): .result.xw := direction.x * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:194: (3 bytes): .result.yx := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:194: (7 bytes): .result.yy := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:194: (3 bytes): .result.yz := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:194: (12 bytes): .result.yw := direction.y * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: inc.i32(+4)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:195: (3 bytes): .result.zx := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:195: (3 bytes): .result.zy := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:195: (7 bytes): .result.zz := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:195: (12 bytes): .result.zw := direction.z * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: inc.i32(+8)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:196: (3 bytes): .result.wx := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:196: (3 bytes): .result.wy := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:196: (3 bytes): .result.wz := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:196: (7 bytes): .result.ww := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(19)
	<translation+?>: ret
.usages:
	cmplGfx/lib/image.transform.ci:29: referenced as `translation`
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 217
.name: 'scale'
.file: 'cmplStd/lib/math/Matrix4f.ci:201'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := ((val < (0) ? -val : val)) < 0.000000 ? (0) : (1) / val;
	return .result := {
			.result.xx := rcp(direction.x * amount);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := (0);
			.result.yx := (0);
			.result.yy := rcp(direction.y * amount);
			.result.yz := (0);
			.result.yw := (0);
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := rcp(direction.z * amount);
			.result.zw := (0);
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
}
.instructions: (217 bytes)
	cmplStd/lib/math/Matrix4f.ci:203: (217 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:204: (55 bytes): .result.xx := rcp(direction.x * amount);
	<scale>  : dup.x32 sp(2)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:204: (3 bytes): .result.xy := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:204: (3 bytes): .result.xz := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:204: (3 bytes): .result.xw := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:205: (3 bytes): .result.yx := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:205: (59 bytes): .result.yy := rcp(direction.y * amount);
	<scale+?>: dup.x32 sp(2)
	<scale+?>: inc.i32(+4)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:205: (3 bytes): .result.yz := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:205: (3 bytes): .result.yw := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:206: (3 bytes): .result.zx := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:206: (3 bytes): .result.zy := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:206: (59 bytes): .result.zz := rcp(direction.z * amount);
	<scale+?>: dup.x32 sp(2)
	<scale+?>: inc.i32(+8)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:206: (3 bytes): .result.zw := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:207: (3 bytes): .result.wx := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:207: (3 bytes): .result.wy := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:207: (3 bytes): .result.wz := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:207: (7 bytes): .result.ww := (1);
	<scale+?>: load.f32 1.000000
	<scale+?>: set.x32 sp(19)
	<scale+?>: ret
.usages:
	cmplGfx/lib/image.transform.ci:54: referenced as `scale`
}
inverse(mat: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 632
.name: 'inverse'
.file: 'cmplStd/lib/math/Matrix4f.ci:213'
.param .result: mat4f (size: 64, cast: variable(val))
.param mat: mat4f (size: 4, cast: const variable(ref))
.doc: 'Build the inverse of the matrix'
.value: {
	a00: float32 := mat.xx;
	a01: float32 := mat.xy;
	a02: float32 := mat.xz;
	a03: float32 := mat.xw;
	a10: float32 := mat.yx;
	a11: float32 := mat.yy;
	a12: float32 := mat.yz;
	a13: float32 := mat.yw;
	a20: float32 := mat.zx;
	a21: float32 := mat.zy;
	a22: float32 := mat.zz;
	a23: float32 := mat.zw;
	a30: float32 := mat.wx;
	a31: float32 := mat.wy;
	a32: float32 := mat.wz;
	a33: float32 := mat.ww;
	b00: float32 := a00 * a11 - a01 * a10;
	b01: float32 := a00 * a12 - a02 * a10;
	b02: float32 := a00 * a13 - a03 * a10;
	b03: float32 := a01 * a12 - a02 * a11;
	b04: float32 := a01 * a13 - a03 * a11;
	b05: float32 := a02 * a13 - a03 * a12;
	b06: float32 := a20 * a31 - a21 * a30;
	b07: float32 := a20 * a32 - a22 * a30;
	b08: float32 := a20 * a33 - a23 * a30;
	b09: float32 := a21 * a32 - a22 * a31;
	b10: float32 := a21 * a33 - a23 * a31;
	b11: float32 := a22 * a33 - a23 * a32;
	det: float32 := b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	return .result := {
			.result.xx := (a11 * b11 - a12 * b10 + a13 * b09) / det;
			.result.xy := (a02 * b10 - a01 * b11 - a03 * b09) / det;
			.result.xz := (a31 * b05 - a32 * b04 + a33 * b03) / det;
			.result.xw := (a22 * b04 - a21 * b05 - a23 * b03) / det;
			.result.yx := (a12 * b08 - a10 * b11 - a13 * b07) / det;
			.result.yy := (a00 * b11 - a02 * b08 + a03 * b07) / det;
			.result.yz := (a32 * b02 - a30 * b05 - a33 * b01) / det;
			.result.yw := (a20 * b05 - a22 * b02 + a23 * b01) / det;
			.result.zx := (a10 * b10 - a11 * b08 + a13 * b06) / det;
			.result.zy := (a01 * b08 - a00 * b10 - a03 * b06) / det;
			.result.zz := (a30 * b04 - a31 * b02 + a33 * b00) / det;
			.result.zw := (a21 * b02 - a20 * b04 - a23 * b00) / det;
			.result.wx := (a11 * b07 - a10 * b09 - a12 * b06) / det;
			.result.wy := (a00 * b09 - a01 * b07 + a02 * b06) / det;
			.result.wz := (a31 * b01 - a30 * b03 - a32 * b00) / det;
			.result.ww := (a20 * b03 - a21 * b01 + a22 * b00) / det;
		};
}
.instructions: (632 bytes)
	cmplStd/lib/math/Matrix4f.ci:214: (3 bytes): a00: float32 := mat.xx
	<inverse>  : dup.x32 sp(1)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:215: (7 bytes): a01: float32 := mat.xy
	<inverse+?>: dup.x32 sp(2)
	<inverse+?>: inc.i32(+4)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:216: (7 bytes): a02: float32 := mat.xz
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: inc.i32(+8)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:217: (7 bytes): a03: float32 := mat.xw
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: inc.i32(+12)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:219: (7 bytes): a10: float32 := mat.yx
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: inc.i32(+16)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:220: (7 bytes): a11: float32 := mat.yy
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: inc.i32(+20)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:221: (7 bytes): a12: float32 := mat.yz
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: inc.i32(+24)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:222: (7 bytes): a13: float32 := mat.yw
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: inc.i32(+28)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:224: (7 bytes): a20: float32 := mat.zx
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: inc.i32(+32)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:225: (7 bytes): a21: float32 := mat.zy
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: inc.i32(+36)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:226: (7 bytes): a22: float32 := mat.zz
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: inc.i32(+40)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:227: (7 bytes): a23: float32 := mat.zw
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: inc.i32(+44)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:229: (7 bytes): a30: float32 := mat.wx
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: inc.i32(+48)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:230: (7 bytes): a31: float32 := mat.wy
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: inc.i32(+52)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:231: (7 bytes): a32: float32 := mat.wz
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: inc.i32(+56)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:232: (7 bytes): a33: float32 := mat.ww
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: inc.i32(+60)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:234: (11 bytes): b00: float32 := a00 * a11 - a01 * a10
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:235: (11 bytes): b01: float32 := a00 * a12 - a02 * a10
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:236: (11 bytes): b02: float32 := a00 * a13 - a03 * a10
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:237: (11 bytes): b03: float32 := a01 * a12 - a02 * a11
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:238: (11 bytes): b04: float32 := a01 * a13 - a03 * a11
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:239: (11 bytes): b05: float32 := a02 * a13 - a03 * a12
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:240: (11 bytes): b06: float32 := a20 * a31 - a21 * a30
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:241: (11 bytes): b07: float32 := a20 * a32 - a22 * a30
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:242: (11 bytes): b08: float32 := a20 * a33 - a23 * a30
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:243: (11 bytes): b09: float32 := a21 * a32 - a22 * a31
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:244: (11 bytes): b10: float32 := a21 * a33 - a23 * a31
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:245: (11 bytes): b11: float32 := a22 * a33 - a23 * a32
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:247: (35 bytes): det: float32 := b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	cmplStd/lib/math/Matrix4f.ci:249: (357 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:250: (22 bytes): .result.xx := (a11 * b11 - a12 * b10 + a13 * b09) / det;
	<inverse+?>: dup.x32 sp(23)
	<inverse+?>: dup.x32 sp(2)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(23)
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(22)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(32)
	cmplStd/lib/math/Matrix4f.ci:251: (22 bytes): .result.xy := (a02 * b10 - a01 * b11 - a03 * b09) / det;
	<inverse+?>: dup.x32 sp(26)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(28)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(26)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(33)
	cmplStd/lib/math/Matrix4f.ci:252: (22 bytes): .result.xz := (a31 * b05 - a32 * b04 + a33 * b03) / det;
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(34)
	cmplStd/lib/math/Matrix4f.ci:253: (22 bytes): .result.xw := (a22 * b04 - a21 * b05 - a23 * b03) / det;
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(20)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(35)
	cmplStd/lib/math/Matrix4f.ci:254: (22 bytes): .result.yx := (a12 * b08 - a10 * b11 - a13 * b07) / det;
	<inverse+?>: dup.x32 sp(22)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(25)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(22)
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(36)
	cmplStd/lib/math/Matrix4f.ci:255: (22 bytes): .result.yy := (a00 * b11 - a02 * b08 + a03 * b07) / det;
	<inverse+?>: dup.x32 sp(28)
	<inverse+?>: dup.x32 sp(2)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(27)
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(26)
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(37)
	cmplStd/lib/math/Matrix4f.ci:256: (22 bytes): .result.yz := (a32 * b02 - a30 * b05 - a33 * b01) / det;
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(38)
	cmplStd/lib/math/Matrix4f.ci:257: (22 bytes): .result.yw := (a20 * b05 - a22 * b02 + a23 * b01) / det;
	<inverse+?>: dup.x32 sp(20)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(19)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(39)
	cmplStd/lib/math/Matrix4f.ci:258: (22 bytes): .result.zx := (a10 * b10 - a11 * b08 + a13 * b06) / det;
	<inverse+?>: dup.x32 sp(24)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(24)
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(22)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(40)
	cmplStd/lib/math/Matrix4f.ci:259: (22 bytes): .result.zy := (a01 * b08 - a00 * b10 - a03 * b06) / det;
	<inverse+?>: dup.x32 sp(27)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(29)
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(26)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(41)
	cmplStd/lib/math/Matrix4f.ci:260: (22 bytes): .result.zz := (a30 * b04 - a31 * b02 + a33 * b00) / det;
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(42)
	cmplStd/lib/math/Matrix4f.ci:261: (22 bytes): .result.zw := (a21 * b02 - a20 * b04 - a23 * b00) / det;
	<inverse+?>: dup.x32 sp(19)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(21)
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(43)
	cmplStd/lib/math/Matrix4f.ci:262: (22 bytes): .result.wx := (a11 * b07 - a10 * b09 - a12 * b06) / det;
	<inverse+?>: dup.x32 sp(23)
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(25)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(23)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(44)
	cmplStd/lib/math/Matrix4f.ci:263: (22 bytes): .result.wy := (a00 * b09 - a01 * b07 + a02 * b06) / det;
	<inverse+?>: dup.x32 sp(28)
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(28)
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(27)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(45)
	cmplStd/lib/math/Matrix4f.ci:264: (22 bytes): .result.wz := (a31 * b01 - a30 * b03 - a32 * b00) / det;
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(46)
	cmplStd/lib/math/Matrix4f.ci:265: (22 bytes): .result.ww := (a20 * b03 - a21 * b01 + a22 * b00) / det;
	<inverse+?>: dup.x32 sp(20)
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(20)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(19)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(47)
	<inverse+?>: inc.sp(-116)
	<inverse+?>: ret
.usages:
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:2'
.field <?>: vec2d.<?> (size: 16, cast: variable(val))
.field x: float64 (size: 0, cast: inline)
.field y: float64 (size: 0, cast: inline)
.field data: float64[2] (size: 16, cast: variable(val))
.doc: 'A 2d vector (2x float64)'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `vec2d`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.name: '<?>'
.file: 'cmplStd/lib/math/Vector2d.ci:44'
.owner: vec2d
.field x: float64 (size: 8, cast: variable(f64))
.field y: float64 (size: 8, cast: variable(f64))
.usages:
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:16: referenced as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:17: referenced as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.name: 'data'
.file: 'cmplStd/lib/math/Vector2d.ci:10'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static function
.base: `function`
.size: 7
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, cast: variable(val))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
		};
}
.instructions: (7 bytes)
	cmplStd/lib/math/Vector2d.ci:15: (7 bytes): return .result := {...};
	cmplStd/lib/math/Vector2d.ci:16: (3 bytes): .result.x := x;
	<vec2d>  : mov.x64 sp(5, 3)
	cmplStd/lib/math/Vector2d.ci:17: (3 bytes): .result.y := y;
	<vec2d+?>: mov.x64 sp(7, 1)
	<vec2d+?>: ret
.usages:
}
add(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec2d(emit(struct(a), struct(b), add.p2d))
.usages:
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector2d.ci:25'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(struct(a), struct(b), sub.p2d))
.usages:
}
mul(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector2d.ci:28'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec2d(emit(struct(a), struct(b), mul.p2d))
.usages:
}
div(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector2d.ci:31'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec2d(emit(struct(a), struct(b), div.p2d))
.usages:
}
min(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Vector2d.ci:34'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise select the minimum from the two vectors.'
.value: vec2d(emit(struct(a), struct(b), min.p2d))
.usages:
}
max(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Vector2d.ci:37'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise select the maximum from the two vectors.'
.value: vec2d(emit(struct(a), struct(b), max.p2d))
.usages:
}
ceq(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'ceq'
.file: 'cmplStd/lib/math/Vector2d.ci:40'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Compare the two vectors for equality.'
.value: vec2d(emit(struct(a), struct(b), ceq.p2d))
.usages:
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dot'
.file: 'cmplStd/lib/math/Vector2d.ci:43'
.param .result: float64 (size: 8, cast: f64)
.param a: vec2d (size: 4, cast: const variable(ref))
.param b: vec2d (size: 4, cast: const variable(ref))
.doc: 'Dot product of thw two vectors'
.value: a.x * b.x + a.y * b.y
.usages:
}
Timeunit: int64 {
.kind: static const typename(ERR)
.base: `int64`
.size: 8
.name: 'Timeunit'
.file: 'cmplStd/lib/time/Timeunit.ci:2'
.field Nanos: int64 (size: 0, cast: static const val)
.field Micros: int64 (size: 0, cast: static const val)
.field Millis: int64 (size: 0, cast: static const val)
.field Seconds: int64 (size: 0, cast: static const val)
.field Minutes: int64 (size: 0, cast: static const val)
.field Hours: int64 (size: 0, cast: static const val)
.field Days: int64 (size: 0, cast: static const val)
.doc: 'enumeration of some known time unit, used for conversions and to specify the precision'
.usages:
	cmplStd/lib/text/Format.ci:436: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:256: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:255: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:254: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:253: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:198: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:175: referenced as `Timeunit`
	cmplStd/lib/time/Timezone.ci:29: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:120: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:94: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:73: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:55: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:42: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:32: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:17: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:12: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:9: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:9: referenced as `Timeunit`
	cmplStd/lib/time/Duration.ci:22: referenced as `Timeunit`
	cmplStd/lib/time/Duration.ci:11: referenced as `Timeunit`
	cmplStd/lib/time/Duration.ci:8: referenced as `Timeunit`
	cmplStd/lib/time/Duration.ci:8: referenced as `Timeunit`
	cmplStd/lib/time/Timeunit.ci:24: referenced as `Timeunit`
	cmplStd/lib/time/Timeunit.ci:24: referenced as `Timeunit`
	cmplStd/lib/time/Timeunit.ci:14: referenced as `Timeunit`
	cmplStd/lib/time/Timeunit.ci:14: referenced as `Timeunit`
}
Timeunit.Nanos: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Nanos'
.file: 'cmplStd/lib/time/Timeunit.ci:4'
.owner: Timeunit
.doc: 'Nanos'
.value: (1)
.usages:
	cmplStd/lib/time/Timeunit.ci:5: referenced as `Nanos`
}
Timeunit.Micros: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Micros'
.file: 'cmplStd/lib/time/Timeunit.ci:5'
.owner: Timeunit
.doc: 'Micros'
.value: (1000)
.usages:
	cmplStd/lib/time/Timeunit.ci:6: referenced as `Micros`
}
Timeunit.Millis: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Millis'
.file: 'cmplStd/lib/time/Timeunit.ci:6'
.owner: Timeunit
.doc: 'Millis'
.value: (1000000)
.usages:
	cmplStd/lib/time/Datetime.ci:256: referenced as `Millis`
	cmplStd/lib/time/Datetime.ci:175: referenced as `Millis`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `Millis`
	cmplStd/lib/time/Timestamp.ci:9: referenced as `Millis`
	cmplStd/lib/time/Duration.ci:8: referenced as `Millis`
	cmplStd/lib/time/Timeunit.ci:7: referenced as `Millis`
}
Timeunit.Seconds: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Seconds'
.file: 'cmplStd/lib/time/Timeunit.ci:7'
.owner: Timeunit
.doc: 'Seconds'
.value: (1000000000)
.usages:
	cmplStd/lib/text/Format.ci:436: referenced as `Seconds`
	cmplStd/lib/time/Datetime.ci:255: referenced as `Seconds`
	cmplStd/lib/time/Timeunit.ci:8: referenced as `Seconds`
}
Timeunit.Minutes: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Minutes'
.file: 'cmplStd/lib/time/Timeunit.ci:8'
.owner: Timeunit
.doc: 'Minutes'
.value: (60000000000)
.usages:
	cmplStd/lib/time/Datetime.ci:254: referenced as `Minutes`
	cmplStd/lib/time/Timeunit.ci:9: referenced as `Minutes`
}
Timeunit.Hours: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Hours'
.file: 'cmplStd/lib/time/Timeunit.ci:9'
.owner: Timeunit
.doc: 'Hours'
.value: (3600000000000)
.usages:
	cmplStd/lib/time/Datetime.ci:253: referenced as `Hours`
	cmplStd/lib/time/Timezone.ci:29: referenced as `Hours`
	cmplStd/lib/time/Timeunit.ci:10: referenced as `Hours`
}
Timeunit.Days: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Days'
.file: 'cmplStd/lib/time/Timeunit.ci:10'
.owner: Timeunit
.doc: 'Days'
.value: (86400000000000)
.usages:
	cmplStd/lib/time/Datetime.ci:198: referenced as `Days`
}
convert(value: int64, from: Timeunit, to: Timeunit): int64: function {
.kind: static function
.base: `function`
.size: 31
.name: 'convert'
.file: 'cmplStd/lib/time/Timeunit.ci:14'
.param .result: int64 (size: 8, cast: variable(i64))
.param value: int64 (size: 8, cast: variable(i64))
.param from: Timeunit (size: 8, cast: variable(i64))
.param to: Timeunit (size: 8, cast: variable(i64))
.doc: 'Convert the given integer `value` from the `from` to `to` unit'
.value: {
	if (from > to) {
		return .result := value * (from / to);
	}
	return .result := value / (to / from);
}
.instructions: (31 bytes)
	cmplStd/lib/time/Timeunit.ci:15: (20 bytes): if (from > to)
	<convert>  : dup.x64 sp(3)
	<convert+?>: dup.x64 sp(3)
	<convert+?>: cgt.i64
	<convert+?>: jz +15
	cmplStd/lib/time/Timeunit.ci:17: (11 bytes): return .result := value * (from / to);
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(5)
	<convert+?>: div.i64
	<convert+?>: mul.i64
	<convert+?>: set.x64 sp(9)
	<convert+?>: ret
	cmplStd/lib/time/Timeunit.ci:20: (11 bytes): return .result := value / (to / from);
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(3)
	<convert+?>: dup.x64 sp(7)
	<convert+?>: div.i64
	<convert+?>: div.i64
	<convert+?>: set.x64 sp(9)
	<convert+?>: ret
.usages:
	cmplStd/lib/time/Timestamp.ci:121: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:78: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:60: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:13: referenced as `convert`
	cmplStd/lib/time/Duration.ci:23: referenced as `convert`
	cmplStd/lib/time/Duration.ci:12: referenced as `convert`
}
convert(value: float64, from: Timeunit, to: Timeunit): float64: function {
.kind: static function
.base: `function`
.size: 33
.name: 'convert'
.file: 'cmplStd/lib/time/Timeunit.ci:24'
.param .result: float64 (size: 8, cast: variable(f64))
.param value: float64 (size: 8, cast: variable(f64))
.param from: Timeunit (size: 8, cast: variable(i64))
.param to: Timeunit (size: 8, cast: variable(i64))
.doc: 'Convert the given floating point `value` from the `from` to `to` unit'
.value: {
	if (from > to) {
		return .result := value * ((from / to));
	}
	return .result := value / ((to / from));
}
.instructions: (33 bytes)
	cmplStd/lib/time/Timeunit.ci:25: (21 bytes): if (from > to)
	<convert>  : dup.x64 sp(3)
	<convert+?>: dup.x64 sp(3)
	<convert+?>: cgt.i64
	<convert+?>: jz +16
	cmplStd/lib/time/Timeunit.ci:27: (12 bytes): return .result := value * ((from / to));
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(5)
	<convert+?>: div.i64
	<convert+?>: i64.2f64
	<convert+?>: mul.f64
	<convert+?>: set.x64 sp(9)
	<convert+?>: ret
	cmplStd/lib/time/Timeunit.ci:30: (12 bytes): return .result := value / ((to / from));
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(3)
	<convert+?>: dup.x64 sp(7)
	<convert+?>: div.i64
	<convert+?>: i64.2f64
	<convert+?>: div.f64
	<convert+?>: set.x64 sp(9)
	<convert+?>: ret
.usages:
}
Duration: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Duration'
.file: 'cmplStd/lib/time/Duration.ci:5'
.field value: int64 (size: 8, cast: const variable(i64))
.field precision: Timeunit (size: 8, cast: static const variable(i64))
.field value: function (size: 22, cast: static function)
.field add: function (size: 8, cast: static function)
.doc: 'Timespan is just a duration
for example: 33 seconds'
.usages:
	cmplStd/lib/time/Datetime.ci:197: referenced as `Duration`
	cmplStd/lib/time/Datetime.ci:196: referenced as `Duration`
	cmplStd/lib/time/Timezone.ci:27: referenced as `Duration`
	cmplStd/lib/time/Timezone.ci:12: referenced as `Duration`
	cmplStd/lib/time/Timezone.ci:6: referenced as `Duration`
	cmplStd/lib/time/Timezone.ci:4: referenced as `Duration`
	cmplStd/lib/time/Timestamp.ci:22: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:23: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:22: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:16: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:16: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:16: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:12: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:11: referenced as `Duration`
}
Duration.value: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'value'
.file: 'cmplStd/lib/time/Duration.ci:6'
.owner: Duration
.value: 0
.usages:
	cmplStd/lib/time/Datetime.ci:197: referenced as `value`
	cmplStd/lib/time/Timezone.ci:14: referenced as `value`
	cmplStd/lib/time/Duration.ci:23: referenced as `value`
	cmplStd/lib/time/Duration.ci:17: referenced as `value`
	cmplStd/lib/time/Duration.ci:17: referenced as `value`
	cmplStd/lib/time/Duration.ci:17: referenced as `value`
	cmplStd/lib/time/Duration.ci:12: referenced as `value`
}
Duration.precision: Timeunit {
.kind: static const variable(i64)
.base: `Timeunit`
.size: 8
.name: 'precision'
.file: 'cmplStd/lib/time/Duration.ci:8'
.owner: Duration
.value: Timeunit.(Millis)
.usages:
	cmplStd/lib/time/Datetime.ci:197: referenced as `precision`
	cmplStd/lib/time/Duration.ci:23: referenced as `precision`
	cmplStd/lib/time/Duration.ci:12: referenced as `precision`
}
Duration.value(duration: Duration, precision: Timeunit): int64: function {
.kind: static function
.base: `function`
.size: 22
.name: 'value'
.file: 'cmplStd/lib/time/Duration.ci:11'
.owner: Duration
.param .result: int64 (size: 8, cast: variable(i64))
.param duration: Duration (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Returns the value of the `duration` at the given `precision` (Seconds and Millis are mostly used as unix epoch)'
.value: {
	return .result := convert(duration.value, Duration.precision, precision);
}
.instructions: (22 bytes)
	cmplStd/lib/time/Duration.ci:12: (22 bytes): return .result := convert(duration.value, Duration.precision, precision);
	<value>  : load.z64
	<value+?>: dup.x64 sp(5)
	<value+?>: load.m64 <?> ;Duration.precision
	<value+?>: dup.x64 sp(7)
	<value+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<value+?>: call
	<value+?>: inc.sp(-24)
	<value+?>: set.x64 sp(7)
	<value+?>: ret
.usages:
}
Duration.add(lhs: Duration, rhs: Duration): Duration: function {
.kind: static function
.base: `function`
.size: 8
.name: 'add'
.file: 'cmplStd/lib/time/Duration.ci:16'
.owner: Duration
.param .result: Duration (size: 8, cast: variable(val))
.param lhs: Duration (size: 8, cast: variable(val))
.param rhs: Duration (size: 8, cast: variable(val))
.doc: 'Add two durations'
.value: {
	return .result := {
			.result.value := lhs.value + rhs.value;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/time/Duration.ci:17: (8 bytes): return .result := {...};
	cmplStd/lib/time/Duration.ci:17: (7 bytes): .result.value := lhs.value + rhs.value;
	<add>  : dup.x64 sp(3)
	<add+?>: dup.x64 sp(3)
	<add+?>: add.i64
	<add+?>: set.x64 sp(7)
	<add+?>: ret
.usages:
}
Duration(value: int64, precision: Timeunit): Duration: function {
.kind: static function
.base: `function`
.size: 22
.name: 'Duration'
.file: 'cmplStd/lib/time/Duration.ci:22'
.param .result: Duration (size: 8, cast: variable(val))
.param value: int64 (size: 8, cast: variable(i64))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Construct a duration from the given `value` at the given `precision`'
.value: {
	return .result := {
			.result.value := convert(value, precision, Duration.precision);
		};
}
.instructions: (22 bytes)
	cmplStd/lib/time/Duration.ci:23: (22 bytes): return .result := {...};
	cmplStd/lib/time/Duration.ci:23: (21 bytes): .result.value := convert(value, precision, Duration.precision);
	<Duration>  : load.z64
	<Duration+?>: dup.x64 sp(5)
	<Duration+?>: dup.x64 sp(5)
	<Duration+?>: load.m64 <?> ;Duration.precision
	<Duration+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<Duration+?>: call
	<Duration+?>: inc.sp(-24)
	<Duration+?>: set.x64 sp(7)
	<Duration+?>: ret
.usages:
	cmplStd/lib/time/Timezone.ci:29: referenced as `Duration`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `Duration`
}
Timestamp: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Timestamp'
.file: 'cmplStd/lib/time/Timestamp.ci:5'
.field value: int64 (size: 8, cast: variable(i64))
.field precision: Timeunit (size: 8, cast: static const variable(i64))
.field value: function (size: 22, cast: static function)
.field diff: function (size: 25, cast: static function)
.field diff: function (size: 26, cast: static function)
.field compare: function (size: 14, cast: static function)
.field equal: function (size: 37, cast: static function)
.field equal: function (size: 11, cast: static function)
.field add: function (size: 25, cast: static function)
.field floor: function (size: 109, cast: static function)
.field ceil: function (size: 130, cast: static function)
.field distribute: function (size: 44, cast: static function)
.field distribute: function (size: 27, cast: static function)
.field now: function (size: 31, cast: static function)
.doc: 'Timestamp is a position in time, without timezone information
in case locale is needed use Datetime.'
.usages:
	cmplStd/lib/time/Datetime.ci:270: referenced as `Timestamp`
	cmplStd/lib/time/Datetime.ci:179: referenced as `Timestamp`
	cmplStd/lib/time/Datetime.ci:153: referenced as `Timestamp`
	cmplStd/lib/time/Datetime.ci:149: referenced as `Timestamp`
	cmplStd/lib/time/Timezone.ci:27: referenced as `Timestamp`
	cmplStd/lib/time/Timezone.ci:12: referenced as `Timestamp`
	cmplStd/lib/time/Timezone.ci:6: referenced as `Timestamp`
	cmplStd/lib/time/Timezone.ci:4: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:121: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:120: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:114: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:94: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:94: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:78: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:74: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:73: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:73: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:60: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:56: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:55: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:55: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:42: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:42: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:37: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:37: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:32: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:32: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:27: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:27: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:22: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:22: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:17: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:17: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:13: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:12: referenced as `Timestamp`
}
Timestamp.value: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'value'
.file: 'cmplStd/lib/time/Timestamp.ci:6'
.owner: Timestamp
.value: 0
.usages:
	cmplStd/lib/time/Timestamp.ci:121: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:96: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:83: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:83: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:79: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:61: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:61: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:61: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:38: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:38: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:13: referenced as `value`
}
Timestamp.precision: Timeunit {
.kind: static const variable(i64)
.base: `Timeunit`
.size: 8
.name: 'precision'
.file: 'cmplStd/lib/time/Timestamp.ci:9'
.owner: Timestamp
.doc: 'The time unit specifying the precision of the timestamp'
.value: Timeunit.(Millis)
.usages:
	cmplStd/lib/time/Datetime.ci:153: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:121: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:78: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:74: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:60: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:56: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:13: referenced as `precision`
}
Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64: function {
.kind: static function
.base: `function`
.size: 22
.name: 'value'
.file: 'cmplStd/lib/time/Timestamp.ci:12'
.owner: Timestamp
.param .result: int64 (size: 8, cast: variable(i64))
.param timestamp: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Returns the value of `timestamp` at the given `precision` (Seconds and Millis are mostly used as unix epoch)'
.value: {
	return .result := convert(timestamp.value, Timestamp.precision, precision);
}
.instructions: (22 bytes)
	cmplStd/lib/time/Timestamp.ci:13: (22 bytes): return .result := convert(timestamp.value, Timestamp.precision, precision);
	<value>  : load.z64
	<value+?>: dup.x64 sp(5)
	<value+?>: load.m64 <?> ;Timestamp.precision
	<value+?>: dup.x64 sp(7)
	<value+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<value+?>: call
	<value+?>: inc.sp(-24)
	<value+?>: set.x64 sp(7)
	<value+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:436: referenced as `value`
	cmplStd/lib/time/Datetime.ci:256: referenced as `value`
	cmplStd/lib/time/Datetime.ci:255: referenced as `value`
	cmplStd/lib/time/Datetime.ci:254: referenced as `value`
	cmplStd/lib/time/Datetime.ci:253: referenced as `value`
	cmplStd/lib/time/Datetime.ci:198: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:33: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:33: referenced as `value`
}
Timestamp.diff(a: Timestamp, b: Timestamp, precision: Timeunit): int64: function {
.kind: static function
.base: `function`
.size: 25
.name: 'diff'
.file: 'cmplStd/lib/time/Timestamp.ci:17'
.owner: Timestamp
.param .result: int64 (size: 8, cast: variable(i64))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Returns the difference of `a` and `b` at the given `precision`'
.value: {
	return .result := convert(a.value - b.value, Timestamp.precision, precision);
}
.instructions: (25 bytes)
	cmplStd/lib/time/Timestamp.ci:18: (25 bytes): return .result := convert(a.value - b.value, Timestamp.precision, precision);
	<diff>  : load.z64
	<diff+?>: dup.x64 sp(7)
	<diff+?>: dup.x64 sp(7)
	<diff+?>: sub.i64
	<diff+?>: load.m64 <?> ;Timestamp.precision
	<diff+?>: dup.x64 sp(7)
	<diff+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<diff+?>: call
	<diff+?>: inc.sp(-24)
	<diff+?>: set.x64 sp(9)
	<diff+?>: ret
.usages:
}
Timestamp.diff(a: Timestamp, b: Timestamp): Duration: function {
.kind: static function
.base: `function`
.size: 26
.name: 'diff'
.file: 'cmplStd/lib/time/Timestamp.ci:22'
.owner: Timestamp
.param .result: Duration (size: 8, cast: variable(val))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.doc: 'Returns the difference of `a` and `b'
.value: {
	return .result := Duration(a.value - b.value, Timestamp.precision);
}
.instructions: (26 bytes)
	cmplStd/lib/time/Timestamp.ci:23: (26 bytes): return .result := Duration(a.value - b.value, Timestamp.precision);
	<diff>  : inc.sp(+8)
	<diff+?>: dup.x64 sp(5)
	<diff+?>: dup.x64 sp(5)
	<diff+?>: sub.i64
	<diff+?>: load.m64 <?> ;Timestamp.precision
	<diff+?>: load.ref <?> ;Duration(value: int64, precision: Timeunit): Duration
	<diff+?>: call
	<diff+?>: inc.sp(-16)
	<diff+?>: set.x64 sp(7)
	<diff+?>: ret
.usages:
}
Timestamp.compare(a: Timestamp, b: Timestamp): int32: function {
.kind: static function
.base: `function`
.size: 14
.name: 'compare'
.file: 'cmplStd/lib/time/Timestamp.ci:27'
.owner: Timestamp
.param .result: int32 (size: 4, cast: variable(i32))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.doc: 'Returns whether the firs timestamp is less(<0), equal(=0), or greater(>0) than the second timestamp'
.value: {
	return .result := int32(a.value > b.value) - int32(a.value < b.value);
}
.instructions: (14 bytes)
	cmplStd/lib/time/Timestamp.ci:28: (14 bytes): return .result := int32(a.value > b.value) - int32(a.value < b.value);
	<compare>  : dup.x64 sp(3)
	<compare+?>: dup.x64 sp(3)
	<compare+?>: cgt.i64
	<compare+?>: dup.x64 sp(4)
	<compare+?>: dup.x64 sp(4)
	<compare+?>: clt.i64
	<compare+?>: sub.i32
	<compare+?>: set.x32 sp(6)
	<compare+?>: ret
.usages:
}
Timestamp.equal(a: Timestamp, b: Timestamp, precision: Timeunit): bool: function {
.kind: static function
.base: `function`
.size: 37
.name: 'equal'
.file: 'cmplStd/lib/time/Timestamp.ci:32'
.owner: Timestamp
.param .result: bool (size: 4, cast: variable(bool))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Check whether the two timestamps `a` and `b` are equal at the given `precision`'
.value: {
	return .result := value(a, precision) == value(b, precision);
}
.instructions: (37 bytes)
	cmplStd/lib/time/Timestamp.ci:33: (37 bytes): return .result := value(a, precision) == value(b, precision);
	<equal>  : load.z64
	<equal+?>: dup.x64 sp(7)
	<equal+?>: dup.x64 sp(5)
	<equal+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<equal+?>: call
	<equal+?>: inc.sp(-16)
	<equal+?>: load.z64
	<equal+?>: dup.x64 sp(7)
	<equal+?>: dup.x64 sp(7)
	<equal+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<equal+?>: call
	<equal+?>: inc.sp(-16)
	<equal+?>: ceq.i64
	<equal+?>: load.sp(+32)
	<equal+?>: store.i8
	<equal+?>: ret
.usages:
}
Timestamp.equal(a: Timestamp, b: Timestamp): bool: function {
.kind: static function
.base: `function`
.size: 11
.name: 'equal'
.file: 'cmplStd/lib/time/Timestamp.ci:37'
.owner: Timestamp
.param .result: bool (size: 4, cast: variable(bool))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.doc: 'Check whether the two timestamps `a` and `b` are equal'
.value: {
	return .result := a.value == b.value;
}
.instructions: (11 bytes)
	cmplStd/lib/time/Timestamp.ci:38: (11 bytes): return .result := a.value == b.value;
	<equal>  : dup.x64 sp(3)
	<equal+?>: dup.x64 sp(3)
	<equal+?>: ceq.i64
	<equal+?>: load.sp(+24)
	<equal+?>: store.i8
	<equal+?>: ret
.usages:
}
Timestamp.add(lhs: Timestamp, value: int64, precision: Timeunit): Timestamp: function {
.kind: static function
.base: `function`
.size: 25
.name: 'add'
.file: 'cmplStd/lib/time/Timestamp.ci:42'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param lhs: Timestamp (size: 8, cast: variable(val))
.param value: int64 (size: 8, cast: variable(i64))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Increment the the current timestamp with the given `value` at the given `precision`'
.value: {
	return .result := {
			.result.value := lhs.value + convert(value, precision, Timestamp.precision);
		};
}
.instructions: (25 bytes)
	cmplStd/lib/time/Timestamp.ci:43: (25 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:43: (24 bytes): .result.value := lhs.value + convert(value, precision, Timestamp.precision);
	<add>  : dup.x64 sp(5)
	<add+?>: load.z64
	<add+?>: dup.x64 sp(7)
	<add+?>: dup.x64 sp(7)
	<add+?>: load.m64 <?> ;Timestamp.precision
	<add+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<add+?>: call
	<add+?>: inc.sp(-24)
	<add+?>: add.i64
	<add+?>: set.x64 sp(9)
	<add+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:197: referenced as `add`
}
Timestamp.floor(value: Timestamp, precision: Timeunit): Timestamp: function {
.kind: static function
.base: `function`
.size: 109
.name: 'floor'
.file: 'cmplStd/lib/time/Timestamp.ci:55'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param value: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Floor the current timestamp, leaving the field specified as the most significant field.
For example, if you have the timestamp: 2002-03-28 13:45:01.231,
using resolution Timeunit.Days, it should return 2002-03-28 00:00:00.000.
using resolution Timeunit.Hours, it should return 2002-03-28 13:00:00.000.
using resolution Timeunit.Minutes, it should return 2002-03-28 13:45:00.000.
	 * @param unit Resolution of the operation.'
.value: {
	if (precision <= (Timestamp.precision)) {
		trace("small precision", precision);
		return .result := value;
	}
	one: int64 := convert(1, precision, Timestamp.precision);
	return .result := {
			.result.value := value.value - value.value % one;
		};
}
.instructions: (109 bytes)
	cmplStd/lib/time/Timestamp.ci:56: (68 bytes): if (precision <= (Timestamp.precision))
	<floor>  : dup.x64 sp(1)
	<floor+?>: load.m64 <?> ;Timestamp.precision
	<floor+?>: cgt.i64
	<floor+?>: jnz +61
	cmplStd/lib/time/Timestamp.ci:57: (53 bytes): trace("small precision", precision);
	<floor+?>: load.ref <?> ;Timeunit
	<floor+?>: load.sp(+8)
	<floor+?>: load.c32 1
	<floor+?>: load.sp(+4)
	<floor+?>: load.ref <?> ;"cmplStd/lib/time/Timestamp.ci"
	<floor+?>: load.c32 57
	<floor+?>: load.c32 14
	<floor+?>: load.c32 128
	<floor+?>: load.ref <?> ;"small precision"
	<floor+?>: dup.x64 sp(5)
	<floor+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<floor+?>: inc.sp(-16)
	cmplStd/lib/time/Timestamp.ci:58: (4 bytes): return .result := value;
	<floor+?>: mov.x64 sp(5, 3)
	<floor+?>: ret
	cmplStd/lib/time/Timestamp.ci:60: (26 bytes): one: int64 := convert(1, precision, Timestamp.precision)
	<floor+?>: load.z64
	<floor+?>: load.c64 1
	<floor+?>: dup.x64 sp(5)
	<floor+?>: load.m64 <?> ;Timestamp.precision
	<floor+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<floor+?>: call
	<floor+?>: inc.sp(-24)
	cmplStd/lib/time/Timestamp.ci:61: (15 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:61: (10 bytes): .result.value := value.value - value.value % one;
	<floor+?>: dup.x64 sp(5)
	<floor+?>: dup.x64 sp(7)
	<floor+?>: dup.x64 sp(4)
	<floor+?>: mod.i64
	<floor+?>: sub.i64
	<floor+?>: set.x64 sp(9)
	<floor+?>: inc.sp(-8)
	<floor+?>: ret
.usages:
}
Timestamp.ceil(value: Timestamp, precision: Timeunit): Timestamp: function {
.kind: static function
.base: `function`
.size: 130
.name: 'ceil'
.file: 'cmplStd/lib/time/Timestamp.ci:73'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param value: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Ceil the current timestamp, leaving the field specified as the most significant field.
For example, if you have the timestamp: 2002-03-28 13:45:01.231,
using resolution Timeunit.Days, it should return 2002-03-29 00:00:00.000.
using resolution Timeunit.Hours, it should return 2002-03-28 14:00:00.000.
using resolution Timeunit.Minutes, it should return 2002-03-28 13:46:00.000.
	 * @param unit Resolution of the operation.'
.value: {
	if (precision <= (Timestamp.precision)) {
		trace("small precision", precision);
		return .result := value;
	}
	one: int64 := convert(1, precision, Timestamp.precision);
	part: int64 := value.value % one;
	if (part == (0)) {
		return .result := value;
	}
	return .result := {
			.result.value := value.value - part + one;
		};
}
.instructions: (130 bytes)
	cmplStd/lib/time/Timestamp.ci:74: (68 bytes): if (precision <= (Timestamp.precision))
	<ceil>  : dup.x64 sp(1)
	<ceil+?>: load.m64 <?> ;Timestamp.precision
	<ceil+?>: cgt.i64
	<ceil+?>: jnz +61
	cmplStd/lib/time/Timestamp.ci:75: (53 bytes): trace("small precision", precision);
	<ceil+?>: load.ref <?> ;Timeunit
	<ceil+?>: load.sp(+8)
	<ceil+?>: load.c32 1
	<ceil+?>: load.sp(+4)
	<ceil+?>: load.ref <?> ;"cmplStd/lib/time/Timestamp.ci"
	<ceil+?>: load.c32 75
	<ceil+?>: load.c32 14
	<ceil+?>: load.c32 128
	<ceil+?>: load.ref <?> ;"small precision"
	<ceil+?>: dup.x64 sp(5)
	<ceil+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<ceil+?>: inc.sp(-16)
	cmplStd/lib/time/Timestamp.ci:76: (4 bytes): return .result := value;
	<ceil+?>: mov.x64 sp(5, 3)
	<ceil+?>: ret
	cmplStd/lib/time/Timestamp.ci:78: (26 bytes): one: int64 := convert(1, precision, Timestamp.precision)
	<ceil+?>: load.z64
	<ceil+?>: load.c64 1
	<ceil+?>: dup.x64 sp(5)
	<ceil+?>: load.m64 <?> ;Timestamp.precision
	<ceil+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<ceil+?>: call
	<ceil+?>: inc.sp(-24)
	cmplStd/lib/time/Timestamp.ci:79: (5 bytes): part: int64 := value.value % one
	<ceil+?>: dup.x64 sp(5)
	<ceil+?>: dup.x64 sp(2)
	<ceil+?>: mod.i64
	cmplStd/lib/time/Timestamp.ci:80: (16 bytes): if (part == (0))
	<ceil+?>: dup.x64 sp(0)
	<ceil+?>: load.z64
	<ceil+?>: ceq.i64
	<ceil+?>: jz +12
	cmplStd/lib/time/Timestamp.ci:81: (8 bytes): return .result := value;
	<ceil+?>: mov.x64 sp(9, 7)
	<ceil+?>: inc.sp(-16)
	<ceil+?>: ret
	cmplStd/lib/time/Timestamp.ci:83: (15 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:83: (10 bytes): .result.value := value.value - part + one;
	<ceil+?>: dup.x64 sp(7)
	<ceil+?>: dup.x64 sp(2)
	<ceil+?>: sub.i64
	<ceil+?>: dup.x64 sp(4)
	<ceil+?>: add.i64
	<ceil+?>: set.x64 sp(11)
	<ceil+?>: inc.sp(-16)
	<ceil+?>: ret
.usages:
}
Timestamp.distribute(this: Timestamp, unit: Timeunit, duration: uint64): Timestamp: function {
.kind: static function
.base: `function`
.size: 44
.name: 'distribute'
.file: 'cmplStd/lib/time/Timestamp.ci:94'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param this: Timestamp (size: 8, cast: variable(val))
.param unit: Timeunit (size: 8, cast: variable(i64))
.param duration: uint64 (size: 8, cast: variable(u64))
.doc: 'Distribute randomly between current value and the duration at the given time-unit resolution.
For example, if you had the timestamp: 2002-03-28 13:45:01.231,
using distribute(Timeunit.Hours, 2), it will return a date between 2002-03-28 13:46:01.231 and 2002-03-28 15:46:01.231.
	 * @param unit  Resolution of the duration.
@param duration The duration of the distribution time frame, negative values are allowed.'
.value: {
	abort("not implemented");
	return .result := {
			.result.value := (0);
		};
}
.instructions: (44 bytes)
	cmplStd/lib/time/Timestamp.ci:95: (40 bytes): abort("not implemented");
	<distribute>  : load.z32
	<distribute+?>: load.sp(+4)
	<distribute+?>: load.ref <?> ;"cmplStd/lib/time/Timestamp.ci"
	<distribute+?>: load.c32 95
	<distribute+?>: load.c32 -2
	<distribute+?>: load.c32 128
	<distribute+?>: load.ref <?> ;"not implemented"
	<distribute+?>: dup.x64 sp(5)
	<distribute+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<distribute+?>: inc.sp(-8)
	cmplStd/lib/time/Timestamp.ci:96: (4 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:96: (3 bytes): .result.value := (0);
	<distribute+?>: load.z64
	<distribute+?>: set.x64 sp(9)
	<distribute+?>: ret
.usages:
	cmplStd/lib/time/Timestamp.ci:110: referenced as `distribute`
}
Timestamp.distribute(this: Timestamp, unit: Timeunit, start: int32, end: int32): Timestamp: function {
.kind: static function
.base: `function`
.size: 27
.name: 'distribute'
.file: 'cmplStd/lib/time/Timestamp.ci:109'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param this: Timestamp (size: 8, cast: variable(val))
.param unit: Timeunit (size: 8, cast: variable(i64))
.param start: int32 (size: 4, cast: variable(i32))
.param end: int32 (size: 4, cast: variable(i32))
.doc: 'Distribute randomly between start and end at the given time-unit resolution.
For example, if you have the timestamp of 2002-03-28 13:46:01.231,
using distribute(Timeunit.Hours, 15, 17) as start and end, it will return a date between 2002-03-28 15:46:01.231 and 2002-03-28 17:46:01.231.
in case you need a timestamp between 15:00:00.000 and 17:00:00.000 yo will need to use the floor method before or after this operation.
	 * @param unit  Resolution of the operation.
@param start The beginning of the distribution time frame.
@param end   The end of the distribution time frame.'
.value: {
	return .result := distribute(this, unit, end - start);
}
.instructions: (27 bytes)
	cmplStd/lib/time/Timestamp.ci:110: (27 bytes): return .result := distribute(this, unit, end - start);
	<distribute>  : inc.sp(+8)
	<distribute+?>: dup.x64 sp(7)
	<distribute+?>: dup.x64 sp(7)
	<distribute+?>: dup.x32 sp(7)
	<distribute+?>: dup.x32 sp(9)
	<distribute+?>: sub.i32
	<distribute+?>: i32.2i64
	<distribute+?>: load.ref <?> ;Timestamp.distribute(this: Timestamp, unit: Timeunit, duration: uint64): Timestamp
	<distribute+?>: call
	<distribute+?>: inc.sp(-24)
	<distribute+?>: set.x64 sp(9)
	<distribute+?>: ret
.usages:
}
Timestamp.now(): Timestamp: function {
.kind: static function
.base: `function`
.size: 31
.name: 'now'
.file: 'cmplStd/lib/time/Timestamp.ci:114'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.doc: 'get the current utc time as timestamp from the system'
.value: {
	return .result := {
			.result.value := convert(System.millis(), Timeunit.(Millis), Timestamp.precision);
		};
}
.instructions: (31 bytes)
	cmplStd/lib/time/Timestamp.ci:115: (31 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:115: (30 bytes): .result.value := convert(System.millis(), Timeunit.(Millis), Timestamp.precision);
	<now>  : load.z64
	<now+?>: nfc(20) ;System.millis(): int64
	<now+?>: load.c64 1000000
	<now+?>: load.m64 <?> ;Timestamp.precision
	<now+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<now+?>: call
	<now+?>: inc.sp(-24)
	<now+?>: set.x64 sp(3)
	<now+?>: ret
.usages:
}
Timestamp(value: int64, precision: Timeunit): Timestamp: function {
.kind: static function
.base: `function`
.size: 22
.name: 'Timestamp'
.file: 'cmplStd/lib/time/Timestamp.ci:120'
.param .result: Timestamp (size: 8, cast: variable(val))
.param value: int64 (size: 8, cast: variable(i64))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Create a timestamp from the given `value` at the given `precision`'
.value: {
	return .result := {
			.result.value := convert(value, precision, Timestamp.precision);
		};
}
.instructions: (22 bytes)
	cmplStd/lib/time/Timestamp.ci:121: (22 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:121: (21 bytes): .result.value := convert(value, precision, Timestamp.precision);
	<Timestamp>  : load.z64
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: load.m64 <?> ;Timestamp.precision
	<Timestamp+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<Timestamp+?>: call
	<Timestamp+?>: inc.sp(-24)
	<Timestamp+?>: set.x64 sp(7)
	<Timestamp+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:175: referenced as `Timestamp`
	cmplStd/lib/time/Datetime.ci:153: referenced as `Timestamp`
}
Timezone: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Timezone'
.file: 'cmplStd/lib/time/Timezone.ci:2'
.field name: char[] (size: 8, cast: const variable(arr))
.field offset: function (size: 4, cast: variable(ref))
.field offset: function (size: 32, cast: static function)
.field utc: function (size: 20, cast: static function)
.field lookup: function (size: 41, cast: static function)
.field local: function (size: 56, cast: static function)
.usages:
	cmplStd/lib/time/Datetime.ci:307: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:301: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:296: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:292: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:273: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:270: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:179: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:79: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:27: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:24: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:22: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:12: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:11: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:6: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:4: referenced as `Timezone`
}
Timezone.name: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'name'
.file: 'cmplStd/lib/time/Timezone.ci:3'
.owner: Timezone
.usages:
	cmplStd/lib/time/Timezone.ci:33: referenced as `name`
	cmplStd/lib/time/Timezone.ci:18: referenced as `name`
}
Timezone.offset(zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'offset'
.file: 'cmplStd/lib/time/Timezone.ci:4'
.owner: Timezone
.param .result: Duration (size: 8, cast: variable(val))
.param zone: Timezone (size: 4, cast: const variable(ref))
.param timestamp: Timestamp (size: 8, cast: variable(val))
.param isDaylightSaving: bool (size: 4, cast: variable(ref))
.usages:
	cmplStd/lib/time/Timezone.ci:32: referenced as `offset`
	cmplStd/lib/time/Timezone.ci:17: referenced as `offset`
	cmplStd/lib/time/Timezone.ci:8: referenced as `offset`
}
Timezone.offset(zone: Timezone, timestamp: Timestamp): Duration: function {
.kind: static function
.base: `function`
.size: 32
.name: 'offset'
.file: 'cmplStd/lib/time/Timezone.ci:6'
.owner: Timezone
.param .result: Duration (size: 8, cast: variable(val))
.param zone: Timezone (size: 4, cast: const variable(ref))
.param timestamp: Timestamp (size: 8, cast: variable(val))
.value: {
	isDaylightSaving: bool;
	return .result := zone.offset(zone, timestamp, &isDaylightSaving);
}
.instructions: (32 bytes)
	cmplStd/lib/time/Timezone.ci:7: (1 byte): isDaylightSaving: bool
	<offset>  : load.z32
	cmplStd/lib/time/Timezone.ci:8: (31 bytes): return .result := zone.offset(zone, timestamp, &isDaylightSaving);
	<offset+?>: inc.sp(+8)
	<offset+?>: dup.x32 sp(6)
	<offset+?>: dup.x64 sp(5)
	<offset+?>: load.sp(+20)
	<offset+?>: dup.x32 sp(10)
	<offset+?>: inc.i32(+8)
	<offset+?>: load.i32
	<offset+?>: call
	<offset+?>: inc.sp(-16)
	<offset+?>: set.x64 sp(7)
	<offset+?>: inc.sp(-4)
	<offset+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:196: referenced as `offset`
}
Timezone.utc(): Timezone: function {
.kind: static function
.base: `function`
.size: 20
.name: 'utc'
.file: 'cmplStd/lib/time/Timezone.ci:11'
.owner: Timezone
.param .result: Timezone (size: 16, cast: variable(val))
.value: {
	static offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration := {
		isDaylightSaving := false;
		return .result := {
			.result.value := (0);
		};
	};
	return .result := {
			.result.offset := offset;
			.result.name := ("UTC");
		};
}
.instructions: (20 bytes)
	cmplStd/lib/time/Timezone.ci:16: (20 bytes): return .result := {...};
	cmplStd/lib/time/Timezone.ci:17: (7 bytes): .result.offset := offset;
	<utc>  : load.ref <?> ;Timezone.utc.offset(zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration
	<utc+?>: set.x32 sp(4)
	cmplStd/lib/time/Timezone.ci:18: (12 bytes): .result.name := ("UTC");
	<utc+?>: load.c32 3
	<utc+?>: load.ref <?> ;"UTC"
	<utc+?>: set.x64 sp(3)
	<utc+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:307: referenced as `utc`
	cmplStd/lib/time/Datetime.ci:292: referenced as `utc`
	cmplStd/lib/time/Datetime.ci:270: referenced as `utc`
}
Timezone.lookup(name: char[]): Timezone: function {
.kind: static function
.base: `function`
.size: 41
.name: 'lookup'
.file: 'cmplStd/lib/time/Timezone.ci:22'
.owner: Timezone
.param .result: Timezone (size: 16, cast: variable(val))
.param name: char[] (size: 8, cast: const variable(arr))
.value: {
	abort("todo");
}
.instructions: (41 bytes)
	cmplStd/lib/time/Timezone.ci:22: (40 bytes): abort("todo");
	<lookup>  : load.z32
	<lookup+?>: load.sp(+4)
	<lookup+?>: load.ref <?> ;"cmplStd/lib/time/Timezone.ci"
	<lookup+?>: load.c32 22
	<lookup+?>: load.c32 -2
	<lookup+?>: load.c32 128
	<lookup+?>: load.ref <?> ;"todo"
	<lookup+?>: dup.x64 sp(5)
	<lookup+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<lookup+?>: inc.sp(-8)
	<lookup+?>: ret
.usages:
}
Timezone.local(): Timezone: function {
.kind: static function
.base: `function`
.size: 56
.name: 'local'
.file: 'cmplStd/lib/time/Timezone.ci:24'
.owner: Timezone
.param .result: Timezone (size: 16, cast: variable(val))
.value: {
	warn("using fake timezone");
	static offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration := {
		isDaylightSaving := false;
		return .result := Duration(3, Timeunit.(Hours));
	};
	return .result := {
			.result.offset := offset;
			.result.name := ("GMT+3");
		};
}
.instructions: (56 bytes)
	cmplStd/lib/time/Timezone.ci:25: (36 bytes): warn("using fake timezone");
	<local>  : load.z32
	<local+?>: load.sp(+4)
	<local+?>: load.ref <?> ;"cmplStd/lib/time/Timezone.ci"
	<local+?>: load.c32 25
	<local+?>: load.c32 1
	<local+?>: load.z32
	<local+?>: load.ref <?> ;"using fake timezone"
	<local+?>: dup.x64 sp(5)
	<local+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<local+?>: inc.sp(-8)
	cmplStd/lib/time/Timezone.ci:31: (20 bytes): return .result := {...};
	cmplStd/lib/time/Timezone.ci:32: (7 bytes): .result.offset := offset;
	<local+?>: load.ref <?> ;Timezone.local.offset(zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration
	<local+?>: set.x32 sp(4)
	cmplStd/lib/time/Timezone.ci:33: (12 bytes): .result.name := ("GMT+3");
	<local+?>: load.c32 5
	<local+?>: load.ref <?> ;"GMT+3"
	<local+?>: set.x64 sp(3)
	<local+?>: ret
.usages:
}
Month: uint8 {
.kind: static const typename(ERR)
.base: `uint8`
.size: 1
.name: 'Month'
.file: 'cmplStd/lib/time/Datetime.ci:2'
.field January: uint8 (size: 0, cast: static const val)
.field February: uint8 (size: 0, cast: static const val)
.field March: uint8 (size: 0, cast: static const val)
.field April: uint8 (size: 0, cast: static const val)
.field May: uint8 (size: 0, cast: static const val)
.field June: uint8 (size: 0, cast: static const val)
.field July: uint8 (size: 0, cast: static const val)
.field August: uint8 (size: 0, cast: static const val)
.field September: uint8 (size: 0, cast: static const val)
.field October: uint8 (size: 0, cast: static const val)
.field November: uint8 (size: 0, cast: static const val)
.field December: uint8 (size: 0, cast: static const val)
.doc: 'Month of year, January is 1, February is 2, ...'
.usages:
	cmplStd/lib/time/Datetime.ci:159: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:159: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:157: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:157: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:63: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:19: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:19: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:17: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:17: referenced as `Month`
}
Month.January: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'January'
.file: 'cmplStd/lib/time/Datetime.ci:3'
.owner: Month
.doc: 'January'
.value: (1)
.usages:
	cmplStd/lib/time/Datetime.ci:159: referenced as `January`
	cmplStd/lib/time/Datetime.ci:157: referenced as `January`
	cmplStd/lib/time/Datetime.ci:19: referenced as `January`
	cmplStd/lib/time/Datetime.ci:17: referenced as `January`
}
Month.February: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'February'
.file: 'cmplStd/lib/time/Datetime.ci:4'
.owner: Month
.doc: 'February'
.value: (2)
.usages:
}
Month.March: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'March'
.file: 'cmplStd/lib/time/Datetime.ci:5'
.owner: Month
.doc: 'March'
.value: (3)
.usages:
}
Month.April: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'April'
.file: 'cmplStd/lib/time/Datetime.ci:6'
.owner: Month
.doc: 'April'
.value: (4)
.usages:
}
Month.May: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'May'
.file: 'cmplStd/lib/time/Datetime.ci:7'
.owner: Month
.doc: 'May'
.value: (5)
.usages:
}
Month.June: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'June'
.file: 'cmplStd/lib/time/Datetime.ci:8'
.owner: Month
.doc: 'June'
.value: (6)
.usages:
}
Month.July: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'July'
.file: 'cmplStd/lib/time/Datetime.ci:9'
.owner: Month
.doc: 'July'
.value: (7)
.usages:
}
Month.August: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'August'
.file: 'cmplStd/lib/time/Datetime.ci:10'
.owner: Month
.doc: 'August'
.value: (8)
.usages:
}
Month.September: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'September'
.file: 'cmplStd/lib/time/Datetime.ci:11'
.owner: Month
.doc: 'September'
.value: (9)
.usages:
}
Month.October: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'October'
.file: 'cmplStd/lib/time/Datetime.ci:12'
.owner: Month
.doc: 'October'
.value: (10)
.usages:
}
Month.November: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'November'
.file: 'cmplStd/lib/time/Datetime.ci:13'
.owner: Month
.doc: 'November'
.value: (11)
.usages:
}
Month.December: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'December'
.file: 'cmplStd/lib/time/Datetime.ci:14'
.owner: Month
.doc: 'December'
.value: (12)
.usages:
	cmplStd/lib/time/Datetime.ci:159: referenced as `December`
	cmplStd/lib/time/Datetime.ci:157: referenced as `December`
}
Month(index: int32): Month: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Month'
.file: 'cmplStd/lib/time/Datetime.ci:17'
.param .result: Month (size: 1, cast: u32)
.param index: int32 (size: 4, cast: i32)
.doc: 'FIXME: implement enum indexing'
.value: Month(emit(int32(index + (Month.(January)))))
.usages:
	cmplStd/lib/time/Datetime.ci:276: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:249: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:133: referenced as `Month`
}
indexOf(value: Month): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'indexOf'
.file: 'cmplStd/lib/time/Datetime.ci:19'
.param .result: int32 (size: 4, cast: i32)
.param value: Month (size: 4, cast: u32)
.doc: 'FIXME: implement enum indexing'
.value: int32(value - (Month.(January)))
.usages:
	cmplStd/lib/text/Format.ci:405: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:381: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:354: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:350: referenced as `indexOf`
	cmplStd/lib/time/Datetime.ci:119: referenced as `indexOf`
}
Weekday: uint8 {
.kind: static const typename(ERR)
.base: `uint8`
.size: 1
.name: 'Weekday'
.file: 'cmplStd/lib/time/Datetime.ci:22'
.field Monday: uint8 (size: 0, cast: static const val)
.field Tuesday: uint8 (size: 0, cast: static const val)
.field Wednesday: uint8 (size: 0, cast: static const val)
.field Thursday: uint8 (size: 0, cast: static const val)
.field Friday: uint8 (size: 0, cast: static const val)
.field Saturday: uint8 (size: 0, cast: static const val)
.field Sunday: uint8 (size: 0, cast: static const val)
.doc: 'Day of week, Monday is 1, Tuesday is 2, ...'
.usages:
	cmplStd/lib/time/Datetime.ci:285: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:264: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:92: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:34: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:34: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:32: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:32: referenced as `Weekday`
}
Weekday.Monday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Monday'
.file: 'cmplStd/lib/time/Datetime.ci:23'
.owner: Weekday
.doc: 'Monday'
.value: (1)
.usages:
	cmplStd/lib/time/Datetime.ci:285: referenced as `Monday`
	cmplStd/lib/time/Datetime.ci:34: referenced as `Monday`
	cmplStd/lib/time/Datetime.ci:32: referenced as `Monday`
}
Weekday.Tuesday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Tuesday'
.file: 'cmplStd/lib/time/Datetime.ci:24'
.owner: Weekday
.doc: 'Tuesday'
.value: (2)
.usages:
}
Weekday.Wednesday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Wednesday'
.file: 'cmplStd/lib/time/Datetime.ci:25'
.owner: Weekday
.doc: 'Wednesday'
.value: (3)
.usages:
}
Weekday.Thursday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Thursday'
.file: 'cmplStd/lib/time/Datetime.ci:26'
.owner: Weekday
.doc: 'Thursday'
.value: (4)
.usages:
	cmplStd/lib/time/Datetime.ci:264: referenced as `Thursday`
}
Weekday.Friday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Friday'
.file: 'cmplStd/lib/time/Datetime.ci:27'
.owner: Weekday
.doc: 'Friday'
.value: (5)
.usages:
}
Weekday.Saturday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Saturday'
.file: 'cmplStd/lib/time/Datetime.ci:28'
.owner: Weekday
.doc: 'Saturday'
.value: (6)
.usages:
}
Weekday.Sunday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Sunday'
.file: 'cmplStd/lib/time/Datetime.ci:29'
.owner: Weekday
.doc: 'Sunday'
.value: (7)
.usages:
}
Weekday(index: int32): Weekday: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Weekday'
.file: 'cmplStd/lib/time/Datetime.ci:32'
.param .result: Weekday (size: 1, cast: u32)
.param index: int32 (size: 4, cast: i32)
.doc: 'FIXME: implement enum indexing'
.value: Weekday(emit(int32(index + (Weekday.(Monday)))))
.usages:
	cmplStd/lib/time/Datetime.ci:263: referenced as `Weekday`
}
indexOf(value: Weekday): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'indexOf'
.file: 'cmplStd/lib/time/Datetime.ci:34'
.param .result: int32 (size: 4, cast: i32)
.param value: Weekday (size: 4, cast: u32)
.doc: 'FIXME: implement enum indexing'
.value: int32(value - (Weekday.(Monday)))
.usages:
	cmplStd/lib/text/Format.ci:452: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:346: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:342: referenced as `indexOf`
	cmplStd/lib/time/Datetime.ci:264: referenced as `indexOf`
}
Calendar: uint8 {
.kind: static const typename(ERR)
.base: `uint8`
.size: 1
.name: 'Calendar'
.file: 'cmplStd/lib/time/Datetime.ci:37'
.field Gregorian: uint8 (size: 0, cast: static const val)
.doc: 'Type of the calendar'
.usages:
	cmplStd/lib/time/Datetime.ci:270: referenced as `Calendar`
	cmplStd/lib/time/Datetime.ci:180: referenced as `Calendar`
	cmplStd/lib/time/Datetime.ci:179: referenced as `Calendar`
}
Calendar.Gregorian: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Gregorian'
.file: 'cmplStd/lib/time/Datetime.ci:38'
.owner: Calendar
.doc: 'Gregorian'
.value: (0)
.usages:
	cmplStd/lib/time/Datetime.ci:270: referenced as `Gregorian`
	cmplStd/lib/time/Datetime.ci:180: referenced as `Gregorian`
}
Datetime: typename {
.kind: static const typename(val)
.base: `typename`
.size: 40
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:57'
.field year: int32 (size: 4, cast: const variable(i32))
.field month: Month (size: 1, cast: const variable(u32))
.field day: uint8 (size: 1, cast: const variable(u32))
.field hour: uint8 (size: 1, cast: const variable(u32))
.field minute: uint8 (size: 1, cast: const variable(u32))
.field second: uint8 (size: 1, cast: const variable(u32))
.field millis: uint16 (size: 2, cast: const variable(u32))
.field timezone: Timezone (size: 16, cast: const variable(val))
.field weekOfYear: uint8 (size: 1, cast: const variable(u32))
.field dayOfYear: uint16 (size: 2, cast: const variable(u32))
.field dayOfWeek: Weekday (size: 1, cast: const variable(u32))
.field leapYear: bool (size: 1, cast: const variable(bool))
.field DaysToMonth365: int32[13] (size: 52, cast: static const variable(val))
.field DaysToMonth366: int32[13] (size: 52, cast: static const variable(val))
.field DaysTil1970: int32 (size: 4, cast: static const variable(i32))
.field isLeapYear: function (size: 78, cast: static function)
.field add: function (size: 272, cast: static function)
.doc: 'DateTime represents the parts of an instant in time.'
.usages:
	cmplStd/lib/text/Format.ci:507: referenced as `Datetime`
	cmplStd/lib/text/Format.ci:501: referenced as `Datetime`
	cmplStd/lib/text/Format.ci:313: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:306: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:301: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:296: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:291: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:286: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:273: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:265: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:239: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:239: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:239: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:198: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:179: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:173: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:162: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:162: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:162: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:149: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:116: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:116: referenced as `Datetime`
}
Datetime.year: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'year'
.file: 'cmplStd/lib/time/Datetime.ci:61'
.owner: Datetime
.doc: 'Year: 1970'
.usages:
	cmplStd/lib/text/Format.ci:475: referenced as `year`
	cmplStd/lib/text/Format.ci:471: referenced as `year`
	cmplStd/lib/text/Format.ci:359: referenced as `year`
	cmplStd/lib/time/Datetime.ci:275: referenced as `year`
	cmplStd/lib/time/Datetime.ci:248: referenced as `year`
	cmplStd/lib/time/Datetime.ci:150: referenced as `year`
	cmplStd/lib/time/Datetime.ci:132: referenced as `year`
	cmplStd/lib/time/Datetime.ci:117: referenced as `year`
}
Datetime.month: Month {
.kind: const variable(u32)
.base: `Month`
.size: 1
.name: 'month'
.file: 'cmplStd/lib/time/Datetime.ci:63'
.owner: Datetime
.doc: 'Month of year: 1 ... 12 / [Jan, Feb, Mar, ...]'
.usages:
	cmplStd/lib/text/Format.ci:405: referenced as `month`
	cmplStd/lib/text/Format.ci:381: referenced as `month`
	cmplStd/lib/text/Format.ci:354: referenced as `month`
	cmplStd/lib/text/Format.ci:350: referenced as `month`
	cmplStd/lib/time/Datetime.ci:276: referenced as `month`
	cmplStd/lib/time/Datetime.ci:249: referenced as `month`
	cmplStd/lib/time/Datetime.ci:156: referenced as `month`
	cmplStd/lib/time/Datetime.ci:133: referenced as `month`
	cmplStd/lib/time/Datetime.ci:119: referenced as `month`
}
Datetime.day: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'day'
.file: 'cmplStd/lib/time/Datetime.ci:65'
.owner: Datetime
.doc: 'Day of month: 1 ... 30'
.usages:
	cmplStd/lib/text/Format.ci:371: referenced as `day`
	cmplStd/lib/text/Format.ci:363: referenced as `day`
	cmplStd/lib/time/Datetime.ci:277: referenced as `day`
	cmplStd/lib/time/Datetime.ci:250: referenced as `day`
	cmplStd/lib/time/Datetime.ci:164: referenced as `day`
	cmplStd/lib/time/Datetime.ci:134: referenced as `day`
	cmplStd/lib/time/Datetime.ci:134: referenced as `day`
}
Datetime.hour: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'hour'
.file: 'cmplStd/lib/time/Datetime.ci:70'
.owner: Datetime
.doc: 'Hour of day: 0 ... 23'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:426: referenced as `hour`
	cmplStd/lib/text/Format.ci:422: referenced as `hour`
	cmplStd/lib/text/Format.ci:401: referenced as `hour`
	cmplStd/lib/text/Format.ci:397: referenced as `hour`
	cmplStd/lib/text/Format.ci:389: referenced as `hour`
	cmplStd/lib/text/Format.ci:385: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:278: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:253: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:174: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:135: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:135: referenced as `hour`
}
Datetime.minute: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'minute'
.file: 'cmplStd/lib/time/Datetime.ci:72'
.owner: Datetime
.doc: 'Minute of hour: 0 ... 59'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:409: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:279: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:254: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:174: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:136: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:136: referenced as `minute`
}
Datetime.second: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'second'
.file: 'cmplStd/lib/time/Datetime.ci:74'
.owner: Datetime
.doc: 'Second of minute: 0 ... 59'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:440: referenced as `second`
	cmplStd/lib/time/Datetime.ci:280: referenced as `second`
	cmplStd/lib/time/Datetime.ci:255: referenced as `second`
	cmplStd/lib/time/Datetime.ci:174: referenced as `second`
	cmplStd/lib/time/Datetime.ci:137: referenced as `second`
	cmplStd/lib/time/Datetime.ci:137: referenced as `second`
}
Datetime.millis: uint16 {
.kind: const variable(u32)
.base: `uint16`
.size: 2
.name: 'millis'
.file: 'cmplStd/lib/time/Datetime.ci:76'
.owner: Datetime
.doc: 'Milliseconds of second: 0 ... 999'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:418: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:281: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:256: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:174: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:138: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:138: referenced as `millis`
}
Datetime.timezone: Timezone {
.kind: const variable(val)
.base: `Timezone`
.size: 16
.name: 'timezone'
.file: 'cmplStd/lib/time/Datetime.ci:79'
.owner: Datetime
.doc: 'timezone'
.usages:
	cmplStd/lib/time/Datetime.ci:282: referenced as `timezone`
	cmplStd/lib/time/Datetime.ci:259: referenced as `timezone`
	cmplStd/lib/time/Datetime.ci:139: referenced as `timezone`
	cmplStd/lib/time/Datetime.ci:139: referenced as `timezone`
}
Datetime.weekOfYear: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'weekOfYear'
.file: 'cmplStd/lib/time/Datetime.ci:86'
.owner: Datetime
.doc: 'Nth week of the year: 1 ... 53'
.usages:
	cmplStd/lib/text/Format.ci:459: referenced as `weekOfYear`
	cmplStd/lib/time/Datetime.ci:283: referenced as `weekOfYear`
	cmplStd/lib/time/Datetime.ci:264: referenced as `weekOfYear`
	cmplStd/lib/time/Datetime.ci:140: referenced as `weekOfYear`
	cmplStd/lib/time/Datetime.ci:140: referenced as `weekOfYear`
}
Datetime.dayOfYear: uint16 {
.kind: const variable(u32)
.base: `uint16`
.size: 2
.name: 'dayOfYear'
.file: 'cmplStd/lib/time/Datetime.ci:89'
.owner: Datetime
.doc: 'Nth day of the year: 1 ... 365'
.usages:
	cmplStd/lib/text/Format.ci:393: referenced as `dayOfYear`
	cmplStd/lib/time/Datetime.ci:284: referenced as `dayOfYear`
	cmplStd/lib/time/Datetime.ci:262: referenced as `dayOfYear`
	cmplStd/lib/time/Datetime.ci:141: referenced as `dayOfYear`
	cmplStd/lib/time/Datetime.ci:141: referenced as `dayOfYear`
}
Datetime.dayOfWeek: Weekday {
.kind: const variable(u32)
.base: `Weekday`
.size: 1
.name: 'dayOfWeek'
.file: 'cmplStd/lib/time/Datetime.ci:92'
.owner: Datetime
.doc: 'Day of week: 1 ... 7 / [Mon, Tue, ...]'
.usages:
	cmplStd/lib/text/Format.ci:452: referenced as `dayOfWeek`
	cmplStd/lib/text/Format.ci:346: referenced as `dayOfWeek`
	cmplStd/lib/text/Format.ci:342: referenced as `dayOfWeek`
	cmplStd/lib/time/Datetime.ci:285: referenced as `dayOfWeek`
	cmplStd/lib/time/Datetime.ci:263: referenced as `dayOfWeek`
	cmplStd/lib/time/Datetime.ci:142: referenced as `dayOfWeek`
	cmplStd/lib/time/Datetime.ci:142: referenced as `dayOfWeek`
}
Datetime.leapYear: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'leapYear'
.file: 'cmplStd/lib/time/Datetime.ci:95'
.owner: Datetime
.doc: 'this is a leap year'
.usages:
	cmplStd/lib/time/Datetime.ci:286: referenced as `leapYear`
	cmplStd/lib/time/Datetime.ci:265: referenced as `leapYear`
	cmplStd/lib/time/Datetime.ci:143: referenced as `leapYear`
}
Datetime.DaysToMonth365: int32[13] {
.kind: static const variable(val)
.base: `int32[13]`
.size: 52
.name: 'DaysToMonth365'
.file: 'cmplStd/lib/time/Datetime.ci:97'
.owner: Datetime
.value: {
	DaysToMonth365[0] := 0;
	DaysToMonth365[1] := 31;
	DaysToMonth365[2] := 59;
	DaysToMonth365[3] := 90;
	DaysToMonth365[4] := 120;
	DaysToMonth365[5] := 151;
	DaysToMonth365[6] := 181;
	DaysToMonth365[7] := 212;
	DaysToMonth365[8] := 243;
	DaysToMonth365[9] := 273;
	DaysToMonth365[10] := 304;
	DaysToMonth365[11] := 334;
	DaysToMonth365[12] := 365;
}
.usages:
	cmplStd/lib/time/Datetime.ci:239: referenced as `DaysToMonth365`
	cmplStd/lib/time/Datetime.ci:162: referenced as `DaysToMonth365`
}
Datetime.DaysToMonth366: int32[13] {
.kind: static const variable(val)
.base: `int32[13]`
.size: 52
.name: 'DaysToMonth366'
.file: 'cmplStd/lib/time/Datetime.ci:98'
.owner: Datetime
.value: {
	DaysToMonth366[0] := 0;
	DaysToMonth366[1] := 31;
	DaysToMonth366[2] := 60;
	DaysToMonth366[3] := 91;
	DaysToMonth366[4] := 121;
	DaysToMonth366[5] := 152;
	DaysToMonth366[6] := 182;
	DaysToMonth366[7] := 213;
	DaysToMonth366[8] := 244;
	DaysToMonth366[9] := 274;
	DaysToMonth366[10] := 305;
	DaysToMonth366[11] := 335;
	DaysToMonth366[12] := 366;
}
.usages:
	cmplStd/lib/time/Datetime.ci:265: referenced as `DaysToMonth366`
	cmplStd/lib/time/Datetime.ci:239: referenced as `DaysToMonth366`
	cmplStd/lib/time/Datetime.ci:162: referenced as `DaysToMonth366`
}
Datetime.DaysTil1970: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.name: 'DaysTil1970'
.file: 'cmplStd/lib/time/Datetime.ci:99'
.owner: Datetime
.value: 719162
.usages:
	cmplStd/lib/time/Datetime.ci:198: referenced as `DaysTil1970`
	cmplStd/lib/time/Datetime.ci:173: referenced as `DaysTil1970`
}
Datetime.isLeapYear(year: int32): bool: function {
.kind: static function
.base: `function`
.size: 78
.name: 'isLeapYear'
.file: 'cmplStd/lib/time/Datetime.ci:102'
.owner: Datetime
.param .result: bool (size: 4, cast: variable(bool))
.param year: int32 (size: 4, cast: variable(i32))
.doc: 'Checks weather the given year is a leap year or not'
.value: {
	if (year % 4 != 0) {
		return .result := false;
	}
	if (year % 100 != 0) {
		return .result := true;
	}
	if (year % 400 != 0) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (78 bytes)
	cmplStd/lib/time/Datetime.ci:103: (21 bytes): if (year % 4 != 0)
	<isLeapYear>  : dup.x32 sp(1)
	<isLeapYear+?>: load.c32 4
	<isLeapYear+?>: mod.i32
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: ceq.i32
	<isLeapYear+?>: jnz +11
	cmplStd/lib/time/Datetime.ci:104: (7 bytes): return .result := false;
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: load.sp(+12)
	<isLeapYear+?>: store.i8
	<isLeapYear+?>: ret
	cmplStd/lib/time/Datetime.ci:106: (25 bytes): if (year % 100 != 0)
	<isLeapYear+?>: dup.x32 sp(1)
	<isLeapYear+?>: load.c32 100
	<isLeapYear+?>: mod.i32
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: ceq.i32
	<isLeapYear+?>: jnz +15
	cmplStd/lib/time/Datetime.ci:107: (11 bytes): return .result := true;
	<isLeapYear+?>: load.c32 1
	<isLeapYear+?>: load.sp(+12)
	<isLeapYear+?>: store.i8
	<isLeapYear+?>: ret
	cmplStd/lib/time/Datetime.ci:109: (21 bytes): if (year % 400 != 0)
	<isLeapYear+?>: dup.x32 sp(1)
	<isLeapYear+?>: load.c32 400
	<isLeapYear+?>: mod.i32
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: ceq.i32
	<isLeapYear+?>: jnz +11
	cmplStd/lib/time/Datetime.ci:110: (7 bytes): return .result := false;
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: load.sp(+12)
	<isLeapYear+?>: store.i8
	<isLeapYear+?>: ret
	cmplStd/lib/time/Datetime.ci:112: (11 bytes): return .result := true;
	<isLeapYear+?>: load.c32 1
	<isLeapYear+?>: load.sp(+12)
	<isLeapYear+?>: store.i8
	<isLeapYear+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:286: referenced as `isLeapYear`
	cmplStd/lib/time/Datetime.ci:239: referenced as `isLeapYear`
	cmplStd/lib/time/Datetime.ci:162: referenced as `isLeapYear`
	cmplStd/lib/time/Datetime.ci:143: referenced as `isLeapYear`
}
Datetime.add(cal: Datetime, years: int32, months: int32, days: int32): Datetime: function {
.kind: static function
.base: `function`
.size: 272
.name: 'add'
.file: 'cmplStd/lib/time/Datetime.ci:116'
.owner: Datetime
.param .result: Datetime (size: 40, cast: variable(val))
.param cal: Datetime (size: 40, cast: variable(val))
.param years: int32 (size: 4, cast: variable(i32))
.param months: int32 (size: 4, cast: variable(i32))
.param days: int32 (size: 4, cast: variable(i32))
.doc: 'Add the amount of `years`, `months` and `days` to the datetime'
.value: {
	year: int32 := cal.year + years;
	month: int32 := indexOf(cal.month) + months;
	if (month >= 12) {
		year := year + month / 12;
		month := month % 12;
	}
	else if (month < 0) {
		year := year + month / 12 - 1;
		month := 12 - (-month % 12);
	}
	assert(days == 0);
	return .result := {
			.result.year := year;
			.result.month := Month(month % 12);
			.result.day := cal.day;
			.result.hour := cal.hour;
			.result.minute := cal.minute;
			.result.second := cal.second;
			.result.millis := cal.millis;
			.result.timezone := cal.timezone;
			.result.weekOfYear := cal.weekOfYear;
			.result.dayOfYear := cal.dayOfYear;
			.result.dayOfWeek := cal.dayOfWeek;
			.result.leapYear := isLeapYear(year);
		};
}
.instructions: (272 bytes)
	cmplStd/lib/time/Datetime.ci:117: (5 bytes): year: int32 := cal.year + years
	<add>  : dup.x32 sp(4)
	<add+?>: dup.x32 sp(4)
	<add+?>: add.i32
	cmplStd/lib/time/Datetime.ci:119: (12 bytes): month: int32 := indexOf(cal.month) + months
	<add+?>: load.sp(+24)
	<add+?>: load.iu8
	<add+?>: inc.i32(-1)
	<add+?>: dup.x32 sp(4)
	<add+?>: add.i32
	cmplStd/lib/time/Datetime.ci:120: (77 bytes): if (month >= 12)
	<add+?>: dup.x32 sp(0)
	<add+?>: load.c32 12
	<add+?>: clt.i32
	<add+?>: jnz +27
	cmplStd/lib/time/Datetime.ci:121: (13 bytes): year := year + month / 12;
	<add+?>: dup.x32 sp(1)
	<add+?>: dup.x32 sp(1)
	<add+?>: load.c32 12
	<add+?>: div.i32
	<add+?>: add.i32
	<add+?>: set.x32 sp(2)
	cmplStd/lib/time/Datetime.ci:122: (6 bytes): month := month % 12;
	<add+?>: load.c32 12
	<add+?>: mod.i32
	<add+?>: jmp +46
	cmplStd/lib/time/Datetime.ci:124: (42 bytes): if (month < 0)
	<add+?>: dup.x32 sp(0)
	<add+?>: load.z32
	<add+?>: clt.i32
	<add+?>: jz +38
	cmplStd/lib/time/Datetime.ci:125: (17 bytes): year := year + month / 12 - 1;
	<add+?>: dup.x32 sp(1)
	<add+?>: dup.x32 sp(1)
	<add+?>: load.c32 12
	<add+?>: div.i32
	<add+?>: inc.i32(-1)
	<add+?>: add.i32
	<add+?>: set.x32 sp(2)
	cmplStd/lib/time/Datetime.ci:126: (17 bytes): month := 12 - (-month % 12);
	<add+?>: load.c32 12
	<add+?>: dup.x32 sp(1)
	<add+?>: neg.i32
	<add+?>: load.c32 12
	<add+?>: mod.i32
	<add+?>: sub.i32
	<add+?>: set.x32 sp(1)
	cmplStd/lib/time/Datetime.ci:129: (52 bytes): assert(days == 0);
	<add+?>: load.z32
	<add+?>: load.sp(+4)
	<add+?>: dup.x32 sp(5)
	<add+?>: load.z32
	<add+?>: ceq.i32
	<add+?>: jz +8
	<add+?>: jmp +35
	<add+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<add+?>: load.c32 129
	<add+?>: load.c32 -2
	<add+?>: load.c32 128
	<add+?>: load.ref <?> ;"assertion failed!"
	<add+?>: dup.x64 sp(5)
	<add+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<add+?>: inc.sp(-8)
	cmplStd/lib/time/Datetime.ci:131: (126 bytes): return .result := {...};
	cmplStd/lib/time/Datetime.ci:132: (3 bytes): .result.year := year;
	<add+?>: mov.x32 sp(16, 1)
	cmplStd/lib/time/Datetime.ci:133: (17 bytes): .result.month := Month(month % 12);
	<add+?>: dup.x32 sp(0)
	<add+?>: load.c32 12
	<add+?>: mod.i32
	<add+?>: inc.i32(+1)
	<add+?>: load.sp(+72)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:134: (10 bytes): .result.day := cal.day;
	<add+?>: load.sp(+29)
	<add+?>: load.iu8
	<add+?>: load.sp(+73)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:135: (10 bytes): .result.hour := cal.hour;
	<add+?>: load.sp(+30)
	<add+?>: load.iu8
	<add+?>: load.sp(+74)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:136: (10 bytes): .result.minute := cal.minute;
	<add+?>: load.sp(+31)
	<add+?>: load.iu8
	<add+?>: load.sp(+75)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:137: (10 bytes): .result.second := cal.second;
	<add+?>: load.sp(+32)
	<add+?>: load.iu8
	<add+?>: load.sp(+76)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:138: (10 bytes): .result.millis := cal.millis;
	<add+?>: load.sp(+34)
	<add+?>: load.iu16
	<add+?>: load.sp(+78)
	<add+?>: store.i16
	cmplStd/lib/time/Datetime.ci:139: (3 bytes): .result.timezone := cal.timezone;
	<add+?>: mov.x128 sp(20, 10)
	cmplStd/lib/time/Datetime.ci:140: (10 bytes): .result.weekOfYear := cal.weekOfYear;
	<add+?>: load.sp(+56)
	<add+?>: load.iu8
	<add+?>: load.sp(+100)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:141: (10 bytes): .result.dayOfYear := cal.dayOfYear;
	<add+?>: load.sp(+58)
	<add+?>: load.iu16
	<add+?>: load.sp(+102)
	<add+?>: store.i16
	cmplStd/lib/time/Datetime.ci:142: (10 bytes): .result.dayOfWeek := cal.dayOfWeek;
	<add+?>: load.sp(+60)
	<add+?>: load.iu8
	<add+?>: load.sp(+104)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:143: (18 bytes): .result.leapYear := isLeapYear(year);
	<add+?>: load.z32
	<add+?>: dup.x32 sp(2)
	<add+?>: load.ref <?> ;Datetime.isLeapYear(year: int32): bool
	<add+?>: call
	<add+?>: inc.sp(-4)
	<add+?>: load.sp(+105)
	<add+?>: store.i8
	<add+?>: inc.sp(-8)
	<add+?>: ret
.usages:
}
Timestamp(value: Datetime): Timestamp: function {
.kind: static function
.base: `function`
.size: 626
.name: 'Timestamp'
.file: 'cmplStd/lib/time/Datetime.ci:149'
.param .result: Timestamp (size: 8, cast: variable(val))
.param value: Datetime (size: 40, cast: variable(val))
.doc: 'Convert the given Datetime `value` to a timestamp (milliseconds since 1970)'
.value: {
	year: int32 := value.year;
	if (year < 0 || year > 9999) {
		trace("invalid year", year);
		return .result := Timestamp(1 << 63, Timestamp.precision);
	}
	month: int32 := value.month;
	if (month < (Month.(January)) || month > (Month.(December))) {
		trace("invalid month", month);
		month := Math.clamp(month, int32(Month.(January)), int32(Month.(December)));
	}
	const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365;
	day: int32 := value.day;
	daysInYear: int32 := DaysToMonth[month - 1];
	daysInMonth: int32 := DaysToMonth[month] - daysInYear;
	if (day < 1 || day > daysInMonth) {
		trace("invalid day of month", day);
		day := Math.clamp(day, 1, daysInMonth);
	}
	y: int32 := year - 1;
	d: int64 := y * 365 + y / 4 - y / 100 + y / 400 + daysInYear + day - 1 - Datetime.DaysTil1970;
	t: int64 := (((d * (24) + (value.hour)) * (60) + (value.minute)) * (60) + (value.second)) * (1000) + (value.millis);
	return .result := Timestamp(t, Timeunit.(Millis));
}
.instructions: (626 bytes)
	cmplStd/lib/time/Datetime.ci:150: (2 bytes): year: int32 := value.year
	<Timestamp>  : dup.x32 sp(1)
	cmplStd/lib/time/Datetime.ci:151: (119 bytes): if (year < 0 || year > 9999)
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.z32
	<Timestamp+?>: clt.i32
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: jnz +16
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.c32 9999
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +97
	cmplStd/lib/time/Datetime.ci:152: (53 bytes): trace("invalid year", year);
	<Timestamp+?>: load.ref <?> ;int32
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<Timestamp+?>: load.c32 152
	<Timestamp+?>: load.c32 14
	<Timestamp+?>: load.c32 128
	<Timestamp+?>: load.ref <?> ;"invalid year"
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<Timestamp+?>: inc.sp(-16)
	cmplStd/lib/time/Datetime.ci:153: (40 bytes): return .result := Timestamp(1 << 63, Timestamp.precision);
	<Timestamp+?>: inc.sp(+8)
	<Timestamp+?>: load.c64 1
	<Timestamp+?>: load.c32 63
	<Timestamp+?>: shl.b64
	<Timestamp+?>: load.m64 <?> ;Timestamp.precision
	<Timestamp+?>: load.ref <?> ;Timestamp(value: int64, precision: Timeunit): Timestamp
	<Timestamp+?>: call
	<Timestamp+?>: inc.sp(-16)
	<Timestamp+?>: set.x64 sp(14)
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: ret
	cmplStd/lib/time/Datetime.ci:156: (5 bytes): month: int32 := value.month
	<Timestamp+?>: load.sp(+12)
	<Timestamp+?>: load.iu8
	cmplStd/lib/time/Datetime.ci:157: (141 bytes): if (month < (Month.(January)) || month > (Month.(December)))
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: clt.i32
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: jnz +16
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.c32 12
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +115
	cmplStd/lib/time/Datetime.ci:158: (53 bytes): trace("invalid month", month);
	<Timestamp+?>: load.ref <?> ;int32
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<Timestamp+?>: load.c32 158
	<Timestamp+?>: load.c32 14
	<Timestamp+?>: load.c32 128
	<Timestamp+?>: load.ref <?> ;"invalid month"
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<Timestamp+?>: inc.sp(-16)
	cmplStd/lib/time/Datetime.ci:159: (58 bytes): month := Math.clamp(month, int32(Month.(January)), int32(Month.(December)));
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +10
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: jmp +6
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: mov.x32 sp(2, 0)
	<Timestamp+?>: inc.sp(-8)
	<Timestamp+?>: load.c32 12
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: clt.i32
	<Timestamp+?>: jz +10
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: jmp +6
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: mov.x32 sp(2, 0)
	<Timestamp+?>: inc.sp(-8)
	cmplStd/lib/time/Datetime.ci:162: (31 bytes): const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365
	<Timestamp+?>: load.z32
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: load.ref <?> ;Datetime.isLeapYear(year: int32): bool
	<Timestamp+?>: call
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: jz +13
	<Timestamp+?>: load.ref <?> ;Datetime.DaysToMonth366
	<Timestamp+?>: jmp +9
	<Timestamp+?>: load.ref <?> ;Datetime.DaysToMonth365
	cmplStd/lib/time/Datetime.ci:164: (5 bytes): day: int32 := value.day
	<Timestamp+?>: load.sp(+21)
	<Timestamp+?>: load.iu8
	cmplStd/lib/time/Datetime.ci:165: (13 bytes): daysInYear: int32 := DaysToMonth[month - 1]
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(3)
	<Timestamp+?>: inc.i32(-1)
	<Timestamp+?>: mad.u32 4
	<Timestamp+?>: load.i32
	cmplStd/lib/time/Datetime.ci:166: (12 bytes): daysInMonth: int32 := DaysToMonth[month] - daysInYear
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: dup.x32 sp(4)
	<Timestamp+?>: mad.u32 4
	<Timestamp+?>: load.i32
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: sub.i32
	cmplStd/lib/time/Datetime.ci:167: (139 bytes): if (day < 1 || day > daysInMonth)
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: clt.i32
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: jnz +13
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +116
	cmplStd/lib/time/Datetime.ci:168: (53 bytes): trace("invalid day of month", day);
	<Timestamp+?>: load.ref <?> ;int32
	<Timestamp+?>: load.sp(+12)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<Timestamp+?>: load.c32 168
	<Timestamp+?>: load.c32 14
	<Timestamp+?>: load.c32 128
	<Timestamp+?>: load.ref <?> ;"invalid day of month"
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<Timestamp+?>: inc.sp(-16)
	cmplStd/lib/time/Datetime.ci:169: (59 bytes): day := Math.clamp(day, 1, daysInMonth);
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +10
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: jmp +6
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: mov.x32 sp(2, 0)
	<Timestamp+?>: inc.sp(-8)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: clt.i32
	<Timestamp+?>: jz +10
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: jmp +6
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: mov.x32 sp(2, 0)
	<Timestamp+?>: inc.sp(-8)
	<Timestamp+?>: set.x32 sp(3)
	cmplStd/lib/time/Datetime.ci:172: (6 bytes): y: int32 := year - 1
	<Timestamp+?>: dup.x32 sp(5)
	<Timestamp+?>: inc.i32(-1)
	cmplStd/lib/time/Datetime.ci:173: (51 bytes): d: int64 := y * 365 + y / 4 - y / 100 + y / 400 + daysInYear + day - 1 - Datetime.DaysTil1970
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.c32 365
	<Timestamp+?>: mul.i32
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: load.c32 4
	<Timestamp+?>: div.i32
	<Timestamp+?>: add.i32
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: load.c32 100
	<Timestamp+?>: div.i32
	<Timestamp+?>: sub.i32
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: load.c32 400
	<Timestamp+?>: div.i32
	<Timestamp+?>: add.i32
	<Timestamp+?>: dup.x32 sp(3)
	<Timestamp+?>: add.i32
	<Timestamp+?>: dup.x32 sp(4)
	<Timestamp+?>: add.i32
	<Timestamp+?>: inc.i32(-1)
	<Timestamp+?>: load.m32 <?> ;Datetime.DaysTil1970
	<Timestamp+?>: sub.i32
	<Timestamp+?>: i32.2i64
	cmplStd/lib/time/Datetime.ci:174: (70 bytes): t: int64 := (((d * (24) + (value.hour)) * (60) + (value.minute)) * (60) + (value.second)) * (1000) + (value.millis)
	<Timestamp+?>: dup.x64 sp(0)
	<Timestamp+?>: load.c64 24
	<Timestamp+?>: mul.i64
	<Timestamp+?>: load.sp(+54)
	<Timestamp+?>: load.iu8
	<Timestamp+?>: u32.2i64
	<Timestamp+?>: add.i64
	<Timestamp+?>: load.c64 60
	<Timestamp+?>: mul.i64
	<Timestamp+?>: load.sp(+55)
	<Timestamp+?>: load.iu8
	<Timestamp+?>: u32.2i64
	<Timestamp+?>: add.i64
	<Timestamp+?>: load.c64 60
	<Timestamp+?>: mul.i64
	<Timestamp+?>: load.sp(+56)
	<Timestamp+?>: load.iu8
	<Timestamp+?>: u32.2i64
	<Timestamp+?>: add.i64
	<Timestamp+?>: load.c64 1000
	<Timestamp+?>: mul.i64
	<Timestamp+?>: load.sp(+58)
	<Timestamp+?>: load.iu16
	<Timestamp+?>: u32.2i64
	<Timestamp+?>: add.i64
	cmplStd/lib/time/Datetime.ci:175: (32 bytes): return .result := Timestamp(t, Timeunit.(Millis));
	<Timestamp+?>: inc.sp(+8)
	<Timestamp+?>: dup.x64 sp(2)
	<Timestamp+?>: load.c64 1000000
	<Timestamp+?>: load.ref <?> ;Timestamp(value: int64, precision: Timeunit): Timestamp
	<Timestamp+?>: call
	<Timestamp+?>: inc.sp(-16)
	<Timestamp+?>: set.x64 sp(24)
	<Timestamp+?>: inc.sp(-44)
	<Timestamp+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:436: referenced as `Timestamp`
}
Datetime(timestamp: Timestamp, calendar: Calendar, timezone: Timezone): Datetime: function {
.kind: static function
.base: `function`
.size: 630
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:179'
.param .result: Datetime (size: 40, cast: variable(val))
.param timestamp: Timestamp (size: 8, cast: variable(val))
.param calendar: Calendar (size: 4, cast: variable(u32))
.param timezone: Timezone (size: 16, cast: variable(val))
.doc: 'Convert the given `timestamp` to a datetime(year, month, day, ...) using the given `calendar` and `timezone`'
.value: {
	assert(calendar == (Calendar.(Gregorian)));
	offset: Duration := Timezone.offset(timezone, timestamp);
	timestamp := Timestamp.add(timestamp, offset.value, Duration.precision);
	n: int32 := (Datetime.DaysTil1970) + Timestamp.value(timestamp, Timeunit.(Days));
	dayOfWeek: int32 := n % 7;
	y400: int32 := n / DaysPer400Years;
	n := n - y400 * DaysPer400Years;
	y100: int32 := n / DaysPer100Years;
	if (y100 == 4) {
		y100 := 3;
	}
	n := n - y100 * DaysPer100Years;
	y4: int32 := n / DaysPer4Years;
	n := n - y4 * DaysPer4Years;
	y1: int32 := n / DaysPerYear;
	if (y1 == 4) {
		y1 := 3;
	}
	year: int32 := y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1;
	n := n - y1 * DaysPerYear;
	m: int32 := n >> 5 + 1;
	const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365;
	for ( ; n >= DaysToMonth[m]; ) {
		m := m + 1;
	}
	return .result := {
			.result.year := year;
			.result.month := Month(m - 1);
			.result.day := (n - DaysToMonth[m - 1] + 1);
			.result.hour := (Timestamp.value(timestamp, Timeunit.(Hours)) % (24));
			.result.minute := (Timestamp.value(timestamp, Timeunit.(Minutes)) % (60));
			.result.second := (Timestamp.value(timestamp, Timeunit.(Seconds)) % (60));
			.result.millis := (Timestamp.value(timestamp, Timeunit.(Millis)) % (1000));
			.result.timezone := timezone;
			.result.dayOfYear := (n + 1);
			.result.dayOfWeek := Weekday(dayOfWeek);
			.result.weekOfYear := ((n - dayOfWeek + indexOf(Weekday.(Thursday))) / 7 + 1);
			.result.leapYear := (DaysToMonth) == Datetime.DaysToMonth366;
		};
}
.instructions: (630 bytes)
	cmplStd/lib/time/Datetime.ci:180: (55 bytes): assert(calendar == (Calendar.(Gregorian)));
	<Datetime>  : load.z32
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: load.sp(+28)
	<Datetime+?>: load.iu8
	<Datetime+?>: load.z32
	<Datetime+?>: ceq.i32
	<Datetime+?>: jz +8
	<Datetime+?>: jmp +35
	<Datetime+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<Datetime+?>: load.c32 180
	<Datetime+?>: load.c32 -2
	<Datetime+?>: load.c32 128
	<Datetime+?>: load.ref <?> ;"assertion failed!"
	<Datetime+?>: dup.x64 sp(5)
	<Datetime+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<Datetime+?>: inc.sp(-8)
	cmplStd/lib/time/Datetime.ci:196: (20 bytes): offset: Duration := Timezone.offset(timezone, timestamp)
	<Datetime+?>: inc.sp(+8)
	<Datetime+?>: load.sp(+12)
	<Datetime+?>: dup.x64 sp(9)
	<Datetime+?>: load.ref <?> ;Timezone.offset(zone: Timezone, timestamp: Timestamp): Duration
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-12)
	cmplStd/lib/time/Datetime.ci:197: (24 bytes): timestamp := Timestamp.add(timestamp, offset.value, Duration.precision);
	<Datetime+?>: inc.sp(+8)
	<Datetime+?>: dup.x64 sp(10)
	<Datetime+?>: dup.x64 sp(4)
	<Datetime+?>: load.m64 <?> ;Duration.precision
	<Datetime+?>: load.ref <?> ;Timestamp.add(lhs: Timestamp, value: int64, precision: Timeunit): Timestamp
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-24)
	<Datetime+?>: set.x64 sp(10)
	cmplStd/lib/time/Datetime.ci:198: (29 bytes): n: int32 := (Datetime.DaysTil1970) + Timestamp.value(timestamp, Timeunit.(Days))
	<Datetime+?>: load.m32 <?> ;Datetime.DaysTil1970
	<Datetime+?>: i32.2i64
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(12)
	<Datetime+?>: load.c64 86400000000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: add.i64
	<Datetime+?>: i64.2i32
	cmplStd/lib/time/Datetime.ci:201: (8 bytes): dayOfWeek: int32 := n % 7
	<Datetime+?>: dup.x32 sp(0)
	<Datetime+?>: load.c32 7
	<Datetime+?>: mod.i32
	cmplStd/lib/time/Datetime.ci:204: (8 bytes): y400: int32 := n / DaysPer400Years
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: load.c32 146097
	<Datetime+?>: div.i32
	cmplStd/lib/time/Datetime.ci:206: (13 bytes): n := n - y400 * DaysPer400Years;
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: load.c32 146097
	<Datetime+?>: mul.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: set.x32 sp(3)
	cmplStd/lib/time/Datetime.ci:209: (8 bytes): y100: int32 := n / DaysPer100Years
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: load.c32 36524
	<Datetime+?>: div.i32
	cmplStd/lib/time/Datetime.ci:212: (19 bytes): if (y100 == 4)
	<Datetime+?>: dup.x32 sp(0)
	<Datetime+?>: load.c32 4
	<Datetime+?>: ceq.i32
	<Datetime+?>: jz +11
	cmplStd/lib/time/Datetime.ci:213: (7 bytes): y100 := 3;
	<Datetime+?>: load.c32 3
	<Datetime+?>: set.x32 sp(1)
	cmplStd/lib/time/Datetime.ci:216: (13 bytes): n := n - y100 * DaysPer100Years;
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: load.c32 36524
	<Datetime+?>: mul.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: set.x32 sp(4)
	cmplStd/lib/time/Datetime.ci:219: (8 bytes): y4: int32 := n / DaysPer4Years
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: load.c32 1461
	<Datetime+?>: div.i32
	cmplStd/lib/time/Datetime.ci:221: (13 bytes): n := n - y4 * DaysPer4Years;
	<Datetime+?>: dup.x32 sp(4)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: load.c32 1461
	<Datetime+?>: mul.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: set.x32 sp(5)
	cmplStd/lib/time/Datetime.ci:224: (8 bytes): y1: int32 := n / DaysPerYear
	<Datetime+?>: dup.x32 sp(4)
	<Datetime+?>: load.c32 365
	<Datetime+?>: div.i32
	cmplStd/lib/time/Datetime.ci:226: (19 bytes): if (y1 == 4)
	<Datetime+?>: dup.x32 sp(0)
	<Datetime+?>: load.c32 4
	<Datetime+?>: ceq.i32
	<Datetime+?>: jz +11
	cmplStd/lib/time/Datetime.ci:227: (7 bytes): y1 := 3;
	<Datetime+?>: load.c32 3
	<Datetime+?>: set.x32 sp(1)
	cmplStd/lib/time/Datetime.ci:231: (33 bytes): year: int32 := y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: load.c32 400
	<Datetime+?>: mul.i32
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: load.c32 100
	<Datetime+?>: mul.i32
	<Datetime+?>: add.i32
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: load.c32 4
	<Datetime+?>: mul.i32
	<Datetime+?>: add.i32
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: add.i32
	<Datetime+?>: inc.i32(+1)
	cmplStd/lib/time/Datetime.ci:234: (13 bytes): n := n - y1 * DaysPerYear;
	<Datetime+?>: dup.x32 sp(6)
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: load.c32 365
	<Datetime+?>: mul.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: set.x32 sp(7)
	cmplStd/lib/time/Datetime.ci:238: (12 bytes): m: int32 := n >> 5 + 1
	<Datetime+?>: dup.x32 sp(6)
	<Datetime+?>: load.c32 5
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: sar.b32
	cmplStd/lib/time/Datetime.ci:239: (31 bytes): const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365
	<Datetime+?>: load.z32
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: load.ref <?> ;Datetime.isLeapYear(year: int32): bool
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-4)
	<Datetime+?>: jz +13
	<Datetime+?>: load.ref <?> ;Datetime.DaysToMonth366
	<Datetime+?>: jmp +9
	<Datetime+?>: load.ref <?> ;Datetime.DaysToMonth365
	cmplStd/lib/time/Datetime.ci:242: (28 bytes): for ( ; n >= DaysToMonth[m]; )
	<Datetime+?>: jmp +12
	cmplStd/lib/time/Datetime.ci:243: (8 bytes): m := m + 1;
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: set.x32 sp(2)
	cmplStd/lib/time/Datetime.ci:242: (16 bytes): n >= DaysToMonth[m]
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: mad.u32 4
	<Datetime+?>: load.i32
	<Datetime+?>: clt.i32
	<Datetime+?>: jz -20
	cmplStd/lib/time/Datetime.ci:246: (268 bytes): return .result := {...};
	cmplStd/lib/time/Datetime.ci:248: (3 bytes): .result.year := year;
	<Datetime+?>: mov.x32 sp(19, 2)
	cmplStd/lib/time/Datetime.ci:249: (15 bytes): .result.month := Month(m - 1);
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: inc.i32(-1)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+84)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:250: (25 bytes): .result.day := (n - DaysToMonth[m - 1] + 1);
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: inc.i32(-1)
	<Datetime+?>: mad.u32 4
	<Datetime+?>: load.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+85)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:253: (38 bytes): .result.hour := (Timestamp.value(timestamp, Timeunit.(Hours)) % (24));
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(19)
	<Datetime+?>: load.c64 3600000000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: load.c64 24
	<Datetime+?>: mod.i64
	<Datetime+?>: i64.2i32
	<Datetime+?>: load.sp(+86)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:254: (38 bytes): .result.minute := (Timestamp.value(timestamp, Timeunit.(Minutes)) % (60));
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(19)
	<Datetime+?>: load.c64 60000000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: load.c64 60
	<Datetime+?>: mod.i64
	<Datetime+?>: i64.2i32
	<Datetime+?>: load.sp(+87)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:255: (38 bytes): .result.second := (Timestamp.value(timestamp, Timeunit.(Seconds)) % (60));
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(19)
	<Datetime+?>: load.c64 1000000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: load.c64 60
	<Datetime+?>: mod.i64
	<Datetime+?>: i64.2i32
	<Datetime+?>: load.sp(+88)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:256: (38 bytes): .result.millis := (Timestamp.value(timestamp, Timeunit.(Millis)) % (1000));
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(19)
	<Datetime+?>: load.c64 1000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: load.c64 1000
	<Datetime+?>: mod.i64
	<Datetime+?>: i64.2i32
	<Datetime+?>: load.sp(+90)
	<Datetime+?>: store.i16
	cmplStd/lib/time/Datetime.ci:259: (3 bytes): .result.timezone := timezone;
	<Datetime+?>: mov.x128 sp(23, 12)
	cmplStd/lib/time/Datetime.ci:262: (11 bytes): .result.dayOfYear := (n + 1);
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+114)
	<Datetime+?>: store.i16
	cmplStd/lib/time/Datetime.ci:263: (11 bytes): .result.dayOfWeek := Weekday(dayOfWeek);
	<Datetime+?>: dup.x32 sp(7)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+116)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:264: (30 bytes): .result.weekOfYear := ((n - dayOfWeek + indexOf(Weekday.(Thursday))) / 7 + 1);
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: sub.i32
	<Datetime+?>: load.c32 4
	<Datetime+?>: inc.i32(-1)
	<Datetime+?>: add.i32
	<Datetime+?>: load.c32 7
	<Datetime+?>: div.i32
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+112)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:265: (13 bytes): .result.leapYear := (DaysToMonth) == Datetime.DaysToMonth366;
	<Datetime+?>: dup.x32 sp(0)
	<Datetime+?>: load.ref <?> ;Datetime.DaysToMonth366
	<Datetime+?>: ceq.i32
	<Datetime+?>: load.sp(+117)
	<Datetime+?>: store.i8
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:270: referenced as `Datetime`
}
Datetime(timestamp: Timestamp): Datetime: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:270'
.param .result: Datetime (size: 40, cast: val)
.param timestamp: Timestamp (size: 8, cast: val)
.doc: 'Convert the given timestamp to a datetime'
.value: Datetime(timestamp, Calendar.(Gregorian), Timezone.utc())
.usages:
}
Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime: function {
.kind: static function
.base: `function`
.size: 97
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:273'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.param hour: int32 (size: 4, cast: variable(i32))
.param minute: int32 (size: 4, cast: variable(i32))
.param second: int32 (size: 4, cast: variable(i32))
.param millis: int32 (size: 4, cast: variable(i32))
.param zone: Timezone (size: 16, cast: variable(val))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := {
			.result.year := year;
			.result.month := Month(month - 1);
			.result.day := (day);
			.result.hour := (hour);
			.result.minute := (minute);
			.result.second := (second);
			.result.millis := (millis);
			.result.timezone := zone;
			.result.weekOfYear := (0);
			.result.dayOfYear := (0);
			.result.dayOfWeek := Weekday.(Monday);
			.result.leapYear := Datetime.isLeapYear(year);
		};
}
.instructions: (97 bytes)
	cmplStd/lib/time/Datetime.ci:274: (97 bytes): return .result := {...};
	cmplStd/lib/time/Datetime.ci:275: (3 bytes): .result.year := year;
	<Datetime>  : mov.x32 sp(12, 11)
	cmplStd/lib/time/Datetime.ci:276: (15 bytes): .result.month := Month(month - 1);
	<Datetime+?>: dup.x32 sp(10)
	<Datetime+?>: inc.i32(-1)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+56)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:277: (7 bytes): .result.day := (day);
	<Datetime+?>: dup.x32 sp(9)
	<Datetime+?>: load.sp(+57)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:278: (7 bytes): .result.hour := (hour);
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: load.sp(+58)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:279: (7 bytes): .result.minute := (minute);
	<Datetime+?>: dup.x32 sp(7)
	<Datetime+?>: load.sp(+59)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:280: (7 bytes): .result.second := (second);
	<Datetime+?>: dup.x32 sp(6)
	<Datetime+?>: load.sp(+60)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:281: (7 bytes): .result.millis := (millis);
	<Datetime+?>: dup.x32 sp(5)
	<Datetime+?>: load.sp(+62)
	<Datetime+?>: store.i16
	cmplStd/lib/time/Datetime.ci:282: (3 bytes): .result.timezone := zone;
	<Datetime+?>: mov.x128 sp(16, 1)
	cmplStd/lib/time/Datetime.ci:283: (6 bytes): .result.weekOfYear := (0);
	<Datetime+?>: load.z32
	<Datetime+?>: load.sp(+84)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:284: (6 bytes): .result.dayOfYear := (0);
	<Datetime+?>: load.z32
	<Datetime+?>: load.sp(+86)
	<Datetime+?>: store.i16
	cmplStd/lib/time/Datetime.ci:285: (10 bytes): .result.dayOfWeek := Weekday.(Monday);
	<Datetime+?>: load.c32 1
	<Datetime+?>: load.sp(+88)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:286: (18 bytes): .result.leapYear := Datetime.isLeapYear(year);
	<Datetime+?>: load.z32
	<Datetime+?>: dup.x32 sp(12)
	<Datetime+?>: load.ref <?> ;Datetime.isLeapYear(year: int32): bool
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-4)
	<Datetime+?>: load.sp(+89)
	<Datetime+?>: store.i8
	<Datetime+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:307: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:302: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:297: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:292: referenced as `Datetime`
}
Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32): Datetime: function {
.kind: static function
.base: `function`
.size: 55
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:291'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.param hour: int32 (size: 4, cast: variable(i32))
.param minute: int32 (size: 4, cast: variable(i32))
.param second: int32 (size: 4, cast: variable(i32))
.param millis: int32 (size: 4, cast: variable(i32))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := Datetime(year, month, day, hour, minute, second, millis, Timezone.utc());
}
.instructions: (55 bytes)
	cmplStd/lib/time/Datetime.ci:292: (55 bytes): return .result := Datetime(year, month, day, hour, minute, second, millis, Timezone.utc());
	<Datetime>  : inc.sp(+40)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: inc.sp(+16)
	<Datetime+?>: load.ref <?> ;Timezone.utc(): Timezone
	<Datetime+?>: call
	<Datetime+?>: load.ref <?> ;Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: load.sp(+72)
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: copy.mem 40
	<Datetime+?>: inc.sp(-40)
	<Datetime+?>: ret
.usages:
}
Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, zone: Timezone): Datetime: function {
.kind: static function
.base: `function`
.size: 46
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:296'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.param hour: int32 (size: 4, cast: variable(i32))
.param minute: int32 (size: 4, cast: variable(i32))
.param second: int32 (size: 4, cast: variable(i32))
.param zone: Timezone (size: 16, cast: variable(val))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := Datetime(year, month, day, hour, minute, second, 0, zone);
}
.instructions: (46 bytes)
	cmplStd/lib/time/Datetime.ci:297: (46 bytes): return .result := Datetime(year, month, day, hour, minute, second, 0, zone);
	<Datetime>  : inc.sp(+40)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: load.z32
	<Datetime+?>: dup.x128 sp(18)
	<Datetime+?>: load.ref <?> ;Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: load.sp(+84)
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: copy.mem 40
	<Datetime+?>: inc.sp(-40)
	<Datetime+?>: ret
.usages:
}
Datetime(year: int32, month: int32, day: int32, zone: Timezone): Datetime: function {
.kind: static function
.base: `function`
.size: 43
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:301'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.param zone: Timezone (size: 16, cast: variable(val))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := Datetime(year, month, day, 0, 0, 0, 0, zone);
}
.instructions: (43 bytes)
	cmplStd/lib/time/Datetime.ci:302: (43 bytes): return .result := Datetime(year, month, day, 0, 0, 0, 0, zone);
	<Datetime>  : inc.sp(+40)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: dup.x128 sp(18)
	<Datetime+?>: load.ref <?> ;Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: load.sp(+72)
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: copy.mem 40
	<Datetime+?>: inc.sp(-40)
	<Datetime+?>: ret
.usages:
}
Datetime(year: int32, month: int32, day: int32): Datetime: function {
.kind: static function
.base: `function`
.size: 51
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:306'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := Datetime(year, month, day, 0, 0, 0, 0, Timezone.utc());
}
.instructions: (51 bytes)
	cmplStd/lib/time/Datetime.ci:307: (51 bytes): return .result := Datetime(year, month, day, 0, 0, 0, 0, Timezone.utc());
	<Datetime>  : inc.sp(+40)
	<Datetime+?>: dup.x32 sp(13)
	<Datetime+?>: dup.x32 sp(13)
	<Datetime+?>: dup.x32 sp(13)
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: inc.sp(+16)
	<Datetime+?>: load.ref <?> ;Timezone.utc(): Timezone
	<Datetime+?>: call
	<Datetime+?>: load.ref <?> ;Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: load.sp(+56)
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: copy.mem 40
	<Datetime+?>: inc.sp(-40)
	<Datetime+?>: ret
.usages:
}
length(str: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 38
.name: 'length'
.file: 'cmplStd/lib/text/cstr.ci:4'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if ((str) == null) {
		return .result := 0;
	}
	result: int32 := 0;
	for ( ; str[result]; result := result + 1) ;
	return .result := result;
}
.instructions: (38 bytes)
	cmplStd/lib/text/cstr.ci:5: (16 bytes): if ((str) == null)
	<length>  : dup.x32 sp(1)
	<length+?>: load.ref <?> ;null
	<length+?>: ceq.i32
	<length+?>: jz +8
	cmplStd/lib/text/cstr.ci:6: (4 bytes): return .result := 0;
	<length+?>: load.z32
	<length+?>: set.x32 sp(3)
	<length+?>: ret
	cmplStd/lib/text/cstr.ci:8: (1 byte): result: int32 := 0
	<length+?>: load.z32
	cmplStd/lib/text/cstr.ci:9: (18 bytes): for ( ; str[result]; result := result + 1)
	<length+?>: jmp +8
	cmplStd/lib/text/cstr.ci:9: (4 bytes): result := result + 1
	<length+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:9: (10 bytes): str[result]
	<length+?>: dup.x32 sp(2)
	<length+?>: dup.x32 sp(1)
	<length+?>: add.i32
	<length+?>: load.is8
	<length+?>: jnz -10
	cmplStd/lib/text/cstr.ci:11: (3 bytes): return .result := result;
	<length+?>: set.x32 sp(3)
	<length+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:48: referenced as `length`
	cmplStd/lib/text/cstr.ci:47: referenced as `length`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.name: 'indexOf'
.file: 'cmplStd/lib/text/cstr.ci:15'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			return .result := i;
		}
	}
	return .result := -1;
}
.instructions: (50 bytes)
	cmplStd/lib/text/cstr.ci:16: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf>  : load.z32
	<indexOf+?>: jmp +27
	cmplStd/lib/text/cstr.ci:17: (19 bytes): if (str[i] == chr)
	<indexOf+?>: dup.x32 sp(3)
	<indexOf+?>: dup.x32 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.is8
	<indexOf+?>: load.sp(+12)
	<indexOf+?>: load.is8
	<indexOf+?>: ceq.i32
	<indexOf+?>: jz +7
	cmplStd/lib/text/cstr.ci:18: (3 bytes): return .result := i;
	<indexOf+?>: set.x32 sp(4)
	<indexOf+?>: ret
	cmplStd/lib/text/cstr.ci:16: (4 bytes): i := i + 1
	<indexOf+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:16: (10 bytes): str[i]
	<indexOf+?>: dup.x32 sp(3)
	<indexOf+?>: dup.x32 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.is8
	<indexOf+?>: jnz -29
	<indexOf+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:21: (8 bytes): return .result := -1;
	<indexOf+?>: load.c32 -1
	<indexOf+?>: set.x32 sp(4)
	<indexOf+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:105: referenced as `indexOf`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.name: 'lastIndexOf'
.file: 'cmplStd/lib/text/cstr.ci:25'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := -1;
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			result := i;
		}
	}
	return .result := result;
}
.instructions: (50 bytes)
	cmplStd/lib/text/cstr.ci:26: (5 bytes): result: int32 := -1
	<lastIndexOf>  : load.c32 -1
	cmplStd/lib/text/cstr.ci:27: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+?>: load.z32
	<lastIndexOf+?>: jmp +27
	cmplStd/lib/text/cstr.ci:28: (19 bytes): if (str[i] == chr)
	<lastIndexOf+?>: dup.x32 sp(4)
	<lastIndexOf+?>: dup.x32 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.is8
	<lastIndexOf+?>: load.sp(+16)
	<lastIndexOf+?>: load.is8
	<lastIndexOf+?>: ceq.i32
	<lastIndexOf+?>: jz +7
	cmplStd/lib/text/cstr.ci:29: (3 bytes): result := i;
	<lastIndexOf+?>: mov.x32 sp(1, 0)
	cmplStd/lib/text/cstr.ci:27: (4 bytes): i := i + 1
	<lastIndexOf+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:27: (10 bytes): str[i]
	<lastIndexOf+?>: dup.x32 sp(4)
	<lastIndexOf+?>: dup.x32 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.is8
	<lastIndexOf+?>: jnz -29
	<lastIndexOf+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:32: (3 bytes): return .result := result;
	<lastIndexOf+?>: set.x32 sp(4)
	<lastIndexOf+?>: ret
.usages:
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 73
.name: 'startsWith'
.file: 'cmplStd/lib/text/cstr.ci:36'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: const variable(ref))
.param with: char[*] (size: 4, cast: const variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
		if (cmp(str[i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (73 bytes)
	cmplStd/lib/text/cstr.ci:37: (62 bytes): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith>  : load.z32
	<startsWith+?>: jmp +45
	cmplStd/lib/text/cstr.ci:38: (37 bytes): if (cmp(str[i], with[i]) != 0)
	<startsWith+?>: load.z32
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: dup.x32 sp(2)
	<startsWith+?>: add.i32
	<startsWith+?>: load.is8
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: dup.x32 sp(3)
	<startsWith+?>: add.i32
	<startsWith+?>: load.is8
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: call
	<startsWith+?>: inc.sp(-8)
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jnz +15
	cmplStd/lib/text/cstr.ci:39: (11 bytes): return .result := false;
	<startsWith+?>: load.z32
	<startsWith+?>: load.sp(+24)
	<startsWith+?>: store.i8
	<startsWith+?>: inc.sp(-4)
	<startsWith+?>: ret
	cmplStd/lib/text/cstr.ci:37: (4 bytes): i := i + 1
	<startsWith+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:37: (12 bytes): (with[i]) != 0
	<startsWith+?>: dup.x32 sp(3)
	<startsWith+?>: dup.x32 sp(1)
	<startsWith+?>: add.i32
	<startsWith+?>: load.is8
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jz -49
	<startsWith+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:42: (11 bytes): return .result := true;
	<startsWith+?>: load.c32 1
	<startsWith+?>: load.sp(+20)
	<startsWith+?>: store.i8
	<startsWith+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:96: referenced as `startsWith`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 126
.name: 'endsWith'
.file: 'cmplStd/lib/text/cstr.ci:46'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: const variable(ref))
.param with: char[*] (size: 4, cast: const variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (strLen < withLen) {
		return .result := false;
	}
	for (i: int32 := 0; i < withLen; i := i + 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (126 bytes)
	cmplStd/lib/text/cstr.ci:47: (13 bytes): withLen: int32 := length(with)
	<endsWith>  : load.z32
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:48: (13 bytes): strLen: int32 := length(str)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x32 sp(5)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:49: (20 bytes): if (strLen < withLen)
	<endsWith+?>: dup.x32 sp(0)
	<endsWith+?>: dup.x32 sp(2)
	<endsWith+?>: clt.i32
	<endsWith+?>: jz +15
	cmplStd/lib/text/cstr.ci:50: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
	cmplStd/lib/text/cstr.ci:52: (65 bytes): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+?>: load.z32
	<endsWith+?>: jmp +51
	cmplStd/lib/text/cstr.ci:53: (43 bytes): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: dup.x32 sp(5)
	<endsWith+?>: sub.i32
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: add.i32
	<endsWith+?>: load.is8
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: load.is8
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: load.z32
	<endsWith+?>: ceq.i32
	<endsWith+?>: jnz +15
	cmplStd/lib/text/cstr.ci:54: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+32)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-12)
	<endsWith+?>: ret
	cmplStd/lib/text/cstr.ci:52: (4 bytes): i := i + 1
	<endsWith+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:52: (9 bytes): i < withLen
	<endsWith+?>: dup.x32 sp(0)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: clt.i32
	<endsWith+?>: jnz -52
	<endsWith+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:57: (15 bytes): return .result := true;
	<endsWith+?>: load.c32 1
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
.usages:
	cmplGfx/lib/mesh.ci:6: referenced as `endsWith`
	cmplGfx/lib/mesh.ci:3: referenced as `endsWith`
	cmplGfx/lib/image.ci:20: referenced as `endsWith`
	cmplGfx/lib/image.ci:15: referenced as `endsWith`
	cmplGfx/lib/image.ci:12: referenced as `endsWith`
	cmplGfx/lib/image.ci:7: referenced as `endsWith`
	cmplStd/lib/text/cstr.ci:98: referenced as `endsWith`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.name: 'compare'
.file: 'cmplStd/lib/text/cstr.ci:61'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.param with: char[*] (size: 4, cast: const variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if the two strings are equal, less or greater, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; result == 0; i := i + 1) {
		result := cmp(str[i], with[i]);
		if ((str[i]) == 0) {
			break;
		}
	}
	return .result := result;
}
.instructions: (63 bytes)
	cmplStd/lib/text/cstr.ci:62: (1 byte): result: int32 := 0
	<compare>  : load.z32
	cmplStd/lib/text/cstr.ci:63: (59 bytes): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+?>: load.z32
	<compare+?>: jmp +46
	cmplStd/lib/text/cstr.ci:64: (22 bytes): result := cmp(str[i], with[i]);
	<compare+?>: load.z32
	<compare+?>: dup.x32 sp(6)
	<compare+?>: dup.x32 sp(2)
	<compare+?>: add.i32
	<compare+?>: load.is8
	<compare+?>: dup.x32 sp(6)
	<compare+?>: dup.x32 sp(3)
	<compare+?>: add.i32
	<compare+?>: load.is8
	<compare+?>: dup.x32 sp(6)
	<compare+?>: call
	<compare+?>: inc.sp(-8)
	<compare+?>: set.x32 sp(2)
	cmplStd/lib/text/cstr.ci:65: (16 bytes): if ((str[i]) == 0)
	<compare+?>: dup.x32 sp(5)
	<compare+?>: dup.x32 sp(1)
	<compare+?>: add.i32
	<compare+?>: load.is8
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jz +8
	cmplStd/lib/text/cstr.ci:66: (4 bytes): break;
	<compare+?>: jmp +16
	cmplStd/lib/text/cstr.ci:63: (4 bytes): i := i + 1
	<compare+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:63: (8 bytes): result == 0
	<compare+?>: dup.x32 sp(1)
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jnz -46
	<compare+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:69: (3 bytes): return .result := result;
	<compare+?>: set.x32 sp(5)
	<compare+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:102: referenced as `compare`
	cmplStd/lib/text/cstr.ci:100: referenced as `compare`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 36
.name: 'ignCaseCmp'
.file: 'cmplStd/lib/text/cstr.ci:73'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static ignCase(chr: char): char := {
		if (chr < 'A') {
			return .result := chr;
		}
		if (chr > 'Z') {
			return .result := chr;
		}
		return .result := chr - 'A' + 'a';
	};
	return .result := ignCase(chr) - ignCase(with);
}
.instructions: (36 bytes)
	cmplStd/lib/text/cstr.ci:84: (36 bytes): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp>  : load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.is8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.is8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: sub.i32
	<ignCaseCmp+?>: set.x32 sp(4)
	<ignCaseCmp+?>: ret
.usages:
	cmplGfx/lib/mesh.ci:6: referenced as `ignCaseCmp`
	cmplGfx/lib/mesh.ci:3: referenced as `ignCaseCmp`
	cmplGfx/lib/image.ci:20: referenced as `ignCaseCmp`
	cmplGfx/lib/image.ci:15: referenced as `ignCaseCmp`
	cmplGfx/lib/image.ci:12: referenced as `ignCaseCmp`
	cmplGfx/lib/image.ci:7: referenced as `ignCaseCmp`
}
caseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 14
.name: 'caseCmp'
.file: 'cmplStd/lib/text/cstr.ci:88'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return .result := chr - with;
}
.instructions: (14 bytes)
	cmplStd/lib/text/cstr.ci:89: (14 bytes): return .result := chr - with;
	<caseCmp>  : load.sp(+8)
	<caseCmp+?>: load.is8
	<caseCmp+?>: load.sp(+8)
	<caseCmp+?>: load.is8
	<caseCmp+?>: sub.i32
	<caseCmp+?>: set.x32 sp(4)
	<caseCmp+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:102: referenced as `caseCmp`
	cmplStd/lib/text/cstr.ci:100: referenced as `caseCmp`
	cmplStd/lib/text/cstr.ci:98: referenced as `caseCmp`
	cmplStd/lib/text/cstr.ci:96: referenced as `caseCmp`
}
toHex(value: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toHex'
.file: 'cmplStd/lib/text/cstr.ci:93'
.param .result: int32 (size: 4, cast: i32)
.param value: int32 (size: 4, cast: i32)
.doc: 'convert lower part (4 bits) of the input value to the corresponding lower case hexadecimal character'
.value: int32("0123456789abcdef"[value & 15])
.usages:
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'startsWith'
.file: 'cmplStd/lib/text/cstr.ci:96'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if a string begins with a specified string, using case-sensitive comparison'
.value: startsWith(str, with, caseCmp)
.usages:
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'endsWith'
.file: 'cmplStd/lib/text/cstr.ci:98'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if a string ends in a specified string, using case-sensitive comparison'
.value: endsWith(str, with, caseCmp)
.usages:
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'compare'
.file: 'cmplStd/lib/text/cstr.ci:100'
.param .result: int32 (size: 4, cast: i32)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if the two strings are equal, less or greater, using case-sensitive comparison'
.value: compare(str, with, caseCmp)
.usages:
}
equals(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'equals'
.file: 'cmplStd/lib/text/cstr.ci:102'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if the two strings are equal, using case-sensitive comparison'
.value: compare(str, with, caseCmp) == 0
.usages:
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'contains'
.file: 'cmplStd/lib/text/cstr.ci:105'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param chr: char (size: 4, cast: i32)
.doc: 'Check if a string contains the given character'
.value: indexOf(str, chr) >= 0
.usages:
	cmplStd/lib/text/Format.ci:135: referenced as `contains`
}
float64(value: char[]): float64: function {
.kind: static function
.base: `function`
.size: 423
.name: 'float64'
.file: 'cmplStd/lib/text/cstr.ci:117'
.param .result: float64 (size: 8, cast: variable(f64))
.param value: char[] (size: 8, cast: const variable(arr))
.doc: 'Convert a string to a 64 bit floating point value'
.value: {
	result: float64 := 0;
	static if ((preferNativeCalls) && (typename(float64.parse)) != null) {
		len: int32 := float64.parse(value, &result);
		if (len > 0 && len < (value.length) && (value[len]) == 0) {
			return .result := result;
		}
		return .result := Math.nan;
	}
	sign: float64 := 1;
	decimal: float64 := 0;
	for (i: int32 := 0; i < (value.length) && (value[i]) != 0; i := i + 1) {
		chr: char := value[i];
		if (chr >= '0' && chr <= '9') {
			result := result * (10) + ((chr - '0'));
			decimal := decimal * (10);
		}
		else if (chr == '.') {
			if (decimal != (0)) {
				return .result := Math.nan;
			}
			decimal := (1);
		}
		else if (chr == '-' && i == 0) {
			sign := (-1);
		}
		else if (chr == '+' && i == 0) {
			sign := (1);
		}
		else {
			return .result := Math.nan;
		}
	}
	if (decimal == (0)) {
		if (value.length > (0)) {
			return .result := sign * result;
		}
	}
	return .result := sign * result / decimal;
}
.instructions: (423 bytes)
	cmplStd/lib/text/cstr.ci:118: (1 byte): result: float64 := 0
	<float64>  : load.z64
	cmplStd/lib/text/cstr.ci:121: (10 bytes): len: int32 := float64.parse(value, &result)
	<float64+?>: dup.x64 sp(3)
	<float64+?>: load.sp(+8)
	<float64+?>: nfc(52) ;float64.parse(value: char[], out: float64): int32
	cmplStd/lib/text/cstr.ci:122: (49 bytes): if (len > 0 && len < (value.length) && (value[len]) == 0)
	<float64+?>: dup.x32 sp(0)
	<float64+?>: load.z32
	<float64+?>: cgt.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +13
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(0)
	<float64+?>: dup.x32 sp(6)
	<float64+?>: clt.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +16
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(4)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: add.i32
	<float64+?>: load.is8
	<float64+?>: load.z32
	<float64+?>: ceq.i32
	<float64+?>: jz +12
	cmplStd/lib/text/cstr.ci:123: (8 bytes): return .result := result;
	<float64+?>: mov.x64 sp(6, 1)
	<float64+?>: inc.sp(-12)
	<float64+?>: ret
	cmplStd/lib/text/cstr.ci:126: (16 bytes): return .result := Math.nan;
	<float64+?>: load.f64 -nan
	<float64+?>: set.x64 sp(8)
	<float64+?>: inc.sp(-12)
	<float64+?>: ret
	<float64+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:129: (9 bytes): sign: float64 := 1
	<float64+?>: load.f64 1.000000
	cmplStd/lib/text/cstr.ci:130: (1 byte): decimal: float64 := 0
	<float64+?>: load.z128
	cmplStd/lib/text/cstr.ci:132: (290 bytes): for (i: int32 := 0; i < (value.length) && (value[i]) != 0; i := i + 1)
	<float64+?>: i64.2i32
	<float64+?>: jmp +257
	cmplStd/lib/text/cstr.ci:133: (6 bytes): chr: char := value[i]
	<float64+?>: dup.x32 sp(8)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: add.i32
	<float64+?>: load.is8
	cmplStd/lib/text/cstr.ci:134: (239 bytes): if (chr >= '0' && chr <= '9')
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 48
	<float64+?>: clt.i32
	<float64+?>: not.b32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +20
	<float64+?>: inc.sp(-4)
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 57
	<float64+?>: cgt.i32
	<float64+?>: not.b32
	<float64+?>: jz +47
	cmplStd/lib/text/cstr.ci:135: (25 bytes): result := result * (10) + ((chr - '0'));
	<float64+?>: dup.x64 sp(6)
	<float64+?>: load.f64 10.000000
	<float64+?>: mul.f64
	<float64+?>: load.sp(+8)
	<float64+?>: load.is8
	<float64+?>: inc.i32(-48)
	<float64+?>: i32.2f64
	<float64+?>: add.f64
	<float64+?>: set.x64 sp(8)
	cmplStd/lib/text/cstr.ci:136: (14 bytes): decimal := decimal * (10);
	<float64+?>: dup.x64 sp(2)
	<float64+?>: load.f64 10.000000
	<float64+?>: mul.f64
	<float64+?>: set.x64 sp(4)
	<float64+?>: jmp +162
	cmplStd/lib/text/cstr.ci:138: (158 bytes): if (chr == '.')
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 46
	<float64+?>: ceq.i32
	<float64+?>: jz +43
	cmplStd/lib/text/cstr.ci:139: (24 bytes): if (decimal != (0))
	<float64+?>: dup.x64 sp(2)
	<float64+?>: load.z64
	<float64+?>: ceq.f64
	<float64+?>: jnz +20
	cmplStd/lib/text/cstr.ci:141: (16 bytes): return .result := Math.nan;
	<float64+?>: load.f64 -nan
	<float64+?>: set.x64 sp(13)
	<float64+?>: inc.sp(-32)
	<float64+?>: ret
	cmplStd/lib/text/cstr.ci:143: (11 bytes): decimal := (1);
	<float64+?>: load.f64 1.000000
	<float64+?>: set.x64 sp(4)
	<float64+?>: jmp +108
	cmplStd/lib/text/cstr.ci:145: (104 bytes): if (chr == '-' && i == 0)
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 45
	<float64+?>: ceq.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +12
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: load.z32
	<float64+?>: ceq.i32
	<float64+?>: jz +19
	cmplStd/lib/text/cstr.ci:146: (11 bytes): sign := (-1);
	<float64+?>: load.f64 -1.000000
	<float64+?>: set.x64 sp(6)
	<float64+?>: jmp +64
	cmplStd/lib/text/cstr.ci:148: (60 bytes): if (chr == '+' && i == 0)
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 43
	<float64+?>: ceq.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +12
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: load.z32
	<float64+?>: ceq.i32
	<float64+?>: jz +19
	cmplStd/lib/text/cstr.ci:149: (11 bytes): sign := (1);
	<float64+?>: load.f64 1.000000
	<float64+?>: set.x64 sp(6)
	<float64+?>: jmp +20
	cmplStd/lib/text/cstr.ci:153: (16 bytes): return .result := Math.nan;
	<float64+?>: load.f64 -nan
	<float64+?>: set.x64 sp(13)
	<float64+?>: inc.sp(-32)
	<float64+?>: ret
	<float64+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:132: (4 bytes): i := i + 1
	<float64+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:132: (28 bytes): i < (value.length) && (value[i]) != 0
	<float64+?>: dup.x32 sp(0)
	<float64+?>: dup.x32 sp(10)
	<float64+?>: clt.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +17
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(8)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: add.i32
	<float64+?>: load.is8
	<float64+?>: load.z32
	<float64+?>: ceq.i32
	<float64+?>: not.b32
	<float64+?>: jnz -277
	<float64+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:157: (28 bytes): if (decimal == (0))
	<float64+?>: dup.x64 sp(0)
	<float64+?>: load.z64
	<float64+?>: ceq.f64
	<float64+?>: jz +24
	cmplStd/lib/text/cstr.ci:158: (20 bytes): if (value.length > (0))
	<float64+?>: dup.x32 sp(8)
	<float64+?>: load.z32
	<float64+?>: cgt.u32
	<float64+?>: jz +16
	cmplStd/lib/text/cstr.ci:159: (12 bytes): return .result := sign * result;
	<float64+?>: dup.x64 sp(2)
	<float64+?>: dup.x64 sp(6)
	<float64+?>: mul.f64
	<float64+?>: set.x64 sp(11)
	<float64+?>: inc.sp(-24)
	<float64+?>: ret
	cmplStd/lib/text/cstr.ci:162: (15 bytes): return .result := sign * result / decimal;
	<float64+?>: dup.x64 sp(2)
	<float64+?>: dup.x64 sp(6)
	<float64+?>: mul.f64
	<float64+?>: dup.x64 sp(2)
	<float64+?>: div.f64
	<float64+?>: set.x64 sp(11)
	<float64+?>: inc.sp(-24)
	<float64+?>: ret
.usages:
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'FormatFlags'
.file: 'cmplStd/lib/text/Format.ci:2'
.field sign: char (size: 1, cast: const variable(i32))
.field padChr: char (size: 1, cast: const variable(i32))
.field width: int32 (size: 4, cast: const variable(i32))
.field precision: int32 (size: 4, cast: const variable(i32))
.field trimDecimal: bool (size: 1, cast: const variable(bool))
.field read: function (size: 420, cast: static function)
.field defPad: function (size: 60, cast: static function)
.doc: 'Flags to convert numbers to string'
.usages:
	cmplGfx/lib/micro.ui.core.ci:36: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:133: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:126: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:119: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:112: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:105: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:98: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:59: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:564: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:334: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:334: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:279: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:276: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:273: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:270: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:267: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:264: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:261: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:258: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:255: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:185: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:184: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:172: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:170: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:107: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:73: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:73: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:19: referenced as `FormatFlags`
}
FormatFlags.sign: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'sign'
.file: 'cmplStd/lib/text/Format.ci:4'
.owner: FormatFlags
.doc: 'forced show sign '+' or '-''
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:186: referenced as `sign`
	cmplStd/lib/text/Format.ci:186: referenced as `sign`
	cmplStd/lib/text/Format.ci:173: referenced as `sign`
	cmplStd/lib/text/Format.ci:144: referenced as `sign`
	cmplStd/lib/text/Format.ci:133: referenced as `sign`
	cmplStd/lib/text/Format.ci:76: referenced as `sign`
	cmplStd/lib/text/Format.ci:76: referenced as `sign`
	cmplStd/lib/text/Format.ci:65: referenced as `sign`
	internal usages: 5
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'padChr'
.file: 'cmplStd/lib/text/Format.ci:7'
.owner: FormatFlags
.doc: 'padding character: usually '0' or space'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:187: referenced as `padChr`
	cmplStd/lib/text/Format.ci:187: referenced as `padChr`
	cmplStd/lib/text/Format.ci:174: referenced as `padChr`
	cmplStd/lib/text/Format.ci:174: referenced as `padChr`
	cmplStd/lib/text/Format.ci:127: referenced as `padChr`
	cmplStd/lib/text/Format.ci:78: referenced as `padChr`
	cmplStd/lib/text/Format.ci:67: referenced as `padChr`
	internal usages: 5
}
FormatFlags.width: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'width'
.file: 'cmplStd/lib/text/Format.ci:10'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:191: referenced as `width`
	cmplStd/lib/text/Format.ci:188: referenced as `width`
	cmplStd/lib/text/Format.ci:188: referenced as `width`
	cmplStd/lib/text/Format.ci:175: referenced as `width`
	cmplStd/lib/text/Format.ci:175: referenced as `width`
	cmplStd/lib/text/Format.ci:125: referenced as `width`
	cmplStd/lib/text/Format.ci:79: referenced as `width`
	cmplStd/lib/text/Format.ci:74: referenced as `width`
	cmplStd/lib/text/Format.ci:66: referenced as `width`
	internal usages: 5
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'precision'
.file: 'cmplStd/lib/text/Format.ci:13'
.owner: FormatFlags
.doc: 'precision length'
.value: 10
.usages:
	cmplGfx/lib/micro.ui.ci:1003: referenced as `precision`
	cmplGfx/lib/micro.ui.ci:995: referenced as `precision`
	cmplStd/lib/text/Format.ci:218: referenced as `precision`
	cmplStd/lib/text/Format.ci:205: referenced as `precision`
	cmplStd/lib/text/Format.ci:188: referenced as `precision`
	cmplStd/lib/text/Format.ci:176: referenced as `precision`
	cmplStd/lib/text/Format.ci:176: referenced as `precision`
	cmplStd/lib/text/Format.ci:77: referenced as `precision`
	cmplStd/lib/text/Format.ci:77: referenced as `precision`
	cmplStd/lib/text/Format.ci:68: referenced as `precision`
	internal usages: 4
}
FormatFlags.trimDecimal: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'trimDecimal'
.file: 'cmplStd/lib/text/Format.ci:16'
.owner: FormatFlags
.doc: 'trim extra `0` decimal digits'
.value: true
.usages:
	cmplGfx/lib/micro.ui.ci:1003: referenced as `trimDecimal`
	cmplGfx/lib/micro.ui.ci:995: referenced as `trimDecimal`
	cmplStd/lib/text/Format.ci:233: referenced as `trimDecimal`
	internal usages: 7
}
FormatFlags.read(format: char[], pos: int32): FormatFlags: function {
.kind: static function
.base: `function`
.size: 420
.name: 'read'
.file: 'cmplStd/lib/text/Format.ci:19'
.owner: FormatFlags
.param .result: FormatFlags (size: 16, cast: variable(val))
.param format: char[] (size: 8, cast: const variable(arr))
.param pos: int32 (size: 4, cast: variable(ref))
.doc: 'read and process c style format flags like: "%02d"'
.value: {
	chr: int32 := format[pos];
	if (chr != ('%')) {
		return .result := {
			.result.trimDecimal := true;
			.result.precision := 10;
			.result.width := 0;
			.result.padChr := (0);
			.result.sign := (0);
		};
	}
	pos := pos + 1;
	chr := (format[pos]);
	if (chr == ('%')) {
		return .result := {
			.result.trimDecimal := true;
			.result.precision := 10;
			.result.width := 0;
			.result.padChr := (0);
			.result.sign := (0);
		};
	}
	sgnChr: int32 := 0;
	if (chr == ('-') || chr == ('+')) {
		pos := pos + 1;
		sgnChr := chr;
		chr := (format[pos]);
	}
	padChr: int32 := ' ';
	if (chr == ('0')) {
		pos := pos + 1;
		padChr := chr;
		chr := (format[pos]);
	}
	padLen: int32 := 0;
	for ( ; chr >= ('0') && chr <= ('9'); ) {
		pos := pos + 1;
		padLen := padLen * 10 + chr - ('0');
		chr := (format[pos]);
	}
	precision: int32 := 0;
	if (chr == ('.')) {
		pos := pos + 1;
		chr := (format[pos]);
		for ( ; chr >= ('0') && chr <= ('9'); ) {
			pos := pos + 1;
			precision := precision * 10 + chr - ('0');
			chr := (format[pos]);
		}
	}
	return .result := {
			.result.sign := (sgnChr);
			.result.width := padLen;
			.result.padChr := (padChr);
			.result.precision := precision;
			.result.trimDecimal := true;
		};
}
.instructions: (420 bytes)
	cmplStd/lib/text/Format.ci:20: (7 bytes): chr: int32 := format[pos]
	<read>  : dup.x32 sp(2)
	<read+?>: dup.x32 sp(2)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	cmplStd/lib/text/Format.ci:21: (49 bytes): if (chr != ('%'))
	<read+?>: dup.x32 sp(0)
	<read+?>: load.c32 37
	<read+?>: ceq.i32
	<read+?>: jnz +41
	cmplStd/lib/text/Format.ci:22: (37 bytes): return .result := {...};
	:: (10 bytes): .result.trimDecimal := true;
	<read+?>: load.c32 1
	<read+?>: load.sp(+36)
	<read+?>: store.i8
	:: (7 bytes): .result.precision := 10;
	<read+?>: load.c32 10
	<read+?>: set.x32 sp(8)
	:: (3 bytes): .result.width := 0;
	<read+?>: load.z32
	<read+?>: set.x32 sp(7)
	:: (6 bytes): .result.padChr := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+25)
	<read+?>: store.i8
	:: (6 bytes): .result.sign := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+24)
	<read+?>: store.i8
	<read+?>: inc.sp(-4)
	<read+?>: ret
	cmplStd/lib/text/Format.ci:25: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(2)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(3)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:26: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(3)
	<read+?>: dup.x32 sp(3)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(1)
	cmplStd/lib/text/Format.ci:28: (49 bytes): if (chr == ('%'))
	<read+?>: dup.x32 sp(0)
	<read+?>: load.c32 37
	<read+?>: ceq.i32
	<read+?>: jz +41
	cmplStd/lib/text/Format.ci:29: (37 bytes): return .result := {...};
	:: (10 bytes): .result.trimDecimal := true;
	<read+?>: load.c32 1
	<read+?>: load.sp(+36)
	<read+?>: store.i8
	:: (7 bytes): .result.precision := 10;
	<read+?>: load.c32 10
	<read+?>: set.x32 sp(8)
	:: (3 bytes): .result.width := 0;
	<read+?>: load.z32
	<read+?>: set.x32 sp(7)
	:: (6 bytes): .result.padChr := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+25)
	<read+?>: store.i8
	:: (6 bytes): .result.sign := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+24)
	<read+?>: store.i8
	<read+?>: inc.sp(-4)
	<read+?>: ret
	cmplStd/lib/text/Format.ci:32: (1 byte): sgnChr: int32 := 0
	<read+?>: load.z32
	cmplStd/lib/text/Format.ci:33: (52 bytes): if (chr == ('-') || chr == ('+'))
	<read+?>: dup.x32 sp(1)
	<read+?>: load.c32 45
	<read+?>: ceq.i32
	<read+?>: dup.x32 sp(0)
	<read+?>: jnz +16
	<read+?>: inc.sp(-4)
	<read+?>: dup.x32 sp(1)
	<read+?>: load.c32 43
	<read+?>: ceq.i32
	<read+?>: jz +26
	cmplStd/lib/text/Format.ci:34: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(3)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(4)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:35: (3 bytes): sgnChr := chr;
	<read+?>: mov.x32 sp(0, 1)
	cmplStd/lib/text/Format.ci:36: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(4)
	<read+?>: dup.x32 sp(4)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:39: (5 bytes): padChr: int32 := ' '
	<read+?>: load.c32 32
	cmplStd/lib/text/Format.ci:40: (34 bytes): if (chr == ('0'))
	<read+?>: dup.x32 sp(2)
	<read+?>: load.c32 48
	<read+?>: ceq.i32
	<read+?>: jz +26
	cmplStd/lib/text/Format.ci:41: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(4)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(5)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:42: (3 bytes): padChr := chr;
	<read+?>: mov.x32 sp(0, 2)
	cmplStd/lib/text/Format.ci:43: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(5)
	<read+?>: dup.x32 sp(5)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(3)
	cmplStd/lib/text/Format.ci:46: (1 byte): padLen: int32 := 0
	<read+?>: load.z32
	cmplStd/lib/text/Format.ci:47: (68 bytes): for ( ; chr >= ('0') && chr <= ('9'); )
	<read+?>: jmp +36
	cmplStd/lib/text/Format.ci:48: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(5)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(6)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:49: (13 bytes): padLen := padLen * 10 + chr - ('0');
	<read+?>: load.c32 10
	<read+?>: mul.i32
	<read+?>: dup.x32 sp(3)
	<read+?>: add.i32
	<read+?>: inc.i32(-48)
	cmplStd/lib/text/Format.ci:50: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(6)
	<read+?>: dup.x32 sp(6)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(4)
	cmplStd/lib/text/Format.ci:47: (32 bytes): chr >= ('0') && chr <= ('9')
	<read+?>: dup.x32 sp(3)
	<read+?>: load.c32 48
	<read+?>: clt.i32
	<read+?>: not.b32
	<read+?>: dup.x32 sp(0)
	<read+?>: jz +17
	<read+?>: inc.sp(-4)
	<read+?>: dup.x32 sp(3)
	<read+?>: load.c32 57
	<read+?>: cgt.i32
	<read+?>: not.b32
	<read+?>: jnz -60
	cmplStd/lib/text/Format.ci:53: (1 byte): precision: int32 := 0
	<read+?>: load.z32
	cmplStd/lib/text/Format.ci:54: (99 bytes): if (chr == ('.'))
	<read+?>: dup.x32 sp(4)
	<read+?>: load.c32 46
	<read+?>: ceq.i32
	<read+?>: jz +91
	cmplStd/lib/text/Format.ci:55: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(6)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(7)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:56: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(7)
	<read+?>: dup.x32 sp(7)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:57: (68 bytes): for ( ; chr >= ('0') && chr <= ('9'); )
	<read+?>: jmp +36
	cmplStd/lib/text/Format.ci:58: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(6)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(7)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:59: (13 bytes): precision := precision * 10 + chr - ('0');
	<read+?>: load.c32 10
	<read+?>: mul.i32
	<read+?>: dup.x32 sp(4)
	<read+?>: add.i32
	<read+?>: inc.i32(-48)
	cmplStd/lib/text/Format.ci:60: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(7)
	<read+?>: dup.x32 sp(7)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:57: (32 bytes): chr >= ('0') && chr <= ('9')
	<read+?>: dup.x32 sp(4)
	<read+?>: load.c32 48
	<read+?>: clt.i32
	<read+?>: not.b32
	<read+?>: dup.x32 sp(0)
	<read+?>: jz +17
	<read+?>: inc.sp(-4)
	<read+?>: dup.x32 sp(4)
	<read+?>: load.c32 57
	<read+?>: cgt.i32
	<read+?>: not.b32
	<read+?>: jnz -60
	cmplStd/lib/text/Format.ci:64: (35 bytes): return .result := {...};
	cmplStd/lib/text/Format.ci:65: (7 bytes): .result.sign := (sgnChr);
	<read+?>: dup.x32 sp(3)
	<read+?>: load.sp(+40)
	<read+?>: store.i8
	cmplStd/lib/text/Format.ci:66: (3 bytes): .result.width := padLen;
	<read+?>: mov.x32 sp(10, 1)
	cmplStd/lib/text/Format.ci:67: (7 bytes): .result.padChr := (padChr);
	<read+?>: dup.x32 sp(2)
	<read+?>: load.sp(+41)
	<read+?>: store.i8
	cmplStd/lib/text/Format.ci:68: (3 bytes): .result.precision := precision;
	<read+?>: mov.x32 sp(11, 0)
	:: (10 bytes): .result.trimDecimal := true;
	<read+?>: load.c32 1
	<read+?>: load.sp(+52)
	<read+?>: store.i8
	<read+?>: inc.sp(-20)
	<read+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:334: referenced as `read`
}
FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags: function {
.kind: static function
.base: `function`
.size: 60
.name: 'defPad'
.file: 'cmplStd/lib/text/Format.ci:73'
.owner: FormatFlags
.param .result: FormatFlags (size: 16, cast: variable(val))
.param this: FormatFlags (size: 4, cast: const variable(ref))
.param width: int32 (size: 4, cast: variable(i32))
.param padChr: char (size: 4, cast: variable(i32))
.doc: 'override the default padding, in case it's length is zero'
.value: {
	if (this.width == 0) {
		return .result := {
			.result.sign := this.sign;
			.result.precision := this.precision;
			.result.padChr := padChr;
			.result.width := width;
			.result.trimDecimal := true;
		};
	}
	return .result := this;
}
.instructions: (60 bytes)
	cmplStd/lib/text/Format.ci:74: (54 bytes): if (this.width == 0)
	<defPad>  : dup.x32 sp(3)
	<defPad+?>: inc.i32(+4)
	<defPad+?>: load.i32
	<defPad+?>: load.z32
	<defPad+?>: ceq.i32
	<defPad+?>: jz +45
	cmplStd/lib/text/Format.ci:75: (41 bytes): return .result := {...};
	cmplStd/lib/text/Format.ci:76: (8 bytes): .result.sign := this.sign;
	<defPad+?>: dup.x32 sp(3)
	<defPad+?>: load.is8
	<defPad+?>: load.sp(+20)
	<defPad+?>: store.i8
	cmplStd/lib/text/Format.ci:77: (9 bytes): .result.precision := this.precision;
	<defPad+?>: dup.x32 sp(3)
	<defPad+?>: inc.i32(+8)
	<defPad+?>: load.i32
	<defPad+?>: set.x32 sp(7)
	cmplStd/lib/text/Format.ci:78: (10 bytes): .result.padChr := padChr;
	<defPad+?>: load.sp(+4)
	<defPad+?>: load.is8
	<defPad+?>: load.sp(+21)
	<defPad+?>: store.i8
	cmplStd/lib/text/Format.ci:79: (3 bytes): .result.width := width;
	<defPad+?>: mov.x32 sp(5, 2)
	:: (10 bytes): .result.trimDecimal := true;
	<defPad+?>: load.c32 1
	<defPad+?>: load.sp(+32)
	<defPad+?>: store.i8
	<defPad+?>: ret
	cmplStd/lib/text/Format.ci:82: (6 bytes): return .result := this;
	<defPad+?>: dup.x32 sp(3)
	<defPad+?>: load.i128
	<defPad+?>: set.x128 sp(8)
	<defPad+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:471: referenced as `defPad`
	cmplStd/lib/text/Format.ci:459: referenced as `defPad`
	cmplStd/lib/text/Format.ci:440: referenced as `defPad`
	cmplStd/lib/text/Format.ci:418: referenced as `defPad`
	cmplStd/lib/text/Format.ci:409: referenced as `defPad`
	cmplStd/lib/text/Format.ci:405: referenced as `defPad`
	cmplStd/lib/text/Format.ci:401: referenced as `defPad`
	cmplStd/lib/text/Format.ci:397: referenced as `defPad`
	cmplStd/lib/text/Format.ci:393: referenced as `defPad`
	cmplStd/lib/text/Format.ci:389: referenced as `defPad`
	cmplStd/lib/text/Format.ci:385: referenced as `defPad`
	cmplStd/lib/text/Format.ci:371: referenced as `defPad`
	cmplStd/lib/text/Format.ci:363: referenced as `defPad`
	cmplStd/lib/text/Format.ci:359: referenced as `defPad`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 119
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:87'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: char[*] (size: 4, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	if ((value) == null) {
		return .result := append(output, pos, "NULL");
	}
	for (i: int32 := 0; value[i]; i := i + 1) {
		if (pos >= (output.length)) {
			break;
		}
		output[pos] := value[i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (119 bytes)
	cmplStd/lib/text/Format.ci:88: (35 bytes): if ((value) == null)
	<append>  : dup.x32 sp(1)
	<append+?>: load.ref <?> ;null
	<append+?>: ceq.i32
	<append+?>: jz +27
	cmplStd/lib/text/Format.ci:89: (23 bytes): return .result := append(output, pos, "NULL");
	<append+?>: load.z32
	<append+?>: dup.x64 sp(4)
	<append+?>: dup.x32 sp(5)
	<append+?>: load.ref <?> ;"NULL"
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: set.x32 sp(6)
	<append+?>: ret
	cmplStd/lib/text/Format.ci:91: (56 bytes): for (i: int32 := 0; value[i]; i := i + 1)
	<append+?>: load.z32
	<append+?>: jmp +41
	cmplStd/lib/text/Format.ci:92: (13 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(3)
	<append+?>: dup.x32 sp(6)
	<append+?>: clt.i32
	<append+?>: jnz +8
	cmplStd/lib/text/Format.ci:93: (4 bytes): break;
	<append+?>: jmp +38
	cmplStd/lib/text/Format.ci:95: (12 bytes): output[pos] := value[i];
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: dup.x32 sp(5)
	<append+?>: dup.x32 sp(5)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:96: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(3)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(4)
	cmplStd/lib/text/Format.ci:91: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	cmplStd/lib/text/Format.ci:91: (10 bytes): value[i]
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: jnz -43
	<append+?>: inc.sp(-4)
	cmplStd/lib/text/Format.ci:99: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(5)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:100: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(4)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(3)
	cmplStd/lib/text/Format.ci:102: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(4)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:103: (4 bytes): return .result := pos;
	<append+?>: mov.x32 sp(5, 2)
	<append+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:528: referenced as `append`
	cmplGfx/lib/micro.ui.ci:527: referenced as `append`
	cmplGfx/lib/micro.ui.ci:522: referenced as `append`
	cmplGfx/lib/micro.ui.ci:521: referenced as `append`
	cmplGfx/lib/micro.ui.ci:516: referenced as `append`
	cmplGfx/lib/micro.ui.ci:515: referenced as `append`
	cmplGfx/lib/window.ci:362: referenced as `append`
	cmplGfx/lib/window.ci:360: referenced as `append`
	cmplGfx/lib/window.ci:358: referenced as `append`
	cmplGfx/lib/window.ci:356: referenced as `append`
	cmplGfx/lib/window.ci:128: referenced as `append`
	cmplGfx/lib/window.ci:109: referenced as `append`
	cmplStd/lib/text/Format.ci:444: referenced as `append`
	cmplStd/lib/text/Format.ci:426: referenced as `append`
	cmplStd/lib/text/Format.ci:422: referenced as `append`
	cmplStd/lib/text/Format.ci:413: referenced as `append`
	cmplStd/lib/text/Format.ci:381: referenced as `append`
	cmplStd/lib/text/Format.ci:354: referenced as `append`
	cmplStd/lib/text/Format.ci:350: referenced as `append`
	cmplStd/lib/text/Format.ci:346: referenced as `append`
	cmplStd/lib/text/Format.ci:342: referenced as `append`
	cmplStd/lib/text/Format.ci:338: referenced as `append`
	cmplStd/lib/text/Format.ci:217: referenced as `append`
	cmplStd/lib/text/Format.ci:204: referenced as `append`
	cmplStd/lib/text/Format.ci:89: referenced as `append`
}
append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 687
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:107'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param radix: int32 (size: 4, cast: variable(i32))
.param value: uint64 (size: 8, cast: variable(u64))
.param format: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80] := {
	};
	assert(radix > 1, "radix is too small", radix);
	assert(radix < (radixDigits.length), "radix is too big", radix);
	for ( ; value > (0); value := value / (radix)) {
		digits[len := len + 1] := radixDigits[value % (radix)];
	}
	if (len == 0) {
		digits[len := len + 1] := '0';
	}
	maxLen: int32 := format.width - len;
	padChr: char := format.padChr;
	if (padChr == '') {
		padChr := ' ';
	}
	if ((format.sign) != 0) {
		maxLen := maxLen - 1;
		if (contains(whiteSpace, padChr)) {
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
		}
		assert(pos < (output.length));
		output[pos] := format.sign;
		pos := pos + 1;
	}
	for ( ; maxLen > 0; maxLen := maxLen - 1) {
		assert(pos < (output.length));
		output[pos] := padChr;
		pos := pos + 1;
	}
	for (i: int32 := 0; i < len; i := i + 1) {
		assert(i < (output.length));
		output[pos] := digits[len - i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (687 bytes)
	cmplStd/lib/text/Format.ci:111: (1 byte): len: int32 := 0
	<append>  : load.z32
	cmplStd/lib/text/Format.ci:112: (4 bytes): digits: char[80] := {...}
	<append+?>: inc.sp(+80)
	cmplStd/lib/text/Format.ci:114: (69 bytes): assert(radix > 1, "radix is too small", radix);
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+104)
	<append+?>: load.c32 1
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(29)
	<append+?>: load.c32 1
	<append+?>: cgt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 114
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too small"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-16)
	cmplStd/lib/text/Format.ci:115: (68 bytes): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+104)
	<append+?>: load.c32 1
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(29)
	<append+?>: load.m32 <?> ;append.radixDigits+4
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 115
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too big"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-16)
	cmplStd/lib/text/Format.ci:118: (49 bytes): for ( ; value > (0); value := value / (radix))
	<append+?>: jmp +41
	cmplStd/lib/text/Format.ci:119: (29 bytes): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+?>: load.m32 <?> ;append.radixDigits
	<append+?>: dup.x64 sp(24)
	<append+?>: dup.x32 sp(28)
	<append+?>: i32.2i64
	<append+?>: mod.u64
	<append+?>: i64.2i32
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(22)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x32 sp(0)
	<append+?>: set.x32 sp(24)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:118: (8 bytes): value := value / (radix)
	<append+?>: dup.x64 sp(23)
	<append+?>: dup.x32 sp(27)
	<append+?>: i32.2i64
	<append+?>: div.u64
	<append+?>: set.x64 sp(25)
	cmplStd/lib/text/Format.ci:118: (8 bytes): value > (0)
	<append+?>: dup.x64 sp(23)
	<append+?>: load.z64
	<append+?>: cgt.u64
	<append+?>: jnz -41
	cmplStd/lib/text/Format.ci:121: (29 bytes): if (len == 0)
	<append+?>: dup.x32 sp(20)
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +25
	cmplStd/lib/text/Format.ci:122: (21 bytes): digits[len := len + 1] := '0';
	<append+?>: load.c32 48
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(22)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x32 sp(0)
	<append+?>: set.x32 sp(24)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:125: (10 bytes): maxLen: int32 := format.width - len
	<append+?>: dup.x32 sp(22)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: dup.x32 sp(21)
	<append+?>: sub.i32
	cmplStd/lib/text/Format.ci:127: (7 bytes): padChr: char := format.padChr
	<append+?>: dup.x32 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: load.is8
	cmplStd/lib/text/Format.ci:128: (21 bytes): if (padChr == '')
	<append+?>: load.sp(+0)
	<append+?>: load.is8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +14
	cmplStd/lib/text/Format.ci:129: (10 bytes): padChr := ' ';
	<append+?>: load.c32 32
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:133: (205 bytes): if ((format.sign) != 0)
	<append+?>: dup.x32 sp(24)
	<append+?>: load.is8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jnz +200
	cmplStd/lib/text/Format.ci:134: (8 bytes): maxLen := maxLen - 1;
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:135: (118 bytes): if (contains(whiteSpace, padChr))
	<append+?>: load.z32
	<append+?>: load.m32 <?> ;append.whiteSpace
	<append+?>: load.sp(+8)
	<append+?>: load.is8
	<append+?>: load.ref <?> ;indexOf(str: char[*], chr: char): int32
	<append+?>: call
	<append+?>: inc.sp(-8)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jnz +96
	cmplStd/lib/text/Format.ci:137: (92 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +84
	cmplStd/lib/text/Format.ci:138: (53 bytes): assert(pos < (output.length));
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(33)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 138
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-8)
	cmplStd/lib/text/Format.ci:139: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.is8
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:140: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(29)
	cmplStd/lib/text/Format.ci:137: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:137: (8 bytes): maxLen > 0
	<append+?>: dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -84
	cmplStd/lib/text/Format.ci:143: (53 bytes): assert(pos < (output.length));
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(33)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 143
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-8)
	cmplStd/lib/text/Format.ci:144: (9 bytes): output[pos] := format.sign;
	<append+?>: dup.x32 sp(24)
	<append+?>: load.is8
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:145: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(29)
	cmplStd/lib/text/Format.ci:149: (92 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +84
	cmplStd/lib/text/Format.ci:150: (53 bytes): assert(pos < (output.length));
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(33)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 150
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-8)
	cmplStd/lib/text/Format.ci:151: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.is8
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:152: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(29)
	cmplStd/lib/text/Format.ci:149: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:149: (8 bytes): maxLen > 0
	<append+?>: dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -84
	cmplStd/lib/text/Format.ci:156: (100 bytes): for (i: int32 := 0; i < len; i := i + 1)
	<append+?>: load.z32
	<append+?>: jmp +86
	cmplStd/lib/text/Format.ci:157: (53 bytes): assert(i < (output.length));
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(34)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 157
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-8)
	cmplStd/lib/text/Format.ci:158: (17 bytes): output[pos] := digits[len - i];
	<append+?>: load.sp(+12)
	<append+?>: dup.x32 sp(24)
	<append+?>: dup.x32 sp(2)
	<append+?>: sub.i32
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:159: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(30)
	cmplStd/lib/text/Format.ci:156: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	cmplStd/lib/text/Format.ci:156: (9 bytes): i < len
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(24)
	<append+?>: clt.i32
	<append+?>: jnz -87
	<append+?>: inc.sp(-4)
	cmplStd/lib/text/Format.ci:162: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(28)
	<append+?>: dup.x32 sp(31)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:163: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(30)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(29)
	cmplStd/lib/text/Format.ci:165: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:166: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(31, 28)
	<append+?>: inc.sp(-92)
	<append+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:264: referenced as `append`
	cmplStd/lib/text/Format.ci:261: referenced as `append`
	cmplStd/lib/text/Format.ci:258: referenced as `append`
	cmplStd/lib/text/Format.ci:255: referenced as `append`
	cmplStd/lib/text/Format.ci:215: referenced as `append`
	cmplStd/lib/text/Format.ci:200: referenced as `append`
	cmplStd/lib/text/Format.ci:180: referenced as `append`
	cmplStd/lib/text/Format.ci:178: referenced as `append`
}
append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 121
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:170'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param radix: int32 (size: 4, cast: variable(i32))
.param value: int64 (size: 8, cast: variable(i64))
.param format: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	if (value < (0)) {
		signedFormat: FormatFlags := {
			signedFormat.sign := '-';
			signedFormat.padChr := format.padChr;
			signedFormat.width := format.width;
			signedFormat.precision := format.precision;
			signedFormat.trimDecimal := true;
		};
		return .result := append(output, pos, radix, uint64(-value), signedFormat);
	}
	return .result := append(output, pos, radix, uint64(value), format);
}
.instructions: (121 bytes)
	cmplStd/lib/text/Format.ci:171: (97 bytes): if (value < (0))
	<append>  : dup.x64 sp(2)
	<append+?>: load.z64
	<append+?>: clt.i64
	<append+?>: jz +93
	cmplStd/lib/text/Format.ci:172: (54 bytes): signedFormat: FormatFlags := {...}
	<append+?>: inc.sp(+16)
	cmplStd/lib/text/Format.ci:173: (10 bytes): signedFormat.sign := '-';
	<append+?>: load.c32 45
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:174: (12 bytes): signedFormat.padChr := format.padChr;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+1)
	<append+?>: load.is8
	<append+?>: load.sp(+5)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:175: (9 bytes): signedFormat.width := format.width;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:176: (9 bytes): signedFormat.precision := format.precision;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: set.x32 sp(3)
	:: (10 bytes): signedFormat.trimDecimal := true;
	<append+?>: load.c32 1
	<append+?>: load.sp(+16)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:178: (31 bytes): return .result := append(output, pos, radix, uint64(-value), signedFormat);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(11)
	<append+?>: dup.x32 sp(12)
	<append+?>: dup.x32 sp(12)
	<append+?>: dup.x64 sp(11)
	<append+?>: neg.i64
	<append+?>: load.sp(+28)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(13)
	<append+?>: inc.sp(-16)
	<append+?>: ret
	<append+?>: inc.sp(-16)
	cmplStd/lib/text/Format.ci:180: (24 bytes): return .result := append(output, pos, radix, uint64(value), format);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(7)
	<append+?>: dup.x32 sp(8)
	<append+?>: dup.x32 sp(8)
	<append+?>: dup.x64 sp(7)
	<append+?>: dup.x32 sp(8)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(9)
	<append+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:276: referenced as `append`
	cmplStd/lib/text/Format.ci:273: referenced as `append`
	cmplStd/lib/text/Format.ci:270: referenced as `append`
	cmplStd/lib/text/Format.ci:267: referenced as `append`
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 649
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:184'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: float64 (size: 8, cast: variable(f64))
.param format: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		formatInt.sign := value < (0) ? '-' : format.sign;
		formatInt.padChr := format.padChr;
		formatInt.width := format.width - format.precision - 1;
		formatInt.precision := 10;
		formatInt.trimDecimal := true;
	};
	end: int32 := pos + format.width;
	if (end >= (output.length)) {
		end := (output.length - (1));
	}
	const beg: int32 := pos;
	fraction: float64 := Math.modf(Math.abs(value), &value);
	pos := append(output, pos, 10, uint64(int64(value)), formatInt);
	dotIndex: int32 := pos;
	pos := append(output, pos, ".");
	end := Math.max(end, pos + format.precision);
	if (end >= (output.length)) {
		end := (output.length - (1));
	}
	fraction := fraction + Math.pow(10.000000, float64(pos - end)) / (2);
	if (fraction >= (1)) {
		fraction := fraction % (1);
		pos := append(output, beg, 10, uint64(int64(value + (1))), formatInt);
		dotIndex := pos;
		pos := append(output, pos, ".");
		end := Math.max(end, pos + format.precision);
		if (end >= (output.length)) {
			end := (output.length - (1));
		}
	}
	for ( ; pos < end; pos := pos + 1) {
		fraction := Math.modf(fraction * (10), &value);
		output[pos] := (('0') + int32(value));
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	if (!format.trimDecimal) {
		output[pos] := (0);
		return .result := pos;
	}
	for (i: int32 := pos - 1; i >= dotIndex; i := i - 1) {
		if (output[i] != '0') {
			if (i == dotIndex) {
				output[i] := (0);
				return .result := i;
			}
			output[i + 1] := (0);
			return .result := i + 1;
		}
	}
	return .result := pos;
}
.instructions: (649 bytes)
	cmplStd/lib/text/Format.ci:185: (79 bytes): formatInt: FormatFlags := {...}
	<append>  : inc.sp(+16)
	cmplStd/lib/text/Format.ci:186: (25 bytes): formatInt.sign := value < (0) ? '-' : format.sign;
	<append+?>: dup.x64 sp(6)
	<append+?>: load.z64
	<append+?>: clt.f64
	<append+?>: jz +13
	<append+?>: load.c32 45
	<append+?>: jmp +7
	<append+?>: dup.x32 sp(5)
	<append+?>: load.is8
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:187: (12 bytes): formatInt.padChr := format.padChr;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+1)
	<append+?>: load.is8
	<append+?>: load.sp(+5)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:188: (21 bytes): formatInt.width := format.width - format.precision - 1;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: dup.x32 sp(6)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: sub.i32
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	:: (7 bytes): formatInt.precision := 10;
	<append+?>: load.c32 10
	<append+?>: set.x32 sp(3)
	:: (10 bytes): formatInt.trimDecimal := true;
	<append+?>: load.c32 1
	<append+?>: load.sp(+16)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:191: (10 bytes): end: int32 := pos + format.width
	<append+?>: dup.x32 sp(8)
	<append+?>: dup.x32 sp(6)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: add.i32
	cmplStd/lib/text/Format.ci:192: (17 bytes): if (end >= (output.length))
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(12)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:193: (8 bytes): end := (output.length - (1));
	<append+?>: dup.x32 sp(11)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(1)
	cmplStd/lib/text/Format.ci:196: (2 bytes): const beg: int32 := pos
	<append+?>: dup.x32 sp(9)
	cmplStd/lib/text/Format.ci:197: (36 bytes): fraction: float64 := Math.modf(Math.abs(value), &value)
	<append+?>: load.z64
	<append+?>: dup.x64 sp(10)
	<append+?>: dup.x64 sp(0)
	<append+?>: load.z64
	<append+?>: clt.f64
	<append+?>: jz +11
	<append+?>: dup.x64 sp(0)
	<append+?>: neg.f64
	<append+?>: jmp +6
	<append+?>: dup.x64 sp(0)
	<append+?>: set.x64 sp(2)
	<append+?>: load.sp(+48)
	<append+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<append+?>: call
	<append+?>: inc.sp(-12)
	cmplStd/lib/text/Format.ci:200: (29 bytes): pos := append(output, pos, 10, uint64(int64(value)), formatInt);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(14)
	<append+?>: dup.x32 sp(15)
	<append+?>: load.c32 10
	<append+?>: dup.x64 sp(15)
	<append+?>: f64.2i64
	<append+?>: load.sp(+44)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(13)
	cmplStd/lib/text/Format.ci:203: (2 bytes): dotIndex: int32 := pos
	<append+?>: dup.x32 sp(12)
	cmplStd/lib/text/Format.ci:204: (22 bytes): pos := append(output, pos, ".");
	<append+?>: load.z32
	<append+?>: dup.x64 sp(15)
	<append+?>: dup.x32 sp(16)
	<append+?>: load.ref <?> ;"."
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:205: (38 bytes): end := Math.max(end, pos + format.precision);
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(14)
	<append+?>: dup.x32 sp(12)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: add.i32
	<append+?>: dup.x32 sp(1)
	<append+?>: dup.x32 sp(1)
	<append+?>: cgt.i32
	<append+?>: jz +10
	<append+?>: dup.x32 sp(1)
	<append+?>: jmp +6
	<append+?>: dup.x32 sp(0)
	<append+?>: mov.x32 sp(2, 0)
	<append+?>: inc.sp(-8)
	<append+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:206: (17 bytes): if (end >= (output.length))
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(16)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:207: (8 bytes): end := (output.length - (1));
	<append+?>: dup.x32 sp(15)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:211: (41 bytes): fraction := fraction + Math.pow(10.000000, float64(pos - end)) / (2);
	<append+?>: dup.x64 sp(1)
	<append+?>: load.z64
	<append+?>: load.f64 10.000000
	<append+?>: dup.x32 sp(19)
	<append+?>: dup.x32 sp(11)
	<append+?>: sub.i32
	<append+?>: i32.2f64
	<append+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: load.f64 2.000000
	<append+?>: div.f64
	<append+?>: add.f64
	<append+?>: set.x64 sp(3)
	cmplStd/lib/text/Format.ci:213: (149 bytes): if (fraction >= (1))
	<append+?>: dup.x64 sp(1)
	<append+?>: load.f64 1.000000
	<append+?>: clt.f64
	<append+?>: jnz +137
	cmplStd/lib/text/Format.ci:214: (14 bytes): fraction := fraction % (1);
	<append+?>: dup.x64 sp(1)
	<append+?>: load.f64 1.000000
	<append+?>: mod.f64
	<append+?>: set.x64 sp(3)
	cmplStd/lib/text/Format.ci:215: (39 bytes): pos := append(output, beg, 10, uint64(int64(value + (1))), formatInt);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(15)
	<append+?>: dup.x32 sp(6)
	<append+?>: load.c32 10
	<append+?>: dup.x64 sp(16)
	<append+?>: load.f64 1.000000
	<append+?>: add.f64
	<append+?>: f64.2i64
	<append+?>: load.sp(+48)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:216: (3 bytes): dotIndex := pos;
	<append+?>: mov.x32 sp(0, 13)
	cmplStd/lib/text/Format.ci:217: (22 bytes): pos := append(output, pos, ".");
	<append+?>: load.z32
	<append+?>: dup.x64 sp(15)
	<append+?>: dup.x32 sp(16)
	<append+?>: load.ref <?> ;"."
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:218: (38 bytes): end := Math.max(end, pos + format.precision);
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(14)
	<append+?>: dup.x32 sp(12)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: add.i32
	<append+?>: dup.x32 sp(1)
	<append+?>: dup.x32 sp(1)
	<append+?>: cgt.i32
	<append+?>: jz +10
	<append+?>: dup.x32 sp(1)
	<append+?>: jmp +6
	<append+?>: dup.x32 sp(0)
	<append+?>: mov.x32 sp(2, 0)
	<append+?>: inc.sp(-8)
	<append+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:219: (17 bytes): if (end >= (output.length))
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(16)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:220: (8 bytes): end := (output.length - (1));
	<append+?>: dup.x32 sp(15)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:224: (65 bytes): for ( ; pos < end; pos := pos + 1)
	<append+?>: jmp +56
	cmplStd/lib/text/Format.ci:225: (29 bytes): fraction := Math.modf(fraction * (10), &value);
	<append+?>: load.z64
	<append+?>: dup.x64 sp(3)
	<append+?>: load.f64 10.000000
	<append+?>: mul.f64
	<append+?>: load.sp(+60)
	<append+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<append+?>: call
	<append+?>: inc.sp(-12)
	<append+?>: set.x64 sp(3)
	cmplStd/lib/text/Format.ci:226: (15 bytes): output[pos] := (('0') + int32(value));
	<append+?>: load.c32 48
	<append+?>: dup.x64 sp(12)
	<append+?>: f64.2i32
	<append+?>: add.i32
	<append+?>: dup.x32 sp(15)
	<append+?>: dup.x32 sp(15)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:224: (8 bytes): pos := pos + 1
	<append+?>: dup.x32 sp(13)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:224: (9 bytes): pos < end
	<append+?>: dup.x32 sp(13)
	<append+?>: dup.x32 sp(5)
	<append+?>: clt.i32
	<append+?>: jnz -57
	cmplStd/lib/text/Format.ci:229: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(13)
	<append+?>: dup.x32 sp(16)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:230: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(15)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:233: (26 bytes): if (!format.trimDecimal)
	<append+?>: dup.x32 sp(10)
	<append+?>: inc.i32(+12)
	<append+?>: load.is8
	<append+?>: jnz +19
	cmplStd/lib/text/Format.ci:234: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(15)
	<append+?>: dup.x32 sp(15)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:235: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(16, 13)
	<append+?>: inc.sp(-36)
	<append+?>: ret
	cmplStd/lib/text/Format.ci:239: (91 bytes): for (i: int32 := pos - 1; i >= dotIndex; i := i - 1)
	<append+?>: dup.x32 sp(13)
	<append+?>: inc.i32(-1)
	<append+?>: jmp +72
	cmplStd/lib/text/Format.ci:240: (64 bytes): if (output[i] != '0')
	<append+?>: dup.x32 sp(15)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: load.c32 48
	<append+?>: ceq.i32
	<append+?>: jnz +52
	cmplStd/lib/text/Format.ci:241: (24 bytes): if (i == dotIndex)
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(2)
	<append+?>: ceq.i32
	<append+?>: jz +19
	cmplStd/lib/text/Format.ci:243: (7 bytes): output[i] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(16)
	<append+?>: dup.x32 sp(2)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:244: (8 bytes): return .result := i;
	<append+?>: mov.x32 sp(17, 0)
	<append+?>: inc.sp(-40)
	<append+?>: ret
	cmplStd/lib/text/Format.ci:246: (11 bytes): output[i + 1] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(16)
	<append+?>: dup.x32 sp(2)
	<append+?>: inc.i32(+1)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:247: (13 bytes): return .result := i + 1;
	<append+?>: dup.x32 sp(0)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(18)
	<append+?>: inc.sp(-40)
	<append+?>: ret
	cmplStd/lib/text/Format.ci:239: (4 bytes): i := i - 1
	<append+?>: inc.i32(-1)
	cmplStd/lib/text/Format.ci:239: (9 bytes): i >= dotIndex
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(2)
	<append+?>: clt.i32
	<append+?>: jz -73
	<append+?>: inc.sp(-4)
	cmplStd/lib/text/Format.ci:251: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(16, 13)
	<append+?>: inc.sp(-36)
	<append+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:321: referenced as `append`
	cmplGfx/lib/micro.ui.ci:288: referenced as `append`
	cmplStd/lib/text/stream/TextStream.ci:135: referenced as `append`
	cmplStd/lib/text/Format.ci:279: referenced as `append`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:255'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint64 (size: 8, cast: u64)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, uint64(value), format)
.usages:
	cmplStd/lib/text/stream/TextStream.ci:121: referenced as `append`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:258'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint32 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, uint64(value), format)
.usages:
	cmplStd/lib/text/stream/TextStream.ci:114: referenced as `append`
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:261'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint16 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, uint64(value), format)
.usages:
	cmplStd/lib/text/Format.ci:393: referenced as `append`
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:264'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint8 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, uint64(value), format)
.usages:
	cmplStd/lib/text/Format.ci:459: referenced as `append`
	cmplStd/lib/text/Format.ci:440: referenced as `append`
	cmplStd/lib/text/Format.ci:409: referenced as `append`
	cmplStd/lib/text/Format.ci:397: referenced as `append`
	cmplStd/lib/text/Format.ci:385: referenced as `append`
	cmplStd/lib/text/Format.ci:371: referenced as `append`
	cmplStd/lib/text/Format.ci:363: referenced as `append`
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:267'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int64 (size: 8, cast: i64)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, int64(value), format)
.usages:
	cmplGfx/lib/micro.ui.ci:319: referenced as `append`
	cmplGfx/lib/micro.ui.ci:286: referenced as `append`
	cmplStd/lib/text/stream/TextStream.ci:107: referenced as `append`
	cmplStd/lib/text/Format.ci:436: referenced as `append`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:270'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int32 (size: 4, cast: i32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, int64(value), format)
.usages:
	cmplStd/lib/text/stream/TextStream.ci:100: referenced as `append`
	cmplStd/lib/text/Format.ci:565: referenced as `append`
	cmplStd/lib/text/Format.ci:475: referenced as `append`
	cmplStd/lib/text/Format.ci:471: referenced as `append`
	cmplStd/lib/text/Format.ci:452: referenced as `append`
	cmplStd/lib/text/Format.ci:418: referenced as `append`
	cmplStd/lib/text/Format.ci:405: referenced as `append`
	cmplStd/lib/text/Format.ci:401: referenced as `append`
	cmplStd/lib/text/Format.ci:389: referenced as `append`
	cmplStd/lib/text/Format.ci:359: referenced as `append`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:273'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int16 (size: 4, cast: i32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, int64(value), format)
.usages:
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:276'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int8 (size: 4, cast: i32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, int64(value), format)
.usages:
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:279'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: float32 (size: 4, cast: f32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, float64(value), format)
.usages:
	cmplStd/lib/text/stream/TextStream.ci:128: referenced as `append`
}
DatetimeFormat: typename {
.kind: static const typename(val)
.base: `typename`
.size: 80
.name: 'DatetimeFormat'
.file: 'cmplStd/lib/text/Format.ci:298'
.field monthsLong: char[][] (size: 8, cast: const variable(arr))
.field monthsShort: char[][] (size: 8, cast: const variable(arr))
.field weeksLong: char[][] (size: 8, cast: const variable(arr))
.field weeksShort: char[][] (size: 8, cast: const variable(arr))
.field amPmUpper: char[][] (size: 8, cast: const variable(arr))
.field amPmLower: char[][] (size: 8, cast: const variable(arr))
.field dateLong: char[] (size: 8, cast: const variable(arr))
.field timeLong: char[] (size: 8, cast: const variable(arr))
.field dateShort: char[] (size: 8, cast: const variable(arr))
.field timeShort: char[] (size: 8, cast: const variable(arr))
.field format: function (size: 2638, cast: static function)
.field format: function (size: 23, cast: static function)
.doc: 'datetime regional formatter, currently 'en' if instantiated with: `DatetimeFormat fmt = {};`'
.usages:
	cmplStd/lib/text/Format.ci:550: referenced as `DatetimeFormat`
	cmplStd/lib/text/Format.ci:501: referenced as `DatetimeFormat`
	cmplStd/lib/text/Format.ci:313: referenced as `DatetimeFormat`
}
DatetimeFormat.monthsLong: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'monthsLong'
.file: 'cmplStd/lib/text/Format.ci:302'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:551: referenced as `monthsLong`
	cmplStd/lib/text/Format.ci:354: referenced as `monthsLong`
}
DatetimeFormat.monthsShort: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'monthsShort'
.file: 'cmplStd/lib/text/Format.ci:303'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:552: referenced as `monthsShort`
	cmplStd/lib/text/Format.ci:381: referenced as `monthsShort`
	cmplStd/lib/text/Format.ci:350: referenced as `monthsShort`
}
DatetimeFormat.weeksLong: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'weeksLong'
.file: 'cmplStd/lib/text/Format.ci:304'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:553: referenced as `weeksLong`
	cmplStd/lib/text/Format.ci:346: referenced as `weeksLong`
}
DatetimeFormat.weeksShort: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'weeksShort'
.file: 'cmplStd/lib/text/Format.ci:305'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:554: referenced as `weeksShort`
	cmplStd/lib/text/Format.ci:342: referenced as `weeksShort`
}
DatetimeFormat.amPmUpper: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'amPmUpper'
.file: 'cmplStd/lib/text/Format.ci:306'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:555: referenced as `amPmUpper`
	cmplStd/lib/text/Format.ci:422: referenced as `amPmUpper`
}
DatetimeFormat.amPmLower: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'amPmLower'
.file: 'cmplStd/lib/text/Format.ci:307'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:556: referenced as `amPmLower`
	cmplStd/lib/text/Format.ci:426: referenced as `amPmLower`
}
DatetimeFormat.dateLong: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'dateLong'
.file: 'cmplStd/lib/text/Format.ci:308'
.owner: DatetimeFormat
.value: "%A %d %B %Y"
.usages:
	internal usages: 1
}
DatetimeFormat.timeLong: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'timeLong'
.file: 'cmplStd/lib/text/Format.ci:309'
.owner: DatetimeFormat
.value: "%r"
.usages:
	internal usages: 1
}
DatetimeFormat.dateShort: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'dateShort'
.file: 'cmplStd/lib/text/Format.ci:310'
.owner: DatetimeFormat
.value: "%x"
.usages:
	cmplStd/lib/text/Format.ci:463: referenced as `dateShort`
	internal usages: 1
}
DatetimeFormat.timeShort: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'timeShort'
.file: 'cmplStd/lib/text/Format.ci:311'
.owner: DatetimeFormat
.value: "%I:%M %p"
.usages:
	cmplStd/lib/text/Format.ci:467: referenced as `timeShort`
	internal usages: 1
}
DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32: function {
.kind: static function
.base: `function`
.size: 2638
.name: 'format'
.file: 'cmplStd/lib/text/Format.ci:313'
.owner: DatetimeFormat
.param .result: int32 (size: 4, cast: variable(i32))
.param formatter: DatetimeFormat (size: 4, cast: const variable(ref))
.param output: char[] (size: 8, cast: variable(arr))
.param end: int32 (size: 4, cast: variable(i32))
.param value: Datetime (size: 4, cast: const variable(ref))
.param format: char[] (size: 8, cast: const variable(arr))
.value: {
	hours24to12(hour: int32): int32 := hour > 12 ? hour - 12 : hour == 0 ? 12 : hour;
	if (pointer(format) == null) {
		return .result := format(formatter, output, end, value, "%Y.%m.%d");
	}
	chr: char := 0;
	for (pos: int32 := 0; pos < (format.length); pos := pos + 1) {
		if (end >= (output.length)) {
			output[output.length - (1)] := (0);
			return .result := output.length - (1);
		}
		chr := format[pos];
		if (chr != '%') {
			output[end] := chr;
			end := end + 1;
			continue;
		}
		flags: FormatFlags := FormatFlags.read(format, &pos);
		chr := format[pos];
		if (chr == '%') {
			end := append(output, end, "%");
		}
		else if (chr == 'a') {
			end := append(output, end, formatter.weeksShort[indexOf(value.dayOfWeek)]);
		}
		else if (chr == 'A') {
			end := append(output, end, formatter.weeksLong[indexOf(value.dayOfWeek)]);
		}
		else if (chr == 'b') {
			end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
		}
		else if (chr == 'B') {
			end := append(output, end, formatter.monthsLong[indexOf(value.month)]);
		}
		else if (chr == 'C') {
			end := append(output, end, value.year / 100, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'd') {
			end := append(output, end, value.day, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'D') {
			end := format(formatter, output, end, value, "%m/%d/%y");
		}
		else if (chr == 'e') {
			end := append(output, end, value.day, FormatFlags.defPad(flags, 2, ' '));
		}
		else if (chr == 'F') {
			end := format(formatter, output, end, value, "%04Y-%m-%d");
		}
		else if (chr == 'h') {
			end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
		}
		else if (chr == 'H') {
			end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'I') {
			end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'j') {
			end := append(output, end, value.dayOfYear, FormatFlags.defPad(flags, 3, '0'));
		}
		else if (chr == 'k') {
			end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, ' '));
		}
		else if (chr == 'l') {
			end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, ' '));
		}
		else if (chr == 'm') {
			end := append(output, end, indexOf(value.month) + 1, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'M') {
			end := append(output, end, value.minute, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'n') {
			end := append(output, end, "\n");
		}
		else if (chr == 'N') {
			end := append(output, end, (value.millis) * 1000000, FormatFlags.defPad(flags, 9, '0'));
		}
		else if (chr == 'p') {
			end := append(output, end, formatter.amPmUpper[int32((value.hour) < 12)]);
		}
		else if (chr == 'P') {
			end := append(output, end, formatter.amPmLower[int32((value.hour) < 12)]);
		}
		else if (chr == 'R') {
			end := format(formatter, output, end, value, "%H:%M");
		}
		else if (chr == 's') {
			end := append(output, end, typename.value(Timestamp(value), Timeunit.(Seconds)), flags);
		}
		else if (chr == 'S') {
			end := append(output, end, value.second, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 't') {
			end := append(output, end, "\t");
		}
		else if (chr == 'T') {
			end := format(formatter, output, end, value, "%H:%M:%S");
		}
		else if (chr == 'u') {
			end := append(output, end, indexOf(value.dayOfWeek) + 1, flags);
		}
		else if (chr == 'W') {
			end := append(output, end, value.weekOfYear, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'x') {
			end := format(formatter, output, end, value, formatter.dateShort);
		}
		else if (chr == 'X') {
			end := format(formatter, output, end, value, formatter.timeShort);
		}
		else if (chr == 'y') {
			end := append(output, end, value.year % 100, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'Y') {
			end := append(output, end, value.year, flags);
		}
		else {
			abort("unimplemented or invalid format character", chr);
		}
	}
	if (end >= (output.length)) {
		end := (output.length - (1));
	}
	output[end] := (0);
	return .result := end;
}
.instructions: (2638 bytes)
	cmplStd/lib/text/Format.ci:316: (44 bytes): if (pointer(format) == null)
	<format>  : dup.x32 sp(1)
	<format+?>: load.ref <?> ;null
	<format+?>: ceq.i32
	<format+?>: jz +36
	cmplStd/lib/text/Format.ci:317: (32 bytes): return .result := format(formatter, output, end, value, "%Y.%m.%d");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x64 sp(7)
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x32 sp(8)
	<format+?>: load.c32 8
	<format+?>: load.ref <?> ;"%Y.%m.%d"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(9)
	<format+?>: ret
	cmplStd/lib/text/Format.ci:320: (1 byte): chr: char := 0
	<format+?>: load.z32
	cmplStd/lib/text/Format.ci:321: (2561 bytes): for (pos: int32 := 0; pos < (format.length); pos := pos + 1)
	<format+?>: load.z32
	<format+?>: jmp +2547
	cmplStd/lib/text/Format.ci:322: (33 bytes): if (end >= (output.length))
	<format+?>: dup.x32 sp(6)
	<format+?>: dup.x32 sp(9)
	<format+?>: clt.i32
	<format+?>: jnz +28
	cmplStd/lib/text/Format.ci:323: (11 bytes): output[output.length - (1)] := (0);
	<format+?>: load.z32
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x32 sp(10)
	<format+?>: inc.i32(-1)
	<format+?>: add.i32
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:324: (13 bytes): return .result := output.length - (1);
	<format+?>: dup.x32 sp(8)
	<format+?>: inc.i32(-1)
	<format+?>: set.x32 sp(11)
	<format+?>: inc.sp(-8)
	<format+?>: ret
	cmplStd/lib/text/Format.ci:327: (11 bytes): chr := format[pos];
	<format+?>: dup.x32 sp(3)
	<format+?>: dup.x32 sp(1)
	<format+?>: add.i32
	<format+?>: load.is8
	<format+?>: load.sp(+8)
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:328: (38 bytes): if (chr != '%')
	<format+?>: load.sp(+4)
	<format+?>: load.is8
	<format+?>: load.c32 37
	<format+?>: ceq.i32
	<format+?>: jnz +27
	cmplStd/lib/text/Format.ci:329: (11 bytes): output[end] := chr;
	<format+?>: load.sp(+4)
	<format+?>: load.is8
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x32 sp(8)
	<format+?>: add.i32
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:330: (8 bytes): end := end + 1;
	<format+?>: dup.x32 sp(6)
	<format+?>: inc.i32(+1)
	<format+?>: set.x32 sp(7)
	cmplStd/lib/text/Format.ci:331: (4 bytes): continue;
	<format+?>: jmp +2461
	cmplStd/lib/text/Format.ci:334: (20 bytes): flags: FormatFlags := FormatFlags.read(format, &pos)
	<format+?>: inc.sp(+16)
	<format+?>: dup.x64 sp(7)
	<format+?>: load.sp(+24)
	<format+?>: load.ref <?> ;FormatFlags.read(format: char[], pos: int32): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	cmplStd/lib/text/Format.ci:335: (11 bytes): chr := format[pos];
	<format+?>: dup.x32 sp(7)
	<format+?>: dup.x32 sp(5)
	<format+?>: add.i32
	<format+?>: load.is8
	<format+?>: load.sp(+24)
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:337: (2422 bytes): if (chr == '%')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 37
	<format+?>: ceq.i32
	<format+?>: jz +30
	cmplStd/lib/text/Format.ci:338: (22 bytes): end := append(output, end, "%");
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.ref <?> ;"%"
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2385
	cmplStd/lib/text/Format.ci:340: (2381 bytes): if (chr == 'a')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 97
	<format+?>: ceq.i32
	<format+?>: jz +48
	cmplStd/lib/text/Format.ci:342: (40 bytes): end := append(output, end, formatter.weeksShort[indexOf(value.dayOfWeek)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+24)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+36)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2326
	cmplStd/lib/text/Format.ci:344: (2322 bytes): if (chr == 'A')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 65
	<format+?>: ceq.i32
	<format+?>: jz +48
	cmplStd/lib/text/Format.ci:346: (40 bytes): end := append(output, end, formatter.weeksLong[indexOf(value.dayOfWeek)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+16)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+36)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2267
	cmplStd/lib/text/Format.ci:348: (2263 bytes): if (chr == 'b')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 98
	<format+?>: ceq.i32
	<format+?>: jz +48
	cmplStd/lib/text/Format.ci:350: (40 bytes): end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+8)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+4)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2208
	cmplStd/lib/text/Format.ci:352: (2204 bytes): if (chr == 'B')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 66
	<format+?>: ceq.i32
	<format+?>: jz +44
	cmplStd/lib/text/Format.ci:354: (36 bytes): end := append(output, end, formatter.monthsLong[indexOf(value.month)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+4)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2153
	cmplStd/lib/text/Format.ci:357: (2149 bytes): if (chr == 'C')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 67
	<format+?>: ceq.i32
	<format+?>: jz +79
	cmplStd/lib/text/Format.ci:359: (71 bytes): end := append(output, end, value.year / 100, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: load.i32
	<format+?>: load.c32 100
	<format+?>: div.i32
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2063
	cmplStd/lib/text/Format.ci:361: (2059 bytes): if (chr == 'd')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 100
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:363: (69 bytes): end := append(output, end, value.day, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+5)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1975
	cmplStd/lib/text/Format.ci:365: (1971 bytes): if (chr == 'D')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 68
	<format+?>: ceq.i32
	<format+?>: jz +39
	cmplStd/lib/text/Format.ci:367: (31 bytes): end := format(formatter, output, end, value, "%m/%d/%y");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: load.c32 8
	<format+?>: load.ref <?> ;"%m/%d/%y"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1925
	cmplStd/lib/text/Format.ci:369: (1921 bytes): if (chr == 'e')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 101
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:371: (69 bytes): end := append(output, end, value.day, FormatFlags.defPad(flags, 2, ' '));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 32
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+5)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1837
	cmplStd/lib/text/Format.ci:373: (1833 bytes): if (chr == 'F')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 70
	<format+?>: ceq.i32
	<format+?>: jz +39
	cmplStd/lib/text/Format.ci:375: (31 bytes): end := format(formatter, output, end, value, "%04Y-%m-%d");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: load.c32 10
	<format+?>: load.ref <?> ;"%04Y-%m-%d"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1787
	cmplStd/lib/text/Format.ci:379: (1783 bytes): if (chr == 'h')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 104
	<format+?>: ceq.i32
	<format+?>: jz +48
	cmplStd/lib/text/Format.ci:381: (40 bytes): end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+8)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+4)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1728
	cmplStd/lib/text/Format.ci:383: (1724 bytes): if (chr == 'H')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 72
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:385: (69 bytes): end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1640
	cmplStd/lib/text/Format.ci:387: (1636 bytes): if (chr == 'I')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 73
	<format+?>: ceq.i32
	<format+?>: jz +120
	cmplStd/lib/text/Format.ci:389: (112 bytes): end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: dup.x32 sp(0)
	<format+?>: load.c32 12
	<format+?>: cgt.i32
	<format+?>: jz +14
	<format+?>: dup.x32 sp(0)
	<format+?>: inc.i32(-12)
	<format+?>: jmp +23
	<format+?>: dup.x32 sp(0)
	<format+?>: load.z32
	<format+?>: ceq.i32
	<format+?>: jz +13
	<format+?>: load.c32 12
	<format+?>: jmp +6
	<format+?>: dup.x32 sp(0)
	<format+?>: set.x32 sp(1)
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1509
	cmplStd/lib/text/Format.ci:391: (1505 bytes): if (chr == 'j')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 106
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:393: (69 bytes): end := append(output, end, value.dayOfYear, FormatFlags.defPad(flags, 3, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 3
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+34)
	<format+?>: load.iu16
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1421
	cmplStd/lib/text/Format.ci:395: (1417 bytes): if (chr == 'k')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 107
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:397: (69 bytes): end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, ' '));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 32
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1333
	cmplStd/lib/text/Format.ci:399: (1329 bytes): if (chr == 'l')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 108
	<format+?>: ceq.i32
	<format+?>: jz +120
	cmplStd/lib/text/Format.ci:401: (112 bytes): end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, ' '));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 32
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: dup.x32 sp(0)
	<format+?>: load.c32 12
	<format+?>: cgt.i32
	<format+?>: jz +14
	<format+?>: dup.x32 sp(0)
	<format+?>: inc.i32(-12)
	<format+?>: jmp +23
	<format+?>: dup.x32 sp(0)
	<format+?>: load.z32
	<format+?>: ceq.i32
	<format+?>: jz +13
	<format+?>: load.c32 12
	<format+?>: jmp +6
	<format+?>: dup.x32 sp(0)
	<format+?>: set.x32 sp(1)
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1202
	cmplStd/lib/text/Format.ci:403: (1198 bytes): if (chr == 'm')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 109
	<format+?>: ceq.i32
	<format+?>: jz +85
	cmplStd/lib/text/Format.ci:405: (77 bytes): end := append(output, end, indexOf(value.month) + 1, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+4)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: inc.i32(+1)
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1106
	cmplStd/lib/text/Format.ci:407: (1102 bytes): if (chr == 'M')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 77
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:409: (69 bytes): end := append(output, end, value.minute, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+7)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1018
	cmplStd/lib/text/Format.ci:411: (1014 bytes): if (chr == 'n')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 110
	<format+?>: ceq.i32
	<format+?>: jz +30
	cmplStd/lib/text/Format.ci:413: (22 bytes): end := append(output, end, "\n");
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.ref <?> ;"\n"
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +977
	cmplStd/lib/text/Format.ci:415: (973 bytes): if (chr == 'N')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 78
	<format+?>: ceq.i32
	<format+?>: jz +83
	cmplStd/lib/text/Format.ci:418: (75 bytes): end := append(output, end, (value.millis) * 1000000, FormatFlags.defPad(flags, 9, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 9
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+10)
	<format+?>: load.iu16
	<format+?>: load.c32 1000000
	<format+?>: mul.i32
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +883
	cmplStd/lib/text/Format.ci:420: (879 bytes): if (chr == 'p')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 112
	<format+?>: ceq.i32
	<format+?>: jz +50
	cmplStd/lib/text/Format.ci:422: (42 bytes): end := append(output, end, formatter.amPmUpper[int32((value.hour) < 12)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+32)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: load.c32 12
	<format+?>: clt.i32
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +822
	cmplStd/lib/text/Format.ci:424: (818 bytes): if (chr == 'P')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 80
	<format+?>: ceq.i32
	<format+?>: jz +50
	cmplStd/lib/text/Format.ci:426: (42 bytes): end := append(output, end, formatter.amPmLower[int32((value.hour) < 12)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+40)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: load.c32 12
	<format+?>: clt.i32
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +761
	cmplStd/lib/text/Format.ci:430: (757 bytes): if (chr == 'R')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 82
	<format+?>: ceq.i32
	<format+?>: jz +39
	cmplStd/lib/text/Format.ci:432: (31 bytes): end := format(formatter, output, end, value, "%H:%M");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: load.c32 5
	<format+?>: load.ref <?> ;"%H:%M"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +711
	cmplStd/lib/text/Format.ci:434: (707 bytes): if (chr == 's')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 115
	<format+?>: ceq.i32
	<format+?>: jz +82
	cmplStd/lib/text/Format.ci:436: (74 bytes): end := append(output, end, typename.value(Timestamp(value), Timeunit.(Seconds)), flags);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.c32 10
	<format+?>: load.z64
	<format+?>: inc.sp(+8)
	<format+?>: dup.x32 sp(18)
	<format+?>: load.sp(-36)
	<format+?>: copy.mem -40
	<format+?>: inc.sp(+40)
	<format+?>: load.ref <?> ;Timestamp(value: Datetime): Timestamp
	<format+?>: call
	<format+?>: inc.sp(-40)
	<format+?>: load.c64 1000000000
	<format+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +618
	cmplStd/lib/text/Format.ci:438: (614 bytes): if (chr == 'S')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 83
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:440: (69 bytes): end := append(output, end, value.second, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+8)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +530
	cmplStd/lib/text/Format.ci:442: (526 bytes): if (chr == 't')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 116
	<format+?>: ceq.i32
	<format+?>: jz +30
	cmplStd/lib/text/Format.ci:444: (22 bytes): end := append(output, end, "\t");
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.ref <?> ;"\t"
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +489
	cmplStd/lib/text/Format.ci:446: (485 bytes): if (chr == 'T')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 84
	<format+?>: ceq.i32
	<format+?>: jz +39
	cmplStd/lib/text/Format.ci:448: (31 bytes): end := format(formatter, output, end, value, "%H:%M:%S");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: load.c32 8
	<format+?>: load.ref <?> ;"%H:%M:%S"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +439
	cmplStd/lib/text/Format.ci:450: (435 bytes): if (chr == 'u')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 117
	<format+?>: ceq.i32
	<format+?>: jz +50
	cmplStd/lib/text/Format.ci:452: (42 bytes): end := append(output, end, indexOf(value.dayOfWeek) + 1, flags);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+36)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: inc.i32(+1)
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +378
	cmplStd/lib/text/Format.ci:457: (374 bytes): if (chr == 'W')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 87
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:459: (69 bytes): end := append(output, end, value.weekOfYear, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+32)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +290
	cmplStd/lib/text/Format.ci:461: (286 bytes): if (chr == 'x')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 120
	<format+?>: ceq.i32
	<format+?>: jz +36
	cmplStd/lib/text/Format.ci:463: (28 bytes): end := format(formatter, output, end, value, formatter.dateShort);
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(19)
	<format+?>: inc.i32(+64)
	<format+?>: load.i64
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +243
	cmplStd/lib/text/Format.ci:465: (239 bytes): if (chr == 'X')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 88
	<format+?>: ceq.i32
	<format+?>: jz +36
	cmplStd/lib/text/Format.ci:467: (28 bytes): end := format(formatter, output, end, value, formatter.timeShort);
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(19)
	<format+?>: inc.i32(+72)
	<format+?>: load.i64
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +196
	cmplStd/lib/text/Format.ci:469: (192 bytes): if (chr == 'y')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 121
	<format+?>: ceq.i32
	<format+?>: jz +79
	cmplStd/lib/text/Format.ci:471: (71 bytes): end := append(output, end, value.year % 100, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: load.i32
	<format+?>: load.c32 100
	<format+?>: mod.i32
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +106
	cmplStd/lib/text/Format.ci:473: (102 bytes): if (chr == 'Y')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 89
	<format+?>: ceq.i32
	<format+?>: jz +38
	cmplStd/lib/text/Format.ci:475: (30 bytes): end := append(output, end, value.year, flags);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(14)
	<format+?>: load.i32
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +57
	cmplStd/lib/text/Format.ci:483: (53 bytes): abort("unimplemented or invalid format character", chr);
	<format+?>: load.ref <?> ;char
	<format+?>: load.sp(+24)
	<format+?>: load.c32 1
	<format+?>: load.sp(+4)
	<format+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<format+?>: load.c32 483
	<format+?>: load.c32 -2
	<format+?>: load.c32 128
	<format+?>: load.ref <?> ;"unimplemented or invalid format character"
	<format+?>: dup.x64 sp(5)
	<format+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<format+?>: inc.sp(-16)
	<format+?>: inc.sp(-16)
	cmplStd/lib/text/Format.ci:321: (4 bytes): pos := pos + 1
	<format+?>: inc.i32(+1)
	cmplStd/lib/text/Format.ci:321: (9 bytes): pos < (format.length)
	<format+?>: dup.x32 sp(0)
	<format+?>: dup.x32 sp(5)
	<format+?>: clt.i32
	<format+?>: jnz -2548
	<format+?>: inc.sp(-4)
	cmplStd/lib/text/Format.ci:487: (17 bytes): if (end >= (output.length))
	<format+?>: dup.x32 sp(5)
	<format+?>: dup.x32 sp(8)
	<format+?>: clt.i32
	<format+?>: jnz +12
	cmplStd/lib/text/Format.ci:488: (8 bytes): end := (output.length - (1));
	<format+?>: dup.x32 sp(7)
	<format+?>: inc.i32(-1)
	<format+?>: set.x32 sp(6)
	cmplStd/lib/text/Format.ci:490: (7 bytes): output[end] := (0);
	<format+?>: load.z32
	<format+?>: dup.x32 sp(7)
	<format+?>: dup.x32 sp(7)
	<format+?>: add.i32
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:491: (8 bytes): return .result := end;
	<format+?>: mov.x32 sp(9, 5)
	<format+?>: inc.sp(-4)
	<format+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:502: referenced as `format`
	cmplStd/lib/text/Format.ci:467: referenced as `format`
	cmplStd/lib/text/Format.ci:463: referenced as `format`
	cmplStd/lib/text/Format.ci:448: referenced as `format`
	cmplStd/lib/text/Format.ci:432: referenced as `format`
	cmplStd/lib/text/Format.ci:375: referenced as `format`
	cmplStd/lib/text/Format.ci:367: referenced as `format`
	cmplStd/lib/text/Format.ci:317: referenced as `format`
}
DatetimeFormat.format(formatter: DatetimeFormat, output: char[], value: Datetime, format: char[]): int32: function {
.kind: static function
.base: `function`
.size: 23
.name: 'format'
.file: 'cmplStd/lib/text/Format.ci:501'
.owner: DatetimeFormat
.param .result: int32 (size: 4, cast: variable(i32))
.param formatter: DatetimeFormat (size: 4, cast: const variable(ref))
.param output: char[] (size: 8, cast: variable(arr))
.param value: Datetime (size: 4, cast: const variable(ref))
.param format: char[] (size: 8, cast: const variable(arr))
.doc: 'Format date to text
@param value date to format
@param output write output to this buffer
@param format format string
 	@null defaults to: "%Y.%m.%d"'
.value: {
	return .result := format(formatter, output, 0, value, format);
}
.instructions: (23 bytes)
	cmplStd/lib/text/Format.ci:502: (23 bytes): return .result := format(formatter, output, 0, value, format);
	<format>  : load.z32
	<format+?>: dup.x32 sp(7)
	<format+?>: dup.x64 sp(6)
	<format+?>: load.z32
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x64 sp(7)
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(8)
	<format+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:558: referenced as `format`
}
format(value: Datetime, output: char[], format: char[]): int32: function {
.kind: static function
.base: `function`
.size: 25
.name: 'format'
.file: 'cmplStd/lib/text/Format.ci:507'
.param .result: int32 (size: 4, cast: variable(i32))
.param value: Datetime (size: 4, cast: const variable(ref))
.param output: char[] (size: 8, cast: variable(arr))
.param format: char[] (size: 8, cast: const variable(arr))
.doc: 'extension method for backward compatibility, using english region'
.value: {
	static const monthsLongEn: char[][] := {
		monthsLongEn := monthsLongEn.init;
		monthsLongEn.init[0] := ("January");
		monthsLongEn.init[1] := ("February");
		monthsLongEn.init[2] := ("March");
		monthsLongEn.init[3] := ("April");
		monthsLongEn.init[4] := ("May");
		monthsLongEn.init[5] := ("June");
		monthsLongEn.init[6] := ("July");
		monthsLongEn.init[7] := ("August");
		monthsLongEn.init[8] := ("September");
		monthsLongEn.init[9] := ("October");
		monthsLongEn.init[10] := ("November");
		monthsLongEn.init[11] := ("December");
	};
	static const monthsShortEn: char[][] := {
		monthsShortEn := monthsShortEn.init;
		monthsShortEn.init[0] := ("Jan");
		monthsShortEn.init[1] := ("Feb");
		monthsShortEn.init[2] := ("Mar");
		monthsShortEn.init[3] := ("Apr");
		monthsShortEn.init[4] := ("May");
		monthsShortEn.init[5] := ("Jun");
		monthsShortEn.init[6] := ("Jul");
		monthsShortEn.init[7] := ("Aug");
		monthsShortEn.init[8] := ("Sep");
		monthsShortEn.init[9] := ("Oct");
		monthsShortEn.init[10] := ("Nov");
		monthsShortEn.init[11] := ("Dec");
	};
	static const weeksLongEn: char[][] := {
		weeksLongEn := weeksLongEn.init;
		weeksLongEn.init[0] := ("Monday");
		weeksLongEn.init[1] := ("Tuesday");
		weeksLongEn.init[2] := ("Wednesday");
		weeksLongEn.init[3] := ("Thursday");
		weeksLongEn.init[4] := ("Friday");
		weeksLongEn.init[5] := ("Saturday");
		weeksLongEn.init[6] := ("Sunday");
	};
	static const weeksShortEn: char[][] := {
		weeksShortEn := weeksShortEn.init;
		weeksShortEn.init[0] := ("Mon");
		weeksShortEn.init[1] := ("Tue");
		weeksShortEn.init[2] := ("Wed");
		weeksShortEn.init[3] := ("Thu");
		weeksShortEn.init[4] := ("Fri");
		weeksShortEn.init[5] := ("Sat");
		weeksShortEn.init[6] := ("Sun");
	};
	static const amPmUpperEn: char[][] := {
		amPmUpperEn := amPmUpperEn.init;
		amPmUpperEn.init[0] := ("AM");
		amPmUpperEn.init[1] := ("PM");
	};
	static const amPmLowerEn: char[][] := {
		amPmLowerEn := amPmLowerEn.init;
		amPmLowerEn.init[0] := ("am");
		amPmLowerEn.init[1] := ("pm");
	};
	static const fmtEN: DatetimeFormat := {
		fmtEN.monthsLong := (monthsLongEn);
		fmtEN.monthsShort := (monthsShortEn);
		fmtEN.weeksLong := (weeksLongEn);
		fmtEN.weeksShort := (weeksShortEn);
		fmtEN.amPmUpper := (amPmUpperEn);
		fmtEN.amPmLower := (amPmLowerEn);
		fmtEN.dateLong := ("%A %d %B %Y");
		fmtEN.timeLong := ("%r");
		fmtEN.dateShort := ("%x");
		fmtEN.timeShort := ("%I:%M %p");
	};
	return .result := DatetimeFormat.format(fmtEN, output, value, format);
}
.instructions: (25 bytes)
	cmplStd/lib/text/Format.ci:558: (25 bytes): return .result := DatetimeFormat.format(fmtEN, output, value, format);
	<format>  : load.z32
	<format+?>: load.ref <?> ;format.fmtEN
	<format+?>: dup.x64 sp(5)
	<format+?>: dup.x32 sp(9)
	<format+?>: dup.x64 sp(6)
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-24)
	<format+?>: set.x32 sp(7)
	<format+?>: ret
.usages:
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static function
.base: `function`
.size: 31
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:563'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		format.sign := (0);
		format.padChr := (0);
		format.width := 0;
		format.precision := 10;
		format.trimDecimal := true;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (31 bytes)
	cmplStd/lib/text/Format.ci:565: (31 bytes): return .result := append(output, pos, value, format);
	<append>  : load.z32
	<append+?>: dup.x64 sp(4)
	<append+?>: dup.x32 sp(5)
	<append+?>: load.c32 10
	<append+?>: dup.x32 sp(6)
	<append+?>: i32.2i64
	<append+?>: load.ref <?> ;append.format
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(6)
	<append+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:529: referenced as `append`
	cmplGfx/lib/micro.ui.ci:523: referenced as `append`
	cmplGfx/lib/micro.ui.ci:517: referenced as `append`
	cmplGfx/lib/window.ci:363: referenced as `append`
	cmplGfx/lib/window.ci:361: referenced as `append`
	cmplGfx/lib/window.ci:359: referenced as `append`
	cmplGfx/lib/window.ci:357: referenced as `append`
	cmplGfx/lib/window.ci:128: referenced as `append`
	cmplGfx/lib/window.ci:109: referenced as `append`
}
Closeable: object {
.kind: static const typename(ref)
.base: `object`
.size: 8
.name: 'Closeable'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:2'
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Represents the base class of closeable objects like files, streams, etc'
.usages:
	cmplFile/lib.ci:16: referenced as `Closeable`
	cmplStd/lib/text/stream/TextStream.ci:74: referenced as `Closeable`
	cmplStd/lib/text/stream/TextStream.ci:48: referenced as `Closeable`
	cmplStd/lib/text/stream/TextStream.ci:21: referenced as `Closeable`
	cmplStd/lib/text/stream/TextStream.ci:7: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:115: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:114: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:44: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:17: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:7: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:5: referenced as `Closeable`
}
Closeable.close(this: Closeable): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'close'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:5'
.owner: Closeable
.param .result: void (size: 0, cast: variable(void))
.param this: Closeable (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:12: referenced as `close`
	cmplStd/lib/text/stream/ByteStream.ci:8: referenced as `close`
	internal usages: 3
}
Closeable.closeSafe(this: Closeable): void: function {
.kind: static function
.base: `function`
.size: 33
.name: 'closeSafe'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:7'
.owner: Closeable
.param .result: void (size: 0, cast: variable(void))
.param this: Closeable (size: 4, cast: variable(ref))
.value: {
	if ((this.close) == null) {
		return;
	}
	this.close(this);
}
.instructions: (33 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:8: (18 bytes): if ((this.close) == null)
	<closeSafe>  : dup.x32 sp(1)
	<closeSafe+?>: inc.i32(+4)
	<closeSafe+?>: load.i32
	<closeSafe+?>: load.ref <?> ;null
	<closeSafe+?>: ceq.i32
	<closeSafe+?>: jz +5
	cmplStd/lib/text/stream/ByteStream.ci:10: (1 byte): return;
	<closeSafe+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:12: (14 bytes): this.close(this);
	<closeSafe+?>: dup.x32 sp(1)
	<closeSafe+?>: dup.x32 sp(2)
	<closeSafe+?>: inc.i32(+4)
	<closeSafe+?>: load.i32
	<closeSafe+?>: call
	<closeSafe+?>: inc.sp(-4)
	<closeSafe+?>: ret
.usages:
	cmplStd/lib/text/stream/TextStream.ci:74: referenced as `closeSafe`
	cmplStd/lib/text/stream/TextStream.ci:21: referenced as `closeSafe`
	cmplStd/lib/text/stream/ByteStream.ci:115: referenced as `closeSafe`
	cmplStd/lib/text/stream/ByteStream.ci:114: referenced as `closeSafe`
}
ByteReader: Closeable {
.kind: static const typename(ref)
.base: `Closeable`
.size: 12
.name: 'ByteReader'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:17'
.field read: function (size: 4, cast: variable(ref))
.field read: function (size: 59, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'ByteReader can be used to read bytes from a stream (~= java:InputStream)'
.usages:
	cmplFile/lib/FileStream.ci:2: referenced as `ByteReader`
	cmplStd/lib/text/encoding/Utf8.ci:7: referenced as `ByteReader`
	cmplStd/lib/text/encoding/Ascii.ci:5: referenced as `ByteReader`
	cmplStd/lib/text/encoding/binary/Base64.ci:166: referenced as `ByteReader`
	cmplStd/lib/text/encoding/binary/Base64.ci:156: referenced as `ByteReader`
	cmplStd/lib/text/encoding/binary/Base64.ci:135: referenced as `ByteReader`
	cmplStd/lib/text/stream/TextStream.ci:10: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:100: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:99: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:76: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:26: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:23: referenced as `ByteReader`
}
ByteReader.read(this: ByteReader, bytes: uint8[]): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:23'
.owner: ByteReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteReader (size: 4, cast: variable(ref))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of bytes read from the stream into the `bytes` array
in case there is an error -1 should be returned'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:35: referenced as `read`
	cmplStd/lib/text/encoding/Utf8.ci:26: referenced as `read`
	cmplStd/lib/text/encoding/Utf8.ci:18: referenced as `read`
	cmplStd/lib/text/encoding/Utf8.ci:9: referenced as `read`
	cmplStd/lib/text/encoding/Ascii.ci:8: referenced as `read`
	cmplStd/lib/text/encoding/binary/Base64.ci:170: referenced as `read`
	cmplStd/lib/text/stream/ByteStream.ci:105: referenced as `read`
	cmplStd/lib/text/stream/ByteStream.ci:80: referenced as `read`
	cmplStd/lib/text/stream/ByteStream.ci:28: referenced as `read`
	internal usages: 1
}
ByteReader.read(this: ByteReader): int32: function {
.kind: static function
.base: `function`
.size: 59
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:26'
.owner: ByteReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteReader (size: 4, cast: variable(ref))
.doc: 'Read a single byte from the stream, a negative number is returned in case of error'
.value: {
	bytes: uint8[1] := {
		bytes[0] := (0);
	};
	if (read(this, bytes) <= 0) {
		return .result := -1;
	}
	return .result := bytes[0];
}
.instructions: (59 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:27: (10 bytes): bytes: uint8[1] := {...}
	<read>  : inc.sp(+4)
	cmplStd/lib/text/stream/ByteStream.ci:27: (6 bytes): bytes[0] := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+4)
	<read+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:28: (37 bytes): if (read(this, bytes) <= 0)
	<read+?>: load.z32
	<read+?>: dup.x32 sp(3)
	<read+?>: load.c32 1
	<read+?>: load.sp(+12)
	<read+?>: dup.x32 sp(6)
	<read+?>: call
	<read+?>: inc.sp(-12)
	<read+?>: load.z32
	<read+?>: cgt.i32
	<read+?>: jnz +16
	cmplStd/lib/text/stream/ByteStream.ci:29: (12 bytes): return .result := -1;
	<read+?>: load.c32 -1
	<read+?>: set.x32 sp(4)
	<read+?>: inc.sp(-4)
	<read+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:31: (12 bytes): return .result := bytes[0];
	<read+?>: load.sp(+0)
	<read+?>: load.iu8
	<read+?>: set.x32 sp(4)
	<read+?>: inc.sp(-4)
	<read+?>: ret
.usages:
}
ByteWriter: Closeable {
.kind: static const typename(ref)
.base: `Closeable`
.size: 16
.name: 'ByteWriter'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:44'
.field write: function (size: 4, cast: variable(ref))
.field flush: function (size: 4, cast: variable(ref))
.field write: function (size: 42, cast: static function)
.field copy: function (size: 112, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'ByteWriter can be used to write bytes to a stream (~= java:OutputStream)'
.usages:
	cmplFile/lib/FileStream.ci:15: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/Utf8.ci:54: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/Ascii.ci:22: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/binary/Base64.ci:44: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/binary/Base64.ci:17: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/binary/Base64.ci:6: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/binary/Base64.ci:2: referenced as `ByteWriter`
	cmplStd/lib/text/stream/TextStream.ci:56: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:101: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:76: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:56: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:53: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:48: referenced as `ByteWriter`
}
ByteWriter.write(this: ByteWriter, bytes: uint8[]): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'write'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:48'
.owner: ByteWriter
.param .result: void (size: 0, cast: variable(void))
.param this: ByteWriter (size: 4, cast: variable(ref))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must write all the bytes from the `bytes` array'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:84: referenced as `write`
	cmplStd/lib/text/encoding/Utf8.ci:75: referenced as `write`
	cmplStd/lib/text/encoding/Utf8.ci:67: referenced as `write`
	cmplStd/lib/text/encoding/Utf8.ci:60: referenced as `write`
	cmplStd/lib/text/encoding/Ascii.ci:25: referenced as `write`
	cmplStd/lib/text/encoding/binary/Base64.ci:34: referenced as `write`
	cmplStd/lib/text/encoding/binary/Base64.ci:30: referenced as `write`
	cmplStd/lib/text/encoding/binary/Base64.ci:25: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:79: referenced as `write`
	cmplStd/lib/text/stream/ByteStream.ci:107: referenced as `write`
	cmplStd/lib/text/stream/ByteStream.ci:84: referenced as `write`
	cmplStd/lib/text/stream/ByteStream.ci:58: referenced as `write`
	internal usages: 2
}
ByteWriter.flush(this: ByteWriter): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'flush'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:53'
.owner: ByteWriter
.param .result: void (size: 0, cast: variable(void))
.param this: ByteWriter (size: 4, cast: variable(ref))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
if a buffer is used directly or indirectly this method must flush all buffered data to the stream.'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:126: referenced as `flush`
	cmplStd/lib/text/stream/TextStream.ci:68: referenced as `flush`
	internal usages: 2
}
ByteWriter.write(this: ByteWriter, oneByte: uint8): void: function {
.kind: static function
.base: `function`
.size: 42
.name: 'write'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:56'
.owner: ByteWriter
.param .result: void (size: 0, cast: variable(void))
.param this: ByteWriter (size: 4, cast: variable(ref))
.param oneByte: uint8 (size: 4, cast: variable(u32))
.doc: 'Write a single byte to the stream'
.value: {
	bytes: uint8[1] := {
		bytes[0] := oneByte;
	};
	return .result := this.write(this, bytes);
}
.instructions: (42 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:57: (14 bytes): bytes: uint8[1] := {...}
	<write>  : inc.sp(+4)
	cmplStd/lib/text/stream/ByteStream.ci:57: (10 bytes): bytes[0] := oneByte;
	<write+?>: load.sp(+8)
	<write+?>: load.iu8
	<write+?>: load.sp(+4)
	<write+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:58: (28 bytes): return .result := this.write(this, bytes);
	<write+?>: dup.x32 sp(3)
	<write+?>: load.c32 1
	<write+?>: load.sp(+8)
	<write+?>: dup.x32 sp(6)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
}
ByteWriter.copy(this: ByteWriter, reader: ByteReader): int32: function {
.kind: static function
.base: `function`
.size: 112
.name: 'copy'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:76'
.owner: ByteWriter
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteWriter (size: 4, cast: variable(ref))
.param reader: ByteReader (size: 4, cast: variable(ref))
.doc: 'Copy all bytes from the reader to the writer'
.value: {
	buffer: uint8[4096] := {
	};
	result: int32 := 0;
	for ( ; ; ) {
		read: int32 := reader.read(reader, buffer);
		if (read <= 0) {
			return .result := result;
		}
		this.write(this, buffer[...read]);
		result := result + read;
	}
	return .result := result;
}
.instructions: (112 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:77: (4 bytes): buffer: uint8[4096] := {...}
	<copy>  : inc.sp(+4096)
	cmplStd/lib/text/stream/ByteStream.ci:78: (1 byte): result: int32 := 0
	<copy+?>: load.z32
	cmplStd/lib/text/stream/ByteStream.ci:79: (95 bytes): for ( ; ; )
	<copy+?>: jmp +91
	cmplStd/lib/text/stream/ByteStream.ci:80: (30 bytes): read: int32 := reader.read(reader, buffer)
	<copy+?>: load.z32
	<copy+?>: load.sp(+4108)
	<copy+?>: load.i32
	<copy+?>: load.c32 4096
	<copy+?>: load.sp(+16)
	<copy+?>: load.sp(+4120)
	<copy+?>: load.i32
	<copy+?>: inc.i32(+8)
	<copy+?>: load.i32
	<copy+?>: call
	<copy+?>: inc.sp(-12)
	cmplStd/lib/text/stream/ByteStream.ci:81: (20 bytes): if (read <= 0)
	<copy+?>: dup.x32 sp(0)
	<copy+?>: load.z32
	<copy+?>: cgt.i32
	<copy+?>: jnz +16
	cmplStd/lib/text/stream/ByteStream.ci:82: (12 bytes): return .result := result;
	<copy+?>: dup.x32 sp(1)
	<copy+?>: load.sp(+4120)
	<copy+?>: store.i32
	<copy+?>: inc.sp(-4104)
	<copy+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:84: (26 bytes): this.write(this, buffer[...read]);
	<copy+?>: load.sp(+4112)
	<copy+?>: load.i32
	<copy+?>: dup.x32 sp(1)
	<copy+?>: load.sp(+16)
	<copy+?>: load.sp(+4124)
	<copy+?>: load.i32
	<copy+?>: inc.i32(+8)
	<copy+?>: load.i32
	<copy+?>: call
	<copy+?>: inc.sp(-12)
	cmplStd/lib/text/stream/ByteStream.ci:85: (7 bytes): result := result + read;
	<copy+?>: dup.x32 sp(1)
	<copy+?>: dup.x32 sp(1)
	<copy+?>: add.i32
	<copy+?>: set.x32 sp(2)
	<copy+?>: inc.sp(-4)
	:: (4 bytes)
	<copy+?>: jmp -87
	cmplStd/lib/text/stream/ByteStream.ci:87: (12 bytes): return .result := result;
	<copy+?>: dup.x32 sp(0)
	<copy+?>: load.sp(+4116)
	<copy+?>: store.i32
	<copy+?>: inc.sp(-4100)
	<copy+?>: ret
.usages:
}
CopyReader: ByteReader {
.kind: static const typename(ref)
.base: `ByteReader`
.size: 20
.name: 'CopyReader'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:99'
.field source: ByteReader (size: 4, cast: const variable(ref))
.field clone: ByteWriter (size: 4, cast: const variable(ref))
.field read: function (size: 56, cast: static function)
.field close: function (size: 35, cast: static function)
.field read: function (size: 4, cast: variable(ref))
.field read: function (size: 59, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:113: referenced as `CopyReader`
	cmplStd/lib/text/stream/ByteStream.ci:104: referenced as `CopyReader`
}
CopyReader.source: ByteReader {
.kind: const variable(ref)
.base: `ByteReader`
.size: 4
.name: 'source'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:100'
.owner: CopyReader
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:114: referenced as `source`
	cmplStd/lib/text/stream/ByteStream.ci:105: referenced as `source`
}
CopyReader.clone: ByteWriter {
.kind: const variable(ref)
.base: `ByteWriter`
.size: 4
.name: 'clone'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:101'
.owner: CopyReader
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:115: referenced as `clone`
	cmplStd/lib/text/stream/ByteStream.ci:107: referenced as `clone`
}
CopyReader.read(this: CopyReader, bytes: uint8[]): int32: function {
.kind: static function
.base: `function`
.size: 56
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:104'
.owner: CopyReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: CopyReader (size: 4, cast: variable(ref))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of bytes read from the stream into the `bytes` array
in case there is an error -1 should be returned'
.value: {
	result: int32 := read(this.source, bytes);
	if (result > 0) {
		this.clone.write(this.clone, bytes[...result]);
	}
	return .result := result;
}
.instructions: (56 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:105: (17 bytes): result: int32 := read(this.source, bytes)
	<read>  : load.z32
	<read+?>: dup.x32 sp(4)
	<read+?>: inc.i32(+12)
	<read+?>: load.i32
	<read+?>: dup.x64 sp(3)
	<read+?>: dup.x32 sp(7)
	<read+?>: call
	<read+?>: inc.sp(-12)
	cmplStd/lib/text/stream/ByteStream.ci:106: (36 bytes): if (result > 0)
	<read+?>: dup.x32 sp(0)
	<read+?>: load.z32
	<read+?>: cgt.i32
	<read+?>: jz +32
	cmplStd/lib/text/stream/ByteStream.ci:107: (28 bytes): this.clone.write(this.clone, bytes[...result]);
	<read+?>: dup.x32 sp(4)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: dup.x32 sp(1)
	<read+?>: dup.x32 sp(4)
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: inc.i32(+8)
	<read+?>: load.i32
	<read+?>: call
	<read+?>: inc.sp(-12)
	cmplStd/lib/text/stream/ByteStream.ci:109: (3 bytes): return .result := result;
	<read+?>: set.x32 sp(5)
	<read+?>: ret
.usages:
}
CopyReader.close(this: CopyReader): void: function {
.kind: static function
.base: `function`
.size: 35
.name: 'close'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:113'
.owner: CopyReader
.param .result: void (size: 0, cast: variable(void))
.param this: CopyReader (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	Closeable.closeSafe(this.source);
	Closeable.closeSafe(this.clone);
}
.instructions: (35 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:114: (17 bytes): Closeable.closeSafe(this.source);
	<close>  : dup.x32 sp(1)
	<close+?>: inc.i32(+12)
	<close+?>: load.i32
	<close+?>: load.ref <?> ;Closeable.closeSafe(this: Closeable): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	cmplStd/lib/text/stream/ByteStream.ci:115: (17 bytes): Closeable.closeSafe(this.clone);
	<close+?>: dup.x32 sp(1)
	<close+?>: inc.i32(+16)
	<close+?>: load.i32
	<close+?>: load.ref <?> ;Closeable.closeSafe(this: Closeable): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	<close+?>: ret
.usages:
}
ByteBuffer: typename {
.kind: static const typename(val)
.base: `typename`
.size: 40
.name: 'ByteBuffer'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:120'
.field position: int32 (size: 4, cast: variable(i32))
.field capacity: int32 (size: 4, cast: variable(i32))
.field length: int32 (size: 4, cast: variable(i32))
.field buffer: uint8[*] (size: 4, cast: variable(ref))
.field read: function (size: 75, cast: static function)
.field read: function (size: 4, cast: const variable(ref))
.field read: function (size: 34, cast: static function)
.field read: function (size: 4, cast: const variable(ref))
.field write: function (size: 154, cast: static function)
.field write: function (size: 4, cast: const variable(ref))
.field flush: function (size: 1, cast: static function)
.field flush: function (size: 4, cast: const variable(ref))
.field close: function (size: 28, cast: static function)
.field close: function (size: 4, cast: const variable(ref))
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:179: referenced as `ByteBuffer`
	cmplStd/lib/text/stream/ByteStream.ci:175: referenced as `ByteBuffer`
	cmplStd/lib/text/stream/ByteStream.ci:149: referenced as `ByteBuffer`
	cmplStd/lib/text/stream/ByteStream.ci:140: referenced as `ByteBuffer`
	cmplStd/lib/text/stream/ByteStream.ci:126: referenced as `ByteBuffer`
}
ByteBuffer.position: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'position'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:121'
.owner: ByteBuffer
.value: 0
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:184: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:171: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:170: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:161: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:150: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:145: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:144: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:141: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:135: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:134: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:131: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:127: referenced as `position`
}
ByteBuffer.capacity: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'capacity'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:122'
.owner: ByteBuffer
.value: 32
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:185: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:156: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:154: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:153: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:151: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `capacity`
}
ByteBuffer.length: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'length'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:123'
.owner: ByteBuffer
.value: 0
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:186: referenced as `length`
	cmplStd/lib/text/stream/ByteStream.ci:141: referenced as `length`
	cmplStd/lib/text/stream/ByteStream.ci:131: referenced as `length`
	cmplStd/lib/text/stream/ByteStream.ci:127: referenced as `length`
}
ByteBuffer.buffer: uint8[*] {
.kind: variable(ref)
.base: `uint8[*]`
.size: 4
.name: 'buffer'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:124'
.owner: ByteBuffer
.value: pointer.alloc(null, capacity)
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:183: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:181: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:170: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:165: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:164: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:162: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:144: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:134: referenced as `buffer`
}
ByteBuffer.read(this: ByteBuffer, bytes: uint8[]): int32: function {
.kind: static function
.base: `function`
.size: 75
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:126'
.owner: ByteBuffer
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteBuffer (size: 40, cast: variable(val))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.value: {
	if (this.position >= this.length) {
		return .result := -1;
	}
	for (i: int32 := 0; i < (bytes.length); i := i + 1) {
		if (this.position >= this.length) {
			return .result := i;
		}
		bytes[i] := this.buffer[this.position];
		this.position := this.position + 1;
	}
	return .result := bytes.length;
}
.instructions: (75 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:127: (17 bytes): if (this.position >= this.length)
	<read>  : dup.x32 sp(3)
	<read+?>: dup.x32 sp(6)
	<read+?>: clt.i32
	<read+?>: jnz +12
	cmplStd/lib/text/stream/ByteStream.ci:128: (8 bytes): return .result := -1;
	<read+?>: load.c32 -1
	<read+?>: set.x32 sp(14)
	<read+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:130: (54 bytes): for (i: int32 := 0; i < (bytes.length); i := i + 1)
	<read+?>: load.z32
	<read+?>: jmp +40
	cmplStd/lib/text/stream/ByteStream.ci:131: (12 bytes): if (this.position >= this.length)
	<read+?>: dup.x32 sp(4)
	<read+?>: dup.x32 sp(7)
	<read+?>: clt.i32
	<read+?>: jnz +7
	cmplStd/lib/text/stream/ByteStream.ci:132: (3 bytes): return .result := i;
	<read+?>: set.x32 sp(14)
	<read+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:134: (12 bytes): bytes[i] := this.buffer[this.position];
	<read+?>: dup.x32 sp(7)
	<read+?>: dup.x32 sp(5)
	<read+?>: add.i32
	<read+?>: load.iu8
	<read+?>: dup.x32 sp(3)
	<read+?>: dup.x32 sp(2)
	<read+?>: add.i32
	<read+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:135: (8 bytes): this.position := this.position + 1;
	<read+?>: dup.x32 sp(4)
	<read+?>: inc.i32(+1)
	<read+?>: set.x32 sp(5)
	cmplStd/lib/text/stream/ByteStream.ci:130: (4 bytes): i := i + 1
	<read+?>: inc.i32(+1)
	cmplStd/lib/text/stream/ByteStream.ci:130: (9 bytes): i < (bytes.length)
	<read+?>: dup.x32 sp(0)
	<read+?>: dup.x32 sp(4)
	<read+?>: clt.i32
	<read+?>: jnz -41
	<read+?>: inc.sp(-4)
	cmplStd/lib/text/stream/ByteStream.ci:137: (4 bytes): return .result := bytes.length;
	<read+?>: mov.x32 sp(13, 2)
	<read+?>: ret
.usages:
}
ByteBuffer.read(this: ByteBuffer, bytes: uint8[]): int32: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:126'
.owner: ByteBuffer
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteBuffer (size: 40, cast: variable(val))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.value: read
.usages:
}
ByteBuffer.read(this: ByteBuffer): int32: function {
.kind: static function
.base: `function`
.size: 34
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:140'
.owner: ByteBuffer
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: {
	if (this.position >= this.length) {
		return .result := -1;
	}
	result: int32 := this.buffer[this.position];
	this.position := this.position + 1;
	return .result := result;
}
.instructions: (34 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:141: (17 bytes): if (this.position >= this.length)
	<read>  : dup.x32 sp(1)
	<read+?>: dup.x32 sp(4)
	<read+?>: clt.i32
	<read+?>: jnz +12
	cmplStd/lib/text/stream/ByteStream.ci:142: (8 bytes): return .result := -1;
	<read+?>: load.c32 -1
	<read+?>: set.x32 sp(12)
	<read+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:144: (6 bytes): result: int32 := this.buffer[this.position]
	<read+?>: dup.x32 sp(4)
	<read+?>: dup.x32 sp(2)
	<read+?>: add.i32
	<read+?>: load.iu8
	cmplStd/lib/text/stream/ByteStream.ci:145: (8 bytes): this.position := this.position + 1;
	<read+?>: dup.x32 sp(2)
	<read+?>: inc.i32(+1)
	<read+?>: set.x32 sp(3)
	cmplStd/lib/text/stream/ByteStream.ci:146: (3 bytes): return .result := result;
	<read+?>: set.x32 sp(12)
	<read+?>: ret
.usages:
}
ByteBuffer.read(this: ByteBuffer): int32: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:140'
.owner: ByteBuffer
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: read
.usages:
}
ByteBuffer.write(this: ByteBuffer, bytes: uint8[]): void: function {
.kind: static function
.base: `function`
.size: 154
.name: 'write'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:149'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.value: {
	size: int32 := this.position + (bytes.length);
	if (size >= this.capacity) {
		this.capacity := this.capacity * 2;
		if (size > 2 * this.capacity) {
			this.capacity := size * 2;
		}
		new: uint8[*] := pointer.alloc(null, this.capacity);
		for (i: int32 := 0; i < this.position; i := i + 1) {
			new[i] := this.buffer[i];
		}
		pointer.alloc(this.buffer, 0);
		this.buffer := (new);
	}
	for (i: int32 := 0; i < (bytes.length); i := i + 1) {
		this.buffer[this.position] := bytes[i];
		this.position := this.position + 1;
	}
}
.instructions: (154 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:150: (5 bytes): size: int32 := this.position + (bytes.length)
	<write>  : dup.x32 sp(3)
	<write+?>: dup.x32 sp(3)
	<write+?>: add.i32
	cmplStd/lib/text/stream/ByteStream.ci:151: (102 bytes): if (size >= this.capacity)
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(6)
	<write+?>: clt.i32
	<write+?>: jnz +97
	cmplStd/lib/text/stream/ByteStream.ci:153: (10 bytes): this.capacity := this.capacity * 2;
	<write+?>: dup.x32 sp(5)
	<write+?>: load.c32 2
	<write+?>: mul.i32
	<write+?>: set.x32 sp(6)
	cmplStd/lib/text/stream/ByteStream.ci:154: (25 bytes): if (size > 2 * this.capacity)
	<write+?>: dup.x32 sp(0)
	<write+?>: load.c32 2
	<write+?>: dup.x32 sp(7)
	<write+?>: mul.i32
	<write+?>: cgt.i32
	<write+?>: jz +14
	cmplStd/lib/text/stream/ByteStream.ci:156: (10 bytes): this.capacity := size * 2;
	<write+?>: dup.x32 sp(0)
	<write+?>: load.c32 2
	<write+?>: mul.i32
	<write+?>: set.x32 sp(6)
	cmplStd/lib/text/stream/ByteStream.ci:160: (11 bytes): new: uint8[*] := pointer.alloc(null, this.capacity)
	<write+?>: load.ref <?> ;null
	<write+?>: dup.x32 sp(6)
	<write+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/lib/text/stream/ByteStream.ci:161: (34 bytes): for (i: int32 := 0; i < this.position; i := i + 1)
	<write+?>: load.z32
	<write+?>: jmp +20
	cmplStd/lib/text/stream/ByteStream.ci:162: (12 bytes): new[i] := this.buffer[i];
	<write+?>: dup.x32 sp(9)
	<write+?>: dup.x32 sp(1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(2)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:161: (4 bytes): i := i + 1
	<write+?>: inc.i32(+1)
	cmplStd/lib/text/stream/ByteStream.ci:161: (9 bytes): i < this.position
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(7)
	<write+?>: clt.i32
	<write+?>: jnz -21
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/stream/ByteStream.ci:164: (11 bytes): pointer.alloc(this.buffer, 0);
	<write+?>: dup.x32 sp(8)
	<write+?>: load.z32
	<write+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<write+?>: inc.sp(-4)
	<write+?>: set.x32 sp(8)
	<write+?>: load.z32
	<write+?>: jmp +28
	cmplStd/lib/text/stream/ByteStream.ci:170: (12 bytes): this.buffer[this.position] := bytes[i];
	<write+?>: dup.x32 sp(3)
	<write+?>: dup.x32 sp(1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(9)
	<write+?>: dup.x32 sp(7)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:171: (8 bytes): this.position := this.position + 1;
	<write+?>: dup.x32 sp(5)
	<write+?>: inc.i32(+1)
	<write+?>: set.x32 sp(6)
	cmplStd/lib/text/stream/ByteStream.ci:169: (4 bytes): i := i + 1
	<write+?>: inc.i32(+1)
	cmplStd/lib/text/stream/ByteStream.ci:169: (9 bytes): i < (bytes.length)
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(5)
	<write+?>: clt.i32
	<write+?>: jnz -29
	<write+?>: inc.sp(-4)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
}
ByteBuffer.write(this: ByteBuffer, bytes: uint8[]): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'write'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:149'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.value: write
.usages:
}
ByteBuffer.flush(this: ByteBuffer): void: function {
.kind: static function
.base: `function`
.size: 1
.name: 'flush'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:175'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: {
}
.instructions: (1 byte)
	<flush>  : ret
.usages:
}
ByteBuffer.flush(this: ByteBuffer): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'flush'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:175'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: flush
.usages:
}
ByteBuffer.close(this: ByteBuffer): void: function {
.kind: static function
.base: `function`
.size: 28
.name: 'close'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:179'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: {
	pointer.alloc(this.buffer, 0);
	this.buffer := (null);
	this.position := 0;
	this.capacity := 0;
	this.length := 0;
}
.instructions: (28 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:181: (11 bytes): pointer.alloc(this.buffer, 0);
	<close>  : dup.x32 sp(4)
	<close+?>: load.z32
	<close+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<close+?>: inc.sp(-4)
	cmplStd/lib/text/stream/ByteStream.ci:183: (7 bytes): this.buffer := (null);
	<close+?>: load.ref <?> ;null
	<close+?>: set.x32 sp(5)
	cmplStd/lib/text/stream/ByteStream.ci:184: (3 bytes): this.position := 0;
	<close+?>: load.z32
	<close+?>: set.x32 sp(2)
	cmplStd/lib/text/stream/ByteStream.ci:185: (3 bytes): this.capacity := 0;
	<close+?>: load.z32
	<close+?>: set.x32 sp(3)
	cmplStd/lib/text/stream/ByteStream.ci:186: (3 bytes): this.length := 0;
	<close+?>: load.z32
	<close+?>: set.x32 sp(4)
	<close+?>: ret
.usages:
}
ByteBuffer.close(this: ByteBuffer): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'close'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:179'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: close
.usages:
}
unicode: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'unicode'
.file: 'cmplStd/lib/text/stream/TextStream.ci:3'
.value: uint32
.usages:
}
TextReader: Closeable {
.kind: static const typename(ref)
.base: `Closeable`
.size: 16
.name: 'TextReader'
.file: 'cmplStd/lib/text/stream/TextStream.ci:7'
.field reader: ByteReader (size: 4, cast: const variable(ref))
.field decode: function (size: 4, cast: variable(ref))
.field close: function (size: 18, cast: static function)
.field decode: function (size: 55, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'TextReader can be used to read decoded text from a stream, including basic parsing'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:2: referenced as `TextReader`
	cmplStd/lib/text/encoding/Ascii.ci:2: referenced as `TextReader`
	cmplStd/lib/text/stream/TextStream.ci:168: referenced as `TextReader`
	cmplStd/lib/text/stream/TextStream.ci:25: referenced as `TextReader`
	cmplStd/lib/text/stream/TextStream.ci:19: referenced as `TextReader`
	cmplStd/lib/text/stream/TextStream.ci:16: referenced as `TextReader`
}
TextReader.reader: ByteReader {
.kind: const variable(ref)
.base: `ByteReader`
.size: 4
.name: 'reader'
.file: 'cmplStd/lib/text/stream/TextStream.ci:10'
.owner: TextReader
.doc: '@public'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:7: referenced as `reader`
	cmplStd/lib/text/encoding/Ascii.ci:5: referenced as `reader`
	cmplStd/lib/text/stream/TextStream.ci:21: referenced as `reader`
}
TextReader.decode(this: TextReader, chars: uint32[]): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'decode'
.file: 'cmplStd/lib/text/stream/TextStream.ci:16'
.owner: TextReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: TextReader (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of characters decoded from the stream into the `chars` array
in case there is an error -1 should be returned'
.usages:
	cmplStd/lib/text/stream/TextStream.ci:172: referenced as `decode`
	cmplStd/lib/text/stream/TextStream.ci:27: referenced as `decode`
}
TextReader.close(this: TextReader): void: function {
.kind: static function
.base: `function`
.size: 18
.name: 'close'
.file: 'cmplStd/lib/text/stream/TextStream.ci:19'
.owner: TextReader
.param .result: void (size: 0, cast: variable(void))
.param this: TextReader (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	Closeable.closeSafe(this.reader);
}
.instructions: (18 bytes)
	cmplStd/lib/text/stream/TextStream.ci:21: (17 bytes): Closeable.closeSafe(this.reader);
	<close>  : dup.x32 sp(1)
	<close+?>: inc.i32(+8)
	<close+?>: load.i32
	<close+?>: load.ref <?> ;Closeable.closeSafe(this: Closeable): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	<close+?>: ret
.usages:
}
TextReader.decode(this: TextReader): int32: function {
.kind: static function
.base: `function`
.size: 55
.name: 'decode'
.file: 'cmplStd/lib/text/stream/TextStream.ci:25'
.owner: TextReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: TextReader (size: 4, cast: variable(ref))
.doc: 'Read a single character from the stream, a negative number is returned in case of error'
.value: {
	chars: uint32[1] := {
		chars[0] := (0);
	};
	if (decode(this, chars) <= 0) {
		return .result := -1;
	}
	return .result := chars[0] & (16777215);
}
.instructions: (55 bytes)
	cmplStd/lib/text/stream/TextStream.ci:26: (7 bytes): chars: uint32[1] := {...}
	<decode>  : inc.sp(+4)
	cmplStd/lib/text/stream/TextStream.ci:26: (3 bytes): chars[0] := (0);
	<decode+?>: load.z32
	<decode+?>: set.x32 sp(1)
	cmplStd/lib/text/stream/TextStream.ci:27: (37 bytes): if (decode(this, chars) <= 0)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(3)
	<decode+?>: load.c32 1
	<decode+?>: load.sp(+12)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.z32
	<decode+?>: cgt.i32
	<decode+?>: jnz +16
	cmplStd/lib/text/stream/TextStream.ci:28: (12 bytes): return .result := -1;
	<decode+?>: load.c32 -1
	<decode+?>: set.x32 sp(4)
	<decode+?>: inc.sp(-4)
	<decode+?>: ret
	cmplStd/lib/text/stream/TextStream.ci:30: (11 bytes): return .result := chars[0] & (16777215);
	<decode+?>: dup.x32 sp(0)
	<decode+?>: b32.and 0xffffff
	<decode+?>: set.x32 sp(4)
	<decode+?>: inc.sp(-4)
	<decode+?>: ret
.usages:
}
TextWriter: Closeable {
.kind: static const typename(ref)
.base: `Closeable`
.size: 36
.name: 'TextWriter'
.file: 'cmplStd/lib/text/stream/TextStream.ci:48'
.field Writeable: object (size: 8, cast: static const typename(ref))
.field writer: ByteWriter (size: 4, cast: const variable(ref))
.field format: FormatFlags (size: 16, cast: const variable(val))
.field encode: function (size: 4, cast: variable(ref))
.field flush: function (size: 25, cast: static function)
.field flush: function (size: 4, cast: const variable(ref))
.field close: function (size: 18, cast: static function)
.field write: function (size: 30, cast: static function)
.field write: function (size: 46, cast: static function)
.field write: function (size: 67, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 71, cast: static function)
.field write: function (size: 70, cast: static function)
.field write: function (size: 20, cast: static function)
.field writeln: function (size: 29, cast: static function)
.field writeln: function (size: 35, cast: static function)
.field copy: function (size: 107, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'TextWriter can be used to write encoded text to a stream, including basic printing'
.usages:
	cmplStd/lib/math/Polynomial.ci:14: referenced as `TextWriter`
	cmplStd/lib/math/Polynomial.ci:4: referenced as `TextWriter`
	cmplStd/lib/text/encoding/Utf8.ci:51: referenced as `TextWriter`
	cmplStd/lib/text/encoding/Ascii.ci:21: referenced as `TextWriter`
	cmplStd/lib/text/encoding/Ascii.ci:19: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:168: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:146: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:146: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:140: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:140: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:133: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:133: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:126: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:126: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:119: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:119: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:112: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:112: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:105: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:105: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:98: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:98: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:90: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:90: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:84: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:84: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:78: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:78: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:72: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:67: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:64: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:52: referenced as `TextWriter`
}
TextWriter.Writeable: object {
.kind: static const typename(ref)
.base: `object`
.size: 8
.name: 'Writeable'
.file: 'cmplStd/lib/text/stream/TextStream.ci:50'
.owner: TextWriter
.field write: function (size: 4, cast: variable(ref))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplStd/lib/math/Polynomial.ci:4: referenced as `Writeable`
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `Writeable`
	cmplStd/lib/text/stream/TextStream.ci:140: referenced as `Writeable`
	cmplStd/lib/text/stream/TextStream.ci:52: referenced as `Writeable`
}
TextWriter.Writeable.write(this: Writeable, writer: TextWriter): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:52'
.owner: TextWriter.Writeable
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter.Writeable (size: 4, cast: variable(ref))
.param writer: TextWriter (size: 4, cast: variable(ref))
.usages:
	cmplStd/lib/text/stream/TextStream.ci:141: referenced as `write`
	internal usages: 1
}
TextWriter.writer: ByteWriter {
.kind: const variable(ref)
.base: `ByteWriter`
.size: 4
.name: 'writer'
.file: 'cmplStd/lib/text/stream/TextStream.ci:56'
.owner: TextWriter
.doc: '@public'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:54: referenced as `writer`
	cmplStd/lib/text/encoding/Ascii.ci:22: referenced as `writer`
	cmplStd/lib/text/stream/TextStream.ci:79: referenced as `writer`
	cmplStd/lib/text/stream/TextStream.ci:74: referenced as `writer`
	cmplStd/lib/text/stream/TextStream.ci:68: referenced as `writer`
}
TextWriter.format: FormatFlags {
.kind: const variable(val)
.base: `FormatFlags`
.size: 16
.name: 'format'
.file: 'cmplStd/lib/text/stream/TextStream.ci:59'
.owner: TextWriter
.doc: 'default formatter'
.usages:
	cmplStd/lib/math/Polynomial.ci:46: referenced as `format`
	cmplStd/lib/math/Polynomial.ci:39: referenced as `format`
}
TextWriter.encode(this: TextWriter, chars: uint32[]): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'encode'
.file: 'cmplStd/lib/text/stream/TextStream.ci:64'
.owner: TextWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must encode and write all the characters from the `chars` array'
.usages:
	cmplStd/lib/text/stream/TextStream.ci:176: referenced as `encode`
}
TextWriter.flush(this: TextWriter): void: function {
.kind: static function
.base: `function`
.size: 25
.name: 'flush'
.file: 'cmplStd/lib/text/stream/TextStream.ci:67'
.owner: TextWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.value: {
	this.writer.flush(this.writer);
}
.instructions: (25 bytes)
	cmplStd/lib/text/stream/TextStream.ci:68: (24 bytes): this.writer.flush(this.writer);
	<flush>  : dup.x32 sp(1)
	<flush+?>: inc.i32(+8)
	<flush+?>: load.i32
	<flush+?>: dup.x32 sp(2)
	<flush+?>: inc.i32(+8)
	<flush+?>: load.i32
	<flush+?>: inc.i32(+12)
	<flush+?>: load.i32
	<flush+?>: call
	<flush+?>: inc.sp(-4)
	<flush+?>: ret
.usages:
}
TextWriter.flush(this: TextWriter): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'flush'
.file: 'cmplStd/lib/text/stream/TextStream.ci:67'
.owner: TextWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.value: flush
.usages:
}
TextWriter.close(this: TextWriter): void: function {
.kind: static function
.base: `function`
.size: 18
.name: 'close'
.file: 'cmplStd/lib/text/stream/TextStream.ci:72'
.owner: TextWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	Closeable.closeSafe(this.writer);
}
.instructions: (18 bytes)
	cmplStd/lib/text/stream/TextStream.ci:74: (17 bytes): Closeable.closeSafe(this.writer);
	<close>  : dup.x32 sp(1)
	<close+?>: inc.i32(+8)
	<close+?>: load.i32
	<close+?>: load.ref <?> ;Closeable.closeSafe(this: Closeable): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	<close+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: char[]): TextWriter: function {
.kind: static function
.base: `function`
.size: 30
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:78'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: char[] (size: 8, cast: variable(arr))
.doc: 'Write an array of raw characters to the stream (no encoding)'
.value: {
	this.writer.write(this.writer, value);
	return .result := this;
}
.instructions: (30 bytes)
	cmplStd/lib/text/stream/TextStream.ci:79: (26 bytes): this.writer.write(this.writer, value);
	<write>  : dup.x32 sp(3)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: dup.x64 sp(2)
	<write+?>: dup.x32 sp(6)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: call
	<write+?>: inc.sp(-12)
	cmplStd/lib/text/stream/TextStream.ci:80: (4 bytes): return .result := this;
	<write+?>: mov.x32 sp(4, 3)
	<write+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:45: referenced as `write`
	cmplStd/lib/math/Polynomial.ci:43: referenced as `write`
	cmplStd/lib/math/Polynomial.ci:35: referenced as `write`
	cmplStd/lib/math/Polynomial.ci:30: referenced as `write`
	cmplStd/lib/math/Polynomial.ci:26: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:147: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:136: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:129: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:122: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:115: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:108: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:101: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:94: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:92: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:86: referenced as `write`
}
TextWriter.write(this: TextWriter, value: char): TextWriter: function {
.kind: static function
.base: `function`
.size: 46
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:84'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: char (size: 4, cast: variable(i32))
.doc: 'Write a single raw character to the stream (no encoding)'
.value: {
	buffer: char[1] := {
		buffer[0] := value;
	};
	return .result := write(this, buffer);
}
.instructions: (46 bytes)
	cmplStd/lib/text/stream/TextStream.ci:85: (14 bytes): buffer: char[1] := {...}
	<write>  : inc.sp(+4)
	cmplStd/lib/text/stream/TextStream.ci:85: (10 bytes): buffer[0] := value;
	<write+?>: load.sp(+8)
	<write+?>: load.is8
	<write+?>: load.sp(+4)
	<write+?>: store.i8
	cmplStd/lib/text/stream/TextStream.ci:86: (32 bytes): return .result := write(this, buffer);
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.c32 1
	<write+?>: load.sp(+12)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: set.x32 sp(5)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: bool): TextWriter: function {
.kind: static function
.base: `function`
.size: 67
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:90'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: bool (size: 4, cast: variable(bool))
.doc: 'Write the value of the boolean parameter: "true" or "false"'
.value: {
	if (value) {
		return .result := write(this, "true");
	}
	return .result := write(this, "false");
}
.instructions: (67 bytes)
	cmplStd/lib/text/stream/TextStream.ci:91: (38 bytes): if (value)
	<write>  : load.sp(+4)
	<write+?>: load.is8
	<write+?>: jz +33
	cmplStd/lib/text/stream/TextStream.ci:92: (29 bytes): return .result := write(this, "true");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(3)
	<write+?>: load.c32 4
	<write+?>: load.ref <?> ;"true"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: set.x32 sp(4)
	<write+?>: ret
	cmplStd/lib/text/stream/TextStream.ci:94: (29 bytes): return .result := write(this, "false");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(3)
	<write+?>: load.c32 5
	<write+?>: load.ref <?> ;"false"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: set.x32 sp(4)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: int32, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 76
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:98'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: int32 (size: 4, cast: variable(i32))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 32-bit integer parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (76 bytes)
	cmplStd/lib/text/stream/TextStream.ci:99: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:100: (37 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.c32 10
	<write+?>: load.sp(+1052)
	<write+?>: load.i32
	<write+?>: i32.2i64
	<write+?>: load.sp(+1056)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-28)
	cmplStd/lib/text/stream/TextStream.ci:101: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1044)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1048)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:46: referenced as `write`
}
TextWriter.write(this: TextWriter, value: int64, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 75
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:105'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: int64 (size: 8, cast: variable(i64))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 64-bit integer parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (75 bytes)
	cmplStd/lib/text/stream/TextStream.ci:106: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:107: (36 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.c32 10
	<write+?>: load.sp(+1052)
	<write+?>: load.i64
	<write+?>: load.sp(+1056)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-28)
	cmplStd/lib/text/stream/TextStream.ci:108: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1048)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1052)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: uint32, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 76
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:112'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: uint32 (size: 4, cast: variable(u32))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 32-bit unsigned integer parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (76 bytes)
	cmplStd/lib/text/stream/TextStream.ci:113: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:114: (37 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.c32 10
	<write+?>: load.sp(+1052)
	<write+?>: load.i32
	<write+?>: u32.2i64
	<write+?>: load.sp(+1056)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-28)
	cmplStd/lib/text/stream/TextStream.ci:115: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1044)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1048)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: uint64, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 75
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:119'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: uint64 (size: 8, cast: variable(u64))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 64-bit unsigned integer parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (75 bytes)
	cmplStd/lib/text/stream/TextStream.ci:120: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:121: (36 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.c32 10
	<write+?>: load.sp(+1052)
	<write+?>: load.i64
	<write+?>: load.sp(+1056)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-28)
	cmplStd/lib/text/stream/TextStream.ci:122: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1048)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1052)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: float32, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 71
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:126'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: float32 (size: 4, cast: variable(f32))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 32-bit floating-point parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (71 bytes)
	cmplStd/lib/text/stream/TextStream.ci:127: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:128: (32 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.sp(+1048)
	<write+?>: load.i32
	<write+?>: f32.2f64
	<write+?>: load.sp(+1052)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-24)
	cmplStd/lib/text/stream/TextStream.ci:129: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1044)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1048)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: float64, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 70
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:133'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: float64 (size: 8, cast: variable(f64))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 64-bit floating-point parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (70 bytes)
	cmplStd/lib/text/stream/TextStream.ci:134: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:135: (31 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.sp(+1048)
	<write+?>: load.i64
	<write+?>: load.sp(+1052)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-24)
	cmplStd/lib/text/stream/TextStream.ci:136: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1048)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1052)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:39: referenced as `write`
}
TextWriter.write(this: TextWriter, value: Writeable): TextWriter: function {
.kind: static function
.base: `function`
.size: 20
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:140'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: TextWriter.Writeable (size: 4, cast: variable(ref))
.doc: 'Write the value of the writeable parameter'
.value: {
	value.write(value, this);
	return .result := this;
}
.instructions: (20 bytes)
	cmplStd/lib/text/stream/TextStream.ci:141: (16 bytes): value.write(value, this);
	<write>  : dup.x32 sp(1)
	<write+?>: dup.x32 sp(3)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+4)
	<write+?>: load.i32
	<write+?>: call
	<write+?>: inc.sp(-8)
	cmplStd/lib/text/stream/TextStream.ci:142: (4 bytes): return .result := this;
	<write+?>: mov.x32 sp(3, 2)
	<write+?>: ret
.usages:
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `write`
}
TextWriter.writeln(this: TextWriter): TextWriter: function {
.kind: static function
.base: `function`
.size: 29
.name: 'writeln'
.file: 'cmplStd/lib/text/stream/TextStream.ci:146'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.doc: 'Write a newline character'
.value: {
	return .result := write(this, "\n");
}
.instructions: (29 bytes)
	cmplStd/lib/text/stream/TextStream.ci:147: (29 bytes): return .result := write(this, "\n");
	<writeln>  : inc.sp(+4)
	<writeln+?>: dup.x32 sp(2)
	<writeln+?>: load.c32 1
	<writeln+?>: load.ref <?> ;"\n"
	<writeln+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<writeln+?>: call
	<writeln+?>: inc.sp(-12)
	<writeln+?>: set.x32 sp(3)
	<writeln+?>: ret
.usages:
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `writeln`
}
TextWriter.writeln(this: TextWriter, value: Writeable): TextWriter: function {
.kind: static function
.base: `function`
.size: 35
.name: 'writeln'
.file: 'cmplStd/lib/text/stream/TextStream.ci:151'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: TextWriter.Writeable (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	return .result := writeln(write(this, value));
}
.instructions: (35 bytes)
	cmplStd/lib/text/stream/TextStream.ci:151: (35 bytes): return .result := writeln(write(this, value));
	<writeln>  : inc.sp(+4)
	<writeln+?>: inc.sp(+4)
	<writeln+?>: dup.x32 sp(4)
	<writeln+?>: dup.x32 sp(4)
	<writeln+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: Writeable): TextWriter
	<writeln+?>: call
	<writeln+?>: inc.sp(-8)
	<writeln+?>: load.ref <?> ;TextWriter.writeln(this: TextWriter): TextWriter
	<writeln+?>: call
	<writeln+?>: inc.sp(-4)
	<writeln+?>: set.x32 sp(4)
	<writeln+?>: ret
.usages:
}
TextWriter.copy(writer: TextWriter, reader: TextReader): int32: function {
.kind: static function
.base: `function`
.size: 107
.name: 'copy'
.file: 'cmplStd/lib/text/stream/TextStream.ci:168'
.owner: TextWriter
.param .result: int32 (size: 4, cast: variable(i32))
.param writer: TextWriter (size: 4, cast: variable(ref))
.param reader: TextReader (size: 4, cast: variable(ref))
.doc: 'Convert from one encoding to another one.
@returns converted character count.
	 * example: convert utf-8 encoded file to ascii
TextWriter output = AsciiWriter("out.txt");
TextReader input = Utf8Reader("in.txt");
output.write(input);'
.value: {
	buffer: uint32[1024] := {
	};
	result: int32 := 0;
	for ( ; ; ) {
		n: int32 := reader.decode(reader, buffer);
		if (n <= 0) {
			return .result := result;
		}
		encode(writer, buffer[...n]);
		result := result + n;
	}
	return .result := result;
}
.instructions: (107 bytes)
	cmplStd/lib/text/stream/TextStream.ci:169: (4 bytes): buffer: uint32[1024] := {...}
	<copy>  : inc.sp(+4096)
	cmplStd/lib/text/stream/TextStream.ci:170: (1 byte): result: int32 := 0
	<copy+?>: load.z32
	cmplStd/lib/text/stream/TextStream.ci:171: (90 bytes): for ( ; ; )
	<copy+?>: jmp +86
	cmplStd/lib/text/stream/TextStream.ci:172: (30 bytes): n: int32 := reader.decode(reader, buffer)
	<copy+?>: load.z32
	<copy+?>: load.sp(+4108)
	<copy+?>: load.i32
	<copy+?>: load.c32 1024
	<copy+?>: load.sp(+16)
	<copy+?>: load.sp(+4120)
	<copy+?>: load.i32
	<copy+?>: inc.i32(+12)
	<copy+?>: load.i32
	<copy+?>: call
	<copy+?>: inc.sp(-12)
	cmplStd/lib/text/stream/TextStream.ci:173: (20 bytes): if (n <= 0)
	<copy+?>: dup.x32 sp(0)
	<copy+?>: load.z32
	<copy+?>: cgt.i32
	<copy+?>: jnz +16
	cmplStd/lib/text/stream/TextStream.ci:174: (12 bytes): return .result := result;
	<copy+?>: dup.x32 sp(1)
	<copy+?>: load.sp(+4120)
	<copy+?>: store.i32
	<copy+?>: inc.sp(-4104)
	<copy+?>: ret
	cmplStd/lib/text/stream/TextStream.ci:176: (21 bytes): encode(writer, buffer[...n]);
	<copy+?>: load.sp(+4112)
	<copy+?>: load.i32
	<copy+?>: dup.x32 sp(1)
	<copy+?>: load.sp(+16)
	<copy+?>: load.sp(+4104)
	<copy+?>: load.i32
	<copy+?>: call
	<copy+?>: inc.sp(-12)
	cmplStd/lib/text/stream/TextStream.ci:177: (7 bytes): result := result + n;
	<copy+?>: dup.x32 sp(1)
	<copy+?>: dup.x32 sp(1)
	<copy+?>: add.i32
	<copy+?>: set.x32 sp(2)
	<copy+?>: inc.sp(-4)
	:: (4 bytes)
	<copy+?>: jmp -82
	cmplStd/lib/text/stream/TextStream.ci:179: (12 bytes): return .result := result;
	<copy+?>: dup.x32 sp(0)
	<copy+?>: load.sp(+4116)
	<copy+?>: store.i32
	<copy+?>: inc.sp(-4100)
	<copy+?>: ret
.usages:
}
Base64Encoder: ByteWriter {
.kind: static const typename(ref)
.base: `ByteWriter`
.size: 1060
.name: 'Base64Encoder'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:2'
.field lookup: uint8[] (size: 8, cast: static const variable(arr))
.field writer: ByteWriter (size: 4, cast: const variable(ref))
.field buffer: uint8[1024] (size: 1024, cast: variable(val))
.field bufferSize: int32 (size: 4, cast: variable(i32))
.field padding: int32 (size: 4, cast: variable(i32))
.field wrap: int32 (size: 4, cast: const variable(i32))
.field wrapSize: int32 (size: 4, cast: variable(i32))
.field flushBuffer: function (size: 232, cast: static function)
.field write: function (size: 896, cast: static function)
.field flush: function (size: 27, cast: static function)
.field close: function (size: 13, cast: static function)
.field write: function (size: 4, cast: variable(ref))
.field flush: function (size: 4, cast: variable(ref))
.field write: function (size: 42, cast: static function)
.field copy: function (size: 112, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Base64 encoder'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:129: referenced as `Base64Encoder`
	cmplStd/lib/text/encoding/binary/Base64.ci:124: referenced as `Base64Encoder`
	cmplStd/lib/text/encoding/binary/Base64.ci:41: referenced as `Base64Encoder`
	cmplStd/lib/text/encoding/binary/Base64.ci:16: referenced as `Base64Encoder`
}
Base64Encoder.lookup: uint8[] {
.kind: static const variable(arr)
.base: `uint8[]`
.size: 8
.name: 'lookup'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:3'
.owner: Base64Encoder
.value: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:115: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:114: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:107: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:106: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:105: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:92: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:91: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:90: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:89: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:74: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:73: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:67: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:66: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:65: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:57: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:56: referenced as `lookup`
}
Base64Encoder.writer: ByteWriter {
.kind: const variable(ref)
.base: `ByteWriter`
.size: 4
.name: 'writer'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:6'
.owner: Base64Encoder
.doc: '@public'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:126: referenced as `writer`
	cmplStd/lib/text/encoding/binary/Base64.ci:44: referenced as `writer`
	cmplStd/lib/text/encoding/binary/Base64.ci:17: referenced as `writer`
}
Base64Encoder.buffer: uint8[1024] {
.kind: variable(val)
.base: `uint8[1024]`
.size: 1024
.name: 'buffer'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:8'
.owner: Base64Encoder
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:45: referenced as `buffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:42: referenced as `buffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:33: referenced as `buffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:25: referenced as `buffer`
}
Base64Encoder.bufferSize: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'bufferSize'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:9'
.owner: Base64Encoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:46: referenced as `bufferSize`
	cmplStd/lib/text/encoding/binary/Base64.ci:38: referenced as `bufferSize`
	cmplStd/lib/text/encoding/binary/Base64.ci:18: referenced as `bufferSize`
}
Base64Encoder.padding: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'padding'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:10'
.owner: Base64Encoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:118: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:109: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:71: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:62: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:58: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:54: referenced as `padding`
}
Base64Encoder.wrap: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'wrap'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:13'
.owner: Base64Encoder
.doc: 'wrap at the given position with a newline'
.value: 80
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:32: referenced as `wrap`
	cmplStd/lib/text/encoding/binary/Base64.ci:21: referenced as `wrap`
	cmplStd/lib/text/encoding/binary/Base64.ci:20: referenced as `wrap`
}
Base64Encoder.wrapSize: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'wrapSize'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:14'
.owner: Base64Encoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:35: referenced as `wrapSize`
	cmplStd/lib/text/encoding/binary/Base64.ci:26: referenced as `wrapSize`
	cmplStd/lib/text/encoding/binary/Base64.ci:20: referenced as `wrapSize`
}
Base64Encoder.flushBuffer(this: Base64Encoder): void: function {
.kind: static function
.base: `function`
.size: 232
.name: 'flushBuffer'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:16'
.owner: Base64Encoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Encoder (size: 4, cast: variable(ref))
.value: {
	writer: ByteWriter := this.writer;
	size: int32 := this.bufferSize;
	wrap: int32 := this.wrap - this.wrapSize;
	if (wrap > size || this.wrap == 0) {
		wrap := size;
	}
	writer.write(writer, this.buffer[...wrap]);
	this.wrapSize := this.wrapSize + wrap;
	for ( ; wrap < size; ) {
		writer.write(writer, "\n");
		len: int32 := Math.min(size - wrap, this.wrap);
		buffer: uint8[*] := inc(this.buffer, wrap);
		writer.write(writer, buffer[...len]);
		this.wrapSize := len;
		wrap := wrap + len;
	}
	this.bufferSize := 0;
}
.instructions: (232 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:17: (7 bytes): writer: ByteWriter := this.writer
	<flushBuffer>  : dup.x32 sp(1)
	<flushBuffer+?>: inc.i32(+16)
	<flushBuffer+?>: load.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:18: (7 bytes): size: int32 := this.bufferSize
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: inc.i32(+1044)
	<flushBuffer+?>: load.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:20: (15 bytes): wrap: int32 := this.wrap - this.wrapSize
	<flushBuffer+?>: dup.x32 sp(3)
	<flushBuffer+?>: inc.i32(+1052)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: dup.x32 sp(4)
	<flushBuffer+?>: inc.i32(+1056)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: sub.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:21: (31 bytes): if (wrap > size || this.wrap == 0)
	<flushBuffer+?>: dup.x32 sp(0)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: cgt.i32
	<flushBuffer+?>: dup.x32 sp(0)
	<flushBuffer+?>: jnz +17
	<flushBuffer+?>: inc.sp(-4)
	<flushBuffer+?>: dup.x32 sp(4)
	<flushBuffer+?>: inc.i32(+1052)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: load.z32
	<flushBuffer+?>: ceq.i32
	<flushBuffer+?>: jz +7
	cmplStd/lib/text/encoding/binary/Base64.ci:22: (3 bytes): wrap := size;
	<flushBuffer+?>: mov.x32 sp(0, 1)
	cmplStd/lib/text/encoding/binary/Base64.ci:25: (22 bytes): writer.write(writer, this.buffer[...wrap]);
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: dup.x32 sp(6)
	<flushBuffer+?>: inc.i32(+20)
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+8)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: call
	<flushBuffer+?>: inc.sp(-12)
	cmplStd/lib/text/encoding/binary/Base64.ci:26: (17 bytes): this.wrapSize := this.wrapSize + wrap;
	<flushBuffer+?>: dup.x32 sp(4)
	<flushBuffer+?>: inc.i32(+1056)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: add.i32
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+1056)
	<flushBuffer+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:29: (120 bytes): for ( ; wrap < size; )
	<flushBuffer+?>: jmp +111
	cmplStd/lib/text/encoding/binary/Base64.ci:30: (24 bytes): writer.write(writer, "\n");
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: load.c32 1
	<flushBuffer+?>: load.ref <?> ;"\n"
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+8)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: call
	<flushBuffer+?>: inc.sp(-12)
	cmplStd/lib/text/encoding/binary/Base64.ci:32: (36 bytes): len: int32 := Math.min(size - wrap, this.wrap)
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: sub.i32
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+1052)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: clt.i32
	<flushBuffer+?>: jz +10
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: jmp +6
	<flushBuffer+?>: dup.x32 sp(0)
	<flushBuffer+?>: mov.x32 sp(2, 0)
	<flushBuffer+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/binary/Base64.ci:33: (9 bytes): buffer: uint8[*] := inc(this.buffer, wrap)
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+20)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: add.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:34: (18 bytes): writer.write(writer, buffer[...len]);
	<flushBuffer+?>: dup.x32 sp(4)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: dup.x32 sp(7)
	<flushBuffer+?>: inc.i32(+8)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: call
	<flushBuffer+?>: inc.sp(-12)
	cmplStd/lib/text/encoding/binary/Base64.ci:35: (9 bytes): this.wrapSize := len;
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: dup.x32 sp(7)
	<flushBuffer+?>: inc.i32(+1056)
	<flushBuffer+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:36: (7 bytes): wrap := wrap + len;
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: add.i32
	<flushBuffer+?>: set.x32 sp(3)
	<flushBuffer+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/binary/Base64.ci:29: (9 bytes): wrap < size
	<flushBuffer+?>: dup.x32 sp(0)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: clt.i32
	<flushBuffer+?>: jnz -112
	cmplStd/lib/text/encoding/binary/Base64.ci:38: (8 bytes): this.bufferSize := 0;
	<flushBuffer+?>: load.z32
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+1044)
	<flushBuffer+?>: store.i32
	<flushBuffer+?>: inc.sp(-12)
	<flushBuffer+?>: ret
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:130: referenced as `flushBuffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:125: referenced as `flushBuffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:99: referenced as `flushBuffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:82: referenced as `flushBuffer`
}
Base64Encoder.write(this: Base64Encoder, data: uint8[]): void: function {
.kind: static function
.base: `function`
.size: 896
.name: 'write'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:41'
.owner: Base64Encoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Encoder (size: 4, cast: variable(ref))
.param data: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must write all the bytes from the `bytes` array'
.value: {
	assert(buffer.(length) > 3);
	writer: ByteWriter := this.writer;
	buffer: uint8[] := this.buffer;
	size: int32 := this.bufferSize;
	i: int32 := 0;
	if (size > 3 && buffer[size - 1] == ('=') && data.length > (0)) {
		if (buffer[size - 2] == ('=')) {
			if (data.length < (2)) {
				b: int32 := (this.padding << 6) | (((data[i]) & 255) << 2);
				buffer[size - 3] := lookup[b >> 6 & 63];
				buffer[size - 2] := lookup[b & 63];
				this.padding := b;
				return;
			}
			b: int32 := (this.padding << 12) | (((data[i]) & 255) << 8) | ((data[i + 1]) & 255);
			buffer[size - 3] := lookup[b >> 12 & 63];
			buffer[size - 2] := lookup[b >> 6 & 63];
			buffer[size - 1] := lookup[b & 63];
			i := i + 2;
		}
		else {
			b: int32 := (this.padding << 6) | ((data[i]) & 255);
			buffer[size - 2] := lookup[b >> 6 & 63];
			buffer[size - 1] := lookup[b & 63];
			i := i + 1;
		}
	}
	for (n: int32 := data.length - (2); i < n; i := i + 3) {
		if (size + 4 > (buffer.length)) {
			flushBuffer(this);
		}
		b: int32 := (((data[i + 0]) & 255) << 16) | (((data[i + 1]) & 255) << 8) | (((data[i + 2]) & 255) << 0);
		buffer[size + 0] := lookup[b >> 18 & 63];
		buffer[size + 1] := lookup[b >> 12 & 63];
		buffer[size + 2] := lookup[b >> 6 & 63];
		buffer[size + 3] := lookup[b & 63];
		size := size + 4;
	}
	if (left) {
		if (size + 4 > (buffer.length)) {
			flushBuffer(this);
		}
		if (left == 2) {
			b: int32 := (((data[i + 0]) & 255) << 10) | (((data[i + 1]) & 255) << 2);
			buffer[size + 0] := lookup[b >> 12 & 63];
			buffer[size + 1] := lookup[b >> 6 & 63];
			buffer[size + 2] := lookup[b & 63];
			buffer[size + 3] := ('=');
			this.padding := b;
			size := size + 4;
		}
		else {
			b: int32 := ((data[i]) & 255) << 4;
			buffer[size + 0] := lookup[(b >> 6) & 63];
			buffer[size + 1] := lookup[(b >> 0) & 63];
			buffer[size + 2] := ('=');
			buffer[size + 3] := ('=');
			this.padding := b;
			size := size + 4;
		}
	}
}
.instructions: (896 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:42: (9 bytes): assert(buffer.(length) > 3);
	<write>  : load.z32
	<write+?>: load.sp(+4)
	<write+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/binary/Base64.ci:44: (7 bytes): writer: ByteWriter := this.writer
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+16)
	<write+?>: load.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:45: (11 bytes): buffer: uint8[] := this.buffer
	<write+?>: load.c32 1024
	<write+?>: dup.x32 sp(5)
	<write+?>: inc.i32(+20)
	cmplStd/lib/text/encoding/binary/Base64.ci:46: (6 bytes): size: int32 := this.bufferSize
	<write+?>: dup.x32 sp(6)
	<write+?>: inc.i32(+1044)
	cmplStd/lib/text/encoding/binary/Base64.ci:47: (1 byte): i: int32 := 0
	<write+?>: load.z32
	cmplStd/lib/text/encoding/binary/Base64.ci:50: (359 bytes): if (size > 3 && buffer[size - 1] == ('=') && data.length > (0))
	<write+?>: dup.x32 sp(1)
	<write+?>: load.i32
	<write+?>: load.c32 3
	<write+?>: cgt.i32
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +25
	<write+?>: inc.sp(-4)
	<write+?>: dup.x32 sp(2)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.i32
	<write+?>: inc.i32(-1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: load.c32 61
	<write+?>: ceq.i32
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +12
	<write+?>: inc.sp(-4)
	<write+?>: dup.x32 sp(7)
	<write+?>: load.z32
	<write+?>: cgt.u32
	<write+?>: jz +309
	cmplStd/lib/text/encoding/binary/Base64.ci:51: (305 bytes): if (buffer[size - 2] == ('='))
	<write+?>: dup.x32 sp(2)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.i32
	<write+?>: inc.i32(-2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: load.c32 61
	<write+?>: ceq.i32
	<write+?>: jz +214
	cmplStd/lib/text/encoding/binary/Base64.ci:52: (94 bytes): if (data.length < (2))
	<write+?>: dup.x32 sp(7)
	<write+?>: load.c32 2
	<write+?>: clt.u32
	<write+?>: jz +86
	cmplStd/lib/text/encoding/binary/Base64.ci:54: (20 bytes): b: int32 := (this.padding << 6) | (((data[i]) & 255) << 2)
	<write+?>: dup.x32 sp(8)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	<write+?>: b32.shl 0x06
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x02
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:56: (23 bytes): buffer[size - 3] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:57: (21 bytes): buffer[size - 2] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:58: (9 bytes): this.padding := b;
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(10)
	<write+?>: inc.i32(+1048)
	<write+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:59: (5 bytes): return;
	<write+?>: inc.sp(-24)
	<write+?>: ret
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:62: (33 bytes): b: int32 := (this.padding << 12) | (((data[i]) & 255) << 8) | ((data[i + 1]) & 255)
	<write+?>: dup.x32 sp(8)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	<write+?>: b32.shl 0x0c
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x08
	<write+?>: or.b32
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:65: (23 bytes): buffer[size - 3] := lookup[b >> 12 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x0c
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:66: (23 bytes): buffer[size - 2] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:67: (21 bytes): buffer[size - 1] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:68: (8 bytes): i := i + 2;
	<write+?>: dup.x32 sp(1)
	<write+?>: inc.i32(+2)
	<write+?>: set.x32 sp(2)
	<write+?>: inc.sp(-4)
	<write+?>: jmp +78
	cmplStd/lib/text/encoding/binary/Base64.ci:71: (18 bytes): b: int32 := (this.padding << 6) | ((data[i]) & 255)
	<write+?>: dup.x32 sp(8)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	<write+?>: b32.shl 0x06
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:73: (23 bytes): buffer[size - 2] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:74: (21 bytes): buffer[size - 1] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:75: (8 bytes): i := i + 1;
	<write+?>: dup.x32 sp(1)
	<write+?>: inc.i32(+1)
	<write+?>: set.x32 sp(2)
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:80: (201 bytes): for (n: int32 := data.length - (2); i < n; i := i + 3)
	<write+?>: dup.x32 sp(7)
	<write+?>: inc.i32(-2)
	<write+?>: jmp +182
	cmplStd/lib/text/encoding/binary/Base64.ci:81: (26 bytes): if (size + 4 > (buffer.length))
	<write+?>: dup.x32 sp(2)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(5)
	<write+?>: cgt.i32
	<write+?>: jz +16
	cmplStd/lib/text/encoding/binary/Base64.ci:82: (12 bytes): flushBuffer(this);
	<write+?>: dup.x32 sp(9)
	<write+?>: load.ref <?> ;Base64Encoder.flushBuffer(this: Base64Encoder): void
	<write+?>: call
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:86: (42 bytes): b: int32 := (((data[i + 0]) & 255) << 16) | (((data[i + 1]) & 255) << 8) | (((data[i + 2]) & 255) << 0)
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x10
	<write+?>: dup.x32 sp(8)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x08
	<write+?>: or.b32
	<write+?>: dup.x32 sp(8)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: load.z32
	<write+?>: shl.b32
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:89: (21 bytes): buffer[size + 0] := lookup[b >> 18 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x12
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:90: (23 bytes): buffer[size + 1] := lookup[b >> 12 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x0c
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:91: (23 bytes): buffer[size + 2] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:92: (21 bytes): buffer[size + 3] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:93: (10 bytes): size := size + 4;
	<write+?>: dup.x32 sp(3)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(4)
	<write+?>: store.i32
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:80: (8 bytes): i := i + 3
	<write+?>: dup.x32 sp(1)
	<write+?>: inc.i32(+3)
	<write+?>: set.x32 sp(2)
	cmplStd/lib/text/encoding/binary/Base64.ci:80: (9 bytes): i < n
	<write+?>: dup.x32 sp(1)
	<write+?>: dup.x32 sp(1)
	<write+?>: clt.i32
	<write+?>: jnz -183
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:97: (297 bytes): if (left)
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(1)
	<write+?>: sub.i32
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +286
	cmplStd/lib/text/encoding/binary/Base64.ci:98: (26 bytes): if (size + 4 > (buffer.length))
	<write+?>: dup.x32 sp(2)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(5)
	<write+?>: cgt.i32
	<write+?>: jz +16
	cmplStd/lib/text/encoding/binary/Base64.ci:99: (12 bytes): flushBuffer(this);
	<write+?>: dup.x32 sp(9)
	<write+?>: load.ref <?> ;Base64Encoder.flushBuffer(this: Base64Encoder): void
	<write+?>: call
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:101: (256 bytes): if (left == 2)
	<write+?>: dup.x32 sp(0)
	<write+?>: load.c32 2
	<write+?>: ceq.i32
	<write+?>: jz +139
	cmplStd/lib/text/encoding/binary/Base64.ci:103: (27 bytes): b: int32 := (((data[i + 0]) & 255) << 10) | (((data[i + 1]) & 255) << 2)
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x0a
	<write+?>: dup.x32 sp(8)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x02
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:105: (21 bytes): buffer[size + 0] := lookup[b >> 12 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x0c
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:106: (23 bytes): buffer[size + 1] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:107: (21 bytes): buffer[size + 2] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:108: (16 bytes): buffer[size + 3] := ('=');
	<write+?>: load.c32 61
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:109: (9 bytes): this.padding := b;
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(11)
	<write+?>: inc.i32(+1048)
	<write+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:110: (10 bytes): size := size + 4;
	<write+?>: dup.x32 sp(3)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(4)
	<write+?>: store.i32
	<write+?>: inc.sp(-4)
	<write+?>: jmp +113
	cmplStd/lib/text/encoding/binary/Base64.ci:113: (10 bytes): b: int32 := ((data[i]) & 255) << 4
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x04
	cmplStd/lib/text/encoding/binary/Base64.ci:114: (21 bytes): buffer[size + 0] := lookup[(b >> 6) & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:115: (23 bytes): buffer[size + 1] := lookup[(b >> 0) & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: load.z32
	<write+?>: sar.b32
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:116: (16 bytes): buffer[size + 2] := ('=');
	<write+?>: load.c32 61
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:117: (16 bytes): buffer[size + 3] := ('=');
	<write+?>: load.c32 61
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:118: (9 bytes): this.padding := b;
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(11)
	<write+?>: inc.i32(+1048)
	<write+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:119: (10 bytes): size := size + 4;
	<write+?>: dup.x32 sp(3)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(4)
	<write+?>: store.i32
	<write+?>: inc.sp(-4)
	<write+?>: inc.sp(-4)
	<write+?>: inc.sp(-20)
	<write+?>: ret
.usages:
}
Base64Encoder.flush(this: Base64Encoder): void: function {
.kind: static function
.base: `function`
.size: 27
.name: 'flush'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:124'
.owner: Base64Encoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Encoder (size: 4, cast: variable(ref))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
if a buffer is used directly or indirectly this method must flush all buffered data to the stream.'
.value: {
	flushBuffer(this);
	flush(this.writer);
}
.instructions: (27 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:125: (12 bytes): flushBuffer(this);
	<flush>  : dup.x32 sp(1)
	<flush+?>: load.ref <?> ;Base64Encoder.flushBuffer(this: Base64Encoder): void
	<flush+?>: call
	<flush+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:126: (14 bytes): flush(this.writer);
	<flush+?>: dup.x32 sp(1)
	<flush+?>: inc.i32(+16)
	<flush+?>: load.i32
	<flush+?>: dup.x32 sp(0)
	<flush+?>: call
	<flush+?>: inc.sp(-4)
	<flush+?>: ret
.usages:
}
Base64Encoder.close(this: Base64Encoder): void: function {
.kind: static function
.base: `function`
.size: 13
.name: 'close'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:129'
.owner: Base64Encoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Encoder (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	flushBuffer(this);
}
.instructions: (13 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:130: (12 bytes): flushBuffer(this);
	<close>  : dup.x32 sp(1)
	<close+?>: load.ref <?> ;Base64Encoder.flushBuffer(this: Base64Encoder): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	<close+?>: ret
.usages:
}
Base64Decoder: ByteReader {
.kind: static const typename(ref)
.base: `ByteReader`
.size: 24
.name: 'Base64Decoder'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:135'
.field lookup: int32[256] (size: 1024, cast: static const variable(val))
.field reader: ByteReader (size: 4, cast: const variable(ref))
.field bitsDecoded: int32 (size: 4, cast: variable(i32))
.field charDecoded: int32 (size: 4, cast: variable(i32))
.field read: function (size: 345, cast: static function)
.field close: function (size: 73, cast: static function)
.field read: function (size: 4, cast: variable(ref))
.field read: function (size: 59, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Base64 decoder'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:190: referenced as `Base64Decoder`
	cmplStd/lib/text/encoding/binary/Base64.ci:162: referenced as `Base64Decoder`
}
Base64Decoder.lookup: int32[256] {
.kind: static const variable(val)
.base: `int32[256]`
.size: 1024
.name: 'lookup'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:136'
.owner: Base64Decoder
.value: {
	lookup[0] := -1;
	lookup[1] := -1;
	lookup[2] := -1;
	lookup[3] := -1;
	lookup[4] := -1;
	lookup[5] := -1;
	lookup[6] := -1;
	lookup[7] := -1;
	lookup[8] := -1;
	lookup[9] := -1;
	lookup[10] := -1;
	lookup[11] := -1;
	lookup[12] := -1;
	lookup[13] := -1;
	lookup[14] := -1;
	lookup[15] := -1;
	lookup[16] := -1;
	lookup[17] := -1;
	lookup[18] := -1;
	lookup[19] := -1;
	lookup[20] := -1;
	lookup[21] := -1;
	lookup[22] := -1;
	lookup[23] := -1;
	lookup[24] := -1;
	lookup[25] := -1;
	lookup[26] := -1;
	lookup[27] := -1;
	lookup[28] := -1;
	lookup[29] := -1;
	lookup[30] := -1;
	lookup[31] := -1;
	lookup[32] := -1;
	lookup[33] := -1;
	lookup[34] := -1;
	lookup[35] := -1;
	lookup[36] := -1;
	lookup[37] := -1;
	lookup[38] := -1;
	lookup[39] := -1;
	lookup[40] := -1;
	lookup[41] := -1;
	lookup[42] := -1;
	lookup[43] := 62;
	lookup[44] := -1;
	lookup[45] := -1;
	lookup[46] := -1;
	lookup[47] := 63;
	lookup[48] := 52;
	lookup[49] := 53;
	lookup[50] := 54;
	lookup[51] := 55;
	lookup[52] := 56;
	lookup[53] := 57;
	lookup[54] := 58;
	lookup[55] := 59;
	lookup[56] := 60;
	lookup[57] := 61;
	lookup[58] := -1;
	lookup[59] := -1;
	lookup[60] := -1;
	lookup[61] := -2;
	lookup[62] := -1;
	lookup[63] := -1;
	lookup[64] := -1;
	lookup[65] := 0;
	lookup[66] := 1;
	lookup[67] := 2;
	lookup[68] := 3;
	lookup[69] := 4;
	lookup[70] := 5;
	lookup[71] := 6;
	lookup[72] := 7;
	lookup[73] := 8;
	lookup[74] := 9;
	lookup[75] := 10;
	lookup[76] := 11;
	lookup[77] := 12;
	lookup[78] := 13;
	lookup[79] := 14;
	lookup[80] := 15;
	lookup[81] := 16;
	lookup[82] := 17;
	lookup[83] := 18;
	lookup[84] := 19;
	lookup[85] := 20;
	lookup[86] := 21;
	lookup[87] := 22;
	lookup[88] := 23;
	lookup[89] := 24;
	lookup[90] := 25;
	lookup[91] := -1;
	lookup[92] := -1;
	lookup[93] := -1;
	lookup[94] := -1;
	lookup[95] := -1;
	lookup[96] := -1;
	lookup[97] := 26;
	lookup[98] := 27;
	lookup[99] := 28;
	lookup[100] := 29;
	lookup[101] := 30;
	lookup[102] := 31;
	lookup[103] := 32;
	lookup[104] := 33;
	lookup[105] := 34;
	lookup[106] := 35;
	lookup[107] := 36;
	lookup[108] := 37;
	lookup[109] := 38;
	lookup[110] := 39;
	lookup[111] := 40;
	lookup[112] := 41;
	lookup[113] := 42;
	lookup[114] := 43;
	lookup[115] := 44;
	lookup[116] := 45;
	lookup[117] := 46;
	lookup[118] := 47;
	lookup[119] := 48;
	lookup[120] := 49;
	lookup[121] := 50;
	lookup[122] := 51;
	lookup[123] := -1;
	lookup[124] := -1;
	lookup[125] := -1;
	lookup[126] := -1;
	lookup[127] := -1;
	lookup[128] := -1;
	lookup[129] := -1;
	lookup[130] := -1;
	lookup[131] := -1;
	lookup[132] := -1;
	lookup[133] := -1;
	lookup[134] := -1;
	lookup[135] := -1;
	lookup[136] := -1;
	lookup[137] := -1;
	lookup[138] := -1;
	lookup[139] := -1;
	lookup[140] := -1;
	lookup[141] := -1;
	lookup[142] := -1;
	lookup[143] := -1;
	lookup[144] := -1;
	lookup[145] := -1;
	lookup[146] := -1;
	lookup[147] := -1;
	lookup[148] := -1;
	lookup[149] := -1;
	lookup[150] := -1;
	lookup[151] := -1;
	lookup[152] := -1;
	lookup[153] := -1;
	lookup[154] := -1;
	lookup[155] := -1;
	lookup[156] := -1;
	lookup[157] := -1;
	lookup[158] := -1;
	lookup[159] := -1;
	lookup[160] := -1;
	lookup[161] := -1;
	lookup[162] := -1;
	lookup[163] := -1;
	lookup[164] := -1;
	lookup[165] := -1;
	lookup[166] := -1;
	lookup[167] := -1;
	lookup[168] := -1;
	lookup[169] := -1;
	lookup[170] := -1;
	lookup[171] := -1;
	lookup[172] := -1;
	lookup[173] := -1;
	lookup[174] := -1;
	lookup[175] := -1;
	lookup[176] := -1;
	lookup[177] := -1;
	lookup[178] := -1;
	lookup[179] := -1;
	lookup[180] := -1;
	lookup[181] := -1;
	lookup[182] := -1;
	lookup[183] := -1;
	lookup[184] := -1;
	lookup[185] := -1;
	lookup[186] := -1;
	lookup[187] := -1;
	lookup[188] := -1;
	lookup[189] := -1;
	lookup[190] := -1;
	lookup[191] := -1;
	lookup[192] := -1;
	lookup[193] := -1;
	lookup[194] := -1;
	lookup[195] := -1;
	lookup[196] := -1;
	lookup[197] := -1;
	lookup[198] := -1;
	lookup[199] := -1;
	lookup[200] := -1;
	lookup[201] := -1;
	lookup[202] := -1;
	lookup[203] := -1;
	lookup[204] := -1;
	lookup[205] := -1;
	lookup[206] := -1;
	lookup[207] := -1;
	lookup[208] := -1;
	lookup[209] := -1;
	lookup[210] := -1;
	lookup[211] := -1;
	lookup[212] := -1;
	lookup[213] := -1;
	lookup[214] := -1;
	lookup[215] := -1;
	lookup[216] := -1;
	lookup[217] := -1;
	lookup[218] := -1;
	lookup[219] := -1;
	lookup[220] := -1;
	lookup[221] := -1;
	lookup[222] := -1;
	lookup[223] := -1;
	lookup[224] := -1;
	lookup[225] := -1;
	lookup[226] := -1;
	lookup[227] := -1;
	lookup[228] := -1;
	lookup[229] := -1;
	lookup[230] := -1;
	lookup[231] := -1;
	lookup[232] := -1;
	lookup[233] := -1;
	lookup[234] := -1;
	lookup[235] := -1;
	lookup[236] := -1;
	lookup[237] := -1;
	lookup[238] := -1;
	lookup[239] := -1;
	lookup[240] := -1;
	lookup[241] := -1;
	lookup[242] := -1;
	lookup[243] := -1;
	lookup[244] := -1;
	lookup[245] := -1;
	lookup[246] := -1;
	lookup[247] := -1;
	lookup[248] := -1;
	lookup[249] := -1;
	lookup[250] := -1;
	lookup[251] := -1;
	lookup[252] := -1;
	lookup[253] := -1;
	lookup[254] := -1;
	lookup[255] := -1;
}
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:179: referenced as `lookup`
}
Base64Decoder.reader: ByteReader {
.kind: const variable(ref)
.base: `ByteReader`
.size: 4
.name: 'reader'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:156'
.owner: Base64Decoder
.doc: '@public'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:166: referenced as `reader`
}
Base64Decoder.bitsDecoded: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'bitsDecoded'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:159'
.owner: Base64Decoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:191: referenced as `bitsDecoded`
	cmplStd/lib/text/encoding/binary/Base64.ci:191: referenced as `bitsDecoded`
	cmplStd/lib/text/encoding/binary/Base64.ci:167: referenced as `bitsDecoded`
}
Base64Decoder.charDecoded: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'charDecoded'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:160'
.owner: Base64Decoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:168: referenced as `charDecoded`
}
Base64Decoder.read(this: Base64Decoder, data: uint8[]): int32: function {
.kind: static function
.base: `function`
.size: 345
.name: 'read'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:162'
.owner: Base64Decoder
.param .result: int32 (size: 4, cast: variable(i32))
.param this: Base64Decoder (size: 4, cast: variable(ref))
.param data: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of bytes read from the stream into the `bytes` array
in case there is an error -1 should be returned'
.value: {
	isWhite(c: char): bool := c == ' ' || c == '\t' || c == '\n' || c == '\r';
	in: uint8[1] := {
		in[0] := (0);
	};
	reader: ByteReader := this.reader;
	bitsDecoded: typename := this.bitsDecoded;
	charDecoded: typename := this.charDecoded;
	for (i: int32 := 0; i < (data.length); ) {
		if (reader.read(reader, in) <= 0) {
			return .result := i;
		}
		else if (in[0] == ('=')) {
			bitsDecoded := bitsDecoded - 2;
		}
		else if (!isWhite(in[0])) {
			bitsDecoded := bitsDecoded + 6;
			charDecoded := charDecoded << 6;
			charDecoded := charDecoded | lookup[in[0]] & 63;
			if (bitsDecoded >= 8) {
				bitsDecoded := bitsDecoded - 8;
				data[i] := uint8(charDecoded >> bitsDecoded);
				i := i + 1;
			}
		}
	}
	return .result := data.length;
}
.instructions: (345 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:165: (10 bytes): in: uint8[1] := {...}
	<read>  : inc.sp(+4)
	cmplStd/lib/text/encoding/binary/Base64.ci:165: (6 bytes): in[0] := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+4)
	<read+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:166: (7 bytes): reader: ByteReader := this.reader
	<read+?>: dup.x32 sp(4)
	<read+?>: inc.i32(+12)
	<read+?>: load.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:169: (320 bytes): for (i: int32 := 0; i < (data.length); )
	<read+?>: load.z32
	<read+?>: jmp +306
	cmplStd/lib/text/encoding/binary/Base64.ci:170: (302 bytes): if (reader.read(reader, in) <= 0)
	<read+?>: load.z32
	<read+?>: dup.x32 sp(2)
	<read+?>: load.c32 1
	<read+?>: load.sp(+20)
	<read+?>: dup.x32 sp(5)
	<read+?>: inc.i32(+8)
	<read+?>: load.i32
	<read+?>: call
	<read+?>: inc.sp(-12)
	<read+?>: load.z32
	<read+?>: cgt.i32
	<read+?>: jnz +16
	cmplStd/lib/text/encoding/binary/Base64.ci:171: (8 bytes): return .result := i;
	<read+?>: mov.x32 sp(7, 0)
	<read+?>: inc.sp(-12)
	<read+?>: ret
	<read+?>: jmp +264
	cmplStd/lib/text/encoding/binary/Base64.ci:173: (260 bytes): if (in[0] == ('='))
	<read+?>: load.sp(+8)
	<read+?>: load.iu8
	<read+?>: load.c32 61
	<read+?>: ceq.i32
	<read+?>: jz +26
	cmplStd/lib/text/encoding/binary/Base64.ci:174: (18 bytes): bitsDecoded := bitsDecoded - 2;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: inc.i32(-2)
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: store.i32
	<read+?>: jmp +227
	cmplStd/lib/text/encoding/binary/Base64.ci:176: (223 bytes): if (!isWhite(in[0]))
	<read+?>: load.sp(+8)
	<read+?>: load.iu8
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.c32 32
	<read+?>: ceq.i32
	<read+?>: dup.x32 sp(0)
	<read+?>: jnz +19
	<read+?>: inc.sp(-4)
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.c32 9
	<read+?>: ceq.i32
	<read+?>: dup.x32 sp(0)
	<read+?>: jnz +19
	<read+?>: inc.sp(-4)
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.c32 10
	<read+?>: ceq.i32
	<read+?>: dup.x32 sp(0)
	<read+?>: jnz +19
	<read+?>: inc.sp(-4)
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.c32 13
	<read+?>: ceq.i32
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.sp(+8)
	<read+?>: store.i8
	<read+?>: inc.sp(-4)
	<read+?>: jnz +130
	cmplStd/lib/text/encoding/binary/Base64.ci:177: (18 bytes): bitsDecoded := bitsDecoded + 6;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: inc.i32(+6)
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:178: (16 bytes): charDecoded := charDecoded << 6;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+20)
	<read+?>: load.i32
	<read+?>: b32.shl 0x06
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+20)
	<read+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:179: (32 bytes): charDecoded := charDecoded | lookup[in[0]] & 63;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+20)
	<read+?>: load.i32
	<read+?>: load.ref <?> ;Base64Decoder.lookup
	<read+?>: load.sp(+16)
	<read+?>: load.iu8
	<read+?>: mad.u32 4
	<read+?>: load.i32
	<read+?>: b32.and 0x3f
	<read+?>: or.b32
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+20)
	<read+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:180: (60 bytes): if (bitsDecoded >= 8)
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: load.c32 8
	<read+?>: clt.i32
	<read+?>: jnz +47
	cmplStd/lib/text/encoding/binary/Base64.ci:181: (18 bytes): bitsDecoded := bitsDecoded - 8;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: inc.i32(-8)
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:182: (21 bytes): data[i] := uint8(charDecoded >> bitsDecoded);
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+20)
	<read+?>: load.i32
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: sar.b32
	<read+?>: dup.x32 sp(5)
	<read+?>: dup.x32 sp(2)
	<read+?>: add.i32
	<read+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:183: (4 bytes): i := i + 1;
	<read+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/binary/Base64.ci:169: (9 bytes): i < (data.length)
	<read+?>: dup.x32 sp(0)
	<read+?>: dup.x32 sp(6)
	<read+?>: clt.i32
	<read+?>: jnz -307
	<read+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:187: (8 bytes): return .result := data.length;
	<read+?>: mov.x32 sp(6, 4)
	<read+?>: inc.sp(-8)
	<read+?>: ret
.usages:
}
Base64Decoder.close(this: Base64Decoder): void: function {
.kind: static function
.base: `function`
.size: 73
.name: 'close'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:190'
.owner: Base64Decoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Decoder (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	assert(this.bitsDecoded == 0, "unprocessed bits remaining.", this.bitsDecoded);
}
.instructions: (73 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:191: (72 bytes): assert(this.bitsDecoded == 0, "unprocessed bits remaining.", this.bitsDecoded);
	<close>  : load.ref <?> ;int32
	<close+?>: dup.x32 sp(2)
	<close+?>: inc.i32(+16)
	<close+?>: load.c32 1
	<close+?>: load.sp(+4)
	<close+?>: dup.x32 sp(5)
	<close+?>: inc.i32(+16)
	<close+?>: load.i32
	<close+?>: load.z32
	<close+?>: ceq.i32
	<close+?>: jz +8
	<close+?>: jmp +35
	<close+?>: load.ref <?> ;"cmplStd/lib/text/encoding/binary/Base64.ci"
	<close+?>: load.c32 191
	<close+?>: load.c32 -2
	<close+?>: load.c32 128
	<close+?>: load.ref <?> ;"unprocessed bits remaining."
	<close+?>: dup.x64 sp(5)
	<close+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<close+?>: inc.sp(-16)
	<close+?>: ret
.usages:
}
AsciiReader: TextReader {
.kind: static const typename(ref)
.base: `TextReader`
.size: 16
.name: 'AsciiReader'
.file: 'cmplStd/lib/text/encoding/Ascii.ci:2'
.field decode: function (size: 97, cast: static function)
.field reader: ByteReader (size: 4, cast: const variable(ref))
.field decode: function (size: 4, cast: variable(ref))
.field close: function (size: 18, cast: static function)
.field decode: function (size: 55, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Ascii reader converts the given input by mapping every byte to a character'
.usages:
	cmplStd/lib/text/encoding/Ascii.ci:4: referenced as `AsciiReader`
}
AsciiReader.decode(this: AsciiReader, chars: uint32[]): int32: function {
.kind: static function
.base: `function`
.size: 97
.name: 'decode'
.file: 'cmplStd/lib/text/encoding/Ascii.ci:4'
.owner: AsciiReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: AsciiReader (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of characters decoded from the stream into the `chars` array
in case there is an error -1 should be returned'
.value: {
	reader: ByteReader := this.reader;
	for (i: int32 := 0; i < (chars.length); i := i + 1) {
		value: uint8[1] := {
		};
		if (reader.read(reader, value) <= 0) {
			return .result := i;
		}
		chars[i] := (value[0]);
	}
	return .result := chars.length;
}
.instructions: (97 bytes)
	cmplStd/lib/text/encoding/Ascii.ci:5: (7 bytes): reader: ByteReader := this.reader
	<decode>  : dup.x32 sp(3)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	cmplStd/lib/text/encoding/Ascii.ci:6: (82 bytes): for (i: int32 := 0; i < (chars.length); i := i + 1)
	<decode+?>: load.z32
	<decode+?>: jmp +68
	cmplStd/lib/text/encoding/Ascii.ci:7: (4 bytes): value: uint8[1] := {...}
	<decode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Ascii.ci:8: (38 bytes): if (reader.read(reader, value) <= 0)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(3)
	<decode+?>: load.c32 1
	<decode+?>: load.sp(+12)
	<decode+?>: dup.x32 sp(6)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.z32
	<decode+?>: cgt.i32
	<decode+?>: jnz +12
	cmplStd/lib/text/encoding/Ascii.ci:10: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(7, 1)
	<decode+?>: inc.sp(-12)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Ascii.ci:12: (14 bytes): chars[i] := (value[0]);
	<decode+?>: load.sp(+0)
	<decode+?>: load.iu8
	<decode+?>: dup.x32 sp(5)
	<decode+?>: dup.x32 sp(3)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	<decode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Ascii.ci:6: (4 bytes): i := i + 1
	<decode+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/Ascii.ci:6: (9 bytes): i < (chars.length)
	<decode+?>: dup.x32 sp(0)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: clt.i32
	<decode+?>: jnz -69
	<decode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Ascii.ci:14: (8 bytes): return .result := chars.length;
	<decode+?>: mov.x32 sp(5, 3)
	<decode+?>: inc.sp(-4)
	<decode+?>: ret
.usages:
}
AsciiWriter: TextWriter {
.kind: static const typename(ref)
.base: `TextWriter`
.size: 36
.name: 'AsciiWriter'
.file: 'cmplStd/lib/text/encoding/Ascii.ci:19'
.field encode: function (size: 79, cast: static function)
.field Writeable: object (size: 8, cast: static const typename(ref))
.field writer: ByteWriter (size: 4, cast: const variable(ref))
.field format: FormatFlags (size: 16, cast: const variable(val))
.field encode: function (size: 4, cast: variable(ref))
.field flush: function (size: 25, cast: static function)
.field flush: function (size: 4, cast: const variable(ref))
.field close: function (size: 18, cast: static function)
.field write: function (size: 30, cast: static function)
.field write: function (size: 46, cast: static function)
.field write: function (size: 67, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 71, cast: static function)
.field write: function (size: 70, cast: static function)
.field write: function (size: 20, cast: static function)
.field writeln: function (size: 29, cast: static function)
.field writeln: function (size: 35, cast: static function)
.field copy: function (size: 107, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Ascii Writer converts the given input by chopping each character to a byte'
.usages:
}
AsciiWriter.encode(this: TextWriter, chars: uint32[]): void: function {
.kind: static function
.base: `function`
.size: 79
.name: 'encode'
.file: 'cmplStd/lib/text/encoding/Ascii.ci:21'
.owner: AsciiWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must encode and write all the characters from the `chars` array'
.value: {
	writer: ByteWriter := this.writer;
	for (i: int32 := 0; i < (chars.length); i := i + 1) {
		value: uint8[1] := {
			value[0] := (chars[i]);
		};
		writer.write(writer, value);
	}
}
.instructions: (79 bytes)
	cmplStd/lib/text/encoding/Ascii.ci:22: (7 bytes): writer: ByteWriter := this.writer
	<encode>  : dup.x32 sp(3)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	cmplStd/lib/text/encoding/Ascii.ci:23: (67 bytes): for (i: int32 := 0; i < (chars.length); i := i + 1)
	<encode+?>: load.z32
	<encode+?>: jmp +53
	cmplStd/lib/text/encoding/Ascii.ci:24: (18 bytes): value: uint8[1] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Ascii.ci:24: (14 bytes): value[0] := (chars[i]);
	<encode+?>: dup.x32 sp(4)
	<encode+?>: dup.x32 sp(2)
	<encode+?>: mad.u32 4
	<encode+?>: load.i32
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Ascii.ci:25: (23 bytes): writer.write(writer, value);
	<encode+?>: dup.x32 sp(2)
	<encode+?>: load.c32 1
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(5)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Ascii.ci:23: (4 bytes): i := i + 1
	<encode+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/Ascii.ci:23: (9 bytes): i < (chars.length)
	<encode+?>: dup.x32 sp(0)
	<encode+?>: dup.x32 sp(5)
	<encode+?>: clt.i32
	<encode+?>: jnz -54
	<encode+?>: inc.sp(-4)
	<encode+?>: inc.sp(-4)
	<encode+?>: ret
.usages:
}
Utf8Reader: TextReader {
.kind: static const typename(ref)
.base: `TextReader`
.size: 16
.name: 'Utf8Reader'
.file: 'cmplStd/lib/text/encoding/Utf8.ci:2'
.field decode: function (size: 945, cast: static function)
.field reader: ByteReader (size: 4, cast: const variable(ref))
.field decode: function (size: 4, cast: variable(ref))
.field close: function (size: 18, cast: static function)
.field decode: function (size: 55, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Utf-8 decoder'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:4: referenced as `Utf8Reader`
}
Utf8Reader.decode(this: Utf8Reader, chars: uint32[]): int32: function {
.kind: static function
.base: `function`
.size: 945
.name: 'decode'
.file: 'cmplStd/lib/text/encoding/Utf8.ci:4'
.owner: Utf8Reader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: Utf8Reader (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of characters decoded from the stream into the `chars` array
in case there is an error -1 should be returned'
.value: {
	buff: uint8[1] := {
		buff[0] := (0);
	};
	ext: uint8[3] := {
		ext[0] := (0);
	};
	reader: ByteReader := this.reader;
	for (i: int32 := 0; i < (chars.length); i := i + 1) {
		if (reader.read(reader, buff) <= 0) {
			return .result := i;
		}
		if (((buff[0]) & 128) == 0) {
			chars[i] := (buff[0]);
		}
		else if (((buff[0]) & 224) == 192) {
			if (reader.read(reader, ext[...1]) != 1) {
				error("invalid codepoint");
				return .result := i;
			}
			assert(((ext[0]) & 192) == 128, "10xxxxxx");
			chars[i] := (((buff[0]) & 31) << 6 | ((ext[0]) & 63));
		}
		else if (((buff[0]) & 240) == 224) {
			if (reader.read(reader, ext[...2]) != 2) {
				error("invalid codepoint");
				return .result := i;
			}
			assert(((ext[0]) & 192) == 128, "10xxxxxx");
			assert(((ext[1]) & 192) == 128, "10xxxxxx");
			chars[i] := (((buff[0]) & 15) << 12 | ((ext[0]) & 63) << 6 | ((ext[1]) & 63));
		}
		else if (((buff[0]) & 248) == 240) {
			if (reader.read(reader, ext[...3]) != 3) {
				error("invalid codepoint");
				return .result := i;
			}
			assert(((ext[0]) & 192) == 128, "10xxxxxx");
			assert(((ext[1]) & 192) == 128, "10xxxxxx");
			assert(((ext[2]) & 192) == 128, "10xxxxxx");
			chars[i] := (((buff[0]) & 7) << 18 | ((ext[0]) & 63) << 12 | ((ext[1]) & 63) << 6 | ((ext[2]) & 63));
		}
	}
	return .result := chars.length;
}
.instructions: (945 bytes)
	cmplStd/lib/text/encoding/Utf8.ci:5: (10 bytes): buff: uint8[1] := {...}
	<decode>  : inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:5: (6 bytes): buff[0] := (0);
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:6: (10 bytes): ext: uint8[3] := {...}
	<decode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:6: (6 bytes): ext[0] := (0);
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:7: (7 bytes): reader: ByteReader := this.reader
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	cmplStd/lib/text/encoding/Utf8.ci:8: (910 bytes): for (i: int32 := 0; i < (chars.length); i := i + 1)
	<decode+?>: load.z32
	<decode+?>: jmp +896
	cmplStd/lib/text/encoding/Utf8.ci:9: (38 bytes): if (reader.read(reader, buff) <= 0)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(2)
	<decode+?>: load.c32 1
	<decode+?>: load.sp(+24)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.z32
	<decode+?>: cgt.i32
	<decode+?>: jnz +12
	cmplStd/lib/text/encoding/Utf8.ci:11: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(8, 0)
	<decode+?>: inc.sp(-16)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Utf8.ci:14: (850 bytes): if (((buff[0]) & 128) == 0)
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: load.c32 128
	<decode+?>: and.b32
	<decode+?>: load.z32
	<decode+?>: ceq.i32
	<decode+?>: jz +22
	cmplStd/lib/text/encoding/Utf8.ci:15: (14 bytes): chars[i] := (buff[0]);
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: dup.x32 sp(6)
	<decode+?>: dup.x32 sp(2)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	<decode+?>: jmp +819
	cmplStd/lib/text/encoding/Utf8.ci:17: (815 bytes): if (((buff[0]) & 224) == 192)
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: load.c32 224
	<decode+?>: and.b32
	<decode+?>: load.c32 192
	<decode+?>: ceq.i32
	<decode+?>: jz +181
	cmplStd/lib/text/encoding/Utf8.ci:18: (82 bytes): if (reader.read(reader, ext[...1]) != 1)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(2)
	<decode+?>: load.c32 1
	<decode+?>: load.sp(+20)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.c32 1
	<decode+?>: ceq.i32
	<decode+?>: jnz +52
	cmplStd/lib/text/encoding/Utf8.ci:19: (40 bytes): error("invalid codepoint");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 19
	<decode+?>: load.c32 -1
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"invalid codepoint"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:20: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(8, 0)
	<decode+?>: inc.sp(-16)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Utf8.ci:22: (65 bytes): assert(((ext[0]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+16)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 22
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:23: (26 bytes): chars[i] := (((buff[0]) & 31) << 6 | ((ext[0]) & 63));
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x1f
	<decode+?>: b32.shl 0x06
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: or.b32
	<decode+?>: dup.x32 sp(6)
	<decode+?>: dup.x32 sp(2)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	<decode+?>: jmp +621
	cmplStd/lib/text/encoding/Utf8.ci:25: (617 bytes): if (((buff[0]) & 240) == 224)
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: load.c32 240
	<decode+?>: and.b32
	<decode+?>: load.c32 224
	<decode+?>: ceq.i32
	<decode+?>: jz +256
	cmplStd/lib/text/encoding/Utf8.ci:26: (82 bytes): if (reader.read(reader, ext[...2]) != 2)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(2)
	<decode+?>: load.c32 2
	<decode+?>: load.sp(+20)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.c32 2
	<decode+?>: ceq.i32
	<decode+?>: jnz +52
	cmplStd/lib/text/encoding/Utf8.ci:27: (40 bytes): error("invalid codepoint");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 27
	<decode+?>: load.c32 -1
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"invalid codepoint"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:28: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(8, 0)
	<decode+?>: inc.sp(-16)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Utf8.ci:30: (65 bytes): assert(((ext[0]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+16)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 30
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:31: (65 bytes): assert(((ext[1]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+17)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 31
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:32: (36 bytes): chars[i] := (((buff[0]) & 15) << 12 | ((ext[0]) & 63) << 6 | ((ext[1]) & 63));
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x0f
	<decode+?>: b32.shl 0x0c
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: b32.shl 0x06
	<decode+?>: or.b32
	<decode+?>: load.sp(+13)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: or.b32
	<decode+?>: dup.x32 sp(6)
	<decode+?>: dup.x32 sp(2)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	<decode+?>: jmp +348
	cmplStd/lib/text/encoding/Utf8.ci:34: (344 bytes): if (((buff[0]) & 248) == 240)
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: load.c32 248
	<decode+?>: and.b32
	<decode+?>: load.c32 240
	<decode+?>: ceq.i32
	<decode+?>: jz +327
	cmplStd/lib/text/encoding/Utf8.ci:35: (82 bytes): if (reader.read(reader, ext[...3]) != 3)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(2)
	<decode+?>: load.c32 3
	<decode+?>: load.sp(+20)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.c32 3
	<decode+?>: ceq.i32
	<decode+?>: jnz +52
	cmplStd/lib/text/encoding/Utf8.ci:36: (40 bytes): error("invalid codepoint");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 36
	<decode+?>: load.c32 -1
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"invalid codepoint"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:37: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(8, 0)
	<decode+?>: inc.sp(-16)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Utf8.ci:39: (65 bytes): assert(((ext[0]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+16)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 39
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:40: (65 bytes): assert(((ext[1]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+17)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 40
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:41: (65 bytes): assert(((ext[2]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+18)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 41
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:42: (46 bytes): chars[i] := (((buff[0]) & 7) << 18 | ((ext[0]) & 63) << 12 | ((ext[1]) & 63) << 6 | ((ext[2]) & 63));
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x07
	<decode+?>: b32.shl 0x12
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: b32.shl 0x0c
	<decode+?>: or.b32
	<decode+?>: load.sp(+13)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: b32.shl 0x06
	<decode+?>: or.b32
	<decode+?>: load.sp(+14)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: or.b32
	<decode+?>: dup.x32 sp(6)
	<decode+?>: dup.x32 sp(2)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	cmplStd/lib/text/encoding/Utf8.ci:8: (4 bytes): i := i + 1
	<decode+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/Utf8.ci:8: (9 bytes): i < (chars.length)
	<decode+?>: dup.x32 sp(0)
	<decode+?>: dup.x32 sp(7)
	<decode+?>: clt.i32
	<decode+?>: jnz -897
	<decode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Utf8.ci:45: (8 bytes): return .result := chars.length;
	<decode+?>: mov.x32 sp(7, 5)
	<decode+?>: inc.sp(-12)
	<decode+?>: ret
.usages:
}
Utf8Writer: TextWriter {
.kind: static const typename(ref)
.base: `TextWriter`
.size: 36
.name: 'Utf8Writer'
.file: 'cmplStd/lib/text/encoding/Utf8.ci:51'
.field encode: function (size: 367, cast: static function)
.field Writeable: object (size: 8, cast: static const typename(ref))
.field writer: ByteWriter (size: 4, cast: const variable(ref))
.field format: FormatFlags (size: 16, cast: const variable(val))
.field encode: function (size: 4, cast: variable(ref))
.field flush: function (size: 25, cast: static function)
.field flush: function (size: 4, cast: const variable(ref))
.field close: function (size: 18, cast: static function)
.field write: function (size: 30, cast: static function)
.field write: function (size: 46, cast: static function)
.field write: function (size: 67, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 71, cast: static function)
.field write: function (size: 70, cast: static function)
.field write: function (size: 20, cast: static function)
.field writeln: function (size: 29, cast: static function)
.field writeln: function (size: 35, cast: static function)
.field copy: function (size: 107, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Utf-8 encoder'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:53: referenced as `Utf8Writer`
}
Utf8Writer.encode(this: Utf8Writer, chars: uint32[]): void: function {
.kind: static function
.base: `function`
.size: 367
.name: 'encode'
.file: 'cmplStd/lib/text/encoding/Utf8.ci:53'
.owner: Utf8Writer
.param .result: void (size: 0, cast: variable(void))
.param this: Utf8Writer (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must encode and write all the characters from the `chars` array'
.value: {
	writer: ByteWriter := this.writer;
	for (i: int32 := 0; i < (chars.length); i := i + 1) {
		cp: uint32 := chars[i];
		if (cp < (128)) {
			bytes: uint8[1] := {
				bytes[0] := (cp);
			};
			writer.write(writer, bytes[...1]);
		}
		else if (cp < (2048)) {
			bytes: uint8[2] := {
				bytes[0] := (192 | ((cp >> 6)));
				bytes[1] := (128 | ((cp & (63))));
			};
			writer.write(writer, bytes[...2]);
		}
		else if (cp < (65536)) {
			bytes: uint8[3] := {
				bytes[0] := (224 | ((cp >> 12)));
				bytes[1] := (128 | (((cp >> 6) & (63))));
				bytes[2] := (128 | ((cp & (63))));
			};
			writer.write(writer, bytes[...3]);
		}
		else {
			bytes: uint8[4] := {
				bytes[0] := (240 | ((cp >> 18)));
				bytes[1] := (128 | (((cp >> 12) & (63))));
				bytes[2] := (128 | (((cp >> 6) & (63))));
				bytes[3] := (128 | ((cp & (63))));
			};
			writer.write(writer, bytes[...4]);
		}
	}
}
.instructions: (367 bytes)
	cmplStd/lib/text/encoding/Utf8.ci:54: (7 bytes): writer: ByteWriter := this.writer
	<encode>  : dup.x32 sp(3)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	cmplStd/lib/text/encoding/Utf8.ci:55: (355 bytes): for (i: int32 := 0; i < (chars.length); i := i + 1)
	<encode+?>: load.z32
	<encode+?>: jmp +341
	cmplStd/lib/text/encoding/Utf8.ci:56: (9 bytes): cp: uint32 := chars[i]
	<encode+?>: dup.x32 sp(3)
	<encode+?>: dup.x32 sp(1)
	<encode+?>: mad.u32 4
	<encode+?>: load.i32
	cmplStd/lib/text/encoding/Utf8.ci:58: (320 bytes): if (cp < (128))
	<encode+?>: dup.x32 sp(0)
	<encode+?>: load.c32 128
	<encode+?>: clt.u32
	<encode+?>: jz +46
	cmplStd/lib/text/encoding/Utf8.ci:59: (11 bytes): bytes: uint8[1] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:59: (7 bytes): bytes[0] := (cp);
	<encode+?>: dup.x32 sp(1)
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:60: (23 bytes): writer.write(writer, bytes[...1]);
	<encode+?>: dup.x32 sp(3)
	<encode+?>: load.c32 1
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(6)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	<encode+?>: jmp +270
	cmplStd/lib/text/encoding/Utf8.ci:62: (266 bytes): if (cp < (2048))
	<encode+?>: dup.x32 sp(0)
	<encode+?>: load.c32 2048
	<encode+?>: clt.u32
	<encode+?>: jz +69
	cmplStd/lib/text/encoding/Utf8.ci:63: (34 bytes): bytes: uint8[2] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:64: (15 bytes): bytes[0] := (192 | ((cp >> 6)));
	<encode+?>: load.c32 192
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x06
	<encode+?>: or.b32
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:65: (15 bytes): bytes[1] := (128 | ((cp & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+5)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:67: (23 bytes): writer.write(writer, bytes[...2]);
	<encode+?>: dup.x32 sp(3)
	<encode+?>: load.c32 2
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(6)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	<encode+?>: jmp +193
	cmplStd/lib/text/encoding/Utf8.ci:69: (189 bytes): if (cp < (65536))
	<encode+?>: dup.x32 sp(0)
	<encode+?>: load.c32 65536
	<encode+?>: clt.u32
	<encode+?>: jz +86
	cmplStd/lib/text/encoding/Utf8.ci:70: (51 bytes): bytes: uint8[3] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:71: (15 bytes): bytes[0] := (224 | ((cp >> 12)));
	<encode+?>: load.c32 224
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x0c
	<encode+?>: or.b32
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:72: (17 bytes): bytes[1] := (128 | (((cp >> 6) & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x06
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+5)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:73: (15 bytes): bytes[2] := (128 | ((cp & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+6)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:75: (23 bytes): writer.write(writer, bytes[...3]);
	<encode+?>: dup.x32 sp(3)
	<encode+?>: load.c32 3
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(6)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	<encode+?>: jmp +99
	cmplStd/lib/text/encoding/Utf8.ci:78: (68 bytes): bytes: uint8[4] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:79: (15 bytes): bytes[0] := (240 | ((cp >> 18)));
	<encode+?>: load.c32 240
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x12
	<encode+?>: or.b32
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:80: (17 bytes): bytes[1] := (128 | (((cp >> 12) & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x0c
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+5)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:81: (17 bytes): bytes[2] := (128 | (((cp >> 6) & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x06
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+6)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:82: (15 bytes): bytes[3] := (128 | ((cp & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+7)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:84: (23 bytes): writer.write(writer, bytes[...4]);
	<encode+?>: dup.x32 sp(3)
	<encode+?>: load.c32 4
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(6)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	<encode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Utf8.ci:55: (4 bytes): i := i + 1
	<encode+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/Utf8.ci:55: (9 bytes): i < (chars.length)
	<encode+?>: dup.x32 sp(0)
	<encode+?>: dup.x32 sp(5)
	<encode+?>: clt.i32
	<encode+?>: jnz -342
	<encode+?>: inc.sp(-4)
	<encode+?>: inc.sp(-4)
	<encode+?>: ret
.usages:
}
Easing: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Easing'
.file: 'cmplStd/lib/math/Easing.ci:4'
.field linear: function (size: 4, cast: static function)
.field quad: function (size: 8, cast: static function)
.field cubic: function (size: 11, cast: static function)
.field quart: function (size: 14, cast: static function)
.field quint: function (size: 17, cast: static function)
.field expo: function (size: 58, cast: static function)
.field sine: function (size: 47, cast: static function)
.field circle: function (size: 40, cast: static function)
.field elastic: function (size: 148, cast: static function)
.field back: function (size: 41, cast: static function)
.field bounce: function (size: 54, cast: static function)
.doc: 'Easing functions maps an input of [0, 1) usually to [0, 1) with an acceleration'
.usages:
}
Easing.linear(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 4
.name: 'linear'
.file: 'cmplStd/lib/math/Easing.ci:6'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t;
}
.instructions: (4 bytes)
	cmplStd/lib/math/Easing.ci:7: (4 bytes): return .result := t;
	<linear>  : mov.x64 sp(3, 1)
	<linear+?>: ret
.usages:
}
Easing.quad(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 8
.name: 'quad'
.file: 'cmplStd/lib/math/Easing.ci:11'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t * t;
}
.instructions: (8 bytes)
	cmplStd/lib/math/Easing.ci:12: (8 bytes): return .result := t * t;
	<quad>  : dup.x64 sp(1)
	<quad+?>: dup.x64 sp(3)
	<quad+?>: mul.f64
	<quad+?>: set.x64 sp(5)
	<quad+?>: ret
.usages:
}
Easing.cubic(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 11
.name: 'cubic'
.file: 'cmplStd/lib/math/Easing.ci:16'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t * t * t;
}
.instructions: (11 bytes)
	cmplStd/lib/math/Easing.ci:17: (11 bytes): return .result := t * t * t;
	<cubic>  : dup.x64 sp(1)
	<cubic+?>: dup.x64 sp(3)
	<cubic+?>: mul.f64
	<cubic+?>: dup.x64 sp(3)
	<cubic+?>: mul.f64
	<cubic+?>: set.x64 sp(5)
	<cubic+?>: ret
.usages:
}
Easing.quart(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 14
.name: 'quart'
.file: 'cmplStd/lib/math/Easing.ci:21'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t * t * t * t;
}
.instructions: (14 bytes)
	cmplStd/lib/math/Easing.ci:22: (14 bytes): return .result := t * t * t * t;
	<quart>  : dup.x64 sp(1)
	<quart+?>: dup.x64 sp(3)
	<quart+?>: mul.f64
	<quart+?>: dup.x64 sp(3)
	<quart+?>: mul.f64
	<quart+?>: dup.x64 sp(3)
	<quart+?>: mul.f64
	<quart+?>: set.x64 sp(5)
	<quart+?>: ret
.usages:
}
Easing.quint(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 17
.name: 'quint'
.file: 'cmplStd/lib/math/Easing.ci:26'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t * t * t * t * t;
}
.instructions: (17 bytes)
	cmplStd/lib/math/Easing.ci:27: (17 bytes): return .result := t * t * t * t * t;
	<quint>  : dup.x64 sp(1)
	<quint+?>: dup.x64 sp(3)
	<quint+?>: mul.f64
	<quint+?>: dup.x64 sp(3)
	<quint+?>: mul.f64
	<quint+?>: dup.x64 sp(3)
	<quint+?>: mul.f64
	<quint+?>: dup.x64 sp(3)
	<quint+?>: mul.f64
	<quint+?>: set.x64 sp(5)
	<quint+?>: ret
.usages:
}
Easing.expo(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 58
.name: 'expo'
.file: 'cmplStd/lib/math/Easing.ci:31'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t == (0) ? (0) : Math.pow(2.000000, (10) * (t - (1)));
}
.instructions: (58 bytes)
	cmplStd/lib/math/Easing.ci:32: (58 bytes): return .result := t == (0) ? (0) : Math.pow(2.000000, (10) * (t - (1)));
	<expo>  : dup.x64 sp(1)
	<expo+?>: load.z64
	<expo+?>: ceq.f64
	<expo+?>: jz +9
	<expo+?>: load.z64
	<expo+?>: jmp +46
	<expo+?>: load.z64
	<expo+?>: load.f64 2.000000
	<expo+?>: load.f64 10.000000
	<expo+?>: dup.x64 sp(7)
	<expo+?>: load.f64 1.000000
	<expo+?>: sub.f64
	<expo+?>: mul.f64
	<expo+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<expo+?>: call
	<expo+?>: inc.sp(-16)
	<expo+?>: set.x64 sp(5)
	<expo+?>: ret
.usages:
}
Easing.sine(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 47
.name: 'sine'
.file: 'cmplStd/lib/math/Easing.ci:36'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := -Math.cos(t * Math.pi / (2)) + (1);
}
.instructions: (47 bytes)
	cmplStd/lib/math/Easing.ci:37: (47 bytes): return .result := -Math.cos(t * Math.pi / (2)) + (1);
	<sine>  : load.z64
	<sine+?>: dup.x64 sp(3)
	<sine+?>: load.f64 3.141593
	<sine+?>: mul.f64
	<sine+?>: load.f64 2.000000
	<sine+?>: div.f64
	<sine+?>: load.ref <?> ;Math.cos(x: float64): float64
	<sine+?>: call
	<sine+?>: inc.sp(-8)
	<sine+?>: neg.f64
	<sine+?>: load.f64 1.000000
	<sine+?>: add.f64
	<sine+?>: set.x64 sp(5)
	<sine+?>: ret
.usages:
}
Easing.circle(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 40
.name: 'circle'
.file: 'cmplStd/lib/math/Easing.ci:41'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := -(Math.sqrt((1) - t * t) - (1));
}
.instructions: (40 bytes)
	cmplStd/lib/math/Easing.ci:42: (40 bytes): return .result := -(Math.sqrt((1) - t * t) - (1));
	<circle>  : load.z64
	<circle+?>: load.f64 1.000000
	<circle+?>: dup.x64 sp(5)
	<circle+?>: dup.x64 sp(7)
	<circle+?>: mul.f64
	<circle+?>: sub.f64
	<circle+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<circle+?>: call
	<circle+?>: inc.sp(-8)
	<circle+?>: load.f64 1.000000
	<circle+?>: sub.f64
	<circle+?>: neg.f64
	<circle+?>: set.x64 sp(5)
	<circle+?>: ret
.usages:
}
Easing.elastic(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 148
.name: 'elastic'
.file: 'cmplStd/lib/math/Easing.ci:46'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	if (t == 0.000000 || t == 1.000000) {
		return .result := t;
	}
	t := t - 1.000000;
	return .result := -Math.pow(2.000000, 10.000000 * t) * Math.sin((t - 0.300000 / 4.000000) * (2.000000 * Math.pi) / 0.300000);
}
.instructions: (148 bytes)
	cmplStd/lib/math/Easing.ci:47: (34 bytes): if (t == 0.000000 || t == 1.000000)
	<elastic>  : dup.x64 sp(1)
	<elastic+?>: load.z64
	<elastic+?>: ceq.f64
	<elastic+?>: dup.x32 sp(0)
	<elastic+?>: jnz +20
	<elastic+?>: inc.sp(-4)
	<elastic+?>: dup.x64 sp(1)
	<elastic+?>: load.f64 1.000000
	<elastic+?>: ceq.f64
	<elastic+?>: jz +8
	cmplStd/lib/math/Easing.ci:47: (4 bytes): return .result := t;
	<elastic+?>: mov.x64 sp(3, 1)
	<elastic+?>: ret
	cmplStd/lib/math/Easing.ci:48: (14 bytes): t := t - 1.000000;
	<elastic+?>: dup.x64 sp(1)
	<elastic+?>: load.f64 1.000000
	<elastic+?>: sub.f64
	<elastic+?>: set.x64 sp(3)
	cmplStd/lib/math/Easing.ci:49: (100 bytes): return .result := -Math.pow(2.000000, 10.000000 * t) * Math.sin((t - 0.300000 / 4.000000) * (2.000000 * Math.pi) / 0.300000);
	<elastic+?>: load.z64
	<elastic+?>: load.f64 2.000000
	<elastic+?>: load.f64 10.000000
	<elastic+?>: dup.x64 sp(7)
	<elastic+?>: mul.f64
	<elastic+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<elastic+?>: call
	<elastic+?>: inc.sp(-16)
	<elastic+?>: neg.f64
	<elastic+?>: load.z64
	<elastic+?>: dup.x64 sp(5)
	<elastic+?>: load.f64 0.300000
	<elastic+?>: load.f64 4.000000
	<elastic+?>: div.f64
	<elastic+?>: sub.f64
	<elastic+?>: load.f64 2.000000
	<elastic+?>: load.f64 3.141593
	<elastic+?>: mul.f64
	<elastic+?>: mul.f64
	<elastic+?>: load.f64 0.300000
	<elastic+?>: div.f64
	<elastic+?>: load.ref <?> ;Math.sin(x: float64): float64
	<elastic+?>: call
	<elastic+?>: inc.sp(-8)
	<elastic+?>: mul.f64
	<elastic+?>: set.x64 sp(5)
	<elastic+?>: ret
.usages:
}
Easing.back(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 41
.name: 'back'
.file: 'cmplStd/lib/math/Easing.ci:53'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	s: typename := 1.701580;
	return .result := t * t * ((s + (1)) * t - s);
}
.instructions: (41 bytes)
	cmplStd/lib/math/Easing.ci:55: (41 bytes): return .result := t * t * ((s + (1)) * t - s);
	<back>  : dup.x64 sp(1)
	<back+?>: dup.x64 sp(3)
	<back+?>: mul.f64
	<back+?>: load.f64 1.701580
	<back+?>: load.f64 1.000000
	<back+?>: add.f64
	<back+?>: dup.x64 sp(5)
	<back+?>: mul.f64
	<back+?>: load.f64 1.701580
	<back+?>: sub.f64
	<back+?>: mul.f64
	<back+?>: set.x64 sp(5)
	<back+?>: ret
.usages:
}
Easing.bounce(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 54
.name: 'bounce'
.file: 'cmplStd/lib/math/Easing.ci:59'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	static Helper(t: float64, c: float64, a: float64): float64 := {
		if (t == (1)) {
			return .result := c;
		}
		if (t < ((4) / 11.000000)) {
			return .result := c * (7.562500 * t * t);
		}
		if (t < ((8) / 11.000000)) {
			t := t - ((6) / 11.000000);
			return .result := -a * ((1) - (7.562500 * t * t + 0.750000)) + c;
		}
		if (t < ((10) / 11.000000)) {
			t := t - (((9) / 11.000000));
			return .result := -a * ((1) - (7.562500 * t * t + 0.937500)) + c;
		}
		t := t - ((21) / 22.000000);
		return .result := -a * ((1) - (7.562500 * t * t + 0.984375)) + c;
	};
	a: typename := 1.701580;
	return .result := (1) - Helper((1) - t, 1, a);
}
.instructions: (54 bytes)
	cmplStd/lib/math/Easing.ci:79: (54 bytes): return .result := (1) - Helper((1) - t, 1, a);
	<bounce>  : load.f64 1.000000
	<bounce+?>: load.z64
	<bounce+?>: load.f64 1.000000
	<bounce+?>: dup.x64 sp(7)
	<bounce+?>: sub.f64
	<bounce+?>: load.f64 1.000000
	<bounce+?>: load.f64 1.701580
	<bounce+?>: load.ref <?> ;Easing.bounce.Helper(t: float64, c: float64, a: float64): float64
	<bounce+?>: call
	<bounce+?>: inc.sp(-24)
	<bounce+?>: sub.f64
	<bounce+?>: set.x64 sp(5)
	<bounce+?>: ret
.usages:
}
in(ease(ratio: float64): float64, ratio: float64): float64: function {
.kind: static function
.base: `function`
.size: 29
.name: 'in'
.file: 'cmplStd/lib/math/Easing.ci:84'
.param .result: float64 (size: 8, cast: variable(f64))
.param ease: function (size: 4, cast: variable(ref))
.param ratio: float64 (size: 8, cast: variable(f64))
.doc: 'ease in, ex: Easing.elastic.in(t)'
.value: {
	if ((ease) == null) {
		return .result := ratio;
	}
	return .result := ease(ratio);
}
.instructions: (29 bytes)
	cmplStd/lib/math/Easing.ci:85: (16 bytes): if ((ease) == null)
	<in>  : dup.x32 sp(3)
	<in+?>: load.ref <?> ;null
	<in+?>: ceq.i32
	<in+?>: jz +8
	cmplStd/lib/math/Easing.ci:86: (4 bytes): return .result := ratio;
	<in+?>: mov.x64 sp(4, 1)
	<in+?>: ret
	cmplStd/lib/math/Easing.ci:88: (13 bytes): return .result := ease(ratio);
	<in+?>: load.z64
	<in+?>: dup.x64 sp(3)
	<in+?>: dup.x32 sp(7)
	<in+?>: call
	<in+?>: inc.sp(-8)
	<in+?>: set.x64 sp(6)
	<in+?>: ret
.usages:
}
out(ease(ratio: float64): float64, ratio: float64): float64: function {
.kind: static function
.base: `function`
.size: 49
.name: 'out'
.file: 'cmplStd/lib/math/Easing.ci:92'
.param .result: float64 (size: 8, cast: variable(f64))
.param ease: function (size: 4, cast: variable(ref))
.param ratio: float64 (size: 8, cast: variable(f64))
.doc: 'ease out, ex: Easing.elastic.out(t)'
.value: {
	if ((ease) == null) {
		return .result := ratio;
	}
	return .result := 1.000000 - ease((1) - ratio);
}
.instructions: (49 bytes)
	cmplStd/lib/math/Easing.ci:93: (16 bytes): if ((ease) == null)
	<out>  : dup.x32 sp(3)
	<out+?>: load.ref <?> ;null
	<out+?>: ceq.i32
	<out+?>: jz +8
	cmplStd/lib/math/Easing.ci:94: (4 bytes): return .result := ratio;
	<out+?>: mov.x64 sp(4, 1)
	<out+?>: ret
	cmplStd/lib/math/Easing.ci:96: (33 bytes): return .result := 1.000000 - ease((1) - ratio);
	<out+?>: load.f64 1.000000
	<out+?>: load.z64
	<out+?>: load.f64 1.000000
	<out+?>: dup.x64 sp(7)
	<out+?>: sub.f64
	<out+?>: dup.x32 sp(9)
	<out+?>: call
	<out+?>: inc.sp(-8)
	<out+?>: sub.f64
	<out+?>: set.x64 sp(6)
	<out+?>: ret
.usages:
	cmplStd/lib/math/Easing.ci:114: referenced as `out`
	cmplStd/lib/math/Easing.ci:105: referenced as `out`
}
inOut(ease(ratio: float64): float64, ratio: float64): float64: function {
.kind: static function
.base: `function`
.size: 118
.name: 'inOut'
.file: 'cmplStd/lib/math/Easing.ci:100'
.param .result: float64 (size: 8, cast: variable(f64))
.param ease: function (size: 4, cast: variable(ref))
.param ratio: float64 (size: 8, cast: variable(f64))
.doc: 'ease in and out, ex: Easing.elastic.inOut(t)'
.value: {
	if ((ease) == null) {
		return .result := ratio;
	}
	ratio := ratio * (2);
	return .result := (ratio < (1)) ? 0.500000 * ease(ratio) : 0.500000 * out(ease, ratio - (1)) + 0.500000;
}
.instructions: (118 bytes)
	cmplStd/lib/math/Easing.ci:101: (16 bytes): if ((ease) == null)
	<inOut>  : dup.x32 sp(3)
	<inOut+?>: load.ref <?> ;null
	<inOut+?>: ceq.i32
	<inOut+?>: jz +8
	cmplStd/lib/math/Easing.ci:102: (4 bytes): return .result := ratio;
	<inOut+?>: mov.x64 sp(4, 1)
	<inOut+?>: ret
	cmplStd/lib/math/Easing.ci:104: (14 bytes): ratio := ratio * (2);
	<inOut+?>: dup.x64 sp(1)
	<inOut+?>: load.f64 2.000000
	<inOut+?>: mul.f64
	<inOut+?>: set.x64 sp(3)
	cmplStd/lib/math/Easing.ci:105: (88 bytes): return .result := (ratio < (1)) ? 0.500000 * ease(ratio) : 0.500000 * out(ease, ratio - (1)) + 0.500000;
	<inOut+?>: dup.x64 sp(1)
	<inOut+?>: load.f64 1.000000
	<inOut+?>: clt.f64
	<inOut+?>: jz +28
	<inOut+?>: load.f64 0.500000
	<inOut+?>: load.z64
	<inOut+?>: dup.x64 sp(5)
	<inOut+?>: dup.x32 sp(9)
	<inOut+?>: call
	<inOut+?>: inc.sp(-8)
	<inOut+?>: mul.f64
	<inOut+?>: jmp +49
	<inOut+?>: load.f64 0.500000
	<inOut+?>: load.z64
	<inOut+?>: dup.x32 sp(7)
	<inOut+?>: dup.x64 sp(6)
	<inOut+?>: load.f64 1.000000
	<inOut+?>: sub.f64
	<inOut+?>: load.ref <?> ;out(ease(ratio: float64): float64, ratio: float64): float64
	<inOut+?>: call
	<inOut+?>: inc.sp(-12)
	<inOut+?>: mul.f64
	<inOut+?>: load.f64 0.500000
	<inOut+?>: add.f64
	<inOut+?>: set.x64 sp(6)
	<inOut+?>: ret
.usages:
}
outIn(ease(ratio: float64): float64, ratio: float64): float64: function {
.kind: static function
.base: `function`
.size: 118
.name: 'outIn'
.file: 'cmplStd/lib/math/Easing.ci:109'
.param .result: float64 (size: 8, cast: variable(f64))
.param ease: function (size: 4, cast: variable(ref))
.param ratio: float64 (size: 8, cast: variable(f64))
.doc: 'ease out and in, ex: Easing.elastic.outIn(t)'
.value: {
	if ((ease) == null) {
		return .result := ratio;
	}
	ratio := ratio * (2);
	return .result := (ratio < (1)) ? 0.500000 * out(ease, ratio) : 0.500000 * ease(ratio - (1)) + 0.500000;
}
.instructions: (118 bytes)
	cmplStd/lib/math/Easing.ci:110: (16 bytes): if ((ease) == null)
	<outIn>  : dup.x32 sp(3)
	<outIn+?>: load.ref <?> ;null
	<outIn+?>: ceq.i32
	<outIn+?>: jz +8
	cmplStd/lib/math/Easing.ci:111: (4 bytes): return .result := ratio;
	<outIn+?>: mov.x64 sp(4, 1)
	<outIn+?>: ret
	cmplStd/lib/math/Easing.ci:113: (14 bytes): ratio := ratio * (2);
	<outIn+?>: dup.x64 sp(1)
	<outIn+?>: load.f64 2.000000
	<outIn+?>: mul.f64
	<outIn+?>: set.x64 sp(3)
	cmplStd/lib/math/Easing.ci:114: (88 bytes): return .result := (ratio < (1)) ? 0.500000 * out(ease, ratio) : 0.500000 * ease(ratio - (1)) + 0.500000;
	<outIn+?>: dup.x64 sp(1)
	<outIn+?>: load.f64 1.000000
	<outIn+?>: clt.f64
	<outIn+?>: jz +33
	<outIn+?>: load.f64 0.500000
	<outIn+?>: load.z64
	<outIn+?>: dup.x32 sp(7)
	<outIn+?>: dup.x64 sp(6)
	<outIn+?>: load.ref <?> ;out(ease(ratio: float64): float64, ratio: float64): float64
	<outIn+?>: call
	<outIn+?>: inc.sp(-12)
	<outIn+?>: mul.f64
	<outIn+?>: jmp +44
	<outIn+?>: load.f64 0.500000
	<outIn+?>: load.z64
	<outIn+?>: dup.x64 sp(5)
	<outIn+?>: load.f64 1.000000
	<outIn+?>: sub.f64
	<outIn+?>: dup.x32 sp(9)
	<outIn+?>: call
	<outIn+?>: inc.sp(-8)
	<outIn+?>: mul.f64
	<outIn+?>: load.f64 0.500000
	<outIn+?>: add.f64
	<outIn+?>: set.x64 sp(6)
	<outIn+?>: ret
.usages:
}
scalar: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'scalar'
.file: 'cmplStd/lib/math/Polynomial.ci:1'
.value: float64
.usages:
}
Polynomial: TextWriter.Writeable {
.kind: static const typename(ref)
.base: `TextWriter.Writeable`
.size: 20
.name: 'Polynomial'
.file: 'cmplStd/lib/math/Polynomial.ci:4'
.field coefficients: float64[*] (size: 4, cast: variable(ref))
.field capacity: int32 (size: 4, cast: variable(i32))
.field c_zero: float64 (size: 0, cast: static const val)
.field c_unit: float64 (size: 0, cast: static const val)
.field write: function (size: 411, cast: static function)
.field destroy: function (size: 17, cast: static function)
.field destroy: function (size: 4, cast: const variable(ref))
.field create: function (size: 253, cast: static function)
.field degree: function (size: 58, cast: static function)
.field get: function (size: 100, cast: static function)
.field set: function (size: 140, cast: static function)
.field neg: function (size: 93, cast: static function)
.field add: function (size: 145, cast: static function)
.field sub: function (size: 145, cast: static function)
.field mul: function (size: 169, cast: static function)
.field evaluate: function (size: 59, cast: static function)
.field derivative: function (size: 107, cast: static function)
.field integral: function (size: 117, cast: static function)
.field write: function (size: 4, cast: variable(ref))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplStd/lib/math/Polynomial.ci:178: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:178: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:177: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:174: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:174: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:164: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:163: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:163: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:155: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:154: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:154: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:145: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:135: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:132: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:132: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:132: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:123: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:123: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:123: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:114: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:114: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:114: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:106: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:105: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:105: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:98: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:89: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:79: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:63: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:59: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:54: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:14: referenced as `Polynomial`
}
Polynomial.coefficients: float64[*] {
.kind: variable(ref)
.base: `float64[*]`
.size: 4
.name: 'coefficients'
.file: 'cmplStd/lib/math/Polynomial.ci:5'
.owner: Polynomial
.usages:
	cmplStd/lib/math/Polynomial.ci:180: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:174: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:167: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:167: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:165: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:157: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:157: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:148: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:138: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:126: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:117: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:108: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:101: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:94: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:81: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:73: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:70: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:65: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:55: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:21: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:17: referenced as `coefficients`
}
Polynomial.capacity: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'capacity'
.file: 'cmplStd/lib/math/Polynomial.ci:6'
.owner: Polynomial
.usages:
	cmplStd/lib/math/Polynomial.ci:166: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:156: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:125: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:116: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:107: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:100: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:91: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:80: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:66: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:16: referenced as `capacity`
}
Polynomial.c_zero: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'c_zero'
.file: 'cmplStd/lib/math/Polynomial.ci:9'
.owner: Polynomial
.doc: 'c_zero'
.value: (0)
.usages:
	cmplStd/lib/math/Polynomial.ci:146: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:92: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:81: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:73: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:22: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:17: referenced as `c_zero`
}
Polynomial.c_unit: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'c_unit'
.file: 'cmplStd/lib/math/Polynomial.ci:10'
.owner: Polynomial
.doc: 'c_unit'
.value: (1)
.usages:
	cmplStd/lib/math/Polynomial.ci:38: referenced as `c_unit`
}
Polynomial.write(this: Polynomial, writer: TextWriter): void: function {
.kind: static function
.base: `function`
.size: 411
.name: 'write'
.file: 'cmplStd/lib/math/Polynomial.ci:14'
.owner: Polynomial
.param .result: void (size: 0, cast: variable(void))
.param this: Polynomial (size: 4, cast: variable(ref))
.param writer: TextWriter (size: 4, cast: variable(ref))
.value: {
	first: bool := true;
	for (i: int32 := this.capacity - 1; i >= 0; i := i - 1) {
		if (this.coefficients[i] == c_zero && !(first && i == 0)) {
			continue;
		}
		value: float64 := this.coefficients[i];
		if (value < c_zero) {
			value := -value;
			if (!first) {
				TextWriter.write(writer, " - ");
			}
			else {
				TextWriter.write(writer, "-");
			}
		}
		else if (!first) {
			TextWriter.write(writer, " + ");
		}
		if (value != c_unit || i == 0) {
			TextWriter.write(writer, value, writer.format);
		}
		if (i > 0) {
			TextWriter.write(writer, "x");
			if (i > 1) {
				TextWriter.write(writer, "^");
				TextWriter.write(writer, i, writer.format);
			}
		}
		first := false;
	}
}
.instructions: (411 bytes)
	cmplStd/lib/math/Polynomial.ci:15: (5 bytes): first: bool := true
	<write>  : load.c32 1
	cmplStd/lib/math/Polynomial.ci:16: (401 bytes): for (i: int32 := this.capacity - 1; i >= 0; i := i - 1)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+12)
	<write+?>: load.i32
	<write+?>: inc.i32(-1)
	<write+?>: jmp +378
	cmplStd/lib/math/Polynomial.ci:17: (54 bytes): if (this.coefficients[i] == c_zero && !(first && i == 0))
	<write+?>: dup.x32 sp(4)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(1)
	<write+?>: mad.u32 8
	<write+?>: load.i64
	<write+?>: load.z64
	<write+?>: ceq.f64
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +28
	<write+?>: inc.sp(-4)
	<write+?>: load.sp(+4)
	<write+?>: load.is8
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +12
	<write+?>: inc.sp(-4)
	<write+?>: dup.x32 sp(0)
	<write+?>: load.z32
	<write+?>: ceq.i32
	<write+?>: not.b32
	<write+?>: jz +8
	cmplStd/lib/math/Polynomial.ci:18: (4 bytes): continue;
	<write+?>: jmp +320
	cmplStd/lib/math/Polynomial.ci:21: (14 bytes): value: float64 := this.coefficients[i]
	<write+?>: dup.x32 sp(4)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(1)
	<write+?>: mad.u32 8
	<write+?>: load.i64
	cmplStd/lib/math/Polynomial.ci:22: (125 bytes): if (value < c_zero)
	<write+?>: dup.x64 sp(0)
	<write+?>: load.z64
	<write+?>: clt.f64
	<write+?>: jz +82
	cmplStd/lib/math/Polynomial.ci:23: (1 byte): value := -value;
	<write+?>: neg.f64
	cmplStd/lib/math/Polynomial.ci:24: (73 bytes): if (!first)
	<write+?>: load.sp(+12)
	<write+?>: load.is8
	<write+?>: jnz +38
	cmplStd/lib/math/Polynomial.ci:26: (30 bytes): TextWriter.write(writer, " - ");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 3
	<write+?>: load.ref <?> ;" - "
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	<write+?>: jmp +34
	cmplStd/lib/math/Polynomial.ci:30: (30 bytes): TextWriter.write(writer, "-");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 1
	<write+?>: load.ref <?> ;"-"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	<write+?>: jmp +43
	cmplStd/lib/math/Polynomial.ci:33: (39 bytes): if (!first)
	<write+?>: load.sp(+12)
	<write+?>: load.is8
	<write+?>: jnz +34
	cmplStd/lib/math/Polynomial.ci:35: (30 bytes): TextWriter.write(writer, " + ");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 3
	<write+?>: load.ref <?> ;" + "
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:38: (59 bytes): if (value != c_unit || i == 0)
	<write+?>: dup.x64 sp(0)
	<write+?>: load.f64 1.000000
	<write+?>: ceq.f64
	<write+?>: not.b32
	<write+?>: dup.x32 sp(0)
	<write+?>: jnz +12
	<write+?>: inc.sp(-4)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.z32
	<write+?>: ceq.i32
	<write+?>: jz +32
	cmplStd/lib/math/Polynomial.ci:39: (28 bytes): TextWriter.write(writer, value, writer.format);
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: dup.x64 sp(2)
	<write+?>: dup.x32 sp(9)
	<write+?>: inc.i32(+12)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: float64, flags: FormatFlags): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-16)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:42: (108 bytes): if (i > 0)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.z32
	<write+?>: cgt.i32
	<write+?>: jz +104
	cmplStd/lib/math/Polynomial.ci:43: (30 bytes): TextWriter.write(writer, "x");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 1
	<write+?>: load.ref <?> ;"x"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:44: (70 bytes): if (i > 1)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.c32 1
	<write+?>: cgt.i32
	<write+?>: jz +62
	cmplStd/lib/math/Polynomial.ci:45: (30 bytes): TextWriter.write(writer, "^");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 1
	<write+?>: load.ref <?> ;"^"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:46: (28 bytes): TextWriter.write(writer, i, writer.format);
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(8)
	<write+?>: inc.i32(+12)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: int32, flags: FormatFlags): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:49: (6 bytes): first := false;
	<write+?>: load.z32
	<write+?>: load.sp(+16)
	<write+?>: store.i8
	<write+?>: inc.sp(-8)
	cmplStd/lib/math/Polynomial.ci:16: (4 bytes): i := i - 1
	<write+?>: inc.i32(-1)
	cmplStd/lib/math/Polynomial.ci:16: (8 bytes): i >= 0
	<write+?>: dup.x32 sp(0)
	<write+?>: load.z32
	<write+?>: clt.i32
	<write+?>: jz -378
	<write+?>: inc.sp(-4)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
}
Polynomial.destroy(this: Polynomial): void: function {
.kind: static function
.base: `function`
.size: 17
.name: 'destroy'
.file: 'cmplStd/lib/math/Polynomial.ci:54'
.owner: Polynomial
.param .result: void (size: 0, cast: variable(void))
.param this: Polynomial (size: 4, cast: variable(ref))
.doc: 'Dispose the polynomial, free up used memory for coefficients'
.value: {
	pointer.alloc(this.coefficients, 0);
}
.instructions: (17 bytes)
	cmplStd/lib/math/Polynomial.ci:55: (16 bytes): pointer.alloc(this.coefficients, 0);
	<destroy>  : dup.x32 sp(1)
	<destroy+?>: inc.i32(+8)
	<destroy+?>: load.i32
	<destroy+?>: load.z32
	<destroy+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<destroy+?>: inc.sp(-4)
	<destroy+?>: ret
.usages:
}
Polynomial.destroy(this: Polynomial): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'destroy'
.file: 'cmplStd/lib/math/Polynomial.ci:54'
.owner: Polynomial
.param .result: void (size: 0, cast: variable(void))
.param this: Polynomial (size: 4, cast: variable(ref))
.doc: 'Dispose the polynomial, free up used memory for coefficients'
.value: destroy
.usages:
	internal usages: 1
}
Polynomial.create(degree: int32, values: float64[]): Polynomial: function {
.kind: static function
.base: `function`
.size: 253
.name: 'create'
.file: 'cmplStd/lib/math/Polynomial.ci:59'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param degree: int32 (size: 4, cast: variable(i32))
.param values: float64[] (size: 8, cast: variable(arr))
.value: {
	capacity: int32 := Math.max(0, degree) + 1;
	assert(capacity >= (values.length));
	coefficients: float64[*] := pointer.alloc(null, capacity * sizeof(float64));
	result: Polynomial := {
		result := create(Polynomial);
		result.coefficients := (coefficients);
		result.capacity := capacity;
		result.destroy := destroy;
		result.write := write;
	};
	for (i: int32 := 0; i < (values.length); i := i + 1) {
		result.coefficients[i] := values[i];
	}
	for (i: int32 := values.length; i < capacity; i := i + 1) {
		result.coefficients[i] := c_zero;
	}
	return .result := result;
}
.instructions: (253 bytes)
	cmplStd/lib/math/Polynomial.ci:60: (31 bytes): capacity: int32 := Math.max(0, degree) + 1
	<create>  : load.z32
	<create+?>: dup.x32 sp(4)
	<create+?>: dup.x32 sp(1)
	<create+?>: dup.x32 sp(1)
	<create+?>: cgt.i32
	<create+?>: jz +10
	<create+?>: dup.x32 sp(1)
	<create+?>: jmp +6
	<create+?>: dup.x32 sp(0)
	<create+?>: mov.x32 sp(2, 0)
	<create+?>: inc.sp(-8)
	<create+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:61: (53 bytes): assert(capacity >= (values.length));
	<create+?>: load.z32
	<create+?>: load.sp(+4)
	<create+?>: dup.x32 sp(2)
	<create+?>: dup.x32 sp(6)
	<create+?>: clt.i32
	<create+?>: jnz +8
	<create+?>: jmp +35
	<create+?>: load.ref <?> ;"cmplStd/lib/math/Polynomial.ci"
	<create+?>: load.c32 61
	<create+?>: load.c32 -2
	<create+?>: load.c32 128
	<create+?>: load.ref <?> ;"assertion failed!"
	<create+?>: dup.x64 sp(5)
	<create+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<create+?>: inc.sp(-8)
	cmplStd/lib/math/Polynomial.ci:62: (21 bytes): coefficients: float64[*] := pointer.alloc(null, capacity * sizeof(float64))
	<create+?>: load.ref <?> ;null
	<create+?>: dup.x32 sp(1)
	<create+?>: load.ref <?> ;float64
	<create+?>: nfc(6) ;typename.size(type: typename): int32
	<create+?>: mul.i32
	<create+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/lib/math/Polynomial.ci:63: (57 bytes): result: Polynomial := {...}
	<create+?>: inc.sp(+4)
	cmplStd/lib/math/Polynomial.ci:63: (11 bytes): result := create(Polynomial);
	<create+?>: load.ref <?> ;Polynomial
	<create+?>: nfc(7) ;object.create(type: typename): pointer
	<create+?>: set.x32 sp(1)
	cmplStd/lib/math/Polynomial.ci:65: (9 bytes): result.coefficients := (coefficients);
	<create+?>: dup.x32 sp(1)
	<create+?>: dup.x32 sp(1)
	<create+?>: inc.i32(+8)
	<create+?>: store.i32
	cmplStd/lib/math/Polynomial.ci:66: (9 bytes): result.capacity := capacity;
	<create+?>: dup.x32 sp(2)
	<create+?>: dup.x32 sp(1)
	<create+?>: inc.i32(+12)
	<create+?>: store.i32
	:: (12 bytes): result.destroy := destroy;
	<create+?>: load.ref <?> ;Polynomial.destroy(this: Polynomial): void
	<create+?>: dup.x32 sp(1)
	<create+?>: inc.i32(+16)
	<create+?>: store.i32
	:: (12 bytes): result.write := write;
	<create+?>: load.ref <?> ;Polynomial.write(this: Polynomial, writer: TextWriter): void
	<create+?>: dup.x32 sp(1)
	<create+?>: inc.i32(+4)
	<create+?>: store.i32
	cmplStd/lib/math/Polynomial.ci:69: (45 bytes): for (i: int32 := 0; i < (values.length); i := i + 1)
	<create+?>: load.z32
	<create+?>: jmp +31
	cmplStd/lib/math/Polynomial.ci:70: (23 bytes): result.coefficients[i] := values[i];
	<create+?>: dup.x32 sp(5)
	<create+?>: dup.x32 sp(1)
	<create+?>: mad.u32 8
	<create+?>: load.i64
	<create+?>: dup.x32 sp(3)
	<create+?>: inc.i32(+8)
	<create+?>: load.i32
	<create+?>: dup.x32 sp(3)
	<create+?>: mad.u32 8
	<create+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:69: (4 bytes): i := i + 1
	<create+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:69: (9 bytes): i < (values.length)
	<create+?>: dup.x32 sp(0)
	<create+?>: dup.x32 sp(7)
	<create+?>: clt.i32
	<create+?>: jnz -32
	<create+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:72: (38 bytes): for (i: int32 := values.length; i < capacity; i := i + 1)
	<create+?>: dup.x32 sp(5)
	<create+?>: jmp +23
	cmplStd/lib/math/Polynomial.ci:73: (15 bytes): result.coefficients[i] := c_zero;
	<create+?>: load.z64
	<create+?>: dup.x32 sp(3)
	<create+?>: inc.i32(+8)
	<create+?>: load.i32
	<create+?>: dup.x32 sp(3)
	<create+?>: mad.u32 8
	<create+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:72: (4 bytes): i := i + 1
	<create+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:72: (9 bytes): i < capacity
	<create+?>: dup.x32 sp(0)
	<create+?>: dup.x32 sp(4)
	<create+?>: clt.i32
	<create+?>: jnz -24
	<create+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:75: (8 bytes): return .result := result;
	<create+?>: mov.x32 sp(7, 0)
	<create+?>: inc.sp(-12)
	<create+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:178: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:174: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:164: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:155: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:135: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:106: referenced as `create`
}
Polynomial.degree(this: Polynomial): int32: function {
.kind: static function
.base: `function`
.size: 58
.name: 'degree'
.file: 'cmplStd/lib/math/Polynomial.ci:79'
.owner: Polynomial
.param .result: int32 (size: 4, cast: variable(i32))
.param this: Polynomial (size: 4, cast: variable(ref))
.doc: 'Compute the degree of the polynomial'
.value: {
	for (i: int32 := this.capacity - 1; i > 0; i := i - 1) {
		if (this.coefficients[i] != c_zero) {
			return .result := i;
		}
	}
	return .result := 0;
}
.instructions: (58 bytes)
	cmplStd/lib/math/Polynomial.ci:80: (54 bytes): for (i: int32 := this.capacity - 1; i > 0; i := i - 1)
	<degree>  : dup.x32 sp(1)
	<degree+?>: inc.i32(+12)
	<degree+?>: load.i32
	<degree+?>: inc.i32(-1)
	<degree+?>: jmp +31
	cmplStd/lib/math/Polynomial.ci:81: (23 bytes): if (this.coefficients[i] != c_zero)
	<degree+?>: dup.x32 sp(2)
	<degree+?>: inc.i32(+8)
	<degree+?>: load.i32
	<degree+?>: dup.x32 sp(1)
	<degree+?>: mad.u32 8
	<degree+?>: load.i64
	<degree+?>: load.z64
	<degree+?>: ceq.f64
	<degree+?>: jnz +7
	cmplStd/lib/math/Polynomial.ci:82: (3 bytes): return .result := i;
	<degree+?>: set.x32 sp(3)
	<degree+?>: ret
	cmplStd/lib/math/Polynomial.ci:80: (4 bytes): i := i - 1
	<degree+?>: inc.i32(-1)
	cmplStd/lib/math/Polynomial.ci:80: (8 bytes): i > 0
	<degree+?>: dup.x32 sp(0)
	<degree+?>: load.z32
	<degree+?>: cgt.i32
	<degree+?>: jnz -31
	<degree+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:85: (4 bytes): return .result := 0;
	<degree+?>: load.z32
	<degree+?>: set.x32 sp(3)
	<degree+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:174: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:164: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:155: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:147: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:134: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:133: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:106: referenced as `degree`
}
Polynomial.get(this: Polynomial, index: int32): float64: function {
.kind: static function
.base: `function`
.size: 100
.name: 'get'
.file: 'cmplStd/lib/math/Polynomial.ci:89'
.owner: Polynomial
.param .result: float64 (size: 8, cast: variable(f64))
.param this: Polynomial (size: 4, cast: const variable(ref))
.param index: int32 (size: 4, cast: variable(i32))
.doc: 'Get the nth coefficient of the polynomial'
.value: {
	assert(index >= 0, "negative index", index);
	if (index >= this.capacity) {
		return .result := c_zero;
	}
	return .result := this.coefficients[index];
}
.instructions: (100 bytes)
	cmplStd/lib/math/Polynomial.ci:90: (65 bytes): assert(index >= 0, "negative index", index);
	<get>  : load.ref <?> ;int32
	<get+?>: load.sp(+8)
	<get+?>: load.c32 1
	<get+?>: load.sp(+4)
	<get+?>: dup.x32 sp(5)
	<get+?>: load.z32
	<get+?>: clt.i32
	<get+?>: jnz +8
	<get+?>: jmp +35
	<get+?>: load.ref <?> ;"cmplStd/lib/math/Polynomial.ci"
	<get+?>: load.c32 90
	<get+?>: load.c32 -2
	<get+?>: load.c32 128
	<get+?>: load.ref <?> ;"negative index"
	<get+?>: dup.x64 sp(5)
	<get+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<get+?>: inc.sp(-16)
	cmplStd/lib/math/Polynomial.ci:91: (18 bytes): if (index >= this.capacity)
	<get+?>: dup.x32 sp(1)
	<get+?>: dup.x32 sp(3)
	<get+?>: inc.i32(+12)
	<get+?>: load.i32
	<get+?>: clt.i32
	<get+?>: jnz +8
	cmplStd/lib/math/Polynomial.ci:92: (4 bytes): return .result := c_zero;
	<get+?>: load.z64
	<get+?>: set.x64 sp(5)
	<get+?>: ret
	cmplStd/lib/math/Polynomial.ci:94: (17 bytes): return .result := this.coefficients[index];
	<get+?>: dup.x32 sp(2)
	<get+?>: inc.i32(+8)
	<get+?>: load.i32
	<get+?>: dup.x32 sp(2)
	<get+?>: mad.u32 8
	<get+?>: load.i64
	<get+?>: set.x64 sp(5)
	<get+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:138: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:138: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:126: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:126: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:117: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:117: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:108: referenced as `get`
}
Polynomial.set(this: Polynomial, index: int32, value: float64): float64: function {
.kind: static function
.base: `function`
.size: 140
.name: 'set'
.file: 'cmplStd/lib/math/Polynomial.ci:98'
.owner: Polynomial
.param .result: float64 (size: 8, cast: variable(f64))
.param this: Polynomial (size: 4, cast: variable(ref))
.param index: int32 (size: 4, cast: variable(i32))
.param value: float64 (size: 8, cast: variable(f64))
.doc: 'Set the nth coefficient of the polynomial'
.value: {
	assert(index >= 0, "negative index", index);
	assert(index < this.capacity, "invalid index");
	return .result := this.coefficients[index];
}
.instructions: (140 bytes)
	cmplStd/lib/math/Polynomial.ci:99: (65 bytes): assert(index >= 0, "negative index", index);
	<set>  : load.ref <?> ;int32
	<set+?>: load.sp(+16)
	<set+?>: load.c32 1
	<set+?>: load.sp(+4)
	<set+?>: dup.x32 sp(7)
	<set+?>: load.z32
	<set+?>: clt.i32
	<set+?>: jnz +8
	<set+?>: jmp +35
	<set+?>: load.ref <?> ;"cmplStd/lib/math/Polynomial.ci"
	<set+?>: load.c32 99
	<set+?>: load.c32 -2
	<set+?>: load.c32 128
	<set+?>: load.ref <?> ;"negative index"
	<set+?>: dup.x64 sp(5)
	<set+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<set+?>: inc.sp(-16)
	cmplStd/lib/math/Polynomial.ci:100: (58 bytes): assert(index < this.capacity, "invalid index");
	<set+?>: load.z32
	<set+?>: load.sp(+4)
	<set+?>: dup.x32 sp(5)
	<set+?>: dup.x32 sp(7)
	<set+?>: inc.i32(+12)
	<set+?>: load.i32
	<set+?>: clt.i32
	<set+?>: jz +8
	<set+?>: jmp +35
	<set+?>: load.ref <?> ;"cmplStd/lib/math/Polynomial.ci"
	<set+?>: load.c32 100
	<set+?>: load.c32 -2
	<set+?>: load.c32 128
	<set+?>: load.ref <?> ;"invalid index"
	<set+?>: dup.x64 sp(5)
	<set+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<set+?>: inc.sp(-8)
	cmplStd/lib/math/Polynomial.ci:101: (17 bytes): return .result := this.coefficients[index];
	<set+?>: dup.x32 sp(4)
	<set+?>: inc.i32(+8)
	<set+?>: load.i32
	<set+?>: dup.x32 sp(4)
	<set+?>: mad.u32 8
	<set+?>: load.i64
	<set+?>: set.x64 sp(7)
	<set+?>: ret
.usages:
}
Polynomial.neg(a: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 93
.name: 'neg'
.file: 'cmplStd/lib/math/Polynomial.ci:105'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param a: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Negate the polynomial'
.value: {
	result: Polynomial := create(degree(a), null);
	for (i: int32 := 0; i < result.capacity; i := i + 1) {
		result.coefficients[i] := -get(a, i);
	}
	return .result := result;
}
.instructions: (93 bytes)
	cmplStd/lib/math/Polynomial.ci:106: (33 bytes): result: Polynomial := create(degree(a), null)
	<neg>  : inc.sp(+4)
	<neg+?>: load.z32
	<neg+?>: dup.x32 sp(3)
	<neg+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<neg+?>: call
	<neg+?>: inc.sp(-4)
	<neg+?>: load.z32
	<neg+?>: load.ref <?> ;null
	<neg+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<neg+?>: call
	<neg+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:107: (57 bytes): for (i: int32 := 0; i < result.capacity; i := i + 1)
	<neg+?>: load.z32
	<neg+?>: jmp +38
	cmplStd/lib/math/Polynomial.ci:108: (30 bytes): result.coefficients[i] := -get(a, i);
	<neg+?>: load.z64
	<neg+?>: dup.x32 sp(5)
	<neg+?>: dup.x32 sp(3)
	<neg+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<neg+?>: call
	<neg+?>: inc.sp(-8)
	<neg+?>: neg.f64
	<neg+?>: dup.x32 sp(3)
	<neg+?>: inc.i32(+8)
	<neg+?>: load.i32
	<neg+?>: dup.x32 sp(3)
	<neg+?>: mad.u32 8
	<neg+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:107: (4 bytes): i := i + 1
	<neg+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:107: (14 bytes): i < result.capacity
	<neg+?>: dup.x32 sp(0)
	<neg+?>: dup.x32 sp(2)
	<neg+?>: inc.i32(+12)
	<neg+?>: load.i32
	<neg+?>: clt.i32
	<neg+?>: jnz -44
	<neg+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:110: (3 bytes): return .result := result;
	<neg+?>: set.x32 sp(3)
	<neg+?>: ret
.usages:
}
Polynomial.add(a: Polynomial, b: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 145
.name: 'add'
.file: 'cmplStd/lib/math/Polynomial.ci:114'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param a: Polynomial (size: 4, cast: const variable(ref))
.param b: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Add two polynomials'
.value: {
	result: Polynomial := create(Math.max(degree(a), degree(b)), null);
	for (i: int32 := 0; i < result.capacity; i := i + 1) {
		result.coefficients[i] := get(a, i) + get(b, i);
	}
	return .result := result;
}
.instructions: (145 bytes)
	cmplStd/lib/math/Polynomial.ci:115: (70 bytes): result: Polynomial := create(Math.max(degree(a), degree(b)), null)
	<add>  : inc.sp(+4)
	<add+?>: load.z32
	<add+?>: dup.x32 sp(4)
	<add+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<add+?>: call
	<add+?>: inc.sp(-4)
	<add+?>: load.z32
	<add+?>: dup.x32 sp(4)
	<add+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<add+?>: call
	<add+?>: inc.sp(-4)
	<add+?>: dup.x32 sp(1)
	<add+?>: dup.x32 sp(1)
	<add+?>: cgt.i32
	<add+?>: jz +10
	<add+?>: dup.x32 sp(1)
	<add+?>: jmp +6
	<add+?>: dup.x32 sp(0)
	<add+?>: mov.x32 sp(2, 0)
	<add+?>: inc.sp(-8)
	<add+?>: load.z32
	<add+?>: load.ref <?> ;null
	<add+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<add+?>: call
	<add+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:116: (72 bytes): for (i: int32 := 0; i < result.capacity; i := i + 1)
	<add+?>: load.z32
	<add+?>: jmp +53
	cmplStd/lib/math/Polynomial.ci:117: (45 bytes): result.coefficients[i] := get(a, i) + get(b, i);
	<add+?>: load.z64
	<add+?>: dup.x32 sp(6)
	<add+?>: dup.x32 sp(3)
	<add+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<add+?>: call
	<add+?>: inc.sp(-8)
	<add+?>: load.z64
	<add+?>: dup.x32 sp(7)
	<add+?>: dup.x32 sp(5)
	<add+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<add+?>: call
	<add+?>: inc.sp(-8)
	<add+?>: add.f64
	<add+?>: dup.x32 sp(3)
	<add+?>: inc.i32(+8)
	<add+?>: load.i32
	<add+?>: dup.x32 sp(3)
	<add+?>: mad.u32 8
	<add+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:116: (4 bytes): i := i + 1
	<add+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:116: (14 bytes): i < result.capacity
	<add+?>: dup.x32 sp(0)
	<add+?>: dup.x32 sp(2)
	<add+?>: inc.i32(+12)
	<add+?>: load.i32
	<add+?>: clt.i32
	<add+?>: jnz -59
	<add+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:119: (3 bytes): return .result := result;
	<add+?>: set.x32 sp(4)
	<add+?>: ret
.usages:
}
Polynomial.sub(a: Polynomial, b: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 145
.name: 'sub'
.file: 'cmplStd/lib/math/Polynomial.ci:123'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param a: Polynomial (size: 4, cast: const variable(ref))
.param b: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Subtract two polynomials'
.value: {
	result: Polynomial := create(Math.max(degree(a), degree(b)), null);
	for (i: int32 := 0; i < result.capacity; i := i + 1) {
		result.coefficients[i] := get(a, i) - get(b, i);
	}
	return .result := result;
}
.instructions: (145 bytes)
	cmplStd/lib/math/Polynomial.ci:124: (70 bytes): result: Polynomial := create(Math.max(degree(a), degree(b)), null)
	<sub>  : inc.sp(+4)
	<sub+?>: load.z32
	<sub+?>: dup.x32 sp(4)
	<sub+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<sub+?>: call
	<sub+?>: inc.sp(-4)
	<sub+?>: load.z32
	<sub+?>: dup.x32 sp(4)
	<sub+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<sub+?>: call
	<sub+?>: inc.sp(-4)
	<sub+?>: dup.x32 sp(1)
	<sub+?>: dup.x32 sp(1)
	<sub+?>: cgt.i32
	<sub+?>: jz +10
	<sub+?>: dup.x32 sp(1)
	<sub+?>: jmp +6
	<sub+?>: dup.x32 sp(0)
	<sub+?>: mov.x32 sp(2, 0)
	<sub+?>: inc.sp(-8)
	<sub+?>: load.z32
	<sub+?>: load.ref <?> ;null
	<sub+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<sub+?>: call
	<sub+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:125: (72 bytes): for (i: int32 := 0; i < result.capacity; i := i + 1)
	<sub+?>: load.z32
	<sub+?>: jmp +53
	cmplStd/lib/math/Polynomial.ci:126: (45 bytes): result.coefficients[i] := get(a, i) - get(b, i);
	<sub+?>: load.z64
	<sub+?>: dup.x32 sp(6)
	<sub+?>: dup.x32 sp(3)
	<sub+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<sub+?>: call
	<sub+?>: inc.sp(-8)
	<sub+?>: load.z64
	<sub+?>: dup.x32 sp(7)
	<sub+?>: dup.x32 sp(5)
	<sub+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<sub+?>: call
	<sub+?>: inc.sp(-8)
	<sub+?>: sub.f64
	<sub+?>: dup.x32 sp(3)
	<sub+?>: inc.i32(+8)
	<sub+?>: load.i32
	<sub+?>: dup.x32 sp(3)
	<sub+?>: mad.u32 8
	<sub+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:125: (4 bytes): i := i + 1
	<sub+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:125: (14 bytes): i < result.capacity
	<sub+?>: dup.x32 sp(0)
	<sub+?>: dup.x32 sp(2)
	<sub+?>: inc.i32(+12)
	<sub+?>: load.i32
	<sub+?>: clt.i32
	<sub+?>: jnz -59
	<sub+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:128: (3 bytes): return .result := result;
	<sub+?>: set.x32 sp(4)
	<sub+?>: ret
.usages:
}
Polynomial.mul(a: Polynomial, b: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 169
.name: 'mul'
.file: 'cmplStd/lib/math/Polynomial.ci:132'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param a: Polynomial (size: 4, cast: const variable(ref))
.param b: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Multiply two polynomials'
.value: {
	degreeA: int32 := degree(a);
	degreeB: int32 := degree(b);
	result: Polynomial := create(degreeA + degreeB, null);
	for (i: int32 := 0; i <= degreeA; i := i + 1) {
		for (j: int32 := 0; j <= degreeB; j := j + 1) {
			result.coefficients[i + j] := result.coefficients[i + j] + get(a, i) * get(b, j);
		}
	}
	return .result := result;
}
.instructions: (169 bytes)
	cmplStd/lib/math/Polynomial.ci:133: (13 bytes): degreeA: int32 := degree(a)
	<mul>  : load.z32
	<mul+?>: dup.x32 sp(3)
	<mul+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<mul+?>: call
	<mul+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:134: (13 bytes): degreeB: int32 := degree(b)
	<mul+?>: load.z32
	<mul+?>: dup.x32 sp(3)
	<mul+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<mul+?>: call
	<mul+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:135: (25 bytes): result: Polynomial := create(degreeA + degreeB, null)
	<mul+?>: inc.sp(+4)
	<mul+?>: dup.x32 sp(2)
	<mul+?>: dup.x32 sp(2)
	<mul+?>: add.i32
	<mul+?>: load.z32
	<mul+?>: load.ref <?> ;null
	<mul+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<mul+?>: call
	<mul+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:136: (110 bytes): for (i: int32 := 0; i <= degreeA; i := i + 1)
	<mul+?>: load.z32
	<mul+?>: jmp +96
	cmplStd/lib/math/Polynomial.ci:137: (88 bytes): for (j: int32 := 0; j <= degreeB; j := j + 1)
	<mul+?>: load.z32
	<mul+?>: jmp +74
	cmplStd/lib/math/Polynomial.ci:138: (66 bytes): result.coefficients[i + j] := result.coefficients[i + j] + get(a, i) * get(b, j);
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+8)
	<mul+?>: load.i32
	<mul+?>: dup.x32 sp(2)
	<mul+?>: dup.x32 sp(2)
	<mul+?>: add.i32
	<mul+?>: mad.u32 8
	<mul+?>: load.i64
	<mul+?>: load.z64
	<mul+?>: dup.x32 sp(11)
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<mul+?>: call
	<mul+?>: inc.sp(-8)
	<mul+?>: load.z64
	<mul+?>: dup.x32 sp(12)
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<mul+?>: call
	<mul+?>: inc.sp(-8)
	<mul+?>: mul.f64
	<mul+?>: add.f64
	<mul+?>: dup.x32 sp(4)
	<mul+?>: inc.i32(+8)
	<mul+?>: load.i32
	<mul+?>: dup.x32 sp(4)
	<mul+?>: dup.x32 sp(4)
	<mul+?>: add.i32
	<mul+?>: mad.u32 8
	<mul+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:137: (4 bytes): j := j + 1
	<mul+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:137: (9 bytes): j <= degreeB
	<mul+?>: dup.x32 sp(0)
	<mul+?>: dup.x32 sp(4)
	<mul+?>: cgt.i32
	<mul+?>: jz -75
	<mul+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:136: (4 bytes): i := i + 1
	<mul+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:136: (9 bytes): i <= degreeA
	<mul+?>: dup.x32 sp(0)
	<mul+?>: dup.x32 sp(4)
	<mul+?>: cgt.i32
	<mul+?>: jz -97
	<mul+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:141: (8 bytes): return .result := result;
	<mul+?>: mov.x32 sp(6, 0)
	<mul+?>: inc.sp(-12)
	<mul+?>: ret
.usages:
}
Polynomial.evaluate(this: Polynomial, value: float64): float64: function {
.kind: static function
.base: `function`
.size: 59
.name: 'evaluate'
.file: 'cmplStd/lib/math/Polynomial.ci:145'
.owner: Polynomial
.param .result: float64 (size: 8, cast: variable(f64))
.param this: Polynomial (size: 4, cast: const variable(ref))
.param value: float64 (size: 8, cast: variable(f64))
.doc: 'Evaluate the polynomial using Horner's method'
.value: {
	result: float64 := c_zero;
	for (i: int32 := degree(this); i >= 0; i := i - 1) {
		result := result * value + this.coefficients[i];
	}
	return .result := result;
}
.instructions: (59 bytes)
	cmplStd/lib/math/Polynomial.ci:146: (1 byte): result: float64 := c_zero
	<evaluate>  : load.z128
	cmplStd/lib/math/Polynomial.ci:147: (55 bytes): for (i: int32 := degree(this); i >= 0; i := i - 1)
	<evaluate+?>: i64.2i32
	<evaluate+?>: dup.x32 sp(6)
	<evaluate+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<evaluate+?>: call
	<evaluate+?>: inc.sp(-4)
	<evaluate+?>: jmp +30
	cmplStd/lib/math/Polynomial.ci:148: (22 bytes): result := result * value + this.coefficients[i];
	<evaluate+?>: dup.x64 sp(1)
	<evaluate+?>: dup.x64 sp(6)
	<evaluate+?>: mul.f64
	<evaluate+?>: dup.x32 sp(8)
	<evaluate+?>: inc.i32(+8)
	<evaluate+?>: load.i32
	<evaluate+?>: dup.x32 sp(3)
	<evaluate+?>: mad.u32 8
	<evaluate+?>: load.i64
	<evaluate+?>: add.f64
	<evaluate+?>: set.x64 sp(3)
	cmplStd/lib/math/Polynomial.ci:147: (4 bytes): i := i - 1
	<evaluate+?>: inc.i32(-1)
	cmplStd/lib/math/Polynomial.ci:147: (8 bytes): i >= 0
	<evaluate+?>: dup.x32 sp(0)
	<evaluate+?>: load.z32
	<evaluate+?>: clt.i32
	<evaluate+?>: jz -30
	<evaluate+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:150: (3 bytes): return .result := result;
	<evaluate+?>: set.x64 sp(6)
	<evaluate+?>: ret
.usages:
}
Polynomial.derivative(this: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 107
.name: 'derivative'
.file: 'cmplStd/lib/math/Polynomial.ci:154'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param this: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Compute the derivative of the polynomial'
.value: {
	result: Polynomial := create(degree(this) - 1, null);
	for (i: int32 := 0; i < result.capacity; i := i + 1) {
		result.coefficients[i] := ((i + 1)) * this.coefficients[i + 1];
	}
	return .result := result;
}
.instructions: (107 bytes)
	cmplStd/lib/math/Polynomial.ci:155: (37 bytes): result: Polynomial := create(degree(this) - 1, null)
	<derivative>  : inc.sp(+4)
	<derivative+?>: load.z32
	<derivative+?>: dup.x32 sp(3)
	<derivative+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<derivative+?>: call
	<derivative+?>: inc.sp(-4)
	<derivative+?>: inc.i32(-1)
	<derivative+?>: load.z32
	<derivative+?>: load.ref <?> ;null
	<derivative+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<derivative+?>: call
	<derivative+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:156: (67 bytes): for (i: int32 := 0; i < result.capacity; i := i + 1)
	<derivative+?>: load.z32
	<derivative+?>: jmp +48
	cmplStd/lib/math/Polynomial.ci:157: (40 bytes): result.coefficients[i] := ((i + 1)) * this.coefficients[i + 1];
	<derivative+?>: dup.x32 sp(0)
	<derivative+?>: inc.i32(+1)
	<derivative+?>: i32.2f64
	<derivative+?>: dup.x32 sp(5)
	<derivative+?>: inc.i32(+8)
	<derivative+?>: load.i32
	<derivative+?>: dup.x32 sp(3)
	<derivative+?>: inc.i32(+1)
	<derivative+?>: mad.u32 8
	<derivative+?>: load.i64
	<derivative+?>: mul.f64
	<derivative+?>: dup.x32 sp(3)
	<derivative+?>: inc.i32(+8)
	<derivative+?>: load.i32
	<derivative+?>: dup.x32 sp(3)
	<derivative+?>: mad.u32 8
	<derivative+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:156: (4 bytes): i := i + 1
	<derivative+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:156: (14 bytes): i < result.capacity
	<derivative+?>: dup.x32 sp(0)
	<derivative+?>: dup.x32 sp(2)
	<derivative+?>: inc.i32(+12)
	<derivative+?>: load.i32
	<derivative+?>: clt.i32
	<derivative+?>: jnz -54
	<derivative+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:159: (3 bytes): return .result := result;
	<derivative+?>: set.x32 sp(3)
	<derivative+?>: ret
.usages:
}
Polynomial.integral(this: Polynomial, c: float64): Polynomial: function {
.kind: static function
.base: `function`
.size: 117
.name: 'integral'
.file: 'cmplStd/lib/math/Polynomial.ci:163'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param this: Polynomial (size: 4, cast: const variable(ref))
.param c: float64 (size: 8, cast: variable(f64))
.doc: 'Compute the integral of the polynomial'
.value: {
	result: Polynomial := create(degree(this) + 1, null);
	result.coefficients[0] := c;
	for (i: int32 := 1; i < result.capacity; i := i + 1) {
		result.coefficients[i] := this.coefficients[i - 1] / (i);
	}
	return .result := result;
}
.instructions: (117 bytes)
	cmplStd/lib/math/Polynomial.ci:164: (37 bytes): result: Polynomial := create(degree(this) + 1, null)
	<integral>  : inc.sp(+4)
	<integral+?>: load.z32
	<integral+?>: dup.x32 sp(5)
	<integral+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<integral+?>: call
	<integral+?>: inc.sp(-4)
	<integral+?>: inc.i32(+1)
	<integral+?>: load.z32
	<integral+?>: load.ref <?> ;null
	<integral+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<integral+?>: call
	<integral+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:165: (10 bytes): result.coefficients[0] := c;
	<integral+?>: dup.x64 sp(2)
	<integral+?>: dup.x32 sp(2)
	<integral+?>: inc.i32(+8)
	<integral+?>: load.i32
	<integral+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:166: (67 bytes): for (i: int32 := 1; i < result.capacity; i := i + 1)
	<integral+?>: load.c32 1
	<integral+?>: jmp +44
	cmplStd/lib/math/Polynomial.ci:167: (36 bytes): result.coefficients[i] := this.coefficients[i - 1] / (i);
	<integral+?>: dup.x32 sp(5)
	<integral+?>: inc.i32(+8)
	<integral+?>: load.i32
	<integral+?>: dup.x32 sp(1)
	<integral+?>: inc.i32(-1)
	<integral+?>: mad.u32 8
	<integral+?>: load.i64
	<integral+?>: dup.x32 sp(2)
	<integral+?>: i32.2f64
	<integral+?>: div.f64
	<integral+?>: dup.x32 sp(3)
	<integral+?>: inc.i32(+8)
	<integral+?>: load.i32
	<integral+?>: dup.x32 sp(3)
	<integral+?>: mad.u32 8
	<integral+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:166: (4 bytes): i := i + 1
	<integral+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:166: (14 bytes): i < result.capacity
	<integral+?>: dup.x32 sp(0)
	<integral+?>: dup.x32 sp(2)
	<integral+?>: inc.i32(+12)
	<integral+?>: load.i32
	<integral+?>: clt.i32
	<integral+?>: jnz -50
	<integral+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:169: (3 bytes): return .result := result;
	<integral+?>: set.x32 sp(5)
	<integral+?>: ret
.usages:
}
Polynomial(copy: Polynomial): Polynomial: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Polynomial'
.file: 'cmplStd/lib/math/Polynomial.ci:174'
.param .result: Polynomial (size: 20, cast: ref)
.param copy: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Create a new polynomial by copying the given one.'
.value: Polynomial.create(Polynomial.degree(copy), copy.coefficients)
.usages:
}
Polynomial(values: float64[]): Polynomial: function {
.kind: static function
.base: `function`
.size: 81
.name: 'Polynomial'
.file: 'cmplStd/lib/math/Polynomial.ci:177'
.param .result: Polynomial (size: 4, cast: variable(ref))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Create a new polynomial with the given values, coefficients are reversed(lowest index === highest degree)'
.value: {
	result: Polynomial := Polynomial.create(values.length - (1), null);
	for (i: int32 := 0; i < (values.length); i := i + 1) {
		result.coefficients[i] := values[values.length - (i) - (1)];
	}
	return .result := result;
}
.instructions: (81 bytes)
	cmplStd/lib/math/Polynomial.ci:178: (26 bytes): result: Polynomial := Polynomial.create(values.length - (1), null)
	<Polynomial>  : inc.sp(+4)
	<Polynomial+?>: dup.x32 sp(3)
	<Polynomial+?>: inc.i32(-1)
	<Polynomial+?>: load.z32
	<Polynomial+?>: load.ref <?> ;null
	<Polynomial+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<Polynomial+?>: call
	<Polynomial+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:179: (52 bytes): for (i: int32 := 0; i < (values.length); i := i + 1)
	<Polynomial+?>: load.z32
	<Polynomial+?>: jmp +38
	cmplStd/lib/math/Polynomial.ci:180: (30 bytes): result.coefficients[i] := values[values.length - (i) - (1)];
	<Polynomial+?>: dup.x32 sp(3)
	<Polynomial+?>: dup.x32 sp(5)
	<Polynomial+?>: dup.x32 sp(2)
	<Polynomial+?>: sub.i32
	<Polynomial+?>: inc.i32(-1)
	<Polynomial+?>: mad.u32 8
	<Polynomial+?>: load.i64
	<Polynomial+?>: dup.x32 sp(3)
	<Polynomial+?>: inc.i32(+8)
	<Polynomial+?>: load.i32
	<Polynomial+?>: dup.x32 sp(3)
	<Polynomial+?>: mad.u32 8
	<Polynomial+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:179: (4 bytes): i := i + 1
	<Polynomial+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:179: (9 bytes): i < (values.length)
	<Polynomial+?>: dup.x32 sp(0)
	<Polynomial+?>: dup.x32 sp(5)
	<Polynomial+?>: clt.i32
	<Polynomial+?>: jnz -39
	<Polynomial+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:182: (3 bytes): return .result := result;
	<Polynomial+?>: set.x32 sp(4)
	<Polynomial+?>: ret
.usages:
}
File: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'File'
.field open: function (size: 0, cast: static const inline)
.field create: function (size: 0, cast: static const inline)
.field append: function (size: 0, cast: static const inline)
.field peek: function (size: 0, cast: static const inline)
.field tell: function (size: 0, cast: static const inline)
.field seek: function (size: 0, cast: static const inline)
.field seekCur: function (size: 0, cast: static const inline)
.field seekEnd: function (size: 0, cast: static const inline)
.field read: function (size: 0, cast: static const inline)
.field write: function (size: 0, cast: static const inline)
.field flush: function (size: 0, cast: static const inline)
.field close: function (size: 0, cast: static const inline)
.field in: File (size: 0, cast: static const inline)
.field out: File (size: 0, cast: static const inline)
.field err: File (size: 0, cast: static const inline)
.field log: File (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplFile/lib/FileStream.ci:93: referenced as `File`
	cmplFile/lib/FileStream.ci:93: referenced as `File`
	cmplFile/lib/FileStream.ci:85: referenced as `File`
	cmplFile/lib/FileStream.ci:85: referenced as `File`
	cmplFile/lib/FileStream.ci:78: referenced as `File`
	cmplFile/lib/FileStream.ci:39: referenced as `File`
	cmplFile/lib/FileStream.ci:29: referenced as `File`
	cmplFile/lib/FileStream.ci:25: referenced as `File`
	cmplFile/lib/FileStream.ci:20: referenced as `File`
	cmplFile/lib/FileStream.ci:17: referenced as `File`
	cmplFile/lib/FileStream.ci:10: referenced as `File`
	cmplFile/lib/FileStream.ci:6: referenced as `File`
	cmplFile/lib/FileStream.ci:3: referenced as `File`
	cmplFile/lib.ci:11: referenced as `File`
	cmplFile/lib.ci:2: referenced as `File`
	internal usages: 19
}
File.open(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(54)
.usages:
	cmplFile/lib/FileStream.ci:78: referenced as `open`
}
File.create(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(55)
.usages:
	cmplFile/lib/FileStream.ci:93: referenced as `create`
	cmplFile/lib/FileStream.ci:85: referenced as `create`
}
File.append(path: char[*]): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'append'
.owner: File
.param .result: File (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(56)
.usages:
	cmplFile/lib/FileStream.ci:93: referenced as `append`
	cmplFile/lib/FileStream.ci:85: referenced as `append`
}
File.peek(file: File): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'peek'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.doc: '@builtin'
.value: nfc(57)
.usages:
}
File.tell(file: File): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tell'
.owner: File
.param .result: int64 (size: 8, cast: inline)
.param file: File (size: 8, cast: variable(val))
.doc: '@builtin'
.value: nfc(58)
.usages:
}
File.seek(file: File, position: int64): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'seek'
.owner: File
.param .result: File (size: 8, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param position: int64 (size: 8, cast: variable(i64))
.doc: '@builtin'
.value: nfc(59)
.usages:
}
File.seekCur(file: File, position: int64): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'seekCur'
.owner: File
.param .result: File (size: 8, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param position: int64 (size: 8, cast: variable(i64))
.doc: '@builtin'
.value: nfc(60)
.usages:
}
File.seekEnd(file: File, position: int64): File: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'seekEnd'
.owner: File
.param .result: File (size: 8, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param position: int64 (size: 8, cast: variable(i64))
.doc: '@builtin'
.value: nfc(61)
.usages:
}
File.read(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'read'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: variable(arr))
.doc: '@builtin'
.value: nfc(62)
.usages:
	cmplFile/lib/FileStream.ci:6: referenced as `read`
	cmplFile/lib.ci:4: referenced as `read`
}
File.write(file: File, buff: uint8[]): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'write'
.owner: File
.param .result: int32 (size: 4, cast: inline)
.param file: File (size: 8, cast: variable(val))
.param buff: uint8[] (size: 8, cast: const variable(arr))
.doc: '@builtin'
.value: nfc(63)
.usages:
	cmplFile/lib/FileStream.ci:39: referenced as `write`
	cmplFile/lib/FileStream.ci:20: referenced as `write`
	cmplFile/lib.ci:13: referenced as `write`
}
File.flush(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'flush'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.doc: '@builtin'
.value: nfc(64)
.usages:
	cmplFile/lib/FileStream.ci:25: referenced as `flush`
}
File.close(file: File): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'close'
.owner: File
.param .result: void (size: 0, cast: inline)
.param file: File (size: 8, cast: variable(val))
.doc: '@builtin'
.value: nfc(65)
.usages:
	cmplFile/lib/FileStream.ci:29: referenced as `close`
	cmplFile/lib/FileStream.ci:10: referenced as `close`
}
File.in: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'in'
.owner: File
.doc: '@builtin'
.value: nfc(66)
.usages:
}
File.out: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'out'
.owner: File
.doc: '@builtin'
.value: nfc(67)
.usages:
}
File.err: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'err'
.owner: File
.doc: '@builtin'
.value: nfc(68)
.usages:
}
File.log: File {
.kind: static const inline
.base: `File`
.size: 0
.name: 'log'
.owner: File
.doc: '@builtin'
.value: nfc(69)
.usages:
}
read(file: File): int32: function {
.kind: static function
.base: `function`
.size: 57
.name: 'read'
.file: 'cmplFile/lib.ci:2'
.param .result: int32 (size: 4, cast: variable(i32))
.param file: File (size: 8, cast: variable(val))
.doc: 'extension method to read a single byte from a file'
.value: {
	buff: uint8[1] := {
		buff[0] := (0);
	};
	if (File.read(file, buff) <= 0) {
		return .result := -1;
	}
	return .result := (buff[0]) & 255;
}
.instructions: (57 bytes)
	cmplFile/lib.ci:3: (10 bytes): buff: uint8[1] := {...}
	<read>  : inc.sp(+4)
	cmplFile/lib.ci:3: (6 bytes): buff[0] := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+4)
	<read+?>: store.i8
	cmplFile/lib.ci:4: (33 bytes): if (File.read(file, buff) <= 0)
	<read+?>: dup.x64 sp(2)
	<read+?>: load.c32 1
	<read+?>: load.sp(+12)
	<read+?>: nfc(62) ;File.read(file: File, buff: uint8[]): int32
	<read+?>: load.z32
	<read+?>: cgt.i32
	<read+?>: jnz +16
	cmplFile/lib.ci:5: (12 bytes): return .result := -1;
	<read+?>: load.c32 -1
	<read+?>: set.x32 sp(5)
	<read+?>: inc.sp(-4)
	<read+?>: ret
	cmplFile/lib.ci:7: (14 bytes): return .result := (buff[0]) & 255;
	<read+?>: load.sp(+0)
	<read+?>: load.iu8
	<read+?>: b32.and 0xff
	<read+?>: set.x32 sp(5)
	<read+?>: inc.sp(-4)
	<read+?>: ret
.usages:
}
write(file: File, value: int32): int32: function {
.kind: static function
.base: `function`
.size: 33
.name: 'write'
.file: 'cmplFile/lib.ci:11'
.param .result: int32 (size: 4, cast: variable(i32))
.param file: File (size: 8, cast: variable(val))
.param value: int32 (size: 4, cast: variable(i32))
.doc: 'extension method to write a single byte into a file'
.value: {
	buff: uint8[1] := {
		buff[0] := (value);
	};
	return .result := File.write(file, buff);
}
.instructions: (33 bytes)
	cmplFile/lib.ci:12: (11 bytes): buff: uint8[1] := {...}
	<write>  : inc.sp(+4)
	cmplFile/lib.ci:12: (7 bytes): buff[0] := (value);
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+4)
	<write+?>: store.i8
	cmplFile/lib.ci:13: (22 bytes): return .result := File.write(file, buff);
	<write+?>: dup.x64 sp(3)
	<write+?>: load.c32 1
	<write+?>: load.sp(+12)
	<write+?>: nfc(63) ;File.write(file: File, buff: uint8[]): int32
	<write+?>: set.x32 sp(6)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
}
FileReader: ByteReader {
.kind: static const typename(ref)
.base: `ByteReader`
.size: 20
.name: 'FileReader'
.file: 'cmplFile/lib/FileStream.ci:2'
.field file: File (size: 8, cast: const variable(val))
.field read: function (size: 16, cast: static function)
.field close: function (size: 12, cast: static function)
.field read: function (size: 4, cast: variable(ref))
.field read: function (size: 59, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplFile/lib/FileStream.ci:77: referenced as `FileReader`
	cmplFile/lib/FileStream.ci:76: referenced as `FileReader`
	cmplFile/lib/FileStream.ci:9: referenced as `FileReader`
	cmplFile/lib/FileStream.ci:5: referenced as `FileReader`
}
FileReader.file: File {
.kind: const variable(val)
.base: `File`
.size: 8
.name: 'file'
.file: 'cmplFile/lib/FileStream.ci:3'
.owner: FileReader
.usages:
	cmplFile/lib/FileStream.ci:78: referenced as `file`
	cmplFile/lib/FileStream.ci:10: referenced as `file`
	cmplFile/lib/FileStream.ci:6: referenced as `file`
}
FileReader.read(this: FileReader, bytes: uint8[]): int32: function {
.kind: static function
.base: `function`
.size: 16
.name: 'read'
.file: 'cmplFile/lib/FileStream.ci:5'
.owner: FileReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: FileReader (size: 4, cast: variable(ref))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of bytes read from the stream into the `bytes` array
in case there is an error -1 should be returned'
.value: {
	return .result := File.read(this.file, bytes);
}
.instructions: (16 bytes)
	cmplFile/lib/FileStream.ci:6: (16 bytes): return .result := File.read(this.file, bytes);
	<read>  : dup.x32 sp(3)
	<read+?>: inc.i32(+12)
	<read+?>: load.i64
	<read+?>: dup.x64 sp(3)
	<read+?>: nfc(62) ;File.read(file: File, buff: uint8[]): int32
	<read+?>: set.x32 sp(5)
	<read+?>: ret
.usages:
}
FileReader.close(this: FileReader): void: function {
.kind: static function
.base: `function`
.size: 12
.name: 'close'
.file: 'cmplFile/lib/FileStream.ci:9'
.owner: FileReader
.param .result: void (size: 0, cast: variable(void))
.param this: FileReader (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	File.close(this.file);
}
.instructions: (12 bytes)
	cmplFile/lib/FileStream.ci:10: (11 bytes): File.close(this.file);
	<close>  : dup.x32 sp(1)
	<close+?>: inc.i32(+12)
	<close+?>: load.i64
	<close+?>: nfc(65) ;File.close(file: File): void
	<close+?>: ret
.usages:
}
FileWriter: ByteWriter {
.kind: static const typename(ref)
.base: `ByteWriter`
.size: 24
.name: 'FileWriter'
.file: 'cmplFile/lib/FileStream.ci:15'
.field file: File (size: 8, cast: const variable(val))
.field write: function (size: 71, cast: static function)
.field flush: function (size: 12, cast: static function)
.field close: function (size: 12, cast: static function)
.field write: function (size: 4, cast: variable(ref))
.field flush: function (size: 4, cast: variable(ref))
.field write: function (size: 42, cast: static function)
.field copy: function (size: 112, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplFile/lib/FileStream.ci:84: referenced as `FileWriter`
	cmplFile/lib/FileStream.ci:83: referenced as `FileWriter`
	cmplFile/lib/FileStream.ci:71: referenced as `FileWriter`
	cmplFile/lib/FileStream.ci:66: referenced as `FileWriter`
	cmplFile/lib/FileStream.ci:51: referenced as `FileWriter`
	cmplFile/lib/FileStream.ci:34: referenced as `FileWriter`
	cmplFile/lib/FileStream.ci:28: referenced as `FileWriter`
	cmplFile/lib/FileStream.ci:24: referenced as `FileWriter`
	cmplFile/lib/FileStream.ci:19: referenced as `FileWriter`
}
FileWriter.file: File {
.kind: const variable(val)
.base: `File`
.size: 8
.name: 'file'
.file: 'cmplFile/lib/FileStream.ci:17'
.owner: FileWriter
.doc: '@public'
.usages:
	cmplFile/lib/FileStream.ci:93: referenced as `file`
	cmplFile/lib/FileStream.ci:85: referenced as `file`
	cmplFile/lib/FileStream.ci:39: referenced as `file`
	cmplFile/lib/FileStream.ci:29: referenced as `file`
	cmplFile/lib/FileStream.ci:25: referenced as `file`
	cmplFile/lib/FileStream.ci:20: referenced as `file`
}
FileWriter.write(this: FileWriter, bytes: uint8[]): void: function {
.kind: static function
.base: `function`
.size: 71
.name: 'write'
.file: 'cmplFile/lib/FileStream.ci:19'
.owner: FileWriter
.param .result: void (size: 0, cast: variable(void))
.param this: FileWriter (size: 4, cast: variable(ref))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must write all the bytes from the `bytes` array'
.value: {
	wrote: int32 := File.write(this.file, bytes);
	assert(wrote == (bytes.length));
}
.instructions: (71 bytes)
	cmplFile/lib/FileStream.ci:20: (13 bytes): wrote: int32 := File.write(this.file, bytes)
	<write>  : dup.x32 sp(3)
	<write+?>: inc.i32(+16)
	<write+?>: load.i64
	<write+?>: dup.x64 sp(3)
	<write+?>: nfc(63) ;File.write(file: File, buff: uint8[]): int32
	cmplFile/lib/FileStream.ci:21: (53 bytes): assert(wrote == (bytes.length));
	<write+?>: load.z32
	<write+?>: load.sp(+4)
	<write+?>: dup.x32 sp(2)
	<write+?>: dup.x32 sp(6)
	<write+?>: ceq.i32
	<write+?>: jz +8
	<write+?>: jmp +35
	<write+?>: load.ref <?> ;"cmplFile/lib/FileStream.ci"
	<write+?>: load.c32 21
	<write+?>: load.c32 -2
	<write+?>: load.c32 128
	<write+?>: load.ref <?> ;"assertion failed!"
	<write+?>: dup.x64 sp(5)
	<write+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<write+?>: inc.sp(-8)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
	cmplFile/lib/FileStream.ci:51: referenced as `write`
}
FileWriter.flush(this: FileWriter): void: function {
.kind: static function
.base: `function`
.size: 12
.name: 'flush'
.file: 'cmplFile/lib/FileStream.ci:24'
.owner: FileWriter
.param .result: void (size: 0, cast: variable(void))
.param this: FileWriter (size: 4, cast: variable(ref))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
if a buffer is used directly or indirectly this method must flush all buffered data to the stream.'
.value: {
	File.flush(this.file);
}
.instructions: (12 bytes)
	cmplFile/lib/FileStream.ci:25: (11 bytes): File.flush(this.file);
	<flush>  : dup.x32 sp(1)
	<flush+?>: inc.i32(+16)
	<flush+?>: load.i64
	<flush+?>: nfc(64) ;File.flush(file: File): void
	<flush+?>: ret
.usages:
	cmplFile/lib/FileStream.ci:66: referenced as `flush`
}
FileWriter.close(this: FileWriter): void: function {
.kind: static function
.base: `function`
.size: 12
.name: 'close'
.file: 'cmplFile/lib/FileStream.ci:28'
.owner: FileWriter
.param .result: void (size: 0, cast: variable(void))
.param this: FileWriter (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	File.close(this.file);
}
.instructions: (12 bytes)
	cmplFile/lib/FileStream.ci:29: (11 bytes): File.close(this.file);
	<close>  : dup.x32 sp(1)
	<close+?>: inc.i32(+16)
	<close+?>: load.i64
	<close+?>: nfc(65) ;File.close(file: File): void
	<close+?>: ret
.usages:
	cmplFile/lib/FileStream.ci:71: referenced as `close`
}
BufferedFileWriter: FileWriter {
.kind: static const typename(ref)
.base: `FileWriter`
.size: 1052
.name: 'BufferedFileWriter'
.file: 'cmplFile/lib/FileStream.ci:34'
.field buffer: uint8[1024] (size: 1024, cast: variable(val))
.field bufferSize: int32 (size: 4, cast: variable(i32))
.field flushBuffer: function (size: 95, cast: static function)
.field write: function (size: 150, cast: static function)
.field flush: function (size: 25, cast: static function)
.field close: function (size: 25, cast: static function)
.field file: File (size: 8, cast: const variable(val))
.field write: function (size: 71, cast: static function)
.field flush: function (size: 12, cast: static function)
.field close: function (size: 12, cast: static function)
.field write: function (size: 4, cast: variable(ref))
.field flush: function (size: 4, cast: variable(ref))
.field write: function (size: 42, cast: static function)
.field copy: function (size: 112, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplFile/lib/FileStream.ci:91: referenced as `BufferedFileWriter`
	cmplFile/lib/FileStream.ci:90: referenced as `BufferedFileWriter`
	cmplFile/lib/FileStream.ci:69: referenced as `BufferedFileWriter`
	cmplFile/lib/FileStream.ci:64: referenced as `BufferedFileWriter`
	cmplFile/lib/FileStream.ci:44: referenced as `BufferedFileWriter`
	cmplFile/lib/FileStream.ci:38: referenced as `BufferedFileWriter`
}
BufferedFileWriter.buffer: uint8[1024] {
.kind: variable(val)
.base: `uint8[1024]`
.size: 1024
.name: 'buffer'
.file: 'cmplFile/lib/FileStream.ci:35'
.owner: BufferedFileWriter
.usages:
	cmplFile/lib/FileStream.ci:92: referenced as `buffer`
	cmplFile/lib/FileStream.ci:56: referenced as `buffer`
	cmplFile/lib/FileStream.ci:49: referenced as `buffer`
	cmplFile/lib/FileStream.ci:45: referenced as `buffer`
	cmplFile/lib/FileStream.ci:39: referenced as `buffer`
}
BufferedFileWriter.bufferSize: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'bufferSize'
.file: 'cmplFile/lib/FileStream.ci:36'
.owner: BufferedFileWriter
.value: 0
.usages:
	cmplFile/lib/FileStream.ci:61: referenced as `bufferSize`
	cmplFile/lib/FileStream.ci:57: referenced as `bufferSize`
	cmplFile/lib/FileStream.ci:46: referenced as `bufferSize`
	cmplFile/lib/FileStream.ci:45: referenced as `bufferSize`
	cmplFile/lib/FileStream.ci:41: referenced as `bufferSize`
	cmplFile/lib/FileStream.ci:40: referenced as `bufferSize`
	cmplFile/lib/FileStream.ci:39: referenced as `bufferSize`
	internal usages: 1
}
BufferedFileWriter.flushBuffer(this: BufferedFileWriter): void: function {
.kind: static function
.base: `function`
.size: 95
.name: 'flushBuffer'
.file: 'cmplFile/lib/FileStream.ci:38'
.owner: BufferedFileWriter
.param .result: void (size: 0, cast: variable(void))
.param this: BufferedFileWriter (size: 4, cast: variable(ref))
.value: {
	wrote: int32 := File.write(this.file, this.buffer[...this.bufferSize]);
	assert(wrote == this.bufferSize);
	this.bufferSize := 0;
}
.instructions: (95 bytes)
	cmplFile/lib/FileStream.ci:39: (24 bytes): wrote: int32 := File.write(this.file, this.buffer[...this.bufferSize])
	<flushBuffer>  : dup.x32 sp(1)
	<flushBuffer+?>: inc.i32(+16)
	<flushBuffer+?>: load.i64
	<flushBuffer+?>: dup.x32 sp(3)
	<flushBuffer+?>: inc.i32(+1048)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: dup.x32 sp(4)
	<flushBuffer+?>: inc.i32(+24)
	<flushBuffer+?>: nfc(63) ;File.write(file: File, buff: uint8[]): int32
	cmplFile/lib/FileStream.ci:40: (58 bytes): assert(wrote == this.bufferSize);
	<flushBuffer+?>: load.z32
	<flushBuffer+?>: load.sp(+4)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+1048)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: ceq.i32
	<flushBuffer+?>: jz +8
	<flushBuffer+?>: jmp +35
	<flushBuffer+?>: load.ref <?> ;"cmplFile/lib/FileStream.ci"
	<flushBuffer+?>: load.c32 40
	<flushBuffer+?>: load.c32 -2
	<flushBuffer+?>: load.c32 128
	<flushBuffer+?>: load.ref <?> ;"assertion failed!"
	<flushBuffer+?>: dup.x64 sp(5)
	<flushBuffer+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<flushBuffer+?>: inc.sp(-8)
	cmplFile/lib/FileStream.ci:41: (8 bytes): this.bufferSize := 0;
	<flushBuffer+?>: load.z32
	<flushBuffer+?>: dup.x32 sp(3)
	<flushBuffer+?>: inc.i32(+1048)
	<flushBuffer+?>: store.i32
	<flushBuffer+?>: inc.sp(-4)
	<flushBuffer+?>: ret
.usages:
	cmplFile/lib/FileStream.ci:70: referenced as `flushBuffer`
	cmplFile/lib/FileStream.ci:65: referenced as `flushBuffer`
	cmplFile/lib/FileStream.ci:47: referenced as `flushBuffer`
}
BufferedFileWriter.write(this: BufferedFileWriter, bytes: uint8[]): void: function {
.kind: static function
.base: `function`
.size: 150
.name: 'write'
.file: 'cmplFile/lib/FileStream.ci:44'
.owner: BufferedFileWriter
.param .result: void (size: 0, cast: variable(void))
.param this: BufferedFileWriter (size: 4, cast: variable(ref))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must write all the bytes from the `bytes` array'
.value: {
	if (this.bufferSize + (bytes.length) > this.buffer.(length)) {
		if (this.bufferSize > 0) {
			flushBuffer(this);
		}
		if (bytes.length > (this.buffer.(length) / 2)) {
			FileWriter.write(this, bytes);
			return;
		}
	}
	buffer: uint8[*] := this.buffer;
	bufferSize: int32 := this.bufferSize;
	for (i: int32 := 0; i < (bytes.length); i := i + 1) {
		buffer[bufferSize + i] := bytes[i];
	}
	this.bufferSize := this.bufferSize + (bytes.length);
}
.instructions: (150 bytes)
	cmplFile/lib/FileStream.ci:45: (78 bytes): if (this.bufferSize + (bytes.length) > this.buffer.(length))
	<write>  : dup.x32 sp(3)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(3)
	<write+?>: add.i32
	<write+?>: load.c32 1024
	<write+?>: cgt.i32
	<write+?>: jz +62
	cmplFile/lib/FileStream.ci:46: (25 bytes): if (this.bufferSize > 0)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	<write+?>: load.z32
	<write+?>: cgt.i32
	<write+?>: jz +16
	cmplFile/lib/FileStream.ci:47: (12 bytes): flushBuffer(this);
	<write+?>: dup.x32 sp(3)
	<write+?>: load.ref <?> ;BufferedFileWriter.flushBuffer(this: BufferedFileWriter): void
	<write+?>: call
	<write+?>: inc.sp(-4)
	cmplFile/lib/FileStream.ci:49: (33 bytes): if (bytes.length > (this.buffer.(length) / 2))
	<write+?>: dup.x32 sp(2)
	<write+?>: load.c32 1024
	<write+?>: load.c32 2
	<write+?>: div.i32
	<write+?>: cgt.u32
	<write+?>: jz +19
	cmplFile/lib/FileStream.ci:51: (14 bytes): FileWriter.write(this, bytes);
	<write+?>: dup.x32 sp(3)
	<write+?>: dup.x64 sp(2)
	<write+?>: load.ref <?> ;FileWriter.write(this: FileWriter, bytes: uint8[]): void
	<write+?>: call
	<write+?>: inc.sp(-12)
	cmplFile/lib/FileStream.ci:52: (1 byte): return;
	<write+?>: ret
	cmplFile/lib/FileStream.ci:56: (6 bytes): buffer: uint8[*] := this.buffer
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+24)
	cmplFile/lib/FileStream.ci:57: (7 bytes): bufferSize: int32 := this.bufferSize
	<write+?>: dup.x32 sp(4)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	cmplFile/lib/FileStream.ci:58: (37 bytes): for (i: int32 := 0; i < (bytes.length); i := i + 1)
	<write+?>: load.z32
	<write+?>: jmp +23
	cmplFile/lib/FileStream.ci:59: (15 bytes): buffer[bufferSize + i] := bytes[i];
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(3)
	<write+?>: dup.x32 sp(3)
	<write+?>: dup.x32 sp(3)
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: store.i8
	cmplFile/lib/FileStream.ci:58: (4 bytes): i := i + 1
	<write+?>: inc.i32(+1)
	cmplFile/lib/FileStream.ci:58: (9 bytes): i < (bytes.length)
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(6)
	<write+?>: clt.i32
	<write+?>: jnz -24
	<write+?>: inc.sp(-4)
	cmplFile/lib/FileStream.ci:61: (17 bytes): this.bufferSize := this.bufferSize + (bytes.length);
	<write+?>: dup.x32 sp(5)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(5)
	<write+?>: add.i32
	<write+?>: dup.x32 sp(6)
	<write+?>: inc.i32(+1048)
	<write+?>: store.i32
	<write+?>: inc.sp(-8)
	<write+?>: ret
.usages:
}
BufferedFileWriter.flush(this: BufferedFileWriter): void: function {
.kind: static function
.base: `function`
.size: 25
.name: 'flush'
.file: 'cmplFile/lib/FileStream.ci:64'
.owner: BufferedFileWriter
.param .result: void (size: 0, cast: variable(void))
.param this: BufferedFileWriter (size: 4, cast: variable(ref))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
if a buffer is used directly or indirectly this method must flush all buffered data to the stream.'
.value: {
	flushBuffer(this);
	FileWriter.flush(this);
}
.instructions: (25 bytes)
	cmplFile/lib/FileStream.ci:65: (12 bytes): flushBuffer(this);
	<flush>  : dup.x32 sp(1)
	<flush+?>: load.ref <?> ;BufferedFileWriter.flushBuffer(this: BufferedFileWriter): void
	<flush+?>: call
	<flush+?>: inc.sp(-4)
	cmplFile/lib/FileStream.ci:66: (12 bytes): FileWriter.flush(this);
	<flush+?>: dup.x32 sp(1)
	<flush+?>: load.ref <?> ;FileWriter.flush(this: FileWriter): void
	<flush+?>: call
	<flush+?>: inc.sp(-4)
	<flush+?>: ret
.usages:
}
BufferedFileWriter.close(this: BufferedFileWriter): void: function {
.kind: static function
.base: `function`
.size: 25
.name: 'close'
.file: 'cmplFile/lib/FileStream.ci:69'
.owner: BufferedFileWriter
.param .result: void (size: 0, cast: variable(void))
.param this: BufferedFileWriter (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	flushBuffer(this);
	FileWriter.close(this);
}
.instructions: (25 bytes)
	cmplFile/lib/FileStream.ci:70: (12 bytes): flushBuffer(this);
	<close>  : dup.x32 sp(1)
	<close+?>: load.ref <?> ;BufferedFileWriter.flushBuffer(this: BufferedFileWriter): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	cmplFile/lib/FileStream.ci:71: (12 bytes): FileWriter.close(this);
	<close+?>: dup.x32 sp(1)
	<close+?>: load.ref <?> ;FileWriter.close(this: FileWriter): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	<close+?>: ret
.usages:
}
FileReader(path: char[*]): FileReader: function {
.kind: static function
.base: `function`
.size: 49
.name: 'FileReader'
.file: 'cmplFile/lib/FileStream.ci:76'
.param .result: FileReader (size: 4, cast: variable(ref))
.param path: char[*] (size: 4, cast: const variable(ref))
.doc: '@public'
.value: {
	return .result := {
			.result := create(FileReader);
			.result.file := File.open(path);
			.result.read := read;
			.result.close := close;
		};
}
.instructions: (49 bytes)
	cmplFile/lib/FileStream.ci:77: (49 bytes): return .result := {...};
	cmplFile/lib/FileStream.ci:76: (11 bytes): .result := create(FileReader);
	<FileReader>  : load.ref <?> ;FileReader
	<FileReader+?>: nfc(7) ;object.create(type: typename): pointer
	<FileReader+?>: set.x32 sp(3)
	cmplFile/lib/FileStream.ci:78: (13 bytes): .result.file := File.open(path);
	<FileReader+?>: dup.x32 sp(1)
	<FileReader+?>: nfc(54) ;File.open(path: char[*]): File
	<FileReader+?>: dup.x32 sp(4)
	<FileReader+?>: inc.i32(+12)
	<FileReader+?>: store.i64
	:: (12 bytes): .result.read := read;
	<FileReader+?>: load.ref <?> ;FileReader.read(this: FileReader, bytes: uint8[]): int32
	<FileReader+?>: dup.x32 sp(3)
	<FileReader+?>: inc.i32(+8)
	<FileReader+?>: store.i32
	:: (12 bytes): .result.close := close;
	<FileReader+?>: load.ref <?> ;FileReader.close(this: FileReader): void
	<FileReader+?>: dup.x32 sp(3)
	<FileReader+?>: inc.i32(+4)
	<FileReader+?>: store.i32
	<FileReader+?>: ret
.usages:
}
FileWriter(path: char[*], append: bool): FileWriter: function {
.kind: static function
.base: `function`
.size: 80
.name: 'FileWriter'
.file: 'cmplFile/lib/FileStream.ci:83'
.param .result: FileWriter (size: 4, cast: variable(ref))
.param path: char[*] (size: 4, cast: const variable(ref))
.param append: bool (size: 4, cast: variable(bool))
.doc: '@public'
.value: {
	return .result := {
			.result := create(FileWriter);
			.result.file := append ? File.append(path) : File.create(path);
			.result.write := write;
			.result.flush := flush;
			.result.close := close;
		};
}
.instructions: (80 bytes)
	cmplFile/lib/FileStream.ci:84: (80 bytes): return .result := {...};
	cmplFile/lib/FileStream.ci:83: (11 bytes): .result := create(FileWriter);
	<FileWriter>  : load.ref <?> ;FileWriter
	<FileWriter+?>: nfc(7) ;object.create(type: typename): pointer
	<FileWriter+?>: set.x32 sp(4)
	cmplFile/lib/FileStream.ci:85: (32 bytes): .result.file := append ? File.append(path) : File.create(path);
	<FileWriter+?>: load.sp(+4)
	<FileWriter+?>: load.is8
	<FileWriter+?>: jz +14
	<FileWriter+?>: dup.x32 sp(2)
	<FileWriter+?>: nfc(56) ;File.append(path: char[*]): File
	<FileWriter+?>: jmp +10
	<FileWriter+?>: dup.x32 sp(2)
	<FileWriter+?>: nfc(55) ;File.create(path: char[*]): File
	<FileWriter+?>: dup.x32 sp(5)
	<FileWriter+?>: inc.i32(+16)
	<FileWriter+?>: store.i64
	:: (12 bytes): .result.write := write;
	<FileWriter+?>: load.ref <?> ;FileWriter.write(this: FileWriter, bytes: uint8[]): void
	<FileWriter+?>: dup.x32 sp(4)
	<FileWriter+?>: inc.i32(+8)
	<FileWriter+?>: store.i32
	:: (12 bytes): .result.flush := flush;
	<FileWriter+?>: load.ref <?> ;FileWriter.flush(this: FileWriter): void
	<FileWriter+?>: dup.x32 sp(4)
	<FileWriter+?>: inc.i32(+12)
	<FileWriter+?>: store.i32
	:: (12 bytes): .result.close := close;
	<FileWriter+?>: load.ref <?> ;FileWriter.close(this: FileWriter): void
	<FileWriter+?>: dup.x32 sp(4)
	<FileWriter+?>: inc.i32(+4)
	<FileWriter+?>: store.i32
	<FileWriter+?>: ret
.usages:
}
BufferedFileWriter(path: char[*], append: bool): BufferedFileWriter: function {
.kind: static function
.base: `function`
.size: 100
.name: 'BufferedFileWriter'
.file: 'cmplFile/lib/FileStream.ci:90'
.param .result: BufferedFileWriter (size: 4, cast: variable(ref))
.param path: char[*] (size: 4, cast: const variable(ref))
.param append: bool (size: 4, cast: variable(bool))
.doc: '@public'
.value: {
	return .result := {
			.result := create(BufferedFileWriter);
			.result.buffer := (null);
			.result.file := append ? File.append(path) : File.create(path);
			.result.bufferSize := 0;
			.result.write := write;
			.result.flush := flush;
			.result.close := close;
		};
}
.instructions: (100 bytes)
	cmplFile/lib/FileStream.ci:91: (100 bytes): return .result := {...};
	cmplFile/lib/FileStream.ci:90: (11 bytes): .result := create(BufferedFileWriter);
	<BufferedFileWriter>  : load.ref <?> ;BufferedFileWriter
	<BufferedFileWriter+?>: nfc(7) ;object.create(type: typename): pointer
	<BufferedFileWriter+?>: set.x32 sp(4)
	cmplFile/lib/FileStream.ci:92: (12 bytes): .result.buffer := (null);
	<BufferedFileWriter+?>: load.ref <?> ;null
	<BufferedFileWriter+?>: dup.x32 sp(4)
	<BufferedFileWriter+?>: inc.i32(+24)
	<BufferedFileWriter+?>: store.i32
	cmplFile/lib/FileStream.ci:93: (32 bytes): .result.file := append ? File.append(path) : File.create(path);
	<BufferedFileWriter+?>: load.sp(+4)
	<BufferedFileWriter+?>: load.is8
	<BufferedFileWriter+?>: jz +14
	<BufferedFileWriter+?>: dup.x32 sp(2)
	<BufferedFileWriter+?>: nfc(56) ;File.append(path: char[*]): File
	<BufferedFileWriter+?>: jmp +10
	<BufferedFileWriter+?>: dup.x32 sp(2)
	<BufferedFileWriter+?>: nfc(55) ;File.create(path: char[*]): File
	<BufferedFileWriter+?>: dup.x32 sp(5)
	<BufferedFileWriter+?>: inc.i32(+16)
	<BufferedFileWriter+?>: store.i64
	:: (8 bytes): .result.bufferSize := 0;
	<BufferedFileWriter+?>: load.z32
	<BufferedFileWriter+?>: dup.x32 sp(4)
	<BufferedFileWriter+?>: inc.i32(+1048)
	<BufferedFileWriter+?>: store.i32
	:: (12 bytes): .result.write := write;
	<BufferedFileWriter+?>: load.ref <?> ;BufferedFileWriter.write(this: BufferedFileWriter, bytes: uint8[]): void
	<BufferedFileWriter+?>: dup.x32 sp(4)
	<BufferedFileWriter+?>: inc.i32(+8)
	<BufferedFileWriter+?>: store.i32
	:: (12 bytes): .result.flush := flush;
	<BufferedFileWriter+?>: load.ref <?> ;BufferedFileWriter.flush(this: BufferedFileWriter): void
	<BufferedFileWriter+?>: dup.x32 sp(4)
	<BufferedFileWriter+?>: inc.i32(+12)
	<BufferedFileWriter+?>: store.i32
	:: (12 bytes): .result.close := close;
	<BufferedFileWriter+?>: load.ref <?> ;BufferedFileWriter.close(this: BufferedFileWriter): void
	<BufferedFileWriter+?>: dup.x32 sp(4)
	<BufferedFileWriter+?>: inc.i32(+4)
	<BufferedFileWriter+?>: store.i32
	<BufferedFileWriter+?>: ret
.usages:
}
Rect: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Rect'
.field x0: int32 (size: 4, cast: variable(i32))
.field y0: int32 (size: 4, cast: variable(i32))
.field x1: int32 (size: 4, cast: variable(i32))
.field y1: int32 (size: 4, cast: variable(i32))
.doc: 'The Rect type represents a rectangle in the plain.'
.usages:
	cmplGfx/lib/micro.ui.ci:1348: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:1282: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:1082: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:971: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:967: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:952: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:949: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:891: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:870: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:675: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:663: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:657: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:651: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:641: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:614: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:567: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:557: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:416: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:406: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:366: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:316: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:298: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:290: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:282: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:246: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:145: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:141: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:126: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:122: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:111: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:14: referenced as `Rect`
	cmplGfx/lib/micro.ui.ci:8: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:1273: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:1224: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:1218: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:1134: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:1119: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:1032: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:1029: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:1015: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:1006: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:974: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:934: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:923: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:900: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:889: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:849: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:838: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:815: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:804: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:803: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:761: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:749: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:643: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:531: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:495: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:391: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:372: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:363: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:347: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:344: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:331: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:298: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:189: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:134: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:134: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:119: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:119: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:113: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:80: referenced as `Rect`
	cmplGfx/lib/micro.ui.core.ci:80: referenced as `Rect`
	cmplGfx/lib/color.matrix.ci:9: referenced as `Rect`
	cmplGfx/lib/color.matrix.ci:2: referenced as `Rect`
	cmplGfx/lib/color.lookup.ci:10: referenced as `Rect`
	cmplGfx/lib/color.lookup.ci:2: referenced as `Rect`
	cmplGfx/lib/image.transform.ci:64: referenced as `Rect`
	cmplGfx/lib/image.transform.ci:64: referenced as `Rect`
	cmplGfx/lib/image.transform.ci:16: referenced as `Rect`
	cmplGfx/lib/image.transform.ci:10: referenced as `Rect`
	cmplGfx/lib/image.transform.ci:2: referenced as `Rect`
	cmplGfx/lib/image.transform.ci:2: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:160: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:159: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:132: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:131: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:119: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:101: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:84: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:67: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:53: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:8: referenced as `Rect`
	cmplGfx/lib/image.blend.ci:2: referenced as `Rect`
	cmplGfx/lib/image.draw.ci:21: referenced as `Rect`
	cmplGfx/lib/image.draw.oval.ci:16: referenced as `Rect`
	cmplGfx/lib/image.draw.oval.ci:8: referenced as `Rect`
	cmplGfx/lib/image.draw.rrect.ci:139: referenced as `Rect`
	cmplGfx/lib/image.draw.rrect.ci:131: referenced as `Rect`
	cmplGfx/lib/image.draw.rect.ci:73: referenced as `Rect`
	cmplGfx/lib/image.draw.rect.ci:65: referenced as `Rect`
	cmplGfx/lib/image.ci:31: referenced as `Rect`
	cmplGfx/lib/rect.ci:73: referenced as `Rect`
	cmplGfx/lib/rect.ci:68: referenced as `Rect`
	cmplGfx/lib/rect.ci:66: referenced as `Rect`
	cmplGfx/lib/rect.ci:58: referenced as `Rect`
	cmplGfx/lib/rect.ci:50: referenced as `Rect`
	cmplGfx/lib/rect.ci:44: referenced as `Rect`
	cmplGfx/lib/rect.ci:38: referenced as `Rect`
	cmplGfx/lib/rect.ci:33: referenced as `Rect`
	cmplGfx/lib/rect.ci:27: referenced as `Rect`
	cmplGfx/lib/rect.ci:22: referenced as `Rect`
	cmplGfx/lib/rect.ci:20: referenced as `Rect`
	cmplGfx/lib/rect.ci:15: referenced as `Rect`
	cmplGfx/lib/rect.ci:13: referenced as `Rect`
	cmplGfx/lib/rect.ci:8: referenced as `Rect`
	cmplGfx/lib/rect.ci:2: referenced as `Rect`
	internal usages: 12
}
Rect.x0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'x0'
.owner: Rect
.doc: 'Represents the left edge of the rectangle'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1257: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:1203: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:1181: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:1154: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:971: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:959: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:953: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:584: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:466: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:458: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:433: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:372: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:305: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:275: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:167: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:165: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:152: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:146: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:148: referenced as `x0`
	cmplGfx/lib/micro.ui.ci:146: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:1007: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:1009: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:1007: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:975: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:924: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:926: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:924: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:855: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:839: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:841: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:839: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:763: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:375: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:190: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:92: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:92: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:89: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:86: referenced as `x0`
	cmplGfx/lib/micro.ui.core.ci:83: referenced as `x0`
	cmplGfx/lib/color.matrix.ci:36: referenced as `x0`
	cmplGfx/lib/color.matrix.ci:10: referenced as `x0`
	cmplGfx/lib/color.matrix.ci:10: referenced as `x0`
	cmplGfx/lib/color.lookup.ci:60: referenced as `x0`
	cmplGfx/lib/color.lookup.ci:32: referenced as `x0`
	cmplGfx/lib/color.lookup.ci:11: referenced as `x0`
	cmplGfx/lib/color.lookup.ci:11: referenced as `x0`
	cmplGfx/lib/image.transform.ci:56: referenced as `x0`
	cmplGfx/lib/image.transform.ci:45: referenced as `x0`
	cmplGfx/lib/image.transform.ci:29: referenced as `x0`
	cmplGfx/lib/image.transform.ci:24: referenced as `x0`
	cmplGfx/lib/image.transform.ci:17: referenced as `x0`
	cmplGfx/lib/image.transform.ci:17: referenced as `x0`
	cmplGfx/lib/image.transform.ci:11: referenced as `x0`
	cmplGfx/lib/image.transform.ci:11: referenced as `x0`
	cmplGfx/lib/image.blend.ci:181: referenced as `x0`
	cmplGfx/lib/image.blend.ci:161: referenced as `x0`
	cmplGfx/lib/image.blend.ci:161: referenced as `x0`
	cmplGfx/lib/image.blend.ci:133: referenced as `x0`
	cmplGfx/lib/image.blend.ci:133: referenced as `x0`
	cmplGfx/lib/image.blend.ci:80: referenced as `x0`
	cmplGfx/lib/image.blend.ci:69: referenced as `x0`
	cmplGfx/lib/image.blend.ci:44: referenced as `x0`
	cmplGfx/lib/image.blend.ci:36: referenced as `x0`
	cmplGfx/lib/image.blend.ci:15: referenced as `x0`
	cmplGfx/lib/image.blend.ci:9: referenced as `x0`
	cmplGfx/lib/image.blend.ci:9: referenced as `x0`
	cmplGfx/lib/image.draw.ci:21: referenced as `x0`
	cmplGfx/lib/image.draw.oval.ci:20: referenced as `x0`
	cmplGfx/lib/image.draw.oval.ci:12: referenced as `x0`
	cmplGfx/lib/image.draw.rrect.ci:135: referenced as `x0`
	cmplGfx/lib/image.draw.rect.ci:77: referenced as `x0`
	cmplGfx/lib/image.draw.rect.ci:69: referenced as `x0`
	cmplGfx/lib/image.ci:33: referenced as `x0`
	cmplGfx/lib/image.ci:32: referenced as `x0`
	cmplGfx/lib/rect.ci:69: referenced as `x0`
	cmplGfx/lib/rect.ci:59: referenced as `x0`
	cmplGfx/lib/rect.ci:51: referenced as `x0`
	cmplGfx/lib/rect.ci:35: referenced as `x0`
	cmplGfx/lib/rect.ci:34: referenced as `x0`
	cmplGfx/lib/rect.ci:28: referenced as `x0`
	cmplGfx/lib/rect.ci:16: referenced as `x0`
	cmplGfx/lib/rect.ci:13: referenced as `x0`
	cmplGfx/lib/rect.ci:9: referenced as `x0`
	cmplGfx/lib/rect.ci:4: referenced as `x0`
	internal usages: 5
}
Rect.y0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y0'
.owner: Rect
.doc: 'Represents the top edge of the rectangle'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1258: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:1204: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:1182: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:1155: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:971: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:960: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:954: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:477: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:374: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:147: referenced as `y0`
	cmplGfx/lib/micro.ui.ci:147: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:1008: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:1010: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:1008: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:976: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:940: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:925: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:927: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:925: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:840: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:842: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:840: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:764: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:193: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:107: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:107: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:104: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:101: referenced as `y0`
	cmplGfx/lib/micro.ui.core.ci:98: referenced as `y0`
	cmplGfx/lib/color.matrix.ci:35: referenced as `y0`
	cmplGfx/lib/color.matrix.ci:11: referenced as `y0`
	cmplGfx/lib/color.matrix.ci:11: referenced as `y0`
	cmplGfx/lib/color.lookup.ci:59: referenced as `y0`
	cmplGfx/lib/color.lookup.ci:31: referenced as `y0`
	cmplGfx/lib/color.lookup.ci:12: referenced as `y0`
	cmplGfx/lib/color.lookup.ci:12: referenced as `y0`
	cmplGfx/lib/image.transform.ci:55: referenced as `y0`
	cmplGfx/lib/image.transform.ci:44: referenced as `y0`
	cmplGfx/lib/image.transform.ci:29: referenced as `y0`
	cmplGfx/lib/image.transform.ci:25: referenced as `y0`
	cmplGfx/lib/image.transform.ci:18: referenced as `y0`
	cmplGfx/lib/image.transform.ci:18: referenced as `y0`
	cmplGfx/lib/image.transform.ci:12: referenced as `y0`
	cmplGfx/lib/image.transform.ci:12: referenced as `y0`
	cmplGfx/lib/image.blend.ci:179: referenced as `y0`
	cmplGfx/lib/image.blend.ci:162: referenced as `y0`
	cmplGfx/lib/image.blend.ci:162: referenced as `y0`
	cmplGfx/lib/image.blend.ci:134: referenced as `y0`
	cmplGfx/lib/image.blend.ci:134: referenced as `y0`
	cmplGfx/lib/image.blend.ci:80: referenced as `y0`
	cmplGfx/lib/image.blend.ci:69: referenced as `y0`
	cmplGfx/lib/image.blend.ci:43: referenced as `y0`
	cmplGfx/lib/image.blend.ci:35: referenced as `y0`
	cmplGfx/lib/image.blend.ci:18: referenced as `y0`
	cmplGfx/lib/image.blend.ci:10: referenced as `y0`
	cmplGfx/lib/image.blend.ci:10: referenced as `y0`
	cmplGfx/lib/image.draw.ci:21: referenced as `y0`
	cmplGfx/lib/image.draw.oval.ci:20: referenced as `y0`
	cmplGfx/lib/image.draw.oval.ci:12: referenced as `y0`
	cmplGfx/lib/image.draw.rrect.ci:135: referenced as `y0`
	cmplGfx/lib/image.draw.rect.ci:77: referenced as `y0`
	cmplGfx/lib/image.draw.rect.ci:69: referenced as `y0`
	cmplGfx/lib/image.ci:37: referenced as `y0`
	cmplGfx/lib/image.ci:36: referenced as `y0`
	cmplGfx/lib/rect.ci:74: referenced as `y0`
	cmplGfx/lib/rect.ci:60: referenced as `y0`
	cmplGfx/lib/rect.ci:52: referenced as `y0`
	cmplGfx/lib/rect.ci:40: referenced as `y0`
	cmplGfx/lib/rect.ci:39: referenced as `y0`
	cmplGfx/lib/rect.ci:29: referenced as `y0`
	cmplGfx/lib/rect.ci:23: referenced as `y0`
	cmplGfx/lib/rect.ci:20: referenced as `y0`
	cmplGfx/lib/rect.ci:9: referenced as `y0`
	cmplGfx/lib/rect.ci:4: referenced as `y0`
	internal usages: 5
}
Rect.x1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'x1'
.owner: Rect
.doc: 'Represents the right edge of the rectangle'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:971: referenced as `x1`
	cmplGfx/lib/micro.ui.ci:959: referenced as `x1`
	cmplGfx/lib/micro.ui.ci:955: referenced as `x1`
	cmplGfx/lib/micro.ui.ci:306: referenced as `x1`
	cmplGfx/lib/micro.ui.ci:167: referenced as `x1`
	cmplGfx/lib/micro.ui.ci:165: referenced as `x1`
	cmplGfx/lib/micro.ui.ci:152: referenced as `x1`
	cmplGfx/lib/micro.ui.ci:148: referenced as `x1`
	cmplGfx/lib/micro.ui.core.ci:1009: referenced as `x1`
	cmplGfx/lib/micro.ui.core.ci:977: referenced as `x1`
	cmplGfx/lib/micro.ui.core.ci:926: referenced as `x1`
	cmplGfx/lib/micro.ui.core.ci:841: referenced as `x1`
	cmplGfx/lib/micro.ui.core.ci:763: referenced as `x1`
	cmplGfx/lib/micro.ui.core.ci:375: referenced as `x1`
	cmplGfx/lib/micro.ui.core.ci:190: referenced as `x1`
	cmplGfx/lib/micro.ui.core.ci:93: referenced as `x1`
	cmplGfx/lib/micro.ui.core.ci:93: referenced as `x1`
	cmplGfx/lib/color.matrix.ci:36: referenced as `x1`
	cmplGfx/lib/color.matrix.ci:12: referenced as `x1`
	cmplGfx/lib/color.matrix.ci:12: referenced as `x1`
	cmplGfx/lib/color.lookup.ci:60: referenced as `x1`
	cmplGfx/lib/color.lookup.ci:32: referenced as `x1`
	cmplGfx/lib/color.lookup.ci:13: referenced as `x1`
	cmplGfx/lib/color.lookup.ci:13: referenced as `x1`
	cmplGfx/lib/image.transform.ci:56: referenced as `x1`
	cmplGfx/lib/image.transform.ci:45: referenced as `x1`
	cmplGfx/lib/image.transform.ci:19: referenced as `x1`
	cmplGfx/lib/image.transform.ci:19: referenced as `x1`
	cmplGfx/lib/image.transform.ci:13: referenced as `x1`
	cmplGfx/lib/image.transform.ci:13: referenced as `x1`
	cmplGfx/lib/image.blend.ci:181: referenced as `x1`
	cmplGfx/lib/image.blend.ci:163: referenced as `x1`
	cmplGfx/lib/image.blend.ci:163: referenced as `x1`
	cmplGfx/lib/image.blend.ci:135: referenced as `x1`
	cmplGfx/lib/image.blend.ci:135: referenced as `x1`
	cmplGfx/lib/image.blend.ci:44: referenced as `x1`
	cmplGfx/lib/image.blend.ci:36: referenced as `x1`
	cmplGfx/lib/image.blend.ci:11: referenced as `x1`
	cmplGfx/lib/image.blend.ci:11: referenced as `x1`
	cmplGfx/lib/image.draw.ci:21: referenced as `x1`
	cmplGfx/lib/image.draw.oval.ci:20: referenced as `x1`
	cmplGfx/lib/image.draw.oval.ci:12: referenced as `x1`
	cmplGfx/lib/image.draw.rrect.ci:135: referenced as `x1`
	cmplGfx/lib/image.draw.rect.ci:77: referenced as `x1`
	cmplGfx/lib/image.draw.rect.ci:69: referenced as `x1`
	cmplGfx/lib/image.ci:42: referenced as `x1`
	cmplGfx/lib/image.ci:41: referenced as `x1`
	cmplGfx/lib/rect.ci:70: referenced as `x1`
	cmplGfx/lib/rect.ci:61: referenced as `x1`
	cmplGfx/lib/rect.ci:53: referenced as `x1`
	cmplGfx/lib/rect.ci:34: referenced as `x1`
	cmplGfx/lib/rect.ci:34: referenced as `x1`
	cmplGfx/lib/rect.ci:28: referenced as `x1`
	cmplGfx/lib/rect.ci:16: referenced as `x1`
	cmplGfx/lib/rect.ci:13: referenced as `x1`
	cmplGfx/lib/rect.ci:9: referenced as `x1`
	cmplGfx/lib/rect.ci:4: referenced as `x1`
	internal usages: 5
}
Rect.y1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y1'
.owner: Rect
.doc: 'Represents the bottom edge of the rectangle'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:971: referenced as `y1`
	cmplGfx/lib/micro.ui.ci:960: referenced as `y1`
	cmplGfx/lib/micro.ui.ci:956: referenced as `y1`
	cmplGfx/lib/micro.ui.ci:579: referenced as `y1`
	cmplGfx/lib/micro.ui.ci:459: referenced as `y1`
	cmplGfx/lib/micro.ui.ci:426: referenced as `y1`
	cmplGfx/lib/micro.ui.ci:303: referenced as `y1`
	cmplGfx/lib/micro.ui.ci:149: referenced as `y1`
	cmplGfx/lib/micro.ui.ci:149: referenced as `y1`
	cmplGfx/lib/micro.ui.core.ci:1010: referenced as `y1`
	cmplGfx/lib/micro.ui.core.ci:978: referenced as `y1`
	cmplGfx/lib/micro.ui.core.ci:927: referenced as `y1`
	cmplGfx/lib/micro.ui.core.ci:842: referenced as `y1`
	cmplGfx/lib/micro.ui.core.ci:764: referenced as `y1`
	cmplGfx/lib/micro.ui.core.ci:193: referenced as `y1`
	cmplGfx/lib/micro.ui.core.ci:108: referenced as `y1`
	cmplGfx/lib/micro.ui.core.ci:108: referenced as `y1`
	cmplGfx/lib/color.matrix.ci:35: referenced as `y1`
	cmplGfx/lib/color.matrix.ci:13: referenced as `y1`
	cmplGfx/lib/color.matrix.ci:13: referenced as `y1`
	cmplGfx/lib/color.lookup.ci:59: referenced as `y1`
	cmplGfx/lib/color.lookup.ci:31: referenced as `y1`
	cmplGfx/lib/color.lookup.ci:14: referenced as `y1`
	cmplGfx/lib/color.lookup.ci:14: referenced as `y1`
	cmplGfx/lib/image.transform.ci:55: referenced as `y1`
	cmplGfx/lib/image.transform.ci:44: referenced as `y1`
	cmplGfx/lib/image.transform.ci:20: referenced as `y1`
	cmplGfx/lib/image.transform.ci:20: referenced as `y1`
	cmplGfx/lib/image.transform.ci:14: referenced as `y1`
	cmplGfx/lib/image.transform.ci:14: referenced as `y1`
	cmplGfx/lib/image.blend.ci:179: referenced as `y1`
	cmplGfx/lib/image.blend.ci:164: referenced as `y1`
	cmplGfx/lib/image.blend.ci:164: referenced as `y1`
	cmplGfx/lib/image.blend.ci:136: referenced as `y1`
	cmplGfx/lib/image.blend.ci:136: referenced as `y1`
	cmplGfx/lib/image.blend.ci:43: referenced as `y1`
	cmplGfx/lib/image.blend.ci:35: referenced as `y1`
	cmplGfx/lib/image.blend.ci:12: referenced as `y1`
	cmplGfx/lib/image.blend.ci:12: referenced as `y1`
	cmplGfx/lib/image.draw.ci:21: referenced as `y1`
	cmplGfx/lib/image.draw.oval.ci:20: referenced as `y1`
	cmplGfx/lib/image.draw.oval.ci:12: referenced as `y1`
	cmplGfx/lib/image.draw.rrect.ci:135: referenced as `y1`
	cmplGfx/lib/image.draw.rect.ci:77: referenced as `y1`
	cmplGfx/lib/image.draw.rect.ci:69: referenced as `y1`
	cmplGfx/lib/image.ci:47: referenced as `y1`
	cmplGfx/lib/image.ci:46: referenced as `y1`
	cmplGfx/lib/rect.ci:75: referenced as `y1`
	cmplGfx/lib/rect.ci:62: referenced as `y1`
	cmplGfx/lib/rect.ci:54: referenced as `y1`
	cmplGfx/lib/rect.ci:39: referenced as `y1`
	cmplGfx/lib/rect.ci:39: referenced as `y1`
	cmplGfx/lib/rect.ci:29: referenced as `y1`
	cmplGfx/lib/rect.ci:23: referenced as `y1`
	cmplGfx/lib/rect.ci:20: referenced as `y1`
	cmplGfx/lib/rect.ci:9: referenced as `y1`
	cmplGfx/lib/rect.ci:4: referenced as `y1`
	internal usages: 5
}
Image: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Image'
.print: '%a'
.field create: function (size: 0, cast: static const inline)
.field create3d: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field slice: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openBmp: function (size: 0, cast: static const inline)
.field openPng: function (size: 0, cast: static const inline)
.field openJpg: function (size: 0, cast: static const inline)
.field openImg: function (size: 0, cast: static const inline)
.field openTtf: function (size: 0, cast: static const inline)
.field openFnt: function (size: 0, cast: static const inline)
.field saveBmp: function (size: 0, cast: static const inline)
.field width: function (size: 0, cast: static const inline)
.field height: function (size: 0, cast: static const inline)
.field depth: function (size: 0, cast: static const inline)
.field get: function (size: 0, cast: static const inline)
.field set: function (size: 0, cast: static const inline)
.field tex: function (size: 0, cast: static const inline)
.field clipText: function (size: 0, cast: static const inline)
.field drawText: function (size: 0, cast: static const inline)
.field fillRect: function (size: 0, cast: static const inline)
.field blend: function (size: 0, cast: static const inline)
.field transform: function (size: 0, cast: static const inline)
.field blur: function (size: 0, cast: static const inline)
.field colorMap: function (size: 0, cast: static const inline)
.field colorMat: function (size: 0, cast: static const inline)
.field calcHueHist: function (size: 0, cast: static const inline)
.field calcLumHist: function (size: 0, cast: static const inline)
.field calcRgbHist: function (size: 0, cast: static const inline)
.field drawMesh: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplGfx/lib/micro.ui.ci:1351: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:1281: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:1080: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:1078: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:967: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:675: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:663: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:657: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:651: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:567: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:416: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:341: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:316: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:298: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:141: referenced as `Image`
	cmplGfx/lib/micro.ui.ci:14: referenced as `Image`
	cmplGfx/lib/micro.ui.core.ci:1224: referenced as `Image`
	cmplGfx/lib/micro.ui.core.ci:1029: referenced as `Image`
	cmplGfx/lib/micro.ui.core.ci:531: referenced as `Image`
	cmplGfx/lib/micro.ui.core.ci:363: referenced as `Image`
	cmplGfx/lib/micro.ui.core.ci:347: referenced as `Image`
	cmplGfx/lib/micro.ui.core.ci:344: referenced as `Image`
	cmplGfx/lib/micro.ui.core.ci:33: referenced as `Image`
	cmplGfx/lib/window.ci:378: referenced as `Image`
	cmplGfx/lib/window.ci:171: referenced as `Image`
	cmplGfx/lib/window.ci:141: referenced as `Image`
	cmplGfx/lib/window.ci:88: referenced as `Image`
	cmplGfx/lib/window.ci:87: referenced as `Image`
	cmplGfx/lib/window.ci:78: referenced as `Image`
	cmplGfx/lib/window.ci:73: referenced as `Image`
	cmplGfx/lib/window.ci:73: referenced as `Image`
	cmplGfx/lib/window.ci:66: referenced as `Image`
	cmplGfx/lib/window.ci:66: referenced as `Image`
	cmplGfx/lib/window.ci:66: referenced as `Image`
	cmplGfx/lib/window.ci:53: referenced as `Image`
	cmplGfx/lib/window.ci:34: referenced as `Image`
	cmplGfx/lib/window.ci:25: referenced as `Image`
	cmplGfx/lib/window.ci:24: referenced as `Image`
	cmplGfx/lib/window.ci:23: referenced as `Image`
	cmplGfx/lib/window.ci:22: referenced as `Image`
	cmplGfx/lib/window.ci:20: referenced as `Image`
	cmplGfx/lib/window.ci:20: referenced as `Image`
	cmplGfx/lib/window.ci:20: referenced as `Image`
	cmplGfx/lib/window.ci:9: referenced as `Image`
	cmplGfx/lib/color.matrix.ci:4: referenced as `Image`
	cmplGfx/lib/color.matrix.ci:3: referenced as `Image`
	cmplGfx/lib/color.matrix.ci:2: referenced as `Image`
	cmplGfx/lib/color.lookup.ci:4: referenced as `Image`
	cmplGfx/lib/color.lookup.ci:3: referenced as `Image`
	cmplGfx/lib/color.lookup.ci:2: referenced as `Image`
	cmplGfx/lib/image.blur.ci:41: referenced as `Image`
	cmplGfx/lib/image.blur.ci:41: referenced as `Image`
	cmplGfx/lib/image.blur.ci:4: referenced as `Image`
	cmplGfx/lib/image.blur.ci:3: referenced as `Image`
	cmplGfx/lib/image.blur.ci:2: referenced as `Image`
	cmplGfx/lib/image.transform.ci:138: referenced as `Image`
	cmplGfx/lib/image.transform.ci:137: referenced as `Image`
	cmplGfx/lib/image.transform.ci:136: referenced as `Image`
	cmplGfx/lib/image.transform.ci:130: referenced as `Image`
	cmplGfx/lib/image.transform.ci:67: referenced as `Image`
	cmplGfx/lib/image.transform.ci:67: referenced as `Image`
	cmplGfx/lib/image.transform.ci:64: referenced as `Image`
	cmplGfx/lib/image.transform.ci:64: referenced as `Image`
	cmplGfx/lib/image.transform.ci:4: referenced as `Image`
	cmplGfx/lib/image.transform.ci:3: referenced as `Image`
	cmplGfx/lib/image.transform.ci:2: referenced as `Image`
	cmplGfx/lib/image.transform.ci:2: referenced as `Image`
	cmplGfx/lib/image.blend.ci:159: referenced as `Image`
	cmplGfx/lib/image.blend.ci:131: referenced as `Image`
	cmplGfx/lib/image.blend.ci:131: referenced as `Image`
	cmplGfx/lib/image.blend.ci:125: referenced as `Image`
	cmplGfx/lib/image.blend.ci:125: referenced as `Image`
	cmplGfx/lib/image.blend.ci:124: referenced as `Image`
	cmplGfx/lib/image.blend.ci:124: referenced as `Image`
	cmplGfx/lib/image.blend.ci:119: referenced as `Image`
	cmplGfx/lib/image.blend.ci:119: referenced as `Image`
	cmplGfx/lib/image.blend.ci:103: referenced as `Image`
	cmplGfx/lib/image.blend.ci:103: referenced as `Image`
	cmplGfx/lib/image.blend.ci:102: referenced as `Image`
	cmplGfx/lib/image.blend.ci:101: referenced as `Image`
	cmplGfx/lib/image.blend.ci:101: referenced as `Image`
	cmplGfx/lib/image.blend.ci:86: referenced as `Image`
	cmplGfx/lib/image.blend.ci:86: referenced as `Image`
	cmplGfx/lib/image.blend.ci:85: referenced as `Image`
	cmplGfx/lib/image.blend.ci:84: referenced as `Image`
	cmplGfx/lib/image.blend.ci:84: referenced as `Image`
	cmplGfx/lib/image.blend.ci:69: referenced as `Image`
	cmplGfx/lib/image.blend.ci:68: referenced as `Image`
	cmplGfx/lib/image.blend.ci:67: referenced as `Image`
	cmplGfx/lib/image.blend.ci:55: referenced as `Image`
	cmplGfx/lib/image.blend.ci:55: referenced as `Image`
	cmplGfx/lib/image.blend.ci:54: referenced as `Image`
	cmplGfx/lib/image.blend.ci:53: referenced as `Image`
	cmplGfx/lib/image.blend.ci:53: referenced as `Image`
	cmplGfx/lib/image.blend.ci:4: referenced as `Image`
	cmplGfx/lib/image.blend.ci:3: referenced as `Image`
	cmplGfx/lib/image.blend.ci:2: referenced as `Image`
	cmplGfx/lib/image.blend.ci:2: referenced as `Image`
	cmplGfx/lib/image.draw.ci:20: referenced as `Image`
	cmplGfx/lib/image.draw.ci:20: referenced as `Image`
	cmplGfx/lib/image.draw.ci:14: referenced as `Image`
	cmplGfx/lib/image.draw.ci:14: referenced as `Image`
	cmplGfx/lib/image.draw.line.ci:105: referenced as `Image`
	cmplGfx/lib/image.draw.line.ci:85: referenced as `Image`
	cmplGfx/lib/image.draw.line.ci:79: referenced as `Image`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `Image`
	cmplGfx/lib/image.draw.line.ci:2: referenced as `Image`
	cmplGfx/lib/image.draw.oval.ci:16: referenced as `Image`
	cmplGfx/lib/image.draw.oval.ci:8: referenced as `Image`
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `Image`
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `Image`
	cmplGfx/lib/image.draw.rrect.ci:139: referenced as `Image`
	cmplGfx/lib/image.draw.rrect.ci:131: referenced as `Image`
	cmplGfx/lib/image.draw.rrect.ci:128: referenced as `Image`
	cmplGfx/lib/image.draw.rrect.ci:125: referenced as `Image`
	cmplGfx/lib/image.draw.rrect.ci:61: referenced as `Image`
	cmplGfx/lib/image.draw.rrect.ci:2: referenced as `Image`
	cmplGfx/lib/image.draw.rect.ci:73: referenced as `Image`
	cmplGfx/lib/image.draw.rect.ci:65: referenced as `Image`
	cmplGfx/lib/image.draw.rect.ci:62: referenced as `Image`
	cmplGfx/lib/image.draw.rect.ci:31: referenced as `Image`
	cmplGfx/lib/image.draw.rect.ci:28: referenced as `Image`
	cmplGfx/lib/image.draw.rect.ci:4: referenced as `Image`
	cmplGfx/lib/image.draw.rect.ci:3: referenced as `Image`
	cmplGfx/lib/image.draw.rect.ci:2: referenced as `Image`
	cmplGfx/lib/image.ci:54: referenced as `Image`
	cmplGfx/lib/image.ci:54: referenced as `Image`
	cmplGfx/lib/image.ci:31: referenced as `Image`
	cmplGfx/lib/image.ci:24: referenced as `Image`
	cmplGfx/lib/image.ci:21: referenced as `Image`
	cmplGfx/lib/image.ci:19: referenced as `Image`
	cmplGfx/lib/image.ci:16: referenced as `Image`
	cmplGfx/lib/image.ci:13: referenced as `Image`
	cmplGfx/lib/image.ci:11: referenced as `Image`
	cmplGfx/lib/image.ci:8: referenced as `Image`
	cmplGfx/lib/image.ci:6: referenced as `Image`
	cmplGfx/lib/image.ci:5: referenced as `Image`
	cmplGfx/lib/image.ci:2: referenced as `Image`
	internal usages: 40
}
Image.create(width: int32, height: int32, depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(89)
.usages:
	cmplGfx/lib/image.blur.ci:41: referenced as `create`
	cmplGfx/lib/image.blend.ci:125: referenced as `create`
	cmplGfx/lib/image.ci:2: referenced as `create`
}
Image.create3d(width: int32, height: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create3d'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(90)
.usages:
	cmplGfx/lib/window.ci:378: referenced as `create3d`
}
Image.recycle(recycle: Image, width: int32, height: int32, depth: int32, flags: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param recycle: Image (size: 8, cast: variable(val))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.param flags: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(91)
.usages:
}
Image.slice(image: Image, rect: Rect): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'slice'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(92)
.usages:
	cmplGfx/lib/micro.ui.ci:968: referenced as `slice`
}
Image.destroy(image: Image): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.doc: '@builtin'
.value: nfc(93)
.usages:
	cmplGfx/lib/micro.ui.ci:1353: referenced as `destroy`
	cmplGfx/lib/micro.ui.ci:975: referenced as `destroy`
	cmplGfx/lib/window.ci:384: referenced as `destroy`
	cmplGfx/lib/window.ci:156: referenced as `destroy`
	cmplGfx/lib/window.ci:155: referenced as `destroy`
	cmplGfx/lib/window.ci:144: referenced as `destroy`
	cmplGfx/lib/window.ci:62: referenced as `destroy`
	cmplGfx/lib/image.blur.ci:83: referenced as `destroy`
	cmplGfx/lib/image.transform.ci:139: referenced as `destroy`
}
Image.openBmp(path: char[*], depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openBmp'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(94)
.usages:
	cmplGfx/lib/image.ci:21: referenced as `openBmp`
	cmplGfx/lib/image.ci:19: referenced as `openBmp`
}
Image.openPng(path: char[*], depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openPng'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(95)
.usages:
	cmplGfx/lib/image.ci:8: referenced as `openPng`
	cmplGfx/lib/image.ci:6: referenced as `openPng`
}
Image.openJpg(path: char[*], depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openJpg'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(96)
.usages:
	cmplGfx/lib/image.ci:16: referenced as `openJpg`
	cmplGfx/lib/image.ci:13: referenced as `openJpg`
	cmplGfx/lib/image.ci:11: referenced as `openJpg`
}
Image.openImg(path: char[*], depth: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openImg'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(97)
.usages:
	cmplGfx/lib/image.ci:24: referenced as `openImg`
}
Image.openTtf(path: char[*], height: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openTtf'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.param height: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(98)
.usages:
}
Image.openFnt(path: char[*]): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openFnt'
.owner: Image
.param .result: Image (size: 8, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(99)
.usages:
}
Image.saveBmp(image: Image, path: char[*], flags: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveBmp'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param path: char[*] (size: 4, cast: const variable(ref))
.param flags: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(100)
.usages:
	cmplGfx/lib/window.ci:119: referenced as `saveBmp`
	cmplGfx/lib/window.ci:118: referenced as `saveBmp`
}
Image.width(image: Image): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'width'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.doc: '@builtin'
.value: nfc(101)
.usages:
	cmplGfx/lib/micro.ui.ci:1284: referenced as `width`
	cmplGfx/lib/micro.ui.ci:971: referenced as `width`
	cmplGfx/lib/window.ci:67: referenced as `width`
	cmplGfx/lib/window.ci:44: referenced as `width`
	cmplGfx/lib/window.ci:44: referenced as `width`
	cmplGfx/lib/color.matrix.ci:12: referenced as `width`
	cmplGfx/lib/color.lookup.ci:13: referenced as `width`
	cmplGfx/lib/image.blur.ci:39: referenced as `width`
	cmplGfx/lib/image.transform.ci:112: referenced as `width`
	cmplGfx/lib/image.transform.ci:109: referenced as `width`
	cmplGfx/lib/image.transform.ci:97: referenced as `width`
	cmplGfx/lib/image.transform.ci:88: referenced as `width`
	cmplGfx/lib/image.transform.ci:54: referenced as `width`
	cmplGfx/lib/image.transform.ci:19: referenced as `width`
	cmplGfx/lib/image.transform.ci:13: referenced as `width`
	cmplGfx/lib/image.blend.ci:171: referenced as `width`
	cmplGfx/lib/image.blend.ci:163: referenced as `width`
	cmplGfx/lib/image.blend.ci:149: referenced as `width`
	cmplGfx/lib/image.blend.ci:135: referenced as `width`
	cmplGfx/lib/image.blend.ci:125: referenced as `width`
	cmplGfx/lib/image.blend.ci:11: referenced as `width`
	cmplGfx/lib/image.draw.ci:21: referenced as `width`
	cmplGfx/lib/image.draw.ci:15: referenced as `width`
	cmplGfx/lib/image.draw.line.ci:23: referenced as `width`
	cmplGfx/lib/image.draw.line.ci:22: referenced as `width`
	cmplGfx/lib/image.ci:40: referenced as `width`
}
Image.height(image: Image): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'height'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.doc: '@builtin'
.value: nfc(102)
.usages:
	cmplGfx/lib/micro.ui.ci:1284: referenced as `height`
	cmplGfx/lib/micro.ui.ci:971: referenced as `height`
	cmplGfx/lib/window.ci:68: referenced as `height`
	cmplGfx/lib/window.ci:44: referenced as `height`
	cmplGfx/lib/window.ci:44: referenced as `height`
	cmplGfx/lib/color.matrix.ci:13: referenced as `height`
	cmplGfx/lib/color.lookup.ci:14: referenced as `height`
	cmplGfx/lib/image.blur.ci:40: referenced as `height`
	cmplGfx/lib/image.transform.ci:120: referenced as `height`
	cmplGfx/lib/image.transform.ci:117: referenced as `height`
	cmplGfx/lib/image.transform.ci:100: referenced as `height`
	cmplGfx/lib/image.transform.ci:89: referenced as `height`
	cmplGfx/lib/image.transform.ci:54: referenced as `height`
	cmplGfx/lib/image.transform.ci:20: referenced as `height`
	cmplGfx/lib/image.transform.ci:14: referenced as `height`
	cmplGfx/lib/image.blend.ci:172: referenced as `height`
	cmplGfx/lib/image.blend.ci:164: referenced as `height`
	cmplGfx/lib/image.blend.ci:150: referenced as `height`
	cmplGfx/lib/image.blend.ci:136: referenced as `height`
	cmplGfx/lib/image.blend.ci:125: referenced as `height`
	cmplGfx/lib/image.blend.ci:12: referenced as `height`
	cmplGfx/lib/image.draw.ci:21: referenced as `height`
	cmplGfx/lib/image.draw.ci:15: referenced as `height`
	cmplGfx/lib/image.draw.line.ci:54: referenced as `height`
	cmplGfx/lib/image.draw.line.ci:53: referenced as `height`
	cmplGfx/lib/image.ci:45: referenced as `height`
}
Image.depth(image: Image): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'depth'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.doc: '@builtin'
.value: nfc(103)
.usages:
	cmplGfx/lib/window.ci:53: referenced as `depth`
	cmplGfx/lib/color.matrix.ci:6: referenced as `depth`
	cmplGfx/lib/color.lookup.ci:7: referenced as `depth`
	cmplGfx/lib/image.blur.ci:41: referenced as `depth`
	cmplGfx/lib/image.transform.ci:130: referenced as `depth`
	cmplGfx/lib/image.transform.ci:8: referenced as `depth`
	cmplGfx/lib/image.transform.ci:7: referenced as `depth`
	cmplGfx/lib/image.blend.ci:125: referenced as `depth`
	cmplGfx/lib/image.blend.ci:33: referenced as `depth`
	cmplGfx/lib/image.blend.ci:33: referenced as `depth`
}
Image.get(image: Image, x: int32, y: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'get'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(104)
.usages:
	cmplGfx/lib/color.matrix.ci:37: referenced as `get`
	cmplGfx/lib/color.lookup.ci:61: referenced as `get`
	cmplGfx/lib/color.lookup.ci:33: referenced as `get`
	cmplGfx/lib/image.blur.ci:72: referenced as `get`
	cmplGfx/lib/image.blur.ci:52: referenced as `get`
	cmplGfx/lib/image.transform.ci:47: referenced as `get`
	cmplGfx/lib/image.blend.ci:46: referenced as `get`
	cmplGfx/lib/image.blend.ci:45: referenced as `get`
	cmplGfx/lib/image.blend.ci:37: referenced as `get`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `get`
}
Image.set(image: Image, x: int32, y: int32, color: uint32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'set'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: '@builtin'
.value: nfc(105)
.usages:
	cmplGfx/lib/micro.ui.ci:477: referenced as `set`
	cmplGfx/lib/image.transform.ci:47: referenced as `set`
	cmplGfx/lib/image.blend.ci:37: referenced as `set`
	cmplGfx/lib/image.draw.line.ci:71: referenced as `set`
	cmplGfx/lib/image.draw.line.ci:40: referenced as `set`
	cmplGfx/lib/image.draw.rrect.ci:108: referenced as `set`
	cmplGfx/lib/image.draw.rrect.ci:107: referenced as `set`
	cmplGfx/lib/image.draw.rrect.ci:106: referenced as `set`
	cmplGfx/lib/image.draw.rrect.ci:105: referenced as `set`
	cmplGfx/lib/image.draw.rect.ci:22: referenced as `set`
	cmplGfx/lib/image.ci:54: referenced as `set`
}
Image.tex(image: Image, x: float32, y: float32): vec4f: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tex'
.owner: Image
.param .result: vec4f (size: 16, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(106)
.usages:
	cmplGfx/lib/image.transform.ci:58: referenced as `tex`
}
Image.clipText(font: Image, rect: Rect, text: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clipText'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param font: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 4, cast: variable(ref))
.param text: char[*] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(107)
.usages:
	cmplGfx/lib/micro.ui.core.ci:121: referenced as `clipText`
	cmplGfx/lib/micro.ui.core.ci:114: referenced as `clipText`
}
Image.drawText(image: Image, roi: Rect, font: Image, text: char[*], color: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawText'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param font: Image (size: 8, cast: variable(val))
.param text: char[*] (size: 4, cast: const variable(ref))
.param color: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(108)
.usages:
	cmplGfx/lib/micro.ui.ci:669: referenced as `drawText`
	cmplGfx/lib/micro.ui.ci:594: referenced as `drawText`
	cmplGfx/lib/micro.ui.core.ci:378: referenced as `drawText`
	cmplGfx/lib/micro.ui.core.ci:374: referenced as `drawText`
	cmplGfx/lib/micro.ui.core.ci:367: referenced as `drawText`
	cmplGfx/lib/image.draw.ci:22: referenced as `drawText`
}
Image.fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fillRect'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param incl: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: '@builtin'
.value: nfc(109)
.usages:
	cmplGfx/lib/image.draw.rect.ci:4: referenced as `fillRect`
	cmplGfx/lib/image.draw.rect.ci:3: referenced as `fillRect`
}
Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'blend'
.owner: Image
.field color: function (size: 0, cast: static const typename(ref))
.field alpha: function (size: 0, cast: static const typename(ref))
.field dstAlpha: function (size: 0, cast: static const typename(ref))
.field blendVec4f: function (size: 0, cast: static const typename(ref))
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: const variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param extra: pointer (size: 4, cast: variable(ref))
.param blend: function (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(110)
.usages:
	cmplGfx/lib/image.blend.ci:103: referenced as `blend`
	cmplGfx/lib/image.blend.ci:103: referenced as `blend`
	cmplGfx/lib/image.blend.ci:102: referenced as `blend`
	cmplGfx/lib/image.blend.ci:86: referenced as `blend`
	cmplGfx/lib/image.blend.ci:86: referenced as `blend`
	cmplGfx/lib/image.blend.ci:85: referenced as `blend`
	cmplGfx/lib/image.blend.ci:69: referenced as `blend`
	cmplGfx/lib/image.blend.ci:69: referenced as `blend`
	cmplGfx/lib/image.blend.ci:68: referenced as `blend`
	cmplGfx/lib/image.blend.ci:55: referenced as `blend`
	cmplGfx/lib/image.blend.ci:55: referenced as `blend`
	cmplGfx/lib/image.blend.ci:54: referenced as `blend`
	cmplGfx/lib/image.blend.ci:4: referenced as `blend`
	cmplGfx/lib/image.blend.ci:3: referenced as `blend`
}
Image.blend.color: function {
.kind: static const typename(ref)
.base: `function`
.size: 0
.name: 'color'
.print: 'color'
.owner: Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void
.param .result: uint32 (size: 4, cast: variable(u32))
.param extra: pointer (size: 4, cast: variable(ref))
.param base: uint32 (size: 4, cast: variable(u32))
.param with: uint32 (size: 4, cast: variable(u32))
.doc: '@builtin'
.usages:
	cmplGfx/lib/image.blend.ci:69: referenced as `color`
	cmplGfx/lib/image.blend.ci:68: referenced as `color`
}
Image.blend.alpha: function {
.kind: static const typename(ref)
.base: `function`
.size: 0
.name: 'alpha'
.print: 'alpha'
.owner: Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void
.param .result: uint32 (size: 4, cast: variable(u32))
.param extra: pointer (size: 4, cast: variable(ref))
.param base: uint32 (size: 4, cast: variable(u32))
.param with: uint32 (size: 4, cast: variable(u32))
.doc: '@builtin'
.usages:
	cmplGfx/lib/image.blend.ci:86: referenced as `alpha`
	cmplGfx/lib/image.blend.ci:85: referenced as `alpha`
}
Image.blend.dstAlpha: function {
.kind: static const typename(ref)
.base: `function`
.size: 0
.name: 'dstAlpha'
.print: 'dstAlpha'
.owner: Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void
.param .result: uint32 (size: 4, cast: variable(u32))
.param extra: pointer (size: 4, cast: variable(ref))
.param base: uint32 (size: 4, cast: variable(u32))
.param with: uint32 (size: 4, cast: variable(u32))
.doc: '@builtin'
.usages:
	cmplGfx/lib/image.blend.ci:103: referenced as `dstAlpha`
	cmplGfx/lib/image.blend.ci:102: referenced as `dstAlpha`
}
Image.blend.blendVec4f: function {
.kind: static const typename(ref)
.base: `function`
.size: 0
.name: 'blendVec4f'
.print: 'blendVec4f'
.owner: Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void
.param .result: uint32 (size: 4, cast: variable(u32))
.param extra: pointer (size: 4, cast: variable(ref))
.param base: uint32 (size: 4, cast: variable(u32))
.param with: uint32 (size: 4, cast: variable(u32))
.doc: '@builtin'
.usages:
	cmplGfx/lib/image.blend.ci:55: referenced as `blendVec4f`
	cmplGfx/lib/image.blend.ci:54: referenced as `blendVec4f`
}
Image.transform(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32, mat: float32[16]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'transform'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 4, cast: const variable(ref))
.param src: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param interpolate: int32 (size: 4, cast: variable(i32))
.param mat: float32[16] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(111)
.usages:
	cmplGfx/lib/image.transform.ci:4: referenced as `transform`
	cmplGfx/lib/image.transform.ci:3: referenced as `transform`
}
Image.blur(image: Image, radius: int32, sigma: float64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'blur'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param radius: int32 (size: 4, cast: variable(i32))
.param sigma: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(112)
.usages:
	cmplGfx/lib/image.blur.ci:4: referenced as `blur`
	cmplGfx/lib/image.blur.ci:3: referenced as `blur`
}
Image.colorMap(image: Image, roi: Rect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMap'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(113)
.usages:
	cmplGfx/lib/color.lookup.ci:4: referenced as `colorMap`
	cmplGfx/lib/color.lookup.ci:3: referenced as `colorMap`
}
Image.colorMat(image: Image, roi: Rect, mat: float32[16]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'colorMat'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param mat: float32[16] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(114)
.usages:
	cmplGfx/lib/color.matrix.ci:4: referenced as `colorMat`
	cmplGfx/lib/color.matrix.ci:3: referenced as `colorMat`
}
Image.calcHueHist(image: Image, roi: Rect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'calcHueHist'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(115)
.usages:
}
Image.calcLumHist(image: Image, roi: Rect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'calcLumHist'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(116)
.usages:
}
Image.calcRgbHist(image: Image, roi: Rect, lut: uint32[256]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'calcRgbHist'
.owner: Image
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param lut: uint32[256] (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(117)
.usages:
	cmplGfx/lib/micro.ui.ci:343: referenced as `calcRgbHist`
}
Image.drawMesh(image: Image, mesh: Mesh, mode: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'drawMesh'
.owner: Image
.param .result: int32 (size: 4, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param mesh: Mesh (size: 4, cast: variable(ref))
.param mode: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(118)
.usages:
	cmplGfx/lib/window.ci:353: referenced as `drawMesh`
}
Mesh: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 160
.name: 'Mesh'
.field create: function (size: 0, cast: static const inline)
.field recycle: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field openObj: function (size: 0, cast: static const inline)
.field open3ds: function (size: 0, cast: static const inline)
.field saveObj: function (size: 0, cast: static const inline)
.field normalize: function (size: 0, cast: static const inline)
.field addVertex: function (size: 0, cast: static const inline)
.field addLine: function (size: 0, cast: static const inline)
.field addFace: function (size: 0, cast: static const inline)
.field addFace: function (size: 0, cast: static const inline)
.field setVertex: function (size: 0, cast: static const inline)
.field setNormal: function (size: 0, cast: static const inline)
.field setTexture: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field shine: function (size: 0, cast: static const inline)
.field texture: function (size: 0, cast: static const inline)
.field keepBuffer: int64 (size: 0, cast: static const i64)
.field cullBack: int64 (size: 0, cast: static const i64)
.field cullFront: int64 (size: 0, cast: static const i64)
.field cullMode: int64 (size: 0, cast: static const i64)
.field drawPlot: int64 (size: 0, cast: static const i64)
.field drawWire: int64 (size: 0, cast: static const i64)
.field drawFill: int64 (size: 0, cast: static const i64)
.field drawMode: int64 (size: 0, cast: static const i64)
.field useTexture: int64 (size: 0, cast: static const i64)
.field useLights: int64 (size: 0, cast: static const i64)
.field drawBounds: int64 (size: 0, cast: static const i64)
.field vertices: int64 (size: 8, cast: const variable(i64))
.field triangles: int64 (size: 8, cast: const variable(i64))
.field segments: int64 (size: 8, cast: const variable(i64))
.doc: '@builtin'
.usages:
	cmplGfx/lib/window.ci:377: referenced as `Mesh`
	cmplGfx/lib/window.ci:377: referenced as `Mesh`
	cmplGfx/lib/window.ci:377: referenced as `Mesh`
	cmplGfx/lib/window.ci:340: referenced as `Mesh`
	cmplGfx/lib/window.ci:337: referenced as `Mesh`
	cmplGfx/lib/window.ci:334: referenced as `Mesh`
	cmplGfx/lib/window.ci:319: referenced as `Mesh`
	cmplGfx/lib/window.ci:316: referenced as `Mesh`
	cmplGfx/lib/window.ci:174: referenced as `Mesh`
	cmplGfx/lib/window.ci:165: referenced as `Mesh`
	cmplGfx/lib/mesh.ci:7: referenced as `Mesh`
	cmplGfx/lib/mesh.ci:4: referenced as `Mesh`
	cmplGfx/lib/mesh.ci:2: referenced as `Mesh`
	internal usages: 21
}
Mesh.create(size: int32): Mesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: Mesh
.param .result: Mesh (size: 4, cast: inline)
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(70)
.usages:
}
Mesh.recycle(recycle: Mesh, size: int32): Mesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'recycle'
.owner: Mesh
.param .result: Mesh (size: 4, cast: inline)
.param recycle: Mesh (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(71)
.usages:
}
Mesh.destroy(mesh: Mesh): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(72)
.usages:
}
Mesh.openObj(path: char[*]): Mesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'openObj'
.owner: Mesh
.param .result: Mesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(73)
.usages:
	cmplGfx/lib/mesh.ci:4: referenced as `openObj`
}
Mesh.open3ds(path: char[*]): Mesh: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'open3ds'
.owner: Mesh
.param .result: Mesh (size: 4, cast: inline)
.param path: char[*] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(74)
.usages:
	cmplGfx/lib/mesh.ci:7: referenced as `open3ds`
}
Mesh.saveObj(mesh: Mesh, path: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'saveObj'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param path: char[*] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(75)
.usages:
}
Mesh.normalize(mesh: Mesh, tolerance: float32, center: float32[3], resize: float32[3]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'normalize'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param tolerance: float32 (size: 4, cast: variable(f32))
.param center: float32[3] (size: 4, cast: variable(ref))
.param resize: float32[3] (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(76)
.usages:
}
Mesh.addVertex(mesh: Mesh, x: float32, y: float32, z: float32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addVertex'
.owner: Mesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(77)
.usages:
}
Mesh.addLine(mesh: Mesh, v1: int32, v2: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addLine'
.owner: Mesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param v1: int32 (size: 4, cast: variable(i32))
.param v2: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(78)
.usages:
}
Mesh.addFace(mesh: Mesh, v1: int32, v2: int32, v3: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addFace'
.owner: Mesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param v1: int32 (size: 4, cast: variable(i32))
.param v2: int32 (size: 4, cast: variable(i32))
.param v3: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(79)
.usages:
}
Mesh.addFace(mesh: Mesh, v1: int32, v2: int32, v3: int32, v4: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'addFace'
.owner: Mesh
.param .result: int32 (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param v1: int32 (size: 4, cast: variable(i32))
.param v2: int32 (size: 4, cast: variable(i32))
.param v3: int32 (size: 4, cast: variable(i32))
.param v4: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(80)
.usages:
}
Mesh.setVertex(mesh: Mesh, idx: int32, x: float32, y: float32, z: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setVertex'
.owner: Mesh
.param .result: bool (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(81)
.usages:
}
Mesh.setNormal(mesh: Mesh, idx: int32, x: float32, y: float32, z: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setNormal'
.owner: Mesh
.param .result: bool (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(82)
.usages:
}
Mesh.setTexture(mesh: Mesh, idx: int32, s: float32, t: float32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTexture'
.owner: Mesh
.param .result: bool (size: 4, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param s: float32 (size: 4, cast: variable(f32))
.param t: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(83)
.usages:
}
Mesh.ambient(mesh: Mesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(84)
.usages:
}
Mesh.diffuse(mesh: Mesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(85)
.usages:
}
Mesh.specular(mesh: Mesh, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(86)
.usages:
}
Mesh.shine(mesh: Mesh, value: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'shine'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param value: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(87)
.usages:
}
Mesh.texture(mesh: Mesh, texture: Image): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'texture'
.owner: Mesh
.param .result: void (size: 0, cast: inline)
.param mesh: Mesh (size: 4, cast: variable(ref))
.param texture: Image (size: 8, cast: variable(val))
.doc: '@builtin'
.value: nfc(88)
.usages:
}
Mesh.keepBuffer: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'keepBuffer'
.owner: Mesh
.doc: '@builtin'
.value: 8
}
Mesh.cullBack: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullBack'
.owner: Mesh
.doc: '@builtin'
.value: 16
.usages:
	cmplGfx/lib/window.ci:377: referenced as `cullBack`
}
Mesh.cullFront: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullFront'
.owner: Mesh
.doc: '@builtin'
.value: 32
}
Mesh.cullMode: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'cullMode'
.owner: Mesh
.doc: '@builtin'
.value: 48
.usages:
	cmplGfx/lib/window.ci:337: referenced as `cullMode`
}
Mesh.drawPlot: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawPlot'
.owner: Mesh
.doc: '@builtin'
.value: 4
}
Mesh.drawWire: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawWire'
.owner: Mesh
.doc: '@builtin'
.value: 2
}
Mesh.drawFill: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawFill'
.owner: Mesh
.doc: '@builtin'
.value: 1
.usages:
	cmplGfx/lib/window.ci:377: referenced as `drawFill`
}
Mesh.drawMode: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawMode'
.owner: Mesh
.doc: '@builtin'
.value: 7
.usages:
	cmplGfx/lib/window.ci:340: referenced as `drawMode`
}
Mesh.useTexture: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useTexture'
.owner: Mesh
.doc: '@builtin'
.value: 64
.usages:
	cmplGfx/lib/window.ci:334: referenced as `useTexture`
}
Mesh.useLights: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'useLights'
.owner: Mesh
.doc: '@builtin'
.value: 128
.usages:
	cmplGfx/lib/window.ci:377: referenced as `useLights`
	cmplGfx/lib/window.ci:316: referenced as `useLights`
}
Mesh.drawBounds: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'drawBounds'
.owner: Mesh
.doc: '@builtin'
.value: 256
.usages:
	cmplGfx/lib/window.ci:319: referenced as `drawBounds`
}
Mesh.vertices: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'vertices'
.owner: Mesh
.doc: '@builtin'
.usages:
	cmplGfx/lib/window.ci:357: referenced as `vertices`
}
Mesh.triangles: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'triangles'
.owner: Mesh
.doc: '@builtin'
.usages:
	cmplGfx/lib/window.ci:359: referenced as `triangles`
}
Mesh.segments: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'segments'
.owner: Mesh
.doc: '@builtin'
}
gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'gradient'
.field Linear: int64 (size: 0, cast: static const i64)
.field Radial: int64 (size: 0, cast: static const i64)
.field Square: int64 (size: 0, cast: static const i64)
.field Spiral: int64 (size: 0, cast: static const i64)
.field Conical: int64 (size: 0, cast: static const i64)
.field MaskLinear: int64 (size: 0, cast: static const i64)
.field MaskRadial: int64 (size: 0, cast: static const i64)
.field MaskSquare: int64 (size: 0, cast: static const i64)
.param .result: void (size: 0, cast: inline)
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param type: int32 (size: 4, cast: variable(i32))
.param repeat: bool (size: 4, cast: variable(bool))
.param colors: uint32[] (size: 8, cast: variable(arr))
.doc: '@builtin'
.value: nfc(119)
.usages:
}
gradient.Linear: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Linear'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.doc: '@builtin'
.value: 0
}
gradient.Radial: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Radial'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.doc: '@builtin'
.value: 1
}
gradient.Square: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Square'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.doc: '@builtin'
.value: 2
}
gradient.Spiral: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Spiral'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.doc: '@builtin'
.value: 4
}
gradient.Conical: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Conical'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.doc: '@builtin'
.value: 3
}
gradient.MaskLinear: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MaskLinear'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.doc: '@builtin'
.value: 16
}
gradient.MaskRadial: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MaskRadial'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.doc: '@builtin'
.value: 17
}
gradient.MaskSquare: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MaskSquare'
.owner: gradient(image: Image, roi: Rect, type: int32, repeat: bool, colors: uint32[]): void
.doc: '@builtin'
.value: 18
}
camera(proj: float32[16], position: float32[4], forward: float32[4], right: float32[4], up: float32[4]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'camera'
.param .result: void (size: 0, cast: inline)
.param proj: float32[16] (size: 4, cast: const variable(ref))
.param position: float32[4] (size: 4, cast: const variable(ref))
.param forward: float32[4] (size: 4, cast: const variable(ref))
.param right: float32[4] (size: 4, cast: const variable(ref))
.param up: float32[4] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(120)
.usages:
	cmplGfx/lib/window.ci:178: referenced as `camera`
}
lights: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'lights'
.field enabled: function (size: 0, cast: static const inline)
.field enable: function (size: 0, cast: static const inline)
.field position: function (size: 0, cast: static const inline)
.field ambient: function (size: 0, cast: static const inline)
.field diffuse: function (size: 0, cast: static const inline)
.field specular: function (size: 0, cast: static const inline)
.field attenuation: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplGfx/lib/window.ci:331: referenced as `lights`
	cmplGfx/lib/window.ci:331: referenced as `lights`
	cmplGfx/lib/window.ci:328: referenced as `lights`
	cmplGfx/lib/window.ci:328: referenced as `lights`
	cmplGfx/lib/window.ci:325: referenced as `lights`
	cmplGfx/lib/window.ci:325: referenced as `lights`
	cmplGfx/lib/window.ci:322: referenced as `lights`
	cmplGfx/lib/window.ci:322: referenced as `lights`
}
lights.enabled(light: int32): bool: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enabled'
.owner: lights
.param .result: bool (size: 4, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(121)
.usages:
	cmplGfx/lib/window.ci:331: referenced as `enabled`
	cmplGfx/lib/window.ci:328: referenced as `enabled`
	cmplGfx/lib/window.ci:325: referenced as `enabled`
	cmplGfx/lib/window.ci:322: referenced as `enabled`
}
lights.enable(light: int32, on: bool): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'enable'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param on: bool (size: 4, cast: variable(bool))
.doc: '@builtin'
.value: nfc(122)
.usages:
	cmplGfx/lib/window.ci:331: referenced as `enable`
	cmplGfx/lib/window.ci:328: referenced as `enable`
	cmplGfx/lib/window.ci:325: referenced as `enable`
	cmplGfx/lib/window.ci:322: referenced as `enable`
}
lights.position(light: int32, x: float32, y: float32, z: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'position'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param z: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(123)
.usages:
}
lights.ambient(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ambient'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(124)
.usages:
}
lights.diffuse(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'diffuse'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(125)
.usages:
}
lights.specular(light: int32, r: float32, g: float32, b: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'specular'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param r: float32 (size: 4, cast: variable(f32))
.param g: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(126)
.usages:
}
lights.attenuation(light: int32, constant: float32, linear: float32, quadratic: float32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'attenuation'
.owner: lights
.param .result: void (size: 0, cast: inline)
.param light: int32 (size: 4, cast: variable(i32))
.param constant: float32 (size: 4, cast: variable(f32))
.param linear: float32 (size: 4, cast: variable(f32))
.param quadratic: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(127)
.usages:
}
Window: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Window'
.field KEY_PRESS: int64 (size: 0, cast: static const i64)
.field KEY_RELEASE: int64 (size: 0, cast: static const i64)
.field MOUSE_WHEEL: int64 (size: 0, cast: static const i64)
.field MOUSE_PRESS: int64 (size: 0, cast: static const i64)
.field MOUSE_MOTION: int64 (size: 0, cast: static const i64)
.field MOUSE_RELEASE: int64 (size: 0, cast: static const i64)
.field FINGER_PRESS: int64 (size: 0, cast: static const i64)
.field FINGER_MOTION: int64 (size: 0, cast: static const i64)
.field FINGER_RELEASE: int64 (size: 0, cast: static const i64)
.field EVENT_TIMEOUT: int64 (size: 0, cast: static const i64)
.field WINDOW_INIT: int64 (size: 0, cast: static const i64)
.field WINDOW_CLOSE: int64 (size: 0, cast: static const i64)
.field WINDOW_ENTER: int64 (size: 0, cast: static const i64)
.field WINDOW_LEAVE: int64 (size: 0, cast: static const i64)
.field KEY_CODE_ESC: int64 (size: 0, cast: static const i64)
.field KEY_CODE_BACK: int64 (size: 0, cast: static const i64)
.field KEY_CODE_TAB: int64 (size: 0, cast: static const i64)
.field KEY_CODE_ENTER: int64 (size: 0, cast: static const i64)
.field KEY_CODE_CAPSLOCK: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PRINT_SCREEN: int64 (size: 0, cast: static const i64)
.field KEY_CODE_SCROLL_LOCK: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PAUSE: int64 (size: 0, cast: static const i64)
.field KEY_CODE_INSERT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_HOME: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PAGE_UP: int64 (size: 0, cast: static const i64)
.field KEY_CODE_DELETE: int64 (size: 0, cast: static const i64)
.field KEY_CODE_END: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PAGE_DOWN: int64 (size: 0, cast: static const i64)
.field KEY_CODE_RIGHT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_LEFT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_DOWN: int64 (size: 0, cast: static const i64)
.field KEY_CODE_UP: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_ALT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_ALT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_GUI: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_GUI: int64 (size: 0, cast: static const i64)
.field KEY_MASK_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_MASK_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_MASK_ALT: int64 (size: 0, cast: static const i64)
.field show: function (size: 0, cast: static const inline)
.field setTitle: function (size: 0, cast: static const inline)
.field quit: function (size: 0, cast: static const inline)
.field font: function (size: 0, cast: static const inline)
.field font: Image (size: 0, cast: static const inline)
.doc: '@builtin'
}
Window.KEY_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_PRESS'
.owner: Window
.doc: '@builtin'
.value: 1
.usages:
	cmplGfx/lib/micro.ui.ci:1209: referenced as `KEY_PRESS`
	cmplGfx/lib/window.ci:260: referenced as `KEY_PRESS`
}
Window.KEY_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_RELEASE'
.owner: Window
.doc: '@builtin'
.value: 2
.usages:
	cmplGfx/lib/micro.ui.ci:1295: referenced as `KEY_RELEASE`
	cmplGfx/lib/micro.ui.ci:1230: referenced as `KEY_RELEASE`
	cmplGfx/lib/window.ci:256: referenced as `KEY_RELEASE`
	cmplGfx/lib/window.ci:103: referenced as `KEY_RELEASE`
	cmplGfx/lib/window.ci:96: referenced as `KEY_RELEASE`
	cmplGfx/lib/window.ci:29: referenced as `KEY_RELEASE`
}
Window.MOUSE_WHEEL: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_WHEEL'
.owner: Window
.doc: '@builtin'
.value: 3
.usages:
	cmplGfx/lib/window.ci:250: referenced as `MOUSE_WHEEL`
}
Window.MOUSE_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_PRESS'
.owner: Window
.doc: '@builtin'
.value: 4
.usages:
	cmplGfx/lib/micro.ui.ci:1328: referenced as `MOUSE_PRESS`
	cmplGfx/lib/micro.ui.ci:1303: referenced as `MOUSE_PRESS`
	cmplGfx/lib/micro.ui.ci:1124: referenced as `MOUSE_PRESS`
	cmplGfx/lib/window.ci:245: referenced as `MOUSE_PRESS`
	cmplGfx/lib/window.ci:33: referenced as `MOUSE_PRESS`
}
Window.MOUSE_MOTION: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_MOTION'
.owner: Window
.doc: '@builtin'
.value: 5
.usages:
	cmplGfx/lib/micro.ui.ci:1324: referenced as `MOUSE_MOTION`
	cmplGfx/lib/micro.ui.ci:1308: referenced as `MOUSE_MOTION`
	cmplGfx/lib/micro.ui.ci:1159: referenced as `MOUSE_MOTION`
	cmplGfx/lib/window.ci:212: referenced as `MOUSE_MOTION`
}
Window.MOUSE_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MOUSE_RELEASE'
.owner: Window
.doc: '@builtin'
.value: 6
.usages:
	cmplGfx/lib/micro.ui.ci:1313: referenced as `MOUSE_RELEASE`
	cmplGfx/lib/micro.ui.ci:1186: referenced as `MOUSE_RELEASE`
	cmplGfx/lib/window.ci:60: referenced as `MOUSE_RELEASE`
	cmplGfx/lib/window.ci:35: referenced as `MOUSE_RELEASE`
	cmplGfx/lib/window.ci:33: referenced as `MOUSE_RELEASE`
}
Window.FINGER_PRESS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'FINGER_PRESS'
.owner: Window
.doc: '@builtin'
.value: 7
.usages:
	cmplGfx/lib/micro.ui.ci:1301: referenced as `FINGER_PRESS`
	cmplGfx/lib/window.ci:245: referenced as `FINGER_PRESS`
}
Window.FINGER_MOTION: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'FINGER_MOTION'
.owner: Window
.doc: '@builtin'
.value: 8
.usages:
	cmplGfx/lib/micro.ui.ci:1306: referenced as `FINGER_MOTION`
	cmplGfx/lib/window.ci:217: referenced as `FINGER_MOTION`
	cmplGfx/lib/window.ci:212: referenced as `FINGER_MOTION`
}
Window.FINGER_RELEASE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'FINGER_RELEASE'
.owner: Window
.doc: '@builtin'
.value: 9
.usages:
	cmplGfx/lib/micro.ui.ci:1311: referenced as `FINGER_RELEASE`
}
Window.EVENT_TIMEOUT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'EVENT_TIMEOUT'
.owner: Window
.doc: '@builtin'
.value: 10
.usages:
	cmplGfx/lib/micro.ui.ci:1247: referenced as `EVENT_TIMEOUT`
}
Window.WINDOW_INIT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_INIT'
.owner: Window
.doc: '@builtin'
.value: 100
.usages:
	cmplGfx/lib/micro.ui.ci:1106: referenced as `WINDOW_INIT`
	cmplGfx/lib/window.ci:344: referenced as `WINDOW_INIT`
	cmplGfx/lib/window.ci:262: referenced as `WINDOW_INIT`
}
Window.WINDOW_CLOSE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_CLOSE'
.owner: Window
.doc: '@builtin'
.value: 102
.usages:
	cmplGfx/lib/micro.ui.ci:1109: referenced as `WINDOW_CLOSE`
	cmplGfx/lib/window.ci:100: referenced as `WINDOW_CLOSE`
}
Window.WINDOW_ENTER: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_ENTER'
.owner: Window
.doc: '@builtin'
.value: 103
.usages:
	cmplGfx/lib/micro.ui.ci:1115: referenced as `WINDOW_ENTER`
}
Window.WINDOW_LEAVE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WINDOW_LEAVE'
.owner: Window
.doc: '@builtin'
.value: 104
.usages:
	cmplGfx/lib/micro.ui.ci:1119: referenced as `WINDOW_LEAVE`
}
Window.KEY_CODE_ESC: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_ESC'
.owner: Window
.doc: '@builtin'
.value: 65307
.usages:
	cmplGfx/lib/micro.ui.ci:1295: referenced as `KEY_CODE_ESC`
	cmplGfx/lib/window.ci:256: referenced as `KEY_CODE_ESC`
	cmplGfx/lib/window.ci:96: referenced as `KEY_CODE_ESC`
	cmplGfx/lib/window.ci:29: referenced as `KEY_CODE_ESC`
}
Window.KEY_CODE_BACK: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_BACK'
.owner: Window
.doc: '@builtin'
.value: 65288
.usages:
	cmplGfx/lib/micro.ui.ci:942: referenced as `KEY_CODE_BACK`
	cmplGfx/lib/micro.ui.core.ci:290: referenced as `KEY_CODE_BACK`
}
Window.KEY_CODE_TAB: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_TAB'
.owner: Window
.doc: '@builtin'
.value: 65289
.usages:
	cmplGfx/lib/micro.ui.core.ci:1204: referenced as `KEY_CODE_TAB`
	cmplGfx/lib/window.ci:339: referenced as `KEY_CODE_TAB`
	cmplGfx/lib/window.ci:113: referenced as `KEY_CODE_TAB`
}
Window.KEY_CODE_ENTER: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_ENTER'
.owner: Window
.doc: '@builtin'
.value: 65293
.usages:
	cmplGfx/lib/micro.ui.core.ci:1204: referenced as `KEY_CODE_ENTER`
	cmplGfx/lib/window.ci:261: referenced as `KEY_CODE_ENTER`
}
Window.KEY_CODE_CAPSLOCK: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_CAPSLOCK'
.owner: Window
.doc: '@builtin'
.value: 65509
}
Window.KEY_CODE_PRINT_SCREEN: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_PRINT_SCREEN'
.owner: Window
.doc: '@builtin'
.value: 65377
}
Window.KEY_CODE_SCROLL_LOCK: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_SCROLL_LOCK'
.owner: Window
.doc: '@builtin'
.value: 65300
}
Window.KEY_CODE_PAUSE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_PAUSE'
.owner: Window
.doc: '@builtin'
.value: 65299
}
Window.KEY_CODE_INSERT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_INSERT'
.owner: Window
.doc: '@builtin'
.value: 65379
}
Window.KEY_CODE_HOME: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_HOME'
.owner: Window
.doc: '@builtin'
.value: 65360
}
Window.KEY_CODE_PAGE_UP: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_PAGE_UP'
.owner: Window
.doc: '@builtin'
.value: 65365
}
Window.KEY_CODE_DELETE: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_DELETE'
.owner: Window
.doc: '@builtin'
.value: 65535
}
Window.KEY_CODE_END: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_END'
.owner: Window
.doc: '@builtin'
.value: 65367
}
Window.KEY_CODE_PAGE_DOWN: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_PAGE_DOWN'
.owner: Window
.doc: '@builtin'
.value: 65366
}
Window.KEY_CODE_RIGHT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_RIGHT'
.owner: Window
.doc: '@builtin'
.value: 65363
.usages:
	cmplGfx/lib/window.ci:308: referenced as `KEY_CODE_RIGHT`
}
Window.KEY_CODE_LEFT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_LEFT'
.owner: Window
.doc: '@builtin'
.value: 65361
.usages:
	cmplGfx/lib/window.ci:302: referenced as `KEY_CODE_LEFT`
}
Window.KEY_CODE_DOWN: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_DOWN'
.owner: Window
.doc: '@builtin'
.value: 65364
.usages:
	cmplGfx/lib/window.ci:296: referenced as `KEY_CODE_DOWN`
}
Window.KEY_CODE_UP: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_UP'
.owner: Window
.doc: '@builtin'
.value: 65362
.usages:
	cmplGfx/lib/window.ci:290: referenced as `KEY_CODE_UP`
}
Window.KEY_CODE_L_SHIFT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_L_SHIFT'
.owner: Window
.doc: '@builtin'
.value: 65505
}
Window.KEY_CODE_R_SHIFT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_R_SHIFT'
.owner: Window
.doc: '@builtin'
.value: 65506
}
Window.KEY_CODE_L_CTRL: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_L_CTRL'
.owner: Window
.doc: '@builtin'
.value: 65507
}
Window.KEY_CODE_R_CTRL: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_R_CTRL'
.owner: Window
.doc: '@builtin'
.value: 65508
}
Window.KEY_CODE_L_ALT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_L_ALT'
.owner: Window
.doc: '@builtin'
.value: 65513
}
Window.KEY_CODE_R_ALT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_R_ALT'
.owner: Window
.doc: '@builtin'
.value: 65514
}
Window.KEY_CODE_L_GUI: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_L_GUI'
.owner: Window
.doc: '@builtin'
.value: 65515
}
Window.KEY_CODE_R_GUI: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_CODE_R_GUI'
.owner: Window
.doc: '@builtin'
.value: 65516
}
Window.KEY_MASK_SHIFT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_SHIFT'
.owner: Window
.doc: '@builtin'
.value: 1
.usages:
	cmplGfx/lib/micro.ui.ci:1231: referenced as `KEY_MASK_SHIFT`
	cmplGfx/lib/micro.ui.ci:1210: referenced as `KEY_MASK_SHIFT`
	cmplGfx/lib/window.ci:310: referenced as `KEY_MASK_SHIFT`
	cmplGfx/lib/window.ci:304: referenced as `KEY_MASK_SHIFT`
	cmplGfx/lib/window.ci:298: referenced as `KEY_MASK_SHIFT`
	cmplGfx/lib/window.ci:292: referenced as `KEY_MASK_SHIFT`
	cmplGfx/lib/window.ci:285: referenced as `KEY_MASK_SHIFT`
	cmplGfx/lib/window.ci:279: referenced as `KEY_MASK_SHIFT`
	cmplGfx/lib/window.ci:273: referenced as `KEY_MASK_SHIFT`
	cmplGfx/lib/window.ci:267: referenced as `KEY_MASK_SHIFT`
}
Window.KEY_MASK_CTRL: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_CTRL'
.owner: Window
.doc: '@builtin'
.value: 2
.usages:
	cmplGfx/lib/micro.ui.ci:1232: referenced as `KEY_MASK_CTRL`
	cmplGfx/lib/micro.ui.ci:1211: referenced as `KEY_MASK_CTRL`
}
Window.KEY_MASK_ALT: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'KEY_MASK_ALT'
.owner: Window
.doc: '@builtin'
.value: 4
.usages:
	cmplGfx/lib/micro.ui.ci:1233: referenced as `KEY_MASK_ALT`
	cmplGfx/lib/micro.ui.ci:1212: referenced as `KEY_MASK_ALT`
}
Window.show(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'show'
.owner: Window
.param .result: void (size: 0, cast: inline)
.param surf: Image (size: 8, cast: variable(val))
.param closure: pointer (size: 4, cast: variable(ref))
.param onEvent: function (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(128)
.usages:
	cmplGfx/lib/micro.ui.ci:1343: referenced as `show`
	cmplGfx/lib/window.ci:383: referenced as `show`
	cmplGfx/lib/window.ci:154: referenced as `show`
	cmplGfx/lib/window.ci:61: referenced as `show`
	cmplGfx/lib/window.ci:16: referenced as `show`
	cmplGfx/lib/window.ci:11: referenced as `show`
}
Window.setTitle(title: char[*]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'setTitle'
.owner: Window
.param .result: void (size: 0, cast: inline)
.param title: char[*] (size: 4, cast: const variable(ref))
.doc: '@builtin'
.value: nfc(129)
.usages:
	cmplGfx/lib/window.ci:364: referenced as `setTitle`
	cmplGfx/lib/window.ci:129: referenced as `setTitle`
	cmplGfx/lib/window.ci:110: referenced as `setTitle`
}
Window.quit(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'quit'
.owner: Window
.param .result: int32 (size: 4, cast: inline)
.doc: '@builtin'
.value: nfc(130)
.usages:
	cmplGfx/lib/micro.ui.ci:1297: referenced as `quit`
	cmplGfx/lib/window.ci:258: referenced as `quit`
	cmplGfx/lib/window.ci:101: referenced as `quit`
	cmplGfx/lib/window.ci:98: referenced as `quit`
	cmplGfx/lib/window.ci:31: referenced as `quit`
}
Window.font(height: int32): Image: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'font'
.owner: Window
.param .result: Image (size: 8, cast: inline)
.param height: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(131)
.usages:
}
Window.font: Image {
.kind: static const inline
.base: `Image`
.size: 0
.name: 'font'
.owner: Window
.doc: '@builtin'
.value: nfc(132)
.usages:
	cmplGfx/lib/micro.ui.core.ci:33: referenced as `font`
}
empty(rectangle: Rect): bool: function {
.kind: static function
.base: `function`
.size: 44
.name: 'empty'
.file: 'cmplGfx/lib/rect.ci:2'
.param .result: bool (size: 4, cast: variable(bool))
.param rectangle: Rect (size: 4, cast: const variable(ref))
.doc: 'Checks whether the given `rectangle` is empty or not.'
.value: {
	return .result := rectangle.x0 >= rectangle.x1 || rectangle.y0 >= rectangle.y1;
}
.instructions: (44 bytes)
	cmplGfx/lib/rect.ci:4: (44 bytes): return .result := rectangle.x0 >= rectangle.x1 || rectangle.y0 >= rectangle.y1;
	<empty>  : dup.x32 sp(1)
	<empty+?>: load.i32
	<empty+?>: dup.x32 sp(2)
	<empty+?>: inc.i32(+8)
	<empty+?>: load.i32
	<empty+?>: clt.i32
	<empty+?>: not.b32
	<empty+?>: dup.x32 sp(0)
	<empty+?>: jnz +24
	<empty+?>: inc.sp(-4)
	<empty+?>: dup.x32 sp(1)
	<empty+?>: inc.i32(+4)
	<empty+?>: load.i32
	<empty+?>: dup.x32 sp(2)
	<empty+?>: inc.i32(+12)
	<empty+?>: load.i32
	<empty+?>: clt.i32
	<empty+?>: not.b32
	<empty+?>: load.sp(+12)
	<empty+?>: store.i8
	<empty+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:1136: referenced as `empty`
	cmplGfx/lib/micro.ui.core.ci:1121: referenced as `empty`
	cmplGfx/lib/micro.ui.core.ci:1033: referenced as `empty`
	cmplGfx/lib/micro.ui.core.ci:1016: referenced as `empty`
	cmplGfx/lib/micro.ui.core.ci:935: referenced as `empty`
	cmplGfx/lib/micro.ui.core.ci:901: referenced as `empty`
	cmplGfx/lib/micro.ui.core.ci:850: referenced as `empty`
	cmplGfx/lib/micro.ui.core.ci:816: referenced as `empty`
	cmplGfx/lib/image.draw.oval.ci:17: referenced as `empty`
	cmplGfx/lib/image.draw.oval.ci:9: referenced as `empty`
	cmplGfx/lib/image.draw.rrect.ci:132: referenced as `empty`
	cmplGfx/lib/image.draw.rect.ci:74: referenced as `empty`
	cmplGfx/lib/image.draw.rect.ci:66: referenced as `empty`
	cmplGfx/lib/image.ci:50: referenced as `empty`
}
contains(rect: Rect, x: int32, y: int32): bool: function {
.kind: static function
.base: `function`
.size: 74
.name: 'contains'
.file: 'cmplGfx/lib/rect.ci:8'
.param .result: bool (size: 4, cast: variable(bool))
.param rect: Rect (size: 4, cast: const variable(ref))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'Checks whether the given `rectangle` contains the point (`x`, `y`).'
.value: {
	return .result := x >= rect.x0 && x < rect.x1 && y >= rect.y0 && y < rect.y1;
}
.instructions: (74 bytes)
	cmplGfx/lib/rect.ci:9: (74 bytes): return .result := x >= rect.x0 && x < rect.x1 && y >= rect.y0 && y < rect.y1;
	<contains>  : dup.x32 sp(2)
	<contains+?>: dup.x32 sp(4)
	<contains+?>: load.i32
	<contains+?>: clt.i32
	<contains+?>: not.b32
	<contains+?>: dup.x32 sp(0)
	<contains+?>: jz +18
	<contains+?>: inc.sp(-4)
	<contains+?>: dup.x32 sp(2)
	<contains+?>: dup.x32 sp(4)
	<contains+?>: inc.i32(+8)
	<contains+?>: load.i32
	<contains+?>: clt.i32
	<contains+?>: dup.x32 sp(0)
	<contains+?>: jz +19
	<contains+?>: inc.sp(-4)
	<contains+?>: dup.x32 sp(1)
	<contains+?>: dup.x32 sp(4)
	<contains+?>: inc.i32(+4)
	<contains+?>: load.i32
	<contains+?>: clt.i32
	<contains+?>: not.b32
	<contains+?>: dup.x32 sp(0)
	<contains+?>: jz +18
	<contains+?>: inc.sp(-4)
	<contains+?>: dup.x32 sp(1)
	<contains+?>: dup.x32 sp(4)
	<contains+?>: inc.i32(+12)
	<contains+?>: load.i32
	<contains+?>: clt.i32
	<contains+?>: load.sp(+20)
	<contains+?>: store.i8
	<contains+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:647: referenced as `contains`
}
width(rectangle: Rect): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'width'
.file: 'cmplGfx/lib/rect.ci:13'
.param .result: int32 (size: 4, cast: i32)
.param rectangle: Rect (size: 4, cast: const variable(ref))
.doc: 'Computes the width of the given `rectangle`.'
.value: rectangle.x1 - rectangle.x0
.usages:
	cmplGfx/lib/micro.ui.ci:1351: referenced as `width`
	cmplGfx/lib/micro.ui.ci:955: referenced as `width`
	cmplGfx/lib/micro.ui.ci:581: referenced as `width`
	cmplGfx/lib/micro.ui.ci:423: referenced as `width`
	cmplGfx/lib/micro.ui.ci:371: referenced as `width`
	cmplGfx/lib/micro.ui.ci:307: referenced as `width`
	cmplGfx/lib/micro.ui.ci:293: referenced as `width`
	cmplGfx/lib/micro.ui.ci:293: referenced as `width`
	cmplGfx/lib/micro.ui.ci:276: referenced as `width`
	cmplGfx/lib/micro.ui.ci:257: referenced as `width`
	cmplGfx/lib/micro.ui.ci:136: referenced as `width`
	cmplGfx/lib/micro.ui.ci:134: referenced as `width`
	cmplGfx/lib/micro.ui.ci:129: referenced as `width`
	cmplGfx/lib/micro.ui.ci:128: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:1009: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:944: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:926: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:919: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:918: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:912: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:911: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:909: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:908: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:841: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:805: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:766: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:333: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:86: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:86: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:83: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:83: referenced as `width`
	cmplGfx/lib/image.transform.ci:24: referenced as `width`
	cmplGfx/lib/image.transform.ci:24: referenced as `width`
	cmplGfx/lib/image.blend.ci:152: referenced as `width`
	cmplGfx/lib/image.blend.ci:144: referenced as `width`
}
width(rectangle: Rect, width: int32): void: function {
.kind: static function
.base: `function`
.size: 14
.name: 'width'
.file: 'cmplGfx/lib/rect.ci:15'
.param .result: void (size: 0, cast: variable(void))
.param rectangle: Rect (size: 4, cast: variable(ref))
.param width: int32 (size: 4, cast: variable(i32))
.doc: 'Sets the width of the given `rectangle`.'
.value: {
	rectangle.x1 := rectangle.x0 + width;
}
.instructions: (14 bytes)
	cmplGfx/lib/rect.ci:16: (13 bytes): rectangle.x1 := rectangle.x0 + width;
	<width>  : dup.x32 sp(2)
	<width+?>: load.i32
	<width+?>: dup.x32 sp(2)
	<width+?>: add.i32
	<width+?>: dup.x32 sp(3)
	<width+?>: inc.i32(+8)
	<width+?>: store.i32
	<width+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:408: referenced as `width`
	cmplGfx/lib/micro.ui.ci:293: referenced as `width`
	cmplGfx/lib/micro.ui.ci:136: referenced as `width`
	cmplGfx/lib/micro.ui.ci:134: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:952: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:867: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:796: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:334: referenced as `width`
}
height(rectangle: Rect): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'height'
.file: 'cmplGfx/lib/rect.ci:20'
.param .result: int32 (size: 4, cast: i32)
.param rectangle: Rect (size: 4, cast: const variable(ref))
.doc: 'Computes the height of the given `rectangle`.'
.value: rectangle.y1 - rectangle.y0
.usages:
	cmplGfx/lib/micro.ui.ci:1351: referenced as `height`
	cmplGfx/lib/micro.ui.ci:956: referenced as `height`
	cmplGfx/lib/micro.ui.ci:580: referenced as `height`
	cmplGfx/lib/micro.ui.ci:424: referenced as `height`
	cmplGfx/lib/micro.ui.ci:397: referenced as `height`
	cmplGfx/lib/micro.ui.ci:167: referenced as `height`
	cmplGfx/lib/micro.ui.ci:165: referenced as `height`
	cmplGfx/lib/micro.ui.ci:162: referenced as `height`
	cmplGfx/lib/micro.ui.ci:148: referenced as `height`
	cmplGfx/lib/micro.ui.ci:134: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:1010: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:927: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:890: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:859: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:842: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:834: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:833: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:824: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:823: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:767: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:337: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:101: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:101: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:98: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:98: referenced as `height`
	cmplGfx/lib/image.transform.ci:25: referenced as `height`
	cmplGfx/lib/image.transform.ci:25: referenced as `height`
	cmplGfx/lib/image.blend.ci:151: referenced as `height`
	cmplGfx/lib/image.blend.ci:147: referenced as `height`
}
height(rectangle: Rect, height: int32): void: function {
.kind: static function
.base: `function`
.size: 18
.name: 'height'
.file: 'cmplGfx/lib/rect.ci:22'
.param .result: void (size: 0, cast: variable(void))
.param rectangle: Rect (size: 4, cast: variable(ref))
.param height: int32 (size: 4, cast: variable(i32))
.doc: 'Sets the height of the given `rectangle`.'
.value: {
	rectangle.y1 := rectangle.y0 + height;
}
.instructions: (18 bytes)
	cmplGfx/lib/rect.ci:23: (17 bytes): rectangle.y1 := rectangle.y0 + height;
	<height>  : dup.x32 sp(2)
	<height+?>: inc.i32(+4)
	<height+?>: load.i32
	<height+?>: dup.x32 sp(2)
	<height+?>: add.i32
	<height+?>: dup.x32 sp(3)
	<height+?>: inc.i32(+12)
	<height+?>: store.i32
	<height+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:411: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:953: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:868: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:797: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:338: referenced as `height`
}
setSize(rectangle: Rect, width: int32, height: int32): void: function {
.kind: static function
.base: `function`
.size: 31
.name: 'setSize'
.file: 'cmplGfx/lib/rect.ci:27'
.param .result: void (size: 0, cast: variable(void))
.param rectangle: Rect (size: 4, cast: variable(ref))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.doc: 'Sets the width and height of the given `rectangle`.'
.value: {
	rectangle.x1 := rectangle.x0 + width;
	rectangle.y1 := rectangle.y0 + height;
}
.instructions: (31 bytes)
	cmplGfx/lib/rect.ci:28: (13 bytes): rectangle.x1 := rectangle.x0 + width;
	<setSize>  : dup.x32 sp(3)
	<setSize+?>: load.i32
	<setSize+?>: dup.x32 sp(3)
	<setSize+?>: add.i32
	<setSize+?>: dup.x32 sp(4)
	<setSize+?>: inc.i32(+8)
	<setSize+?>: store.i32
	cmplGfx/lib/rect.ci:29: (17 bytes): rectangle.y1 := rectangle.y0 + height;
	<setSize+?>: dup.x32 sp(3)
	<setSize+?>: inc.i32(+4)
	<setSize+?>: load.i32
	<setSize+?>: dup.x32 sp(2)
	<setSize+?>: add.i32
	<setSize+?>: dup.x32 sp(4)
	<setSize+?>: inc.i32(+12)
	<setSize+?>: store.i32
	<setSize+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:1284: referenced as `setSize`
	cmplGfx/lib/micro.ui.ci:645: referenced as `setSize`
	cmplGfx/lib/micro.ui.ci:617: referenced as `setSize`
}
positionX(rectangle: Rect, x: int32): void: function {
.kind: static function
.base: `function`
.size: 27
.name: 'positionX'
.file: 'cmplGfx/lib/rect.ci:33'
.param .result: void (size: 0, cast: variable(void))
.param rectangle: Rect (size: 4, cast: variable(ref))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'Sets the x position of the given `rectangle`.'
.value: {
	rectangle.x1 := x + rectangle.x1 - rectangle.x0;
	rectangle.x0 := x;
}
.instructions: (27 bytes)
	cmplGfx/lib/rect.ci:34: (21 bytes): rectangle.x1 := x + rectangle.x1 - rectangle.x0;
	<positionX>  : dup.x32 sp(1)
	<positionX+?>: dup.x32 sp(3)
	<positionX+?>: inc.i32(+8)
	<positionX+?>: load.i32
	<positionX+?>: add.i32
	<positionX+?>: dup.x32 sp(3)
	<positionX+?>: load.i32
	<positionX+?>: sub.i32
	<positionX+?>: dup.x32 sp(3)
	<positionX+?>: inc.i32(+8)
	<positionX+?>: store.i32
	cmplGfx/lib/rect.ci:35: (5 bytes): rectangle.x0 := x;
	<positionX+?>: dup.x32 sp(1)
	<positionX+?>: dup.x32 sp(3)
	<positionX+?>: store.i32
	<positionX+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:855: referenced as `positionX`
	cmplGfx/lib/micro.ui.core.ci:89: referenced as `positionX`
	cmplGfx/lib/micro.ui.core.ci:86: referenced as `positionX`
	cmplGfx/lib/micro.ui.core.ci:83: referenced as `positionX`
	cmplGfx/lib/image.blend.ci:26: referenced as `positionX`
	cmplGfx/lib/rect.ci:45: referenced as `positionX`
}
positionY(rectangle: Rect, y: int32): void: function {
.kind: static function
.base: `function`
.size: 35
.name: 'positionY'
.file: 'cmplGfx/lib/rect.ci:38'
.param .result: void (size: 0, cast: variable(void))
.param rectangle: Rect (size: 4, cast: variable(ref))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'Sets the y position of the given `rectangle`.'
.value: {
	rectangle.y1 := y + rectangle.y1 - rectangle.y0;
	rectangle.y0 := y;
}
.instructions: (35 bytes)
	cmplGfx/lib/rect.ci:39: (25 bytes): rectangle.y1 := y + rectangle.y1 - rectangle.y0;
	<positionY>  : dup.x32 sp(1)
	<positionY+?>: dup.x32 sp(3)
	<positionY+?>: inc.i32(+12)
	<positionY+?>: load.i32
	<positionY+?>: add.i32
	<positionY+?>: dup.x32 sp(3)
	<positionY+?>: inc.i32(+4)
	<positionY+?>: load.i32
	<positionY+?>: sub.i32
	<positionY+?>: dup.x32 sp(3)
	<positionY+?>: inc.i32(+12)
	<positionY+?>: store.i32
	cmplGfx/lib/rect.ci:40: (9 bytes): rectangle.y0 := y;
	<positionY+?>: dup.x32 sp(1)
	<positionY+?>: dup.x32 sp(3)
	<positionY+?>: inc.i32(+4)
	<positionY+?>: store.i32
	<positionY+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:940: referenced as `positionY`
	cmplGfx/lib/micro.ui.core.ci:104: referenced as `positionY`
	cmplGfx/lib/micro.ui.core.ci:101: referenced as `positionY`
	cmplGfx/lib/micro.ui.core.ci:98: referenced as `positionY`
	cmplGfx/lib/image.blend.ci:27: referenced as `positionY`
	cmplGfx/lib/rect.ci:46: referenced as `positionY`
}
position(rectangle: Rect, x: int32, y: int32): void: function {
.kind: static function
.base: `function`
.size: 29
.name: 'position'
.file: 'cmplGfx/lib/rect.ci:44'
.param .result: void (size: 0, cast: variable(void))
.param rectangle: Rect (size: 4, cast: variable(ref))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'Sets the x and y position of the given `rectangle`.'
.value: {
	positionX(rectangle, x);
	positionY(rectangle, y);
}
.instructions: (29 bytes)
	cmplGfx/lib/rect.ci:45: (14 bytes): positionX(rectangle, x);
	<position>  : dup.x32 sp(3)
	<position+?>: dup.x32 sp(3)
	<position+?>: load.ref <?> ;positionX(rectangle: Rect, x: int32): void
	<position+?>: call
	<position+?>: inc.sp(-8)
	cmplGfx/lib/rect.ci:46: (14 bytes): positionY(rectangle, y);
	<position+?>: dup.x32 sp(3)
	<position+?>: dup.x32 sp(2)
	<position+?>: load.ref <?> ;positionY(rectangle: Rect, y: int32): void
	<position+?>: call
	<position+?>: inc.sp(-8)
	<position+?>: ret
.usages:
}
adjust(rect: Rect, dx0: int32, dy0: int32, dx1: int32, dy1: int32): void: function {
.kind: static function
.base: `function`
.size: 61
.name: 'adjust'
.file: 'cmplGfx/lib/rect.ci:50'
.param .result: void (size: 0, cast: variable(void))
.param rect: Rect (size: 4, cast: variable(ref))
.param dx0: int32 (size: 4, cast: variable(i32))
.param dy0: int32 (size: 4, cast: variable(i32))
.param dx1: int32 (size: 4, cast: variable(i32))
.param dy1: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	rect.x0 := rect.x0 + dx0;
	rect.y0 := rect.y0 + dy0;
	rect.x1 := rect.x1 + dx1;
	rect.y1 := rect.y1 + dy1;
}
.instructions: (61 bytes)
	cmplGfx/lib/rect.ci:51: (9 bytes): rect.x0 := rect.x0 + dx0;
	<adjust>  : dup.x32 sp(5)
	<adjust+?>: load.i32
	<adjust+?>: dup.x32 sp(5)
	<adjust+?>: add.i32
	<adjust+?>: dup.x32 sp(6)
	<adjust+?>: store.i32
	cmplGfx/lib/rect.ci:52: (17 bytes): rect.y0 := rect.y0 + dy0;
	<adjust+?>: dup.x32 sp(5)
	<adjust+?>: inc.i32(+4)
	<adjust+?>: load.i32
	<adjust+?>: dup.x32 sp(4)
	<adjust+?>: add.i32
	<adjust+?>: dup.x32 sp(6)
	<adjust+?>: inc.i32(+4)
	<adjust+?>: store.i32
	cmplGfx/lib/rect.ci:53: (17 bytes): rect.x1 := rect.x1 + dx1;
	<adjust+?>: dup.x32 sp(5)
	<adjust+?>: inc.i32(+8)
	<adjust+?>: load.i32
	<adjust+?>: dup.x32 sp(3)
	<adjust+?>: add.i32
	<adjust+?>: dup.x32 sp(6)
	<adjust+?>: inc.i32(+8)
	<adjust+?>: store.i32
	cmplGfx/lib/rect.ci:54: (17 bytes): rect.y1 := rect.y1 + dy1;
	<adjust+?>: dup.x32 sp(5)
	<adjust+?>: inc.i32(+12)
	<adjust+?>: load.i32
	<adjust+?>: dup.x32 sp(2)
	<adjust+?>: add.i32
	<adjust+?>: dup.x32 sp(6)
	<adjust+?>: inc.i32(+12)
	<adjust+?>: store.i32
	<adjust+?>: ret
.usages:
	cmplGfx/lib/rect.ci:66: referenced as `adjust`
}
padded(rect: Rect, padding: int32): void: function {
.kind: static function
.base: `function`
.size: 61
.name: 'padded'
.file: 'cmplGfx/lib/rect.ci:58'
.param .result: void (size: 0, cast: variable(void))
.param rect: Rect (size: 4, cast: variable(ref))
.param padding: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	rect.x0 := rect.x0 - padding;
	rect.y0 := rect.y0 - padding;
	rect.x1 := rect.x1 + padding;
	rect.y1 := rect.y1 + padding;
}
.instructions: (61 bytes)
	cmplGfx/lib/rect.ci:59: (9 bytes): rect.x0 := rect.x0 - padding;
	<padded>  : dup.x32 sp(2)
	<padded+?>: load.i32
	<padded+?>: dup.x32 sp(2)
	<padded+?>: sub.i32
	<padded+?>: dup.x32 sp(3)
	<padded+?>: store.i32
	cmplGfx/lib/rect.ci:60: (17 bytes): rect.y0 := rect.y0 - padding;
	<padded+?>: dup.x32 sp(2)
	<padded+?>: inc.i32(+4)
	<padded+?>: load.i32
	<padded+?>: dup.x32 sp(2)
	<padded+?>: sub.i32
	<padded+?>: dup.x32 sp(3)
	<padded+?>: inc.i32(+4)
	<padded+?>: store.i32
	cmplGfx/lib/rect.ci:61: (17 bytes): rect.x1 := rect.x1 + padding;
	<padded+?>: dup.x32 sp(2)
	<padded+?>: inc.i32(+8)
	<padded+?>: load.i32
	<padded+?>: dup.x32 sp(2)
	<padded+?>: add.i32
	<padded+?>: dup.x32 sp(3)
	<padded+?>: inc.i32(+8)
	<padded+?>: store.i32
	cmplGfx/lib/rect.ci:62: (17 bytes): rect.y1 := rect.y1 + padding;
	<padded+?>: dup.x32 sp(2)
	<padded+?>: inc.i32(+12)
	<padded+?>: load.i32
	<padded+?>: dup.x32 sp(2)
	<padded+?>: add.i32
	<padded+?>: dup.x32 sp(3)
	<padded+?>: inc.i32(+12)
	<padded+?>: store.i32
	<padded+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:170: referenced as `padded`
	cmplGfx/lib/micro.ui.ci:154: referenced as `padded`
	cmplGfx/lib/micro.ui.core.ci:120: referenced as `padded`
	cmplGfx/lib/micro.ui.core.ci:115: referenced as `padded`
}
translate(rectangle: Rect, dx: int32, dy: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'translate'
.file: 'cmplGfx/lib/rect.ci:66'
.param .result: void (size: 0, cast: void)
.param rectangle: Rect (size: 4, cast: ref)
.param dx: int32 (size: 4, cast: variable(i32))
.param dy: int32 (size: 4, cast: variable(i32))
.doc: 'Moves the given `rectangle` by `dx` and `dy`.'
.value: adjust(rectangle, dx, dy, dx, dy)
.usages:
}
translateX(rectangle: Rect, dx: int32): void: function {
.kind: static function
.base: `function`
.size: 27
.name: 'translateX'
.file: 'cmplGfx/lib/rect.ci:68'
.param .result: void (size: 0, cast: variable(void))
.param rectangle: Rect (size: 4, cast: variable(ref))
.param dx: int32 (size: 4, cast: variable(i32))
.doc: 'Moves the given `rectangle` horizontally by `dx`.'
.value: {
	rectangle.x0 := rectangle.x0 + dx;
	rectangle.x1 := rectangle.x1 + dx;
}
.instructions: (27 bytes)
	cmplGfx/lib/rect.ci:69: (9 bytes): rectangle.x0 := rectangle.x0 + dx;
	<translateX>  : dup.x32 sp(2)
	<translateX+?>: load.i32
	<translateX+?>: dup.x32 sp(2)
	<translateX+?>: add.i32
	<translateX+?>: dup.x32 sp(3)
	<translateX+?>: store.i32
	cmplGfx/lib/rect.ci:70: (17 bytes): rectangle.x1 := rectangle.x1 + dx;
	<translateX+?>: dup.x32 sp(2)
	<translateX+?>: inc.i32(+8)
	<translateX+?>: load.i32
	<translateX+?>: dup.x32 sp(2)
	<translateX+?>: add.i32
	<translateX+?>: dup.x32 sp(3)
	<translateX+?>: inc.i32(+8)
	<translateX+?>: store.i32
	<translateX+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:941: referenced as `translateX`
	cmplGfx/lib/micro.ui.core.ci:931: referenced as `translateX`
	cmplGfx/lib/micro.ui.core.ci:885: referenced as `translateX`
}
translateY(rectangle: Rect, dy: int32): void: function {
.kind: static function
.base: `function`
.size: 35
.name: 'translateY'
.file: 'cmplGfx/lib/rect.ci:73'
.param .result: void (size: 0, cast: variable(void))
.param rectangle: Rect (size: 4, cast: variable(ref))
.param dy: int32 (size: 4, cast: variable(i32))
.doc: 'Moves the given `rectangle` vertically by `dy`.'
.value: {
	rectangle.y0 := rectangle.y0 + dy;
	rectangle.y1 := rectangle.y1 + dy;
}
.instructions: (35 bytes)
	cmplGfx/lib/rect.ci:74: (17 bytes): rectangle.y0 := rectangle.y0 + dy;
	<translateY>  : dup.x32 sp(2)
	<translateY+?>: inc.i32(+4)
	<translateY+?>: load.i32
	<translateY+?>: dup.x32 sp(2)
	<translateY+?>: add.i32
	<translateY+?>: dup.x32 sp(3)
	<translateY+?>: inc.i32(+4)
	<translateY+?>: store.i32
	cmplGfx/lib/rect.ci:75: (17 bytes): rectangle.y1 := rectangle.y1 + dy;
	<translateY+?>: dup.x32 sp(2)
	<translateY+?>: inc.i32(+12)
	<translateY+?>: load.i32
	<translateY+?>: dup.x32 sp(2)
	<translateY+?>: add.i32
	<translateY+?>: dup.x32 sp(3)
	<translateY+?>: inc.i32(+12)
	<translateY+?>: store.i32
	<translateY+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:970: referenced as `translateY`
	cmplGfx/lib/micro.ui.core.ci:856: referenced as `translateY`
	cmplGfx/lib/micro.ui.core.ci:846: referenced as `translateY`
}
argb: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:2'
.field v: uint32 (size: 4, cast: variable(u32))
.field <?>: argb.<?> (size: 4, cast: variable(val))
.field b: uint8 (size: 0, cast: inline)
.field g: uint8 (size: 0, cast: inline)
.field r: uint8 (size: 0, cast: inline)
.field a: uint8 (size: 0, cast: inline)
.doc: 'an 32 bit argb color'
.usages:
	cmplGfx/lib/micro.ui.ci:632: referenced as `argb`
	cmplGfx/lib/micro.ui.ci:467: referenced as `argb`
	cmplGfx/lib/micro.ui.ci:457: referenced as `argb`
	cmplGfx/lib/micro.ui.ci:434: referenced as `argb`
	cmplGfx/lib/micro.ui.ci:338: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:139: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:139: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:24: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:23: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:21: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:19: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:17: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:15: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:13: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:11: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:9: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:6: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:4: referenced as `argb`
	cmplGfx/lib/color.matrix.ci:37: referenced as `argb`
	cmplGfx/lib/color.lookup.ci:61: referenced as `argb`
	cmplGfx/lib/color.lookup.ci:33: referenced as `argb`
	cmplGfx/lib/color.lookup.ci:2: referenced as `argb`
	cmplGfx/lib/image.blur.ci:72: referenced as `argb`
	cmplGfx/lib/image.blur.ci:52: referenced as `argb`
	cmplGfx/lib/image.blend.ci:106: referenced as `argb`
	cmplGfx/lib/image.blend.ci:106: referenced as `argb`
	cmplGfx/lib/image.blend.ci:106: referenced as `argb`
	cmplGfx/lib/image.blend.ci:89: referenced as `argb`
	cmplGfx/lib/image.blend.ci:89: referenced as `argb`
	cmplGfx/lib/image.blend.ci:89: referenced as `argb`
	cmplGfx/lib/image.blend.ci:71: referenced as `argb`
	cmplGfx/lib/image.blend.ci:71: referenced as `argb`
	cmplGfx/lib/image.blend.ci:71: referenced as `argb`
	cmplGfx/lib/image.blend.ci:71: referenced as `argb`
	cmplGfx/lib/image.blend.ci:67: referenced as `argb`
	cmplGfx/lib/image.blend.ci:57: referenced as `argb`
	cmplGfx/lib/image.blend.ci:57: referenced as `argb`
	cmplGfx/lib/image.blend.ci:57: referenced as `argb`
	cmplGfx/lib/image.blend.ci:46: referenced as `argb`
	cmplGfx/lib/image.blend.ci:45: referenced as `argb`
	cmplGfx/lib/image.blend.ci:2: referenced as `argb`
	cmplGfx/lib/image.blend.ci:2: referenced as `argb`
	cmplGfx/lib/image.blend.ci:2: referenced as `argb`
	cmplGfx/lib/image.ci:54: referenced as `argb`
	cmplGfx/lib/color.ci:171: referenced as `argb`
	cmplGfx/lib/color.ci:133: referenced as `argb`
	cmplGfx/lib/color.ci:132: referenced as `argb`
	cmplGfx/lib/color.ci:128: referenced as `argb`
	cmplGfx/lib/color.ci:128: referenced as `argb`
	cmplGfx/lib/color.ci:125: referenced as `argb`
	cmplGfx/lib/color.ci:125: referenced as `argb`
	cmplGfx/lib/color.ci:80: referenced as `argb`
	cmplGfx/lib/color.ci:76: referenced as `argb`
	cmplGfx/lib/color.ci:73: referenced as `argb`
	cmplGfx/lib/color.ci:71: referenced as `argb`
	cmplGfx/lib/color.ci:69: referenced as `argb`
	cmplGfx/lib/color.ci:67: referenced as `argb`
	cmplGfx/lib/color.ci:23: referenced as `argb`
	cmplGfx/lib/color.ci:21: referenced as `argb`
}
argb.v: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'v'
.file: 'cmplGfx/lib/color.ci:4'
.owner: argb
.doc: 'value of color'
.usages:
	cmplGfx/lib/micro.ui.ci:659: referenced as `v`
	cmplGfx/lib/micro.ui.ci:653: referenced as `v`
	cmplGfx/lib/micro.ui.ci:441: referenced as `v`
	cmplGfx/lib/color.ci:138: referenced as `v`
}
argb.<?>: argb.<?> {
.kind: variable(val)
.base: `argb.<?>`
.size: 4
.name: '<?>'
.file: 'cmplGfx/lib/color.ci:181'
.owner: argb
.field b: uint8 (size: 1, cast: variable(u32))
.field g: uint8 (size: 1, cast: variable(u32))
.field r: uint8 (size: 1, cast: variable(u32))
.field a: uint8 (size: 1, cast: variable(u32))
.usages:
}
argb.<?>.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'b'
.file: 'cmplGfx/lib/color.ci:7'
.owner: argb.<?>
.doc: 'blue component'
.usages:
	cmplGfx/lib/color.matrix.ci:43: referenced as `b`
	cmplGfx/lib/color.lookup.ci:74: referenced as `b`
	cmplGfx/lib/color.lookup.ci:36: referenced as `b`
	cmplGfx/lib/color.lookup.ci:36: referenced as `b`
	cmplGfx/lib/image.blend.ci:109: referenced as `b`
	cmplGfx/lib/image.blend.ci:91: referenced as `b`
	cmplGfx/lib/image.blend.ci:74: referenced as `b`
}
argb.<?>.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'g'
.file: 'cmplGfx/lib/color.ci:10'
.owner: argb.<?>
.doc: 'green component'
.usages:
	cmplGfx/lib/color.matrix.ci:42: referenced as `g`
	cmplGfx/lib/color.lookup.ci:73: referenced as `g`
	cmplGfx/lib/color.lookup.ci:35: referenced as `g`
	cmplGfx/lib/color.lookup.ci:35: referenced as `g`
	cmplGfx/lib/image.blend.ci:110: referenced as `g`
	cmplGfx/lib/image.blend.ci:92: referenced as `g`
	cmplGfx/lib/image.blend.ci:75: referenced as `g`
}
argb.<?>.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'r'
.file: 'cmplGfx/lib/color.ci:13'
.owner: argb.<?>
.doc: 'red component'
.usages:
	cmplGfx/lib/color.matrix.ci:41: referenced as `r`
	cmplGfx/lib/color.lookup.ci:72: referenced as `r`
	cmplGfx/lib/color.lookup.ci:34: referenced as `r`
	cmplGfx/lib/color.lookup.ci:34: referenced as `r`
	cmplGfx/lib/image.blend.ci:111: referenced as `r`
	cmplGfx/lib/image.blend.ci:93: referenced as `r`
	cmplGfx/lib/image.blend.ci:76: referenced as `r`
}
argb.<?>.a: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'a'
.file: 'cmplGfx/lib/color.ci:16'
.owner: argb.<?>
.doc: 'alpha component'
.usages:
	cmplGfx/lib/image.blend.ci:112: referenced as `a`
	cmplGfx/lib/image.blend.ci:94: referenced as `a`
	cmplGfx/lib/image.blend.ci:77: referenced as `a`
}
argb.b: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'b'
.file: 'cmplGfx/lib/color.ci:7'
.owner: argb
.doc: 'blue component'
.value: b: uint8
}
argb.g: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'g'
.file: 'cmplGfx/lib/color.ci:10'
.owner: argb
.doc: 'green component'
.value: g: uint8
}
argb.r: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'r'
.file: 'cmplGfx/lib/color.ci:13'
.owner: argb
.doc: 'red component'
.value: r: uint8
}
argb.a: uint8 {
.kind: inline
.base: `uint8`
.size: 0
.name: 'a'
.file: 'cmplGfx/lib/color.ci:16'
.owner: argb
.doc: 'alpha component'
.value: a: uint8
}
argb(argb: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:21'
.param .result: argb (size: 4, cast: val)
.param argb: uint32 (size: 4, cast: u32)
.doc: 'cast unsigned integer to argb value'
.value: argb(emit(struct(argb)))
.usages:
	cmplGfx/lib/micro.ui.ci:638: referenced as `argb`
	cmplGfx/lib/micro.ui.ci:638: referenced as `argb`
	cmplGfx/lib/micro.ui.ci:632: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:6: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:4: referenced as `argb`
	cmplGfx/lib/color.matrix.ci:37: referenced as `argb`
	cmplGfx/lib/color.lookup.ci:61: referenced as `argb`
	cmplGfx/lib/color.lookup.ci:33: referenced as `argb`
	cmplGfx/lib/image.blur.ci:72: referenced as `argb`
	cmplGfx/lib/image.blur.ci:52: referenced as `argb`
	cmplGfx/lib/image.blend.ci:46: referenced as `argb`
	cmplGfx/lib/image.blend.ci:45: referenced as `argb`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `argb`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `argb`
	cmplGfx/lib/color.ci:36: referenced as `argb`
	cmplGfx/lib/color.ci:34: referenced as `argb`
	cmplGfx/lib/color.ci:32: referenced as `argb`
}
uint32(value: argb): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'uint32'
.file: 'cmplGfx/lib/color.ci:23'
.param .result: uint32 (size: 4, cast: u32)
.param value: argb (size: 4, cast: val)
.doc: 'cast argb value to unsigned integer'
.value: uint32(emit(struct(value)))
.usages:
	cmplGfx/lib/micro.ui.ci:461: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:144: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:143: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:142: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:141: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:140: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:48: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:46: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:44: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:42: referenced as `uint32`
	cmplGfx/lib/micro.ui.core.ci:39: referenced as `uint32`
	cmplGfx/lib/image.ci:54: referenced as `uint32`
	cmplGfx/lib/color.ci:73: referenced as `uint32`
	cmplGfx/lib/color.ci:71: referenced as `uint32`
	cmplGfx/lib/color.ci:69: referenced as `uint32`
	cmplGfx/lib/color.ci:67: referenced as `uint32`
}
sat_s8(c: int32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sat_s8'
.file: 'cmplGfx/lib/color.ci:27'
.param .result: uint32 (size: 4, cast: u32)
.param c: int32 (size: 4, cast: variable(i32))
.doc: 'clamp signed gray or color component to fit in 8 bits (0 ... 255)'
.value: uint32(c > 255 ? 255 : c < 0 ? 0 : c)
.usages:
	cmplGfx/lib/color.matrix.ci:43: referenced as `sat_s8`
	cmplGfx/lib/color.matrix.ci:42: referenced as `sat_s8`
	cmplGfx/lib/color.matrix.ci:41: referenced as `sat_s8`
	cmplGfx/lib/color.lookup.ci:74: referenced as `sat_s8`
	cmplGfx/lib/color.lookup.ci:73: referenced as `sat_s8`
	cmplGfx/lib/color.lookup.ci:72: referenced as `sat_s8`
	cmplGfx/lib/color.lookup.ci:70: referenced as `sat_s8`
	cmplGfx/lib/image.blend.ci:93: referenced as `sat_s8`
	cmplGfx/lib/image.blend.ci:92: referenced as `sat_s8`
	cmplGfx/lib/image.blend.ci:91: referenced as `sat_s8`
	cmplGfx/lib/color.ci:148: referenced as `sat_s8`
	cmplGfx/lib/color.ci:57: referenced as `sat_s8`
	cmplGfx/lib/color.ci:57: referenced as `sat_s8`
	cmplGfx/lib/color.ci:57: referenced as `sat_s8`
	cmplGfx/lib/color.ci:57: referenced as `sat_s8`
	cmplGfx/lib/color.ci:49: referenced as `sat_s8`
	cmplGfx/lib/color.ci:49: referenced as `sat_s8`
	cmplGfx/lib/color.ci:49: referenced as `sat_s8`
	cmplGfx/lib/color.ci:41: referenced as `sat_s8`
	cmplGfx/lib/color.ci:39: referenced as `sat_s8`
}
sat_u8(c: uint32): uint32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sat_u8'
.file: 'cmplGfx/lib/color.ci:29'
.param .result: uint32 (size: 4, cast: u32)
.param c: uint32 (size: 4, cast: variable(u32))
.doc: 'clamp unsigned gray or color component to fit in 8 bits (0 ... 255)'
.value: uint32(c > (255) ? 255 : (c))
.usages:
	cmplGfx/lib/color.ci:145: referenced as `sat_u8`
	cmplGfx/lib/color.ci:59: referenced as `sat_u8`
	cmplGfx/lib/color.ci:59: referenced as `sat_u8`
	cmplGfx/lib/color.ci:59: referenced as `sat_u8`
	cmplGfx/lib/color.ci:59: referenced as `sat_u8`
	cmplGfx/lib/color.ci:51: referenced as `sat_u8`
	cmplGfx/lib/color.ci:51: referenced as `sat_u8`
	cmplGfx/lib/color.ci:51: referenced as `sat_u8`
}
pack(c: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pack'
.file: 'cmplGfx/lib/color.ci:32'
.param .result: argb (size: 4, cast: val)
.param c: uint32 (size: 4, cast: variable(u32))
.doc: 'pack an argb color from the given component'
.value: argb((((c << 8) | c) << 8) | c)
.usages:
	cmplGfx/lib/color.ci:41: referenced as `pack`
	cmplGfx/lib/color.ci:39: referenced as `pack`
}
pack(r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pack'
.file: 'cmplGfx/lib/color.ci:34'
.param .result: argb (size: 4, cast: val)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'pack an argb color from the given components'
.value: argb((((r << 8) | g) << 8) | b)
.usages:
	cmplGfx/lib/color.ci:51: referenced as `pack`
	cmplGfx/lib/color.ci:49: referenced as `pack`
}
pack(a: uint32, r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pack'
.file: 'cmplGfx/lib/color.ci:36'
.param .result: argb (size: 4, cast: val)
.param a: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'pack an argb color from the given components'
.value: argb((((((a << 8) | r) << 8) | g) << 8) | b)
.usages:
	cmplGfx/lib/color.ci:59: referenced as `pack`
	cmplGfx/lib/color.ci:57: referenced as `pack`
}
gray(c: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:39'
.param .result: argb (size: 4, cast: val)
.param c: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: pack(sat_s8(c))
.usages:
	cmplGfx/lib/color.ci:45: referenced as `gray`
	cmplGfx/lib/color.ci:43: referenced as `gray`
}
gray(c: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:41'
.param .result: argb (size: 4, cast: val)
.param c: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: pack(sat_s8(c))
.usages:
}
gray(c: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:43'
.param .result: argb (size: 4, cast: val)
.param c: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: gray(int32(c * (255)))
.usages:
}
gray(c: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gray'
.file: 'cmplGfx/lib/color.ci:45'
.param .result: argb (size: 4, cast: val)
.param c: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given gray value, clamp the input'
.value: gray(int32(c * (255)))
.usages:
}
argb(r: int32, g: int32, b: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:49'
.param .result: argb (size: 4, cast: val)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: pack(sat_s8(r), sat_s8(g), sat_s8(b))
.usages:
	cmplGfx/lib/micro.ui.core.ci:21: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:19: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:17: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:15: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:13: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:11: referenced as `argb`
	cmplGfx/lib/micro.ui.core.ci:9: referenced as `argb`
	cmplGfx/lib/image.blur.ci:79: referenced as `argb`
	cmplGfx/lib/image.blur.ci:59: referenced as `argb`
	cmplGfx/lib/color.ci:125: referenced as `argb`
	cmplGfx/lib/color.ci:55: referenced as `argb`
	cmplGfx/lib/color.ci:53: referenced as `argb`
}
argb(r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:51'
.param .result: argb (size: 4, cast: val)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: pack(sat_u8(r), sat_u8(g), sat_u8(b))
.usages:
}
argb(r: float32, g: float32, b: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:53'
.param .result: argb (size: 4, cast: val)
.param r: float32 (size: 4, cast: f32)
.param g: float32 (size: 4, cast: f32)
.param b: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
}
argb(r: float64, g: float64, b: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:55'
.param .result: argb (size: 4, cast: val)
.param r: float64 (size: 8, cast: f64)
.param g: float64 (size: 8, cast: f64)
.param b: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
}
argb(a: int32, r: int32, g: int32, b: int32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:57'
.param .result: argb (size: 4, cast: val)
.param a: int32 (size: 4, cast: i32)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: pack(sat_s8(a), sat_s8(r), sat_s8(g), sat_s8(b))
.usages:
	cmplGfx/lib/micro.ui.ci:349: referenced as `argb`
	cmplGfx/lib/color.ci:63: referenced as `argb`
	cmplGfx/lib/color.ci:61: referenced as `argb`
}
argb(a: uint32, r: uint32, g: uint32, b: uint32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:59'
.param .result: argb (size: 4, cast: val)
.param a: uint32 (size: 4, cast: u32)
.param r: uint32 (size: 4, cast: u32)
.param g: uint32 (size: 4, cast: u32)
.param b: uint32 (size: 4, cast: u32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: pack(sat_u8(a), sat_u8(r), sat_u8(g), sat_u8(b))
.usages:
}
argb(a: float32, r: float32, g: float32, b: float32): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:61'
.param .result: argb (size: 4, cast: val)
.param a: float32 (size: 4, cast: f32)
.param r: float32 (size: 4, cast: f32)
.param g: float32 (size: 4, cast: f32)
.param b: float32 (size: 4, cast: f32)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(a * (255)), int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
	cmplGfx/lib/color.ci:174: referenced as `argb`
}
argb(a: float64, r: float64, g: float64, b: float64): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:63'
.param .result: argb (size: 4, cast: val)
.param a: float64 (size: 8, cast: f64)
.param r: float64 (size: 8, cast: f64)
.param g: float64 (size: 8, cast: f64)
.param b: float64 (size: 8, cast: f64)
.doc: 'construct a rgb8 color from the given components, clamp the input'
.value: argb(int32(a * (255)), int32(r * (255)), int32(g * (255)), int32(b * (255)))
.usages:
}
ach(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'ach'
.file: 'cmplGfx/lib/color.ci:67'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'get the Alpha channel of the color'
.value: int32((uint32(color) >> 24))
.usages:
	cmplGfx/lib/micro.ui.ci:471: referenced as `ach`
	cmplGfx/lib/micro.ui.ci:460: referenced as `ach`
	cmplGfx/lib/micro.ui.ci:438: referenced as `ach`
	cmplGfx/lib/micro.ui.ci:430: referenced as `ach`
	cmplGfx/lib/color.lookup.ci:70: referenced as `ach`
	cmplGfx/lib/color.lookup.ci:23: referenced as `ach`
	cmplGfx/lib/image.blend.ci:107: referenced as `ach`
	cmplGfx/lib/image.blend.ci:72: referenced as `ach`
	cmplGfx/lib/color.ci:171: referenced as `ach`
	cmplGfx/lib/color.ci:134: referenced as `ach`
	cmplGfx/lib/color.ci:134: referenced as `ach`
}
rch(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rch'
.file: 'cmplGfx/lib/color.ci:69'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'get the Red channel of the color'
.value: int32(uint32(color) >> 16 & (255))
.usages:
	cmplGfx/lib/micro.ui.ci:470: referenced as `rch`
	cmplGfx/lib/micro.ui.ci:437: referenced as `rch`
	cmplGfx/lib/micro.ui.ci:429: referenced as `rch`
	cmplGfx/lib/color.matrix.ci:38: referenced as `rch`
	cmplGfx/lib/color.lookup.ci:62: referenced as `rch`
	cmplGfx/lib/color.lookup.ci:62: referenced as `rch`
	cmplGfx/lib/color.lookup.ci:34: referenced as `rch`
	cmplGfx/lib/image.blur.ci:74: referenced as `rch`
	cmplGfx/lib/image.blur.ci:54: referenced as `rch`
	cmplGfx/lib/image.blend.ci:111: referenced as `rch`
	cmplGfx/lib/image.blend.ci:111: referenced as `rch`
	cmplGfx/lib/image.blend.ci:93: referenced as `rch`
	cmplGfx/lib/image.blend.ci:93: referenced as `rch`
	cmplGfx/lib/image.blend.ci:76: referenced as `rch`
	cmplGfx/lib/image.blend.ci:76: referenced as `rch`
	cmplGfx/lib/color.ci:171: referenced as `rch`
	cmplGfx/lib/color.ci:135: referenced as `rch`
	cmplGfx/lib/color.ci:135: referenced as `rch`
	cmplGfx/lib/color.ci:125: referenced as `rch`
	cmplGfx/lib/color.ci:125: referenced as `rch`
	cmplGfx/lib/color.ci:81: referenced as `rch`
	cmplGfx/lib/color.ci:76: referenced as `rch`
}
gch(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'gch'
.file: 'cmplGfx/lib/color.ci:71'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'get the Green channel of the color'
.value: int32(uint32(color) >> 8 & (255))
.usages:
	cmplGfx/lib/micro.ui.ci:469: referenced as `gch`
	cmplGfx/lib/micro.ui.ci:436: referenced as `gch`
	cmplGfx/lib/micro.ui.ci:428: referenced as `gch`
	cmplGfx/lib/color.matrix.ci:39: referenced as `gch`
	cmplGfx/lib/color.lookup.ci:63: referenced as `gch`
	cmplGfx/lib/color.lookup.ci:63: referenced as `gch`
	cmplGfx/lib/color.lookup.ci:35: referenced as `gch`
	cmplGfx/lib/image.blur.ci:75: referenced as `gch`
	cmplGfx/lib/image.blur.ci:55: referenced as `gch`
	cmplGfx/lib/image.blend.ci:110: referenced as `gch`
	cmplGfx/lib/image.blend.ci:110: referenced as `gch`
	cmplGfx/lib/image.blend.ci:92: referenced as `gch`
	cmplGfx/lib/image.blend.ci:92: referenced as `gch`
	cmplGfx/lib/image.blend.ci:75: referenced as `gch`
	cmplGfx/lib/image.blend.ci:75: referenced as `gch`
	cmplGfx/lib/color.ci:171: referenced as `gch`
	cmplGfx/lib/color.ci:136: referenced as `gch`
	cmplGfx/lib/color.ci:136: referenced as `gch`
	cmplGfx/lib/color.ci:125: referenced as `gch`
	cmplGfx/lib/color.ci:125: referenced as `gch`
	cmplGfx/lib/color.ci:82: referenced as `gch`
	cmplGfx/lib/color.ci:76: referenced as `gch`
}
bch(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'bch'
.file: 'cmplGfx/lib/color.ci:73'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'get the Blue channel of the color'
.value: int32(uint32(color) & (255))
.usages:
	cmplGfx/lib/micro.ui.ci:468: referenced as `bch`
	cmplGfx/lib/micro.ui.ci:435: referenced as `bch`
	cmplGfx/lib/micro.ui.ci:427: referenced as `bch`
	cmplGfx/lib/color.matrix.ci:40: referenced as `bch`
	cmplGfx/lib/color.lookup.ci:64: referenced as `bch`
	cmplGfx/lib/color.lookup.ci:64: referenced as `bch`
	cmplGfx/lib/color.lookup.ci:36: referenced as `bch`
	cmplGfx/lib/image.blur.ci:76: referenced as `bch`
	cmplGfx/lib/image.blur.ci:56: referenced as `bch`
	cmplGfx/lib/image.blend.ci:109: referenced as `bch`
	cmplGfx/lib/image.blend.ci:109: referenced as `bch`
	cmplGfx/lib/image.blend.ci:91: referenced as `bch`
	cmplGfx/lib/image.blend.ci:91: referenced as `bch`
	cmplGfx/lib/image.blend.ci:74: referenced as `bch`
	cmplGfx/lib/image.blend.ci:74: referenced as `bch`
	cmplGfx/lib/color.ci:171: referenced as `bch`
	cmplGfx/lib/color.ci:137: referenced as `bch`
	cmplGfx/lib/color.ci:137: referenced as `bch`
	cmplGfx/lib/color.ci:125: referenced as `bch`
	cmplGfx/lib/color.ci:125: referenced as `bch`
	cmplGfx/lib/color.ci:83: referenced as `bch`
	cmplGfx/lib/color.ci:76: referenced as `bch`
}
lum(color: argb): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'cmplGfx/lib/color.ci:76'
.param .result: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: variable(val))
.doc: 'get the luminosity of the color (0.299 * color.r + 0.587 * color.g + 0.114 * color.b)'
.value: int32((19595 * rch(color) + 38470 * gch(color) + 7471 * bch(color)) >> 16)
.usages:
	cmplGfx/lib/micro.ui.core.ci:144: referenced as `lum`
	cmplGfx/lib/micro.ui.core.ci:48: referenced as `lum`
}
hue(rgb: argb): uint32: function {
.kind: static function
.base: `function`
.size: 206
.name: 'hue'
.file: 'cmplGfx/lib/color.ci:80'
.param .result: uint32 (size: 4, cast: variable(u32))
.param rgb: argb (size: 4, cast: variable(val))
.doc: 'get the hue of the color'
.value: {
	r: int32 := rch(rgb);
	g: int32 := gch(rgb);
	b: int32 := bch(rgb);
	min: int32 := r;
	max: int32 := r;
	if (min > g) {
		min := g;
	}
	if (min > b) {
		min := b;
	}
	if (max < g) {
		max := g;
	}
	if (max < b) {
		max := b;
	}
	if (max == min) {
		return .result := 0;
	}
	hue: int32 := 0;
	if (max == r) {
		hue := ((g - b) * 60) / (max - min);
	}
	else if (max == g) {
		hue := ((b - r) * 60) / (max - min) + 120;
	}
	else if (max == b) {
		hue := ((r - g) * 60) / (max - min) + 240;
	}
	if (hue < 0) {
		hue := hue + 360;
	}
	return .result := hue;
}
.instructions: (206 bytes)
	cmplGfx/lib/color.ci:81: (6 bytes): r: int32 := rch(rgb)
	<hue>  : dup.x32 sp(1)
	<hue+?>: b32.shr 0x10
	<hue+?>: b32.and 0xff
	cmplGfx/lib/color.ci:82: (6 bytes): g: int32 := gch(rgb)
	<hue+?>: dup.x32 sp(2)
	<hue+?>: b32.shr 0x08
	<hue+?>: b32.and 0xff
	cmplGfx/lib/color.ci:83: (4 bytes): b: int32 := bch(rgb)
	<hue+?>: dup.x32 sp(3)
	<hue+?>: b32.and 0xff
	cmplGfx/lib/color.ci:84: (2 bytes): min: int32 := r
	<hue+?>: dup.x32 sp(2)
	cmplGfx/lib/color.ci:85: (2 bytes): max: int32 := r
	<hue+?>: dup.x32 sp(3)
	cmplGfx/lib/color.ci:87: (12 bytes): if (min > g)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: cgt.i32
	<hue+?>: jz +7
	cmplGfx/lib/color.ci:88: (3 bytes): min := g;
	<hue+?>: mov.x32 sp(1, 3)
	cmplGfx/lib/color.ci:90: (12 bytes): if (min > b)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(3)
	<hue+?>: cgt.i32
	<hue+?>: jz +7
	cmplGfx/lib/color.ci:91: (3 bytes): min := b;
	<hue+?>: mov.x32 sp(1, 2)
	cmplGfx/lib/color.ci:93: (12 bytes): if (max < g)
	<hue+?>: dup.x32 sp(0)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: clt.i32
	<hue+?>: jz +7
	cmplGfx/lib/color.ci:94: (3 bytes): max := g;
	<hue+?>: mov.x32 sp(0, 3)
	cmplGfx/lib/color.ci:96: (12 bytes): if (max < b)
	<hue+?>: dup.x32 sp(0)
	<hue+?>: dup.x32 sp(3)
	<hue+?>: clt.i32
	<hue+?>: jz +7
	cmplGfx/lib/color.ci:97: (3 bytes): max := b;
	<hue+?>: mov.x32 sp(0, 2)
	cmplGfx/lib/color.ci:100: (17 bytes): if (max == min)
	<hue+?>: dup.x32 sp(0)
	<hue+?>: dup.x32 sp(2)
	<hue+?>: ceq.i32
	<hue+?>: jz +12
	cmplGfx/lib/color.ci:101: (8 bytes): return .result := 0;
	<hue+?>: load.z32
	<hue+?>: set.x32 sp(8)
	<hue+?>: inc.sp(-20)
	<hue+?>: ret
	cmplGfx/lib/color.ci:104: (1 byte): hue: int32 := 0
	<hue+?>: load.z32
	cmplGfx/lib/color.ci:105: (100 bytes): if (max == r)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(6)
	<hue+?>: ceq.i32
	<hue+?>: jz +27
	cmplGfx/lib/color.ci:106: (19 bytes): hue := ((g - b) * 60) / (max - min);
	<hue+?>: dup.x32 sp(4)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: sub.i32
	<hue+?>: load.c32 60
	<hue+?>: mul.i32
	<hue+?>: dup.x32 sp(2)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: sub.i32
	<hue+?>: div.i32
	<hue+?>: set.x32 sp(1)
	<hue+?>: jmp +72
	cmplGfx/lib/color.ci:108: (68 bytes): if (max == g)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(5)
	<hue+?>: ceq.i32
	<hue+?>: jz +31
	cmplGfx/lib/color.ci:109: (23 bytes): hue := ((b - r) * 60) / (max - min) + 120;
	<hue+?>: dup.x32 sp(3)
	<hue+?>: dup.x32 sp(6)
	<hue+?>: sub.i32
	<hue+?>: load.c32 60
	<hue+?>: mul.i32
	<hue+?>: dup.x32 sp(2)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: sub.i32
	<hue+?>: div.i32
	<hue+?>: inc.i32(+120)
	<hue+?>: set.x32 sp(1)
	<hue+?>: jmp +36
	cmplGfx/lib/color.ci:111: (32 bytes): if (max == b)
	<hue+?>: dup.x32 sp(1)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: ceq.i32
	<hue+?>: jz +27
	cmplGfx/lib/color.ci:112: (23 bytes): hue := ((r - g) * 60) / (max - min) + 240;
	<hue+?>: dup.x32 sp(5)
	<hue+?>: dup.x32 sp(5)
	<hue+?>: sub.i32
	<hue+?>: load.c32 60
	<hue+?>: mul.i32
	<hue+?>: dup.x32 sp(2)
	<hue+?>: dup.x32 sp(4)
	<hue+?>: sub.i32
	<hue+?>: div.i32
	<hue+?>: inc.i32(+240)
	<hue+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:114: (12 bytes): if (hue < 0)
	<hue+?>: dup.x32 sp(0)
	<hue+?>: load.z32
	<hue+?>: clt.i32
	<hue+?>: jz +8
	cmplGfx/lib/color.ci:115: (4 bytes): hue := hue + 360;
	<hue+?>: inc.i32(+360)
	cmplGfx/lib/color.ci:117: (8 bytes): return .result := hue;
	<hue+?>: mov.x32 sp(8, 0)
	<hue+?>: inc.sp(-24)
	<hue+?>: ret
.usages:
}
mix_s8(t: int32, a: uint32, b: uint32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mix_s8'
.file: 'cmplGfx/lib/color.ci:121'
.param .result: int32 (size: 4, cast: i32)
.param t: int32 (size: 4, cast: i32)
.param a: uint32 (size: 4, cast: variable(u32))
.param b: uint32 (size: 4, cast: u32)
.doc: 'compute the linear interpolation of the values `a` and `b` by `t` in range 0...255'
.value: int32(a + ((t * ((b - a + (1))) >> 8)))
.usages:
	cmplGfx/lib/image.blend.ci:111: referenced as `mix_s8`
	cmplGfx/lib/image.blend.ci:110: referenced as `mix_s8`
	cmplGfx/lib/image.blend.ci:109: referenced as `mix_s8`
	cmplGfx/lib/image.blend.ci:93: referenced as `mix_s8`
	cmplGfx/lib/image.blend.ci:92: referenced as `mix_s8`
	cmplGfx/lib/image.blend.ci:91: referenced as `mix_s8`
	cmplGfx/lib/image.blend.ci:76: referenced as `mix_s8`
	cmplGfx/lib/image.blend.ci:75: referenced as `mix_s8`
	cmplGfx/lib/image.blend.ci:74: referenced as `mix_s8`
	cmplGfx/lib/color.ci:125: referenced as `mix_s8`
	cmplGfx/lib/color.ci:125: referenced as `mix_s8`
	cmplGfx/lib/color.ci:125: referenced as `mix_s8`
}
mix_s16(t: int32, a: uint32, b: uint32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mix_s16'
.file: 'cmplGfx/lib/color.ci:123'
.param .result: int32 (size: 4, cast: i32)
.param t: int32 (size: 4, cast: i32)
.param a: uint32 (size: 4, cast: variable(u32))
.param b: uint32 (size: 4, cast: u32)
.doc: 'compute the linear interpolation of the values `a` and `b` by `t` in range 0...65535'
.value: int32(a + ((t * ((b - a + (1))) >> 16)))
.usages:
	cmplGfx/lib/color.ci:137: referenced as `mix_s16`
	cmplGfx/lib/color.ci:136: referenced as `mix_s16`
	cmplGfx/lib/color.ci:135: referenced as `mix_s16`
	cmplGfx/lib/color.ci:134: referenced as `mix_s16`
}
mix_rgb8(t: int32, a: argb, b: argb): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mix_rgb8'
.file: 'cmplGfx/lib/color.ci:125'
.param .result: argb (size: 4, cast: val)
.param t: int32 (size: 4, cast: variable(i32))
.param a: argb (size: 4, cast: variable(val))
.param b: argb (size: 4, cast: variable(val))
.doc: 'compute the linear interpolation of the colors `a` and `b` by `t` in range 0...255'
.value: argb(mix_s8(t, rch(a), rch(b)), mix_s8(t, gch(a), gch(b)), mix_s8(t, bch(a), bch(b)))
.usages:
	cmplGfx/lib/micro.ui.ci:638: referenced as `mix_rgb8`
	cmplGfx/lib/micro.ui.core.ci:142: referenced as `mix_rgb8`
	cmplGfx/lib/micro.ui.core.ci:141: referenced as `mix_rgb8`
	cmplGfx/lib/micro.ui.core.ci:44: referenced as `mix_rgb8`
	cmplGfx/lib/micro.ui.core.ci:42: referenced as `mix_rgb8`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `mix_rgb8`
}
lerpLut(lut: argb[], colors: argb[]): void: function {
.kind: static function
.base: `function`
.size: 219
.name: 'lerpLut'
.file: 'cmplGfx/lib/color.ci:128'
.param .result: void (size: 0, cast: variable(void))
.param lut: argb[] (size: 8, cast: variable(arr))
.param colors: argb[] (size: 8, cast: variable(arr))
.doc: 'linear interpolate a lookup-table with the given colors'
.value: {
	dt: int32 := (colors.length - (1) << 16) / (lut.length - (1));
	for (i: int32 := 0; i < (lut.length); i := i + 1) {
		t: int32 := i * dt;
		c1: argb := colors[t >> 16];
		c2: argb := colors[(t >> 16) + 1];
		a: int32 := mix_s16(t & 65535, ach(c1), ach(c2));
		r: int32 := mix_s16(t & 65535, rch(c1), rch(c2));
		g: int32 := mix_s16(t & 65535, gch(c1), gch(c2));
		b: int32 := mix_s16(t & 65535, bch(c1), bch(c2));
		lut[i].v := (a << 24 | r << 16 | g << 8 | b);
	}
}
.instructions: (219 bytes)
	cmplGfx/lib/color.ci:129: (15 bytes): dt: int32 := (colors.length - (1) << 16) / (lut.length - (1))
	<lerpLut>  : dup.x32 sp(2)
	<lerpLut+?>: inc.i32(-1)
	<lerpLut+?>: b32.shl 0x10
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: inc.i32(-1)
	<lerpLut+?>: div.u32
	cmplGfx/lib/color.ci:130: (199 bytes): for (i: int32 := 0; i < (lut.length); i := i + 1)
	<lerpLut+?>: load.z32
	<lerpLut+?>: jmp +185
	cmplGfx/lib/color.ci:131: (5 bytes): t: int32 := i * dt
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: mul.i32
	cmplGfx/lib/color.ci:132: (11 bytes): c1: argb := colors[t >> 16]
	<lerpLut+?>: dup.x32 sp(4)
	<lerpLut+?>: dup.x32 sp(1)
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: mad.u32 4
	<lerpLut+?>: load.i32
	cmplGfx/lib/color.ci:133: (15 bytes): c2: argb := colors[(t >> 16) + 1]
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mad.u32 4
	<lerpLut+?>: load.i32
	cmplGfx/lib/color.ci:134: (27 bytes): a: int32 := mix_s16(t & 65535, ach(c1), ach(c2))
	<lerpLut+?>: dup.x32 sp(1)
	<lerpLut+?>: b32.shr 0x18
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(4)
	<lerpLut+?>: b32.and 0xffff
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: b32.shr 0x18
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: sub.i32
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mul.i32
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: add.i32
	<lerpLut+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:135: (31 bytes): r: int32 := mix_s16(t & 65535, rch(c1), rch(c2))
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: b32.shr 0x10
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: b32.and 0xffff
	<lerpLut+?>: dup.x32 sp(4)
	<lerpLut+?>: b32.shr 0x10
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: sub.i32
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mul.i32
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: add.i32
	<lerpLut+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:136: (31 bytes): g: int32 := mix_s16(t & 65535, gch(c1), gch(c2))
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: b32.shr 0x08
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(6)
	<lerpLut+?>: b32.and 0xffff
	<lerpLut+?>: dup.x32 sp(5)
	<lerpLut+?>: b32.shr 0x08
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: sub.i32
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mul.i32
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: add.i32
	<lerpLut+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:137: (27 bytes): b: int32 := mix_s16(t & 65535, bch(c1), bch(c2))
	<lerpLut+?>: dup.x32 sp(4)
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(7)
	<lerpLut+?>: b32.and 0xffff
	<lerpLut+?>: dup.x32 sp(6)
	<lerpLut+?>: b32.and 0xff
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: sub.i32
	<lerpLut+?>: inc.i32(+1)
	<lerpLut+?>: mul.i32
	<lerpLut+?>: b32.sar 0x10
	<lerpLut+?>: add.i32
	<lerpLut+?>: set.x32 sp(1)
	cmplGfx/lib/color.ci:138: (26 bytes): lut[i].v := (a << 24 | r << 16 | g << 8 | b);
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: b32.shl 0x18
	<lerpLut+?>: dup.x32 sp(3)
	<lerpLut+?>: b32.shl 0x10
	<lerpLut+?>: or.b32
	<lerpLut+?>: dup.x32 sp(2)
	<lerpLut+?>: b32.shl 0x08
	<lerpLut+?>: or.b32
	<lerpLut+?>: dup.x32 sp(1)
	<lerpLut+?>: or.b32
	<lerpLut+?>: dup.x32 sp(13)
	<lerpLut+?>: dup.x32 sp(9)
	<lerpLut+?>: mad.u32 4
	<lerpLut+?>: store.i32
	<lerpLut+?>: inc.sp(-28)
	cmplGfx/lib/color.ci:130: (4 bytes): i := i + 1
	<lerpLut+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:130: (9 bytes): i < (lut.length)
	<lerpLut+?>: dup.x32 sp(0)
	<lerpLut+?>: dup.x32 sp(7)
	<lerpLut+?>: clt.i32
	<lerpLut+?>: jnz -186
	<lerpLut+?>: inc.sp(-4)
	<lerpLut+?>: inc.sp(-4)
	<lerpLut+?>: ret
.usages:
}
alphaLut(lut: uint32[], hardness: int32, alpha: int32, reflect: bool): void: function {
.kind: static function
.base: `function`
.size: 388
.name: 'alphaLut'
.file: 'cmplGfx/lib/color.ci:143'
.param .result: void (size: 0, cast: variable(void))
.param lut: uint32[] (size: 8, cast: variable(arr))
.param hardness: int32 (size: 4, cast: variable(i32))
.param alpha: int32 (size: 4, cast: variable(i32))
.param reflect: bool (size: 4, cast: variable(bool))
.doc: 'linear interpolate a alpha lookup-table with the given colors'
.value: {
	mid: int32 := hardness <= 0 ? -1 : 255;
	div: int32 := 256 - (sat_u8(hardness < 0 ? -hardness : hardness));
	for (i: int32 := 0; i < (lut.length); i := i + 1) {
		t: int32 := i * 255 / ((lut.length - (1)));
		lut[i] := sat_s8((t - mid) * 255 / div + mid);
		if (alpha < 0) {
			lut[i] := (255 - (255 - (lut[i])) * -alpha / 255);
		}
		else {
			lut[i] := (255 - (lut[i] * (alpha) / (255)));
		}
	}
	if (reflect) {
		end: int32 := lut.length - (1);
		mid: int32 := lut.length / (2);
		for (i: int32 := end; i >= mid; i := i - 1) {
			lut[i] := lut[end];
			end := end - 2;
		}
		for (i: int32 := 0; i < mid; i := i + 1) {
			lut[i] := lut[lut.length - (i) - (1)];
		}
	}
}
.instructions: (388 bytes)
	cmplGfx/lib/color.ci:144: (22 bytes): mid: int32 := hardness <= 0 ? -1 : 255
	<alphaLut>  : dup.x32 sp(3)
	<alphaLut+?>: load.z32
	<alphaLut+?>: cgt.i32
	<alphaLut+?>: jnz +13
	<alphaLut+?>: load.c32 -1
	<alphaLut+?>: jmp +9
	<alphaLut+?>: load.c32 255
	cmplGfx/lib/color.ci:145: (48 bytes): div: int32 := 256 - (sat_u8(hardness < 0 ? -hardness : hardness))
	<alphaLut+?>: load.c32 256
	<alphaLut+?>: dup.x32 sp(5)
	<alphaLut+?>: load.z32
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jz +11
	<alphaLut+?>: dup.x32 sp(5)
	<alphaLut+?>: neg.i32
	<alphaLut+?>: jmp +6
	<alphaLut+?>: dup.x32 sp(5)
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: cgt.u32
	<alphaLut+?>: jz +13
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: jmp +6
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: set.x32 sp(1)
	<alphaLut+?>: sub.i32
	cmplGfx/lib/color.ci:146: (190 bytes): for (i: int32 := 0; i < (lut.length); i := i + 1)
	<alphaLut+?>: load.z32
	<alphaLut+?>: jmp +176
	cmplGfx/lib/color.ci:147: (15 bytes): t: int32 := i * 255 / ((lut.length - (1)))
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: mul.i32
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: inc.i32(-1)
	<alphaLut+?>: div.i32
	cmplGfx/lib/color.ci:148: (64 bytes): lut[i] := sat_s8((t - mid) * 255 / div + mid);
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: dup.x32 sp(4)
	<alphaLut+?>: sub.i32
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: mul.i32
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: div.i32
	<alphaLut+?>: dup.x32 sp(4)
	<alphaLut+?>: add.i32
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: cgt.i32
	<alphaLut+?>: jz +13
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: jmp +19
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: load.z32
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jz +9
	<alphaLut+?>: load.z32
	<alphaLut+?>: jmp +6
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: set.x32 sp(1)
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	cmplGfx/lib/color.ci:149: (85 bytes): if (alpha < 0)
	<alphaLut+?>: dup.x32 sp(6)
	<alphaLut+?>: load.z32
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jz +48
	cmplGfx/lib/color.ci:150: (40 bytes): lut[i] := (255 - (255 - (lut[i])) * -alpha / 255);
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: dup.x32 sp(10)
	<alphaLut+?>: dup.x32 sp(4)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: load.i32
	<alphaLut+?>: sub.i32
	<alphaLut+?>: dup.x32 sp(8)
	<alphaLut+?>: neg.i32
	<alphaLut+?>: mul.i32
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: div.i32
	<alphaLut+?>: sub.i32
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	<alphaLut+?>: jmp +37
	cmplGfx/lib/color.ci:152: (33 bytes): lut[i] := (255 - (lut[i] * (alpha) / (255)));
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: load.i32
	<alphaLut+?>: dup.x32 sp(8)
	<alphaLut+?>: mul.u32
	<alphaLut+?>: load.c32 255
	<alphaLut+?>: div.u32
	<alphaLut+?>: sub.i32
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	<alphaLut+?>: inc.sp(-4)
	cmplGfx/lib/color.ci:146: (4 bytes): i := i + 1
	<alphaLut+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:146: (9 bytes): i < (lut.length)
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jnz -177
	<alphaLut+?>: inc.sp(-4)
	cmplGfx/lib/color.ci:155: (123 bytes): if (reflect)
	<alphaLut+?>: load.sp(+12)
	<alphaLut+?>: load.is8
	<alphaLut+?>: jz +118
	cmplGfx/lib/color.ci:156: (6 bytes): end: int32 := lut.length - (1)
	<alphaLut+?>: dup.x32 sp(7)
	<alphaLut+?>: inc.i32(-1)
	cmplGfx/lib/color.ci:157: (8 bytes): mid: int32 := lut.length / (2)
	<alphaLut+?>: dup.x32 sp(8)
	<alphaLut+?>: load.c32 2
	<alphaLut+?>: div.u32
	cmplGfx/lib/color.ci:158: (49 bytes): for (i: int32 := end; i >= mid; i := i - 1)
	<alphaLut+?>: dup.x32 sp(1)
	<alphaLut+?>: jmp +34
	cmplGfx/lib/color.ci:159: (18 bytes): lut[i] := lut[end];
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(3)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: load.i32
	<alphaLut+?>: dup.x32 sp(10)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	cmplGfx/lib/color.ci:160: (8 bytes): end := end - 2;
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: inc.i32(-2)
	<alphaLut+?>: set.x32 sp(3)
	cmplGfx/lib/color.ci:158: (4 bytes): i := i - 1
	<alphaLut+?>: inc.i32(-1)
	cmplGfx/lib/color.ci:158: (9 bytes): i >= mid
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jz -35
	<alphaLut+?>: inc.sp(-4)
	cmplGfx/lib/color.ci:162: (47 bytes): for (i: int32 := 0; i < mid; i := i + 1)
	<alphaLut+?>: load.z32
	<alphaLut+?>: jmp +33
	cmplGfx/lib/color.ci:163: (25 bytes): lut[i] := lut[lut.length - (i) - (1)];
	<alphaLut+?>: dup.x32 sp(9)
	<alphaLut+?>: dup.x32 sp(11)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: sub.i32
	<alphaLut+?>: inc.i32(-1)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: load.i32
	<alphaLut+?>: dup.x32 sp(10)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: mad.u32 4
	<alphaLut+?>: store.i32
	cmplGfx/lib/color.ci:162: (4 bytes): i := i + 1
	<alphaLut+?>: inc.i32(+1)
	cmplGfx/lib/color.ci:162: (9 bytes): i < mid
	<alphaLut+?>: dup.x32 sp(0)
	<alphaLut+?>: dup.x32 sp(2)
	<alphaLut+?>: clt.i32
	<alphaLut+?>: jnz -34
	<alphaLut+?>: inc.sp(-4)
	<alphaLut+?>: inc.sp(-8)
	<alphaLut+?>: inc.sp(-8)
	<alphaLut+?>: ret
.usages:
}
vec4f(rgb: argb): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplGfx/lib/color.ci:171'
.param .result: vec4f (size: 16, cast: val)
.param rgb: argb (size: 4, cast: variable(val))
.doc: 'convert an argb color to a floating point vector'
.value: vec4f((rch(rgb)) / 255.000000, (gch(rgb)) / 255.000000, (bch(rgb)) / 255.000000, (ach(rgb)) / 255.000000)
.usages:
	cmplGfx/lib/image.blend.ci:58: referenced as `vec4f`
	cmplGfx/lib/image.blend.ci:58: referenced as `vec4f`
}
argb(vec: vec4f): argb: function {
.kind: inline
.base: `function`
.size: 0
.name: 'argb'
.file: 'cmplGfx/lib/color.ci:174'
.param .result: argb (size: 4, cast: val)
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'convert a floating point vector to an argb color'
.value: argb(vec.w, vec.x, vec.y, vec.z)
.usages:
	cmplGfx/lib/image.transform.ci:58: referenced as `argb`
	cmplGfx/lib/image.blend.ci:183: referenced as `argb`
	cmplGfx/lib/image.blend.ci:58: referenced as `argb`
}
lum(vec: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'lum'
.file: 'cmplGfx/lib/color.ci:177'
.param .result: float32 (size: 4, cast: f32)
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'calculate the luminosity of a color'
.value: 0.299000 * vec.x + 0.587000 * vec.y + 0.114000 * vec.z
.usages:
}
rgb2hsl(rgb: vec4f): vec4f: function {
.kind: static function
.base: `function`
.size: 554
.name: 'rgb2hsl'
.file: 'cmplGfx/lib/color.hsl.ci:3'
.param .result: vec4f (size: 16, cast: variable(val))
.param rgb: vec4f (size: 16, cast: variable(val))
.doc: 'Convert color from Rgb color space to Hsl color space'
.value: {
	min(x: float32, y: float32): float32 := x < y ? x : y;
	max(x: float32, y: float32): float32 := x > y ? x : y;
	clamp(value: float32, min: float32, max: float32): float32 := min(max(value, min), max);
	fmin: float32 := min(min(rgb.x, rgb.y), rgb.z);
	fmax: float32 := max(max(rgb.x, rgb.y), rgb.z);
	delta: float32 := fmax - fmin;
	lum: float32 := (fmax + fmin) / (2);
	if (delta == (0)) {
		return .result := {
			.result.x := (0);
			.result.y := (0);
			.result.z := lum;
		};
	}
	sat: float32;
	if (lum < 0.500000) {
		sat := delta / (fmax + fmin);
	}
	else {
		sat := delta / ((2) - fmax - fmin);
	}
	deltaR: float32 := (((fmax - rgb.x) / (6)) + (delta / (2))) / delta;
	deltaG: float32 := (((fmax - rgb.y) / (6)) + (delta / (2))) / delta;
	deltaB: float32 := (((fmax - rgb.z) / (6)) + (delta / (2))) / delta;
	hue: float32;
	if (rgb.x == fmax) {
		hue := deltaB - deltaG;
	}
	else if (rgb.y == fmax) {
		hue := ((1) / 3.000000) + deltaR - deltaB;
	}
	else if (rgb.z == fmax) {
		hue := ((2) / 3.000000) + deltaG - deltaR;
	}
	if (hue < (0)) {
		hue := hue + (1);
	}
	else if (hue > (1)) {
		hue := hue - (1);
	}
	return .result := {
			.result.x := clamp(hue, 0, 1);
			.result.y := clamp(sat, 0, 1);
			.result.z := clamp(lum, 0, 1);
		};
}
.instructions: (554 bytes)
	cmplGfx/lib/color.hsl.ci:7: (54 bytes): fmin: float32 := min(min(rgb.x, rgb.y), rgb.z)
	<rgb2hsl>  : dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	cmplGfx/lib/color.hsl.ci:8: (54 bytes): fmax: float32 := max(max(rgb.x, rgb.y), rgb.z)
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	cmplGfx/lib/color.hsl.ci:9: (5 bytes): delta: float32 := fmax - fmin
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: sub.f32
	cmplGfx/lib/color.hsl.ci:12: (11 bytes): lum: float32 := (fmax + fmin) / (2)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: div.f32
	cmplGfx/lib/color.hsl.ci:14: (22 bytes): if (delta == (0))
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: ceq.f32
	<rgb2hsl+?>: jz +18
	cmplGfx/lib/color.hsl.ci:16: (14 bytes): return .result := {...};
	cmplGfx/lib/color.hsl.ci:17: (3 bytes): .result.x := (0);
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: set.x32 sp(10)
	cmplGfx/lib/color.hsl.ci:18: (3 bytes): .result.y := (0);
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: set.x32 sp(11)
	cmplGfx/lib/color.hsl.ci:19: (3 bytes): .result.z := lum;
	<rgb2hsl+?>: mov.x32 sp(11, 0)
	<rgb2hsl+?>: inc.sp(-16)
	<rgb2hsl+?>: ret
	cmplGfx/lib/color.hsl.ci:24: (1 byte): sat: float32
	<rgb2hsl+?>: load.z32
	cmplGfx/lib/color.hsl.ci:25: (42 bytes): if (lum < 0.500000)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: load.f32 0.500000
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +18
	cmplGfx/lib/color.hsl.ci:26: (10 bytes): sat := delta / (fmax + fmin);
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: dup.x32 sp(6)
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: set.x32 sp(1)
	<rgb2hsl+?>: jmp +20
	cmplGfx/lib/color.hsl.ci:28: (16 bytes): sat := delta / ((2) - fmax - fmin);
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: dup.x32 sp(6)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: set.x32 sp(1)
	cmplGfx/lib/color.hsl.ci:31: (23 bytes): deltaR: float32 := (((fmax - rgb.x) / (6)) + (delta / (2))) / delta
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: dup.x32 sp(7)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: load.f32 6.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: div.f32
	cmplGfx/lib/color.hsl.ci:32: (23 bytes): deltaG: float32 := (((fmax - rgb.y) / (6)) + (delta / (2))) / delta
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: dup.x32 sp(9)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: load.f32 6.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: div.f32
	cmplGfx/lib/color.hsl.ci:33: (23 bytes): deltaB: float32 := (((fmax - rgb.z) / (6)) + (delta / (2))) / delta
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: dup.x32 sp(11)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: load.f32 6.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: div.f32
	cmplGfx/lib/color.hsl.ci:35: (1 byte): hue: float32
	<rgb2hsl+?>: load.z32
	cmplGfx/lib/color.hsl.ci:36: (80 bytes): if (rgb.x == fmax)
	<rgb2hsl+?>: dup.x32 sp(10)
	<rgb2hsl+?>: dup.x32 sp(8)
	<rgb2hsl+?>: ceq.f32
	<rgb2hsl+?>: jz +15
	cmplGfx/lib/color.hsl.ci:37: (7 bytes): hue := deltaB - deltaG;
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: set.x32 sp(1)
	<rgb2hsl+?>: jmp +64
	cmplGfx/lib/color.hsl.ci:39: (60 bytes): if (rgb.y == fmax)
	<rgb2hsl+?>: dup.x32 sp(11)
	<rgb2hsl+?>: dup.x32 sp(8)
	<rgb2hsl+?>: ceq.f32
	<rgb2hsl+?>: jz +27
	cmplGfx/lib/color.hsl.ci:40: (19 bytes): hue := ((1) / 3.000000) + deltaR - deltaB;
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: load.f32 3.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(2)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: set.x32 sp(1)
	<rgb2hsl+?>: jmp +32
	cmplGfx/lib/color.hsl.ci:42: (28 bytes): if (rgb.z == fmax)
	<rgb2hsl+?>: dup.x32 sp(12)
	<rgb2hsl+?>: dup.x32 sp(8)
	<rgb2hsl+?>: ceq.f32
	<rgb2hsl+?>: jz +23
	cmplGfx/lib/color.hsl.ci:43: (19 bytes): hue := ((2) / 3.000000) + deltaG - deltaR;
	<rgb2hsl+?>: load.f32 2.000000
	<rgb2hsl+?>: load.f32 3.000000
	<rgb2hsl+?>: div.f32
	<rgb2hsl+?>: dup.x32 sp(3)
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: sub.f32
	<rgb2hsl+?>: set.x32 sp(1)
	cmplGfx/lib/color.hsl.ci:46: (36 bytes): if (hue < (0))
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +14
	cmplGfx/lib/color.hsl.ci:47: (6 bytes): hue := hue + (1);
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: add.f32
	<rgb2hsl+?>: jmp +22
	cmplGfx/lib/color.hsl.ci:49: (18 bytes): if (hue > (1))
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	cmplGfx/lib/color.hsl.ci:50: (6 bytes): hue := hue - (1);
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: sub.f32
	cmplGfx/lib/color.hsl.ci:53: (179 bytes): return .result := {...};
	cmplGfx/lib/color.hsl.ci:54: (58 bytes): .result.x := clamp(hue, 0, 1);
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	<rgb2hsl+?>: set.x32 sp(15)
	cmplGfx/lib/color.hsl.ci:55: (58 bytes): .result.y := clamp(sat, 0, 1);
	<rgb2hsl+?>: dup.x32 sp(4)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	<rgb2hsl+?>: set.x32 sp(16)
	cmplGfx/lib/color.hsl.ci:56: (58 bytes): .result.z := clamp(lum, 0, 1);
	<rgb2hsl+?>: dup.x32 sp(5)
	<rgb2hsl+?>: load.z32
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: cgt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	<rgb2hsl+?>: load.f32 1.000000
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: clt.f32
	<rgb2hsl+?>: jz +10
	<rgb2hsl+?>: dup.x32 sp(1)
	<rgb2hsl+?>: jmp +6
	<rgb2hsl+?>: dup.x32 sp(0)
	<rgb2hsl+?>: mov.x32 sp(2, 0)
	<rgb2hsl+?>: inc.sp(-8)
	<rgb2hsl+?>: set.x32 sp(17)
	<rgb2hsl+?>: inc.sp(-36)
	<rgb2hsl+?>: ret
.usages:
}
hsl2rgb(hsl: vec4f): vec4f: function {
.kind: static function
.base: `function`
.size: 168
.name: 'hsl2rgb'
.file: 'cmplGfx/lib/color.hsl.ci:61'
.param .result: vec4f (size: 16, cast: variable(val))
.param hsl: vec4f (size: 16, cast: variable(val))
.doc: 'Convert color from Hsl color space to Rgb color space'
.value: {
	static hue2rgb(f1: float32, f2: float32, hue: float32): float32 := {
		if (hue < (0)) {
			hue := hue + (1);
		}
		else if (hue > (1)) {
			hue := hue - (1);
		}
		if (hue < 1.000000 / (6)) {
			return .result := f1 + (f2 - f1) * (6) * hue;
		}
		if (hue < 1.000000 / (2)) {
			return .result := f2;
		}
		if (hue < 2.000000 / (3)) {
			return .result := f1 + (f2 - f1) * (((2) / 3.000000) - hue) * (6);
		}
		return .result := f1;
	};
	if (hsl.y == (0)) {
		return .result := vec4f(hsl.z);
	}
	f2: float32;
	if (hsl.z < 0.500000) {
		f2 := hsl.z * ((1) + hsl.y);
	}
	else {
		f2 := (hsl.z + hsl.y) - (hsl.y * hsl.z);
	}
	f1: float32 := (2) * hsl.z - f2;
	return .result := {
			.result.x := hue2rgb(f1, f2, hsl.x + ((1) / 3.000000));
			.result.y := hue2rgb(f1, f2, hsl.x);
			.result.z := hue2rgb(f1, f2, hsl.x - ((1) / 3.000000));
		};
}
.instructions: (168 bytes)
	cmplGfx/lib/color.hsl.ci:82: (28 bytes): if (hsl.y == (0))
	<hsl2rgb>  : dup.x32 sp(2)
	<hsl2rgb+?>: load.z32
	<hsl2rgb+?>: ceq.f32
	<hsl2rgb+?>: jz +24
	cmplGfx/lib/color.hsl.ci:83: (20 bytes): return .result := vec4f(hsl.z);
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: dup.x32 sp(0)
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: dup.x32 sp(2)
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: mov.x128 sp(1, 0)
	<hsl2rgb+?>: inc.sp(-4)
	<hsl2rgb+?>: set.x128 sp(9)
	<hsl2rgb+?>: ret
	cmplGfx/lib/color.hsl.ci:86: (1 byte): f2: float32
	<hsl2rgb+?>: load.z32
	cmplGfx/lib/color.hsl.ci:87: (42 bytes): if (hsl.z < 0.500000)
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: load.f32 0.500000
	<hsl2rgb+?>: clt.f32
	<hsl2rgb+?>: jz +21
	cmplGfx/lib/color.hsl.ci:88: (13 bytes): f2 := hsl.z * ((1) + hsl.y);
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: load.f32 1.000000
	<hsl2rgb+?>: dup.x32 sp(5)
	<hsl2rgb+?>: add.f32
	<hsl2rgb+?>: mul.f32
	<hsl2rgb+?>: set.x32 sp(1)
	<hsl2rgb+?>: jmp +17
	cmplGfx/lib/color.hsl.ci:91: (13 bytes): f2 := (hsl.z + hsl.y) - (hsl.y * hsl.z);
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: add.f32
	<hsl2rgb+?>: dup.x32 sp(4)
	<hsl2rgb+?>: dup.x32 sp(6)
	<hsl2rgb+?>: mul.f32
	<hsl2rgb+?>: sub.f32
	<hsl2rgb+?>: set.x32 sp(1)
	cmplGfx/lib/color.hsl.ci:94: (11 bytes): f1: float32 := (2) * hsl.z - f2
	<hsl2rgb+?>: load.f32 2.000000
	<hsl2rgb+?>: dup.x32 sp(5)
	<hsl2rgb+?>: mul.f32
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: sub.f32
	cmplGfx/lib/color.hsl.ci:95: (86 bytes): return .result := {...};
	cmplGfx/lib/color.hsl.ci:96: (31 bytes): .result.x := hue2rgb(f1, f2, hsl.x + ((1) / 3.000000));
	<hsl2rgb+?>: load.z32
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: dup.x32 sp(6)
	<hsl2rgb+?>: load.f32 1.000000
	<hsl2rgb+?>: load.f32 3.000000
	<hsl2rgb+?>: div.f32
	<hsl2rgb+?>: add.f32
	<hsl2rgb+?>: load.ref <?> ;hsl2rgb.hue2rgb(f1: float32, f2: float32, hue: float32): float32
	<hsl2rgb+?>: call
	<hsl2rgb+?>: inc.sp(-12)
	<hsl2rgb+?>: set.x32 sp(8)
	cmplGfx/lib/color.hsl.ci:97: (19 bytes): .result.y := hue2rgb(f1, f2, hsl.x);
	<hsl2rgb+?>: load.z32
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: dup.x32 sp(6)
	<hsl2rgb+?>: load.ref <?> ;hsl2rgb.hue2rgb(f1: float32, f2: float32, hue: float32): float32
	<hsl2rgb+?>: call
	<hsl2rgb+?>: inc.sp(-12)
	<hsl2rgb+?>: set.x32 sp(9)
	cmplGfx/lib/color.hsl.ci:98: (31 bytes): .result.z := hue2rgb(f1, f2, hsl.x - ((1) / 3.000000));
	<hsl2rgb+?>: load.z32
	<hsl2rgb+?>: dup.x32 sp(1)
	<hsl2rgb+?>: dup.x32 sp(3)
	<hsl2rgb+?>: dup.x32 sp(6)
	<hsl2rgb+?>: load.f32 1.000000
	<hsl2rgb+?>: load.f32 3.000000
	<hsl2rgb+?>: div.f32
	<hsl2rgb+?>: sub.f32
	<hsl2rgb+?>: load.ref <?> ;hsl2rgb.hue2rgb(f1: float32, f2: float32, hue: float32): float32
	<hsl2rgb+?>: call
	<hsl2rgb+?>: inc.sp(-12)
	<hsl2rgb+?>: set.x32 sp(10)
	<hsl2rgb+?>: inc.sp(-8)
	<hsl2rgb+?>: ret
.usages:
}
Image(width: int32, height: int32, depth: int32): Image: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:2'
.param .result: Image (size: 8, cast: val)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.doc: 'Create an image with the given with, height and depth'
.value: Image.create(width, height, depth)
.usages:
	cmplGfx/lib/micro.ui.ci:1351: referenced as `Image`
	cmplGfx/lib/window.ci:150: referenced as `Image`
	cmplGfx/lib/window.ci:149: referenced as `Image`
	cmplGfx/lib/window.ci:141: referenced as `Image`
	cmplGfx/lib/window.ci:53: referenced as `Image`
	cmplGfx/lib/image.transform.ci:130: referenced as `Image`
}
Image(fileName: char[*], depth: int32): Image: function {
.kind: static function
.base: `function`
.size: 163
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:5'
.param .result: Image (size: 8, cast: variable(val))
.param fileName: char[*] (size: 4, cast: const variable(ref))
.param depth: int32 (size: 4, cast: variable(i32))
.doc: 'Create an image by opening an image file'
.value: {
	static if ((typename(Image.openPng)) != null) {
		if (endsWith(fileName, ".png", ignCaseCmp)) {
			return .result := Image.openPng(fileName, depth);
		}
	}
	static if ((typename(Image.openJpg)) != null) {
		if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
			return .result := Image.openJpg(fileName, depth);
		}
		if (endsWith(fileName, ".jpg", ignCaseCmp)) {
			return .result := Image.openJpg(fileName, depth);
		}
	}
	static if ((typename(Image.openBmp)) != null) {
		if (endsWith(fileName, ".bmp", ignCaseCmp)) {
			return .result := Image.openBmp(fileName, depth);
		}
	}
	return .result := Image.openImg(fileName, depth);
}
.instructions: (163 bytes)
	cmplGfx/lib/image.ci:7: (38 bytes): if (endsWith(fileName, ".png", ignCaseCmp))
	<Image>  : load.z32
	<Image+?>: dup.x32 sp(3)
	<Image+?>: load.ref <?> ;".png"
	<Image+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<Image+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<Image+?>: call
	<Image+?>: inc.sp(-12)
	<Image+?>: jz +15
	cmplGfx/lib/image.ci:8: (11 bytes): return .result := Image.openPng(fileName, depth);
	<Image+?>: dup.x32 sp(2)
	<Image+?>: dup.x32 sp(2)
	<Image+?>: nfc(95) ;Image.openPng(path: char[*], depth: int32): Image
	<Image+?>: set.x64 sp(5)
	<Image+?>: ret
	cmplGfx/lib/image.ci:12: (38 bytes): if (endsWith(fileName, ".jpeg", ignCaseCmp))
	<Image+?>: load.z32
	<Image+?>: dup.x32 sp(3)
	<Image+?>: load.ref <?> ;".jpeg"
	<Image+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<Image+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<Image+?>: call
	<Image+?>: inc.sp(-12)
	<Image+?>: jz +15
	cmplGfx/lib/image.ci:13: (11 bytes): return .result := Image.openJpg(fileName, depth);
	<Image+?>: dup.x32 sp(2)
	<Image+?>: dup.x32 sp(2)
	<Image+?>: nfc(96) ;Image.openJpg(path: char[*], depth: int32): Image
	<Image+?>: set.x64 sp(5)
	<Image+?>: ret
	cmplGfx/lib/image.ci:15: (38 bytes): if (endsWith(fileName, ".jpg", ignCaseCmp))
	<Image+?>: load.z32
	<Image+?>: dup.x32 sp(3)
	<Image+?>: load.ref <?> ;".jpg"
	<Image+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<Image+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<Image+?>: call
	<Image+?>: inc.sp(-12)
	<Image+?>: jz +15
	cmplGfx/lib/image.ci:16: (11 bytes): return .result := Image.openJpg(fileName, depth);
	<Image+?>: dup.x32 sp(2)
	<Image+?>: dup.x32 sp(2)
	<Image+?>: nfc(96) ;Image.openJpg(path: char[*], depth: int32): Image
	<Image+?>: set.x64 sp(5)
	<Image+?>: ret
	cmplGfx/lib/image.ci:20: (38 bytes): if (endsWith(fileName, ".bmp", ignCaseCmp))
	<Image+?>: load.z32
	<Image+?>: dup.x32 sp(3)
	<Image+?>: load.ref <?> ;".bmp"
	<Image+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<Image+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<Image+?>: call
	<Image+?>: inc.sp(-12)
	<Image+?>: jz +15
	cmplGfx/lib/image.ci:21: (11 bytes): return .result := Image.openBmp(fileName, depth);
	<Image+?>: dup.x32 sp(2)
	<Image+?>: dup.x32 sp(2)
	<Image+?>: nfc(94) ;Image.openBmp(path: char[*], depth: int32): Image
	<Image+?>: set.x64 sp(5)
	<Image+?>: ret
	cmplGfx/lib/image.ci:24: (11 bytes): return .result := Image.openImg(fileName, depth);
	<Image+?>: dup.x32 sp(2)
	<Image+?>: dup.x32 sp(2)
	<Image+?>: nfc(97) ;Image.openImg(path: char[*], depth: int32): Image
	<Image+?>: set.x64 sp(5)
	<Image+?>: ret
.usages:
	cmplGfx/lib/image.transform.ci:137: referenced as `Image`
	cmplGfx/lib/image.ci:28: referenced as `Image`
}
Image(fileName: char[*]): Image: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Image'
.file: 'cmplGfx/lib/image.ci:28'
.param .result: Image (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: const ref)
.doc: 'Create an image by opening an image file'
.value: Image(fileName, 32)
.usages:
}
clip(image: Image, roi: Rect): bool: function {
.kind: static function
.base: `function`
.size: 116
.name: 'clip'
.file: 'cmplGfx/lib/image.ci:31'
.param .result: bool (size: 4, cast: variable(bool))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: variable(ref))
.doc: 'Clip the rectangle against the given image boundaries'
.value: {
	if (roi.x0 < 0) {
		roi.x0 := 0;
	}
	if (roi.y0 < 0) {
		roi.y0 := 0;
	}
	width: int32 := Image.width(image);
	if (roi.x1 > width) {
		roi.x1 := width;
	}
	height: int32 := Image.height(image);
	if (roi.y1 > height) {
		roi.y1 := height;
	}
	return .result := !empty(roi);
}
.instructions: (116 bytes)
	cmplGfx/lib/image.ci:32: (13 bytes): if (roi.x0 < 0)
	<clip>  : dup.x32 sp(1)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +8
	cmplGfx/lib/image.ci:33: (4 bytes): roi.x0 := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:36: (21 bytes): if (roi.y0 < 0)
	<clip+?>: dup.x32 sp(1)
	<clip+?>: inc.i32(+4)
	<clip+?>: load.i32
	<clip+?>: load.z32
	<clip+?>: clt.i32
	<clip+?>: jz +12
	cmplGfx/lib/image.ci:37: (8 bytes): roi.y0 := 0;
	<clip+?>: load.z32
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+4)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:40: (6 bytes): width: int32 := Image.width(image)
	<clip+?>: dup.x64 sp(2)
	<clip+?>: nfc(101) ;Image.width(image: Image): int32
	cmplGfx/lib/image.ci:41: (23 bytes): if (roi.x1 > width)
	<clip+?>: dup.x32 sp(2)
	<clip+?>: inc.i32(+8)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	cmplGfx/lib/image.ci:42: (9 bytes): roi.x1 := width;
	<clip+?>: dup.x32 sp(0)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+8)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:45: (6 bytes): height: int32 := Image.height(image)
	<clip+?>: dup.x64 sp(3)
	<clip+?>: nfc(102) ;Image.height(image: Image): int32
	cmplGfx/lib/image.ci:46: (23 bytes): if (roi.y1 > height)
	<clip+?>: dup.x32 sp(3)
	<clip+?>: inc.i32(+12)
	<clip+?>: load.i32
	<clip+?>: dup.x32 sp(1)
	<clip+?>: cgt.i32
	<clip+?>: jz +13
	cmplGfx/lib/image.ci:47: (9 bytes): roi.y1 := height;
	<clip+?>: dup.x32 sp(0)
	<clip+?>: dup.x32 sp(4)
	<clip+?>: inc.i32(+12)
	<clip+?>: store.i32
	cmplGfx/lib/image.ci:50: (24 bytes): return .result := !empty(roi);
	<clip+?>: load.z32
	<clip+?>: dup.x32 sp(4)
	<clip+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<clip+?>: call
	<clip+?>: inc.sp(-4)
	<clip+?>: not.b32
	<clip+?>: load.sp(+28)
	<clip+?>: store.i8
	<clip+?>: inc.sp(-8)
	<clip+?>: ret
.usages:
	cmplGfx/lib/color.matrix.ci:15: referenced as `clip`
	cmplGfx/lib/color.lookup.ci:16: referenced as `clip`
	cmplGfx/lib/image.transform.ci:38: referenced as `clip`
	cmplGfx/lib/image.transform.ci:33: referenced as `clip`
	cmplGfx/lib/image.blend.ci:167: referenced as `clip`
	cmplGfx/lib/image.blend.ci:139: referenced as `clip`
	cmplGfx/lib/image.blend.ci:28: referenced as `clip`
	cmplGfx/lib/image.blend.ci:20: referenced as `clip`
}
set(image: Image, x: int32, y: int32, color: argb): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'set'
.file: 'cmplGfx/lib/image.ci:54'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param x: int32 (size: 4, cast: i32)
.param y: int32 (size: 4, cast: i32)
.param color: argb (size: 4, cast: val)
.doc: 'Set the the color of a pixel at the given position'
.value: Image.set(image, x, y, uint32(color))
.usages:
	cmplGfx/lib/color.matrix.ci:44: referenced as `set`
	cmplGfx/lib/color.lookup.ci:75: referenced as `set`
	cmplGfx/lib/color.lookup.ci:37: referenced as `set`
	cmplGfx/lib/image.blur.ci:79: referenced as `set`
	cmplGfx/lib/image.blur.ci:59: referenced as `set`
	cmplGfx/lib/image.transform.ci:58: referenced as `set`
	cmplGfx/lib/image.blend.ci:183: referenced as `set`
	cmplGfx/lib/image.blend.ci:47: referenced as `set`
	cmplGfx/lib/image.draw.line.ci:3: referenced as `set`
}
drawAntiAliased: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'drawAntiAliased'
.file: 'cmplGfx/lib/image.draw.ci:3'
.value: true
.usages:
}
fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 124
.name: 'fillRect'
.file: 'cmplGfx/lib/image.draw.rect.ci:2'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param incl: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Fill a rectangle on the `image` specified by the coordinates with the given `color`'
.value: {
	static if ((preferNativeCalls) && (typename(Image.fillRect)) != null) {
		return .result := Image.fillRect(image, x0, y0, x1, y1, incl, color);
	}
	if (x0 > x1) {
		t: int32 := x0;
		x0 := x1;
		x1 := t;
	}
	if (y0 > y1) {
		t: int32 := y0;
		y0 := y1;
		y1 := t;
	}
	x1 := x1 + incl;
	y1 := y1 + incl;
	for (y: int32 := y0; y < y1; y := y + 1) {
		for (x: int32 := x0; x < x1; x := x + 1) {
			Image.set(image, x, y, color);
		}
	}
}
.instructions: (124 bytes)
	cmplGfx/lib/image.draw.rect.ci:4: (19 bytes): return .result := Image.fillRect(image, x0, y0, x1, y1, incl, color);
	<fillRect>  : dup.x64 sp(7)
	<fillRect+?>: dup.x32 sp(8)
	<fillRect+?>: dup.x32 sp(8)
	<fillRect+?>: dup.x32 sp(8)
	<fillRect+?>: dup.x32 sp(8)
	<fillRect+?>: dup.x32 sp(8)
	<fillRect+?>: dup.x32 sp(8)
	<fillRect+?>: nfc(109) ;Image.fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<fillRect+?>: ret
	cmplGfx/lib/image.draw.rect.ci:7: (16 bytes): if (x0 > x1)
	<fillRect+?>: dup.x32 sp(6)
	<fillRect+?>: dup.x32 sp(5)
	<fillRect+?>: cgt.i32
	<fillRect+?>: jz +11
	cmplGfx/lib/image.draw.rect.ci:8: (2 bytes): t: int32 := x0
	<fillRect+?>: dup.x32 sp(6)
	cmplGfx/lib/image.draw.rect.ci:9: (3 bytes): x0 := x1;
	<fillRect+?>: mov.x32 sp(7, 5)
	<fillRect+?>: set.x32 sp(5)
	<fillRect+?>: dup.x32 sp(5)
	<fillRect+?>: dup.x32 sp(4)
	<fillRect+?>: cgt.i32
	<fillRect+?>: jz +11
	cmplGfx/lib/image.draw.rect.ci:13: (2 bytes): t: int32 := y0
	<fillRect+?>: dup.x32 sp(5)
	cmplGfx/lib/image.draw.rect.ci:14: (3 bytes): y0 := y1;
	<fillRect+?>: mov.x32 sp(6, 4)
	<fillRect+?>: set.x32 sp(4)
	<fillRect+?>: dup.x32 sp(4)
	<fillRect+?>: dup.x32 sp(3)
	<fillRect+?>: add.i32
	<fillRect+?>: set.x32 sp(5)
	cmplGfx/lib/image.draw.rect.ci:18: (7 bytes): y1 := y1 + incl;
	<fillRect+?>: dup.x32 sp(3)
	<fillRect+?>: dup.x32 sp(3)
	<fillRect+?>: add.i32
	<fillRect+?>: set.x32 sp(4)
	cmplGfx/lib/image.draw.rect.ci:20: (58 bytes): for (y: int32 := y0; y < y1; y := y + 1)
	<fillRect+?>: dup.x32 sp(5)
	<fillRect+?>: jmp +43
	cmplGfx/lib/image.draw.rect.ci:21: (35 bytes): for (x: int32 := x0; x < x1; x := x + 1)
	<fillRect+?>: dup.x32 sp(7)
	<fillRect+?>: jmp +20
	cmplGfx/lib/image.draw.rect.ci:22: (12 bytes): Image.set(image, x, y, color);
	<fillRect+?>: dup.x64 sp(9)
	<fillRect+?>: dup.x32 sp(2)
	<fillRect+?>: dup.x32 sp(4)
	<fillRect+?>: dup.x32 sp(7)
	<fillRect+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	cmplGfx/lib/image.draw.rect.ci:21: (4 bytes): x := x + 1
	<fillRect+?>: inc.i32(+1)
	cmplGfx/lib/image.draw.rect.ci:21: (9 bytes): x < x1
	<fillRect+?>: dup.x32 sp(0)
	<fillRect+?>: dup.x32 sp(7)
	<fillRect+?>: clt.i32
	<fillRect+?>: jnz -21
	<fillRect+?>: inc.sp(-4)
	cmplGfx/lib/image.draw.rect.ci:20: (4 bytes): y := y + 1
	<fillRect+?>: inc.i32(+1)
	cmplGfx/lib/image.draw.rect.ci:20: (9 bytes): y < y1
	<fillRect+?>: dup.x32 sp(0)
	<fillRect+?>: dup.x32 sp(5)
	<fillRect+?>: clt.i32
	<fillRect+?>: jnz -44
	<fillRect+?>: inc.sp(-4)
	<fillRect+?>: ret
.usages:
	cmplGfx/lib/image.draw.line.ci:7: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:121: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:120: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:103: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:102: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:79: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:57: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:45: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:44: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:28: referenced as `fillRect`
	cmplGfx/lib/image.draw.rrect.ci:20: referenced as `fillRect`
	cmplGfx/lib/image.draw.rect.ci:28: referenced as `fillRect`
}
fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fillRect'
.file: 'cmplGfx/lib/image.draw.rect.ci:28'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param x0: int32 (size: 4, cast: i32)
.param y0: int32 (size: 4, cast: i32)
.param x1: int32 (size: 4, cast: i32)
.param y1: int32 (size: 4, cast: i32)
.param color: uint32 (size: 4, cast: u32)
.doc: 'Fill a rectangle on the `image` specified by the coordinates with the given `color`'
.value: fillRect(image, x0, y0, x1, y1, 0, color)
.usages:
	cmplGfx/lib/micro.ui.ci:585: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:461: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:446: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:445: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:444: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:443: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:441: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:312: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:309: referenced as `fillRect`
	cmplGfx/lib/image.draw.ci:15: referenced as `fillRect`
	cmplGfx/lib/image.draw.rect.ci:69: referenced as `fillRect`
	cmplGfx/lib/image.draw.rect.ci:58: referenced as `fillRect`
	cmplGfx/lib/image.draw.rect.ci:57: referenced as `fillRect`
	cmplGfx/lib/image.draw.rect.ci:56: referenced as `fillRect`
	cmplGfx/lib/image.draw.rect.ci:55: referenced as `fillRect`
	cmplGfx/lib/image.draw.rect.ci:52: referenced as `fillRect`
}
drawRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, width: int32, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 275
.name: 'drawRect'
.file: 'cmplGfx/lib/image.draw.rect.ci:31'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param width: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Draw a rectangle on the `image` specified by the coordinates with the given `width` and `color`'
.value: {
	if (y0 > y1) {
		t: int32 := y1;
		y1 := y0;
		y0 := t;
	}
	if (x0 > x1) {
		t: int32 := x1;
		x1 := x0;
		x0 := t;
	}
	half1: int32 := (width - 0) / 2;
	half2: int32 := (width - 1) / 2;
	x0 := x0 - half1;
	y0 := y0 - half1;
	x1 := x1 + half2;
	y1 := y1 + half2;
	if (x1 - x0 <= 2 * width || y1 - y0 <= 2 * width) {
		return .result := fillRect(image, x0, y0, x1, y1, color);
	}
	fillRect(image, x0, y0, x1, y0 + width, color);
	fillRect(image, x0, y0 + width, x0 + width, y1 - width, color);
	fillRect(image, x1 - width, y0 + width, x1, y1 - width, color);
	fillRect(image, x0, y1 - width, x1, y1, color);
}
.instructions: (275 bytes)
	cmplGfx/lib/image.draw.rect.ci:32: (16 bytes): if (y0 > y1)
	<drawRect>  : dup.x32 sp(5)
	<drawRect+?>: dup.x32 sp(4)
	<drawRect+?>: cgt.i32
	<drawRect+?>: jz +11
	cmplGfx/lib/image.draw.rect.ci:33: (2 bytes): t: int32 := y1
	<drawRect+?>: dup.x32 sp(3)
	cmplGfx/lib/image.draw.rect.ci:34: (3 bytes): y1 := y0;
	<drawRect+?>: mov.x32 sp(4, 6)
	<drawRect+?>: set.x32 sp(6)
	<drawRect+?>: dup.x32 sp(6)
	<drawRect+?>: dup.x32 sp(5)
	<drawRect+?>: cgt.i32
	<drawRect+?>: jz +11
	cmplGfx/lib/image.draw.rect.ci:38: (2 bytes): t: int32 := x1
	<drawRect+?>: dup.x32 sp(4)
	cmplGfx/lib/image.draw.rect.ci:39: (3 bytes): x1 := x0;
	<drawRect+?>: mov.x32 sp(5, 7)
	<drawRect+?>: set.x32 sp(7)
	<drawRect+?>: dup.x32 sp(2)
	<drawRect+?>: load.z32
	<drawRect+?>: sub.i32
	<drawRect+?>: load.c32 2
	<drawRect+?>: div.i32
	cmplGfx/lib/image.draw.rect.ci:44: (12 bytes): half2: int32 := (width - 1) / 2
	<drawRect+?>: dup.x32 sp(3)
	<drawRect+?>: inc.i32(-1)
	<drawRect+?>: load.c32 2
	<drawRect+?>: div.i32
	cmplGfx/lib/image.draw.rect.ci:45: (7 bytes): x0 := x0 - half1;
	<drawRect+?>: dup.x32 sp(8)
	<drawRect+?>: dup.x32 sp(2)
	<drawRect+?>: sub.i32
	<drawRect+?>: set.x32 sp(9)
	cmplGfx/lib/image.draw.rect.ci:46: (7 bytes): y0 := y0 - half1;
	<drawRect+?>: dup.x32 sp(7)
	<drawRect+?>: dup.x32 sp(2)
	<drawRect+?>: sub.i32
	<drawRect+?>: set.x32 sp(8)
	cmplGfx/lib/image.draw.rect.ci:47: (7 bytes): x1 := x1 + half2;
	<drawRect+?>: dup.x32 sp(6)
	<drawRect+?>: dup.x32 sp(1)
	<drawRect+?>: add.i32
	<drawRect+?>: set.x32 sp(7)
	cmplGfx/lib/image.draw.rect.ci:48: (7 bytes): y1 := y1 + half2;
	<drawRect+?>: dup.x32 sp(5)
	<drawRect+?>: dup.x32 sp(1)
	<drawRect+?>: add.i32
	<drawRect+?>: set.x32 sp(6)
	cmplGfx/lib/image.draw.rect.ci:50: (72 bytes): if (x1 - x0 <= 2 * width || y1 - y0 <= 2 * width)
	<drawRect+?>: dup.x32 sp(6)
	<drawRect+?>: dup.x32 sp(9)
	<drawRect+?>: sub.i32
	<drawRect+?>: load.c32 2
	<drawRect+?>: dup.x32 sp(6)
	<drawRect+?>: mul.i32
	<drawRect+?>: cgt.i32
	<drawRect+?>: not.b32
	<drawRect+?>: dup.x32 sp(0)
	<drawRect+?>: jnz +23
	<drawRect+?>: inc.sp(-4)
	<drawRect+?>: dup.x32 sp(5)
	<drawRect+?>: dup.x32 sp(8)
	<drawRect+?>: sub.i32
	<drawRect+?>: load.c32 2
	<drawRect+?>: dup.x32 sp(6)
	<drawRect+?>: mul.i32
	<drawRect+?>: cgt.i32
	<drawRect+?>: not.b32
	<drawRect+?>: jz +32
	cmplGfx/lib/image.draw.rect.ci:52: (28 bytes): return .result := fillRect(image, x0, y0, x1, y1, color);
	<drawRect+?>: dup.x64 sp(9)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: load.z32
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRect+?>: call
	<drawRect+?>: inc.sp(-32)
	<drawRect+?>: inc.sp(-8)
	<drawRect+?>: ret
	cmplGfx/lib/image.draw.rect.ci:55: (26 bytes): fillRect(image, x0, y0, x1, y0 + width, color);
	<drawRect+?>: dup.x64 sp(9)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(12)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: add.i32
	<drawRect+?>: load.z32
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRect+?>: call
	<drawRect+?>: inc.sp(-32)
	cmplGfx/lib/image.draw.rect.ci:56: (32 bytes): fillRect(image, x0, y0 + width, x0 + width, y1 - width, color);
	<drawRect+?>: dup.x64 sp(9)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(8)
	<drawRect+?>: add.i32
	<drawRect+?>: dup.x32 sp(12)
	<drawRect+?>: dup.x32 sp(9)
	<drawRect+?>: add.i32
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: sub.i32
	<drawRect+?>: load.z32
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRect+?>: call
	<drawRect+?>: inc.sp(-32)
	cmplGfx/lib/image.draw.rect.ci:57: (32 bytes): fillRect(image, x1 - width, y0 + width, x1, y1 - width, color);
	<drawRect+?>: dup.x64 sp(9)
	<drawRect+?>: dup.x32 sp(8)
	<drawRect+?>: dup.x32 sp(7)
	<drawRect+?>: sub.i32
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(8)
	<drawRect+?>: add.i32
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: sub.i32
	<drawRect+?>: load.z32
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRect+?>: call
	<drawRect+?>: inc.sp(-32)
	cmplGfx/lib/image.draw.rect.ci:58: (26 bytes): fillRect(image, x0, y1 - width, x1, y1, color);
	<drawRect+?>: dup.x64 sp(9)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(8)
	<drawRect+?>: dup.x32 sp(8)
	<drawRect+?>: sub.i32
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: load.z32
	<drawRect+?>: dup.x32 sp(10)
	<drawRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRect+?>: call
	<drawRect+?>: inc.sp(-32)
	<drawRect+?>: inc.sp(-8)
	<drawRect+?>: ret
.usages:
	cmplGfx/lib/image.draw.rrect.ci:87: referenced as `drawRect`
	cmplGfx/lib/image.draw.rect.ci:77: referenced as `drawRect`
	cmplGfx/lib/image.draw.rect.ci:62: referenced as `drawRect`
}
drawRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'drawRect'
.file: 'cmplGfx/lib/image.draw.rect.ci:62'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param x0: int32 (size: 4, cast: i32)
.param y0: int32 (size: 4, cast: i32)
.param x1: int32 (size: 4, cast: i32)
.param y1: int32 (size: 4, cast: i32)
.param color: uint32 (size: 4, cast: u32)
.doc: 'Draw a rectangle on the `image` specified by the coordinates with the given `color`'
.value: drawRect(image, x0, y0, x1, y1, 1, color)
.usages:
}
fillRect(image: Image, roi: Rect, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 58
.name: 'fillRect'
.file: 'cmplGfx/lib/image.draw.rect.ci:65'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Fill a rectangle on the `image` specified by `roi` with the given `color`'
.value: {
	if (empty(roi)) {
		return;
	}
	fillRect(image, roi.x0, roi.y0, roi.x1, roi.y1, color);
}
.instructions: (58 bytes)
	cmplGfx/lib/image.draw.rect.ci:66: (18 bytes): if (empty(roi))
	<fillRect>  : load.z32
	<fillRect+?>: dup.x32 sp(3)
	<fillRect+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<fillRect+?>: call
	<fillRect+?>: inc.sp(-4)
	<fillRect+?>: jz +5
	cmplGfx/lib/image.draw.rect.ci:67: (1 byte): return;
	<fillRect+?>: ret
	cmplGfx/lib/image.draw.rect.ci:69: (39 bytes): fillRect(image, roi.x0, roi.y0, roi.x1, roi.y1, color);
	<fillRect+?>: dup.x64 sp(3)
	<fillRect+?>: dup.x32 sp(4)
	<fillRect+?>: load.i32
	<fillRect+?>: dup.x32 sp(5)
	<fillRect+?>: inc.i32(+4)
	<fillRect+?>: load.i32
	<fillRect+?>: dup.x32 sp(6)
	<fillRect+?>: inc.i32(+8)
	<fillRect+?>: load.i32
	<fillRect+?>: dup.x32 sp(7)
	<fillRect+?>: inc.i32(+12)
	<fillRect+?>: load.i32
	<fillRect+?>: load.z32
	<fillRect+?>: dup.x32 sp(8)
	<fillRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<fillRect+?>: call
	<fillRect+?>: inc.sp(-32)
	<fillRect+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:667: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:659: referenced as `fillRect`
	cmplGfx/lib/micro.ui.ci:653: referenced as `fillRect`
	cmplGfx/lib/micro.ui.core.ci:1225: referenced as `fillRect`
	cmplGfx/lib/micro.ui.core.ci:356: referenced as `fillRect`
	cmplGfx/lib/micro.ui.core.ci:353: referenced as `fillRect`
	cmplGfx/lib/micro.ui.core.ci:350: referenced as `fillRect`
}
drawRect(image: Image, roi: Rect, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 62
.name: 'drawRect'
.file: 'cmplGfx/lib/image.draw.rect.ci:73'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Draw a rectangle on the `image` specified by `roi` with the given `color`'
.value: {
	if (empty(roi)) {
		return;
	}
	drawRect(image, roi.x0, roi.y0, roi.x1, roi.y1, 1, color);
}
.instructions: (62 bytes)
	cmplGfx/lib/image.draw.rect.ci:74: (18 bytes): if (empty(roi))
	<drawRect>  : load.z32
	<drawRect+?>: dup.x32 sp(3)
	<drawRect+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<drawRect+?>: call
	<drawRect+?>: inc.sp(-4)
	<drawRect+?>: jz +5
	cmplGfx/lib/image.draw.rect.ci:75: (1 byte): return;
	<drawRect+?>: ret
	cmplGfx/lib/image.draw.rect.ci:77: (43 bytes): drawRect(image, roi.x0, roi.y0, roi.x1, roi.y1, 1, color);
	<drawRect+?>: dup.x64 sp(3)
	<drawRect+?>: dup.x32 sp(4)
	<drawRect+?>: load.i32
	<drawRect+?>: dup.x32 sp(5)
	<drawRect+?>: inc.i32(+4)
	<drawRect+?>: load.i32
	<drawRect+?>: dup.x32 sp(6)
	<drawRect+?>: inc.i32(+8)
	<drawRect+?>: load.i32
	<drawRect+?>: dup.x32 sp(7)
	<drawRect+?>: inc.i32(+12)
	<drawRect+?>: load.i32
	<drawRect+?>: load.c32 1
	<drawRect+?>: dup.x32 sp(8)
	<drawRect+?>: load.ref <?> ;drawRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, width: int32, color: uint32): void
	<drawRect+?>: call
	<drawRect+?>: inc.sp(-32)
	<drawRect+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:360: referenced as `drawRect`
}
fillRRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, rx: int32, ry: int32, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 562
.name: 'fillRRect'
.file: 'cmplGfx/lib/image.draw.rrect.ci:2'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param rx: int32 (size: 4, cast: variable(i32))
.param ry: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Fill a rounded rectangle on `image` specified by the coordinates and rounding, with the given `color`'
.value: {
	if (x0 > x1) {
		t: int32 := x0;
		x0 := x1;
		x1 := t;
	}
	if (y0 > y1) {
		t: int32 := y0;
		y0 := y1;
		y1 := t;
	}
	x1 := x1 - int32(x1 > x0);
	y1 := y1 - int32(y1 > y0);
	dx: int32 := x1 - x0;
	dy: int32 := y1 - y0;
	if (dx < 3 || dy < 3) {
		return .result := fillRect(image, x0, y0, x1, y1, 1, color);
	}
	ry := Math.min(ry, (dy - int32(dx > 16)) / 2);
	rx := Math.min(rx, (dx - int32(dy > 16)) / 2);
	if (rx < 8 || ry < 8) {
		if (rx < 1 || ry < 1) {
			return .result := fillRect(image, x0, y0, x1, y1, 1, color);
		}
		rx := rx + int32(rx == 7) - int32(rx == 6);
		ry := ry + int32(ry == 7) - int32(ry == 6);
	}
	sx: int64 := rx * rx;
	sy: int64 := ry * ry;
	rdy: int64 := sx * (ry);
	rdx: int64 := 0;
	r: int64 := rdy / (2);
	x0 := x0 + rx;
	x1 := x1 - rx;
	for ( ; y0 < y1; ) {
		fillRect(image, x0, y0, x1, y0, 1, color);
		fillRect(image, x0, y1, x1, y1, 1, color);
		if (r >= (0)) {
			x0 := x0 - 1;
			x1 := x1 + 1;
			r := r - (rdx := rdx + sy);
		}
		if (r < (0)) {
			y0 := y0 + 1;
			y1 := y1 - 1;
			r := r + (rdy := rdy - sx);
		}
	}
	fillRect(image, x0, y0, x1, y1, 1, color);
}
.instructions: (562 bytes)
	cmplGfx/lib/image.draw.rrect.ci:3: (16 bytes): if (x0 > x1)
	<fillRRect>  : dup.x32 sp(7)
	<fillRRect+?>: dup.x32 sp(6)
	<fillRRect+?>: cgt.i32
	<fillRRect+?>: jz +11
	cmplGfx/lib/image.draw.rrect.ci:4: (2 bytes): t: int32 := x0
	<fillRRect+?>: dup.x32 sp(7)
	cmplGfx/lib/image.draw.rrect.ci:5: (3 bytes): x0 := x1;
	<fillRRect+?>: mov.x32 sp(8, 6)
	<fillRRect+?>: set.x32 sp(6)
	<fillRRect+?>: dup.x32 sp(6)
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: cgt.i32
	<fillRRect+?>: jz +11
	cmplGfx/lib/image.draw.rrect.ci:9: (2 bytes): t: int32 := y0
	<fillRRect+?>: dup.x32 sp(6)
	cmplGfx/lib/image.draw.rrect.ci:10: (3 bytes): y0 := y1;
	<fillRRect+?>: mov.x32 sp(7, 5)
	<fillRRect+?>: set.x32 sp(5)
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: dup.x32 sp(6)
	<fillRRect+?>: dup.x32 sp(9)
	<fillRRect+?>: cgt.i32
	<fillRRect+?>: sub.i32
	<fillRRect+?>: set.x32 sp(6)
	cmplGfx/lib/image.draw.rrect.ci:14: (10 bytes): y1 := y1 - int32(y1 > y0);
	<fillRRect+?>: dup.x32 sp(4)
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: dup.x32 sp(8)
	<fillRRect+?>: cgt.i32
	<fillRRect+?>: sub.i32
	<fillRRect+?>: set.x32 sp(5)
	cmplGfx/lib/image.draw.rrect.ci:16: (5 bytes): dx: int32 := x1 - x0
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: dup.x32 sp(8)
	<fillRRect+?>: sub.i32
	cmplGfx/lib/image.draw.rrect.ci:17: (5 bytes): dy: int32 := y1 - y0
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: dup.x32 sp(8)
	<fillRRect+?>: sub.i32
	cmplGfx/lib/image.draw.rrect.ci:18: (62 bytes): if (dx < 3 || dy < 3)
	<fillRRect+?>: dup.x32 sp(1)
	<fillRRect+?>: load.c32 3
	<fillRRect+?>: clt.i32
	<fillRRect+?>: dup.x32 sp(0)
	<fillRRect+?>: jnz +16
	<fillRRect+?>: inc.sp(-4)
	<fillRRect+?>: dup.x32 sp(0)
	<fillRRect+?>: load.c32 3
	<fillRRect+?>: clt.i32
	<fillRRect+?>: jz +36
	cmplGfx/lib/image.draw.rrect.ci:20: (32 bytes): return .result := fillRect(image, x0, y0, x1, y1, 1, color);
	<fillRRect+?>: dup.x64 sp(10)
	<fillRRect+?>: dup.x32 sp(11)
	<fillRRect+?>: dup.x32 sp(11)
	<fillRRect+?>: dup.x32 sp(11)
	<fillRRect+?>: dup.x32 sp(11)
	<fillRRect+?>: load.c32 1
	<fillRRect+?>: dup.x32 sp(10)
	<fillRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<fillRRect+?>: call
	<fillRRect+?>: inc.sp(-32)
	<fillRRect+?>: inc.sp(-8)
	<fillRRect+?>: ret
	cmplGfx/lib/image.draw.rrect.ci:23: (45 bytes): ry := Math.min(ry, (dy - int32(dx > 16)) / 2);
	<fillRRect+?>: dup.x32 sp(4)
	<fillRRect+?>: dup.x32 sp(1)
	<fillRRect+?>: dup.x32 sp(3)
	<fillRRect+?>: load.c32 16
	<fillRRect+?>: cgt.i32
	<fillRRect+?>: sub.i32
	<fillRRect+?>: load.c32 2
	<fillRRect+?>: div.i32
	<fillRRect+?>: dup.x32 sp(1)
	<fillRRect+?>: dup.x32 sp(1)
	<fillRRect+?>: clt.i32
	<fillRRect+?>: jz +10
	<fillRRect+?>: dup.x32 sp(1)
	<fillRRect+?>: jmp +6
	<fillRRect+?>: dup.x32 sp(0)
	<fillRRect+?>: mov.x32 sp(2, 0)
	<fillRRect+?>: inc.sp(-8)
	<fillRRect+?>: set.x32 sp(5)
	cmplGfx/lib/image.draw.rrect.ci:24: (45 bytes): rx := Math.min(rx, (dx - int32(dy > 16)) / 2);
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: dup.x32 sp(2)
	<fillRRect+?>: dup.x32 sp(2)
	<fillRRect+?>: load.c32 16
	<fillRRect+?>: cgt.i32
	<fillRRect+?>: sub.i32
	<fillRRect+?>: load.c32 2
	<fillRRect+?>: div.i32
	<fillRRect+?>: dup.x32 sp(1)
	<fillRRect+?>: dup.x32 sp(1)
	<fillRRect+?>: clt.i32
	<fillRRect+?>: jz +10
	<fillRRect+?>: dup.x32 sp(1)
	<fillRRect+?>: jmp +6
	<fillRRect+?>: dup.x32 sp(0)
	<fillRRect+?>: mov.x32 sp(2, 0)
	<fillRRect+?>: inc.sp(-8)
	<fillRRect+?>: set.x32 sp(6)
	cmplGfx/lib/image.draw.rrect.ci:25: (136 bytes): if (rx < 8 || ry < 8)
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: load.c32 8
	<fillRRect+?>: clt.i32
	<fillRRect+?>: dup.x32 sp(0)
	<fillRRect+?>: jnz +16
	<fillRRect+?>: inc.sp(-4)
	<fillRRect+?>: dup.x32 sp(4)
	<fillRRect+?>: load.c32 8
	<fillRRect+?>: clt.i32
	<fillRRect+?>: jz +110
	cmplGfx/lib/image.draw.rrect.ci:26: (62 bytes): if (rx < 1 || ry < 1)
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: load.c32 1
	<fillRRect+?>: clt.i32
	<fillRRect+?>: dup.x32 sp(0)
	<fillRRect+?>: jnz +16
	<fillRRect+?>: inc.sp(-4)
	<fillRRect+?>: dup.x32 sp(4)
	<fillRRect+?>: load.c32 1
	<fillRRect+?>: clt.i32
	<fillRRect+?>: jz +36
	cmplGfx/lib/image.draw.rrect.ci:28: (32 bytes): return .result := fillRect(image, x0, y0, x1, y1, 1, color);
	<fillRRect+?>: dup.x64 sp(10)
	<fillRRect+?>: dup.x32 sp(11)
	<fillRRect+?>: dup.x32 sp(11)
	<fillRRect+?>: dup.x32 sp(11)
	<fillRRect+?>: dup.x32 sp(11)
	<fillRRect+?>: load.c32 1
	<fillRRect+?>: dup.x32 sp(10)
	<fillRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<fillRRect+?>: call
	<fillRRect+?>: inc.sp(-32)
	<fillRRect+?>: inc.sp(-8)
	<fillRRect+?>: ret
	cmplGfx/lib/image.draw.rrect.ci:31: (22 bytes): rx := rx + int32(rx == 7) - int32(rx == 6);
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: dup.x32 sp(6)
	<fillRRect+?>: load.c32 7
	<fillRRect+?>: ceq.i32
	<fillRRect+?>: dup.x32 sp(7)
	<fillRRect+?>: load.c32 6
	<fillRRect+?>: ceq.i32
	<fillRRect+?>: sub.i32
	<fillRRect+?>: add.i32
	<fillRRect+?>: set.x32 sp(6)
	cmplGfx/lib/image.draw.rrect.ci:32: (22 bytes): ry := ry + int32(ry == 7) - int32(ry == 6);
	<fillRRect+?>: dup.x32 sp(4)
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: load.c32 7
	<fillRRect+?>: ceq.i32
	<fillRRect+?>: dup.x32 sp(6)
	<fillRRect+?>: load.c32 6
	<fillRRect+?>: ceq.i32
	<fillRRect+?>: sub.i32
	<fillRRect+?>: add.i32
	<fillRRect+?>: set.x32 sp(5)
	cmplGfx/lib/image.draw.rrect.ci:35: (6 bytes): sx: int64 := rx * rx
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: dup.x32 sp(6)
	<fillRRect+?>: mul.i32
	<fillRRect+?>: i32.2i64
	cmplGfx/lib/image.draw.rrect.ci:36: (6 bytes): sy: int64 := ry * ry
	<fillRRect+?>: dup.x32 sp(6)
	<fillRRect+?>: dup.x32 sp(7)
	<fillRRect+?>: mul.i32
	<fillRRect+?>: i32.2i64
	cmplGfx/lib/image.draw.rrect.ci:37: (6 bytes): rdy: int64 := sx * (ry)
	<fillRRect+?>: dup.x64 sp(2)
	<fillRRect+?>: dup.x32 sp(10)
	<fillRRect+?>: i32.2i64
	<fillRRect+?>: mul.i64
	cmplGfx/lib/image.draw.rrect.ci:38: (1 byte): rdx: int64 := 0
	<fillRRect+?>: load.z64
	cmplGfx/lib/image.draw.rrect.ci:39: (12 bytes): r: int64 := rdy / (2)
	<fillRRect+?>: dup.x64 sp(2)
	<fillRRect+?>: load.c64 2
	<fillRRect+?>: div.i64
	cmplGfx/lib/image.draw.rrect.ci:41: (7 bytes): x0 := x0 + rx;
	<fillRRect+?>: dup.x32 sp(19)
	<fillRRect+?>: dup.x32 sp(16)
	<fillRRect+?>: add.i32
	<fillRRect+?>: set.x32 sp(20)
	cmplGfx/lib/image.draw.rrect.ci:42: (7 bytes): x1 := x1 - rx;
	<fillRRect+?>: dup.x32 sp(17)
	<fillRRect+?>: dup.x32 sp(16)
	<fillRRect+?>: sub.i32
	<fillRRect+?>: set.x32 sp(18)
	cmplGfx/lib/image.draw.rrect.ci:43: (135 bytes): for ( ; y0 < y1; )
	<fillRRect+?>: jmp +126
	cmplGfx/lib/image.draw.rrect.ci:44: (27 bytes): fillRect(image, x0, y0, x1, y0, 1, color);
	<fillRRect+?>: dup.x64 sp(20)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: dup.x32 sp(23)
	<fillRRect+?>: load.c32 1
	<fillRRect+?>: dup.x32 sp(20)
	<fillRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<fillRRect+?>: call
	<fillRRect+?>: inc.sp(-32)
	cmplGfx/lib/image.draw.rrect.ci:45: (27 bytes): fillRect(image, x0, y1, x1, y1, 1, color);
	<fillRRect+?>: dup.x64 sp(20)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: dup.x32 sp(19)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: load.c32 1
	<fillRRect+?>: dup.x32 sp(20)
	<fillRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<fillRRect+?>: call
	<fillRRect+?>: inc.sp(-32)
	cmplGfx/lib/image.draw.rrect.ci:46: (34 bytes): if (r >= (0))
	<fillRRect+?>: dup.x64 sp(0)
	<fillRRect+?>: load.z64
	<fillRRect+?>: clt.i64
	<fillRRect+?>: jnz +30
	cmplGfx/lib/image.draw.rrect.ci:47: (8 bytes): x0 := x0 - 1;
	<fillRRect+?>: dup.x32 sp(19)
	<fillRRect+?>: inc.i32(-1)
	<fillRRect+?>: set.x32 sp(20)
	cmplGfx/lib/image.draw.rrect.ci:48: (8 bytes): x1 := x1 + 1;
	<fillRRect+?>: dup.x32 sp(17)
	<fillRRect+?>: inc.i32(+1)
	<fillRRect+?>: set.x32 sp(18)
	cmplGfx/lib/image.draw.rrect.ci:49: (10 bytes): r := r - (rdx := rdx + sy);
	<fillRRect+?>: dup.x64 sp(2)
	<fillRRect+?>: dup.x64 sp(8)
	<fillRRect+?>: add.i64
	<fillRRect+?>: dup.x64 sp(0)
	<fillRRect+?>: set.x64 sp(6)
	<fillRRect+?>: sub.i64
	cmplGfx/lib/image.draw.rrect.ci:51: (34 bytes): if (r < (0))
	<fillRRect+?>: dup.x64 sp(0)
	<fillRRect+?>: load.z64
	<fillRRect+?>: clt.i64
	<fillRRect+?>: jz +30
	cmplGfx/lib/image.draw.rrect.ci:52: (8 bytes): y0 := y0 + 1;
	<fillRRect+?>: dup.x32 sp(18)
	<fillRRect+?>: inc.i32(+1)
	<fillRRect+?>: set.x32 sp(19)
	cmplGfx/lib/image.draw.rrect.ci:53: (8 bytes): y1 := y1 - 1;
	<fillRRect+?>: dup.x32 sp(16)
	<fillRRect+?>: inc.i32(-1)
	<fillRRect+?>: set.x32 sp(17)
	cmplGfx/lib/image.draw.rrect.ci:54: (10 bytes): r := r + (rdy := rdy - sx);
	<fillRRect+?>: dup.x64 sp(4)
	<fillRRect+?>: dup.x64 sp(10)
	<fillRRect+?>: sub.i64
	<fillRRect+?>: dup.x64 sp(0)
	<fillRRect+?>: set.x64 sp(8)
	<fillRRect+?>: add.i64
	cmplGfx/lib/image.draw.rrect.ci:43: (9 bytes): y0 < y1
	<fillRRect+?>: dup.x32 sp(18)
	<fillRRect+?>: dup.x32 sp(17)
	<fillRRect+?>: clt.i32
	<fillRRect+?>: jnz -127
	cmplGfx/lib/image.draw.rrect.ci:57: (27 bytes): fillRect(image, x0, y0, x1, y1, 1, color);
	<fillRRect+?>: dup.x64 sp(20)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: dup.x32 sp(21)
	<fillRRect+?>: load.c32 1
	<fillRRect+?>: dup.x32 sp(20)
	<fillRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<fillRRect+?>: call
	<fillRRect+?>: inc.sp(-32)
	<fillRRect+?>: inc.sp(-48)
	<fillRRect+?>: ret
.usages:
	cmplGfx/lib/image.draw.oval.ci:2: referenced as `fillRRect`
	cmplGfx/lib/image.draw.rrect.ci:135: referenced as `fillRRect`
	cmplGfx/lib/image.draw.rrect.ci:125: referenced as `fillRRect`
}
drawRRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, rx: int32, ry: int32, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 645
.name: 'drawRRect'
.file: 'cmplGfx/lib/image.draw.rrect.ci:61'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param rx: int32 (size: 4, cast: variable(i32))
.param ry: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Draw a rounded rectangle on `image` specified by the coordinates and rounding, with the given `color`'
.value: {
	if (x0 > x1) {
		t: int32 := x0;
		x0 := x1;
		x1 := t;
	}
	if (y0 > y1) {
		t: int32 := y0;
		y0 := y1;
		y1 := t;
	}
	x1 := x1 - int32(x1 > x0);
	y1 := y1 - int32(y1 > y0);
	dx: int32 := x1 - x0;
	dy: int32 := y1 - y0;
	if (dx < 2 || dy < 2) {
		return .result := fillRect(image, x0, y0, x1, y1, 1, color);
	}
	ry := Math.min(ry, (dy - int32(dx > 16)) / 2);
	rx := Math.min(rx, (dx - int32(dy > 16)) / 2);
	if (rx < 8 || ry < 8) {
		if (rx < 1 || ry < 1) {
			return .result := drawRect(image, x0, y0, x1 + 1, y1 + 1, 1, color);
		}
		rx := rx + int32(rx == 7) - int32(rx == 6);
		ry := ry + int32(ry == 7) - int32(ry == 6);
	}
	sx: int64 := rx * rx;
	sy: int64 := ry * ry;
	rdy: int64 := sx * (ry);
	rdx: int64 := 0;
	r: int64 := rdy / (2);
	x0 := x0 + rx;
	x1 := x1 - rx;
	fillRect(image, x0, y0, x1, y0, 1, color);
	fillRect(image, x0, y1, x1, y1, 1, color);
	for ( ; y0 < y1; ) {
		Image.set(image, x0, y0, color);
		Image.set(image, x1, y0, color);
		Image.set(image, x0, y1, color);
		Image.set(image, x1, y1, color);
		if (r >= (0)) {
			x0 := x0 - 1;
			x1 := x1 + 1;
			r := r - (rdx := rdx + sy);
		}
		if (r < (0)) {
			y0 := y0 + 1;
			y1 := y1 - 1;
			r := r + (rdy := rdy - sx);
		}
	}
	fillRect(image, x0, y0, x0, y1, 1, color);
	fillRect(image, x1, y0, x1, y1, 1, color);
}
.instructions: (645 bytes)
	cmplGfx/lib/image.draw.rrect.ci:62: (16 bytes): if (x0 > x1)
	<drawRRect>  : dup.x32 sp(7)
	<drawRRect+?>: dup.x32 sp(6)
	<drawRRect+?>: cgt.i32
	<drawRRect+?>: jz +11
	cmplGfx/lib/image.draw.rrect.ci:63: (2 bytes): t: int32 := x0
	<drawRRect+?>: dup.x32 sp(7)
	cmplGfx/lib/image.draw.rrect.ci:64: (3 bytes): x0 := x1;
	<drawRRect+?>: mov.x32 sp(8, 6)
	<drawRRect+?>: set.x32 sp(6)
	<drawRRect+?>: dup.x32 sp(6)
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: cgt.i32
	<drawRRect+?>: jz +11
	cmplGfx/lib/image.draw.rrect.ci:68: (2 bytes): t: int32 := y0
	<drawRRect+?>: dup.x32 sp(6)
	cmplGfx/lib/image.draw.rrect.ci:69: (3 bytes): y0 := y1;
	<drawRRect+?>: mov.x32 sp(7, 5)
	<drawRRect+?>: set.x32 sp(5)
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: dup.x32 sp(6)
	<drawRRect+?>: dup.x32 sp(9)
	<drawRRect+?>: cgt.i32
	<drawRRect+?>: sub.i32
	<drawRRect+?>: set.x32 sp(6)
	cmplGfx/lib/image.draw.rrect.ci:73: (10 bytes): y1 := y1 - int32(y1 > y0);
	<drawRRect+?>: dup.x32 sp(4)
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: dup.x32 sp(8)
	<drawRRect+?>: cgt.i32
	<drawRRect+?>: sub.i32
	<drawRRect+?>: set.x32 sp(5)
	cmplGfx/lib/image.draw.rrect.ci:75: (5 bytes): dx: int32 := x1 - x0
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: dup.x32 sp(8)
	<drawRRect+?>: sub.i32
	cmplGfx/lib/image.draw.rrect.ci:76: (5 bytes): dy: int32 := y1 - y0
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: dup.x32 sp(8)
	<drawRRect+?>: sub.i32
	cmplGfx/lib/image.draw.rrect.ci:77: (62 bytes): if (dx < 2 || dy < 2)
	<drawRRect+?>: dup.x32 sp(1)
	<drawRRect+?>: load.c32 2
	<drawRRect+?>: clt.i32
	<drawRRect+?>: dup.x32 sp(0)
	<drawRRect+?>: jnz +16
	<drawRRect+?>: inc.sp(-4)
	<drawRRect+?>: dup.x32 sp(0)
	<drawRRect+?>: load.c32 2
	<drawRRect+?>: clt.i32
	<drawRRect+?>: jz +36
	cmplGfx/lib/image.draw.rrect.ci:79: (32 bytes): return .result := fillRect(image, x0, y0, x1, y1, 1, color);
	<drawRRect+?>: dup.x64 sp(10)
	<drawRRect+?>: dup.x32 sp(11)
	<drawRRect+?>: dup.x32 sp(11)
	<drawRRect+?>: dup.x32 sp(11)
	<drawRRect+?>: dup.x32 sp(11)
	<drawRRect+?>: load.c32 1
	<drawRRect+?>: dup.x32 sp(10)
	<drawRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRRect+?>: call
	<drawRRect+?>: inc.sp(-32)
	<drawRRect+?>: inc.sp(-8)
	<drawRRect+?>: ret
	cmplGfx/lib/image.draw.rrect.ci:82: (45 bytes): ry := Math.min(ry, (dy - int32(dx > 16)) / 2);
	<drawRRect+?>: dup.x32 sp(4)
	<drawRRect+?>: dup.x32 sp(1)
	<drawRRect+?>: dup.x32 sp(3)
	<drawRRect+?>: load.c32 16
	<drawRRect+?>: cgt.i32
	<drawRRect+?>: sub.i32
	<drawRRect+?>: load.c32 2
	<drawRRect+?>: div.i32
	<drawRRect+?>: dup.x32 sp(1)
	<drawRRect+?>: dup.x32 sp(1)
	<drawRRect+?>: clt.i32
	<drawRRect+?>: jz +10
	<drawRRect+?>: dup.x32 sp(1)
	<drawRRect+?>: jmp +6
	<drawRRect+?>: dup.x32 sp(0)
	<drawRRect+?>: mov.x32 sp(2, 0)
	<drawRRect+?>: inc.sp(-8)
	<drawRRect+?>: set.x32 sp(5)
	cmplGfx/lib/image.draw.rrect.ci:83: (45 bytes): rx := Math.min(rx, (dx - int32(dy > 16)) / 2);
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: dup.x32 sp(2)
	<drawRRect+?>: dup.x32 sp(2)
	<drawRRect+?>: load.c32 16
	<drawRRect+?>: cgt.i32
	<drawRRect+?>: sub.i32
	<drawRRect+?>: load.c32 2
	<drawRRect+?>: div.i32
	<drawRRect+?>: dup.x32 sp(1)
	<drawRRect+?>: dup.x32 sp(1)
	<drawRRect+?>: clt.i32
	<drawRRect+?>: jz +10
	<drawRRect+?>: dup.x32 sp(1)
	<drawRRect+?>: jmp +6
	<drawRRect+?>: dup.x32 sp(0)
	<drawRRect+?>: mov.x32 sp(2, 0)
	<drawRRect+?>: inc.sp(-8)
	<drawRRect+?>: set.x32 sp(6)
	cmplGfx/lib/image.draw.rrect.ci:84: (144 bytes): if (rx < 8 || ry < 8)
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: load.c32 8
	<drawRRect+?>: clt.i32
	<drawRRect+?>: dup.x32 sp(0)
	<drawRRect+?>: jnz +16
	<drawRRect+?>: inc.sp(-4)
	<drawRRect+?>: dup.x32 sp(4)
	<drawRRect+?>: load.c32 8
	<drawRRect+?>: clt.i32
	<drawRRect+?>: jz +118
	cmplGfx/lib/image.draw.rrect.ci:85: (70 bytes): if (rx < 1 || ry < 1)
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: load.c32 1
	<drawRRect+?>: clt.i32
	<drawRRect+?>: dup.x32 sp(0)
	<drawRRect+?>: jnz +16
	<drawRRect+?>: inc.sp(-4)
	<drawRRect+?>: dup.x32 sp(4)
	<drawRRect+?>: load.c32 1
	<drawRRect+?>: clt.i32
	<drawRRect+?>: jz +44
	cmplGfx/lib/image.draw.rrect.ci:87: (40 bytes): return .result := drawRect(image, x0, y0, x1 + 1, y1 + 1, 1, color);
	<drawRRect+?>: dup.x64 sp(10)
	<drawRRect+?>: dup.x32 sp(11)
	<drawRRect+?>: dup.x32 sp(11)
	<drawRRect+?>: dup.x32 sp(11)
	<drawRRect+?>: inc.i32(+1)
	<drawRRect+?>: dup.x32 sp(11)
	<drawRRect+?>: inc.i32(+1)
	<drawRRect+?>: load.c32 1
	<drawRRect+?>: dup.x32 sp(10)
	<drawRRect+?>: load.ref <?> ;drawRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, width: int32, color: uint32): void
	<drawRRect+?>: call
	<drawRRect+?>: inc.sp(-32)
	<drawRRect+?>: inc.sp(-8)
	<drawRRect+?>: ret
	cmplGfx/lib/image.draw.rrect.ci:90: (22 bytes): rx := rx + int32(rx == 7) - int32(rx == 6);
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: dup.x32 sp(6)
	<drawRRect+?>: load.c32 7
	<drawRRect+?>: ceq.i32
	<drawRRect+?>: dup.x32 sp(7)
	<drawRRect+?>: load.c32 6
	<drawRRect+?>: ceq.i32
	<drawRRect+?>: sub.i32
	<drawRRect+?>: add.i32
	<drawRRect+?>: set.x32 sp(6)
	cmplGfx/lib/image.draw.rrect.ci:91: (22 bytes): ry := ry + int32(ry == 7) - int32(ry == 6);
	<drawRRect+?>: dup.x32 sp(4)
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: load.c32 7
	<drawRRect+?>: ceq.i32
	<drawRRect+?>: dup.x32 sp(6)
	<drawRRect+?>: load.c32 6
	<drawRRect+?>: ceq.i32
	<drawRRect+?>: sub.i32
	<drawRRect+?>: add.i32
	<drawRRect+?>: set.x32 sp(5)
	cmplGfx/lib/image.draw.rrect.ci:94: (6 bytes): sx: int64 := rx * rx
	<drawRRect+?>: dup.x32 sp(5)
	<drawRRect+?>: dup.x32 sp(6)
	<drawRRect+?>: mul.i32
	<drawRRect+?>: i32.2i64
	cmplGfx/lib/image.draw.rrect.ci:95: (6 bytes): sy: int64 := ry * ry
	<drawRRect+?>: dup.x32 sp(6)
	<drawRRect+?>: dup.x32 sp(7)
	<drawRRect+?>: mul.i32
	<drawRRect+?>: i32.2i64
	cmplGfx/lib/image.draw.rrect.ci:96: (6 bytes): rdy: int64 := sx * (ry)
	<drawRRect+?>: dup.x64 sp(2)
	<drawRRect+?>: dup.x32 sp(10)
	<drawRRect+?>: i32.2i64
	<drawRRect+?>: mul.i64
	cmplGfx/lib/image.draw.rrect.ci:97: (1 byte): rdx: int64 := 0
	<drawRRect+?>: load.z64
	cmplGfx/lib/image.draw.rrect.ci:98: (12 bytes): r: int64 := rdy / (2)
	<drawRRect+?>: dup.x64 sp(2)
	<drawRRect+?>: load.c64 2
	<drawRRect+?>: div.i64
	cmplGfx/lib/image.draw.rrect.ci:100: (7 bytes): x0 := x0 + rx;
	<drawRRect+?>: dup.x32 sp(19)
	<drawRRect+?>: dup.x32 sp(16)
	<drawRRect+?>: add.i32
	<drawRRect+?>: set.x32 sp(20)
	cmplGfx/lib/image.draw.rrect.ci:101: (7 bytes): x1 := x1 - rx;
	<drawRRect+?>: dup.x32 sp(17)
	<drawRRect+?>: dup.x32 sp(16)
	<drawRRect+?>: sub.i32
	<drawRRect+?>: set.x32 sp(18)
	cmplGfx/lib/image.draw.rrect.ci:102: (27 bytes): fillRect(image, x0, y0, x1, y0, 1, color);
	<drawRRect+?>: dup.x64 sp(20)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(23)
	<drawRRect+?>: load.c32 1
	<drawRRect+?>: dup.x32 sp(20)
	<drawRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRRect+?>: call
	<drawRRect+?>: inc.sp(-32)
	cmplGfx/lib/image.draw.rrect.ci:103: (27 bytes): fillRect(image, x0, y1, x1, y1, 1, color);
	<drawRRect+?>: dup.x64 sp(20)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(19)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: load.c32 1
	<drawRRect+?>: dup.x32 sp(20)
	<drawRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRRect+?>: call
	<drawRRect+?>: inc.sp(-32)
	cmplGfx/lib/image.draw.rrect.ci:104: (129 bytes): for ( ; y0 < y1; )
	<drawRRect+?>: jmp +120
	cmplGfx/lib/image.draw.rrect.ci:105: (12 bytes): Image.set(image, x0, y0, color);
	<drawRRect+?>: dup.x64 sp(20)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(17)
	<drawRRect+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	cmplGfx/lib/image.draw.rrect.ci:106: (12 bytes): Image.set(image, x1, y0, color);
	<drawRRect+?>: dup.x64 sp(20)
	<drawRRect+?>: dup.x32 sp(19)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(17)
	<drawRRect+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	cmplGfx/lib/image.draw.rrect.ci:107: (12 bytes): Image.set(image, x0, y1, color);
	<drawRRect+?>: dup.x64 sp(20)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(19)
	<drawRRect+?>: dup.x32 sp(17)
	<drawRRect+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	cmplGfx/lib/image.draw.rrect.ci:108: (12 bytes): Image.set(image, x1, y1, color);
	<drawRRect+?>: dup.x64 sp(20)
	<drawRRect+?>: dup.x32 sp(19)
	<drawRRect+?>: dup.x32 sp(19)
	<drawRRect+?>: dup.x32 sp(17)
	<drawRRect+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	cmplGfx/lib/image.draw.rrect.ci:109: (34 bytes): if (r >= (0))
	<drawRRect+?>: dup.x64 sp(0)
	<drawRRect+?>: load.z64
	<drawRRect+?>: clt.i64
	<drawRRect+?>: jnz +30
	cmplGfx/lib/image.draw.rrect.ci:110: (8 bytes): x0 := x0 - 1;
	<drawRRect+?>: dup.x32 sp(19)
	<drawRRect+?>: inc.i32(-1)
	<drawRRect+?>: set.x32 sp(20)
	cmplGfx/lib/image.draw.rrect.ci:111: (8 bytes): x1 := x1 + 1;
	<drawRRect+?>: dup.x32 sp(17)
	<drawRRect+?>: inc.i32(+1)
	<drawRRect+?>: set.x32 sp(18)
	cmplGfx/lib/image.draw.rrect.ci:112: (10 bytes): r := r - (rdx := rdx + sy);
	<drawRRect+?>: dup.x64 sp(2)
	<drawRRect+?>: dup.x64 sp(8)
	<drawRRect+?>: add.i64
	<drawRRect+?>: dup.x64 sp(0)
	<drawRRect+?>: set.x64 sp(6)
	<drawRRect+?>: sub.i64
	cmplGfx/lib/image.draw.rrect.ci:114: (34 bytes): if (r < (0))
	<drawRRect+?>: dup.x64 sp(0)
	<drawRRect+?>: load.z64
	<drawRRect+?>: clt.i64
	<drawRRect+?>: jz +30
	cmplGfx/lib/image.draw.rrect.ci:115: (8 bytes): y0 := y0 + 1;
	<drawRRect+?>: dup.x32 sp(18)
	<drawRRect+?>: inc.i32(+1)
	<drawRRect+?>: set.x32 sp(19)
	cmplGfx/lib/image.draw.rrect.ci:116: (8 bytes): y1 := y1 - 1;
	<drawRRect+?>: dup.x32 sp(16)
	<drawRRect+?>: inc.i32(-1)
	<drawRRect+?>: set.x32 sp(17)
	cmplGfx/lib/image.draw.rrect.ci:117: (10 bytes): r := r + (rdy := rdy - sx);
	<drawRRect+?>: dup.x64 sp(4)
	<drawRRect+?>: dup.x64 sp(10)
	<drawRRect+?>: sub.i64
	<drawRRect+?>: dup.x64 sp(0)
	<drawRRect+?>: set.x64 sp(8)
	<drawRRect+?>: add.i64
	cmplGfx/lib/image.draw.rrect.ci:104: (9 bytes): y0 < y1
	<drawRRect+?>: dup.x32 sp(18)
	<drawRRect+?>: dup.x32 sp(17)
	<drawRRect+?>: clt.i32
	<drawRRect+?>: jnz -121
	cmplGfx/lib/image.draw.rrect.ci:120: (27 bytes): fillRect(image, x0, y0, x0, y1, 1, color);
	<drawRRect+?>: dup.x64 sp(20)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(23)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: load.c32 1
	<drawRRect+?>: dup.x32 sp(20)
	<drawRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRRect+?>: call
	<drawRRect+?>: inc.sp(-32)
	cmplGfx/lib/image.draw.rrect.ci:121: (27 bytes): fillRect(image, x1, y0, x1, y1, 1, color);
	<drawRRect+?>: dup.x64 sp(20)
	<drawRRect+?>: dup.x32 sp(19)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: dup.x32 sp(21)
	<drawRRect+?>: load.c32 1
	<drawRRect+?>: dup.x32 sp(20)
	<drawRRect+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawRRect+?>: call
	<drawRRect+?>: inc.sp(-32)
	<drawRRect+?>: inc.sp(-48)
	<drawRRect+?>: ret
.usages:
	cmplGfx/lib/image.draw.oval.ci:5: referenced as `drawRRect`
	cmplGfx/lib/image.draw.rrect.ci:128: referenced as `drawRRect`
}
fillRRect(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, r: int32, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fillRRect'
.file: 'cmplGfx/lib/image.draw.rrect.ci:125'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param x1: int32 (size: 4, cast: i32)
.param y1: int32 (size: 4, cast: i32)
.param x2: int32 (size: 4, cast: i32)
.param y2: int32 (size: 4, cast: i32)
.param r: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: u32)
.doc: 'Fill the given rectangle rounding the corners using the given radius'
.value: fillRRect(image, x1, y1, x2, y2, r, r, color)
.usages:
}
drawRRect(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, r: int32, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'drawRRect'
.file: 'cmplGfx/lib/image.draw.rrect.ci:128'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param x1: int32 (size: 4, cast: i32)
.param y1: int32 (size: 4, cast: i32)
.param x2: int32 (size: 4, cast: i32)
.param y2: int32 (size: 4, cast: i32)
.param r: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: u32)
.doc: 'Draw the given rectangle rounding the corners using the given radius'
.value: drawRRect(image, x1, y1, x2, y2, r, r, color)
.usages:
}
fillRRect(image: Image, roi: Rect, rx: int32, ry: int32, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 61
.name: 'fillRRect'
.file: 'cmplGfx/lib/image.draw.rrect.ci:131'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param rx: int32 (size: 4, cast: variable(i32))
.param ry: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Fill the given rectangle rounding the corners using the given radius'
.value: {
	if (empty(roi)) {
		return;
	}
	fillRRect(image, roi.x0, roi.y0, roi.x1, roi.y1, rx, ry, color);
}
.instructions: (61 bytes)
	cmplGfx/lib/image.draw.rrect.ci:132: (18 bytes): if (empty(roi))
	<fillRRect>  : load.z32
	<fillRRect+?>: dup.x32 sp(5)
	<fillRRect+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<fillRRect+?>: call
	<fillRRect+?>: inc.sp(-4)
	<fillRRect+?>: jz +5
	cmplGfx/lib/image.draw.rrect.ci:133: (1 byte): return;
	<fillRRect+?>: ret
	cmplGfx/lib/image.draw.rrect.ci:135: (42 bytes): fillRRect(image, roi.x0, roi.y0, roi.x1, roi.y1, rx, ry, color);
	<fillRRect+?>: dup.x64 sp(5)
	<fillRRect+?>: dup.x32 sp(6)
	<fillRRect+?>: load.i32
	<fillRRect+?>: dup.x32 sp(7)
	<fillRRect+?>: inc.i32(+4)
	<fillRRect+?>: load.i32
	<fillRRect+?>: dup.x32 sp(8)
	<fillRRect+?>: inc.i32(+8)
	<fillRRect+?>: load.i32
	<fillRRect+?>: dup.x32 sp(9)
	<fillRRect+?>: inc.i32(+12)
	<fillRRect+?>: load.i32
	<fillRRect+?>: dup.x32 sp(9)
	<fillRRect+?>: dup.x32 sp(9)
	<fillRRect+?>: dup.x32 sp(9)
	<fillRRect+?>: load.ref <?> ;fillRRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, rx: int32, ry: int32, color: uint32): void
	<fillRRect+?>: call
	<fillRRect+?>: inc.sp(-36)
	<fillRRect+?>: ret
.usages:
	cmplGfx/lib/image.draw.rrect.ci:139: referenced as `fillRRect`
}
fillRRect(image: Image, roi: Rect, r: int32, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fillRRect'
.file: 'cmplGfx/lib/image.draw.rrect.ci:139'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param roi: Rect (size: 4, cast: const ref)
.param r: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: u32)
.doc: 'Fill the given rectangle rounding the corners using the given radius'
.value: fillRRect(image, roi, r, r, color)
.usages:
	cmplGfx/lib/micro.ui.ci:972: referenced as `fillRRect`
	cmplGfx/lib/micro.ui.ci:162: referenced as `fillRRect`
}
fillOval(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'fillOval'
.file: 'cmplGfx/lib/image.draw.oval.ci:2'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: u32)
.doc: 'Fill an ellipse on the `image` specified by the given coordinates and the given `color`'
.value: fillRRect(image, x0, y0, x1, y1, Math.abs(x0 - x1), Math.abs(y0 - y1), color)
.usages:
	cmplGfx/lib/image.draw.oval.ci:12: referenced as `fillOval`
}
drawOval(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'drawOval'
.file: 'cmplGfx/lib/image.draw.oval.ci:5'
.param .result: void (size: 0, cast: void)
.param image: Image (size: 8, cast: val)
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: u32)
.doc: 'Draw an ellipse on the `image` specified by the given coordinates and the given `color`'
.value: drawRRect(image, x0, y0, x1, y1, Math.abs(x0 - x1), Math.abs(y0 - y1), color)
.usages:
	cmplGfx/lib/image.draw.oval.ci:20: referenced as `drawOval`
}
fillOval(image: Image, roi: Rect, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 117
.name: 'fillOval'
.file: 'cmplGfx/lib/image.draw.oval.ci:8'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Fill an ellipse on the `image` specified by `roi` with the given `color`'
.value: {
	if (empty(roi)) {
		return;
	}
	fillOval(image, roi.x0, roi.y0, roi.x1, roi.y1, color);
}
.instructions: (117 bytes)
	cmplGfx/lib/image.draw.oval.ci:9: (18 bytes): if (empty(roi))
	<fillOval>  : load.z32
	<fillOval+?>: dup.x32 sp(3)
	<fillOval+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<fillOval+?>: call
	<fillOval+?>: inc.sp(-4)
	<fillOval+?>: jz +5
	cmplGfx/lib/image.draw.oval.ci:10: (1 byte): return;
	<fillOval+?>: ret
	cmplGfx/lib/image.draw.oval.ci:12: (98 bytes): fillOval(image, roi.x0, roi.y0, roi.x1, roi.y1, color);
	<fillOval+?>: dup.x32 sp(2)
	<fillOval+?>: load.i32
	<fillOval+?>: dup.x32 sp(3)
	<fillOval+?>: inc.i32(+4)
	<fillOval+?>: load.i32
	<fillOval+?>: dup.x32 sp(4)
	<fillOval+?>: inc.i32(+8)
	<fillOval+?>: load.i32
	<fillOval+?>: dup.x32 sp(5)
	<fillOval+?>: inc.i32(+12)
	<fillOval+?>: load.i32
	<fillOval+?>: dup.x64 sp(7)
	<fillOval+?>: dup.x32 sp(5)
	<fillOval+?>: dup.x32 sp(5)
	<fillOval+?>: dup.x32 sp(5)
	<fillOval+?>: dup.x32 sp(5)
	<fillOval+?>: dup.x32 sp(9)
	<fillOval+?>: dup.x32 sp(8)
	<fillOval+?>: sub.i32
	<fillOval+?>: dup.x32 sp(0)
	<fillOval+?>: load.z32
	<fillOval+?>: clt.i32
	<fillOval+?>: jz +11
	<fillOval+?>: dup.x32 sp(0)
	<fillOval+?>: neg.i32
	<fillOval+?>: jmp +6
	<fillOval+?>: dup.x32 sp(0)
	<fillOval+?>: set.x32 sp(1)
	<fillOval+?>: dup.x32 sp(9)
	<fillOval+?>: dup.x32 sp(8)
	<fillOval+?>: sub.i32
	<fillOval+?>: dup.x32 sp(0)
	<fillOval+?>: load.z32
	<fillOval+?>: clt.i32
	<fillOval+?>: jz +11
	<fillOval+?>: dup.x32 sp(0)
	<fillOval+?>: neg.i32
	<fillOval+?>: jmp +6
	<fillOval+?>: dup.x32 sp(0)
	<fillOval+?>: set.x32 sp(1)
	<fillOval+?>: dup.x32 sp(13)
	<fillOval+?>: load.ref <?> ;fillRRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, rx: int32, ry: int32, color: uint32): void
	<fillOval+?>: call
	<fillOval+?>: inc.sp(-36)
	<fillOval+?>: inc.sp(-16)
	<fillOval+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:171: referenced as `fillOval`
}
drawOval(image: Image, roi: Rect, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 117
.name: 'drawOval'
.file: 'cmplGfx/lib/image.draw.oval.ci:16'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Draw an ellipse on the `image` specified by `roi` with the given `color`'
.value: {
	if (empty(roi)) {
		return;
	}
	drawOval(image, roi.x0, roi.y0, roi.x1, roi.y1, color);
}
.instructions: (117 bytes)
	cmplGfx/lib/image.draw.oval.ci:17: (18 bytes): if (empty(roi))
	<drawOval>  : load.z32
	<drawOval+?>: dup.x32 sp(3)
	<drawOval+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<drawOval+?>: call
	<drawOval+?>: inc.sp(-4)
	<drawOval+?>: jz +5
	cmplGfx/lib/image.draw.oval.ci:18: (1 byte): return;
	<drawOval+?>: ret
	cmplGfx/lib/image.draw.oval.ci:20: (98 bytes): drawOval(image, roi.x0, roi.y0, roi.x1, roi.y1, color);
	<drawOval+?>: dup.x32 sp(2)
	<drawOval+?>: load.i32
	<drawOval+?>: dup.x32 sp(3)
	<drawOval+?>: inc.i32(+4)
	<drawOval+?>: load.i32
	<drawOval+?>: dup.x32 sp(4)
	<drawOval+?>: inc.i32(+8)
	<drawOval+?>: load.i32
	<drawOval+?>: dup.x32 sp(5)
	<drawOval+?>: inc.i32(+12)
	<drawOval+?>: load.i32
	<drawOval+?>: dup.x64 sp(7)
	<drawOval+?>: dup.x32 sp(5)
	<drawOval+?>: dup.x32 sp(5)
	<drawOval+?>: dup.x32 sp(5)
	<drawOval+?>: dup.x32 sp(5)
	<drawOval+?>: dup.x32 sp(9)
	<drawOval+?>: dup.x32 sp(8)
	<drawOval+?>: sub.i32
	<drawOval+?>: dup.x32 sp(0)
	<drawOval+?>: load.z32
	<drawOval+?>: clt.i32
	<drawOval+?>: jz +11
	<drawOval+?>: dup.x32 sp(0)
	<drawOval+?>: neg.i32
	<drawOval+?>: jmp +6
	<drawOval+?>: dup.x32 sp(0)
	<drawOval+?>: set.x32 sp(1)
	<drawOval+?>: dup.x32 sp(9)
	<drawOval+?>: dup.x32 sp(8)
	<drawOval+?>: sub.i32
	<drawOval+?>: dup.x32 sp(0)
	<drawOval+?>: load.z32
	<drawOval+?>: clt.i32
	<drawOval+?>: jz +11
	<drawOval+?>: dup.x32 sp(0)
	<drawOval+?>: neg.i32
	<drawOval+?>: jmp +6
	<drawOval+?>: dup.x32 sp(0)
	<drawOval+?>: set.x32 sp(1)
	<drawOval+?>: dup.x32 sp(13)
	<drawOval+?>: load.ref <?> ;drawRRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, rx: int32, ry: int32, color: uint32): void
	<drawOval+?>: call
	<drawOval+?>: inc.sp(-36)
	<drawOval+?>: inc.sp(-16)
	<drawOval+?>: ret
.usages:
}
drawLineIncl(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 1362
.name: 'drawLineIncl'
.file: 'cmplGfx/lib/image.draw.line.ci:2'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Draw a line, including ending pixel'
.value: {
	mix(image: Image, x0: int32, y0: int32, alpha: int32, color: uint32): void := set(image, x0, y0, mix_rgb8(alpha, argb(uint32(Image.get(image, x0, y0))), argb(color)));
	if (x0 == x1 || y0 == y1) {
		return .result := fillRect(image, x0, y0, x1, y1, 1, color);
	}
	dx: int32 := x1 - x0;
	dy: int32 := y1 - y0;
	if (Math.abs(dx) > Math.abs(dy)) {
		if (x0 > x1) {
			x: int32 := x0;
			x0 := x1;
			x1 := x;
			y0 := y1;
		}
		y: int32 := y0 << 16;
		dy := (dy << 16) / dx;
		if (x1 > Image.width(image)) {
			x1 := Image.width(image);
		}
		if (x0 < 0) {
			y := y - dy * x0;
			x0 := 0;
		}
		static if (true) {
			for (x: int32 := x0; x <= x1; x := x + 1) {
				alpha: uint32 := (~y >> 8) & 255;
				mix(image, x, y >> 16, alpha, color);
				mix(image, x, (y >> 16) + 1, 255 - (alpha), color);
				y := y + dy;
			}
		}
		else {
			y := y + 32768;
			for (x: int32 := x0; x <= x1; x := x + 1) {
				Image.set(image, x, y >> 16, color);
				y := y + dy;
			}
		}
	}
	else {
		if (y0 > y1) {
			y: int32 := y0;
			y0 := y1;
			y1 := y;
			x0 := x1;
		}
		x: int32 := x0 << 16;
		dx := (dx << 16) / dy;
		if (y1 > Image.height(image)) {
			y1 := Image.height(image);
		}
		if (y0 < 0) {
			x := x - dx * y0;
			y0 := 0;
		}
		static if (true) {
			for (y: int32 := y0; y <= y1; y := y + 1) {
				alpha: int32 := (~x >> 8) & 255;
				mix(image, x >> 16, y, alpha, color);
				mix(image, (x >> 16) + 1, y, 255 - alpha, color);
				x := x + dx;
			}
		}
		else {
			x := x + 32768;
			for (y: int32 := y0; y <= y1; y := y + 1) {
				Image.set(image, x >> 16, y, color);
				x := x + dx;
			}
		}
	}
}
.instructions: (1362 bytes)
	cmplGfx/lib/image.draw.line.ci:5: (52 bytes): if (x0 == x1 || y0 == y1)
	<drawLineIncl>  : dup.x32 sp(5)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: ceq.i32
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: jnz +13
	<drawLineIncl+?>: inc.sp(-4)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: ceq.i32
	<drawLineIncl+?>: jz +32
	cmplGfx/lib/image.draw.line.ci:7: (28 bytes): return .result := fillRect(image, x0, y0, x1, y1, 1, color);
	<drawLineIncl+?>: dup.x64 sp(6)
	<drawLineIncl+?>: dup.x32 sp(7)
	<drawLineIncl+?>: dup.x32 sp(7)
	<drawLineIncl+?>: dup.x32 sp(7)
	<drawLineIncl+?>: dup.x32 sp(7)
	<drawLineIncl+?>: load.c32 1
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<drawLineIncl+?>: call
	<drawLineIncl+?>: inc.sp(-32)
	<drawLineIncl+?>: ret
	cmplGfx/lib/image.draw.line.ci:10: (5 bytes): dx: int32 := x1 - x0
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(6)
	<drawLineIncl+?>: sub.i32
	cmplGfx/lib/image.draw.line.ci:11: (5 bytes): dy: int32 := y1 - y0
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(6)
	<drawLineIncl+?>: sub.i32
	cmplGfx/lib/image.draw.line.ci:13: (1295 bytes): if (Math.abs(dx) > Math.abs(dy))
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +11
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: neg.i32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +11
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: neg.i32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +630
	cmplGfx/lib/image.draw.line.ci:14: (24 bytes): if (x0 > x1)
	<drawLineIncl+?>: dup.x32 sp(7)
	<drawLineIncl+?>: dup.x32 sp(6)
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +19
	cmplGfx/lib/image.draw.line.ci:15: (2 bytes): x: int32 := x0
	<drawLineIncl+?>: dup.x32 sp(7)
	cmplGfx/lib/image.draw.line.ci:16: (3 bytes): x0 := x1;
	<drawLineIncl+?>: mov.x32 sp(8, 6)
	cmplGfx/lib/image.draw.line.ci:17: (3 bytes): x1 := x;
	<drawLineIncl+?>: mov.x32 sp(6, 0)
	cmplGfx/lib/image.draw.line.ci:18: (3 bytes): y0 := y1;
	<drawLineIncl+?>: mov.x32 sp(7, 5)
	<drawLineIncl+?>: inc.sp(-4)
	cmplGfx/lib/image.draw.line.ci:20: (4 bytes): y: int32 := y0 << 16
	<drawLineIncl+?>: dup.x32 sp(6)
	<drawLineIncl+?>: b32.shl 0x10
	cmplGfx/lib/image.draw.line.ci:21: (9 bytes): dy := (dy << 16) / dx;
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: b32.shl 0x10
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: div.i32
	<drawLineIncl+?>: set.x32 sp(2)
	cmplGfx/lib/image.draw.line.ci:22: (21 bytes): if (x1 > Image.width(image))
	<drawLineIncl+?>: dup.x32 sp(6)
	<drawLineIncl+?>: dup.x64 sp(10)
	<drawLineIncl+?>: nfc(101) ;Image.width(image: Image): int32
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +12
	cmplGfx/lib/image.draw.line.ci:23: (8 bytes): x1 := Image.width(image);
	<drawLineIncl+?>: dup.x64 sp(9)
	<drawLineIncl+?>: nfc(101) ;Image.width(image: Image): int32
	<drawLineIncl+?>: set.x32 sp(7)
	cmplGfx/lib/image.draw.line.ci:25: (17 bytes): if (x0 < 0)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +13
	cmplGfx/lib/image.draw.line.ci:26: (6 bytes): y := y - dy * x0;
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(9)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: sub.i32
	cmplGfx/lib/image.draw.line.ci:27: (3 bytes): x0 := 0;
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: set.x32 sp(9)
	cmplGfx/lib/image.draw.line.ci:31: (543 bytes): for (x: int32 := x0; x <= x1; x := x + 1)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: jmp +528
	cmplGfx/lib/image.draw.line.ci:32: (7 bytes): alpha: uint32 := (~y >> 8) & 255
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: cmt.b32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: b32.and 0xff
	cmplGfx/lib/image.draw.line.ci:33: (246 bytes): mix(image, x, y >> 16, alpha, color);
	<drawLineIncl+?>: dup.x64 sp(11)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: b32.sar 0x10
	<drawLineIncl+?>: dup.x64 sp(2)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: dup.x64 sp(7)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	<drawLineIncl+?>: dup.x32 sp(16)
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: b32.shr 0x10
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: b32.shr 0x10
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: b32.shl 0x08
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: b32.shr 0x08
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.shr 0x08
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: or.b32
	<drawLineIncl+?>: b32.shl 0x08
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: or.b32
	<drawLineIncl+?>: mov.x32 sp(3, 0)
	<drawLineIncl+?>: inc.sp(-12)
	<drawLineIncl+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<drawLineIncl+?>: inc.sp(-16)
	cmplGfx/lib/image.draw.line.ci:34: (256 bytes): mix(image, x, (y >> 16) + 1, 255 - (alpha), color);
	<drawLineIncl+?>: dup.x64 sp(11)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: b32.sar 0x10
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: dup.x64 sp(2)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: dup.x32 sp(9)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: dup.x64 sp(7)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	<drawLineIncl+?>: dup.x32 sp(16)
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: b32.shr 0x10
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: b32.shr 0x10
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: b32.shl 0x08
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: b32.shr 0x08
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.shr 0x08
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: or.b32
	<drawLineIncl+?>: b32.shl 0x08
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: or.b32
	<drawLineIncl+?>: mov.x32 sp(3, 0)
	<drawLineIncl+?>: inc.sp(-12)
	<drawLineIncl+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<drawLineIncl+?>: inc.sp(-16)
	cmplGfx/lib/image.draw.line.ci:35: (7 bytes): y := y + dy;
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(3)
	<drawLineIncl+?>: inc.sp(-4)
	cmplGfx/lib/image.draw.line.ci:31: (4 bytes): x := x + 1
	<drawLineIncl+?>: inc.i32(+1)
	cmplGfx/lib/image.draw.line.ci:31: (9 bytes): x <= x1
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz -529
	<drawLineIncl+?>: inc.sp(-4)
	<drawLineIncl+?>: inc.sp(-4)
	<drawLineIncl+?>: jmp +626
	cmplGfx/lib/image.draw.line.ci:45: (24 bytes): if (y0 > y1)
	<drawLineIncl+?>: dup.x32 sp(6)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +19
	cmplGfx/lib/image.draw.line.ci:46: (2 bytes): y: int32 := y0
	<drawLineIncl+?>: dup.x32 sp(6)
	cmplGfx/lib/image.draw.line.ci:47: (3 bytes): y0 := y1;
	<drawLineIncl+?>: mov.x32 sp(7, 5)
	cmplGfx/lib/image.draw.line.ci:48: (3 bytes): y1 := y;
	<drawLineIncl+?>: mov.x32 sp(5, 0)
	cmplGfx/lib/image.draw.line.ci:49: (3 bytes): x0 := x1;
	<drawLineIncl+?>: mov.x32 sp(8, 6)
	<drawLineIncl+?>: inc.sp(-4)
	cmplGfx/lib/image.draw.line.ci:51: (4 bytes): x: int32 := x0 << 16
	<drawLineIncl+?>: dup.x32 sp(7)
	<drawLineIncl+?>: b32.shl 0x10
	cmplGfx/lib/image.draw.line.ci:52: (9 bytes): dx := (dx << 16) / dy;
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: b32.shl 0x10
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: div.i32
	<drawLineIncl+?>: set.x32 sp(3)
	cmplGfx/lib/image.draw.line.ci:53: (21 bytes): if (y1 > Image.height(image))
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: dup.x64 sp(10)
	<drawLineIncl+?>: nfc(102) ;Image.height(image: Image): int32
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +12
	cmplGfx/lib/image.draw.line.ci:54: (8 bytes): y1 := Image.height(image);
	<drawLineIncl+?>: dup.x64 sp(9)
	<drawLineIncl+?>: nfc(102) ;Image.height(image: Image): int32
	<drawLineIncl+?>: set.x32 sp(6)
	cmplGfx/lib/image.draw.line.ci:56: (17 bytes): if (y0 < 0)
	<drawLineIncl+?>: dup.x32 sp(7)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +13
	cmplGfx/lib/image.draw.line.ci:57: (6 bytes): x := x - dx * y0;
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: sub.i32
	cmplGfx/lib/image.draw.line.ci:58: (3 bytes): y0 := 0;
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: set.x32 sp(8)
	cmplGfx/lib/image.draw.line.ci:62: (543 bytes): for (y: int32 := y0; y <= y1; y := y + 1)
	<drawLineIncl+?>: dup.x32 sp(7)
	<drawLineIncl+?>: jmp +528
	cmplGfx/lib/image.draw.line.ci:63: (7 bytes): alpha: int32 := (~x >> 8) & 255
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: cmt.b32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: b32.and 0xff
	cmplGfx/lib/image.draw.line.ci:64: (246 bytes): mix(image, x >> 16, y, alpha, color);
	<drawLineIncl+?>: dup.x64 sp(11)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.sar 0x10
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: dup.x64 sp(2)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: dup.x64 sp(7)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	<drawLineIncl+?>: dup.x32 sp(16)
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: b32.shr 0x10
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: b32.shr 0x10
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: b32.shl 0x08
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: b32.shr 0x08
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.shr 0x08
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: or.b32
	<drawLineIncl+?>: b32.shl 0x08
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: or.b32
	<drawLineIncl+?>: mov.x32 sp(3, 0)
	<drawLineIncl+?>: inc.sp(-12)
	<drawLineIncl+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<drawLineIncl+?>: inc.sp(-16)
	cmplGfx/lib/image.draw.line.ci:65: (256 bytes): mix(image, (x >> 16) + 1, y, 255 - alpha, color);
	<drawLineIncl+?>: dup.x64 sp(11)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.sar 0x10
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: dup.x64 sp(2)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: dup.x32 sp(9)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: dup.x64 sp(7)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: dup.x32 sp(8)
	<drawLineIncl+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	<drawLineIncl+?>: dup.x32 sp(16)
	<drawLineIncl+?>: dup.x32 sp(1)
	<drawLineIncl+?>: b32.shr 0x10
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: b32.shr 0x10
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: b32.shl 0x08
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: b32.shr 0x08
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.shr 0x08
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: or.b32
	<drawLineIncl+?>: b32.shl 0x08
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: dup.x32 sp(4)
	<drawLineIncl+?>: b32.and 0xff
	<drawLineIncl+?>: dup.x32 sp(3)
	<drawLineIncl+?>: sub.i32
	<drawLineIncl+?>: inc.i32(+1)
	<drawLineIncl+?>: mul.i32
	<drawLineIncl+?>: b32.sar 0x08
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz +13
	<drawLineIncl+?>: load.c32 255
	<drawLineIncl+?>: jmp +19
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: clt.i32
	<drawLineIncl+?>: jz +9
	<drawLineIncl+?>: load.z32
	<drawLineIncl+?>: jmp +6
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: set.x32 sp(1)
	<drawLineIncl+?>: or.b32
	<drawLineIncl+?>: mov.x32 sp(3, 0)
	<drawLineIncl+?>: inc.sp(-12)
	<drawLineIncl+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<drawLineIncl+?>: inc.sp(-16)
	cmplGfx/lib/image.draw.line.ci:66: (7 bytes): x := x + dx;
	<drawLineIncl+?>: dup.x32 sp(2)
	<drawLineIncl+?>: dup.x32 sp(5)
	<drawLineIncl+?>: add.i32
	<drawLineIncl+?>: set.x32 sp(3)
	<drawLineIncl+?>: inc.sp(-4)
	cmplGfx/lib/image.draw.line.ci:62: (4 bytes): y := y + 1
	<drawLineIncl+?>: inc.i32(+1)
	cmplGfx/lib/image.draw.line.ci:62: (9 bytes): y <= y1
	<drawLineIncl+?>: dup.x32 sp(0)
	<drawLineIncl+?>: dup.x32 sp(7)
	<drawLineIncl+?>: cgt.i32
	<drawLineIncl+?>: jz -529
	<drawLineIncl+?>: inc.sp(-4)
	<drawLineIncl+?>: inc.sp(-4)
	<drawLineIncl+?>: inc.sp(-8)
	<drawLineIncl+?>: ret
.usages:
	cmplGfx/lib/image.draw.line.ci:119: referenced as `drawLineIncl`
	cmplGfx/lib/image.draw.line.ci:97: referenced as `drawLineIncl`
	cmplGfx/lib/image.draw.line.ci:81: referenced as `drawLineIncl`
}
drawLine(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 63
.name: 'drawLine'
.file: 'cmplGfx/lib/image.draw.line.ci:79'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Draw a line between the given coordinates(excluding the rightmost bottom pixel)'
.value: {
	p(a: int32, b: int32): int32 := a - int32(b < a);
	return .result := drawLineIncl(image, p(x0, x1), p(y0, y1), p(x1, x0), p(y1, y0), color);
}
.instructions: (63 bytes)
	cmplGfx/lib/image.draw.line.ci:81: (63 bytes): return .result := drawLineIncl(image, p(x0, x1), p(y0, y1), p(x1, x0), p(y1, y0), color);
	<drawLine>  : dup.x64 sp(6)
	<drawLine+?>: dup.x32 sp(7)
	<drawLine+?>: dup.x32 sp(0)
	<drawLine+?>: dup.x32 sp(7)
	<drawLine+?>: dup.x32 sp(2)
	<drawLine+?>: clt.i32
	<drawLine+?>: sub.i32
	<drawLine+?>: set.x32 sp(1)
	<drawLine+?>: dup.x32 sp(7)
	<drawLine+?>: dup.x32 sp(0)
	<drawLine+?>: dup.x32 sp(7)
	<drawLine+?>: dup.x32 sp(2)
	<drawLine+?>: clt.i32
	<drawLine+?>: sub.i32
	<drawLine+?>: set.x32 sp(1)
	<drawLine+?>: dup.x32 sp(7)
	<drawLine+?>: dup.x32 sp(0)
	<drawLine+?>: dup.x32 sp(11)
	<drawLine+?>: dup.x32 sp(2)
	<drawLine+?>: clt.i32
	<drawLine+?>: sub.i32
	<drawLine+?>: set.x32 sp(1)
	<drawLine+?>: dup.x32 sp(7)
	<drawLine+?>: dup.x32 sp(0)
	<drawLine+?>: dup.x32 sp(11)
	<drawLine+?>: dup.x32 sp(2)
	<drawLine+?>: clt.i32
	<drawLine+?>: sub.i32
	<drawLine+?>: set.x32 sp(1)
	<drawLine+?>: dup.x32 sp(7)
	<drawLine+?>: load.ref <?> ;drawLineIncl(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void
	<drawLine+?>: call
	<drawLine+?>: inc.sp(-28)
	<drawLine+?>: ret
.usages:
	cmplGfx/lib/image.draw.line.ci:123: referenced as `drawLine`
	cmplGfx/lib/image.draw.line.ci:101: referenced as `drawLine`
}
drawBezier(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, x2: int32, y2: int32, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 197
.name: 'drawBezier'
.file: 'cmplGfx/lib/image.draw.line.ci:85'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Draw a quadratic bezier curve'
.value: {
	px_0: int32 := x0;
	py_0: int32 := y0;
	px_1: int32 := 2 * (x1 - x0);
	py_1: int32 := 2 * (y1 - y0);
	px_2: int32 := x2 - 2 * x1 + x0;
	py_2: int32 := y2 - 2 * y1 + y0;
	dt: float64 := 1.000000 / (128);
	for (t: float64 := dt; t < (1); t := t + dt) {
		x1 := (((px_2) * t + (px_1)) * t + (px_0));
		y1 := (((py_2) * t + (py_1)) * t + (py_0));
		drawLineIncl(image, x0, y0, x1, y1, color);
		x0 := x1;
		y0 := y1;
	}
	drawLine(image, x0, y0, x2, y2, color);
}
.instructions: (197 bytes)
	cmplGfx/lib/image.draw.line.ci:86: (2 bytes): px_0: int32 := x0
	<drawBezier>  : dup.x32 sp(7)
	cmplGfx/lib/image.draw.line.ci:87: (2 bytes): py_0: int32 := y0
	<drawBezier+?>: dup.x32 sp(7)
	cmplGfx/lib/image.draw.line.ci:88: (11 bytes): px_1: int32 := 2 * (x1 - x0)
	<drawBezier+?>: load.c32 2
	<drawBezier+?>: dup.x32 sp(8)
	<drawBezier+?>: dup.x32 sp(11)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: mul.i32
	cmplGfx/lib/image.draw.line.ci:89: (11 bytes): py_1: int32 := 2 * (y1 - y0)
	<drawBezier+?>: load.c32 2
	<drawBezier+?>: dup.x32 sp(8)
	<drawBezier+?>: dup.x32 sp(11)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: mul.i32
	cmplGfx/lib/image.draw.line.ci:90: (14 bytes): px_2: int32 := x2 - 2 * x1 + x0
	<drawBezier+?>: dup.x32 sp(7)
	<drawBezier+?>: load.c32 2
	<drawBezier+?>: dup.x32 sp(11)
	<drawBezier+?>: mul.i32
	<drawBezier+?>: sub.i32
	<drawBezier+?>: dup.x32 sp(12)
	<drawBezier+?>: add.i32
	cmplGfx/lib/image.draw.line.ci:91: (14 bytes): py_2: int32 := y2 - 2 * y1 + y0
	<drawBezier+?>: dup.x32 sp(7)
	<drawBezier+?>: load.c32 2
	<drawBezier+?>: dup.x32 sp(11)
	<drawBezier+?>: mul.i32
	<drawBezier+?>: sub.i32
	<drawBezier+?>: dup.x32 sp(12)
	<drawBezier+?>: add.i32
	cmplGfx/lib/image.draw.line.ci:93: (19 bytes): dt: float64 := 1.000000 / (128)
	<drawBezier+?>: load.f64 1.000000
	<drawBezier+?>: load.f64 128.000000
	<drawBezier+?>: div.f64
	cmplGfx/lib/image.draw.line.ci:94: (97 bytes): for (t: float64 := dt; t < (1); t := t + dt)
	<drawBezier+?>: dup.x64 sp(0)
	<drawBezier+?>: jmp +75
	cmplGfx/lib/image.draw.line.ci:95: (20 bytes): x1 := (((px_2) * t + (px_1)) * t + (px_0));
	<drawBezier+?>: dup.x32 sp(5)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(9)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(11)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: f64.2i32
	<drawBezier+?>: set.x32 sp(16)
	cmplGfx/lib/image.draw.line.ci:96: (20 bytes): y1 := (((py_2) * t + (py_1)) * t + (py_0));
	<drawBezier+?>: dup.x32 sp(4)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(8)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(10)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: f64.2i32
	<drawBezier+?>: set.x32 sp(15)
	cmplGfx/lib/image.draw.line.ci:97: (22 bytes): drawLineIncl(image, x0, y0, x1, y1, color);
	<drawBezier+?>: dup.x64 sp(18)
	<drawBezier+?>: dup.x32 sp(19)
	<drawBezier+?>: dup.x32 sp(19)
	<drawBezier+?>: dup.x32 sp(19)
	<drawBezier+?>: dup.x32 sp(19)
	<drawBezier+?>: dup.x32 sp(17)
	<drawBezier+?>: load.ref <?> ;drawLineIncl(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void
	<drawBezier+?>: call
	<drawBezier+?>: inc.sp(-28)
	cmplGfx/lib/image.draw.line.ci:98: (3 bytes): x0 := x1;
	<drawBezier+?>: mov.x32 sp(17, 15)
	cmplGfx/lib/image.draw.line.ci:99: (3 bytes): y0 := y1;
	<drawBezier+?>: mov.x32 sp(16, 14)
	cmplGfx/lib/image.draw.line.ci:94: (3 bytes): t := t + dt
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: add.f64
	cmplGfx/lib/image.draw.line.ci:94: (16 bytes): t < (1)
	<drawBezier+?>: dup.x64 sp(0)
	<drawBezier+?>: load.f64 1.000000
	<drawBezier+?>: clt.f64
	<drawBezier+?>: jnz -83
	<drawBezier+?>: inc.sp(-8)
	cmplGfx/lib/image.draw.line.ci:101: (22 bytes): drawLine(image, x0, y0, x2, y2, color);
	<drawBezier+?>: dup.x64 sp(16)
	<drawBezier+?>: dup.x32 sp(17)
	<drawBezier+?>: dup.x32 sp(17)
	<drawBezier+?>: dup.x32 sp(15)
	<drawBezier+?>: dup.x32 sp(15)
	<drawBezier+?>: dup.x32 sp(15)
	<drawBezier+?>: load.ref <?> ;drawLine(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void
	<drawBezier+?>: call
	<drawBezier+?>: inc.sp(-28)
	<drawBezier+?>: inc.sp(-32)
	<drawBezier+?>: ret
.usages:
}
drawBezier(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, color: uint32): void: function {
.kind: static function
.base: `function`
.size: 233
.name: 'drawBezier'
.file: 'cmplGfx/lib/image.draw.line.ci:105'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param x1: int32 (size: 4, cast: variable(i32))
.param y1: int32 (size: 4, cast: variable(i32))
.param x2: int32 (size: 4, cast: variable(i32))
.param y2: int32 (size: 4, cast: variable(i32))
.param x3: int32 (size: 4, cast: variable(i32))
.param y3: int32 (size: 4, cast: variable(i32))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Draw a cubic bezier curve'
.value: {
	px_0: int32 := x0;
	py_0: int32 := y0;
	px_1: int32 := 3 * (x1 - x0);
	py_1: int32 := 3 * (y1 - y0);
	px_2: int32 := 3 * (x2 - x1) - px_1;
	py_2: int32 := 3 * (y2 - y1) - py_1;
	px_3: int32 := x3 - px_2 - px_1 - px_0;
	py_3: int32 := y3 - py_2 - py_1 - py_0;
	dt: float64 := 1.000000 / (128);
	for (t: float64 := dt; t < (1); t := t + dt) {
		x1 := ((((px_3) * t + (px_2)) * t + (px_1)) * t + (px_0));
		y1 := ((((py_3) * t + (py_2)) * t + (py_1)) * t + (py_0));
		drawLineIncl(image, x0, y0, x1, y1, color);
		x0 := x1;
		y0 := y1;
	}
	drawLine(image, x0, y0, x3, y3, color);
}
.instructions: (233 bytes)
	cmplGfx/lib/image.draw.line.ci:106: (2 bytes): px_0: int32 := x0
	<drawBezier>  : dup.x32 sp(9)
	cmplGfx/lib/image.draw.line.ci:107: (2 bytes): py_0: int32 := y0
	<drawBezier+?>: dup.x32 sp(9)
	cmplGfx/lib/image.draw.line.ci:108: (11 bytes): px_1: int32 := 3 * (x1 - x0)
	<drawBezier+?>: load.c32 3
	<drawBezier+?>: dup.x32 sp(10)
	<drawBezier+?>: dup.x32 sp(13)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: mul.i32
	cmplGfx/lib/image.draw.line.ci:109: (11 bytes): py_1: int32 := 3 * (y1 - y0)
	<drawBezier+?>: load.c32 3
	<drawBezier+?>: dup.x32 sp(10)
	<drawBezier+?>: dup.x32 sp(13)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: mul.i32
	cmplGfx/lib/image.draw.line.ci:110: (14 bytes): px_2: int32 := 3 * (x2 - x1) - px_1
	<drawBezier+?>: load.c32 3
	<drawBezier+?>: dup.x32 sp(10)
	<drawBezier+?>: dup.x32 sp(13)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: mul.i32
	<drawBezier+?>: dup.x32 sp(2)
	<drawBezier+?>: sub.i32
	cmplGfx/lib/image.draw.line.ci:111: (14 bytes): py_2: int32 := 3 * (y2 - y1) - py_1
	<drawBezier+?>: load.c32 3
	<drawBezier+?>: dup.x32 sp(10)
	<drawBezier+?>: dup.x32 sp(13)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: mul.i32
	<drawBezier+?>: dup.x32 sp(2)
	<drawBezier+?>: sub.i32
	cmplGfx/lib/image.draw.line.ci:112: (11 bytes): px_3: int32 := x3 - px_2 - px_1 - px_0
	<drawBezier+?>: dup.x32 sp(9)
	<drawBezier+?>: dup.x32 sp(2)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: dup.x32 sp(4)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: dup.x32 sp(6)
	<drawBezier+?>: sub.i32
	cmplGfx/lib/image.draw.line.ci:113: (11 bytes): py_3: int32 := y3 - py_2 - py_1 - py_0
	<drawBezier+?>: dup.x32 sp(9)
	<drawBezier+?>: dup.x32 sp(2)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: dup.x32 sp(4)
	<drawBezier+?>: sub.i32
	<drawBezier+?>: dup.x32 sp(6)
	<drawBezier+?>: sub.i32
	cmplGfx/lib/image.draw.line.ci:115: (19 bytes): dt: float64 := 1.000000 / (128)
	<drawBezier+?>: load.f64 1.000000
	<drawBezier+?>: load.f64 128.000000
	<drawBezier+?>: div.f64
	cmplGfx/lib/image.draw.line.ci:116: (111 bytes): for (t: float64 := dt; t < (1); t := t + dt)
	<drawBezier+?>: dup.x64 sp(0)
	<drawBezier+?>: jmp +89
	cmplGfx/lib/image.draw.line.ci:117: (27 bytes): x1 := ((((px_3) * t + (px_2)) * t + (px_1)) * t + (px_0));
	<drawBezier+?>: dup.x32 sp(5)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(9)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(11)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(13)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: f64.2i32
	<drawBezier+?>: set.x32 sp(20)
	cmplGfx/lib/image.draw.line.ci:118: (27 bytes): y1 := ((((py_3) * t + (py_2)) * t + (py_1)) * t + (py_0));
	<drawBezier+?>: dup.x32 sp(4)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(8)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(10)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: mul.f64
	<drawBezier+?>: dup.x32 sp(12)
	<drawBezier+?>: i32.2f64
	<drawBezier+?>: add.f64
	<drawBezier+?>: f64.2i32
	<drawBezier+?>: set.x32 sp(19)
	cmplGfx/lib/image.draw.line.ci:119: (22 bytes): drawLineIncl(image, x0, y0, x1, y1, color);
	<drawBezier+?>: dup.x64 sp(22)
	<drawBezier+?>: dup.x32 sp(23)
	<drawBezier+?>: dup.x32 sp(23)
	<drawBezier+?>: dup.x32 sp(23)
	<drawBezier+?>: dup.x32 sp(23)
	<drawBezier+?>: dup.x32 sp(19)
	<drawBezier+?>: load.ref <?> ;drawLineIncl(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void
	<drawBezier+?>: call
	<drawBezier+?>: inc.sp(-28)
	cmplGfx/lib/image.draw.line.ci:120: (3 bytes): x0 := x1;
	<drawBezier+?>: mov.x32 sp(21, 19)
	cmplGfx/lib/image.draw.line.ci:121: (3 bytes): y0 := y1;
	<drawBezier+?>: mov.x32 sp(20, 18)
	cmplGfx/lib/image.draw.line.ci:116: (3 bytes): t := t + dt
	<drawBezier+?>: dup.x64 sp(2)
	<drawBezier+?>: add.f64
	cmplGfx/lib/image.draw.line.ci:116: (16 bytes): t < (1)
	<drawBezier+?>: dup.x64 sp(0)
	<drawBezier+?>: load.f64 1.000000
	<drawBezier+?>: clt.f64
	<drawBezier+?>: jnz -97
	<drawBezier+?>: inc.sp(-8)
	cmplGfx/lib/image.draw.line.ci:123: (22 bytes): drawLine(image, x0, y0, x3, y3, color);
	<drawBezier+?>: dup.x64 sp(20)
	<drawBezier+?>: dup.x32 sp(21)
	<drawBezier+?>: dup.x32 sp(21)
	<drawBezier+?>: dup.x32 sp(17)
	<drawBezier+?>: dup.x32 sp(17)
	<drawBezier+?>: dup.x32 sp(17)
	<drawBezier+?>: load.ref <?> ;drawLine(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void
	<drawBezier+?>: call
	<drawBezier+?>: inc.sp(-28)
	<drawBezier+?>: inc.sp(-40)
	<drawBezier+?>: ret
.usages:
}
fill(image: Image, color: uint32): Image: function {
.kind: static function
.base: `function`
.size: 33
.name: 'fill'
.file: 'cmplGfx/lib/image.draw.ci:14'
.param .result: Image (size: 8, cast: variable(val))
.param image: Image (size: 8, cast: variable(val))
.param color: uint32 (size: 4, cast: variable(u32))
.doc: 'Fill the entire image with the given color'
.value: {
	fillRect(image, 0, 0, Image.width(image), Image.height(image), color);
	return .result := image;
}
.instructions: (33 bytes)
	cmplGfx/lib/image.draw.ci:15: (29 bytes): fillRect(image, 0, 0, Image.width(image), Image.height(image), color);
	<fill>  : dup.x64 sp(2)
	<fill+?>: load.z32
	<fill+?>: load.z32
	<fill+?>: dup.x64 sp(6)
	<fill+?>: nfc(101) ;Image.width(image: Image): int32
	<fill+?>: dup.x64 sp(7)
	<fill+?>: nfc(102) ;Image.height(image: Image): int32
	<fill+?>: load.z32
	<fill+?>: dup.x32 sp(8)
	<fill+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<fill+?>: call
	<fill+?>: inc.sp(-32)
	cmplGfx/lib/image.draw.ci:16: (4 bytes): return .result := image;
	<fill+?>: mov.x64 sp(4, 2)
	<fill+?>: ret
.usages:
}
drawText(image: Image, x: int32, y: int32, font: Image, text: char[*], color: int32): void: function {
.kind: static function
.base: `function`
.size: 47
.name: 'drawText'
.file: 'cmplGfx/lib/image.draw.ci:20'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param font: Image (size: 8, cast: variable(val))
.param text: char[*] (size: 4, cast: const variable(ref))
.param color: int32 (size: 4, cast: variable(i32))
.doc: 'Draw the given ASCII `text` to the `image` at the given `x`, `y` coordinate, with the given `font` and `color`'
.value: {
	rect: Rect := {
		rect.x0 := x;
		rect.y0 := y;
		rect.x1 := Image.width(image);
		rect.y1 := Image.height(image);
	};
	return .result := Image.drawText(image, rect, font, text, color);
}
.instructions: (47 bytes)
	cmplGfx/lib/image.draw.ci:21: (26 bytes): rect: Rect := {...}
	<drawText>  : inc.sp(+16)
	cmplGfx/lib/image.draw.ci:21: (3 bytes): rect.x0 := x;
	<drawText+?>: mov.x32 sp(0, 10)
	cmplGfx/lib/image.draw.ci:21: (3 bytes): rect.y0 := y;
	<drawText+?>: mov.x32 sp(1, 9)
	cmplGfx/lib/image.draw.ci:21: (8 bytes): rect.x1 := Image.width(image);
	<drawText+?>: dup.x64 sp(11)
	<drawText+?>: nfc(101) ;Image.width(image: Image): int32
	<drawText+?>: set.x32 sp(3)
	cmplGfx/lib/image.draw.ci:21: (8 bytes): rect.y1 := Image.height(image);
	<drawText+?>: dup.x64 sp(11)
	<drawText+?>: nfc(102) ;Image.height(image: Image): int32
	<drawText+?>: set.x32 sp(4)
	cmplGfx/lib/image.draw.ci:22: (21 bytes): return .result := Image.drawText(image, rect, font, text, color);
	<drawText+?>: dup.x64 sp(11)
	<drawText+?>: load.sp(+8)
	<drawText+?>: dup.x64 sp(10)
	<drawText+?>: dup.x32 sp(11)
	<drawText+?>: dup.x32 sp(11)
	<drawText+?>: nfc(108) ;Image.drawText(image: Image, roi: Rect, font: Image, text: char[*], color: int32): void
	<drawText+?>: inc.sp(-16)
	<drawText+?>: ret
.usages:
}
blend(image: Image, x0: int32, y0: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: argb, with: argb): argb): void: function {
.kind: static function
.base: `function`
.size: 548
.name: 'blend'
.file: 'cmplGfx/lib/image.blend.ci:2'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: const variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param extra: pointer (size: 4, cast: variable(ref))
.param blend: function (size: 4, cast: variable(ref))
.doc: 'copy the `src` image to the destination with an optional blend method'
.value: {
	static if ((preferNativeCalls) && (typename(Image.blend)) != null) {
		return .result := Image.blend(image, x0, y0, src, roi, extra, pointer(blend));
	}
	rect: Rect := {
		rect.x0 := (roi) != null ? roi.x0 : 0;
		rect.y0 := (roi) != null ? roi.y0 : 0;
		rect.x1 := (roi) != null ? roi.x1 : Image.width(src);
		rect.y1 := (roi) != null ? roi.y1 : Image.height(src);
	};
	if (x0 < 0) {
		rect.x0 := rect.x0 - x0;
	}
	if (y0 < 0) {
		rect.y0 := rect.y0 - y0;
	}
	if (!clip(src, &rect)) {
		return;
	}
	positionX(rect, x0 < 0 ? 0 : x0);
	positionY(rect, y0 < 0 ? 0 : y0);
	if (!clip(image, &rect)) {
		return;
	}
	assert(Image.depth(image) == 32 && Image.depth(src) == 32);
	if ((blend) == null) {
		for (y: int32 := rect.y0; y < rect.y1; y := y + 1) {
			for (x: int32 := rect.x0; x < rect.x1; x := x + 1) {
				Image.set(image, x, y, Image.get(src, x - x0, y - y0));
			}
		}
		return;
	}
	for (y: int32 := rect.y0; y < rect.y1; y := y + 1) {
		for (x: int32 := rect.x0; x < rect.x1; x := x + 1) {
			base: argb := argb(Image.get(image, x, y));
			with: argb := argb(Image.get(src, x - x0, y - y0));
			set(image, x, y, blend(extra, base, with));
		}
	}
}
.instructions: (548 bytes)
	cmplGfx/lib/image.blend.ci:4: (19 bytes): return .result := Image.blend(image, x0, y0, src, roi, extra, pointer(blend));
	<blend>  : dup.x64 sp(8)
	<blend+?>: dup.x32 sp(9)
	<blend+?>: dup.x32 sp(9)
	<blend+?>: dup.x64 sp(8)
	<blend+?>: dup.x32 sp(9)
	<blend+?>: dup.x32 sp(9)
	<blend+?>: dup.x32 sp(9)
	<blend+?>: nfc(110) ;Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void
	<blend+?>: ret
	cmplGfx/lib/image.blend.ci:8: (114 bytes): rect: Rect := {...}
	<blend+?>: inc.sp(+16)
	cmplGfx/lib/image.blend.ci:9: (22 bytes): rect.x0 := (roi) != null ? roi.x0 : 0;
	<blend+?>: dup.x32 sp(7)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jnz +11
	<blend+?>: dup.x32 sp(7)
	<blend+?>: load.i32
	<blend+?>: jmp +5
	<blend+?>: load.z32
	<blend+?>: set.x32 sp(1)
	cmplGfx/lib/image.blend.ci:10: (26 bytes): rect.y0 := (roi) != null ? roi.y0 : 0;
	<blend+?>: dup.x32 sp(7)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jnz +15
	<blend+?>: dup.x32 sp(7)
	<blend+?>: inc.i32(+4)
	<blend+?>: load.i32
	<blend+?>: jmp +5
	<blend+?>: load.z32
	<blend+?>: set.x32 sp(2)
	cmplGfx/lib/image.blend.ci:11: (31 bytes): rect.x1 := (roi) != null ? roi.x1 : Image.width(src);
	<blend+?>: dup.x32 sp(7)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jnz +15
	<blend+?>: dup.x32 sp(7)
	<blend+?>: inc.i32(+8)
	<blend+?>: load.i32
	<blend+?>: jmp +10
	<blend+?>: dup.x64 sp(8)
	<blend+?>: nfc(101) ;Image.width(image: Image): int32
	<blend+?>: set.x32 sp(3)
	cmplGfx/lib/image.blend.ci:12: (31 bytes): rect.y1 := (roi) != null ? roi.y1 : Image.height(src);
	<blend+?>: dup.x32 sp(7)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jnz +15
	<blend+?>: dup.x32 sp(7)
	<blend+?>: inc.i32(+12)
	<blend+?>: load.i32
	<blend+?>: jmp +10
	<blend+?>: dup.x64 sp(8)
	<blend+?>: nfc(102) ;Image.height(image: Image): int32
	<blend+?>: set.x32 sp(4)
	cmplGfx/lib/image.blend.ci:14: (11 bytes): if (x0 < 0)
	<blend+?>: dup.x32 sp(11)
	<blend+?>: load.z32
	<blend+?>: clt.i32
	<blend+?>: jz +7
	cmplGfx/lib/image.blend.ci:15: (3 bytes): rect.x0 := rect.x0 - x0;
	<blend+?>: dup.x32 sp(11)
	<blend+?>: sub.i32
	cmplGfx/lib/image.blend.ci:17: (15 bytes): if (y0 < 0)
	<blend+?>: dup.x32 sp(10)
	<blend+?>: load.z32
	<blend+?>: clt.i32
	<blend+?>: jz +11
	cmplGfx/lib/image.blend.ci:18: (7 bytes): rect.y0 := rect.y0 - y0;
	<blend+?>: dup.x32 sp(1)
	<blend+?>: dup.x32 sp(11)
	<blend+?>: sub.i32
	<blend+?>: set.x32 sp(2)
	cmplGfx/lib/image.blend.ci:20: (26 bytes): if (!clip(src, &rect))
	<blend+?>: load.z32
	<blend+?>: dup.x64 sp(9)
	<blend+?>: load.sp(+12)
	<blend+?>: load.ref <?> ;clip(image: Image, roi: Rect): bool
	<blend+?>: call
	<blend+?>: inc.sp(-12)
	<blend+?>: jnz +9
	cmplGfx/lib/image.blend.ci:22: (5 bytes): return;
	<blend+?>: inc.sp(-16)
	<blend+?>: ret
	cmplGfx/lib/image.blend.ci:26: (29 bytes): positionX(rect, x0 < 0 ? 0 : x0);
	<blend+?>: load.sp(+0)
	<blend+?>: dup.x32 sp(12)
	<blend+?>: load.z32
	<blend+?>: clt.i32
	<blend+?>: jz +9
	<blend+?>: load.z32
	<blend+?>: jmp +6
	<blend+?>: dup.x32 sp(12)
	<blend+?>: load.ref <?> ;positionX(rectangle: Rect, x: int32): void
	<blend+?>: call
	<blend+?>: inc.sp(-8)
	cmplGfx/lib/image.blend.ci:27: (29 bytes): positionY(rect, y0 < 0 ? 0 : y0);
	<blend+?>: load.sp(+0)
	<blend+?>: dup.x32 sp(11)
	<blend+?>: load.z32
	<blend+?>: clt.i32
	<blend+?>: jz +9
	<blend+?>: load.z32
	<blend+?>: jmp +6
	<blend+?>: dup.x32 sp(11)
	<blend+?>: load.ref <?> ;positionY(rectangle: Rect, y: int32): void
	<blend+?>: call
	<blend+?>: inc.sp(-8)
	cmplGfx/lib/image.blend.ci:28: (26 bytes): if (!clip(image, &rect))
	<blend+?>: load.z32
	<blend+?>: dup.x64 sp(13)
	<blend+?>: load.sp(+12)
	<blend+?>: load.ref <?> ;clip(image: Image, roi: Rect): bool
	<blend+?>: call
	<blend+?>: inc.sp(-12)
	<blend+?>: jnz +9
	cmplGfx/lib/image.blend.ci:30: (5 bytes): return;
	<blend+?>: inc.sp(-16)
	<blend+?>: ret
	cmplGfx/lib/image.blend.ci:33: (82 bytes): assert(Image.depth(image) == 32 && Image.depth(src) == 32);
	<blend+?>: load.z32
	<blend+?>: load.sp(+4)
	<blend+?>: dup.x64 sp(14)
	<blend+?>: nfc(103) ;Image.depth(image: Image): int32
	<blend+?>: load.c32 32
	<blend+?>: ceq.i32
	<blend+?>: dup.x32 sp(0)
	<blend+?>: jz +20
	<blend+?>: inc.sp(-4)
	<blend+?>: dup.x64 sp(10)
	<blend+?>: nfc(103) ;Image.depth(image: Image): int32
	<blend+?>: load.c32 32
	<blend+?>: ceq.i32
	<blend+?>: jz +8
	<blend+?>: jmp +35
	<blend+?>: load.ref <?> ;"cmplGfx/lib/image.blend.ci"
	<blend+?>: load.c32 33
	<blend+?>: load.c32 -2
	<blend+?>: load.c32 128
	<blend+?>: load.ref <?> ;"assertion failed!"
	<blend+?>: dup.x64 sp(5)
	<blend+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<blend+?>: inc.sp(-8)
	cmplGfx/lib/image.blend.ci:34: (89 bytes): if ((blend) == null)
	<blend+?>: dup.x32 sp(5)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jz +81
	cmplGfx/lib/image.blend.ci:35: (72 bytes): for (y: int32 := rect.y0; y < rect.y1; y := y + 1)
	<blend+?>: dup.x32 sp(1)
	<blend+?>: jmp +57
	cmplGfx/lib/image.blend.ci:36: (49 bytes): for (x: int32 := rect.x0; x < rect.x1; x := x + 1)
	<blend+?>: dup.x32 sp(1)
	<blend+?>: jmp +34
	cmplGfx/lib/image.blend.ci:37: (26 bytes): Image.set(image, x, y, Image.get(src, x - x0, y - y0));
	<blend+?>: dup.x64 sp(14)
	<blend+?>: dup.x32 sp(2)
	<blend+?>: dup.x32 sp(4)
	<blend+?>: dup.x64 sp(14)
	<blend+?>: dup.x32 sp(6)
	<blend+?>: dup.x32 sp(20)
	<blend+?>: sub.i32
	<blend+?>: dup.x32 sp(8)
	<blend+?>: dup.x32 sp(20)
	<blend+?>: sub.i32
	<blend+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	<blend+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	cmplGfx/lib/image.blend.ci:36: (4 bytes): x := x + 1
	<blend+?>: inc.i32(+1)
	cmplGfx/lib/image.blend.ci:36: (9 bytes): x < rect.x1
	<blend+?>: dup.x32 sp(0)
	<blend+?>: dup.x32 sp(5)
	<blend+?>: clt.i32
	<blend+?>: jnz -35
	<blend+?>: inc.sp(-4)
	cmplGfx/lib/image.blend.ci:35: (4 bytes): y := y + 1
	<blend+?>: inc.i32(+1)
	cmplGfx/lib/image.blend.ci:35: (9 bytes): y < rect.y1
	<blend+?>: dup.x32 sp(0)
	<blend+?>: dup.x32 sp(5)
	<blend+?>: clt.i32
	<blend+?>: jnz -58
	<blend+?>: inc.sp(-4)
	cmplGfx/lib/image.blend.ci:40: (5 bytes): return;
	<blend+?>: inc.sp(-16)
	<blend+?>: ret
	cmplGfx/lib/image.blend.ci:43: (103 bytes): for (y: int32 := rect.y0; y < rect.y1; y := y + 1)
	<blend+?>: dup.x32 sp(1)
	<blend+?>: jmp +88
	cmplGfx/lib/image.blend.ci:44: (80 bytes): for (x: int32 := rect.x0; x < rect.x1; x := x + 1)
	<blend+?>: dup.x32 sp(1)
	<blend+?>: jmp +65
	cmplGfx/lib/image.blend.ci:45: (10 bytes): base: argb := argb(Image.get(image, x, y))
	<blend+?>: dup.x64 sp(14)
	<blend+?>: dup.x32 sp(2)
	<blend+?>: dup.x32 sp(4)
	<blend+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	cmplGfx/lib/image.blend.ci:46: (16 bytes): with: argb := argb(Image.get(src, x - x0, y - y0))
	<blend+?>: dup.x64 sp(11)
	<blend+?>: dup.x32 sp(3)
	<blend+?>: dup.x32 sp(17)
	<blend+?>: sub.i32
	<blend+?>: dup.x32 sp(5)
	<blend+?>: dup.x32 sp(17)
	<blend+?>: sub.i32
	<blend+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	cmplGfx/lib/image.blend.ci:47: (27 bytes): set(image, x, y, blend(extra, base, with));
	<blend+?>: dup.x64 sp(16)
	<blend+?>: dup.x32 sp(4)
	<blend+?>: dup.x32 sp(6)
	<blend+?>: inc.sp(+4)
	<blend+?>: dup.x32 sp(15)
	<blend+?>: dup.x32 sp(7)
	<blend+?>: dup.x32 sp(7)
	<blend+?>: dup.x32 sp(17)
	<blend+?>: call
	<blend+?>: inc.sp(-12)
	<blend+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<blend+?>: inc.sp(-8)
	cmplGfx/lib/image.blend.ci:44: (4 bytes): x := x + 1
	<blend+?>: inc.i32(+1)
	cmplGfx/lib/image.blend.ci:44: (9 bytes): x < rect.x1
	<blend+?>: dup.x32 sp(0)
	<blend+?>: dup.x32 sp(5)
	<blend+?>: clt.i32
	<blend+?>: jnz -66
	<blend+?>: inc.sp(-4)
	cmplGfx/lib/image.blend.ci:43: (4 bytes): y := y + 1
	<blend+?>: inc.i32(+1)
	cmplGfx/lib/image.blend.ci:43: (9 bytes): y < rect.y1
	<blend+?>: dup.x32 sp(0)
	<blend+?>: dup.x32 sp(5)
	<blend+?>: clt.i32
	<blend+?>: jnz -89
	<blend+?>: inc.sp(-4)
	<blend+?>: inc.sp(-16)
	<blend+?>: ret
.usages:
	cmplGfx/lib/image.blend.ci:120: referenced as `blend`
	cmplGfx/lib/image.blend.ci:115: referenced as `blend`
	cmplGfx/lib/image.blend.ci:97: referenced as `blend`
	cmplGfx/lib/image.blend.ci:80: referenced as `blend`
	cmplGfx/lib/image.blend.ci:63: referenced as `blend`
	cmplGfx/lib/image.blend.ci:61: referenced as `blend`
}
blend(image: Image, x0: int32, y0: int32, src: Image, roi: Rect, blend(base: vec4f, with: vec4f): vec4f): void: function {
.kind: static function
.base: `function`
.size: 93
.name: 'blend'
.file: 'cmplGfx/lib/image.blend.ci:53'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x0: int32 (size: 4, cast: variable(i32))
.param y0: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: const variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param blend: function (size: 4, cast: variable(ref))
.doc: 'copy the `src` image to the destination with an optional blend method'
.value: {
	static if ((preferNativeCalls) && (typename(Image.blend.blendVec4f)) != null) {
		return .result := Image.blend(image, x0, y0, src, roi, blend, Image.blend.blendVec4f);
	}
	static blendVec4f(blend(base: vec4f, with: vec4f): vec4f, base: argb, with: argb): argb := {
		return .result := argb(blend(vec4f(base), vec4f(with)));
	};
	if ((blend) == null) {
		return .result := blend(image, x0, y0, src, roi, null, null);
	}
	return .result := blend(image, x0, y0, src, roi, blend, blendVec4f);
}
.instructions: (93 bytes)
	cmplGfx/lib/image.blend.ci:55: (22 bytes): return .result := Image.blend(image, x0, y0, src, roi, blend, Image.blend.blendVec4f);
	<blend>  : dup.x64 sp(7)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: dup.x64 sp(7)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: load.ref <?> ;Image.blend.blendVec4f
	<blend+?>: nfc(110) ;Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void
	<blend+?>: ret
	cmplGfx/lib/image.blend.ci:60: (43 bytes): if ((blend) == null)
	<blend+?>: dup.x32 sp(1)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jz +35
	cmplGfx/lib/image.blend.ci:61: (31 bytes): return .result := blend(image, x0, y0, src, roi, null, null);
	<blend+?>: dup.x64 sp(7)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: dup.x64 sp(7)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: load.ref <?> ;null
	<blend+?>: load.ref <?> ;null
	<blend+?>: load.ref <?> ;blend(image: Image, x0: int32, y0: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: argb, with: argb): argb): void
	<blend+?>: call
	<blend+?>: inc.sp(-36)
	<blend+?>: ret
	cmplGfx/lib/image.blend.ci:63: (28 bytes): return .result := blend(image, x0, y0, src, roi, blend, blendVec4f);
	<blend+?>: dup.x64 sp(7)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: dup.x64 sp(7)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: load.ref <?> ;blend.blendVec4f(blend(base: vec4f, with: vec4f): vec4f, base: argb, with: argb): argb
	<blend+?>: load.ref <?> ;blend(image: Image, x0: int32, y0: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: argb, with: argb): argb): void
	<blend+?>: call
	<blend+?>: inc.sp(-36)
	<blend+?>: ret
.usages:
}
blend(image: Image, roi: Rect, col: argb): void: function {
.kind: static function
.base: `function`
.size: 134
.name: 'blend'
.file: 'cmplGfx/lib/image.blend.ci:67'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param col: argb (size: 4, cast: variable(val))
.doc: 'fill the destination with the given `col` (alpha channel is used)'
.value: {
	static if ((preferNativeCalls) && (typename(Image.blend.color)) != null) {
		return .result := Image.blend(image, (roi) != null ? roi.x0 : 0, (roi) != null ? roi.y0 : 0, image, roi, col, Image.blend.color);
	}
	static blender(const color: argb, base: argb, with: argb): argb := {
		alpha: int32 := ach(color);
		return .result := {
			.result.b := (mix_s8(alpha, bch(color), bch(base)));
			.result.g := (mix_s8(alpha, gch(color), gch(base)));
			.result.r := (mix_s8(alpha, rch(color), rch(base)));
			.result.a := (alpha);
		};
	};
	return .result := blend(image, (roi) != null ? roi.x0 : 0, (roi) != null ? roi.y0 : 0, image, roi, col, blender);
}
.instructions: (134 bytes)
	cmplGfx/lib/image.blend.ci:69: (64 bytes): return .result := Image.blend(image, (roi) != null ? roi.x0 : 0, (roi) != null ? roi.y0 : 0, image, roi, col, Image.blend.color);
	<blend>  : dup.x64 sp(3)
	<blend+?>: dup.x32 sp(4)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jnz +11
	<blend+?>: dup.x32 sp(4)
	<blend+?>: load.i32
	<blend+?>: jmp +5
	<blend+?>: load.z32
	<blend+?>: dup.x32 sp(5)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jnz +15
	<blend+?>: dup.x32 sp(5)
	<blend+?>: inc.i32(+4)
	<blend+?>: load.i32
	<blend+?>: jmp +5
	<blend+?>: load.z32
	<blend+?>: dup.x64 sp(7)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: load.sp(+32)
	<blend+?>: load.ref <?> ;Image.blend.color
	<blend+?>: nfc(110) ;Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void
	<blend+?>: ret
	cmplGfx/lib/image.blend.ci:80: (70 bytes): return .result := blend(image, (roi) != null ? roi.x0 : 0, (roi) != null ? roi.y0 : 0, image, roi, col, blender);
	<blend+?>: dup.x64 sp(3)
	<blend+?>: dup.x32 sp(4)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jnz +11
	<blend+?>: dup.x32 sp(4)
	<blend+?>: load.i32
	<blend+?>: jmp +5
	<blend+?>: load.z32
	<blend+?>: dup.x32 sp(5)
	<blend+?>: load.ref <?> ;null
	<blend+?>: ceq.i32
	<blend+?>: jnz +15
	<blend+?>: dup.x32 sp(5)
	<blend+?>: inc.i32(+4)
	<blend+?>: load.i32
	<blend+?>: jmp +5
	<blend+?>: load.z32
	<blend+?>: dup.x64 sp(7)
	<blend+?>: dup.x32 sp(8)
	<blend+?>: load.sp(+32)
	<blend+?>: load.ref <?> ;blend.blender(color: argb, base: argb, with: argb): argb
	<blend+?>: load.ref <?> ;blend(image: Image, x0: int32, y0: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: argb, with: argb): argb): void
	<blend+?>: call
	<blend+?>: inc.sp(-36)
	<blend+?>: ret
.usages:
}
blendAlpha(image: Image, x: int32, y: int32, src: Image, roi: Rect, alpha: int32): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'blendAlpha'
.file: 'cmplGfx/lib/image.blend.ci:84'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: const variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param alpha: int32 (size: 4, cast: variable(i32))
.doc: 'copy the `src` image to the destination with the given transparency'
.value: {
	static if ((preferNativeCalls) && (typename(Image.blend.alpha)) != null) {
		return .result := Image.blend(image, x, y, src, roi, alpha, Image.blend.alpha);
	}
	static blender(const alpha: int32, base: argb, with: argb): argb := {
		return .result := {
			.result.b := (sat_s8(mix_s8(alpha, bch(base), bch(with))));
			.result.g := (sat_s8(mix_s8(alpha, gch(base), gch(with))));
			.result.r := (sat_s8(mix_s8(alpha, rch(base), rch(with))));
			.result.a := (alpha);
		};
	};
	return .result := blend(image, x, y, src, roi, alpha, blender);
}
.instructions: (54 bytes)
	cmplGfx/lib/image.blend.ci:86: (24 bytes): return .result := Image.blend(image, x, y, src, roi, alpha, Image.blend.alpha);
	<blendAlpha>  : dup.x64 sp(7)
	<blendAlpha+?>: dup.x32 sp(8)
	<blendAlpha+?>: dup.x32 sp(8)
	<blendAlpha+?>: dup.x64 sp(7)
	<blendAlpha+?>: dup.x32 sp(8)
	<blendAlpha+?>: load.sp(+32)
	<blendAlpha+?>: load.ref <?> ;Image.blend.alpha
	<blendAlpha+?>: nfc(110) ;Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void
	<blendAlpha+?>: ret
	cmplGfx/lib/image.blend.ci:97: (30 bytes): return .result := blend(image, x, y, src, roi, alpha, blender);
	<blendAlpha+?>: dup.x64 sp(7)
	<blendAlpha+?>: dup.x32 sp(8)
	<blendAlpha+?>: dup.x32 sp(8)
	<blendAlpha+?>: dup.x64 sp(7)
	<blendAlpha+?>: dup.x32 sp(8)
	<blendAlpha+?>: load.sp(+32)
	<blendAlpha+?>: load.ref <?> ;blendAlpha.blender(alpha: int32, base: argb, with: argb): argb
	<blendAlpha+?>: load.ref <?> ;blend(image: Image, x0: int32, y0: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: argb, with: argb): argb): void
	<blendAlpha+?>: call
	<blendAlpha+?>: inc.sp(-36)
	<blendAlpha+?>: ret
.usages:
}
blendDstAlpha(image: Image, x: int32, y: int32, src: Image, roi: Rect): void: function {
.kind: static function
.base: `function`
.size: 56
.name: 'blendDstAlpha'
.file: 'cmplGfx/lib/image.blend.ci:101'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: const variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.doc: 'copy the `src` image to the destination masked with destination alpha'
.value: {
	static if ((preferNativeCalls) && (typename(Image.blend.dstAlpha)) != null) {
		return .result := Image.blend(image, x, y, src, roi, null, Image.blend.dstAlpha);
	}
	static blender(null: pointer, base: argb, with: argb): argb := {
		alpha: int32 := ach(base);
		return .result := {
			.result.b := (mix_s8(alpha, bch(base), bch(with)));
			.result.g := (mix_s8(alpha, gch(base), gch(with)));
			.result.r := (mix_s8(alpha, rch(base), rch(with)));
			.result.a := (alpha);
		};
	};
	return .result := blend(image, x, y, src, roi, null, blender);
}
.instructions: (56 bytes)
	cmplGfx/lib/image.blend.ci:103: (25 bytes): return .result := Image.blend(image, x, y, src, roi, null, Image.blend.dstAlpha);
	<blendDstAlpha>  : dup.x64 sp(6)
	<blendDstAlpha+?>: dup.x32 sp(7)
	<blendDstAlpha+?>: dup.x32 sp(7)
	<blendDstAlpha+?>: dup.x64 sp(6)
	<blendDstAlpha+?>: dup.x32 sp(7)
	<blendDstAlpha+?>: load.ref <?> ;null
	<blendDstAlpha+?>: load.ref <?> ;Image.blend.dstAlpha
	<blendDstAlpha+?>: nfc(110) ;Image.blend(image: Image, x: int32, y: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: uint32, with: uint32): uint32): void
	<blendDstAlpha+?>: ret
	cmplGfx/lib/image.blend.ci:115: (31 bytes): return .result := blend(image, x, y, src, roi, null, blender);
	<blendDstAlpha+?>: dup.x64 sp(6)
	<blendDstAlpha+?>: dup.x32 sp(7)
	<blendDstAlpha+?>: dup.x32 sp(7)
	<blendDstAlpha+?>: dup.x64 sp(6)
	<blendDstAlpha+?>: dup.x32 sp(7)
	<blendDstAlpha+?>: load.ref <?> ;null
	<blendDstAlpha+?>: load.ref <?> ;blendDstAlpha.blender(null: pointer, base: argb, with: argb): argb
	<blendDstAlpha+?>: load.ref <?> ;blend(image: Image, x0: int32, y0: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: argb, with: argb): argb): void
	<blendDstAlpha+?>: call
	<blendDstAlpha+?>: inc.sp(-36)
	<blendDstAlpha+?>: ret
.usages:
}
copy(image: Image, x: int32, y: int32, src: Image, roi: Rect): void: function {
.kind: static function
.base: `function`
.size: 31
.name: 'copy'
.file: 'cmplGfx/lib/image.blend.ci:119'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.doc: 'copy or convert `src` image to the destination `image`'
.value: {
	return .result := blend(image, x, y, src, roi, null, null);
}
.instructions: (31 bytes)
	cmplGfx/lib/image.blend.ci:120: (31 bytes): return .result := blend(image, x, y, src, roi, null, null);
	<copy>  : dup.x64 sp(6)
	<copy+?>: dup.x32 sp(7)
	<copy+?>: dup.x32 sp(7)
	<copy+?>: dup.x64 sp(6)
	<copy+?>: dup.x32 sp(7)
	<copy+?>: load.ref <?> ;null
	<copy+?>: load.ref <?> ;null
	<copy+?>: load.ref <?> ;blend(image: Image, x0: int32, y0: int32, src: Image, roi: Rect, extra: pointer, blend(extra: pointer, base: argb, with: argb): argb): void
	<copy+?>: call
	<copy+?>: inc.sp(-36)
	<copy+?>: ret
.usages:
	cmplGfx/lib/window.ci:47: referenced as `copy`
	cmplGfx/lib/image.blend.ci:153: referenced as `copy`
	cmplGfx/lib/image.blend.ci:126: referenced as `copy`
}
Image(copy: Image): Image: function {
.kind: static function
.base: `function`
.size: 46
.name: 'Image'
.file: 'cmplGfx/lib/image.blend.ci:124'
.param .result: Image (size: 8, cast: variable(val))
.param copy: Image (size: 8, cast: variable(val))
.doc: 'Create an image by copying another one'
.value: {
	result: Image := Image.create(Image.width(copy), Image.height(copy), Image.depth(copy));
	copy(result, 0, 0, copy, null);
	return .result := result;
}
.instructions: (46 bytes)
	cmplGfx/lib/image.blend.ci:125: (22 bytes): result: Image := Image.create(Image.width(copy), Image.height(copy), Image.depth(copy))
	<Image>  : dup.x64 sp(1)
	<Image+?>: nfc(101) ;Image.width(image: Image): int32
	<Image+?>: dup.x64 sp(2)
	<Image+?>: nfc(102) ;Image.height(image: Image): int32
	<Image+?>: dup.x64 sp(3)
	<Image+?>: nfc(103) ;Image.depth(image: Image): int32
	<Image+?>: nfc(89) ;Image.create(width: int32, height: int32, depth: int32): Image
	cmplGfx/lib/image.blend.ci:126: (21 bytes): copy(result, 0, 0, copy, null);
	<Image+?>: dup.x64 sp(0)
	<Image+?>: load.z32
	<Image+?>: load.z32
	<Image+?>: dup.x64 sp(7)
	<Image+?>: load.ref <?> ;null
	<Image+?>: load.ref <?> ;copy(image: Image, x: int32, y: int32, src: Image, roi: Rect): void
	<Image+?>: call
	<Image+?>: inc.sp(-28)
	cmplGfx/lib/image.blend.ci:127: (3 bytes): return .result := result;
	<Image+?>: set.x64 sp(5)
	<Image+?>: ret
.usages:
}
tile(image: Image, x: int32, y: int32, src: Image, roi: Rect): void: function {
.kind: static function
.base: `function`
.size: 325
.name: 'tile'
.file: 'cmplGfx/lib/image.blend.ci:131'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.param src: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.doc: 'copy the `src` image multiple times so it fills the whole `image`'
.value: {
	rect: Rect := {
		rect.x0 := (roi) != null ? roi.x0 : 0;
		rect.y0 := (roi) != null ? roi.y0 : 0;
		rect.x1 := (roi) != null ? roi.x1 : Image.width(src);
		rect.y1 := (roi) != null ? roi.y1 : Image.height(src);
	};
	if (!clip(src, &rect)) {
		return;
	}
	if (x < 0) {
		x := -(-x % width(rect));
	}
	if (y < 0) {
		y := -(-y % height(rect));
	}
	width: int32 := Image.width(image);
	height: int32 := Image.height(image);
	for (j: int32 := y; j < height; j := j + height(rect)) {
		for (i: int32 := x; i < width; i := i + width(rect)) {
			copy(image, i, j, src, rect);
		}
	}
}
.instructions: (325 bytes)
	cmplGfx/lib/image.blend.ci:132: (114 bytes): rect: Rect := {...}
	<tile>  : inc.sp(+16)
	cmplGfx/lib/image.blend.ci:133: (22 bytes): rect.x0 := (roi) != null ? roi.x0 : 0;
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +11
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x32 sp(1)
	cmplGfx/lib/image.blend.ci:134: (26 bytes): rect.y0 := (roi) != null ? roi.y0 : 0;
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x32 sp(5)
	<tile+?>: inc.i32(+4)
	<tile+?>: load.i32
	<tile+?>: jmp +5
	<tile+?>: load.z32
	<tile+?>: set.x32 sp(2)
	cmplGfx/lib/image.blend.ci:135: (31 bytes): rect.x1 := (roi) != null ? roi.x1 : Image.width(src);
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x32 sp(5)
	<tile+?>: inc.i32(+8)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x64 sp(6)
	<tile+?>: nfc(101) ;Image.width(image: Image): int32
	<tile+?>: set.x32 sp(3)
	cmplGfx/lib/image.blend.ci:136: (31 bytes): rect.y1 := (roi) != null ? roi.y1 : Image.height(src);
	<tile+?>: dup.x32 sp(5)
	<tile+?>: load.ref <?> ;null
	<tile+?>: ceq.i32
	<tile+?>: jnz +15
	<tile+?>: dup.x32 sp(5)
	<tile+?>: inc.i32(+12)
	<tile+?>: load.i32
	<tile+?>: jmp +10
	<tile+?>: dup.x64 sp(6)
	<tile+?>: nfc(102) ;Image.height(image: Image): int32
	<tile+?>: set.x32 sp(4)
	cmplGfx/lib/image.blend.ci:139: (26 bytes): if (!clip(src, &rect))
	<tile+?>: load.z32
	<tile+?>: dup.x64 sp(7)
	<tile+?>: load.sp(+12)
	<tile+?>: load.ref <?> ;clip(image: Image, roi: Rect): bool
	<tile+?>: call
	<tile+?>: inc.sp(-12)
	<tile+?>: jnz +9
	cmplGfx/lib/image.blend.ci:140: (5 bytes): return;
	<tile+?>: inc.sp(-16)
	<tile+?>: ret
	cmplGfx/lib/image.blend.ci:143: (32 bytes): if (x < 0)
	<tile+?>: dup.x32 sp(9)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +28
	cmplGfx/lib/image.blend.ci:144: (24 bytes): x := -(-x % width(rect));
	<tile+?>: dup.x32 sp(9)
	<tile+?>: neg.i32
	<tile+?>: load.sp(+4)
	<tile+?>: dup.x32 sp(0)
	<tile+?>: inc.i32(+8)
	<tile+?>: load.i32
	<tile+?>: dup.x32 sp(1)
	<tile+?>: load.i32
	<tile+?>: sub.i32
	<tile+?>: set.x32 sp(1)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x32 sp(10)
	cmplGfx/lib/image.blend.ci:146: (36 bytes): if (y < 0)
	<tile+?>: dup.x32 sp(8)
	<tile+?>: load.z32
	<tile+?>: clt.i32
	<tile+?>: jz +32
	cmplGfx/lib/image.blend.ci:147: (28 bytes): y := -(-y % height(rect));
	<tile+?>: dup.x32 sp(8)
	<tile+?>: neg.i32
	<tile+?>: load.sp(+4)
	<tile+?>: dup.x32 sp(0)
	<tile+?>: inc.i32(+12)
	<tile+?>: load.i32
	<tile+?>: dup.x32 sp(1)
	<tile+?>: inc.i32(+4)
	<tile+?>: load.i32
	<tile+?>: sub.i32
	<tile+?>: set.x32 sp(1)
	<tile+?>: mod.i32
	<tile+?>: neg.i32
	<tile+?>: set.x32 sp(9)
	cmplGfx/lib/image.blend.ci:149: (6 bytes): width: int32 := Image.width(image)
	<tile+?>: dup.x64 sp(10)
	<tile+?>: nfc(101) ;Image.width(image: Image): int32
	cmplGfx/lib/image.blend.ci:150: (6 bytes): height: int32 := Image.height(image)
	<tile+?>: dup.x64 sp(11)
	<tile+?>: nfc(102) ;Image.height(image: Image): int32
	cmplGfx/lib/image.blend.ci:151: (100 bytes): for (j: int32 := y; j < height; j := j + height(rect))
	<tile+?>: dup.x32 sp(10)
	<tile+?>: jmp +85
	cmplGfx/lib/image.blend.ci:152: (59 bytes): for (i: int32 := x; i < width; i := i + width(rect))
	<tile+?>: dup.x32 sp(12)
	<tile+?>: jmp +44
	cmplGfx/lib/image.blend.ci:153: (22 bytes): copy(image, i, j, src, rect);
	<tile+?>: dup.x64 sp(14)
	<tile+?>: dup.x32 sp(2)
	<tile+?>: dup.x32 sp(4)
	<tile+?>: dup.x64 sp(14)
	<tile+?>: load.sp(+40)
	<tile+?>: load.ref <?> ;copy(image: Image, x: int32, y: int32, src: Image, roi: Rect): void
	<tile+?>: call
	<tile+?>: inc.sp(-28)
	cmplGfx/lib/image.blend.ci:152: (18 bytes): i := i + width(rect)
	<tile+?>: load.sp(+16)
	<tile+?>: dup.x32 sp(0)
	<tile+?>: inc.i32(+8)
	<tile+?>: load.i32
	<tile+?>: dup.x32 sp(1)
	<tile+?>: load.i32
	<tile+?>: sub.i32
	<tile+?>: set.x32 sp(1)
	<tile+?>: add.i32
	cmplGfx/lib/image.blend.ci:152: (9 bytes): i < width
	<tile+?>: dup.x32 sp(0)
	<tile+?>: dup.x32 sp(4)
	<tile+?>: clt.i32
	<tile+?>: jnz -45
	<tile+?>: inc.sp(-4)
	cmplGfx/lib/image.blend.ci:151: (22 bytes): j := j + height(rect)
	<tile+?>: load.sp(+12)
	<tile+?>: dup.x32 sp(0)
	<tile+?>: inc.i32(+12)
	<tile+?>: load.i32
	<tile+?>: dup.x32 sp(1)
	<tile+?>: inc.i32(+4)
	<tile+?>: load.i32
	<tile+?>: sub.i32
	<tile+?>: set.x32 sp(1)
	<tile+?>: add.i32
	cmplGfx/lib/image.blend.ci:151: (9 bytes): j < height
	<tile+?>: dup.x32 sp(0)
	<tile+?>: dup.x32 sp(2)
	<tile+?>: clt.i32
	<tile+?>: jnz -86
	<tile+?>: inc.sp(-4)
	<tile+?>: inc.sp(-24)
	<tile+?>: ret
.usages:
}
eval(image: Image, roi: Rect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void: function {
.kind: static function
.base: `function`
.size: 491
.name: 'eval'
.file: 'cmplGfx/lib/image.blend.ci:159'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param aspect: float32 (size: 4, cast: variable(f32))
.param time: float32 (size: 4, cast: variable(f32))
.param eval: function (size: 4, cast: variable(ref))
.doc: 'Fill the surface by evaluating the given function for each pixel'
.value: {
	rect: Rect := {
		rect.x0 := (roi) != null ? roi.x0 : 0;
		rect.y0 := (roi) != null ? roi.y0 : 0;
		rect.x1 := (roi) != null ? roi.x1 : Image.width(image);
		rect.y1 := (roi) != null ? roi.y1 : Image.height(image);
	};
	if (!clip(image, &rect)) {
		return;
	}
	w: float32 := Image.width(image);
	h: float32 := Image.height(image);
	if (aspect == (0)) {
		aspect := w / h;
	}
	h := h * aspect;
	in: vec4f := vec4f(0, 0, 0, time);
	for (y: int32 := rect.y0; y < rect.y1; y := y + 1) {
		in.y := (y) / h;
		for (x: int32 := rect.x0; x < rect.x1; x := x + 1) {
			in.x := (x) / w;
			set(image, x, y, argb(eval(in)));
		}
	}
}
.instructions: (491 bytes)
	cmplGfx/lib/image.blend.ci:160: (114 bytes): rect: Rect := {...}
	<eval>  : inc.sp(+16)
	cmplGfx/lib/image.blend.ci:161: (22 bytes): rect.x0 := (roi) != null ? roi.x0 : 0;
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +11
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(1)
	cmplGfx/lib/image.blend.ci:162: (26 bytes): rect.y0 := (roi) != null ? roi.y0 : 0;
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x32 sp(8)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: jmp +5
	<eval+?>: load.z32
	<eval+?>: set.x32 sp(2)
	cmplGfx/lib/image.blend.ci:163: (31 bytes): rect.x1 := (roi) != null ? roi.x1 : Image.width(image);
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x32 sp(8)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x64 sp(9)
	<eval+?>: nfc(101) ;Image.width(image: Image): int32
	<eval+?>: set.x32 sp(3)
	cmplGfx/lib/image.blend.ci:164: (31 bytes): rect.y1 := (roi) != null ? roi.y1 : Image.height(image);
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.ref <?> ;null
	<eval+?>: ceq.i32
	<eval+?>: jnz +15
	<eval+?>: dup.x32 sp(8)
	<eval+?>: inc.i32(+12)
	<eval+?>: load.i32
	<eval+?>: jmp +10
	<eval+?>: dup.x64 sp(9)
	<eval+?>: nfc(102) ;Image.height(image: Image): int32
	<eval+?>: set.x32 sp(4)
	cmplGfx/lib/image.blend.ci:167: (26 bytes): if (!clip(image, &rect))
	<eval+?>: load.z32
	<eval+?>: dup.x64 sp(10)
	<eval+?>: load.sp(+12)
	<eval+?>: load.ref <?> ;clip(image: Image, roi: Rect): bool
	<eval+?>: call
	<eval+?>: inc.sp(-12)
	<eval+?>: jnz +9
	cmplGfx/lib/image.blend.ci:168: (5 bytes): return;
	<eval+?>: inc.sp(-16)
	<eval+?>: ret
	cmplGfx/lib/image.blend.ci:171: (7 bytes): w: float32 := Image.width(image)
	<eval+?>: dup.x64 sp(9)
	<eval+?>: nfc(101) ;Image.width(image: Image): int32
	<eval+?>: i32.2f32
	cmplGfx/lib/image.blend.ci:172: (7 bytes): h: float32 := Image.height(image)
	<eval+?>: dup.x64 sp(10)
	<eval+?>: nfc(102) ;Image.height(image: Image): int32
	<eval+?>: i32.2f32
	cmplGfx/lib/image.blend.ci:173: (15 bytes): if (aspect == (0))
	<eval+?>: dup.x32 sp(9)
	<eval+?>: load.z32
	<eval+?>: ceq.f32
	<eval+?>: jz +11
	cmplGfx/lib/image.blend.ci:174: (7 bytes): aspect := w / h;
	<eval+?>: dup.x32 sp(1)
	<eval+?>: dup.x32 sp(1)
	<eval+?>: div.f32
	<eval+?>: set.x32 sp(10)
	cmplGfx/lib/image.blend.ci:176: (3 bytes): h := h * aspect;
	<eval+?>: dup.x32 sp(9)
	<eval+?>: mul.f32
	cmplGfx/lib/image.blend.ci:178: (5 bytes): in: vec4f := vec4f(0, 0, 0, time)
	<eval+?>: dup.x32 sp(8)
	<eval+?>: load.z32
	<eval+?>: load.z32
	<eval+?>: load.z32
	cmplGfx/lib/image.blend.ci:179: (309 bytes): for (y: int32 := rect.y0; y < rect.y1; y := y + 1)
	<eval+?>: dup.x32 sp(7)
	<eval+?>: jmp +294
	cmplGfx/lib/image.blend.ci:180: (8 bytes): in.y := (y) / h;
	<eval+?>: dup.x32 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x32 sp(6)
	<eval+?>: div.f32
	<eval+?>: set.x32 sp(3)
	cmplGfx/lib/image.blend.ci:181: (278 bytes): for (x: int32 := rect.x0; x < rect.x1; x := x + 1)
	<eval+?>: dup.x32 sp(7)
	<eval+?>: jmp +263
	cmplGfx/lib/image.blend.ci:182: (8 bytes): in.x := (x) / w;
	<eval+?>: dup.x32 sp(0)
	<eval+?>: i32.2f32
	<eval+?>: dup.x32 sp(8)
	<eval+?>: div.f32
	<eval+?>: set.x32 sp(3)
	cmplGfx/lib/image.blend.ci:183: (247 bytes): set(image, x, y, argb(eval(in)));
	<eval+?>: dup.x64 sp(17)
	<eval+?>: dup.x32 sp(2)
	<eval+?>: dup.x32 sp(4)
	<eval+?>: inc.sp(+16)
	<eval+?>: dup.x128 sp(10)
	<eval+?>: dup.x32 sp(25)
	<eval+?>: call
	<eval+?>: inc.sp(-16)
	<eval+?>: load.sp(+0)
	<eval+?>: dup.x32 sp(0)
	<eval+?>: inc.i32(+12)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.c32 255
	<eval+?>: cgt.i32
	<eval+?>: jz +13
	<eval+?>: load.c32 255
	<eval+?>: jmp +19
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz +9
	<eval+?>: load.z32
	<eval+?>: jmp +6
	<eval+?>: dup.x32 sp(0)
	<eval+?>: set.x32 sp(1)
	<eval+?>: b32.shl 0x08
	<eval+?>: dup.x32 sp(1)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.c32 255
	<eval+?>: cgt.i32
	<eval+?>: jz +13
	<eval+?>: load.c32 255
	<eval+?>: jmp +19
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz +9
	<eval+?>: load.z32
	<eval+?>: jmp +6
	<eval+?>: dup.x32 sp(0)
	<eval+?>: set.x32 sp(1)
	<eval+?>: or.b32
	<eval+?>: b32.shl 0x08
	<eval+?>: dup.x32 sp(1)
	<eval+?>: inc.i32(+4)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.c32 255
	<eval+?>: cgt.i32
	<eval+?>: jz +13
	<eval+?>: load.c32 255
	<eval+?>: jmp +19
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz +9
	<eval+?>: load.z32
	<eval+?>: jmp +6
	<eval+?>: dup.x32 sp(0)
	<eval+?>: set.x32 sp(1)
	<eval+?>: or.b32
	<eval+?>: b32.shl 0x08
	<eval+?>: dup.x32 sp(1)
	<eval+?>: inc.i32(+8)
	<eval+?>: load.i32
	<eval+?>: load.f32 255.000000
	<eval+?>: mul.f32
	<eval+?>: f32.2i32
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.c32 255
	<eval+?>: cgt.i32
	<eval+?>: jz +13
	<eval+?>: load.c32 255
	<eval+?>: jmp +19
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz +9
	<eval+?>: load.z32
	<eval+?>: jmp +6
	<eval+?>: dup.x32 sp(0)
	<eval+?>: set.x32 sp(1)
	<eval+?>: or.b32
	<eval+?>: mov.x32 sp(5, 0)
	<eval+?>: inc.sp(-20)
	<eval+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	cmplGfx/lib/image.blend.ci:181: (4 bytes): x := x + 1
	<eval+?>: inc.i32(+1)
	cmplGfx/lib/image.blend.ci:181: (9 bytes): x < rect.x1
	<eval+?>: dup.x32 sp(0)
	<eval+?>: dup.x32 sp(11)
	<eval+?>: clt.i32
	<eval+?>: jnz -264
	<eval+?>: inc.sp(-4)
	cmplGfx/lib/image.blend.ci:179: (4 bytes): y := y + 1
	<eval+?>: inc.i32(+1)
	cmplGfx/lib/image.blend.ci:179: (9 bytes): y < rect.y1
	<eval+?>: dup.x32 sp(0)
	<eval+?>: dup.x32 sp(11)
	<eval+?>: clt.i32
	<eval+?>: jnz -295
	<eval+?>: inc.sp(-4)
	<eval+?>: inc.sp(-40)
	<eval+?>: ret
.usages:
	cmplGfx/lib/window.ci:142: referenced as `eval`
	cmplGfx/lib/window.ci:124: referenced as `eval`
	cmplGfx/lib/window.ci:108: referenced as `eval`
}
transform(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32, mat: mat4f): void: function {
.kind: static function
.base: `function`
.size: 1354
.name: 'transform'
.file: 'cmplGfx/lib/image.transform.ci:2'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 4, cast: const variable(ref))
.param src: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param interpolate: int32 (size: 4, cast: variable(i32))
.param mat: mat4f (size: 4, cast: const variable(ref))
.doc: 'Copy one image to another using a transformation matrix [scale, rotate, translate, shear, perspective, etc]'
.value: {
	static if ((preferNativeCalls) && (typename(Image.transform)) != null) {
		return .result := Image.transform(image, rect, src, roi, interpolate, pointer(mat.data));
	}
	assert(Image.depth(image) == 32);
	assert(Image.depth(src) == 32);
	dRec: Rect := {
		dRec.x0 := (rect) != null ? rect.x0 : 0;
		dRec.y0 := (rect) != null ? rect.y0 : 0;
		dRec.x1 := (rect) != null ? rect.x1 : Image.width(image);
		dRec.y1 := (rect) != null ? rect.y1 : Image.height(image);
	};
	sRec: Rect := {
		sRec.x0 := (roi) != null ? roi.x0 : 0;
		sRec.y0 := (roi) != null ? roi.y0 : 0;
		sRec.x1 := (roi) != null ? roi.x1 : Image.width(src);
		sRec.y1 := (roi) != null ? roi.y1 : Image.height(src);
	};
	if ((mat) == null) {
		scale: mat4f := {
			scale.x := vec4f(float32(width(sRec)) / (width(dRec)), 0, 0, sRec.x0);
			scale.y := vec4f(0, float32(height(sRec)) / (height(dRec)), 0, sRec.y0);
			scale.z := vec4f(0, 0, 1, 0);
			scale.w := vec4f(0, 0, 0, 1);
		};
		scale := mul(scale, translation(vec4f(dRec.x0, dRec.y0, 0, 0), -1));
		return .result := transform(image, rect, src, roi, interpolate, scale);
	}
	if (!clip(image, &dRec)) {
		return;
	}
	if (!clip(src, &sRec)) {
		return;
	}
	if (interpolate == 0) {
		for (y: int32 := dRec.y0; y < dRec.y1; y := y + 1) {
			for (x: int32 := dRec.x0; x < dRec.x1; x := x + 1) {
				t: vec4f := dph(mat, vec4f(x, y, 0, 1));
				Image.set(image, x, y, Image.get(src, t.x, t.y));
			}
		}
		return;
	}
	transform: mat4f := mul(scale(vec4f(Image.width(src), Image.height(src), 0, 0), 1), mat);
	for (y: int32 := dRec.y0; y < dRec.y1; y := y + 1) {
		for (x: int32 := dRec.x0; x < dRec.x1; x := x + 1) {
			t: vec4f := dph(transform, vec4f(x, y, 0, 1));
			set(image, x, y, argb(Image.tex(src, t.x, t.y)));
		}
	}
}
.instructions: (1354 bytes)
	cmplGfx/lib/image.transform.ci:4: (17 bytes): return .result := Image.transform(image, rect, src, roi, interpolate, pointer(mat.data));
	<transform>  : dup.x64 sp(7)
	<transform+?>: dup.x32 sp(8)
	<transform+?>: dup.x64 sp(7)
	<transform+?>: dup.x32 sp(8)
	<transform+?>: dup.x32 sp(8)
	<transform+?>: dup.x32 sp(8)
	<transform+?>: nfc(111) ;Image.transform(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32, mat: float32[16]): void
	<transform+?>: ret
	cmplGfx/lib/image.transform.ci:7: (60 bytes): assert(Image.depth(image) == 32);
	<transform+?>: load.z32
	<transform+?>: load.sp(+4)
	<transform+?>: dup.x64 sp(9)
	<transform+?>: nfc(103) ;Image.depth(image: Image): int32
	<transform+?>: load.c32 32
	<transform+?>: ceq.i32
	<transform+?>: jz +8
	<transform+?>: jmp +35
	<transform+?>: load.ref <?> ;"cmplGfx/lib/image.transform.ci"
	<transform+?>: load.c32 7
	<transform+?>: load.c32 -2
	<transform+?>: load.c32 128
	<transform+?>: load.ref <?> ;"assertion failed!"
	<transform+?>: dup.x64 sp(5)
	<transform+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<transform+?>: inc.sp(-8)
	cmplGfx/lib/image.transform.ci:8: (60 bytes): assert(Image.depth(src) == 32);
	<transform+?>: load.z32
	<transform+?>: load.sp(+4)
	<transform+?>: dup.x64 sp(6)
	<transform+?>: nfc(103) ;Image.depth(image: Image): int32
	<transform+?>: load.c32 32
	<transform+?>: ceq.i32
	<transform+?>: jz +8
	<transform+?>: jmp +35
	<transform+?>: load.ref <?> ;"cmplGfx/lib/image.transform.ci"
	<transform+?>: load.c32 8
	<transform+?>: load.c32 -2
	<transform+?>: load.c32 128
	<transform+?>: load.ref <?> ;"assertion failed!"
	<transform+?>: dup.x64 sp(5)
	<transform+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<transform+?>: inc.sp(-8)
	cmplGfx/lib/image.transform.ci:10: (114 bytes): dRec: Rect := {...}
	<transform+?>: inc.sp(+16)
	cmplGfx/lib/image.transform.ci:11: (22 bytes): dRec.x0 := (rect) != null ? rect.x0 : 0;
	<transform+?>: dup.x32 sp(10)
	<transform+?>: load.ref <?> ;null
	<transform+?>: ceq.i32
	<transform+?>: jnz +11
	<transform+?>: dup.x32 sp(10)
	<transform+?>: load.i32
	<transform+?>: jmp +5
	<transform+?>: load.z32
	<transform+?>: set.x32 sp(1)
	cmplGfx/lib/image.transform.ci:12: (26 bytes): dRec.y0 := (rect) != null ? rect.y0 : 0;
	<transform+?>: dup.x32 sp(10)
	<transform+?>: load.ref <?> ;null
	<transform+?>: ceq.i32
	<transform+?>: jnz +15
	<transform+?>: dup.x32 sp(10)
	<transform+?>: inc.i32(+4)
	<transform+?>: load.i32
	<transform+?>: jmp +5
	<transform+?>: load.z32
	<transform+?>: set.x32 sp(2)
	cmplGfx/lib/image.transform.ci:13: (31 bytes): dRec.x1 := (rect) != null ? rect.x1 : Image.width(image);
	<transform+?>: dup.x32 sp(10)
	<transform+?>: load.ref <?> ;null
	<transform+?>: ceq.i32
	<transform+?>: jnz +15
	<transform+?>: dup.x32 sp(10)
	<transform+?>: inc.i32(+8)
	<transform+?>: load.i32
	<transform+?>: jmp +10
	<transform+?>: dup.x64 sp(11)
	<transform+?>: nfc(101) ;Image.width(image: Image): int32
	<transform+?>: set.x32 sp(3)
	cmplGfx/lib/image.transform.ci:14: (31 bytes): dRec.y1 := (rect) != null ? rect.y1 : Image.height(image);
	<transform+?>: dup.x32 sp(10)
	<transform+?>: load.ref <?> ;null
	<transform+?>: ceq.i32
	<transform+?>: jnz +15
	<transform+?>: dup.x32 sp(10)
	<transform+?>: inc.i32(+12)
	<transform+?>: load.i32
	<transform+?>: jmp +10
	<transform+?>: dup.x64 sp(11)
	<transform+?>: nfc(102) ;Image.height(image: Image): int32
	<transform+?>: set.x32 sp(4)
	cmplGfx/lib/image.transform.ci:16: (114 bytes): sRec: Rect := {...}
	<transform+?>: inc.sp(+16)
	cmplGfx/lib/image.transform.ci:17: (22 bytes): sRec.x0 := (roi) != null ? roi.x0 : 0;
	<transform+?>: dup.x32 sp(11)
	<transform+?>: load.ref <?> ;null
	<transform+?>: ceq.i32
	<transform+?>: jnz +11
	<transform+?>: dup.x32 sp(11)
	<transform+?>: load.i32
	<transform+?>: jmp +5
	<transform+?>: load.z32
	<transform+?>: set.x32 sp(1)
	cmplGfx/lib/image.transform.ci:18: (26 bytes): sRec.y0 := (roi) != null ? roi.y0 : 0;
	<transform+?>: dup.x32 sp(11)
	<transform+?>: load.ref <?> ;null
	<transform+?>: ceq.i32
	<transform+?>: jnz +15
	<transform+?>: dup.x32 sp(11)
	<transform+?>: inc.i32(+4)
	<transform+?>: load.i32
	<transform+?>: jmp +5
	<transform+?>: load.z32
	<transform+?>: set.x32 sp(2)
	cmplGfx/lib/image.transform.ci:19: (31 bytes): sRec.x1 := (roi) != null ? roi.x1 : Image.width(src);
	<transform+?>: dup.x32 sp(11)
	<transform+?>: load.ref <?> ;null
	<transform+?>: ceq.i32
	<transform+?>: jnz +15
	<transform+?>: dup.x32 sp(11)
	<transform+?>: inc.i32(+8)
	<transform+?>: load.i32
	<transform+?>: jmp +10
	<transform+?>: dup.x64 sp(12)
	<transform+?>: nfc(101) ;Image.width(image: Image): int32
	<transform+?>: set.x32 sp(3)
	cmplGfx/lib/image.transform.ci:20: (31 bytes): sRec.y1 := (roi) != null ? roi.y1 : Image.height(src);
	<transform+?>: dup.x32 sp(11)
	<transform+?>: load.ref <?> ;null
	<transform+?>: ceq.i32
	<transform+?>: jnz +15
	<transform+?>: dup.x32 sp(11)
	<transform+?>: inc.i32(+12)
	<transform+?>: load.i32
	<transform+?>: jmp +10
	<transform+?>: dup.x64 sp(12)
	<transform+?>: nfc(102) ;Image.height(image: Image): int32
	<transform+?>: set.x32 sp(4)
	cmplGfx/lib/image.transform.ci:22: (298 bytes): if ((mat) == null)
	<transform+?>: dup.x32 sp(9)
	<transform+?>: load.ref <?> ;null
	<transform+?>: ceq.i32
	<transform+?>: jz +290
	cmplGfx/lib/image.transform.ci:23: (120 bytes): scale: mat4f := {...}
	<transform+?>: inc.sp(+64)
	cmplGfx/lib/image.transform.ci:24: (44 bytes): scale.x := vec4f(float32(width(sRec)) / (width(dRec)), 0, 0, sRec.x0);
	<transform+?>: dup.x32 sp(16)
	<transform+?>: i32.2f32
	<transform+?>: load.z32
	<transform+?>: load.z32
	<transform+?>: load.sp(+76)
	<transform+?>: dup.x32 sp(0)
	<transform+?>: inc.i32(+8)
	<transform+?>: load.i32
	<transform+?>: dup.x32 sp(1)
	<transform+?>: load.i32
	<transform+?>: sub.i32
	<transform+?>: set.x32 sp(1)
	<transform+?>: i32.2f32
	<transform+?>: load.sp(+96)
	<transform+?>: dup.x32 sp(0)
	<transform+?>: inc.i32(+8)
	<transform+?>: load.i32
	<transform+?>: dup.x32 sp(1)
	<transform+?>: load.i32
	<transform+?>: sub.i32
	<transform+?>: set.x32 sp(1)
	<transform+?>: i32.2f32
	<transform+?>: div.f32
	<transform+?>: set.x128 sp(4)
	cmplGfx/lib/image.transform.ci:25: (52 bytes): scale.y := vec4f(0, float32(height(sRec)) / (height(dRec)), 0, sRec.y0);
	<transform+?>: dup.x32 sp(17)
	<transform+?>: i32.2f32
	<transform+?>: load.z32
	<transform+?>: load.sp(+72)
	<transform+?>: dup.x32 sp(0)
	<transform+?>: inc.i32(+12)
	<transform+?>: load.i32
	<transform+?>: dup.x32 sp(1)
	<transform+?>: inc.i32(+4)
	<transform+?>: load.i32
	<transform+?>: sub.i32
	<transform+?>: set.x32 sp(1)
	<transform+?>: i32.2f32
	<transform+?>: load.sp(+92)
	<transform+?>: dup.x32 sp(0)
	<transform+?>: inc.i32(+12)
	<transform+?>: load.i32
	<transform+?>: dup.x32 sp(1)
	<transform+?>: inc.i32(+4)
	<transform+?>: load.i32
	<transform+?>: sub.i32
	<transform+?>: set.x32 sp(1)
	<transform+?>: i32.2f32
	<transform+?>: div.f32
	<transform+?>: load.z32
	<transform+?>: set.x128 sp(8)
	cmplGfx/lib/image.transform.ci:26: (10 bytes): scale.z := vec4f(0, 0, 1, 0);
	<transform+?>: load.z32
	<transform+?>: load.f32 1.000000
	<transform+?>: load.z32
	<transform+?>: load.z32
	<transform+?>: set.x128 sp(12)
	cmplGfx/lib/image.transform.ci:27: (10 bytes): scale.w := vec4f(0, 0, 0, 1);
	<transform+?>: load.f32 1.000000
	<transform+?>: load.z32
	<transform+?>: load.z32
	<transform+?>: load.z32
	<transform+?>: set.x128 sp(16)
	cmplGfx/lib/image.transform.ci:29: (133 bytes): scale := mul(scale, translation(vec4f(dRec.x0, dRec.y0, 0, 0), -1));
	<transform+?>: load.z32
	<transform+?>: load.z32
	<transform+?>: dup.x32 sp(23)
	<transform+?>: i32.2f32
	<transform+?>: dup.x32 sp(23)
	<transform+?>: i32.2f32
	<transform+?>: inc.sp(+64)
	<transform+?>: load.sp(+64)
	<transform+?>: load.f32 -1.000000
	<transform+?>: load.ref <?> ;translation(direction: vec4f, amount: float32): mat4f
	<transform+?>: call
	<transform+?>: load.sp(+8)
	<transform+?>: load.sp(-60)
	<transform+?>: copy.mem -64
	<transform+?>: inc.sp(+64)
	<transform+?>: load.sp(+88)
	<transform+?>: load.sp(+4)
	<transform+?>: copy.mem 64
	<transform+?>: inc.sp(-64)
	<transform+?>: inc.sp(-24)
	<transform+?>: inc.sp(+64)
	<transform+?>: load.sp(+128)
	<transform+?>: load.sp(+68)
	<transform+?>: load.ref <?> ;mul(lhs: mat4f, rhs: mat4f): mat4f
	<transform+?>: call
	<transform+?>: load.sp(+8)
	<transform+?>: load.sp(-60)
	<transform+?>: copy.mem -64
	<transform+?>: inc.sp(+64)
	<transform+?>: load.sp(+136)
	<transform+?>: load.sp(+4)
	<transform+?>: copy.mem 64
	<transform+?>: inc.sp(-64)
	<transform+?>: inc.sp(-72)
	<transform+?>: load.sp(+64)
	<transform+?>: load.sp(+4)
	<transform+?>: copy.mem 64
	<transform+?>: inc.sp(-64)
	cmplGfx/lib/image.transform.ci:30: (29 bytes): return .result := transform(image, rect, src, roi, interpolate, scale);
	<transform+?>: dup.x64 sp(31)
	<transform+?>: dup.x32 sp(32)
	<transform+?>: dup.x64 sp(31)
	<transform+?>: dup.x32 sp(32)
	<transform+?>: dup.x32 sp(32)
	<transform+?>: load.sp(+28)
	<transform+?>: load.ref <?> ;transform(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32, mat: mat4f): void
	<transform+?>: call
	<transform+?>: inc.sp(-32)
	<transform+?>: inc.sp(-96)
	<transform+?>: ret
	<transform+?>: inc.sp(-64)
	cmplGfx/lib/image.transform.ci:33: (26 bytes): if (!clip(image, &dRec))
	<transform+?>: load.z32
	<transform+?>: dup.x64 sp(16)
	<transform+?>: load.sp(+28)
	<transform+?>: load.ref <?> ;clip(image: Image, roi: Rect): bool
	<transform+?>: call
	<transform+?>: inc.sp(-12)
	<transform+?>: jnz +9
	cmplGfx/lib/image.transform.ci:35: (5 bytes): return;
	<transform+?>: inc.sp(-32)
	<transform+?>: ret
	cmplGfx/lib/image.transform.ci:38: (26 bytes): if (!clip(src, &sRec))
	<transform+?>: load.z32
	<transform+?>: dup.x64 sp(13)
	<transform+?>: load.sp(+12)
	<transform+?>: load.ref <?> ;clip(image: Image, roi: Rect): bool
	<transform+?>: call
	<transform+?>: inc.sp(-12)
	<transform+?>: jnz +9
	cmplGfx/lib/image.transform.ci:40: (5 bytes): return;
	<transform+?>: inc.sp(-32)
	<transform+?>: ret
	cmplGfx/lib/image.transform.ci:43: (150 bytes): if (interpolate == 0)
	<transform+?>: dup.x32 sp(10)
	<transform+?>: load.z32
	<transform+?>: ceq.i32
	<transform+?>: jz +146
	cmplGfx/lib/image.transform.ci:44: (137 bytes): for (y: int32 := dRec.y0; y < dRec.y1; y := y + 1)
	<transform+?>: dup.x32 sp(5)
	<transform+?>: jmp +122
	cmplGfx/lib/image.transform.ci:45: (114 bytes): for (x: int32 := dRec.x0; x < dRec.x1; x := x + 1)
	<transform+?>: dup.x32 sp(5)
	<transform+?>: jmp +99
	cmplGfx/lib/image.transform.ci:46: (65 bytes): t: vec4f := dph(mat, vec4f(x, y, 0, 1))
	<transform+?>: load.f32 1.000000
	<transform+?>: load.z32
	<transform+?>: dup.x32 sp(3)
	<transform+?>: i32.2f32
	<transform+?>: dup.x32 sp(3)
	<transform+?>: i32.2f32
	<transform+?>: dup.x32 sp(15)
	<transform+?>: load.sp(+4)
	<transform+?>: dup.x32 sp(1)
	<transform+?>: inc.i32(+48)
	<transform+?>: load.i128
	<transform+?>: dup.x32 sp(4)
	<transform+?>: load.i128
	<transform+?>: dph.v4f
	<transform+?>: dup.x32 sp(2)
	<transform+?>: inc.i32(+32)
	<transform+?>: load.i128
	<transform+?>: dup.x32 sp(5)
	<transform+?>: load.i128
	<transform+?>: dph.v4f
	<transform+?>: dup.x32 sp(3)
	<transform+?>: inc.i32(+16)
	<transform+?>: load.i128
	<transform+?>: dup.x32 sp(6)
	<transform+?>: load.i128
	<transform+?>: dph.v4f
	<transform+?>: dup.x32 sp(4)
	<transform+?>: load.i128
	<transform+?>: dup.x32 sp(7)
	<transform+?>: load.i128
	<transform+?>: dph.v4f
	<transform+?>: mov.x128 sp(6, 0)
	<transform+?>: inc.sp(-24)
	cmplGfx/lib/image.transform.ci:47: (22 bytes): Image.set(image, x, y, Image.get(src, t.x, t.y));
	<transform+?>: dup.x64 sp(21)
	<transform+?>: dup.x32 sp(6)
	<transform+?>: dup.x32 sp(8)
	<transform+?>: dup.x64 sp(22)
	<transform+?>: dup.x32 sp(6)
	<transform+?>: f32.2i32
	<transform+?>: dup.x32 sp(8)
	<transform+?>: f32.2i32
	<transform+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	<transform+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<transform+?>: inc.sp(-16)
	cmplGfx/lib/image.transform.ci:45: (4 bytes): x := x + 1
	<transform+?>: inc.i32(+1)
	cmplGfx/lib/image.transform.ci:45: (9 bytes): x < dRec.x1
	<transform+?>: dup.x32 sp(0)
	<transform+?>: dup.x32 sp(9)
	<transform+?>: clt.i32
	<transform+?>: jnz -100
	<transform+?>: inc.sp(-4)
	cmplGfx/lib/image.transform.ci:44: (4 bytes): y := y + 1
	<transform+?>: inc.i32(+1)
	cmplGfx/lib/image.transform.ci:44: (9 bytes): y < dRec.y1
	<transform+?>: dup.x32 sp(0)
	<transform+?>: dup.x32 sp(9)
	<transform+?>: clt.i32
	<transform+?>: jnz -123
	<transform+?>: inc.sp(-4)
	cmplGfx/lib/image.transform.ci:50: (5 bytes): return;
	<transform+?>: inc.sp(-32)
	<transform+?>: ret
	cmplGfx/lib/image.transform.ci:54: (123 bytes): transform: mat4f := mul(scale(vec4f(Image.width(src), Image.height(src), 0, 0), 1), mat)
	<transform+?>: load.z32
	<transform+?>: load.z32
	<transform+?>: dup.x64 sp(14)
	<transform+?>: nfc(102) ;Image.height(image: Image): int32
	<transform+?>: i32.2f32
	<transform+?>: dup.x64 sp(15)
	<transform+?>: nfc(101) ;Image.width(image: Image): int32
	<transform+?>: i32.2f32
	<transform+?>: inc.sp(+64)
	<transform+?>: load.sp(+64)
	<transform+?>: load.f32 1.000000
	<transform+?>: load.ref <?> ;scale(direction: vec4f, amount: float32): mat4f
	<transform+?>: call
	<transform+?>: load.sp(+8)
	<transform+?>: load.sp(-60)
	<transform+?>: copy.mem -64
	<transform+?>: inc.sp(+64)
	<transform+?>: load.sp(+88)
	<transform+?>: load.sp(+4)
	<transform+?>: copy.mem 64
	<transform+?>: inc.sp(-64)
	<transform+?>: inc.sp(-24)
	<transform+?>: inc.sp(+64)
	<transform+?>: load.sp(+64)
	<transform+?>: dup.x32 sp(42)
	<transform+?>: load.ref <?> ;mul(lhs: mat4f, rhs: mat4f): mat4f
	<transform+?>: call
	<transform+?>: load.sp(+8)
	<transform+?>: load.sp(-60)
	<transform+?>: copy.mem -64
	<transform+?>: inc.sp(+64)
	<transform+?>: load.sp(+136)
	<transform+?>: load.sp(+4)
	<transform+?>: copy.mem 64
	<transform+?>: inc.sp(-64)
	<transform+?>: inc.sp(-72)
	cmplGfx/lib/image.transform.ci:55: (361 bytes): for (y: int32 := dRec.y0; y < dRec.y1; y := y + 1)
	<transform+?>: dup.x32 sp(21)
	<transform+?>: jmp +346
	cmplGfx/lib/image.transform.ci:56: (338 bytes): for (x: int32 := dRec.x0; x < dRec.x1; x := x + 1)
	<transform+?>: dup.x32 sp(21)
	<transform+?>: jmp +323
	cmplGfx/lib/image.transform.ci:57: (67 bytes): t: vec4f := dph(transform, vec4f(x, y, 0, 1))
	<transform+?>: load.f32 1.000000
	<transform+?>: load.z32
	<transform+?>: dup.x32 sp(3)
	<transform+?>: i32.2f32
	<transform+?>: dup.x32 sp(3)
	<transform+?>: i32.2f32
	<transform+?>: load.sp(+24)
	<transform+?>: load.sp(+4)
	<transform+?>: dup.x32 sp(1)
	<transform+?>: inc.i32(+48)
	<transform+?>: load.i128
	<transform+?>: dup.x32 sp(4)
	<transform+?>: load.i128
	<transform+?>: dph.v4f
	<transform+?>: dup.x32 sp(2)
	<transform+?>: inc.i32(+32)
	<transform+?>: load.i128
	<transform+?>: dup.x32 sp(5)
	<transform+?>: load.i128
	<transform+?>: dph.v4f
	<transform+?>: dup.x32 sp(3)
	<transform+?>: inc.i32(+16)
	<transform+?>: load.i128
	<transform+?>: dup.x32 sp(6)
	<transform+?>: load.i128
	<transform+?>: dph.v4f
	<transform+?>: dup.x32 sp(4)
	<transform+?>: load.i128
	<transform+?>: dup.x32 sp(7)
	<transform+?>: load.i128
	<transform+?>: dph.v4f
	<transform+?>: mov.x128 sp(6, 0)
	<transform+?>: inc.sp(-24)
	cmplGfx/lib/image.transform.ci:58: (244 bytes): set(image, x, y, argb(Image.tex(src, t.x, t.y)));
	<transform+?>: dup.x64 sp(37)
	<transform+?>: dup.x32 sp(6)
	<transform+?>: dup.x32 sp(8)
	<transform+?>: dup.x64 sp(38)
	<transform+?>: dup.x32 sp(6)
	<transform+?>: dup.x32 sp(8)
	<transform+?>: nfc(106) ;Image.tex(image: Image, x: float32, y: float32): vec4f
	<transform+?>: load.sp(+0)
	<transform+?>: dup.x32 sp(0)
	<transform+?>: inc.i32(+12)
	<transform+?>: load.i32
	<transform+?>: load.f32 255.000000
	<transform+?>: mul.f32
	<transform+?>: f32.2i32
	<transform+?>: dup.x32 sp(0)
	<transform+?>: load.c32 255
	<transform+?>: cgt.i32
	<transform+?>: jz +13
	<transform+?>: load.c32 255
	<transform+?>: jmp +19
	<transform+?>: dup.x32 sp(0)
	<transform+?>: load.z32
	<transform+?>: clt.i32
	<transform+?>: jz +9
	<transform+?>: load.z32
	<transform+?>: jmp +6
	<transform+?>: dup.x32 sp(0)
	<transform+?>: set.x32 sp(1)
	<transform+?>: b32.shl 0x08
	<transform+?>: dup.x32 sp(1)
	<transform+?>: load.i32
	<transform+?>: load.f32 255.000000
	<transform+?>: mul.f32
	<transform+?>: f32.2i32
	<transform+?>: dup.x32 sp(0)
	<transform+?>: load.c32 255
	<transform+?>: cgt.i32
	<transform+?>: jz +13
	<transform+?>: load.c32 255
	<transform+?>: jmp +19
	<transform+?>: dup.x32 sp(0)
	<transform+?>: load.z32
	<transform+?>: clt.i32
	<transform+?>: jz +9
	<transform+?>: load.z32
	<transform+?>: jmp +6
	<transform+?>: dup.x32 sp(0)
	<transform+?>: set.x32 sp(1)
	<transform+?>: or.b32
	<transform+?>: b32.shl 0x08
	<transform+?>: dup.x32 sp(1)
	<transform+?>: inc.i32(+4)
	<transform+?>: load.i32
	<transform+?>: load.f32 255.000000
	<transform+?>: mul.f32
	<transform+?>: f32.2i32
	<transform+?>: dup.x32 sp(0)
	<transform+?>: load.c32 255
	<transform+?>: cgt.i32
	<transform+?>: jz +13
	<transform+?>: load.c32 255
	<transform+?>: jmp +19
	<transform+?>: dup.x32 sp(0)
	<transform+?>: load.z32
	<transform+?>: clt.i32
	<transform+?>: jz +9
	<transform+?>: load.z32
	<transform+?>: jmp +6
	<transform+?>: dup.x32 sp(0)
	<transform+?>: set.x32 sp(1)
	<transform+?>: or.b32
	<transform+?>: b32.shl 0x08
	<transform+?>: dup.x32 sp(1)
	<transform+?>: inc.i32(+8)
	<transform+?>: load.i32
	<transform+?>: load.f32 255.000000
	<transform+?>: mul.f32
	<transform+?>: f32.2i32
	<transform+?>: dup.x32 sp(0)
	<transform+?>: load.c32 255
	<transform+?>: cgt.i32
	<transform+?>: jz +13
	<transform+?>: load.c32 255
	<transform+?>: jmp +19
	<transform+?>: dup.x32 sp(0)
	<transform+?>: load.z32
	<transform+?>: clt.i32
	<transform+?>: jz +9
	<transform+?>: load.z32
	<transform+?>: jmp +6
	<transform+?>: dup.x32 sp(0)
	<transform+?>: set.x32 sp(1)
	<transform+?>: or.b32
	<transform+?>: mov.x32 sp(5, 0)
	<transform+?>: inc.sp(-20)
	<transform+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<transform+?>: inc.sp(-16)
	cmplGfx/lib/image.transform.ci:56: (4 bytes): x := x + 1
	<transform+?>: inc.i32(+1)
	cmplGfx/lib/image.transform.ci:56: (9 bytes): x < dRec.x1
	<transform+?>: dup.x32 sp(0)
	<transform+?>: dup.x32 sp(25)
	<transform+?>: clt.i32
	<transform+?>: jnz -324
	<transform+?>: inc.sp(-4)
	cmplGfx/lib/image.transform.ci:55: (4 bytes): y := y + 1
	<transform+?>: inc.i32(+1)
	cmplGfx/lib/image.transform.ci:55: (9 bytes): y < dRec.y1
	<transform+?>: dup.x32 sp(0)
	<transform+?>: dup.x32 sp(25)
	<transform+?>: clt.i32
	<transform+?>: jnz -347
	<transform+?>: inc.sp(-4)
	<transform+?>: inc.sp(-96)
	<transform+?>: ret
.usages:
	cmplGfx/lib/window.ci:45: referenced as `transform`
	cmplGfx/lib/image.transform.ci:131: referenced as `transform`
	cmplGfx/lib/image.transform.ci:64: referenced as `transform`
	cmplGfx/lib/image.transform.ci:30: referenced as `transform`
}
resize(destination: Image, rect: Rect, source: Image, region: Rect, interpolation: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'resize'
.file: 'cmplGfx/lib/image.transform.ci:64'
.param .result: void (size: 0, cast: void)
.param destination: Image (size: 8, cast: val)
.param rect: Rect (size: 4, cast: const ref)
.param source: Image (size: 8, cast: const val)
.param region: Rect (size: 4, cast: const ref)
.param interpolation: int32 (size: 4, cast: i32)
.doc: 'Resize the given `region` of the `source` image into the `destination` image using the `interpolation`.'
.value: transform(destination, rect, source, region, interpolation, null)
.usages:
	cmplGfx/lib/window.ci:125: referenced as `resize`
}
Image(image: Image, width: int32, height: int32, align: int32, maxScale: float64): Image: function {
.kind: static function
.base: `function`
.size: 567
.name: 'Image'
.file: 'cmplGfx/lib/image.transform.ci:67'
.param .result: Image (size: 8, cast: variable(val))
.param image: Image (size: 8, cast: variable(val))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param align: int32 (size: 4, cast: variable(i32))
.param maxScale: float64 (size: 8, cast: variable(f64))
.doc: 'Create an image by copying another one using a custom width and height'
.value: {
	alignVertical: int32 := align & fitVertical;
	alignHorizontal: int32 := align & fitHorizontal;
	fitWidth: bool := alignVertical == fitVertical;
	fitHeight: bool := alignHorizontal == fitHorizontal;
	scale: float64 := 1;
	if (fitWidth && fitHeight) {
		widthScale: float64 := (width) / float64(Image.width(image));
		heightScale: float64 := (height) / float64(Image.height(image));
		if (align & fill) {
			scale := Math.max(widthScale, heightScale);
		}
		else {
			scale := Math.min(widthScale, heightScale);
		}
	}
	else if (fitWidth) {
		scale := (width) / float64(Image.width(image));
	}
	else if (fitHeight) {
		scale := (height) / float64(Image.height(image));
	}
	if (scale > maxScale) {
		scale := maxScale;
	}
	tx: float64 := 0;
	if (fitWidth || alignVertical == center) {
		tx := ((width) - (Image.width(image)) * scale) / (2);
	}
	else if (alignVertical == right) {
		tx := ((width) - (Image.width(image)) * scale);
	}
	ty: float64 := 0;
	if (fitHeight || alignHorizontal == center) {
		ty := ((height) - (Image.height(image)) * scale) / (2);
	}
	else if (alignHorizontal == bottom) {
		ty := ((height) - (Image.height(image)) * scale);
	}
	mat: mat4f := {
		mat.x.x := ((1) / scale);
		mat.x.y := (0);
		mat.x.z := (0);
		mat.x.w := (-tx / scale);
		mat.y.x := (0);
		mat.y.y := ((1) / scale);
		mat.y.z := (0);
		mat.y.w := (-ty / scale);
		mat.z.x := (0);
		mat.z.y := (0);
		mat.z.z := ((1) / scale);
		mat.z.w := (0);
		mat.w.x := (0);
		mat.w.y := (0);
		mat.w.z := (0);
		mat.w.w := (1);
	};
	result: Image := Image(width, height, Image.depth(image));
	transform(result, null, image, null, (align & highRes) ? 1 : 0, mat);
	return .result := result;
}
.instructions: (567 bytes)
	cmplGfx/lib/image.transform.ci:81: (4 bytes): alignVertical: int32 := align & fitVertical
	<Image>  : dup.x32 sp(3)
	<Image+?>: b32.and 0x03
	cmplGfx/lib/image.transform.ci:82: (8 bytes): alignHorizontal: int32 := align & fitHorizontal
	<Image+?>: dup.x32 sp(4)
	<Image+?>: load.c32 12
	<Image+?>: and.b32
	cmplGfx/lib/image.transform.ci:83: (8 bytes): fitWidth: bool := alignVertical == fitVertical
	<Image+?>: dup.x32 sp(1)
	<Image+?>: load.c32 3
	<Image+?>: ceq.i32
	cmplGfx/lib/image.transform.ci:84: (8 bytes): fitHeight: bool := alignHorizontal == fitHorizontal
	<Image+?>: dup.x32 sp(1)
	<Image+?>: load.c32 12
	<Image+?>: ceq.i32
	cmplGfx/lib/image.transform.ci:86: (9 bytes): scale: float64 := 1
	<Image+?>: load.f64 1.000000
	cmplGfx/lib/image.transform.ci:87: (178 bytes): if (fitWidth && fitHeight)
	<Image+?>: load.sp(+12)
	<Image+?>: load.is8
	<Image+?>: dup.x32 sp(0)
	<Image+?>: jz +13
	<Image+?>: inc.sp(-4)
	<Image+?>: load.sp(+8)
	<Image+?>: load.is8
	<Image+?>: jz +110
	cmplGfx/lib/image.transform.ci:88: (11 bytes): widthScale: float64 := (width) / float64(Image.width(image))
	<Image+?>: dup.x32 sp(11)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(14)
	<Image+?>: nfc(101) ;Image.width(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: div.f64
	cmplGfx/lib/image.transform.ci:89: (11 bytes): heightScale: float64 := (height) / float64(Image.height(image))
	<Image+?>: dup.x32 sp(12)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(16)
	<Image+?>: nfc(102) ;Image.height(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: div.f64
	cmplGfx/lib/image.transform.ci:90: (76 bytes): if (align & fill)
	<Image+?>: dup.x32 sp(13)
	<Image+?>: load.c32 16
	<Image+?>: and.b32
	<Image+?>: jz +38
	cmplGfx/lib/image.transform.ci:91: (30 bytes): scale := Math.max(widthScale, heightScale);
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: cgt.f64
	<Image+?>: jz +10
	<Image+?>: dup.x64 sp(2)
	<Image+?>: jmp +6
	<Image+?>: dup.x64 sp(0)
	<Image+?>: mov.x64 sp(4, 0)
	<Image+?>: inc.sp(-16)
	<Image+?>: set.x64 sp(6)
	<Image+?>: jmp +34
	cmplGfx/lib/image.transform.ci:93: (30 bytes): scale := Math.min(widthScale, heightScale);
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: clt.f64
	<Image+?>: jz +10
	<Image+?>: dup.x64 sp(2)
	<Image+?>: jmp +6
	<Image+?>: dup.x64 sp(0)
	<Image+?>: mov.x64 sp(4, 0)
	<Image+?>: inc.sp(-16)
	<Image+?>: set.x64 sp(6)
	<Image+?>: inc.sp(-16)
	<Image+?>: jmp +52
	cmplGfx/lib/image.transform.ci:96: (48 bytes): if (fitWidth)
	<Image+?>: load.sp(+12)
	<Image+?>: load.is8
	<Image+?>: jz +21
	cmplGfx/lib/image.transform.ci:97: (13 bytes): scale := (width) / float64(Image.width(image));
	<Image+?>: dup.x32 sp(11)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(14)
	<Image+?>: nfc(101) ;Image.width(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: div.f64
	<Image+?>: set.x64 sp(2)
	<Image+?>: jmp +26
	cmplGfx/lib/image.transform.ci:99: (22 bytes): if (fitHeight)
	<Image+?>: load.sp(+8)
	<Image+?>: load.is8
	<Image+?>: jz +17
	cmplGfx/lib/image.transform.ci:100: (13 bytes): scale := (height) / float64(Image.height(image));
	<Image+?>: dup.x32 sp(10)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(14)
	<Image+?>: nfc(102) ;Image.height(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: div.f64
	<Image+?>: set.x64 sp(2)
	cmplGfx/lib/image.transform.ci:102: (12 bytes): if (scale > maxScale)
	<Image+?>: dup.x64 sp(0)
	<Image+?>: dup.x64 sp(9)
	<Image+?>: cgt.f64
	<Image+?>: jz +7
	cmplGfx/lib/image.transform.ci:103: (3 bytes): scale := maxScale;
	<Image+?>: mov.x64 sp(0, 7)
	cmplGfx/lib/image.transform.ci:107: (1 byte): tx: float64 := 0
	<Image+?>: load.z64
	cmplGfx/lib/image.transform.ci:108: (81 bytes): if (fitWidth || alignVertical == center)
	<Image+?>: load.sp(+20)
	<Image+?>: load.is8
	<Image+?>: dup.x32 sp(0)
	<Image+?>: jnz +12
	<Image+?>: inc.sp(-4)
	<Image+?>: dup.x32 sp(7)
	<Image+?>: load.z32
	<Image+?>: ceq.i32
	<Image+?>: jz +34
	cmplGfx/lib/image.transform.ci:109: (26 bytes): tx := ((width) - (Image.width(image)) * scale) / (2);
	<Image+?>: dup.x32 sp(13)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(16)
	<Image+?>: nfc(101) ;Image.width(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(6)
	<Image+?>: mul.f64
	<Image+?>: sub.f64
	<Image+?>: load.f64 2.000000
	<Image+?>: div.f64
	<Image+?>: set.x64 sp(2)
	<Image+?>: jmp +32
	cmplGfx/lib/image.transform.ci:111: (28 bytes): if (alignVertical == right)
	<Image+?>: dup.x32 sp(7)
	<Image+?>: load.c32 2
	<Image+?>: ceq.i32
	<Image+?>: jz +20
	cmplGfx/lib/image.transform.ci:112: (16 bytes): tx := ((width) - (Image.width(image)) * scale);
	<Image+?>: dup.x32 sp(13)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(16)
	<Image+?>: nfc(101) ;Image.width(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(6)
	<Image+?>: mul.f64
	<Image+?>: sub.f64
	<Image+?>: set.x64 sp(2)
	cmplGfx/lib/image.transform.ci:115: (1 byte): ty: float64 := 0
	<Image+?>: load.z64
	cmplGfx/lib/image.transform.ci:116: (81 bytes): if (fitHeight || alignHorizontal == center)
	<Image+?>: load.sp(+24)
	<Image+?>: load.is8
	<Image+?>: dup.x32 sp(0)
	<Image+?>: jnz +12
	<Image+?>: inc.sp(-4)
	<Image+?>: dup.x32 sp(8)
	<Image+?>: load.z32
	<Image+?>: ceq.i32
	<Image+?>: jz +34
	cmplGfx/lib/image.transform.ci:117: (26 bytes): ty := ((height) - (Image.height(image)) * scale) / (2);
	<Image+?>: dup.x32 sp(14)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(18)
	<Image+?>: nfc(102) ;Image.height(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(8)
	<Image+?>: mul.f64
	<Image+?>: sub.f64
	<Image+?>: load.f64 2.000000
	<Image+?>: div.f64
	<Image+?>: set.x64 sp(2)
	<Image+?>: jmp +32
	cmplGfx/lib/image.transform.ci:119: (28 bytes): if (alignHorizontal == bottom)
	<Image+?>: dup.x32 sp(8)
	<Image+?>: load.c32 8
	<Image+?>: ceq.i32
	<Image+?>: jz +20
	cmplGfx/lib/image.transform.ci:120: (16 bytes): ty := ((height) - (Image.height(image)) * scale);
	<Image+?>: dup.x32 sp(14)
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(18)
	<Image+?>: nfc(102) ;Image.height(image: Image): int32
	<Image+?>: i32.2f64
	<Image+?>: dup.x64 sp(8)
	<Image+?>: mul.f64
	<Image+?>: sub.f64
	<Image+?>: set.x64 sp(2)
	cmplGfx/lib/image.transform.ci:123: (104 bytes): mat: mat4f := {...}
	<Image+?>: inc.sp(+64)
	cmplGfx/lib/image.transform.ci:124: (15 bytes): mat.x.x := ((1) / scale);
	<Image+?>: load.f64 1.000000
	<Image+?>: dup.x64 sp(22)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(1)
	cmplGfx/lib/image.transform.ci:124: (3 bytes): mat.x.y := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(2)
	cmplGfx/lib/image.transform.ci:124: (3 bytes): mat.x.z := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(3)
	cmplGfx/lib/image.transform.ci:124: (9 bytes): mat.x.w := (-tx / scale);
	<Image+?>: dup.x64 sp(18)
	<Image+?>: neg.f64
	<Image+?>: dup.x64 sp(22)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(4)
	cmplGfx/lib/image.transform.ci:125: (3 bytes): mat.y.x := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(5)
	cmplGfx/lib/image.transform.ci:125: (15 bytes): mat.y.y := ((1) / scale);
	<Image+?>: load.f64 1.000000
	<Image+?>: dup.x64 sp(22)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(6)
	cmplGfx/lib/image.transform.ci:125: (3 bytes): mat.y.z := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(7)
	cmplGfx/lib/image.transform.ci:125: (9 bytes): mat.y.w := (-ty / scale);
	<Image+?>: dup.x64 sp(16)
	<Image+?>: neg.f64
	<Image+?>: dup.x64 sp(22)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(8)
	cmplGfx/lib/image.transform.ci:126: (3 bytes): mat.z.x := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(9)
	cmplGfx/lib/image.transform.ci:126: (3 bytes): mat.z.y := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(10)
	cmplGfx/lib/image.transform.ci:126: (15 bytes): mat.z.z := ((1) / scale);
	<Image+?>: load.f64 1.000000
	<Image+?>: dup.x64 sp(22)
	<Image+?>: div.f64
	<Image+?>: f64.2f32
	<Image+?>: set.x32 sp(11)
	cmplGfx/lib/image.transform.ci:126: (3 bytes): mat.z.w := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(12)
	cmplGfx/lib/image.transform.ci:127: (3 bytes): mat.w.x := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(13)
	cmplGfx/lib/image.transform.ci:127: (3 bytes): mat.w.y := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(14)
	cmplGfx/lib/image.transform.ci:127: (3 bytes): mat.w.z := (0);
	<Image+?>: load.z32
	<Image+?>: set.x32 sp(15)
	cmplGfx/lib/image.transform.ci:127: (7 bytes): mat.w.w := (1);
	<Image+?>: load.f32 1.000000
	<Image+?>: set.x32 sp(16)
	cmplGfx/lib/image.transform.ci:130: (14 bytes): result: Image := Image(width, height, Image.depth(image))
	<Image+?>: dup.x32 sp(31)
	<Image+?>: dup.x32 sp(31)
	<Image+?>: dup.x64 sp(34)
	<Image+?>: nfc(103) ;Image.depth(image: Image): int32
	<Image+?>: nfc(89) ;Image.create(width: int32, height: int32, depth: int32): Image
	cmplGfx/lib/image.transform.ci:131: (50 bytes): transform(result, null, image, null, (align & highRes) ? 1 : 0, mat);
	<Image+?>: dup.x64 sp(0)
	<Image+?>: load.ref <?> ;null
	<Image+?>: dup.x64 sp(37)
	<Image+?>: load.ref <?> ;null
	<Image+?>: dup.x32 sp(37)
	<Image+?>: load.c32 32
	<Image+?>: and.b32
	<Image+?>: jz +13
	<Image+?>: load.c32 1
	<Image+?>: jmp +5
	<Image+?>: load.z32
	<Image+?>: load.sp(+36)
	<Image+?>: load.ref <?> ;transform(image: Image, rect: Rect, src: Image, roi: Rect, interpolate: int32, mat: mat4f): void
	<Image+?>: call
	<Image+?>: inc.sp(-32)
	cmplGfx/lib/image.transform.ci:132: (8 bytes): return .result := result;
	<Image+?>: mov.x64 sp(36, 0)
	<Image+?>: inc.sp(-112)
	<Image+?>: ret
.usages:
	cmplGfx/lib/image.transform.ci:138: referenced as `Image`
}
Image(fileName: char[*], width: int32, height: int32, depth: int32, align: int32, maxScale: float64): Image: function {
.kind: static function
.base: `function`
.size: 56
.name: 'Image'
.file: 'cmplGfx/lib/image.transform.ci:136'
.param .result: Image (size: 8, cast: variable(val))
.param fileName: char[*] (size: 4, cast: const variable(ref))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param depth: int32 (size: 4, cast: variable(i32))
.param align: int32 (size: 4, cast: variable(i32))
.param maxScale: float64 (size: 8, cast: variable(f64))
.doc: 'Create an image by opening an image file with custom width and height'
.value: {
	image: Image := Image(fileName, depth);
	result: Image := Image(image, width, height, align, maxScale);
	Image.destroy(image);
	return .result := result;
}
.instructions: (56 bytes)
	cmplGfx/lib/image.transform.ci:137: (18 bytes): image: Image := Image(fileName, depth)
	<Image>  : inc.sp(+8)
	<Image+?>: dup.x32 sp(9)
	<Image+?>: dup.x32 sp(7)
	<Image+?>: load.ref <?> ;Image(fileName: char[*], depth: int32): Image
	<Image+?>: call
	<Image+?>: inc.sp(-8)
	cmplGfx/lib/image.transform.ci:138: (24 bytes): result: Image := Image(image, width, height, align, maxScale)
	<Image+?>: inc.sp(+8)
	<Image+?>: dup.x64 sp(2)
	<Image+?>: dup.x32 sp(12)
	<Image+?>: dup.x32 sp(12)
	<Image+?>: dup.x32 sp(11)
	<Image+?>: dup.x64 sp(10)
	<Image+?>: load.ref <?> ;Image(image: Image, width: int32, height: int32, align: int32, maxScale: float64): Image
	<Image+?>: call
	<Image+?>: inc.sp(-28)
	cmplGfx/lib/image.transform.ci:139: (6 bytes): Image.destroy(image);
	<Image+?>: dup.x64 sp(2)
	<Image+?>: nfc(93) ;Image.destroy(image: Image): void
	cmplGfx/lib/image.transform.ci:140: (8 bytes): return .result := result;
	<Image+?>: mov.x64 sp(12, 0)
	<Image+?>: inc.sp(-16)
	<Image+?>: ret
.usages:
	cmplGfx/lib/image.transform.ci:147: referenced as `Image`
	cmplGfx/lib/image.transform.ci:144: referenced as `Image`
}
Image(fileName: char[*], width: int32, height: int32, depth: int32, align: int32): Image: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Image'
.file: 'cmplGfx/lib/image.transform.ci:144'
.param .result: Image (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: const ref)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.param align: int32 (size: 4, cast: i32)
.doc: 'Create an image by opening an image file with custom width and height'
.value: Image(fileName, width, height, depth, align, Math.inf)
.usages:
}
Image(fileName: char[*], width: int32, height: int32, depth: int32): Image: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Image'
.file: 'cmplGfx/lib/image.transform.ci:147'
.param .result: Image (size: 8, cast: val)
.param fileName: char[*] (size: 4, cast: const ref)
.param width: int32 (size: 4, cast: i32)
.param height: int32 (size: 4, cast: i32)
.param depth: int32 (size: 4, cast: i32)
.doc: 'Create an image by opening an image file with custom width and height'
.value: Image(fileName, width, height, depth, -1, Math.inf)
.usages:
}
blur(image: Image, radius: int32, sigma: float64): void: function {
.kind: static function
.base: `function`
.size: 934
.name: 'blur'
.file: 'cmplGfx/lib/image.blur.ci:2'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param radius: int32 (size: 4, cast: variable(i32))
.param sigma: float64 (size: 8, cast: variable(f64))
.doc: 'emulated implementation of blur function'
.value: {
	static if ((preferNativeCalls) && (typename(Image.blur)) != null) {
		return .result := Image.blur(image, radius, sigma);
	}
	static gauss(x: float64, sigma: float64): float64 := {
		SQRT_2_PI_INV: typename := 0.398942;
		t: float64 := x / sigma;
		return .result := SQRT_2_PI_INV * Math.exp(-0.500000 * t * t) / sigma;
	};
	kernel: int32[1024] := {
	};
	size: int32 := radius * 2 + 1;
	assert(size < kernel.(length));
	kernelSum: float64 := 0;
	kernelFlt: float64[1024] := {
	};
	for (i: int32 := 0; i < size; i := i + 1) {
		kernelFlt[i] := gauss(radius - i, sigma);
		kernelSum := kernelSum + kernelFlt[i];
	}
	for (i: int32 := 0; i < size; i := i + 1) {
		kernel[i] := ((65536) * (kernelFlt[i] / kernelSum));
	}
	width: int32 := Image.width(image);
	height: int32 := Image.height(image);
	tmp: Image := Image.create(width, height, Image.depth(image));
	for (y: int32 := 0; y < height; y := y + 1) {
		for (x: int32 := 0; x < width; x := x + 1) {
			r: int32 := 0;
			g: int32 := 0;
			b: int32 := 0;
			for (i: int32 := 0; i < size; i := i + 1) {
				_x: int32 := x + i - radius;
				if (_x >= 0 && _x < width) {
					col: argb := argb(Image.get(image, _x, y));
					_k: int32 := kernel[i];
					r := r + _k * rch(col);
					g := g + _k * gch(col);
					b := b + _k * bch(col);
				}
			}
			set(tmp, x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}
	for (y: int32 := 0; y < height; y := y + 1) {
		for (x: int32 := 0; x < width; x := x + 1) {
			r: int32 := 0;
			g: int32 := 0;
			b: int32 := 0;
			for (i: int32 := 0; i < size; i := i + 1) {
				_y: int32 := y + i - radius;
				if (_y >= 0 && _y < height) {
					col: argb := argb(Image.get(tmp, x, _y));
					_k: int32 := kernel[i];
					r := r + _k * rch(col);
					g := g + _k * gch(col);
					b := b + _k * bch(col);
				}
			}
			set(image, x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}
	Image.destroy(tmp);
}
.instructions: (934 bytes)
	cmplGfx/lib/image.blur.ci:4: (11 bytes): return .result := Image.blur(image, radius, sigma);
	<blur>  : dup.x64 sp(4)
	<blur+?>: dup.x32 sp(5)
	<blur+?>: dup.x64 sp(4)
	<blur+?>: nfc(112) ;Image.blur(image: Image, radius: int32, sigma: float64): void
	<blur+?>: ret
	cmplGfx/lib/image.blur.ci:24: (4 bytes): kernel: int32[1024] := {...}
	<blur+?>: inc.sp(+4096)
	cmplGfx/lib/image.blur.ci:25: (15 bytes): size: int32 := radius * 2 + 1
	<blur+?>: load.sp(+4108)
	<blur+?>: load.i32
	<blur+?>: load.c32 2
	<blur+?>: mul.i32
	<blur+?>: inc.i32(+1)
	cmplGfx/lib/image.blur.ci:26: (56 bytes): assert(size < kernel.(length));
	<blur+?>: load.z32
	<blur+?>: load.sp(+4)
	<blur+?>: dup.x32 sp(2)
	<blur+?>: load.c32 1024
	<blur+?>: clt.i32
	<blur+?>: jz +8
	<blur+?>: jmp +35
	<blur+?>: load.ref <?> ;"cmplGfx/lib/image.blur.ci"
	<blur+?>: load.c32 26
	<blur+?>: load.c32 -2
	<blur+?>: load.c32 128
	<blur+?>: load.ref <?> ;"assertion failed!"
	<blur+?>: dup.x64 sp(5)
	<blur+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<blur+?>: inc.sp(-8)
	cmplGfx/lib/image.blur.ci:28: (1 byte): kernelSum: float64 := 0
	<blur+?>: load.z64
	cmplGfx/lib/image.blur.ci:29: (4 bytes): kernelFlt: float64[1024] := {...}
	<blur+?>: inc.sp(+8192)
	cmplGfx/lib/image.blur.ci:30: (83 bytes): for (i: int32 := 0; i < size; i := i + 1)
	<blur+?>: load.z32
	<blur+?>: jmp +66
	cmplGfx/lib/image.blur.ci:31: (36 bytes): kernelFlt[i] := gauss(radius - i, sigma);
	<blur+?>: load.z64
	<blur+?>: load.sp(+12324)
	<blur+?>: load.i32
	<blur+?>: dup.x32 sp(3)
	<blur+?>: sub.i32
	<blur+?>: i32.2f64
	<blur+?>: load.sp(+12324)
	<blur+?>: load.i64
	<blur+?>: load.ref <?> ;blur.gauss(x: float64, sigma: float64): float64
	<blur+?>: call
	<blur+?>: inc.sp(-16)
	<blur+?>: load.sp(+12)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: mad.u32 8
	<blur+?>: store.i64
	cmplGfx/lib/image.blur.ci:32: (22 bytes): kernelSum := kernelSum + kernelFlt[i];
	<blur+?>: load.sp(+8196)
	<blur+?>: load.i64
	<blur+?>: load.sp(+12)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: mad.u32 8
	<blur+?>: load.i64
	<blur+?>: add.f64
	<blur+?>: load.sp(+8204)
	<blur+?>: store.i64
	cmplGfx/lib/image.blur.ci:30: (4 bytes): i := i + 1
	<blur+?>: inc.i32(+1)
	cmplGfx/lib/image.blur.ci:30: (12 bytes): i < size
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.sp(+8208)
	<blur+?>: load.i32
	<blur+?>: clt.i32
	<blur+?>: jnz -70
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:35: (64 bytes): for (i: int32 := 0; i < size; i := i + 1)
	<blur+?>: load.z32
	<blur+?>: jmp +47
	cmplGfx/lib/image.blur.ci:36: (39 bytes): kernel[i] := ((65536) * (kernelFlt[i] / kernelSum));
	<blur+?>: load.f64 65536.000000
	<blur+?>: load.sp(+12)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: mad.u32 8
	<blur+?>: load.i64
	<blur+?>: load.sp(+8212)
	<blur+?>: load.i64
	<blur+?>: div.f64
	<blur+?>: mul.f64
	<blur+?>: f64.2i32
	<blur+?>: load.sp(+8212)
	<blur+?>: dup.x32 sp(2)
	<blur+?>: mad.u32 4
	<blur+?>: store.i32
	cmplGfx/lib/image.blur.ci:35: (4 bytes): i := i + 1
	<blur+?>: inc.i32(+1)
	cmplGfx/lib/image.blur.ci:35: (12 bytes): i < size
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.sp(+8208)
	<blur+?>: load.i32
	<blur+?>: clt.i32
	<blur+?>: jnz -51
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:39: (9 bytes): width: int32 := Image.width(image)
	<blur+?>: load.sp(+12316)
	<blur+?>: load.i64
	<blur+?>: nfc(101) ;Image.width(image: Image): int32
	cmplGfx/lib/image.blur.ci:40: (9 bytes): height: int32 := Image.height(image)
	<blur+?>: load.sp(+12320)
	<blur+?>: load.i64
	<blur+?>: nfc(102) ;Image.height(image: Image): int32
	cmplGfx/lib/image.blur.ci:41: (17 bytes): tmp: Image := Image.create(width, height, Image.depth(image))
	<blur+?>: dup.x32 sp(1)
	<blur+?>: dup.x32 sp(1)
	<blur+?>: load.sp(+12332)
	<blur+?>: load.i64
	<blur+?>: nfc(103) ;Image.depth(image: Image): int32
	<blur+?>: nfc(89) ;Image.create(width: int32, height: int32, depth: int32): Image
	cmplGfx/lib/image.blur.ci:44: (325 bytes): for (y: int32 := 0; y < height; y := y + 1)
	<blur+?>: load.z32
	<blur+?>: jmp +311
	cmplGfx/lib/image.blur.ci:45: (303 bytes): for (x: int32 := 0; x < width; x := x + 1)
	<blur+?>: load.z32
	<blur+?>: jmp +289
	cmplGfx/lib/image.blur.ci:46: (1 byte): r: int32 := 0
	<blur+?>: load.z32
	cmplGfx/lib/image.blur.ci:47: (1 byte): g: int32 := 0
	<blur+?>: load.z32
	cmplGfx/lib/image.blur.ci:48: (1 byte): b: int32 := 0
	<blur+?>: load.z32
	cmplGfx/lib/image.blur.ci:49: (132 bytes): for (i: int32 := 0; i < size; i := i + 1)
	<blur+?>: load.z32
	<blur+?>: jmp +115
	cmplGfx/lib/image.blur.ci:50: (11 bytes): _x: int32 := x + i - radius
	<blur+?>: dup.x32 sp(4)
	<blur+?>: dup.x32 sp(1)
	<blur+?>: add.i32
	<blur+?>: load.sp(+12356)
	<blur+?>: load.i32
	<blur+?>: sub.i32
	cmplGfx/lib/image.blur.ci:51: (92 bytes): if (_x >= 0 && _x < width)
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.z32
	<blur+?>: clt.i32
	<blur+?>: not.b32
	<blur+?>: dup.x32 sp(0)
	<blur+?>: jz +13
	<blur+?>: inc.sp(-4)
	<blur+?>: dup.x32 sp(0)
	<blur+?>: dup.x32 sp(11)
	<blur+?>: clt.i32
	<blur+?>: jz +72
	cmplGfx/lib/image.blur.ci:52: (13 bytes): col: argb := argb(Image.get(image, _x, y))
	<blur+?>: load.sp(+12360)
	<blur+?>: load.i64
	<blur+?>: dup.x32 sp(2)
	<blur+?>: dup.x32 sp(9)
	<blur+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	cmplGfx/lib/image.blur.ci:53: (11 bytes): _k: int32 := kernel[i]
	<blur+?>: load.sp(+8252)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: mad.u32 4
	<blur+?>: load.i32
	cmplGfx/lib/image.blur.ci:54: (14 bytes): r := r + _k * rch(col);
	<blur+?>: dup.x32 sp(6)
	<blur+?>: dup.x32 sp(1)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: b32.shr 0x10
	<blur+?>: b32.and 0xff
	<blur+?>: mul.i32
	<blur+?>: add.i32
	<blur+?>: set.x32 sp(7)
	cmplGfx/lib/image.blur.ci:55: (14 bytes): g := g + _k * gch(col);
	<blur+?>: dup.x32 sp(5)
	<blur+?>: dup.x32 sp(1)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: b32.shr 0x08
	<blur+?>: b32.and 0xff
	<blur+?>: mul.i32
	<blur+?>: add.i32
	<blur+?>: set.x32 sp(6)
	cmplGfx/lib/image.blur.ci:56: (12 bytes): b := b + _k * bch(col);
	<blur+?>: dup.x32 sp(4)
	<blur+?>: dup.x32 sp(1)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: b32.and 0xff
	<blur+?>: mul.i32
	<blur+?>: add.i32
	<blur+?>: set.x32 sp(5)
	<blur+?>: inc.sp(-8)
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:49: (4 bytes): i := i + 1
	<blur+?>: inc.i32(+1)
	cmplGfx/lib/image.blur.ci:49: (12 bytes): i < size
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.sp(+8244)
	<blur+?>: load.i32
	<blur+?>: clt.i32
	<blur+?>: jnz -119
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:59: (142 bytes): set(tmp, x, y, argb(r >> 16, g >> 16, b >> 16));
	<blur+?>: dup.x64 sp(5)
	<blur+?>: dup.x32 sp(5)
	<blur+?>: dup.x32 sp(7)
	<blur+?>: dup.x32 sp(6)
	<blur+?>: b32.sar 0x10
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.c32 255
	<blur+?>: cgt.i32
	<blur+?>: jz +13
	<blur+?>: load.c32 255
	<blur+?>: jmp +19
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.z32
	<blur+?>: clt.i32
	<blur+?>: jz +9
	<blur+?>: load.z32
	<blur+?>: jmp +6
	<blur+?>: dup.x32 sp(0)
	<blur+?>: set.x32 sp(1)
	<blur+?>: b32.shl 0x08
	<blur+?>: dup.x32 sp(6)
	<blur+?>: b32.sar 0x10
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.c32 255
	<blur+?>: cgt.i32
	<blur+?>: jz +13
	<blur+?>: load.c32 255
	<blur+?>: jmp +19
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.z32
	<blur+?>: clt.i32
	<blur+?>: jz +9
	<blur+?>: load.z32
	<blur+?>: jmp +6
	<blur+?>: dup.x32 sp(0)
	<blur+?>: set.x32 sp(1)
	<blur+?>: or.b32
	<blur+?>: b32.shl 0x08
	<blur+?>: dup.x32 sp(5)
	<blur+?>: b32.sar 0x10
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.c32 255
	<blur+?>: cgt.i32
	<blur+?>: jz +13
	<blur+?>: load.c32 255
	<blur+?>: jmp +19
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.z32
	<blur+?>: clt.i32
	<blur+?>: jz +9
	<blur+?>: load.z32
	<blur+?>: jmp +6
	<blur+?>: dup.x32 sp(0)
	<blur+?>: set.x32 sp(1)
	<blur+?>: or.b32
	<blur+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<blur+?>: inc.sp(-12)
	cmplGfx/lib/image.blur.ci:45: (4 bytes): x := x + 1
	<blur+?>: inc.i32(+1)
	cmplGfx/lib/image.blur.ci:45: (9 bytes): x < width
	<blur+?>: dup.x32 sp(0)
	<blur+?>: dup.x32 sp(6)
	<blur+?>: clt.i32
	<blur+?>: jnz -290
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:44: (4 bytes): y := y + 1
	<blur+?>: inc.i32(+1)
	cmplGfx/lib/image.blur.ci:44: (9 bytes): y < height
	<blur+?>: dup.x32 sp(0)
	<blur+?>: dup.x32 sp(4)
	<blur+?>: clt.i32
	<blur+?>: jnz -312
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:64: (325 bytes): for (y: int32 := 0; y < height; y := y + 1)
	<blur+?>: load.z32
	<blur+?>: jmp +311
	cmplGfx/lib/image.blur.ci:65: (303 bytes): for (x: int32 := 0; x < width; x := x + 1)
	<blur+?>: load.z32
	<blur+?>: jmp +289
	cmplGfx/lib/image.blur.ci:66: (1 byte): r: int32 := 0
	<blur+?>: load.z32
	cmplGfx/lib/image.blur.ci:67: (1 byte): g: int32 := 0
	<blur+?>: load.z32
	cmplGfx/lib/image.blur.ci:68: (1 byte): b: int32 := 0
	<blur+?>: load.z32
	cmplGfx/lib/image.blur.ci:69: (129 bytes): for (i: int32 := 0; i < size; i := i + 1)
	<blur+?>: load.z32
	<blur+?>: jmp +112
	cmplGfx/lib/image.blur.ci:70: (11 bytes): _y: int32 := y + i - radius
	<blur+?>: dup.x32 sp(5)
	<blur+?>: dup.x32 sp(1)
	<blur+?>: add.i32
	<blur+?>: load.sp(+12356)
	<blur+?>: load.i32
	<blur+?>: sub.i32
	cmplGfx/lib/image.blur.ci:71: (89 bytes): if (_y >= 0 && _y < height)
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.z32
	<blur+?>: clt.i32
	<blur+?>: not.b32
	<blur+?>: dup.x32 sp(0)
	<blur+?>: jz +13
	<blur+?>: inc.sp(-4)
	<blur+?>: dup.x32 sp(0)
	<blur+?>: dup.x32 sp(10)
	<blur+?>: clt.i32
	<blur+?>: jz +69
	cmplGfx/lib/image.blur.ci:72: (10 bytes): col: argb := argb(Image.get(tmp, x, _y))
	<blur+?>: dup.x64 sp(7)
	<blur+?>: dup.x32 sp(7)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	cmplGfx/lib/image.blur.ci:73: (11 bytes): _k: int32 := kernel[i]
	<blur+?>: load.sp(+8252)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: mad.u32 4
	<blur+?>: load.i32
	cmplGfx/lib/image.blur.ci:74: (14 bytes): r := r + _k * rch(col);
	<blur+?>: dup.x32 sp(6)
	<blur+?>: dup.x32 sp(1)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: b32.shr 0x10
	<blur+?>: b32.and 0xff
	<blur+?>: mul.i32
	<blur+?>: add.i32
	<blur+?>: set.x32 sp(7)
	cmplGfx/lib/image.blur.ci:75: (14 bytes): g := g + _k * gch(col);
	<blur+?>: dup.x32 sp(5)
	<blur+?>: dup.x32 sp(1)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: b32.shr 0x08
	<blur+?>: b32.and 0xff
	<blur+?>: mul.i32
	<blur+?>: add.i32
	<blur+?>: set.x32 sp(6)
	cmplGfx/lib/image.blur.ci:76: (12 bytes): b := b + _k * bch(col);
	<blur+?>: dup.x32 sp(4)
	<blur+?>: dup.x32 sp(1)
	<blur+?>: dup.x32 sp(3)
	<blur+?>: b32.and 0xff
	<blur+?>: mul.i32
	<blur+?>: add.i32
	<blur+?>: set.x32 sp(5)
	<blur+?>: inc.sp(-8)
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:69: (4 bytes): i := i + 1
	<blur+?>: inc.i32(+1)
	cmplGfx/lib/image.blur.ci:69: (12 bytes): i < size
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.sp(+8244)
	<blur+?>: load.i32
	<blur+?>: clt.i32
	<blur+?>: jnz -116
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:79: (145 bytes): set(image, x, y, argb(r >> 16, g >> 16, b >> 16));
	<blur+?>: load.sp(+12352)
	<blur+?>: load.i64
	<blur+?>: dup.x32 sp(5)
	<blur+?>: dup.x32 sp(7)
	<blur+?>: dup.x32 sp(6)
	<blur+?>: b32.sar 0x10
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.c32 255
	<blur+?>: cgt.i32
	<blur+?>: jz +13
	<blur+?>: load.c32 255
	<blur+?>: jmp +19
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.z32
	<blur+?>: clt.i32
	<blur+?>: jz +9
	<blur+?>: load.z32
	<blur+?>: jmp +6
	<blur+?>: dup.x32 sp(0)
	<blur+?>: set.x32 sp(1)
	<blur+?>: b32.shl 0x08
	<blur+?>: dup.x32 sp(6)
	<blur+?>: b32.sar 0x10
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.c32 255
	<blur+?>: cgt.i32
	<blur+?>: jz +13
	<blur+?>: load.c32 255
	<blur+?>: jmp +19
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.z32
	<blur+?>: clt.i32
	<blur+?>: jz +9
	<blur+?>: load.z32
	<blur+?>: jmp +6
	<blur+?>: dup.x32 sp(0)
	<blur+?>: set.x32 sp(1)
	<blur+?>: or.b32
	<blur+?>: b32.shl 0x08
	<blur+?>: dup.x32 sp(5)
	<blur+?>: b32.sar 0x10
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.c32 255
	<blur+?>: cgt.i32
	<blur+?>: jz +13
	<blur+?>: load.c32 255
	<blur+?>: jmp +19
	<blur+?>: dup.x32 sp(0)
	<blur+?>: load.z32
	<blur+?>: clt.i32
	<blur+?>: jz +9
	<blur+?>: load.z32
	<blur+?>: jmp +6
	<blur+?>: dup.x32 sp(0)
	<blur+?>: set.x32 sp(1)
	<blur+?>: or.b32
	<blur+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<blur+?>: inc.sp(-12)
	cmplGfx/lib/image.blur.ci:65: (4 bytes): x := x + 1
	<blur+?>: inc.i32(+1)
	cmplGfx/lib/image.blur.ci:65: (9 bytes): x < width
	<blur+?>: dup.x32 sp(0)
	<blur+?>: dup.x32 sp(6)
	<blur+?>: clt.i32
	<blur+?>: jnz -290
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:64: (4 bytes): y := y + 1
	<blur+?>: inc.i32(+1)
	cmplGfx/lib/image.blur.ci:64: (9 bytes): y < height
	<blur+?>: dup.x32 sp(0)
	<blur+?>: dup.x32 sp(4)
	<blur+?>: clt.i32
	<blur+?>: jnz -312
	<blur+?>: inc.sp(-4)
	cmplGfx/lib/image.blur.ci:83: (6 bytes): Image.destroy(tmp);
	<blur+?>: dup.x64 sp(0)
	<blur+?>: nfc(93) ;Image.destroy(image: Image): void
	<blur+?>: inc.sp(-12316)
	<blur+?>: ret
.usages:
}
colorMap(image: Image, roi: Rect, lut: argb[256]): void: function {
.kind: static function
.base: `function`
.size: 951
.name: 'colorMap'
.file: 'cmplGfx/lib/color.lookup.ci:2'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param lut: argb[256] (size: 4, cast: const variable(ref))
.doc: 'apply a color lookup table to each pixel defined by the `roi` on the `image`'
.value: {
	static if ((preferNativeCalls) && (typename(Image.colorMap)) != null) {
		return .result := Image.colorMap(image, roi, pointer(lut));
	}
	assert(Image.depth(image) == 32);
	r: Rect := {
		r.x0 := (roi) != null ? roi.x0 : 0;
		r.y0 := (roi) != null ? roi.y0 : 0;
		r.x1 := (roi) != null ? roi.x1 : Image.width(image);
		r.y1 := (roi) != null ? roi.y1 : Image.height(image);
	};
	if (!clip(image, &r)) {
		return;
	}
	useLuminosity: bool := false;
	for (i: int32 := 0; i < 256; i := i + 1) {
		if (ach(lut[i]) != i) {
			useLuminosity := true;
			break;
		}
	}
	if (!useLuminosity) {
		for (y: int32 := r.y0; y < r.y1; y := y + 1) {
			for (x: int32 := r.x0; x < r.x1; x := x + 1) {
				col: argb := argb(Image.get(image, x, y));
				col.r := lut[rch(col)].r;
				col.g := lut[gch(col)].g;
				col.b := lut[bch(col)].b;
				set(image, x, y, col);
			}
		}
		return;
	}
	fxpBits: typename := 16;
	fxp(v: float64): int32 := int32(v * ((1 << fxpBits)));
	static const rgb2luv: int32[] := {
		rgb2luv := rgb2luv.init;
		rgb2luv.init[0] := fxp(0.299000);
		rgb2luv.init[1] := fxp(0.587000);
		rgb2luv.init[2] := fxp(0.114000);
		rgb2luv.init[3] := 0;
		rgb2luv.init[4] := fxp(-0.147000);
		rgb2luv.init[5] := fxp(-0.289000);
		rgb2luv.init[6] := fxp(0.437000);
		rgb2luv.init[7] := 0;
		rgb2luv.init[8] := fxp(0.615000);
		rgb2luv.init[9] := fxp(-0.515000);
		rgb2luv.init[10] := fxp(-0.100000);
		rgb2luv.init[11] := 0;
	};
	static const luv2rgb: int32[] := {
		luv2rgb := luv2rgb.init;
		luv2rgb.init[0] := fxp(1);
		luv2rgb.init[1] := fxp(0.000000);
		luv2rgb.init[2] := fxp(1.140000);
		luv2rgb.init[3] := 0;
		luv2rgb.init[4] := fxp(1);
		luv2rgb.init[5] := fxp(-0.394000);
		luv2rgb.init[6] := fxp(-0.581000);
		luv2rgb.init[7] := 0;
		luv2rgb.init[8] := fxp(1);
		luv2rgb.init[9] := fxp(2.028000);
		luv2rgb.init[10] := fxp(0.000000);
		luv2rgb.init[11] := 0;
	};
	for (y: int32 := r.y0; y < r.y1; y := y + 1) {
		for (x: int32 := r.x0; x < r.x1; x := x + 1) {
			col: argb := argb(Image.get(image, x, y));
			r: int32 := rch(lut[rch(col)]);
			g: int32 := gch(lut[gch(col)]);
			b: int32 := bch(lut[bch(col)]);
			l: int32 := (r * rgb2luv[0] + g * rgb2luv[1] + b * rgb2luv[2]) >> fxpBits;
			u: int32 := (r * rgb2luv[4] + g * rgb2luv[5] + b * rgb2luv[6]) >> fxpBits;
			v: int32 := (r * rgb2luv[8] + g * rgb2luv[9] + b * rgb2luv[10]) >> fxpBits;
			l := ach(lut[sat_s8(l)]);
			col.r := (sat_s8((l * luv2rgb[0] + u * luv2rgb[1] + v * luv2rgb[2]) >> fxpBits));
			col.g := (sat_s8((l * luv2rgb[4] + u * luv2rgb[5] + v * luv2rgb[6]) >> fxpBits));
			col.b := (sat_s8((l * luv2rgb[8] + u * luv2rgb[9] + v * luv2rgb[10]) >> fxpBits));
			set(image, x, y, col);
		}
	}
}
.instructions: (951 bytes)
	cmplGfx/lib/color.lookup.ci:4: (11 bytes): return .result := Image.colorMap(image, roi, pointer(lut));
	<colorMap>  : dup.x64 sp(3)
	<colorMap+?>: dup.x32 sp(4)
	<colorMap+?>: dup.x32 sp(4)
	<colorMap+?>: nfc(113) ;Image.colorMap(image: Image, roi: Rect, lut: uint32[256]): void
	<colorMap+?>: ret
	cmplGfx/lib/color.lookup.ci:7: (60 bytes): assert(Image.depth(image) == 32);
	<colorMap+?>: load.z32
	<colorMap+?>: load.sp(+4)
	<colorMap+?>: dup.x64 sp(5)
	<colorMap+?>: nfc(103) ;Image.depth(image: Image): int32
	<colorMap+?>: load.c32 32
	<colorMap+?>: ceq.i32
	<colorMap+?>: jz +8
	<colorMap+?>: jmp +35
	<colorMap+?>: load.ref <?> ;"cmplGfx/lib/color.lookup.ci"
	<colorMap+?>: load.c32 7
	<colorMap+?>: load.c32 -2
	<colorMap+?>: load.c32 128
	<colorMap+?>: load.ref <?> ;"assertion failed!"
	<colorMap+?>: dup.x64 sp(5)
	<colorMap+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<colorMap+?>: inc.sp(-8)
	cmplGfx/lib/color.lookup.ci:10: (114 bytes): r: Rect := {...}
	<colorMap+?>: inc.sp(+16)
	cmplGfx/lib/color.lookup.ci:11: (22 bytes): r.x0 := (roi) != null ? roi.x0 : 0;
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: load.ref <?> ;null
	<colorMap+?>: ceq.i32
	<colorMap+?>: jnz +11
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: load.i32
	<colorMap+?>: jmp +5
	<colorMap+?>: load.z32
	<colorMap+?>: set.x32 sp(1)
	cmplGfx/lib/color.lookup.ci:12: (26 bytes): r.y0 := (roi) != null ? roi.y0 : 0;
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: load.ref <?> ;null
	<colorMap+?>: ceq.i32
	<colorMap+?>: jnz +15
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: inc.i32(+4)
	<colorMap+?>: load.i32
	<colorMap+?>: jmp +5
	<colorMap+?>: load.z32
	<colorMap+?>: set.x32 sp(2)
	cmplGfx/lib/color.lookup.ci:13: (31 bytes): r.x1 := (roi) != null ? roi.x1 : Image.width(image);
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: load.ref <?> ;null
	<colorMap+?>: ceq.i32
	<colorMap+?>: jnz +15
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: inc.i32(+8)
	<colorMap+?>: load.i32
	<colorMap+?>: jmp +10
	<colorMap+?>: dup.x64 sp(7)
	<colorMap+?>: nfc(101) ;Image.width(image: Image): int32
	<colorMap+?>: set.x32 sp(3)
	cmplGfx/lib/color.lookup.ci:14: (31 bytes): r.y1 := (roi) != null ? roi.y1 : Image.height(image);
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: load.ref <?> ;null
	<colorMap+?>: ceq.i32
	<colorMap+?>: jnz +15
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: inc.i32(+12)
	<colorMap+?>: load.i32
	<colorMap+?>: jmp +10
	<colorMap+?>: dup.x64 sp(7)
	<colorMap+?>: nfc(102) ;Image.height(image: Image): int32
	<colorMap+?>: set.x32 sp(4)
	cmplGfx/lib/color.lookup.ci:16: (26 bytes): if (!clip(image, &r))
	<colorMap+?>: load.z32
	<colorMap+?>: dup.x64 sp(8)
	<colorMap+?>: load.sp(+12)
	<colorMap+?>: load.ref <?> ;clip(image: Image, roi: Rect): bool
	<colorMap+?>: call
	<colorMap+?>: inc.sp(-12)
	<colorMap+?>: jnz +9
	cmplGfx/lib/color.lookup.ci:18: (5 bytes): return;
	<colorMap+?>: inc.sp(-16)
	<colorMap+?>: ret
	cmplGfx/lib/color.lookup.ci:21: (1 byte): useLuminosity: bool := false
	<colorMap+?>: load.z32
	cmplGfx/lib/color.lookup.ci:22: (57 bytes): for (i: int32 := 0; i < 256; i := i + 1)
	<colorMap+?>: load.z32
	<colorMap+?>: jmp +40
	cmplGfx/lib/color.lookup.ci:23: (32 bytes): if (ach(lut[i]) != i)
	<colorMap+?>: dup.x32 sp(7)
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: mad.u32 4
	<colorMap+?>: load.i32
	<colorMap+?>: b32.shr 0x18
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: ceq.i32
	<colorMap+?>: jnz +18
	cmplGfx/lib/color.lookup.ci:24: (10 bytes): useLuminosity := true;
	<colorMap+?>: load.c32 1
	<colorMap+?>: load.sp(+8)
	<colorMap+?>: store.i8
	cmplGfx/lib/color.lookup.ci:25: (4 bytes): break;
	<colorMap+?>: jmp +20
	cmplGfx/lib/color.lookup.ci:22: (4 bytes): i := i + 1
	<colorMap+?>: inc.i32(+1)
	cmplGfx/lib/color.lookup.ci:22: (12 bytes): i < 256
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: load.c32 256
	<colorMap+?>: clt.i32
	<colorMap+?>: jnz -44
	<colorMap+?>: inc.sp(-4)
	cmplGfx/lib/color.lookup.ci:29: (146 bytes): if (!useLuminosity)
	<colorMap+?>: load.sp(+0)
	<colorMap+?>: load.is8
	<colorMap+?>: jnz +141
	cmplGfx/lib/color.lookup.ci:31: (132 bytes): for (y: int32 := r.y0; y < r.y1; y := y + 1)
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: jmp +117
	cmplGfx/lib/color.lookup.ci:32: (109 bytes): for (x: int32 := r.x0; x < r.x1; x := x + 1)
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: jmp +94
	cmplGfx/lib/color.lookup.ci:33: (10 bytes): col: argb := argb(Image.get(image, x, y))
	<colorMap+?>: dup.x64 sp(10)
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: dup.x32 sp(4)
	<colorMap+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	cmplGfx/lib/color.lookup.ci:34: (22 bytes): col.r := lut[rch(col)].r;
	<colorMap+?>: dup.x32 sp(9)
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: b32.shr 0x10
	<colorMap+?>: b32.and 0xff
	<colorMap+?>: mad.u32 4
	<colorMap+?>: inc.i32(+2)
	<colorMap+?>: load.iu8
	<colorMap+?>: load.sp(+6)
	<colorMap+?>: store.i8
	cmplGfx/lib/color.lookup.ci:35: (22 bytes): col.g := lut[gch(col)].g;
	<colorMap+?>: dup.x32 sp(9)
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: b32.shr 0x08
	<colorMap+?>: b32.and 0xff
	<colorMap+?>: mad.u32 4
	<colorMap+?>: inc.i32(+1)
	<colorMap+?>: load.iu8
	<colorMap+?>: load.sp(+5)
	<colorMap+?>: store.i8
	cmplGfx/lib/color.lookup.ci:36: (16 bytes): col.b := lut[bch(col)].b;
	<colorMap+?>: dup.x32 sp(9)
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: b32.and 0xff
	<colorMap+?>: mad.u32 4
	<colorMap+?>: load.iu8
	<colorMap+?>: load.sp(+4)
	<colorMap+?>: store.i8
	cmplGfx/lib/color.lookup.ci:37: (12 bytes): set(image, x, y, col);
	<colorMap+?>: dup.x64 sp(11)
	<colorMap+?>: dup.x32 sp(3)
	<colorMap+?>: dup.x32 sp(5)
	<colorMap+?>: dup.x32 sp(4)
	<colorMap+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<colorMap+?>: inc.sp(-4)
	cmplGfx/lib/color.lookup.ci:32: (4 bytes): x := x + 1
	<colorMap+?>: inc.i32(+1)
	cmplGfx/lib/color.lookup.ci:32: (9 bytes): x < r.x1
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: clt.i32
	<colorMap+?>: jnz -95
	<colorMap+?>: inc.sp(-4)
	cmplGfx/lib/color.lookup.ci:31: (4 bytes): y := y + 1
	<colorMap+?>: inc.i32(+1)
	cmplGfx/lib/color.lookup.ci:31: (9 bytes): y < r.y1
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: clt.i32
	<colorMap+?>: jnz -118
	<colorMap+?>: inc.sp(-4)
	cmplGfx/lib/color.lookup.ci:40: (5 bytes): return;
	<colorMap+?>: inc.sp(-20)
	<colorMap+?>: ret
	cmplGfx/lib/color.lookup.ci:59: (531 bytes): for (y: int32 := r.y0; y < r.y1; y := y + 1)
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: jmp +516
	cmplGfx/lib/color.lookup.ci:60: (508 bytes): for (x: int32 := r.x0; x < r.x1; x := x + 1)
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: jmp +493
	cmplGfx/lib/color.lookup.ci:61: (10 bytes): col: argb := argb(Image.get(image, x, y))
	<colorMap+?>: dup.x64 sp(10)
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: dup.x32 sp(4)
	<colorMap+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	cmplGfx/lib/color.lookup.ci:62: (17 bytes): r: int32 := rch(lut[rch(col)])
	<colorMap+?>: dup.x32 sp(9)
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: b32.shr 0x10
	<colorMap+?>: b32.and 0xff
	<colorMap+?>: mad.u32 4
	<colorMap+?>: load.i32
	<colorMap+?>: b32.shr 0x10
	<colorMap+?>: b32.and 0xff
	cmplGfx/lib/color.lookup.ci:63: (17 bytes): g: int32 := gch(lut[gch(col)])
	<colorMap+?>: dup.x32 sp(10)
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: b32.shr 0x08
	<colorMap+?>: b32.and 0xff
	<colorMap+?>: mad.u32 4
	<colorMap+?>: load.i32
	<colorMap+?>: b32.shr 0x08
	<colorMap+?>: b32.and 0xff
	cmplGfx/lib/color.lookup.ci:64: (13 bytes): b: int32 := bch(lut[bch(col)])
	<colorMap+?>: dup.x32 sp(11)
	<colorMap+?>: dup.x32 sp(3)
	<colorMap+?>: b32.and 0xff
	<colorMap+?>: mad.u32 4
	<colorMap+?>: load.i32
	<colorMap+?>: b32.and 0xff
	cmplGfx/lib/color.lookup.ci:66: (36 bytes): l: int32 := (r * rgb2luv[0] + g * rgb2luv[1] + b * rgb2luv[2]) >> fxpBits
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: load.m32 <?> ;colorMap.rgb2luv
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: load.m32 <?> ;colorMap.rgb2luv
	<colorMap+?>: inc.i32(+4)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: load.m32 <?> ;colorMap.rgb2luv
	<colorMap+?>: inc.i32(+8)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: b32.sar 0x10
	cmplGfx/lib/color.lookup.ci:67: (40 bytes): u: int32 := (r * rgb2luv[4] + g * rgb2luv[5] + b * rgb2luv[6]) >> fxpBits
	<colorMap+?>: dup.x32 sp(3)
	<colorMap+?>: load.m32 <?> ;colorMap.rgb2luv
	<colorMap+?>: inc.i32(+16)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: dup.x32 sp(3)
	<colorMap+?>: load.m32 <?> ;colorMap.rgb2luv
	<colorMap+?>: inc.i32(+20)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: load.m32 <?> ;colorMap.rgb2luv
	<colorMap+?>: inc.i32(+24)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: b32.sar 0x10
	cmplGfx/lib/color.lookup.ci:68: (40 bytes): v: int32 := (r * rgb2luv[8] + g * rgb2luv[9] + b * rgb2luv[10]) >> fxpBits
	<colorMap+?>: dup.x32 sp(4)
	<colorMap+?>: load.m32 <?> ;colorMap.rgb2luv
	<colorMap+?>: inc.i32(+32)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: dup.x32 sp(4)
	<colorMap+?>: load.m32 <?> ;colorMap.rgb2luv
	<colorMap+?>: inc.i32(+36)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: dup.x32 sp(3)
	<colorMap+?>: load.m32 <?> ;colorMap.rgb2luv
	<colorMap+?>: inc.i32(+40)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: b32.sar 0x10
	cmplGfx/lib/color.lookup.ci:70: (51 bytes): l := ach(lut[sat_s8(l)]);
	<colorMap+?>: dup.x32 sp(15)
	<colorMap+?>: dup.x32 sp(3)
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: load.c32 255
	<colorMap+?>: cgt.i32
	<colorMap+?>: jz +13
	<colorMap+?>: load.c32 255
	<colorMap+?>: jmp +19
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: load.z32
	<colorMap+?>: clt.i32
	<colorMap+?>: jz +9
	<colorMap+?>: load.z32
	<colorMap+?>: jmp +6
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: set.x32 sp(1)
	<colorMap+?>: mad.u32 4
	<colorMap+?>: load.i32
	<colorMap+?>: b32.shr 0x18
	<colorMap+?>: set.x32 sp(3)
	cmplGfx/lib/color.lookup.ci:72: (79 bytes): col.r := (sat_s8((l * luv2rgb[0] + u * luv2rgb[1] + v * luv2rgb[2]) >> fxpBits));
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: load.m32 <?> ;colorMap.luv2rgb
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: load.m32 <?> ;colorMap.luv2rgb
	<colorMap+?>: inc.i32(+4)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: load.m32 <?> ;colorMap.luv2rgb
	<colorMap+?>: inc.i32(+8)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: b32.sar 0x10
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: load.c32 255
	<colorMap+?>: cgt.i32
	<colorMap+?>: jz +13
	<colorMap+?>: load.c32 255
	<colorMap+?>: jmp +19
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: load.z32
	<colorMap+?>: clt.i32
	<colorMap+?>: jz +9
	<colorMap+?>: load.z32
	<colorMap+?>: jmp +6
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: set.x32 sp(1)
	<colorMap+?>: load.sp(+30)
	<colorMap+?>: store.i8
	cmplGfx/lib/color.lookup.ci:73: (83 bytes): col.g := (sat_s8((l * luv2rgb[4] + u * luv2rgb[5] + v * luv2rgb[6]) >> fxpBits));
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: load.m32 <?> ;colorMap.luv2rgb
	<colorMap+?>: inc.i32(+16)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: load.m32 <?> ;colorMap.luv2rgb
	<colorMap+?>: inc.i32(+20)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: load.m32 <?> ;colorMap.luv2rgb
	<colorMap+?>: inc.i32(+24)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: b32.sar 0x10
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: load.c32 255
	<colorMap+?>: cgt.i32
	<colorMap+?>: jz +13
	<colorMap+?>: load.c32 255
	<colorMap+?>: jmp +19
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: load.z32
	<colorMap+?>: clt.i32
	<colorMap+?>: jz +9
	<colorMap+?>: load.z32
	<colorMap+?>: jmp +6
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: set.x32 sp(1)
	<colorMap+?>: load.sp(+29)
	<colorMap+?>: store.i8
	cmplGfx/lib/color.lookup.ci:74: (83 bytes): col.b := (sat_s8((l * luv2rgb[8] + u * luv2rgb[9] + v * luv2rgb[10]) >> fxpBits));
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: load.m32 <?> ;colorMap.luv2rgb
	<colorMap+?>: inc.i32(+32)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: dup.x32 sp(2)
	<colorMap+?>: load.m32 <?> ;colorMap.luv2rgb
	<colorMap+?>: inc.i32(+36)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: dup.x32 sp(1)
	<colorMap+?>: load.m32 <?> ;colorMap.luv2rgb
	<colorMap+?>: inc.i32(+40)
	<colorMap+?>: load.i32
	<colorMap+?>: mul.i32
	<colorMap+?>: add.i32
	<colorMap+?>: b32.sar 0x10
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: load.c32 255
	<colorMap+?>: cgt.i32
	<colorMap+?>: jz +13
	<colorMap+?>: load.c32 255
	<colorMap+?>: jmp +19
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: load.z32
	<colorMap+?>: clt.i32
	<colorMap+?>: jz +9
	<colorMap+?>: load.z32
	<colorMap+?>: jmp +6
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: set.x32 sp(1)
	<colorMap+?>: load.sp(+28)
	<colorMap+?>: store.i8
	cmplGfx/lib/color.lookup.ci:75: (12 bytes): set(image, x, y, col);
	<colorMap+?>: dup.x64 sp(17)
	<colorMap+?>: dup.x32 sp(9)
	<colorMap+?>: dup.x32 sp(11)
	<colorMap+?>: dup.x32 sp(10)
	<colorMap+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<colorMap+?>: inc.sp(-28)
	cmplGfx/lib/color.lookup.ci:60: (4 bytes): x := x + 1
	<colorMap+?>: inc.i32(+1)
	cmplGfx/lib/color.lookup.ci:60: (9 bytes): x < r.x1
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: clt.i32
	<colorMap+?>: jnz -494
	<colorMap+?>: inc.sp(-4)
	cmplGfx/lib/color.lookup.ci:59: (4 bytes): y := y + 1
	<colorMap+?>: inc.i32(+1)
	cmplGfx/lib/color.lookup.ci:59: (9 bytes): y < r.y1
	<colorMap+?>: dup.x32 sp(0)
	<colorMap+?>: dup.x32 sp(6)
	<colorMap+?>: clt.i32
	<colorMap+?>: jnz -517
	<colorMap+?>: inc.sp(-4)
	<colorMap+?>: inc.sp(-20)
	<colorMap+?>: ret
.usages:
}
colorMat(image: Image, roi: Rect, mat: mat4f): void: function {
.kind: static function
.base: `function`
.size: 684
.name: 'colorMat'
.file: 'cmplGfx/lib/color.matrix.ci:2'
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param roi: Rect (size: 4, cast: const variable(ref))
.param mat: mat4f (size: 4, cast: const variable(ref))
.doc: 'apply a color matrix to each pixel defined by the `roi` on the `image`'
.value: {
	static if ((preferNativeCalls) && (typename(Image.colorMat)) != null) {
		return .result := Image.colorMat(image, roi, mat.data);
	}
	assert(Image.depth(image) == 32);
	r: Rect := {
		r.x0 := (roi) != null ? roi.x0 : 0;
		r.y0 := (roi) != null ? roi.y0 : 0;
		r.x1 := (roi) != null ? roi.x1 : Image.width(image);
		r.y1 := (roi) != null ? roi.y1 : Image.height(image);
	};
	if (!clip(image, &r)) {
		return;
	}
	m00: int32 := (65536) * mat.xx;
	m01: int32 := (65536) * mat.xy;
	m02: int32 := (65536) * mat.xz;
	m03: int32 := (256 * 65536) * mat.xw;
	m10: int32 := (65536) * mat.yx;
	m11: int32 := (65536) * mat.yy;
	m12: int32 := (65536) * mat.yz;
	m13: int32 := (256 * 65536) * mat.yw;
	m20: int32 := (65536) * mat.zx;
	m21: int32 := (65536) * mat.zy;
	m22: int32 := (65536) * mat.zz;
	m23: int32 := (256 * 65536) * mat.zw;
	for (y: int32 := r.y0; y < r.y1; y := y + 1) {
		for (x: int32 := r.x0; x < r.x1; x := x + 1) {
			col: argb := argb(Image.get(image, x, y));
			r: int32 := rch(col);
			g: int32 := gch(col);
			b: int32 := bch(col);
			col.r := (sat_s8((r * m00 + g * m01 + b * m02 + m03) >> 16));
			col.g := (sat_s8((r * m10 + g * m11 + b * m12 + m13) >> 16));
			col.b := (sat_s8((r * m20 + g * m21 + b * m22 + m23) >> 16));
			set(image, x, y, col);
		}
	}
}
.instructions: (684 bytes)
	cmplGfx/lib/color.matrix.ci:4: (11 bytes): return .result := Image.colorMat(image, roi, mat.data);
	<colorMat>  : dup.x64 sp(3)
	<colorMat+?>: dup.x32 sp(4)
	<colorMat+?>: dup.x32 sp(4)
	<colorMat+?>: nfc(114) ;Image.colorMat(image: Image, roi: Rect, mat: float32[16]): void
	<colorMat+?>: ret
	cmplGfx/lib/color.matrix.ci:6: (60 bytes): assert(Image.depth(image) == 32);
	<colorMat+?>: load.z32
	<colorMat+?>: load.sp(+4)
	<colorMat+?>: dup.x64 sp(5)
	<colorMat+?>: nfc(103) ;Image.depth(image: Image): int32
	<colorMat+?>: load.c32 32
	<colorMat+?>: ceq.i32
	<colorMat+?>: jz +8
	<colorMat+?>: jmp +35
	<colorMat+?>: load.ref <?> ;"cmplGfx/lib/color.matrix.ci"
	<colorMat+?>: load.c32 6
	<colorMat+?>: load.c32 -2
	<colorMat+?>: load.c32 128
	<colorMat+?>: load.ref <?> ;"assertion failed!"
	<colorMat+?>: dup.x64 sp(5)
	<colorMat+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<colorMat+?>: inc.sp(-8)
	cmplGfx/lib/color.matrix.ci:9: (114 bytes): r: Rect := {...}
	<colorMat+?>: inc.sp(+16)
	cmplGfx/lib/color.matrix.ci:10: (22 bytes): r.x0 := (roi) != null ? roi.x0 : 0;
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: load.ref <?> ;null
	<colorMat+?>: ceq.i32
	<colorMat+?>: jnz +11
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: load.i32
	<colorMat+?>: jmp +5
	<colorMat+?>: load.z32
	<colorMat+?>: set.x32 sp(1)
	cmplGfx/lib/color.matrix.ci:11: (26 bytes): r.y0 := (roi) != null ? roi.y0 : 0;
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: load.ref <?> ;null
	<colorMat+?>: ceq.i32
	<colorMat+?>: jnz +15
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: inc.i32(+4)
	<colorMat+?>: load.i32
	<colorMat+?>: jmp +5
	<colorMat+?>: load.z32
	<colorMat+?>: set.x32 sp(2)
	cmplGfx/lib/color.matrix.ci:12: (31 bytes): r.x1 := (roi) != null ? roi.x1 : Image.width(image);
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: load.ref <?> ;null
	<colorMat+?>: ceq.i32
	<colorMat+?>: jnz +15
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: inc.i32(+8)
	<colorMat+?>: load.i32
	<colorMat+?>: jmp +10
	<colorMat+?>: dup.x64 sp(7)
	<colorMat+?>: nfc(101) ;Image.width(image: Image): int32
	<colorMat+?>: set.x32 sp(3)
	cmplGfx/lib/color.matrix.ci:13: (31 bytes): r.y1 := (roi) != null ? roi.y1 : Image.height(image);
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: load.ref <?> ;null
	<colorMat+?>: ceq.i32
	<colorMat+?>: jnz +15
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: inc.i32(+12)
	<colorMat+?>: load.i32
	<colorMat+?>: jmp +10
	<colorMat+?>: dup.x64 sp(7)
	<colorMat+?>: nfc(102) ;Image.height(image: Image): int32
	<colorMat+?>: set.x32 sp(4)
	cmplGfx/lib/color.matrix.ci:15: (26 bytes): if (!clip(image, &r))
	<colorMat+?>: load.z32
	<colorMat+?>: dup.x64 sp(8)
	<colorMat+?>: load.sp(+12)
	<colorMat+?>: load.ref <?> ;clip(image: Image, roi: Rect): bool
	<colorMat+?>: call
	<colorMat+?>: inc.sp(-12)
	<colorMat+?>: jnz +9
	cmplGfx/lib/color.matrix.ci:17: (5 bytes): return;
	<colorMat+?>: inc.sp(-16)
	<colorMat+?>: ret
	cmplGfx/lib/color.matrix.ci:20: (10 bytes): m00: int32 := (65536) * mat.xx
	<colorMat+?>: load.f32 65536.000000
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:21: (14 bytes): m01: int32 := (65536) * mat.xy
	<colorMat+?>: load.f32 65536.000000
	<colorMat+?>: dup.x32 sp(7)
	<colorMat+?>: inc.i32(+4)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:22: (14 bytes): m02: int32 := (65536) * mat.xz
	<colorMat+?>: load.f32 65536.000000
	<colorMat+?>: dup.x32 sp(8)
	<colorMat+?>: inc.i32(+8)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:23: (21 bytes): m03: int32 := (256 * 65536) * mat.xw
	<colorMat+?>: load.c32 256
	<colorMat+?>: load.c32 65536
	<colorMat+?>: mul.i32
	<colorMat+?>: i32.2f32
	<colorMat+?>: dup.x32 sp(9)
	<colorMat+?>: inc.i32(+12)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:25: (14 bytes): m10: int32 := (65536) * mat.yx
	<colorMat+?>: load.f32 65536.000000
	<colorMat+?>: dup.x32 sp(10)
	<colorMat+?>: inc.i32(+16)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:26: (14 bytes): m11: int32 := (65536) * mat.yy
	<colorMat+?>: load.f32 65536.000000
	<colorMat+?>: dup.x32 sp(11)
	<colorMat+?>: inc.i32(+20)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:27: (14 bytes): m12: int32 := (65536) * mat.yz
	<colorMat+?>: load.f32 65536.000000
	<colorMat+?>: dup.x32 sp(12)
	<colorMat+?>: inc.i32(+24)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:28: (21 bytes): m13: int32 := (256 * 65536) * mat.yw
	<colorMat+?>: load.c32 256
	<colorMat+?>: load.c32 65536
	<colorMat+?>: mul.i32
	<colorMat+?>: i32.2f32
	<colorMat+?>: dup.x32 sp(13)
	<colorMat+?>: inc.i32(+28)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:30: (14 bytes): m20: int32 := (65536) * mat.zx
	<colorMat+?>: load.f32 65536.000000
	<colorMat+?>: dup.x32 sp(14)
	<colorMat+?>: inc.i32(+32)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:31: (14 bytes): m21: int32 := (65536) * mat.zy
	<colorMat+?>: load.f32 65536.000000
	<colorMat+?>: dup.x32 sp(15)
	<colorMat+?>: inc.i32(+36)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:32: (14 bytes): m22: int32 := (65536) * mat.zz
	<colorMat+?>: load.f32 65536.000000
	<colorMat+?>: dup.x32 sp(16)
	<colorMat+?>: inc.i32(+40)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:33: (21 bytes): m23: int32 := (256 * 65536) * mat.zw
	<colorMat+?>: load.c32 256
	<colorMat+?>: load.c32 65536
	<colorMat+?>: mul.i32
	<colorMat+?>: i32.2f32
	<colorMat+?>: dup.x32 sp(17)
	<colorMat+?>: inc.i32(+44)
	<colorMat+?>: load.i32
	<colorMat+?>: mul.f32
	<colorMat+?>: f32.2i32
	cmplGfx/lib/color.matrix.ci:35: (283 bytes): for (y: int32 := r.y0; y < r.y1; y := y + 1)
	<colorMat+?>: dup.x32 sp(13)
	<colorMat+?>: jmp +268
	cmplGfx/lib/color.matrix.ci:36: (260 bytes): for (x: int32 := r.x0; x < r.x1; x := x + 1)
	<colorMat+?>: dup.x32 sp(13)
	<colorMat+?>: jmp +245
	cmplGfx/lib/color.matrix.ci:37: (10 bytes): col: argb := argb(Image.get(image, x, y))
	<colorMat+?>: dup.x64 sp(21)
	<colorMat+?>: dup.x32 sp(2)
	<colorMat+?>: dup.x32 sp(4)
	<colorMat+?>: nfc(104) ;Image.get(image: Image, x: int32, y: int32): int32
	cmplGfx/lib/color.matrix.ci:38: (6 bytes): r: int32 := rch(col)
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: b32.shr 0x10
	<colorMat+?>: b32.and 0xff
	cmplGfx/lib/color.matrix.ci:39: (6 bytes): g: int32 := gch(col)
	<colorMat+?>: dup.x32 sp(1)
	<colorMat+?>: b32.shr 0x08
	<colorMat+?>: b32.and 0xff
	cmplGfx/lib/color.matrix.ci:40: (4 bytes): b: int32 := bch(col)
	<colorMat+?>: dup.x32 sp(2)
	<colorMat+?>: b32.and 0xff
	cmplGfx/lib/color.matrix.ci:41: (65 bytes): col.r := (sat_s8((r * m00 + g * m01 + b * m02 + m03) >> 16));
	<colorMat+?>: dup.x32 sp(2)
	<colorMat+?>: dup.x32 sp(18)
	<colorMat+?>: mul.i32
	<colorMat+?>: dup.x32 sp(2)
	<colorMat+?>: dup.x32 sp(18)
	<colorMat+?>: mul.i32
	<colorMat+?>: add.i32
	<colorMat+?>: dup.x32 sp(1)
	<colorMat+?>: dup.x32 sp(17)
	<colorMat+?>: mul.i32
	<colorMat+?>: add.i32
	<colorMat+?>: dup.x32 sp(15)
	<colorMat+?>: add.i32
	<colorMat+?>: b32.sar 0x10
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: load.c32 255
	<colorMat+?>: cgt.i32
	<colorMat+?>: jz +13
	<colorMat+?>: load.c32 255
	<colorMat+?>: jmp +19
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: load.z32
	<colorMat+?>: clt.i32
	<colorMat+?>: jz +9
	<colorMat+?>: load.z32
	<colorMat+?>: jmp +6
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: set.x32 sp(1)
	<colorMat+?>: load.sp(+18)
	<colorMat+?>: store.i8
	cmplGfx/lib/color.matrix.ci:42: (65 bytes): col.g := (sat_s8((r * m10 + g * m11 + b * m12 + m13) >> 16));
	<colorMat+?>: dup.x32 sp(2)
	<colorMat+?>: dup.x32 sp(14)
	<colorMat+?>: mul.i32
	<colorMat+?>: dup.x32 sp(2)
	<colorMat+?>: dup.x32 sp(14)
	<colorMat+?>: mul.i32
	<colorMat+?>: add.i32
	<colorMat+?>: dup.x32 sp(1)
	<colorMat+?>: dup.x32 sp(13)
	<colorMat+?>: mul.i32
	<colorMat+?>: add.i32
	<colorMat+?>: dup.x32 sp(11)
	<colorMat+?>: add.i32
	<colorMat+?>: b32.sar 0x10
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: load.c32 255
	<colorMat+?>: cgt.i32
	<colorMat+?>: jz +13
	<colorMat+?>: load.c32 255
	<colorMat+?>: jmp +19
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: load.z32
	<colorMat+?>: clt.i32
	<colorMat+?>: jz +9
	<colorMat+?>: load.z32
	<colorMat+?>: jmp +6
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: set.x32 sp(1)
	<colorMat+?>: load.sp(+17)
	<colorMat+?>: store.i8
	cmplGfx/lib/color.matrix.ci:43: (65 bytes): col.b := (sat_s8((r * m20 + g * m21 + b * m22 + m23) >> 16));
	<colorMat+?>: dup.x32 sp(2)
	<colorMat+?>: dup.x32 sp(10)
	<colorMat+?>: mul.i32
	<colorMat+?>: dup.x32 sp(2)
	<colorMat+?>: dup.x32 sp(10)
	<colorMat+?>: mul.i32
	<colorMat+?>: add.i32
	<colorMat+?>: dup.x32 sp(1)
	<colorMat+?>: dup.x32 sp(9)
	<colorMat+?>: mul.i32
	<colorMat+?>: add.i32
	<colorMat+?>: dup.x32 sp(7)
	<colorMat+?>: add.i32
	<colorMat+?>: b32.sar 0x10
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: load.c32 255
	<colorMat+?>: cgt.i32
	<colorMat+?>: jz +13
	<colorMat+?>: load.c32 255
	<colorMat+?>: jmp +19
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: load.z32
	<colorMat+?>: clt.i32
	<colorMat+?>: jz +9
	<colorMat+?>: load.z32
	<colorMat+?>: jmp +6
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: set.x32 sp(1)
	<colorMat+?>: load.sp(+16)
	<colorMat+?>: store.i8
	cmplGfx/lib/color.matrix.ci:44: (12 bytes): set(image, x, y, col);
	<colorMat+?>: dup.x64 sp(25)
	<colorMat+?>: dup.x32 sp(6)
	<colorMat+?>: dup.x32 sp(8)
	<colorMat+?>: dup.x32 sp(7)
	<colorMat+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<colorMat+?>: inc.sp(-16)
	cmplGfx/lib/color.matrix.ci:36: (4 bytes): x := x + 1
	<colorMat+?>: inc.i32(+1)
	cmplGfx/lib/color.matrix.ci:36: (9 bytes): x < r.x1
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: dup.x32 sp(17)
	<colorMat+?>: clt.i32
	<colorMat+?>: jnz -246
	<colorMat+?>: inc.sp(-4)
	cmplGfx/lib/color.matrix.ci:35: (4 bytes): y := y + 1
	<colorMat+?>: inc.i32(+1)
	cmplGfx/lib/color.matrix.ci:35: (9 bytes): y < r.y1
	<colorMat+?>: dup.x32 sp(0)
	<colorMat+?>: dup.x32 sp(17)
	<colorMat+?>: clt.i32
	<colorMat+?>: jnz -269
	<colorMat+?>: inc.sp(-4)
	<colorMat+?>: inc.sp(-64)
	<colorMat+?>: ret
.usages:
}
Mesh(fileName: char[*]): Mesh: function {
.kind: static function
.base: `function`
.size: 124
.name: 'Mesh'
.file: 'cmplGfx/lib/mesh.ci:2'
.param .result: Mesh (size: 4, cast: variable(ref))
.param fileName: char[*] (size: 4, cast: const variable(ref))
.doc: 'Create a mesh by opening a file'
.value: {
	if (endsWith(fileName, ".obj", ignCaseCmp)) {
		return .result := Mesh.openObj(fileName);
	}
	if (endsWith(fileName, ".3ds", ignCaseCmp)) {
		return .result := Mesh.open3ds(fileName);
	}
	abort("unknown file extension", fileName);
}
.instructions: (124 bytes)
	cmplGfx/lib/mesh.ci:3: (36 bytes): if (endsWith(fileName, ".obj", ignCaseCmp))
	<Mesh>  : load.z32
	<Mesh+?>: dup.x32 sp(2)
	<Mesh+?>: load.ref <?> ;".obj"
	<Mesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<Mesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<Mesh+?>: call
	<Mesh+?>: inc.sp(-12)
	<Mesh+?>: jz +13
	cmplGfx/lib/mesh.ci:4: (9 bytes): return .result := Mesh.openObj(fileName);
	<Mesh+?>: dup.x32 sp(1)
	<Mesh+?>: nfc(73) ;Mesh.openObj(path: char[*]): Mesh
	<Mesh+?>: set.x32 sp(3)
	<Mesh+?>: ret
	cmplGfx/lib/mesh.ci:6: (36 bytes): if (endsWith(fileName, ".3ds", ignCaseCmp))
	<Mesh+?>: load.z32
	<Mesh+?>: dup.x32 sp(2)
	<Mesh+?>: load.ref <?> ;".3ds"
	<Mesh+?>: load.ref <?> ;ignCaseCmp(chr: char, with: char): int32
	<Mesh+?>: load.ref <?> ;endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool
	<Mesh+?>: call
	<Mesh+?>: inc.sp(-12)
	<Mesh+?>: jz +13
	cmplGfx/lib/mesh.ci:7: (9 bytes): return .result := Mesh.open3ds(fileName);
	<Mesh+?>: dup.x32 sp(1)
	<Mesh+?>: nfc(74) ;Mesh.open3ds(path: char[*]): Mesh
	<Mesh+?>: set.x32 sp(3)
	<Mesh+?>: ret
	cmplGfx/lib/mesh.ci:9: (51 bytes): abort("unknown file extension", fileName);
	<Mesh+?>: load.ref <?>
	<Mesh+?>: dup.x32 sp(2)
	<Mesh+?>: load.c32 1
	<Mesh+?>: load.sp(+4)
	<Mesh+?>: load.ref <?> ;"cmplGfx/lib/mesh.ci"
	<Mesh+?>: load.c32 9
	<Mesh+?>: load.c32 -2
	<Mesh+?>: load.c32 128
	<Mesh+?>: load.ref <?> ;"unknown file extension"
	<Mesh+?>: dup.x64 sp(5)
	<Mesh+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<Mesh+?>: inc.sp(-16)
	<Mesh+?>: ret
.usages:
}
Camera: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.name: 'Camera'
.file: 'cmplGfx/lib/camera.ci:2'
.field position: vec4f (size: 16, cast: variable(val))
.field forward: vec4f (size: 16, cast: variable(val))
.field right: vec4f (size: 16, cast: variable(val))
.field up: vec4f (size: 16, cast: variable(val))
.field projection: function (size: 185, cast: static function)
.field lookAt: function (size: 327, cast: static function)
.field matrix: function (size: 98, cast: static function)
.field matrix: function (size: 109, cast: static function)
.field move: function (size: 28, cast: static function)
.field rotate: function (size: 430, cast: static function)
.doc: 'Simple camera for 3d transformations and projection.'
.usages:
	cmplGfx/lib/window.ci:379: referenced as `Camera`
	cmplGfx/lib/window.ci:349: referenced as `Camera`
	cmplGfx/lib/window.ci:345: referenced as `Camera`
	cmplGfx/lib/window.ci:309: referenced as `Camera`
	cmplGfx/lib/window.ci:303: referenced as `Camera`
	cmplGfx/lib/window.ci:297: referenced as `Camera`
	cmplGfx/lib/window.ci:291: referenced as `Camera`
	cmplGfx/lib/window.ci:284: referenced as `Camera`
	cmplGfx/lib/window.ci:278: referenced as `Camera`
	cmplGfx/lib/window.ci:272: referenced as `Camera`
	cmplGfx/lib/window.ci:266: referenced as `Camera`
	cmplGfx/lib/window.ci:251: referenced as `Camera`
	cmplGfx/lib/window.ci:213: referenced as `Camera`
	cmplGfx/lib/window.ci:177: referenced as `Camera`
	cmplGfx/lib/window.ci:173: referenced as `Camera`
	cmplGfx/lib/camera.ci:72: referenced as `Camera`
	cmplGfx/lib/camera.ci:67: referenced as `Camera`
	cmplGfx/lib/camera.ci:62: referenced as `Camera`
	cmplGfx/lib/camera.ci:52: referenced as `Camera`
	cmplGfx/lib/camera.ci:40: referenced as `Camera`
}
Camera.position: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'position'
.file: 'cmplGfx/lib/camera.ci:4'
.owner: Camera
.doc: '@public'
.value: vec4f(0, 0, 0, 1)
.usages:
	cmplGfx/lib/window.ci:311: referenced as `position`
	cmplGfx/lib/window.ci:305: referenced as `position`
	cmplGfx/lib/window.ci:299: referenced as `position`
	cmplGfx/lib/window.ci:293: referenced as `position`
	cmplGfx/lib/window.ci:226: referenced as `position`
	cmplGfx/lib/window.ci:178: referenced as `position`
	cmplGfx/lib/camera.ci:82: referenced as `position`
	cmplGfx/lib/camera.ci:82: referenced as `position`
	cmplGfx/lib/camera.ci:68: referenced as `position`
	cmplGfx/lib/camera.ci:68: referenced as `position`
	cmplGfx/lib/camera.ci:56: referenced as `position`
	cmplGfx/lib/camera.ci:55: referenced as `position`
	cmplGfx/lib/camera.ci:54: referenced as `position`
	cmplGfx/lib/camera.ci:44: referenced as `position`
	internal usages: 1
}
Camera.forward: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'forward'
.file: 'cmplGfx/lib/camera.ci:6'
.owner: Camera
.doc: '@public'
.value: vec4f(0, 0, 0, 1)
.usages:
	cmplGfx/lib/window.ci:274: referenced as `forward`
	cmplGfx/lib/window.ci:268: referenced as `forward`
	cmplGfx/lib/window.ci:252: referenced as `forward`
	cmplGfx/lib/window.ci:233: referenced as `forward`
	cmplGfx/lib/window.ci:178: referenced as `forward`
	cmplGfx/lib/camera.ci:81: referenced as `forward`
	cmplGfx/lib/camera.ci:79: referenced as `forward`
	cmplGfx/lib/camera.ci:79: referenced as `forward`
	cmplGfx/lib/camera.ci:56: referenced as `forward`
	cmplGfx/lib/camera.ci:56: referenced as `forward`
	cmplGfx/lib/camera.ci:45: referenced as `forward`
	internal usages: 1
}
Camera.right: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'right'
.file: 'cmplGfx/lib/camera.ci:8'
.owner: Camera
.doc: '@public'
.value: vec4f(0, 0, 0, 1)
.usages:
	cmplGfx/lib/window.ci:299: referenced as `right`
	cmplGfx/lib/window.ci:293: referenced as `right`
	cmplGfx/lib/window.ci:286: referenced as `right`
	cmplGfx/lib/window.ci:280: referenced as `right`
	cmplGfx/lib/window.ci:238: referenced as `right`
	cmplGfx/lib/window.ci:228: referenced as `right`
	cmplGfx/lib/window.ci:221: referenced as `right`
	cmplGfx/lib/window.ci:178: referenced as `right`
	cmplGfx/lib/camera.ci:81: referenced as `right`
	cmplGfx/lib/camera.ci:80: referenced as `right`
	cmplGfx/lib/camera.ci:80: referenced as `right`
	cmplGfx/lib/camera.ci:54: referenced as `right`
	cmplGfx/lib/camera.ci:54: referenced as `right`
	cmplGfx/lib/camera.ci:46: referenced as `right`
	internal usages: 1
}
Camera.up: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'up'
.file: 'cmplGfx/lib/camera.ci:10'
.owner: Camera
.doc: '@public'
.value: vec4f(0, 1, 0, 1)
.usages:
	cmplGfx/lib/window.ci:311: referenced as `up`
	cmplGfx/lib/window.ci:305: referenced as `up`
	cmplGfx/lib/window.ci:239: referenced as `up`
	cmplGfx/lib/window.ci:227: referenced as `up`
	cmplGfx/lib/window.ci:220: referenced as `up`
	cmplGfx/lib/window.ci:178: referenced as `up`
	cmplGfx/lib/camera.ci:81: referenced as `up`
	cmplGfx/lib/camera.ci:55: referenced as `up`
	cmplGfx/lib/camera.ci:55: referenced as `up`
	cmplGfx/lib/camera.ci:47: referenced as `up`
	internal usages: 1
}
Camera.projection(fov: float32, asp: float32, n: float32, f: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 185
.name: 'projection'
.file: 'cmplGfx/lib/camera.ci:13'
.owner: Camera
.param .result: mat4f (size: 64, cast: variable(val))
.param fov: float32 (size: 4, cast: variable(f32))
.param asp: float32 (size: 4, cast: variable(f32))
.param n: float32 (size: 4, cast: variable(f32))
.param f: float32 (size: 4, cast: variable(f32))
.doc: 'Create an orthographic(`fov` == 0) or perspective projection matrix'
.value: {
	bot: float32 := 1;
	nf: float32 := n - f;
	if (fov == (0)) {
		return .result := {
			.result.x := vec4f((1) / asp, 0, 0, 0);
			.result.y := vec4f(0, (1) / bot, 0, 0);
			.result.z := vec4f(0, 0, (2) / nf, -(f + n) / nf);
			.result.w := vec4f(0, 0, 0, 1);
		};
	}
	bot := (Math.tan(Math.radians(fov)));
	asp := asp * bot;
	return .result := {
			.result.x := vec4f(n / asp, 0, 0, 0);
			.result.y := vec4f(0, n / bot, 0, 0);
			.result.z := vec4f(0, 0, (n + f) / nf, (-2) * n * f / nf);
			.result.w := vec4f(0, 0, 1, 0);
		};
}
.instructions: (185 bytes)
	cmplGfx/lib/camera.ci:14: (5 bytes): bot: float32 := 1
	<projection>  : load.f32 1.000000
	cmplGfx/lib/camera.ci:15: (5 bytes): nf: float32 := n - f
	<projection+?>: dup.x32 sp(3)
	<projection+?>: dup.x32 sp(3)
	<projection+?>: sub.f32
	cmplGfx/lib/camera.ci:17: (70 bytes): if (fov == (0))
	<projection+?>: dup.x32 sp(6)
	<projection+?>: load.z32
	<projection+?>: ceq.f32
	<projection+?>: jz +66
	cmplGfx/lib/camera.ci:19: (62 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:20: (13 bytes): .result.x := vec4f((1) / asp, 0, 0, 0);
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.f32 1.000000
	<projection+?>: dup.x32 sp(9)
	<projection+?>: div.f32
	<projection+?>: set.x128 sp(11)
	cmplGfx/lib/camera.ci:21: (13 bytes): .result.y := vec4f(0, (1) / bot, 0, 0);
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.f32 1.000000
	<projection+?>: dup.x32 sp(4)
	<projection+?>: div.f32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(15)
	cmplGfx/lib/camera.ci:22: (21 bytes): .result.z := vec4f(0, 0, (2) / nf, -(f + n) / nf);
	<projection+?>: dup.x32 sp(3)
	<projection+?>: dup.x32 sp(5)
	<projection+?>: add.f32
	<projection+?>: neg.f32
	<projection+?>: dup.x32 sp(1)
	<projection+?>: div.f32
	<projection+?>: load.f32 2.000000
	<projection+?>: dup.x32 sp(2)
	<projection+?>: div.f32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(19)
	cmplGfx/lib/camera.ci:23: (10 bytes): .result.w := vec4f(0, 0, 0, 1);
	<projection+?>: load.f32 1.000000
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(23)
	<projection+?>: inc.sp(-8)
	<projection+?>: ret
	cmplGfx/lib/camera.ci:28: (37 bytes): bot := (Math.tan(Math.radians(fov)));
	<projection+?>: load.z64
	<projection+?>: dup.x32 sp(8)
	<projection+?>: f32.2f64
	<projection+?>: load.f64 3.141593
	<projection+?>: mul.f64
	<projection+?>: load.f64 180.000000
	<projection+?>: div.f64
	<projection+?>: load.ref <?> ;Math.tan(x: float64): float64
	<projection+?>: call
	<projection+?>: inc.sp(-8)
	<projection+?>: f64.2f32
	<projection+?>: set.x32 sp(2)
	cmplGfx/lib/camera.ci:29: (7 bytes): asp := asp * bot;
	<projection+?>: dup.x32 sp(5)
	<projection+?>: dup.x32 sp(2)
	<projection+?>: mul.f32
	<projection+?>: set.x32 sp(6)
	cmplGfx/lib/camera.ci:31: (61 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:32: (10 bytes): .result.x := vec4f(n / asp, 0, 0, 0);
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: dup.x32 sp(7)
	<projection+?>: dup.x32 sp(9)
	<projection+?>: div.f32
	<projection+?>: set.x128 sp(11)
	cmplGfx/lib/camera.ci:33: (10 bytes): .result.y := vec4f(0, n / bot, 0, 0);
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: dup.x32 sp(6)
	<projection+?>: dup.x32 sp(4)
	<projection+?>: div.f32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(15)
	cmplGfx/lib/camera.ci:34: (26 bytes): .result.z := vec4f(0, 0, (n + f) / nf, (-2) * n * f / nf);
	<projection+?>: load.f32 -2.000000
	<projection+?>: dup.x32 sp(5)
	<projection+?>: mul.f32
	<projection+?>: dup.x32 sp(4)
	<projection+?>: mul.f32
	<projection+?>: dup.x32 sp(1)
	<projection+?>: div.f32
	<projection+?>: dup.x32 sp(5)
	<projection+?>: dup.x32 sp(5)
	<projection+?>: add.f32
	<projection+?>: dup.x32 sp(2)
	<projection+?>: div.f32
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(19)
	cmplGfx/lib/camera.ci:35: (10 bytes): .result.w := vec4f(0, 0, 1, 0);
	<projection+?>: load.z32
	<projection+?>: load.f32 1.000000
	<projection+?>: load.z32
	<projection+?>: load.z32
	<projection+?>: set.x128 sp(23)
	<projection+?>: inc.sp(-8)
	<projection+?>: ret
.usages:
	cmplGfx/lib/window.ci:379: referenced as `projection`
	cmplGfx/lib/camera.ci:63: referenced as `projection`
}
Camera.lookAt(position: vec4f, target: vec4f, up: vec4f): Camera: function {
.kind: static function
.base: `function`
.size: 327
.name: 'lookAt'
.file: 'cmplGfx/lib/camera.ci:40'
.owner: Camera
.param .result: Camera (size: 64, cast: variable(val))
.param position: vec4f (size: 16, cast: variable(val))
.param target: vec4f (size: 16, cast: variable(val))
.param up: vec4f (size: 16, cast: variable(val))
.doc: 'Create a camera at the given `position` looking at the given `target`'
.value: {
	forward: vec4f := normalize(sub(target, position));
	right: vec4f := normalize(cross(up, forward));
	return .result := {
			.result.position := position;
			.result.forward := forward;
			.result.right := right;
			.result.up := cross(forward, right);
		};
}
.instructions: (327 bytes)
	cmplGfx/lib/camera.ci:41: (61 bytes): forward: vec4f := normalize(sub(target, position))
	<lookAt>  : dup.x128 sp(5)
	<lookAt+?>: dup.x128 sp(13)
	<lookAt+?>: sub.v4f
	<lookAt+?>: load.sp(+0)
	<lookAt+?>: dup.x32 sp(0)
	<lookAt+?>: load.i128
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: load.i128
	<lookAt+?>: load.z32
	<lookAt+?>: dup.x128 sp(1)
	<lookAt+?>: dup.x128 sp(5)
	<lookAt+?>: dp3.v4f
	<lookAt+?>: load.ref <?> ;Math.sqrt(x: float32): float32
	<lookAt+?>: call
	<lookAt+?>: inc.sp(-4)
	<lookAt+?>: mov.x32 sp(4, 0)
	<lookAt+?>: inc.sp(-16)
	<lookAt+?>: dup.x32 sp(0)
	<lookAt+?>: dup.x32 sp(1)
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: mov.x128 sp(1, 0)
	<lookAt+?>: inc.sp(-4)
	<lookAt+?>: div.v4f
	<lookAt+?>: mov.x128 sp(5, 0)
	<lookAt+?>: inc.sp(-20)
	cmplGfx/lib/camera.ci:42: (153 bytes): right: vec4f := normalize(cross(up, forward))
	<lookAt+?>: load.sp(+20)
	<lookAt+?>: load.sp(+4)
	<lookAt+?>: load.f32 1.000000
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(5)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(5)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: mov.x128 sp(2, 0)
	<lookAt+?>: inc.sp(-8)
	<lookAt+?>: load.sp(+0)
	<lookAt+?>: dup.x32 sp(0)
	<lookAt+?>: load.i128
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: load.i128
	<lookAt+?>: load.z32
	<lookAt+?>: dup.x128 sp(1)
	<lookAt+?>: dup.x128 sp(5)
	<lookAt+?>: dp3.v4f
	<lookAt+?>: load.ref <?> ;Math.sqrt(x: float32): float32
	<lookAt+?>: call
	<lookAt+?>: inc.sp(-4)
	<lookAt+?>: mov.x32 sp(4, 0)
	<lookAt+?>: inc.sp(-16)
	<lookAt+?>: dup.x32 sp(0)
	<lookAt+?>: dup.x32 sp(1)
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: mov.x128 sp(1, 0)
	<lookAt+?>: inc.sp(-4)
	<lookAt+?>: div.v4f
	<lookAt+?>: mov.x128 sp(5, 0)
	<lookAt+?>: inc.sp(-20)
	cmplGfx/lib/camera.ci:43: (113 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:44: (3 bytes): .result.position := position;
	<lookAt+?>: mov.x128 sp(21, 17)
	cmplGfx/lib/camera.ci:45: (3 bytes): .result.forward := forward;
	<lookAt+?>: mov.x128 sp(25, 4)
	cmplGfx/lib/camera.ci:46: (3 bytes): .result.right := right;
	<lookAt+?>: mov.x128 sp(29, 0)
	cmplGfx/lib/camera.ci:47: (99 bytes): .result.up := cross(forward, right);
	<lookAt+?>: load.sp(+16)
	<lookAt+?>: load.sp(+4)
	<lookAt+?>: load.f32 1.000000
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(2)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(3)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(4)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: dup.x32 sp(5)
	<lookAt+?>: inc.i32(+8)
	<lookAt+?>: load.i32
	<lookAt+?>: dup.x32 sp(5)
	<lookAt+?>: inc.i32(+4)
	<lookAt+?>: load.i32
	<lookAt+?>: mul.f32
	<lookAt+?>: sub.f32
	<lookAt+?>: mov.x128 sp(2, 0)
	<lookAt+?>: inc.sp(-8)
	<lookAt+?>: set.x128 sp(37)
	<lookAt+?>: inc.sp(-32)
	<lookAt+?>: ret
.usages:
	cmplGfx/lib/window.ci:349: referenced as `lookAt`
}
Camera.matrix(camera: Camera): mat4f: function {
.kind: static function
.base: `function`
.size: 98
.name: 'matrix'
.file: 'cmplGfx/lib/camera.ci:52'
.owner: Camera
.param .result: mat4f (size: 64, cast: variable(val))
.param camera: Camera (size: 4, cast: const variable(ref))
.doc: 'get the matrix of the camera, which can be multiplied with the projection matrix'
.value: {
	return .result := {
			.result.x := vec4f(camera.right, -dp3(camera.right, camera.position));
			.result.y := vec4f(camera.up, -dp3(camera.up, camera.position));
			.result.z := vec4f(camera.forward, -dp3(camera.forward, camera.position));
			.result.w := vec4f(0, 0, 0, 1);
		};
}
.instructions: (98 bytes)
	cmplGfx/lib/camera.ci:53: (98 bytes): return .result := {...};
	cmplGfx/lib/camera.ci:54: (29 bytes): .result.x := vec4f(camera.right, -dp3(camera.right, camera.position));
	<matrix>  : dup.x32 sp(1)
	<matrix+?>: inc.i32(+32)
	<matrix+?>: load.i128
	<matrix+?>: dup.x32 sp(5)
	<matrix+?>: inc.i32(+32)
	<matrix+?>: load.i128
	<matrix+?>: dup.x32 sp(9)
	<matrix+?>: load.i128
	<matrix+?>: dp3.v4f
	<matrix+?>: neg.f32
	<matrix+?>: dup.x32 sp(3)
	<matrix+?>: dup.x32 sp(3)
	<matrix+?>: dup.x32 sp(3)
	<matrix+?>: set.x128 sp(4)
	<matrix+?>: set.x128 sp(6)
	cmplGfx/lib/camera.ci:55: (29 bytes): .result.y := vec4f(camera.up, -dp3(camera.up, camera.position));
	<matrix+?>: dup.x32 sp(1)
	<matrix+?>: inc.i32(+48)
	<matrix+?>: load.i128
	<matrix+?>: dup.x32 sp(5)
	<matrix+?>: inc.i32(+48)
	<matrix+?>: load.i128
	<matrix+?>: dup.x32 sp(9)
	<matrix+?>: load.i128
	<matrix+?>: dp3.v4f
	<matrix+?>: neg.f32
	<matrix+?>: dup.x32 sp(3)
	<matrix+?>: dup.x32 sp(3)
	<matrix+?>: dup.x32 sp(3)
	<matrix+?>: set.x128 sp(4)
	<matrix+?>: set.x128 sp(10)
	cmplGfx/lib/camera.ci:56: (29 bytes): .result.z := vec4f(camera.forward, -dp3(camera.forward, camera.position));
	<matrix+?>: dup.x32 sp(1)
	<matrix+?>: inc.i32(+16)
	<matrix+?>: load.i128
	<matrix+?>: dup.x32 sp(5)
	<matrix+?>: inc.i32(+16)
	<matrix+?>: load.i128
	<matrix+?>: dup.x32 sp(9)
	<matrix+?>: load.i128
	<matrix+?>: dp3.v4f
	<matrix+?>: neg.f32
	<matrix+?>: dup.x32 sp(3)
	<matrix+?>: dup.x32 sp(3)
	<matrix+?>: dup.x32 sp(3)
	<matrix+?>: set.x128 sp(4)
	<matrix+?>: set.x128 sp(14)
	cmplGfx/lib/camera.ci:57: (10 bytes): .result.w := vec4f(0, 0, 0, 1);
	<matrix+?>: load.f32 1.000000
	<matrix+?>: load.z32
	<matrix+?>: load.z32
	<matrix+?>: load.z32
	<matrix+?>: set.x128 sp(18)
	<matrix+?>: ret
.usages:
	cmplGfx/lib/camera.ci:63: referenced as `matrix`
}
Camera.matrix(camera: Camera, fov: float32, asp: float32, n: float32, f: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 109
.name: 'matrix'
.file: 'cmplGfx/lib/camera.ci:62'
.owner: Camera
.param .result: mat4f (size: 64, cast: variable(val))
.param camera: Camera (size: 4, cast: const variable(ref))
.param fov: float32 (size: 4, cast: variable(f32))
.param asp: float32 (size: 4, cast: variable(f32))
.param n: float32 (size: 4, cast: variable(f32))
.param f: float32 (size: 4, cast: variable(f32))
.doc: 'get the matrix of the camera multiplied with the projection matrix'
.value: {
	return .result := mul(projection(fov, asp, n, f), matrix(camera));
}
.instructions: (109 bytes)
	cmplGfx/lib/camera.ci:63: (109 bytes): return .result := mul(projection(fov, asp, n, f), matrix(camera));
	<matrix>  : inc.sp(+64)
	<matrix+?>: dup.x32 sp(20)
	<matrix+?>: dup.x32 sp(20)
	<matrix+?>: dup.x32 sp(20)
	<matrix+?>: dup.x32 sp(20)
	<matrix+?>: load.ref <?> ;Camera.projection(fov: float32, asp: float32, n: float32, f: float32): mat4f
	<matrix+?>: call
	<matrix+?>: inc.sp(-16)
	<matrix+?>: inc.sp(+64)
	<matrix+?>: dup.x32 sp(37)
	<matrix+?>: load.ref <?> ;Camera.matrix(camera: Camera): mat4f
	<matrix+?>: call
	<matrix+?>: inc.sp(-4)
	<matrix+?>: inc.sp(+64)
	<matrix+?>: load.sp(+128)
	<matrix+?>: load.sp(+68)
	<matrix+?>: load.ref <?> ;mul(lhs: mat4f, rhs: mat4f): mat4f
	<matrix+?>: call
	<matrix+?>: load.sp(+8)
	<matrix+?>: load.sp(-60)
	<matrix+?>: copy.mem -64
	<matrix+?>: inc.sp(+64)
	<matrix+?>: load.sp(+200)
	<matrix+?>: load.sp(+4)
	<matrix+?>: copy.mem 64
	<matrix+?>: inc.sp(-64)
	<matrix+?>: inc.sp(-136)
	<matrix+?>: load.sp(+88)
	<matrix+?>: load.sp(+4)
	<matrix+?>: copy.mem 64
	<matrix+?>: inc.sp(-64)
	<matrix+?>: ret
.usages:
}
Camera.move(camera: Camera, direction: vec4f, amount: float32): void: function {
.kind: static function
.base: `function`
.size: 28
.name: 'move'
.file: 'cmplGfx/lib/camera.ci:67'
.owner: Camera
.param .result: void (size: 0, cast: variable(void))
.param camera: Camera (size: 4, cast: variable(ref))
.param direction: vec4f (size: 16, cast: variable(val))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Move the camera in the given `direction` with the given `amount`'
.value: {
	camera.position := add(camera.position, mul(direction, amount));
}
.instructions: (28 bytes)
	cmplGfx/lib/camera.ci:68: (27 bytes): camera.position := add(camera.position, mul(direction, amount));
	<move>  : dup.x32 sp(6)
	<move+?>: load.i128
	<move+?>: dup.x128 sp(6)
	<move+?>: dup.x32 sp(9)
	<move+?>: dup.x32 sp(0)
	<move+?>: dup.x32 sp(1)
	<move+?>: dup.x32 sp(2)
	<move+?>: dup.x32 sp(3)
	<move+?>: mov.x128 sp(1, 0)
	<move+?>: inc.sp(-4)
	<move+?>: mul.v4f
	<move+?>: add.v4f
	<move+?>: dup.x32 sp(10)
	<move+?>: store.i128
	<move+?>: ret
.usages:
	cmplGfx/lib/window.ci:286: referenced as `move`
	cmplGfx/lib/window.ci:280: referenced as `move`
	cmplGfx/lib/window.ci:274: referenced as `move`
	cmplGfx/lib/window.ci:268: referenced as `move`
	cmplGfx/lib/window.ci:252: referenced as `move`
	cmplGfx/lib/window.ci:239: referenced as `move`
	cmplGfx/lib/window.ci:238: referenced as `move`
	cmplGfx/lib/window.ci:233: referenced as `move`
}
Camera.rotate(camera: Camera, orbit: vec4f, direction: vec4f, amount: float32): void: function {
.kind: static function
.base: `function`
.size: 430
.name: 'rotate'
.file: 'cmplGfx/lib/camera.ci:72'
.owner: Camera
.param .result: void (size: 0, cast: variable(void))
.param camera: Camera (size: 4, cast: variable(ref))
.param orbit: vec4f (size: 16, cast: variable(val))
.param direction: vec4f (size: 16, cast: variable(val))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Rotate the camera around `orbit` in the given `direction` with the given `amount`'
.value: {
	if (amount == (0)) {
		return;
	}
	matrix: mat4f := rotation(orbit, direction, amount);
	camera.forward := normalize(dp3(matrix, camera.forward));
	camera.right := normalize(dp3(matrix, camera.right));
	camera.up := cross(camera.forward, camera.right);
	camera.position := dph(matrix, camera.position);
}
.instructions: (430 bytes)
	cmplGfx/lib/camera.ci:73: (9 bytes): if (amount == (0))
	<rotate>  : dup.x32 sp(1)
	<rotate+?>: load.z32
	<rotate+?>: ceq.f32
	<rotate+?>: jz +5
	cmplGfx/lib/camera.ci:74: (1 byte): return;
	<rotate+?>: ret
	cmplGfx/lib/camera.ci:78: (24 bytes): matrix: mat4f := rotation(orbit, direction, amount)
	<rotate+?>: inc.sp(+64)
	<rotate+?>: load.sp(+88)
	<rotate+?>: load.sp(+76)
	<rotate+?>: dup.x32 sp(19)
	<rotate+?>: load.ref <?> ;rotation(center: vec4f, direction: vec4f, angle: float32): mat4f
	<rotate+?>: call
	<rotate+?>: inc.sp(-12)
	cmplGfx/lib/camera.ci:79: (114 bytes): camera.forward := normalize(dp3(matrix, camera.forward));
	<rotate+?>: load.sp(+0)
	<rotate+?>: dup.x32 sp(27)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: load.f32 1.000000
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(6)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(7)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: mov.x128 sp(2, 0)
	<rotate+?>: inc.sp(-8)
	<rotate+?>: load.sp(+0)
	<rotate+?>: dup.x32 sp(0)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: load.z32
	<rotate+?>: dup.x128 sp(1)
	<rotate+?>: dup.x128 sp(5)
	<rotate+?>: dp3.v4f
	<rotate+?>: load.ref <?> ;Math.sqrt(x: float32): float32
	<rotate+?>: call
	<rotate+?>: inc.sp(-4)
	<rotate+?>: mov.x32 sp(4, 0)
	<rotate+?>: inc.sp(-16)
	<rotate+?>: dup.x32 sp(0)
	<rotate+?>: dup.x32 sp(1)
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: mov.x128 sp(1, 0)
	<rotate+?>: inc.sp(-4)
	<rotate+?>: div.v4f
	<rotate+?>: mov.x128 sp(5, 0)
	<rotate+?>: inc.sp(-20)
	<rotate+?>: dup.x32 sp(30)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: store.i128
	cmplGfx/lib/camera.ci:80: (114 bytes): camera.right := normalize(dp3(matrix, camera.right));
	<rotate+?>: load.sp(+0)
	<rotate+?>: dup.x32 sp(27)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.f32 1.000000
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(6)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(7)
	<rotate+?>: load.i128
	<rotate+?>: dp3.v4f
	<rotate+?>: mov.x128 sp(2, 0)
	<rotate+?>: inc.sp(-8)
	<rotate+?>: load.sp(+0)
	<rotate+?>: dup.x32 sp(0)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: load.z32
	<rotate+?>: dup.x128 sp(1)
	<rotate+?>: dup.x128 sp(5)
	<rotate+?>: dp3.v4f
	<rotate+?>: load.ref <?> ;Math.sqrt(x: float32): float32
	<rotate+?>: call
	<rotate+?>: inc.sp(-4)
	<rotate+?>: mov.x32 sp(4, 0)
	<rotate+?>: inc.sp(-16)
	<rotate+?>: dup.x32 sp(0)
	<rotate+?>: dup.x32 sp(1)
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: mov.x128 sp(1, 0)
	<rotate+?>: inc.sp(-4)
	<rotate+?>: div.v4f
	<rotate+?>: mov.x128 sp(5, 0)
	<rotate+?>: inc.sp(-20)
	<rotate+?>: dup.x32 sp(30)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: store.i128
	cmplGfx/lib/camera.ci:81: (108 bytes): camera.up := cross(camera.forward, camera.right);
	<rotate+?>: dup.x32 sp(26)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: dup.x32 sp(27)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.f32 1.000000
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: inc.i32(+4)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+4)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: sub.f32
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+8)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: inc.i32(+8)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: sub.f32
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: inc.i32(+4)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: inc.i32(+8)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: inc.i32(+8)
	<rotate+?>: load.i32
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: inc.i32(+4)
	<rotate+?>: load.i32
	<rotate+?>: mul.f32
	<rotate+?>: sub.f32
	<rotate+?>: mov.x128 sp(2, 0)
	<rotate+?>: inc.sp(-8)
	<rotate+?>: dup.x32 sp(30)
	<rotate+?>: inc.i32(+48)
	<rotate+?>: store.i128
	cmplGfx/lib/camera.ci:82: (56 bytes): camera.position := dph(matrix, camera.position);
	<rotate+?>: load.sp(+0)
	<rotate+?>: dup.x32 sp(27)
	<rotate+?>: dup.x32 sp(1)
	<rotate+?>: inc.i32(+48)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dph.v4f
	<rotate+?>: dup.x32 sp(2)
	<rotate+?>: inc.i32(+32)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(5)
	<rotate+?>: load.i128
	<rotate+?>: dph.v4f
	<rotate+?>: dup.x32 sp(3)
	<rotate+?>: inc.i32(+16)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(6)
	<rotate+?>: load.i128
	<rotate+?>: dph.v4f
	<rotate+?>: dup.x32 sp(4)
	<rotate+?>: load.i128
	<rotate+?>: dup.x32 sp(7)
	<rotate+?>: load.i128
	<rotate+?>: dph.v4f
	<rotate+?>: mov.x128 sp(2, 0)
	<rotate+?>: inc.sp(-8)
	<rotate+?>: dup.x32 sp(30)
	<rotate+?>: store.i128
	<rotate+?>: inc.sp(-64)
	<rotate+?>: ret
.usages:
	cmplGfx/lib/window.ci:311: referenced as `rotate`
	cmplGfx/lib/window.ci:305: referenced as `rotate`
	cmplGfx/lib/window.ci:299: referenced as `rotate`
	cmplGfx/lib/window.ci:293: referenced as `rotate`
	cmplGfx/lib/window.ci:228: referenced as `rotate`
	cmplGfx/lib/window.ci:227: referenced as `rotate`
	cmplGfx/lib/window.ci:221: referenced as `rotate`
	cmplGfx/lib/window.ci:220: referenced as `rotate`
}
Window: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Window'
.file: 'cmplGfx/lib/window.ci:2'
.field timeoutMax: int32 (size: 0, cast: static const val)
.field timeoutFps: function (size: 0, cast: static inline)
.field show: function (size: 43, cast: static function)
.field show: function (size: 83, cast: static function)
.field show: function (size: 37, cast: static function)
.field show: function (size: 17, cast: static function)
.field show: function (size: 17, cast: static function)
.field show: function (size: 171, cast: static function)
.field show: function (size: 18, cast: static function)
.field show: function (size: 177, cast: static function)
.field KEY_PRESS: int64 (size: 0, cast: static const i64)
.field KEY_RELEASE: int64 (size: 0, cast: static const i64)
.field MOUSE_WHEEL: int64 (size: 0, cast: static const i64)
.field MOUSE_PRESS: int64 (size: 0, cast: static const i64)
.field MOUSE_MOTION: int64 (size: 0, cast: static const i64)
.field MOUSE_RELEASE: int64 (size: 0, cast: static const i64)
.field FINGER_PRESS: int64 (size: 0, cast: static const i64)
.field FINGER_MOTION: int64 (size: 0, cast: static const i64)
.field FINGER_RELEASE: int64 (size: 0, cast: static const i64)
.field EVENT_TIMEOUT: int64 (size: 0, cast: static const i64)
.field WINDOW_INIT: int64 (size: 0, cast: static const i64)
.field WINDOW_CLOSE: int64 (size: 0, cast: static const i64)
.field WINDOW_ENTER: int64 (size: 0, cast: static const i64)
.field WINDOW_LEAVE: int64 (size: 0, cast: static const i64)
.field KEY_CODE_ESC: int64 (size: 0, cast: static const i64)
.field KEY_CODE_BACK: int64 (size: 0, cast: static const i64)
.field KEY_CODE_TAB: int64 (size: 0, cast: static const i64)
.field KEY_CODE_ENTER: int64 (size: 0, cast: static const i64)
.field KEY_CODE_CAPSLOCK: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PRINT_SCREEN: int64 (size: 0, cast: static const i64)
.field KEY_CODE_SCROLL_LOCK: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PAUSE: int64 (size: 0, cast: static const i64)
.field KEY_CODE_INSERT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_HOME: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PAGE_UP: int64 (size: 0, cast: static const i64)
.field KEY_CODE_DELETE: int64 (size: 0, cast: static const i64)
.field KEY_CODE_END: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PAGE_DOWN: int64 (size: 0, cast: static const i64)
.field KEY_CODE_RIGHT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_LEFT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_DOWN: int64 (size: 0, cast: static const i64)
.field KEY_CODE_UP: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_ALT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_ALT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_GUI: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_GUI: int64 (size: 0, cast: static const i64)
.field KEY_MASK_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_MASK_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_MASK_ALT: int64 (size: 0, cast: static const i64)
.field show: function (size: 0, cast: static const inline)
.field setTitle: function (size: 0, cast: static const inline)
.field quit: function (size: 0, cast: static const inline)
.field font: function (size: 0, cast: static const inline)
.field font: Image (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:942: referenced as `Window`
	cmplGfx/lib/micro.ui.core.ci:1204: referenced as `Window`
	cmplGfx/lib/micro.ui.core.ci:1204: referenced as `Window`
	cmplGfx/lib/micro.ui.core.ci:290: referenced as `Window`
	cmplGfx/lib/micro.ui.core.ci:33: referenced as `Window`
	cmplGfx/lib/window.ci:383: referenced as `Window`
	cmplGfx/lib/window.ci:373: referenced as `Window`
	cmplGfx/lib/window.ci:364: referenced as `Window`
	cmplGfx/lib/window.ci:344: referenced as `Window`
	cmplGfx/lib/window.ci:339: referenced as `Window`
	cmplGfx/lib/window.ci:310: referenced as `Window`
	cmplGfx/lib/window.ci:308: referenced as `Window`
	cmplGfx/lib/window.ci:304: referenced as `Window`
	cmplGfx/lib/window.ci:302: referenced as `Window`
	cmplGfx/lib/window.ci:298: referenced as `Window`
	cmplGfx/lib/window.ci:296: referenced as `Window`
	cmplGfx/lib/window.ci:292: referenced as `Window`
	cmplGfx/lib/window.ci:290: referenced as `Window`
	cmplGfx/lib/window.ci:285: referenced as `Window`
	cmplGfx/lib/window.ci:279: referenced as `Window`
	cmplGfx/lib/window.ci:273: referenced as `Window`
	cmplGfx/lib/window.ci:267: referenced as `Window`
	cmplGfx/lib/window.ci:262: referenced as `Window`
	cmplGfx/lib/window.ci:261: referenced as `Window`
	cmplGfx/lib/window.ci:260: referenced as `Window`
	cmplGfx/lib/window.ci:258: referenced as `Window`
	cmplGfx/lib/window.ci:256: referenced as `Window`
	cmplGfx/lib/window.ci:256: referenced as `Window`
	cmplGfx/lib/window.ci:250: referenced as `Window`
	cmplGfx/lib/window.ci:248: referenced as `Window`
	cmplGfx/lib/window.ci:245: referenced as `Window`
	cmplGfx/lib/window.ci:245: referenced as `Window`
	cmplGfx/lib/window.ci:217: referenced as `Window`
	cmplGfx/lib/window.ci:212: referenced as `Window`
	cmplGfx/lib/window.ci:212: referenced as `Window`
	cmplGfx/lib/window.ci:154: referenced as `Window`
	cmplGfx/lib/window.ci:143: referenced as `Window`
	cmplGfx/lib/window.ci:129: referenced as `Window`
	cmplGfx/lib/window.ci:113: referenced as `Window`
	cmplGfx/lib/window.ci:111: referenced as `Window`
	cmplGfx/lib/window.ci:110: referenced as `Window`
	cmplGfx/lib/window.ci:103: referenced as `Window`
	cmplGfx/lib/window.ci:101: referenced as `Window`
	cmplGfx/lib/window.ci:100: referenced as `Window`
	cmplGfx/lib/window.ci:98: referenced as `Window`
	cmplGfx/lib/window.ci:96: referenced as `Window`
	cmplGfx/lib/window.ci:96: referenced as `Window`
	cmplGfx/lib/window.ci:79: referenced as `Window`
	cmplGfx/lib/window.ci:61: referenced as `Window`
	cmplGfx/lib/window.ci:60: referenced as `Window`
	cmplGfx/lib/window.ci:50: referenced as `Window`
	cmplGfx/lib/window.ci:35: referenced as `Window`
	cmplGfx/lib/window.ci:33: referenced as `Window`
	cmplGfx/lib/window.ci:33: referenced as `Window`
	cmplGfx/lib/window.ci:31: referenced as `Window`
	cmplGfx/lib/window.ci:29: referenced as `Window`
	cmplGfx/lib/window.ci:29: referenced as `Window`
	cmplGfx/lib/window.ci:16: referenced as `Window`
	cmplGfx/lib/window.ci:11: referenced as `Window`
}
Window.timeoutMax: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'timeoutMax'
.file: 'cmplGfx/lib/window.ci:3'
.owner: Window
.doc: 'timeoutMax'
.value: 2147483647
.usages:
	cmplGfx/lib/micro.ui.ci:1320: referenced as `timeoutMax`
	cmplGfx/lib/micro.ui.ci:1277: referenced as `timeoutMax`
	cmplGfx/lib/micro.ui.ci:1273: referenced as `timeoutMax`
	cmplGfx/lib/micro.ui.ci:1271: referenced as `timeoutMax`
	cmplGfx/lib/window.ci:373: referenced as `timeoutMax`
	cmplGfx/lib/window.ci:248: referenced as `timeoutMax`
	cmplGfx/lib/window.ci:111: referenced as `timeoutMax`
	cmplGfx/lib/window.ci:50: referenced as `timeoutMax`
}
Window.timeoutFps(fps: float64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'timeoutFps'
.file: 'cmplGfx/lib/window.ci:6'
.owner: Window
.param .result: int64 (size: 8, cast: i64)
.param fps: float64 (size: 8, cast: f64)
.doc: 'calculate the timeout based on the given fps'
.value: int64((1000) / fps)
.usages:
}
Window.show(image: Image, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void: function {
.kind: static function
.base: `function`
.size: 43
.name: 'show'
.file: 'cmplGfx/lib/window.ci:9'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.param onEvent: function (size: 4, cast: variable(ref))
.doc: 'Show the given `image` in a window and delegate the events to the `onEvent` callback'
.value: {
	if ((onEvent) == null) {
		return .result := Window.show(image, null, null);
	}
	static delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		return .result := onEvent(action, button, ex, ey);
	};
	Window.show(image, onEvent, delegate);
}
.instructions: (43 bytes)
	cmplGfx/lib/window.ci:10: (29 bytes): if ((onEvent) == null)
	<show>  : dup.x32 sp(1)
	<show+?>: load.ref <?> ;null
	<show+?>: ceq.i32
	<show+?>: jz +21
	cmplGfx/lib/window.ci:11: (17 bytes): return .result := Window.show(image, null, null);
	<show+?>: dup.x64 sp(2)
	<show+?>: load.ref <?> ;null
	<show+?>: load.ref <?> ;null
	<show+?>: nfc(128) ;Window.show(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
	cmplGfx/lib/window.ci:16: (13 bytes): Window.show(image, onEvent, delegate);
	<show+?>: dup.x64 sp(2)
	<show+?>: dup.x32 sp(3)
	<show+?>: load.ref <?> ;Window.show.delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(128) ;Window.show(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: ret
.usages:
}
Window.show(width: int32, height: int32, image0: Image, image1: Image, image2: Image): void: function {
.kind: static function
.base: `function`
.size: 83
.name: 'show'
.file: 'cmplGfx/lib/window.ci:20'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param image0: Image (size: 8, cast: variable(val))
.param image1: Image (size: 8, cast: variable(val))
.param image2: Image (size: 8, cast: variable(val))
.doc: 'Show the images in a window clicking on the window will select one of them'
.value: {
	static const Data: struct {
		offs: Image;
		image0: Image;
		image1: Image;
		image2: Image;
	};
	static onEvent(const data: Data, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
			return .result := Window.quit();
		}
		if ((action) == Window.MOUSE_PRESS || (action) == Window.MOUSE_RELEASE) {
			show: Image := data.image0;
			if ((action) == Window.MOUSE_RELEASE) {
				show := data.image0;
			}
			else if (button == 1) {
				show := data.image1;
			}
			else {
				show := data.image2;
			}
			if (Image.width(data.offs) != Image.width(show) || Image.height(data.offs) != Image.height(show)) {
				transform(data.offs, null, show, null, 1, null);
			}
			else {
				copy(data.offs, 0, 0, show, null);
			}
		}
		return .result := Window.timeoutMax;
	};
	offs: Image := Image(width, height, Image.depth(image0));
	data: Data := {
		data.offs := offs;
		data.image0 := image0;
		data.image1 := image1;
		data.image2 := image2;
	};
	onEvent(data, Window.MOUSE_RELEASE, 0, 0, 0);
	Window.show(offs, data, onEvent);
	Image.destroy(offs);
}
.instructions: (83 bytes)
	cmplGfx/lib/window.ci:53: (14 bytes): offs: Image := Image(width, height, Image.depth(image0))
	<show>  : dup.x32 sp(8)
	<show+?>: dup.x32 sp(8)
	<show+?>: dup.x64 sp(7)
	<show+?>: nfc(103) ;Image.depth(image: Image): int32
	<show+?>: nfc(89) ;Image.create(width: int32, height: int32, depth: int32): Image
	cmplGfx/lib/window.ci:54: (16 bytes): data: Data := {...}
	<show+?>: inc.sp(+32)
	cmplGfx/lib/window.ci:55: (3 bytes): data.offs := offs;
	<show+?>: mov.x64 sp(0, 8)
	cmplGfx/lib/window.ci:56: (3 bytes): data.image0 := image0;
	<show+?>: mov.x64 sp(2, 15)
	cmplGfx/lib/window.ci:57: (3 bytes): data.image1 := image1;
	<show+?>: mov.x64 sp(4, 13)
	cmplGfx/lib/window.ci:58: (3 bytes): data.image2 := image2;
	<show+?>: mov.x64 sp(6, 11)
	cmplGfx/lib/window.ci:60: (27 bytes): onEvent(data, Window.MOUSE_RELEASE, 0, 0, 0);
	<show+?>: load.z32
	<show+?>: load.sp(+4)
	<show+?>: load.c32 6
	<show+?>: load.z32
	<show+?>: load.z32
	<show+?>: load.z32
	<show+?>: load.ref <?> ;Window.show.onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: call
	<show+?>: inc.sp(-20)
	<show+?>: inc.sp(-4)
	cmplGfx/lib/window.ci:61: (15 bytes): Window.show(offs, data, onEvent);
	<show+?>: dup.x64 sp(8)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;Window.show.onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(128) ;Window.show(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	cmplGfx/lib/window.ci:62: (6 bytes): Image.destroy(offs);
	<show+?>: dup.x64 sp(8)
	<show+?>: nfc(93) ;Image.destroy(image: Image): void
	<show+?>: inc.sp(-40)
	<show+?>: ret
.usages:
	cmplGfx/lib/window.ci:69: referenced as `show`
}
Window.show(image0: Image, image1: Image, image2: Image): void: function {
.kind: static function
.base: `function`
.size: 37
.name: 'show'
.file: 'cmplGfx/lib/window.ci:66'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param image0: Image (size: 8, cast: variable(val))
.param image1: Image (size: 8, cast: variable(val))
.param image2: Image (size: 8, cast: variable(val))
.doc: 'Show the images in a window clicking on the window will select one of them'
.value: {
	width: int32 := Image.width(image0);
	height: int32 := Image.height(image0);
	return .result := show(width, height, image0, image1, image1);
}
.instructions: (37 bytes)
	cmplGfx/lib/window.ci:67: (6 bytes): width: int32 := Image.width(image0)
	<show>  : dup.x64 sp(5)
	<show+?>: nfc(101) ;Image.width(image: Image): int32
	cmplGfx/lib/window.ci:68: (6 bytes): height: int32 := Image.height(image0)
	<show+?>: dup.x64 sp(6)
	<show+?>: nfc(102) ;Image.height(image: Image): int32
	cmplGfx/lib/window.ci:69: (25 bytes): return .result := show(width, height, image0, image1, image1);
	<show+?>: dup.x32 sp(1)
	<show+?>: dup.x32 sp(1)
	<show+?>: dup.x64 sp(9)
	<show+?>: dup.x64 sp(9)
	<show+?>: dup.x64 sp(11)
	<show+?>: load.ref <?> ;Window.show(width: int32, height: int32, image0: Image, image1: Image, image2: Image): void
	<show+?>: call
	<show+?>: inc.sp(-32)
	<show+?>: inc.sp(-8)
	<show+?>: ret
.usages:
	cmplGfx/lib/window.ci:79: referenced as `show`
	cmplGfx/lib/window.ci:74: referenced as `show`
}
Window.show(image0: Image, image1: Image): void: function {
.kind: static function
.base: `function`
.size: 17
.name: 'show'
.file: 'cmplGfx/lib/window.ci:73'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param image0: Image (size: 8, cast: variable(val))
.param image1: Image (size: 8, cast: variable(val))
.doc: 'Show the images in a window clicking on the window will select one of them'
.value: {
	return .result := show(image0, image1, image1);
}
.instructions: (17 bytes)
	cmplGfx/lib/window.ci:74: (17 bytes): return .result := show(image0, image1, image1);
	<show>  : dup.x64 sp(3)
	<show+?>: dup.x64 sp(3)
	<show+?>: dup.x64 sp(5)
	<show+?>: load.ref <?> ;Window.show(image0: Image, image1: Image, image2: Image): void
	<show+?>: call
	<show+?>: inc.sp(-24)
	<show+?>: ret
.usages:
}
Window.show(image: Image): void: function {
.kind: static function
.base: `function`
.size: 17
.name: 'show'
.file: 'cmplGfx/lib/window.ci:78'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param image: Image (size: 8, cast: variable(val))
.doc: 'Show the image in a window'
.value: {
	Window.show(image, image, image);
}
.instructions: (17 bytes)
	cmplGfx/lib/window.ci:79: (16 bytes): Window.show(image, image, image);
	<show>  : dup.x64 sp(1)
	<show+?>: dup.x64 sp(3)
	<show+?>: dup.x64 sp(5)
	<show+?>: load.ref <?> ;Window.show(image0: Image, image1: Image, image2: Image): void
	<show+?>: call
	<show+?>: inc.sp(-24)
	<show+?>: ret
.usages:
	cmplGfx/lib/window.ci:143: referenced as `show`
}
Window.show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void: function {
.kind: static function
.base: `function`
.size: 171
.name: 'show'
.file: 'cmplGfx/lib/window.ci:83'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param animationResolution: int32 (size: 4, cast: variable(i32))
.param eval: function (size: 4, cast: variable(ref))
.doc: 'Show or animate the the procedural image generated by the `eval` function'
.value: {
	static const start: int64 := System.millis();
	static const Data: struct {
		lerp: bool := true;
		const offs: Image;
		const thumb: Image;
		const aspect: float32;
		fpsCount: int32 := 0;
		fpsTime: float32 := 0;
		const eval(in: vec4f): vec4f;
	};
	static onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
			return .result := Window.quit();
		}
		if ((action) == Window.WINDOW_CLOSE) {
			return .result := Window.quit();
		}
		if ((action) == Window.KEY_RELEASE) {
			if (button == (' ')) {
				text: char[256] := {
				};
				now: int64 := System.millis();
				time: float32 := ((now - start)) / 1000.000000;
				eval(data.offs, null, data.aspect, time, data.eval);
				append(text, append(text, 0, "Millis: "), System.millis() - now);
				Window.setTitle(text);
				return .result := Window.timeoutMax;
			}
			if ((button) == Window.KEY_CODE_TAB) {
				data.lerp := !data.lerp;
			}
			if (button == ('S')) {
				trace("dumping screen");
				Image.saveBmp(data.offs, "out/offs.bmp", 0);
				Image.saveBmp(data.thumb, "out/thumb.bmp", 0);
			}
		}
		time: float32 := ((System.millis() - start)) / 1000.000000;
		eval(data.thumb, null, data.aspect, time, data.eval);
		resize(data.offs, null, data.thumb, null, int32(data.lerp));
		if (time > data.fpsTime) {
			text: char[256] := {
			};
			append(text, append(text, 0, "Fps: "), data.fpsCount);
			Window.setTitle(text);
			data.fpsTime := time + (1);
			data.fpsCount := 0;
		}
		data.fpsCount := data.fpsCount + 1;
		return .result := 0;
	};
	if (animationResolution == 0) {
		aspect: float32 := (width) / float32(height);
		image: Image := Image(width, height, 32);
		eval(image, null, aspect, 0.000000, eval);
		Window.show(image);
		Image.destroy(image);
		return;
	}
	data: Data := {
		data.offs := Image(width, height, 32);
		data.thumb := Image(animationResolution, animationResolution, 32);
		data.aspect := (width) / float32(height);
		data.eval := eval;
		data.lerp := true;
		data.fpsCount := 0;
		data.fpsTime := (0);
	};
	Window.show(data.offs, data, onEvent);
	Image.destroy(data.thumb);
	Image.destroy(data.offs);
}
.instructions: (171 bytes)
	cmplGfx/lib/window.ci:139: (77 bytes): if (animationResolution == 0)
	<show>  : dup.x32 sp(2)
	<show+?>: load.z32
	<show+?>: ceq.i32
	<show+?>: jz +73
	cmplGfx/lib/window.ci:140: (7 bytes): aspect: float32 := (width) / float32(height)
	<show+?>: dup.x32 sp(4)
	<show+?>: i32.2f32
	<show+?>: dup.x32 sp(4)
	<show+?>: i32.2f32
	<show+?>: div.f32
	cmplGfx/lib/window.ci:141: (13 bytes): image: Image := Image(width, height, 32)
	<show+?>: dup.x32 sp(5)
	<show+?>: dup.x32 sp(5)
	<show+?>: load.c32 32
	<show+?>: nfc(89) ;Image.create(width: int32, height: int32, depth: int32): Image
	cmplGfx/lib/window.ci:142: (22 bytes): eval(image, null, aspect, 0.000000, eval);
	<show+?>: dup.x64 sp(0)
	<show+?>: load.ref <?> ;null
	<show+?>: dup.x32 sp(5)
	<show+?>: load.z32
	<show+?>: dup.x32 sp(9)
	<show+?>: load.ref <?> ;eval(image: Image, roi: Rect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void
	<show+?>: call
	<show+?>: inc.sp(-24)
	cmplGfx/lib/window.ci:143: (12 bytes): Window.show(image);
	<show+?>: dup.x64 sp(0)
	<show+?>: load.ref <?> ;Window.show(image: Image): void
	<show+?>: call
	<show+?>: inc.sp(-8)
	cmplGfx/lib/window.ci:144: (6 bytes): Image.destroy(image);
	<show+?>: dup.x64 sp(0)
	<show+?>: nfc(93) ;Image.destroy(image: Image): void
	cmplGfx/lib/window.ci:145: (5 bytes): return;
	<show+?>: inc.sp(-12)
	<show+?>: ret
	<show+?>: inc.sp(-12)
	cmplGfx/lib/window.ci:148: (62 bytes): data: Data := {...}
	<show+?>: inc.sp(+40)
	cmplGfx/lib/window.ci:149: (15 bytes): data.offs := Image(width, height, 32);
	<show+?>: dup.x32 sp(14)
	<show+?>: dup.x32 sp(14)
	<show+?>: load.c32 32
	<show+?>: nfc(89) ;Image.create(width: int32, height: int32, depth: int32): Image
	<show+?>: set.x64 sp(4)
	cmplGfx/lib/window.ci:150: (15 bytes): data.thumb := Image(animationResolution, animationResolution, 32);
	<show+?>: dup.x32 sp(12)
	<show+?>: dup.x32 sp(13)
	<show+?>: load.c32 32
	<show+?>: nfc(89) ;Image.create(width: int32, height: int32, depth: int32): Image
	<show+?>: set.x64 sp(6)
	cmplGfx/lib/window.ci:151: (9 bytes): data.aspect := (width) / float32(height);
	<show+?>: dup.x32 sp(14)
	<show+?>: i32.2f32
	<show+?>: dup.x32 sp(14)
	<show+?>: i32.2f32
	<show+?>: div.f32
	<show+?>: set.x32 sp(7)
	cmplGfx/lib/window.ci:152: (3 bytes): data.eval := eval;
	<show+?>: mov.x32 sp(9, 11)
	:: (10 bytes): data.lerp := true;
	<show+?>: load.c32 1
	<show+?>: load.sp(+4)
	<show+?>: store.i8
	:: (3 bytes): data.fpsCount := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(8)
	:: (3 bytes): data.fpsTime := (0);
	<show+?>: load.z32
	<show+?>: set.x32 sp(9)
	cmplGfx/lib/window.ci:154: (15 bytes): Window.show(data.offs, data, onEvent);
	<show+?>: dup.x64 sp(2)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;Window.show.onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(128) ;Window.show(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	cmplGfx/lib/window.ci:155: (6 bytes): Image.destroy(data.thumb);
	<show+?>: dup.x64 sp(4)
	<show+?>: nfc(93) ;Image.destroy(image: Image): void
	cmplGfx/lib/window.ci:156: (6 bytes): Image.destroy(data.offs);
	<show+?>: dup.x64 sp(2)
	<show+?>: nfc(93) ;Image.destroy(image: Image): void
	<show+?>: inc.sp(-40)
	<show+?>: ret
.usages:
	cmplGfx/lib/window.ci:161: referenced as `show`
}
Window.show(width: int32, height: int32, eval(in: vec4f): vec4f): void: function {
.kind: static function
.base: `function`
.size: 18
.name: 'show'
.file: 'cmplGfx/lib/window.ci:160'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param eval: function (size: 4, cast: variable(ref))
.doc: 'Show the the procedural image generated by the `eval` function'
.value: {
	return .result := show(width, height, 0, eval);
}
.instructions: (18 bytes)
	cmplGfx/lib/window.ci:161: (18 bytes): return .result := show(width, height, 0, eval);
	<show>  : dup.x32 sp(3)
	<show+?>: dup.x32 sp(3)
	<show+?>: load.z32
	<show+?>: dup.x32 sp(4)
	<show+?>: load.ref <?> ;Window.show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void
	<show+?>: call
	<show+?>: inc.sp(-16)
	<show+?>: ret
.usages:
}
Window.show(w: int32, h: int32, fovy: float32, mesh: Mesh): void: function {
.kind: static function
.base: `function`
.size: 177
.name: 'show'
.file: 'cmplGfx/lib/window.ci:165'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param w: int32 (size: 4, cast: variable(i32))
.param h: int32 (size: 4, cast: variable(i32))
.param fovy: float32 (size: 4, cast: variable(f32))
.param mesh: Mesh (size: 4, cast: variable(ref))
.doc: 'Show the mesh in a window'
.value: {
	static const Data: struct {
		fpsCount: int32 := 0;
		fpsShow: int32 := 0;
		fpsTime: int64 := 0;
		mode: int32;
		offs: Image;
		proj: mat4f;
		cam: Camera;
		mesh: Mesh;
		static updateCamera(const this: Data): void := {
			camera: Camera := this.cam;
			camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
		};
	};
	static nextInc(x: int32, mask: int32): int32 := {
		next: int32 := x & mask;
		next := next + (mask & -mask);
		next := next & mask;
		return .result := next | (x & ~mask);
	};
	static nextBit(x: int32, mask: int32): int32 := {
		next: int32 := x & mask;
		if (next == 0) {
			next := mask & -mask;
		}
		else {
			next := (next + next) & mask;
		}
		return .result := next | (x & ~mask);
	};
	static onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32 := {
		static ox: int32 := 0;
		static oy: int32 := 0;
		static const slow: float32 := (1) / 100.000000;
		static const fast: float32 := (5) / 100.000000;
		if ((action) == Window.MOUSE_MOTION || (action) == Window.FINGER_MOTION) {
			camera: Camera := data.cam;
			dx: int32 := ex - ox;
			dy: int32 := ey - oy;
			if (button == 1 || (action) == Window.FINGER_MOTION) {
				orbit: vec4f := vec4f(0, 0, 0);
				Camera.rotate(camera, orbit, camera.up, (dx) * slow);
				Camera.rotate(camera, orbit, camera.right, (dy) * slow);
				Data.updateCamera(data);
			}
			else if (button == 2) {
				orbit: vec4f := camera.position;
				Camera.rotate(camera, orbit, camera.up, (-dx) * slow);
				Camera.rotate(camera, orbit, camera.right, (-dy) * slow);
				Data.updateCamera(data);
			}
			else if (button == 3) {
				Camera.move(camera, camera.forward, (dy) * slow);
				Data.updateCamera(data);
			}
			else if (button == 4) {
				Camera.move(camera, camera.right, (-dx) * slow);
				Camera.move(camera, camera.up, (dy) * slow);
				Data.updateCamera(data);
			}
			ox := ex;
			oy := ey;
		}
		else if ((action) == Window.MOUSE_PRESS || (action) == Window.FINGER_PRESS) {
			ox := ex;
			oy := ey;
			return .result := Window.timeoutMax;
		}
		else if ((action) == Window.MOUSE_WHEEL) {
			camera: Camera := data.cam;
			Camera.move(camera, camera.forward, (ey) * fast);
			Data.updateCamera(data);
		}
		else if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
			return .result := Window.quit();
		}
		else if ((action) == Window.KEY_PRESS) {
			if ((button) == Window.KEY_CODE_ENTER) {
				return .result := onEvent(&data, Window.WINDOW_INIT, button, ex, ey);
			}
			else if (button == ('w')) {
				camera: Camera := data.cam;
				shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
				Camera.move(camera, camera.forward, +(shift ? fast : slow));
				Data.updateCamera(data);
			}
			else if (button == ('s')) {
				camera: Camera := data.cam;
				shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
				Camera.move(camera, camera.forward, -(shift ? fast : slow));
				Data.updateCamera(data);
			}
			else if (button == ('a')) {
				camera: Camera := data.cam;
				shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
				Camera.move(camera, camera.right, -(shift ? fast : slow));
				Data.updateCamera(data);
			}
			else if (button == ('d')) {
				camera: Camera := data.cam;
				shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
				Camera.move(camera, camera.right, +(shift ? fast : slow));
				Data.updateCamera(data);
			}
			else if ((button) == Window.KEY_CODE_UP) {
				camera: Camera := data.cam;
				shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
				Camera.rotate(camera, camera.position, camera.right, -(shift ? fast : slow));
				Data.updateCamera(data);
			}
			else if ((button) == Window.KEY_CODE_DOWN) {
				camera: Camera := data.cam;
				shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
				Camera.rotate(camera, camera.position, camera.right, +(shift ? fast : slow));
				Data.updateCamera(data);
			}
			else if ((button) == Window.KEY_CODE_LEFT) {
				camera: Camera := data.cam;
				shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
				Camera.rotate(camera, camera.position, camera.up, -(shift ? fast : slow));
				Data.updateCamera(data);
			}
			else if ((button) == Window.KEY_CODE_RIGHT) {
				camera: Camera := data.cam;
				shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
				Camera.rotate(camera, camera.position, camera.up, +(shift ? fast : slow));
				Data.updateCamera(data);
			}
			else if (button == ('l')) {
				data.mode := ((data.mode) ^ Mesh.useLights);
			}
			else if (button == ('b')) {
				data.mode := ((data.mode) ^ Mesh.drawBounds);
			}
			else if (button == ('0')) {
				lights.enable(0, !lights.enabled(0));
			}
			else if (button == ('1')) {
				lights.enable(1, !lights.enabled(1));
			}
			else if (button == ('2')) {
				lights.enable(2, !lights.enabled(2));
			}
			else if (button == ('3')) {
				lights.enable(3, !lights.enabled(3));
			}
			else if (button == ('t')) {
				data.mode := ((data.mode) ^ Mesh.useTexture);
			}
			else if (button == ('/')) {
				data.mode := nextInc(data.mode, Mesh.cullMode);
			}
			else if ((button) == Window.KEY_CODE_TAB) {
				data.mode := nextBit(data.mode, Mesh.drawMode);
			}
		}
		else if ((action) == Window.WINDOW_INIT) {
			camera: Camera := data.cam;
			eye: vec4f := {
				eye.x := (0);
				eye.y := (0);
				eye.z := (2);
				eye.w := (1);
			};
			at: vec4f := {
				at.x := (0);
				at.y := (0);
				at.z := (0);
				at.w := (1);
			};
			up: vec4f := {
				up.x := (0);
				up.y := (1);
				up.z := (0);
				up.w := (1);
			};
			data.cam := Camera.lookAt(eye, at, up);
			Data.updateCamera(data);
		}
		rendered: int32 := Image.drawMesh(data.offs, data.mesh, data.mode);
		text: char[256] := {
		};
		pos: int32 := append(text, 0, "Vertices: ");
		pos := append(text, pos, data.mesh.vertices);
		pos := append(text, pos, ", Triangles: ");
		pos := append(text, pos, data.mesh.triangles);
		pos := append(text, pos, "/");
		pos := append(text, pos, rendered);
		pos := append(text, pos, ", Fps: ");
		pos := append(text, pos, data.fpsShow);
		Window.setTitle(text);
		time: int64 := System.millis();
		if (time > data.fpsTime) {
			data.fpsTime := time + (1000);
			data.fpsShow := data.fpsCount;
			data.fpsCount := 0;
		}
		data.fpsCount := data.fpsCount + 1;
		return .result := Window.timeoutMax;
	};
	data: Data := {
		data.mode := (Mesh.useLights | Mesh.cullBack | Mesh.drawFill);
		data.offs := Image.create3d(w, h);
		data.proj := Camera.projection(fovy, (w) / float32(h), 1, 100);
		data.cam.position := vec4f(0, 0, 0, 1);
		data.cam.forward := vec4f(0, 0, 0, 1);
		data.cam.right := vec4f(0, 0, 0, 1);
		data.cam.up := vec4f(0, 1, 0, 1);
		data.mesh := mesh;
		data.fpsCount := 0;
		data.fpsShow := 0;
		data.fpsTime := (0);
	};
	Window.show(data.offs, data, onEvent);
	Image.destroy(data.offs);
}
.instructions: (177 bytes)
	cmplGfx/lib/window.ci:376: (151 bytes): data: Data := {...}
	<show>  : inc.sp(+168)
	cmplGfx/lib/window.ci:377: (32 bytes): data.mode := (Mesh.useLights | Mesh.cullBack | Mesh.drawFill);
	<show+?>: load.c64 128
	<show+?>: load.c64 16
	<show+?>: or.b64
	<show+?>: load.c64 1
	<show+?>: or.b64
	<show+?>: i64.2i32
	<show+?>: set.x32 sp(5)
	cmplGfx/lib/window.ci:378: (10 bytes): data.offs := Image.create3d(w, h);
	<show+?>: dup.x32 sp(46)
	<show+?>: dup.x32 sp(46)
	<show+?>: nfc(90) ;Image.create3d(width: int32, height: int32): Image
	<show+?>: set.x64 sp(8)
	cmplGfx/lib/window.ci:379: (49 bytes): data.proj := Camera.projection(fovy, (w) / float32(h), 1, 100);
	<show+?>: inc.sp(+64)
	<show+?>: dup.x32 sp(60)
	<show+?>: dup.x32 sp(63)
	<show+?>: i32.2f32
	<show+?>: dup.x32 sp(63)
	<show+?>: i32.2f32
	<show+?>: div.f32
	<show+?>: load.f32 1.000000
	<show+?>: load.f32 100.000000
	<show+?>: load.ref <?> ;Camera.projection(fov: float32, asp: float32, n: float32, f: float32): mat4f
	<show+?>: call
	<show+?>: inc.sp(-16)
	<show+?>: load.sp(+96)
	<show+?>: load.sp(+4)
	<show+?>: copy.mem 64
	<show+?>: inc.sp(-64)
	:: (10 bytes): data.cam.position := vec4f(0, 0, 0, 1);
	<show+?>: load.f32 1.000000
	<show+?>: load.z32
	<show+?>: load.z32
	<show+?>: load.z32
	<show+?>: set.x128 sp(28)
	:: (10 bytes): data.cam.forward := vec4f(0, 0, 0, 1);
	<show+?>: load.f32 1.000000
	<show+?>: load.z32
	<show+?>: load.z32
	<show+?>: load.z32
	<show+?>: set.x128 sp(32)
	:: (10 bytes): data.cam.right := vec4f(0, 0, 0, 1);
	<show+?>: load.f32 1.000000
	<show+?>: load.z32
	<show+?>: load.z32
	<show+?>: load.z32
	<show+?>: set.x128 sp(36)
	:: (14 bytes): data.cam.up := vec4f(0, 1, 0, 1);
	<show+?>: load.f32 1.000000
	<show+?>: load.z32
	<show+?>: load.f32 1.000000
	<show+?>: load.z32
	<show+?>: set.x128 sp(40)
	cmplGfx/lib/window.ci:381: (3 bytes): data.mesh := mesh;
	<show+?>: mov.x32 sp(40, 43)
	:: (3 bytes): data.fpsCount := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(1)
	:: (3 bytes): data.fpsShow := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(2)
	:: (3 bytes): data.fpsTime := (0);
	<show+?>: load.z64
	<show+?>: set.x64 sp(4)
	cmplGfx/lib/window.ci:383: (15 bytes): Window.show(data.offs, data, onEvent);
	<show+?>: dup.x64 sp(6)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;Window.show.onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32
	<show+?>: nfc(128) ;Window.show(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	cmplGfx/lib/window.ci:384: (6 bytes): Image.destroy(data.offs);
	<show+?>: dup.x64 sp(6)
	<show+?>: nfc(93) ;Image.destroy(image: Image): void
	<show+?>: inc.sp(-168)
	<show+?>: ret
.usages:
}
Style: typename {
.kind: static const typename(val)
.base: `typename`
.size: 56
.name: 'Style'
.file: 'cmplGfx/lib/micro.ui.core.ci:2'
.field dark: argb (size: 4, cast: static const variable(val))
.field light: argb (size: 4, cast: static const variable(val))
.field blue: argb (size: 4, cast: static const variable(val))
.field green: argb (size: 4, cast: static const variable(val))
.field gray: argb (size: 4, cast: static const variable(val))
.field orange: argb (size: 4, cast: static const variable(val))
.field red: argb (size: 4, cast: static const variable(val))
.field magenta: argb (size: 4, cast: static const variable(val))
.field cyan: argb (size: 4, cast: static const variable(val))
.field theme: argb (size: 4, cast: static const variable(val))
.field accent: argb (size: 4, cast: static const variable(val))
.field align: int32 (size: 4, cast: const variable(i32))
.field padding: int32 (size: 4, cast: const variable(i32))
.field font: Image (size: 8, cast: const variable(val))
.field format: FormatFlags (size: 16, cast: const variable(val))
.field backgroundColor: uint32 (size: 4, cast: variable(u32))
.field hoveredColor: uint32 (size: 4, cast: variable(u32))
.field focusedColor: uint32 (size: 4, cast: variable(u32))
.field valueColor: uint32 (size: 4, cast: variable(u32))
.field textColor: uint32 (size: 4, cast: variable(u32))
.field top: int32 (size: 0, cast: static const val)
.field left: int32 (size: 0, cast: static const val)
.field right: int32 (size: 0, cast: static const val)
.field bottom: int32 (size: 0, cast: static const val)
.field center: int32 (size: 0, cast: static const val)
.field topLeft: int32 (size: 0, cast: static const val)
.field topRight: int32 (size: 0, cast: static const val)
.field bottomLeft: int32 (size: 0, cast: static const val)
.field bottomRight: int32 (size: 0, cast: static const val)
.field vertical: int32 (size: 0, cast: static const val)
.field verticalTop: int32 (size: 0, cast: static const val)
.field verticalBottom: int32 (size: 0, cast: static const val)
.field horizontal: int32 (size: 0, cast: static const val)
.field horizontalLeft: int32 (size: 0, cast: static const val)
.field horizontalRight: int32 (size: 0, cast: static const val)
.field fill: int32 (size: 0, cast: static const val)
.field hovered: int32 (size: 0, cast: static const val)
.field pressed: int32 (size: 0, cast: static const val)
.field focused: int32 (size: 0, cast: static const val)
.field align: function (size: 389, cast: static function)
.field measure: function (size: 35, cast: static function)
.field align: function (size: 112, cast: static function)
.field align: function (size: 22, cast: static function)
.field setColor: function (size: 542, cast: static function)
.field vertical: function (size: 0, cast: static inline)
.field horizontal: function (size: 0, cast: static inline)
.doc: 'Style used to layout and draw text and views.'
.usages:
	cmplGfx/lib/micro.ui.ci:1121: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:1008: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:1002: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:1001: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:994: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:983: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:969: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:963: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:925: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:920: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:917: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:912: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:909: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:863: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:848: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:740: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:719: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:665: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:637: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:577: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:562: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:302: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:284: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:151: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:151: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:143: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:124: referenced as `Style`
	cmplGfx/lib/micro.ui.ci:9: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1206: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1157: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1145: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1077: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1072: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1067: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1047: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1044: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1041: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:1021: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:965: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:962: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:960: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:958: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:956: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:880: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:877: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:875: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:873: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:871: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:743: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:739: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:724: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:706: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:706: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:695: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:687: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:680: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:678: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:669: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:667: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:504: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:498: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:491: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:447: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:439: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:431: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:373: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:364: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:359: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:352: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:349: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:348: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:244: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:139: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:134: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:119: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:113: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:96: referenced as `Style`
	cmplGfx/lib/micro.ui.core.ci:81: referenced as `Style`
}
Style.dark: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'dark'
.file: 'cmplGfx/lib/micro.ui.core.ci:4'
.owner: Style
.doc: 'Default dark theme color for background'
.value: argb(1710618)
.usages:
	cmplGfx/lib/micro.ui.core.ci:144: referenced as `dark`
	cmplGfx/lib/micro.ui.core.ci:48: referenced as `dark`
	cmplGfx/lib/micro.ui.core.ci:23: referenced as `dark`
}
Style.light: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'light'
.file: 'cmplGfx/lib/micro.ui.core.ci:6'
.owner: Style
.doc: 'Default light theme color for background'
.value: argb(14342874)
.usages:
	cmplGfx/lib/micro.ui.core.ci:144: referenced as `light`
	cmplGfx/lib/micro.ui.core.ci:48: referenced as `light`
}
Style.blue: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'blue'
.file: 'cmplGfx/lib/micro.ui.core.ci:9'
.owner: Style
.doc: 'Default blue accent color for controls'
.value: argb(33, 149, 246)
.usages:
}
Style.green: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'green'
.file: 'cmplGfx/lib/micro.ui.core.ci:11'
.owner: Style
.doc: 'Default green accent color for controls'
.value: argb(74, 174, 82)
.usages:
}
Style.gray: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'gray'
.file: 'cmplGfx/lib/micro.ui.core.ci:13'
.owner: Style
.doc: 'Default gray accent color for controls'
.value: argb(98, 125, 139)
.usages:
	cmplGfx/lib/micro.ui.core.ci:24: referenced as `gray`
}
Style.orange: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'orange'
.file: 'cmplGfx/lib/micro.ui.core.ci:15'
.owner: Style
.doc: 'Default orange accent color for controls'
.value: argb(255, 153, 0)
.usages:
}
Style.red: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'red'
.file: 'cmplGfx/lib/micro.ui.core.ci:17'
.owner: Style
.doc: 'Default red accent color for controls'
.value: argb(246, 64, 49)
.usages:
}
Style.magenta: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'magenta'
.file: 'cmplGfx/lib/micro.ui.core.ci:19'
.owner: Style
.doc: 'Default magenta accent color for controls'
.value: argb(156, 36, 181)
.usages:
}
Style.cyan: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'cyan'
.file: 'cmplGfx/lib/micro.ui.core.ci:21'
.owner: Style
.doc: 'Default cyan accent color for controls'
.value: argb(0, 149, 139)
.usages:
}
Style.theme: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'theme'
.file: 'cmplGfx/lib/micro.ui.core.ci:23'
.owner: Style
.value: dark
.usages:
	cmplGfx/lib/micro.ui.core.ci:48: referenced as `theme`
	cmplGfx/lib/micro.ui.core.ci:44: referenced as `theme`
	cmplGfx/lib/micro.ui.core.ci:42: referenced as `theme`
	cmplGfx/lib/micro.ui.core.ci:39: referenced as `theme`
}
Style.accent: argb {
.kind: static const variable(val)
.base: `argb`
.size: 4
.name: 'accent'
.file: 'cmplGfx/lib/micro.ui.core.ci:24'
.owner: Style
.value: gray
.usages:
	cmplGfx/lib/micro.ui.core.ci:46: referenced as `accent`
	cmplGfx/lib/micro.ui.core.ci:44: referenced as `accent`
	cmplGfx/lib/micro.ui.core.ci:42: referenced as `accent`
}
Style.align: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'align'
.file: 'cmplGfx/lib/micro.ui.core.ci:27'
.owner: Style
.doc: 'Alignment of text in views'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1002: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:135: referenced as `align`
	internal usages: 1
}
Style.padding: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'padding'
.file: 'cmplGfx/lib/micro.ui.core.ci:30'
.owner: Style
.doc: 'Padding around text in views'
.value: 8
.usages:
	cmplGfx/lib/micro.ui.ci:304: referenced as `padding`
	cmplGfx/lib/micro.ui.ci:170: referenced as `padding`
	cmplGfx/lib/micro.ui.ci:154: referenced as `padding`
	cmplGfx/lib/micro.ui.core.ci:375: referenced as `padding`
	cmplGfx/lib/micro.ui.core.ci:120: referenced as `padding`
	cmplGfx/lib/micro.ui.core.ci:115: referenced as `padding`
	internal usages: 2
}
Style.font: Image {
.kind: const variable(val)
.base: `Image`
.size: 8
.name: 'font'
.file: 'cmplGfx/lib/micro.ui.core.ci:33'
.owner: Style
.doc: 'The font to be used to draw text'
.value: Window.font
.usages:
	cmplGfx/lib/micro.ui.ci:669: referenced as `font`
	cmplGfx/lib/micro.ui.ci:594: referenced as `font`
	cmplGfx/lib/micro.ui.core.ci:378: referenced as `font`
	cmplGfx/lib/micro.ui.core.ci:374: referenced as `font`
	cmplGfx/lib/micro.ui.core.ci:367: referenced as `font`
	cmplGfx/lib/micro.ui.core.ci:121: referenced as `font`
	cmplGfx/lib/micro.ui.core.ci:114: referenced as `font`
	internal usages: 2
}
Style.format: FormatFlags {
.kind: const variable(val)
.base: `FormatFlags`
.size: 16
.name: 'format'
.file: 'cmplGfx/lib/micro.ui.core.ci:36'
.owner: Style
.doc: 'Formatting to be used printing numbers, dates, etc'
.usages:
	cmplGfx/lib/micro.ui.ci:1003: referenced as `format`
	cmplGfx/lib/micro.ui.ci:995: referenced as `format`
	cmplGfx/lib/micro.ui.ci:321: referenced as `format`
	cmplGfx/lib/micro.ui.ci:319: referenced as `format`
	cmplGfx/lib/micro.ui.ci:288: referenced as `format`
	cmplGfx/lib/micro.ui.ci:286: referenced as `format`
}
Style.backgroundColor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'backgroundColor'
.file: 'cmplGfx/lib/micro.ui.core.ci:39'
.owner: Style
.doc: '@public'
.value: uint32(theme)
.usages:
	cmplGfx/lib/micro.ui.ci:972: referenced as `backgroundColor`
	cmplGfx/lib/micro.ui.ci:970: referenced as `backgroundColor`
	cmplGfx/lib/micro.ui.ci:638: referenced as `backgroundColor`
	cmplGfx/lib/micro.ui.core.ci:1225: referenced as `backgroundColor`
	cmplGfx/lib/micro.ui.core.ci:356: referenced as `backgroundColor`
	cmplGfx/lib/micro.ui.core.ci:140: referenced as `backgroundColor`
	internal usages: 2
}
Style.hoveredColor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'hoveredColor'
.file: 'cmplGfx/lib/micro.ui.core.ci:42'
.owner: Style
.doc: '@public'
.value: uint32(mix_rgb8(16, theme, accent))
.usages:
	cmplGfx/lib/micro.ui.ci:638: referenced as `hoveredColor`
	cmplGfx/lib/micro.ui.ci:160: referenced as `hoveredColor`
	cmplGfx/lib/micro.ui.core.ci:353: referenced as `hoveredColor`
	cmplGfx/lib/micro.ui.core.ci:141: referenced as `hoveredColor`
	internal usages: 2
}
Style.focusedColor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'focusedColor'
.file: 'cmplGfx/lib/micro.ui.core.ci:44'
.owner: Style
.doc: '@public'
.value: uint32(mix_rgb8(64, theme, accent))
.usages:
	cmplGfx/lib/micro.ui.ci:667: referenced as `focusedColor`
	cmplGfx/lib/micro.ui.ci:585: referenced as `focusedColor`
	cmplGfx/lib/micro.ui.ci:312: referenced as `focusedColor`
	cmplGfx/lib/micro.ui.ci:155: referenced as `focusedColor`
	cmplGfx/lib/micro.ui.core.ci:350: referenced as `focusedColor`
	cmplGfx/lib/micro.ui.core.ci:142: referenced as `focusedColor`
	internal usages: 2
}
Style.valueColor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'valueColor'
.file: 'cmplGfx/lib/micro.ui.core.ci:46'
.owner: Style
.doc: '@public'
.value: uint32(accent)
.usages:
	cmplGfx/lib/micro.ui.ci:309: referenced as `valueColor`
	cmplGfx/lib/micro.ui.ci:157: referenced as `valueColor`
	cmplGfx/lib/micro.ui.core.ci:374: referenced as `valueColor`
	cmplGfx/lib/micro.ui.core.ci:367: referenced as `valueColor`
	cmplGfx/lib/micro.ui.core.ci:360: referenced as `valueColor`
	cmplGfx/lib/micro.ui.core.ci:143: referenced as `valueColor`
	internal usages: 2
}
Style.textColor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'textColor'
.file: 'cmplGfx/lib/micro.ui.core.ci:48'
.owner: Style
.doc: '@public'
.value: uint32(lum(theme) > 127 ? dark : light)
.usages:
	cmplGfx/lib/micro.ui.ci:669: referenced as `textColor`
	cmplGfx/lib/micro.ui.ci:594: referenced as `textColor`
	cmplGfx/lib/micro.ui.ci:171: referenced as `textColor`
	cmplGfx/lib/micro.ui.core.ci:378: referenced as `textColor`
	cmplGfx/lib/micro.ui.core.ci:144: referenced as `textColor`
	internal usages: 2
}
Style.top: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'top'
.file: 'cmplGfx/lib/micro.ui.core.ci:51'
.owner: Style
.doc: 'top'
.value: 1
.usages:
	cmplGfx/lib/micro.ui.core.ci:103: referenced as `top`
	cmplGfx/lib/micro.ui.core.ci:70: referenced as `top`
	cmplGfx/lib/micro.ui.core.ci:66: referenced as `top`
	cmplGfx/lib/micro.ui.core.ci:63: referenced as `top`
	cmplGfx/lib/micro.ui.core.ci:58: referenced as `top`
	cmplGfx/lib/micro.ui.core.ci:57: referenced as `top`
}
Style.left: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'left'
.file: 'cmplGfx/lib/micro.ui.core.ci:52'
.owner: Style
.doc: 'left'
.value: 2
.usages:
	cmplGfx/lib/micro.ui.ci:1002: referenced as `left`
	cmplGfx/lib/micro.ui.core.ci:88: referenced as `left`
	cmplGfx/lib/micro.ui.core.ci:70: referenced as `left`
	cmplGfx/lib/micro.ui.core.ci:67: referenced as `left`
	cmplGfx/lib/micro.ui.core.ci:62: referenced as `left`
	cmplGfx/lib/micro.ui.core.ci:59: referenced as `left`
	cmplGfx/lib/micro.ui.core.ci:57: referenced as `left`
}
Style.right: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'right'
.file: 'cmplGfx/lib/micro.ui.core.ci:53'
.owner: Style
.doc: 'right'
.value: 4
.usages:
	cmplGfx/lib/micro.ui.ci:151: referenced as `right`
	cmplGfx/lib/micro.ui.core.ci:373: referenced as `right`
	cmplGfx/lib/micro.ui.core.ci:85: referenced as `right`
	cmplGfx/lib/micro.ui.core.ci:70: referenced as `right`
	cmplGfx/lib/micro.ui.core.ci:68: referenced as `right`
	cmplGfx/lib/micro.ui.core.ci:62: referenced as `right`
	cmplGfx/lib/micro.ui.core.ci:60: referenced as `right`
	cmplGfx/lib/micro.ui.core.ci:58: referenced as `right`
}
Style.bottom: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'bottom'
.file: 'cmplGfx/lib/micro.ui.core.ci:54'
.owner: Style
.doc: 'bottom'
.value: 8
.usages:
	cmplGfx/lib/micro.ui.core.ci:100: referenced as `bottom`
	cmplGfx/lib/micro.ui.core.ci:70: referenced as `bottom`
	cmplGfx/lib/micro.ui.core.ci:66: referenced as `bottom`
	cmplGfx/lib/micro.ui.core.ci:64: referenced as `bottom`
	cmplGfx/lib/micro.ui.core.ci:60: referenced as `bottom`
	cmplGfx/lib/micro.ui.core.ci:59: referenced as `bottom`
}
Style.center: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'center'
.file: 'cmplGfx/lib/micro.ui.core.ci:55'
.owner: Style
.doc: 'center'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:719: referenced as `center`
	cmplGfx/lib/micro.ui.core.ci:97: referenced as `center`
	cmplGfx/lib/micro.ui.core.ci:82: referenced as `center`
}
Style.topLeft: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'topLeft'
.file: 'cmplGfx/lib/micro.ui.core.ci:57'
.owner: Style
.doc: 'topLeft'
.value: 3
.usages:
	cmplGfx/lib/micro.ui.ci:917: referenced as `topLeft`
	cmplGfx/lib/micro.ui.ci:912: referenced as `topLeft`
}
Style.topRight: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'topRight'
.file: 'cmplGfx/lib/micro.ui.core.ci:58'
.owner: Style
.doc: 'topRight'
.value: 5
.usages:
	cmplGfx/lib/micro.ui.ci:1008: referenced as `topRight`
	cmplGfx/lib/micro.ui.ci:925: referenced as `topRight`
	cmplGfx/lib/micro.ui.ci:920: referenced as `topRight`
}
Style.bottomLeft: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'bottomLeft'
.file: 'cmplGfx/lib/micro.ui.core.ci:59'
.owner: Style
.doc: 'bottomLeft'
.value: 10
.usages:
}
Style.bottomRight: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'bottomRight'
.file: 'cmplGfx/lib/micro.ui.core.ci:60'
.owner: Style
.doc: 'bottomRight'
.value: 12
.usages:
}
Style.vertical: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'vertical'
.file: 'cmplGfx/lib/micro.ui.core.ci:62'
.owner: Style
.doc: 'vertical'
.value: 6
.usages:
	cmplGfx/lib/micro.ui.core.ci:958: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:873: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:147: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:147: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:128: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:126: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:126: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:81: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:64: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:63: referenced as `vertical`
}
Style.verticalTop: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'verticalTop'
.file: 'cmplGfx/lib/micro.ui.core.ci:63'
.owner: Style
.doc: 'verticalTop'
.value: 7
.usages:
}
Style.verticalBottom: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'verticalBottom'
.file: 'cmplGfx/lib/micro.ui.core.ci:64'
.owner: Style
.doc: 'verticalBottom'
.value: 14
.usages:
}
Style.horizontal: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'horizontal'
.file: 'cmplGfx/lib/micro.ui.core.ci:66'
.owner: Style
.doc: 'horizontal'
.value: 9
.usages:
	cmplGfx/lib/micro.ui.core.ci:962: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:877: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:148: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:148: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:124: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:122: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:122: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:96: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:68: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:67: referenced as `horizontal`
}
Style.horizontalLeft: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'horizontalLeft'
.file: 'cmplGfx/lib/micro.ui.core.ci:67'
.owner: Style
.doc: 'horizontalLeft'
.value: 11
.usages:
}
Style.horizontalRight: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'horizontalRight'
.file: 'cmplGfx/lib/micro.ui.core.ci:68'
.owner: Style
.doc: 'horizontalRight'
.value: 13
.usages:
}
Style.fill: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'fill'
.file: 'cmplGfx/lib/micro.ui.core.ci:70'
.owner: Style
.doc: 'fill'
.value: 15
.usages:
	cmplGfx/lib/micro.ui.ci:863: referenced as `fill`
	cmplGfx/lib/micro.ui.ci:848: referenced as `fill`
	cmplGfx/lib/micro.ui.ci:740: referenced as `fill`
	cmplGfx/lib/micro.ui.core.ci:1157: referenced as `fill`
	cmplGfx/lib/micro.ui.core.ci:1077: referenced as `fill`
	cmplGfx/lib/micro.ui.core.ci:1072: referenced as `fill`
	cmplGfx/lib/micro.ui.core.ci:1067: referenced as `fill`
}
Style.hovered: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'hovered'
.file: 'cmplGfx/lib/micro.ui.core.ci:74'
.owner: Style
.doc: 'hovered'
.value: 1
.usages:
	cmplGfx/lib/micro.ui.ci:1121: referenced as `hovered`
	cmplGfx/lib/micro.ui.ci:909: referenced as `hovered`
	cmplGfx/lib/micro.ui.core.ci:1206: referenced as `hovered`
	cmplGfx/lib/micro.ui.core.ci:1041: referenced as `hovered`
	cmplGfx/lib/micro.ui.core.ci:724: referenced as `hovered`
	cmplGfx/lib/micro.ui.core.ci:706: referenced as `hovered`
	cmplGfx/lib/micro.ui.core.ci:695: referenced as `hovered`
	cmplGfx/lib/micro.ui.core.ci:678: referenced as `hovered`
	cmplGfx/lib/micro.ui.core.ci:667: referenced as `hovered`
	cmplGfx/lib/micro.ui.core.ci:431: referenced as `hovered`
	cmplGfx/lib/micro.ui.core.ci:352: referenced as `hovered`
}
Style.pressed: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'pressed'
.file: 'cmplGfx/lib/micro.ui.core.ci:75'
.owner: Style
.doc: 'pressed'
.value: 2
.usages:
	cmplGfx/lib/micro.ui.core.ci:1044: referenced as `pressed`
	cmplGfx/lib/micro.ui.core.ci:743: referenced as `pressed`
	cmplGfx/lib/micro.ui.core.ci:706: referenced as `pressed`
	cmplGfx/lib/micro.ui.core.ci:687: referenced as `pressed`
	cmplGfx/lib/micro.ui.core.ci:680: referenced as `pressed`
	cmplGfx/lib/micro.ui.core.ci:669: referenced as `pressed`
	cmplGfx/lib/micro.ui.core.ci:439: referenced as `pressed`
	cmplGfx/lib/micro.ui.core.ci:359: referenced as `pressed`
}
Style.focused: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'focused'
.file: 'cmplGfx/lib/micro.ui.core.ci:76'
.owner: Style
.doc: 'focused'
.value: 4
.usages:
	cmplGfx/lib/micro.ui.core.ci:1145: referenced as `focused`
	cmplGfx/lib/micro.ui.core.ci:1047: referenced as `focused`
	cmplGfx/lib/micro.ui.core.ci:739: referenced as `focused`
	cmplGfx/lib/micro.ui.core.ci:504: referenced as `focused`
	cmplGfx/lib/micro.ui.core.ci:498: referenced as `focused`
	cmplGfx/lib/micro.ui.core.ci:491: referenced as `focused`
	cmplGfx/lib/micro.ui.core.ci:447: referenced as `focused`
	cmplGfx/lib/micro.ui.core.ci:349: referenced as `focused`
}
Style.align(parent: Rect, rect: Rect, align: int32): void: function {
.kind: static function
.base: `function`
.size: 389
.name: 'align'
.file: 'cmplGfx/lib/micro.ui.core.ci:80'
.owner: Style
.param .result: void (size: 0, cast: variable(void))
.param parent: Rect (size: 16, cast: variable(val))
.param rect: Rect (size: 4, cast: variable(ref))
.param align: int32 (size: 4, cast: variable(i32))
.doc: 'Place the given `rect` inside the `parent` rectangle conforming to `align`'
.value: {
	vertical: int32 := align & Style.vertical;
	if (vertical == center) {
		positionX(rect, parent.x0 + (width(parent) - width(rect)) / 2);
	}
	else if (vertical == right) {
		positionX(rect, parent.x0 + (width(parent) - width(rect)));
	}
	else if (vertical == left) {
		positionX(rect, parent.x0);
	}
	else {
		rect.x0 := parent.x0;
		rect.x1 := parent.x1;
	}
	horizontal: int32 := align & Style.horizontal;
	if (horizontal == center) {
		positionY(rect, parent.y0 + (height(parent) - height(rect)) / 2);
	}
	else if (horizontal == bottom) {
		positionY(rect, parent.y0 + (height(parent) - height(rect)));
	}
	else if (horizontal == top) {
		positionY(rect, parent.y0);
	}
	else {
		rect.y0 := parent.y0;
		rect.y1 := parent.y1;
	}
}
.instructions: (389 bytes)
	cmplGfx/lib/micro.ui.core.ci:81: (8 bytes): vertical: int32 := align & Style.vertical
	<align>  : dup.x32 sp(1)
	<align+?>: load.c32 6
	<align+?>: and.b32
	cmplGfx/lib/micro.ui.core.ci:82: (174 bytes): if (vertical == center)
	<align+?>: dup.x32 sp(0)
	<align+?>: load.z32
	<align+?>: ceq.i32
	<align+?>: jz +62
	cmplGfx/lib/micro.ui.core.ci:83: (54 bytes): positionX(rect, parent.x0 + (width(parent) - width(rect)) / 2);
	<align+?>: dup.x32 sp(3)
	<align+?>: dup.x32 sp(5)
	<align+?>: load.sp(+24)
	<align+?>: dup.x32 sp(0)
	<align+?>: inc.i32(+8)
	<align+?>: load.i32
	<align+?>: dup.x32 sp(1)
	<align+?>: load.i32
	<align+?>: sub.i32
	<align+?>: set.x32 sp(1)
	<align+?>: dup.x32 sp(6)
	<align+?>: dup.x32 sp(0)
	<align+?>: inc.i32(+8)
	<align+?>: load.i32
	<align+?>: dup.x32 sp(1)
	<align+?>: load.i32
	<align+?>: sub.i32
	<align+?>: set.x32 sp(1)
	<align+?>: sub.i32
	<align+?>: load.c32 2
	<align+?>: div.i32
	<align+?>: add.i32
	<align+?>: load.ref <?> ;positionX(rectangle: Rect, x: int32): void
	<align+?>: call
	<align+?>: inc.sp(-8)
	<align+?>: jmp +112
	cmplGfx/lib/micro.ui.core.ci:85: (108 bytes): if (vertical == right)
	<align+?>: dup.x32 sp(0)
	<align+?>: load.c32 4
	<align+?>: ceq.i32
	<align+?>: jz +56
	cmplGfx/lib/micro.ui.core.ci:86: (48 bytes): positionX(rect, parent.x0 + (width(parent) - width(rect)));
	<align+?>: dup.x32 sp(3)
	<align+?>: dup.x32 sp(5)
	<align+?>: load.sp(+24)
	<align+?>: dup.x32 sp(0)
	<align+?>: inc.i32(+8)
	<align+?>: load.i32
	<align+?>: dup.x32 sp(1)
	<align+?>: load.i32
	<align+?>: sub.i32
	<align+?>: set.x32 sp(1)
	<align+?>: dup.x32 sp(6)
	<align+?>: dup.x32 sp(0)
	<align+?>: inc.i32(+8)
	<align+?>: load.i32
	<align+?>: dup.x32 sp(1)
	<align+?>: load.i32
	<align+?>: sub.i32
	<align+?>: set.x32 sp(1)
	<align+?>: sub.i32
	<align+?>: add.i32
	<align+?>: load.ref <?> ;positionX(rectangle: Rect, x: int32): void
	<align+?>: call
	<align+?>: inc.sp(-8)
	<align+?>: jmp +48
	cmplGfx/lib/micro.ui.core.ci:88: (44 bytes): if (vertical == left)
	<align+?>: dup.x32 sp(0)
	<align+?>: load.c32 2
	<align+?>: ceq.i32
	<align+?>: jz +22
	cmplGfx/lib/micro.ui.core.ci:89: (14 bytes): positionX(rect, parent.x0);
	<align+?>: dup.x32 sp(3)
	<align+?>: dup.x32 sp(5)
	<align+?>: load.ref <?> ;positionX(rectangle: Rect, x: int32): void
	<align+?>: call
	<align+?>: inc.sp(-8)
	<align+?>: jmp +18
	cmplGfx/lib/micro.ui.core.ci:92: (5 bytes): rect.x0 := parent.x0;
	<align+?>: dup.x32 sp(4)
	<align+?>: dup.x32 sp(4)
	<align+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:93: (9 bytes): rect.x1 := parent.x1;
	<align+?>: dup.x32 sp(6)
	<align+?>: dup.x32 sp(4)
	<align+?>: inc.i32(+8)
	<align+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:96: (8 bytes): horizontal: int32 := align & Style.horizontal
	<align+?>: dup.x32 sp(2)
	<align+?>: load.c32 9
	<align+?>: and.b32
	cmplGfx/lib/micro.ui.core.ci:97: (194 bytes): if (horizontal == center)
	<align+?>: dup.x32 sp(0)
	<align+?>: load.z32
	<align+?>: ceq.i32
	<align+?>: jz +70
	cmplGfx/lib/micro.ui.core.ci:98: (62 bytes): positionY(rect, parent.y0 + (height(parent) - height(rect)) / 2);
	<align+?>: dup.x32 sp(4)
	<align+?>: dup.x32 sp(7)
	<align+?>: load.sp(+28)
	<align+?>: dup.x32 sp(0)
	<align+?>: inc.i32(+12)
	<align+?>: load.i32
	<align+?>: dup.x32 sp(1)
	<align+?>: inc.i32(+4)
	<align+?>: load.i32
	<align+?>: sub.i32
	<align+?>: set.x32 sp(1)
	<align+?>: dup.x32 sp(7)
	<align+?>: dup.x32 sp(0)
	<align+?>: inc.i32(+12)
	<align+?>: load.i32
	<align+?>: dup.x32 sp(1)
	<align+?>: inc.i32(+4)
	<align+?>: load.i32
	<align+?>: sub.i32
	<align+?>: set.x32 sp(1)
	<align+?>: sub.i32
	<align+?>: load.c32 2
	<align+?>: div.i32
	<align+?>: add.i32
	<align+?>: load.ref <?> ;positionY(rectangle: Rect, y: int32): void
	<align+?>: call
	<align+?>: inc.sp(-8)
	<align+?>: jmp +124
	cmplGfx/lib/micro.ui.core.ci:100: (120 bytes): if (horizontal == bottom)
	<align+?>: dup.x32 sp(0)
	<align+?>: load.c32 8
	<align+?>: ceq.i32
	<align+?>: jz +64
	cmplGfx/lib/micro.ui.core.ci:101: (56 bytes): positionY(rect, parent.y0 + (height(parent) - height(rect)));
	<align+?>: dup.x32 sp(4)
	<align+?>: dup.x32 sp(7)
	<align+?>: load.sp(+28)
	<align+?>: dup.x32 sp(0)
	<align+?>: inc.i32(+12)
	<align+?>: load.i32
	<align+?>: dup.x32 sp(1)
	<align+?>: inc.i32(+4)
	<align+?>: load.i32
	<align+?>: sub.i32
	<align+?>: set.x32 sp(1)
	<align+?>: dup.x32 sp(7)
	<align+?>: dup.x32 sp(0)
	<align+?>: inc.i32(+12)
	<align+?>: load.i32
	<align+?>: dup.x32 sp(1)
	<align+?>: inc.i32(+4)
	<align+?>: load.i32
	<align+?>: sub.i32
	<align+?>: set.x32 sp(1)
	<align+?>: sub.i32
	<align+?>: add.i32
	<align+?>: load.ref <?> ;positionY(rectangle: Rect, y: int32): void
	<align+?>: call
	<align+?>: inc.sp(-8)
	<align+?>: jmp +52
	cmplGfx/lib/micro.ui.core.ci:103: (48 bytes): if (horizontal == top)
	<align+?>: dup.x32 sp(0)
	<align+?>: load.c32 1
	<align+?>: ceq.i32
	<align+?>: jz +22
	cmplGfx/lib/micro.ui.core.ci:104: (14 bytes): positionY(rect, parent.y0);
	<align+?>: dup.x32 sp(4)
	<align+?>: dup.x32 sp(7)
	<align+?>: load.ref <?> ;positionY(rectangle: Rect, y: int32): void
	<align+?>: call
	<align+?>: inc.sp(-8)
	<align+?>: jmp +22
	cmplGfx/lib/micro.ui.core.ci:107: (9 bytes): rect.y0 := parent.y0;
	<align+?>: dup.x32 sp(6)
	<align+?>: dup.x32 sp(5)
	<align+?>: inc.i32(+4)
	<align+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:108: (9 bytes): rect.y1 := parent.y1;
	<align+?>: dup.x32 sp(8)
	<align+?>: dup.x32 sp(5)
	<align+?>: inc.i32(+12)
	<align+?>: store.i32
	<align+?>: inc.sp(-8)
	<align+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:963: referenced as `align`
	cmplGfx/lib/micro.ui.ci:151: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:1021: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:965: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:880: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:130: referenced as `align`
}
Style.measure(this: Style, rect: Rect, text: char[*]): void: function {
.kind: static function
.base: `function`
.size: 35
.name: 'measure'
.file: 'cmplGfx/lib/micro.ui.core.ci:113'
.owner: Style
.param .result: void (size: 0, cast: variable(void))
.param this: Style (size: 4, cast: const variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.param text: char[*] (size: 4, cast: const variable(ref))
.doc: 'Measure the given `text` whit `this` style.'
.value: {
	Image.clipText(this.font, &rect, text);
	padded(&rect, this.padding);
}
.instructions: (35 bytes)
	cmplGfx/lib/micro.ui.core.ci:114: (15 bytes): Image.clipText(this.font, &rect, text);
	<measure>  : dup.x32 sp(3)
	<measure+?>: inc.i32(+8)
	<measure+?>: load.i64
	<measure+?>: dup.x32 sp(4)
	<measure+?>: dup.x32 sp(4)
	<measure+?>: nfc(107) ;Image.clipText(font: Image, rect: Rect, text: char[*]): void
	cmplGfx/lib/micro.ui.core.ci:115: (19 bytes): padded(&rect, this.padding);
	<measure+?>: dup.x32 sp(2)
	<measure+?>: dup.x32 sp(4)
	<measure+?>: inc.i32(+4)
	<measure+?>: load.i32
	<measure+?>: load.ref <?> ;padded(rect: Rect, padding: int32): void
	<measure+?>: call
	<measure+?>: inc.sp(-8)
	<measure+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:563: referenced as `measure`
	cmplGfx/lib/micro.ui.ci:292: referenced as `measure`
	cmplGfx/lib/micro.ui.ci:291: referenced as `measure`
	cmplGfx/lib/micro.ui.ci:132: referenced as `measure`
	cmplGfx/lib/micro.ui.ci:127: referenced as `measure`
	cmplGfx/lib/micro.ui.ci:10: referenced as `measure`
}
Style.align(this: Style, parent: Rect, rect: Rect, value: char[*], align: int32): void: function {
.kind: static function
.base: `function`
.size: 112
.name: 'align'
.file: 'cmplGfx/lib/micro.ui.core.ci:119'
.owner: Style
.param .result: void (size: 0, cast: variable(void))
.param this: Style (size: 4, cast: const variable(ref))
.param parent: Rect (size: 16, cast: variable(val))
.param rect: Rect (size: 4, cast: variable(ref))
.param value: char[*] (size: 4, cast: const variable(ref))
.param align: int32 (size: 4, cast: variable(i32))
.doc: 'Measure and align the given `text` whit `this` style.'
.value: {
	padded(parent, -this.padding);
	Image.clipText(this.font, &rect, value);
	if ((align & horizontal) == horizontal) {
		align := align & ~horizontal;
	}
	if ((align & vertical) == vertical) {
		align := align & ~vertical;
	}
	align(parent, &rect, align);
}
.instructions: (112 bytes)
	cmplGfx/lib/micro.ui.core.ci:120: (22 bytes): padded(parent, -this.padding);
	<align>  : load.sp(+16)
	<align+?>: dup.x32 sp(9)
	<align+?>: inc.i32(+4)
	<align+?>: load.i32
	<align+?>: neg.i32
	<align+?>: load.ref <?> ;padded(rect: Rect, padding: int32): void
	<align+?>: call
	<align+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:121: (15 bytes): Image.clipText(this.font, &rect, value);
	<align+?>: dup.x32 sp(8)
	<align+?>: inc.i32(+8)
	<align+?>: load.i64
	<align+?>: dup.x32 sp(5)
	<align+?>: dup.x32 sp(5)
	<align+?>: nfc(107) ;Image.clipText(font: Image, rect: Rect, text: char[*]): void
	cmplGfx/lib/micro.ui.core.ci:122: (29 bytes): if ((align & horizontal) == horizontal)
	<align+?>: dup.x32 sp(1)
	<align+?>: load.c32 9
	<align+?>: and.b32
	<align+?>: load.c32 9
	<align+?>: ceq.i32
	<align+?>: jz +15
	cmplGfx/lib/micro.ui.core.ci:124: (11 bytes): align := align & ~horizontal;
	<align+?>: dup.x32 sp(1)
	<align+?>: load.c32 9
	<align+?>: cmt.b32
	<align+?>: and.b32
	<align+?>: set.x32 sp(2)
	cmplGfx/lib/micro.ui.core.ci:126: (29 bytes): if ((align & vertical) == vertical)
	<align+?>: dup.x32 sp(1)
	<align+?>: load.c32 6
	<align+?>: and.b32
	<align+?>: load.c32 6
	<align+?>: ceq.i32
	<align+?>: jz +15
	cmplGfx/lib/micro.ui.core.ci:128: (11 bytes): align := align & ~vertical;
	<align+?>: dup.x32 sp(1)
	<align+?>: load.c32 6
	<align+?>: cmt.b32
	<align+?>: and.b32
	<align+?>: set.x32 sp(2)
	cmplGfx/lib/micro.ui.core.ci:130: (16 bytes): align(parent, &rect, align);
	<align+?>: dup.x128 sp(4)
	<align+?>: dup.x32 sp(7)
	<align+?>: dup.x32 sp(6)
	<align+?>: load.ref <?> ;Style.align(parent: Rect, rect: Rect, align: int32): void
	<align+?>: call
	<align+?>: inc.sp(-24)
	<align+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:373: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:135: referenced as `align`
}
Style.align(this: Style, parent: Rect, rect: Rect, value: char[*]): void: function {
.kind: static function
.base: `function`
.size: 22
.name: 'align'
.file: 'cmplGfx/lib/micro.ui.core.ci:134'
.owner: Style
.param .result: void (size: 0, cast: variable(void))
.param this: Style (size: 4, cast: const variable(ref))
.param parent: Rect (size: 16, cast: variable(val))
.param rect: Rect (size: 4, cast: variable(ref))
.param value: char[*] (size: 4, cast: const variable(ref))
.doc: 'Measure and align the given `text` whit `this` style.'
.value: {
	return .result := align(this, parent, &rect, value, this.align);
}
.instructions: (22 bytes)
	cmplGfx/lib/micro.ui.core.ci:135: (22 bytes): return .result := align(this, parent, &rect, value, this.align);
	<align>  : dup.x32 sp(7)
	<align+?>: dup.x128 sp(4)
	<align+?>: dup.x32 sp(7)
	<align+?>: dup.x32 sp(7)
	<align+?>: dup.x32 sp(14)
	<align+?>: load.i32
	<align+?>: load.ref <?> ;Style.align(this: Style, parent: Rect, rect: Rect, value: char[*], align: int32): void
	<align+?>: call
	<align+?>: inc.sp(-32)
	<align+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:668: referenced as `align`
	cmplGfx/lib/micro.ui.ci:593: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:377: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:366: referenced as `align`
}
Style.setColor(style: Style, background: argb, accent: argb): void: function {
.kind: static function
.base: `function`
.size: 542
.name: 'setColor'
.file: 'cmplGfx/lib/micro.ui.core.ci:139'
.owner: Style
.param .result: void (size: 0, cast: variable(void))
.param style: Style (size: 4, cast: variable(ref))
.param background: argb (size: 4, cast: variable(val))
.param accent: argb (size: 4, cast: variable(val))
.doc: 'Setup a custom color for the style'
.value: {
	style.backgroundColor := uint32(background);
	style.hoveredColor := uint32(mix_rgb8(16, background, accent));
	style.focusedColor := uint32(mix_rgb8(64, background, accent));
	style.valueColor := uint32(accent);
	style.textColor := uint32(lum(background) > 127 ? dark : light);
}
.instructions: (542 bytes)
	cmplGfx/lib/micro.ui.core.ci:140: (9 bytes): style.backgroundColor := uint32(background);
	<setColor>  : dup.x32 sp(2)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: inc.i32(+32)
	<setColor+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:141: (226 bytes): style.hoveredColor := uint32(mix_rgb8(16, background, accent));
	<setColor+?>: load.c32 16
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: dup.x32 sp(1)
	<setColor+?>: b32.shr 0x10
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: b32.shr 0x10
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: sub.i32
	<setColor+?>: inc.i32(+1)
	<setColor+?>: mul.i32
	<setColor+?>: b32.sar 0x08
	<setColor+?>: add.i32
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.c32 255
	<setColor+?>: cgt.i32
	<setColor+?>: jz +13
	<setColor+?>: load.c32 255
	<setColor+?>: jmp +19
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.z32
	<setColor+?>: clt.i32
	<setColor+?>: jz +9
	<setColor+?>: load.z32
	<setColor+?>: jmp +6
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: b32.shl 0x08
	<setColor+?>: dup.x32 sp(2)
	<setColor+?>: b32.shr 0x08
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: dup.x32 sp(5)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: b32.shr 0x08
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: sub.i32
	<setColor+?>: inc.i32(+1)
	<setColor+?>: mul.i32
	<setColor+?>: b32.sar 0x08
	<setColor+?>: add.i32
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.c32 255
	<setColor+?>: cgt.i32
	<setColor+?>: jz +13
	<setColor+?>: load.c32 255
	<setColor+?>: jmp +19
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.z32
	<setColor+?>: clt.i32
	<setColor+?>: jz +9
	<setColor+?>: load.z32
	<setColor+?>: jmp +6
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: or.b32
	<setColor+?>: b32.shl 0x08
	<setColor+?>: dup.x32 sp(2)
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: dup.x32 sp(5)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: sub.i32
	<setColor+?>: inc.i32(+1)
	<setColor+?>: mul.i32
	<setColor+?>: b32.sar 0x08
	<setColor+?>: add.i32
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.c32 255
	<setColor+?>: cgt.i32
	<setColor+?>: jz +13
	<setColor+?>: load.c32 255
	<setColor+?>: jmp +19
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.z32
	<setColor+?>: clt.i32
	<setColor+?>: jz +9
	<setColor+?>: load.z32
	<setColor+?>: jmp +6
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: or.b32
	<setColor+?>: mov.x32 sp(3, 0)
	<setColor+?>: inc.sp(-12)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: inc.i32(+36)
	<setColor+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:142: (226 bytes): style.focusedColor := uint32(mix_rgb8(64, background, accent));
	<setColor+?>: load.c32 64
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: dup.x32 sp(1)
	<setColor+?>: b32.shr 0x10
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: b32.shr 0x10
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: sub.i32
	<setColor+?>: inc.i32(+1)
	<setColor+?>: mul.i32
	<setColor+?>: b32.sar 0x08
	<setColor+?>: add.i32
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.c32 255
	<setColor+?>: cgt.i32
	<setColor+?>: jz +13
	<setColor+?>: load.c32 255
	<setColor+?>: jmp +19
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.z32
	<setColor+?>: clt.i32
	<setColor+?>: jz +9
	<setColor+?>: load.z32
	<setColor+?>: jmp +6
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: b32.shl 0x08
	<setColor+?>: dup.x32 sp(2)
	<setColor+?>: b32.shr 0x08
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: dup.x32 sp(5)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: b32.shr 0x08
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: sub.i32
	<setColor+?>: inc.i32(+1)
	<setColor+?>: mul.i32
	<setColor+?>: b32.sar 0x08
	<setColor+?>: add.i32
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.c32 255
	<setColor+?>: cgt.i32
	<setColor+?>: jz +13
	<setColor+?>: load.c32 255
	<setColor+?>: jmp +19
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.z32
	<setColor+?>: clt.i32
	<setColor+?>: jz +9
	<setColor+?>: load.z32
	<setColor+?>: jmp +6
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: or.b32
	<setColor+?>: b32.shl 0x08
	<setColor+?>: dup.x32 sp(2)
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: dup.x32 sp(5)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: b32.and 0xff
	<setColor+?>: dup.x32 sp(3)
	<setColor+?>: sub.i32
	<setColor+?>: inc.i32(+1)
	<setColor+?>: mul.i32
	<setColor+?>: b32.sar 0x08
	<setColor+?>: add.i32
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.c32 255
	<setColor+?>: cgt.i32
	<setColor+?>: jz +13
	<setColor+?>: load.c32 255
	<setColor+?>: jmp +19
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: load.z32
	<setColor+?>: clt.i32
	<setColor+?>: jz +9
	<setColor+?>: load.z32
	<setColor+?>: jmp +6
	<setColor+?>: dup.x32 sp(0)
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: or.b32
	<setColor+?>: mov.x32 sp(3, 0)
	<setColor+?>: inc.sp(-12)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: inc.i32(+40)
	<setColor+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:143: (9 bytes): style.valueColor := uint32(accent);
	<setColor+?>: dup.x32 sp(1)
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: inc.i32(+44)
	<setColor+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:144: (71 bytes): style.textColor := uint32(lum(background) > 127 ? dark : light);
	<setColor+?>: dup.x32 sp(2)
	<setColor+?>: load.c32 19595
	<setColor+?>: dup.x32 sp(1)
	<setColor+?>: b32.shr 0x10
	<setColor+?>: b32.and 0xff
	<setColor+?>: mul.i32
	<setColor+?>: load.c32 38470
	<setColor+?>: dup.x32 sp(2)
	<setColor+?>: b32.shr 0x08
	<setColor+?>: b32.and 0xff
	<setColor+?>: mul.i32
	<setColor+?>: add.i32
	<setColor+?>: load.c32 7471
	<setColor+?>: dup.x32 sp(2)
	<setColor+?>: b32.and 0xff
	<setColor+?>: mul.i32
	<setColor+?>: add.i32
	<setColor+?>: b32.sar 0x10
	<setColor+?>: set.x32 sp(1)
	<setColor+?>: load.c32 127
	<setColor+?>: cgt.i32
	<setColor+?>: jz +12
	<setColor+?>: load.m32 <?> ;Style.dark
	<setColor+?>: jmp +8
	<setColor+?>: load.m32 <?> ;Style.light
	<setColor+?>: dup.x32 sp(4)
	<setColor+?>: inc.i32(+48)
	<setColor+?>: store.i32
	<setColor+?>: ret
.usages:
}
Style.vertical(align: int32): bool: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'vertical'
.file: 'cmplGfx/lib/micro.ui.core.ci:147'
.owner: Style
.param .result: bool (size: 1, cast: bool)
.param align: int32 (size: 4, cast: i32)
.value: (align & vertical) == vertical
.usages:
	cmplGfx/lib/micro.ui.core.ci:956: referenced as `vertical`
	cmplGfx/lib/micro.ui.core.ci:871: referenced as `vertical`
}
Style.horizontal(align: int32): bool: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horizontal'
.file: 'cmplGfx/lib/micro.ui.core.ci:148'
.owner: Style
.param .result: bool (size: 1, cast: bool)
.param align: int32 (size: 4, cast: i32)
.value: (align & horizontal) == horizontal
.usages:
	cmplGfx/lib/micro.ui.core.ci:960: referenced as `horizontal`
	cmplGfx/lib/micro.ui.core.ci:875: referenced as `horizontal`
}
KeyEvent: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'KeyEvent'
.file: 'cmplGfx/lib/micro.ui.core.ci:151'
.field release: bool (size: 1, cast: const variable(bool))
.field isShift: bool (size: 1, cast: const variable(bool))
.field isCtrl: bool (size: 1, cast: const variable(bool))
.field isAlt: bool (size: 1, cast: const variable(bool))
.field repeat: int32 (size: 4, cast: const variable(i32))
.field key: int32 (size: 4, cast: const variable(i32))
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1234: referenced as `KeyEvent`
	cmplGfx/lib/micro.ui.ci:1220: referenced as `KeyEvent`
	cmplGfx/lib/micro.ui.ci:895: referenced as `KeyEvent`
	cmplGfx/lib/micro.ui.ci:230: referenced as `KeyEvent`
	cmplGfx/lib/micro.ui.ci:96: referenced as `KeyEvent`
	cmplGfx/lib/micro.ui.core.ci:1195: referenced as `KeyEvent`
	cmplGfx/lib/micro.ui.core.ci:628: referenced as `KeyEvent`
	cmplGfx/lib/micro.ui.core.ci:278: referenced as `KeyEvent`
}
KeyEvent.release: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'release'
.file: 'cmplGfx/lib/micro.ui.core.ci:153'
.owner: KeyEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1235: referenced as `release`
	cmplGfx/lib/micro.ui.ci:1221: referenced as `release`
	cmplGfx/lib/micro.ui.ci:938: referenced as `release`
	cmplGfx/lib/micro.ui.ci:935: referenced as `release`
	cmplGfx/lib/micro.ui.ci:934: referenced as `release`
	cmplGfx/lib/micro.ui.ci:904: referenced as `release`
	cmplGfx/lib/micro.ui.ci:900: referenced as `release`
	cmplGfx/lib/micro.ui.ci:898: referenced as `release`
	cmplGfx/lib/micro.ui.ci:897: referenced as `release`
	cmplGfx/lib/micro.ui.ci:231: referenced as `release`
	cmplGfx/lib/micro.ui.ci:97: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:1200: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:283: referenced as `release`
}
KeyEvent.isShift: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'isShift'
.file: 'cmplGfx/lib/micro.ui.core.ci:155'
.owner: KeyEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1236: referenced as `isShift`
	cmplGfx/lib/micro.ui.ci:1222: referenced as `isShift`
	cmplGfx/lib/micro.ui.ci:942: referenced as `isShift`
	cmplGfx/lib/micro.ui.ci:241: referenced as `isShift`
	cmplGfx/lib/micro.ui.ci:238: referenced as `isShift`
	cmplGfx/lib/micro.ui.core.ci:1208: referenced as `isShift`
	cmplGfx/lib/micro.ui.core.ci:1207: referenced as `isShift`
}
KeyEvent.isCtrl: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'isCtrl'
.file: 'cmplGfx/lib/micro.ui.core.ci:157'
.owner: KeyEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1237: referenced as `isCtrl`
	cmplGfx/lib/micro.ui.ci:1223: referenced as `isCtrl`
}
KeyEvent.isAlt: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'isAlt'
.file: 'cmplGfx/lib/micro.ui.core.ci:159'
.owner: KeyEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1238: referenced as `isAlt`
	cmplGfx/lib/micro.ui.ci:1224: referenced as `isAlt`
}
KeyEvent.repeat: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'repeat'
.file: 'cmplGfx/lib/micro.ui.core.ci:161'
.owner: KeyEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1239: referenced as `repeat`
	cmplGfx/lib/micro.ui.ci:1225: referenced as `repeat`
	cmplGfx/lib/micro.ui.ci:935: referenced as `repeat`
	cmplGfx/lib/micro.ui.ci:904: referenced as `repeat`
	cmplGfx/lib/micro.ui.ci:902: referenced as `repeat`
	cmplGfx/lib/micro.ui.ci:900: referenced as `repeat`
	cmplGfx/lib/micro.ui.ci:898: referenced as `repeat`
}
KeyEvent.key: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'key'
.file: 'cmplGfx/lib/micro.ui.core.ci:163'
.owner: KeyEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1240: referenced as `key`
	cmplGfx/lib/micro.ui.ci:1226: referenced as `key`
	cmplGfx/lib/micro.ui.ci:942: referenced as `key`
	cmplGfx/lib/micro.ui.ci:933: referenced as `key`
	cmplGfx/lib/micro.ui.ci:919: referenced as `key`
	cmplGfx/lib/micro.ui.ci:911: referenced as `key`
	cmplGfx/lib/micro.ui.ci:896: referenced as `key`
	cmplGfx/lib/micro.ui.ci:896: referenced as `key`
	cmplGfx/lib/micro.ui.ci:240: referenced as `key`
	cmplGfx/lib/micro.ui.ci:240: referenced as `key`
	cmplGfx/lib/micro.ui.ci:237: referenced as `key`
	cmplGfx/lib/micro.ui.ci:237: referenced as `key`
	cmplGfx/lib/micro.ui.ci:234: referenced as `key`
	cmplGfx/lib/micro.ui.ci:104: referenced as `key`
	cmplGfx/lib/micro.ui.ci:104: referenced as `key`
	cmplGfx/lib/micro.ui.ci:100: referenced as `key`
	cmplGfx/lib/micro.ui.ci:100: referenced as `key`
	cmplGfx/lib/micro.ui.core.ci:1204: referenced as `key`
	cmplGfx/lib/micro.ui.core.ci:1204: referenced as `key`
	cmplGfx/lib/micro.ui.core.ci:290: referenced as `key`
	cmplGfx/lib/micro.ui.core.ci:286: referenced as `key`
}
TouchEvent: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'TouchEvent'
.file: 'cmplGfx/lib/micro.ui.core.ci:166'
.field release: bool (size: 1, cast: const variable(bool))
.field isShift: bool (size: 1, cast: const variable(bool))
.field isCtrl: bool (size: 1, cast: const variable(bool))
.field isAlt: bool (size: 1, cast: const variable(bool))
.field clicks: int32 (size: 4, cast: const variable(i32))
.field button: int32 (size: 4, cast: const variable(i32))
.field dx: int32 (size: 4, cast: const variable(i32))
.field dy: int32 (size: 4, cast: const variable(i32))
.field x: int32 (size: 4, cast: const variable(i32))
.field y: int32 (size: 4, cast: const variable(i32))
.field test: function (size: 111, cast: static function)
.field isMotion: function (size: 32, cast: static function)
.field isPress: function (size: 46, cast: static function)
.field isLongPress: function (size: 28, cast: static function)
.field isPress: function (size: 66, cast: static function)
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1250: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.ci:1196: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.ci:1172: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.ci:1147: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.ci:870: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.ci:366: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.ci:246: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.ci:111: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.core.ci:643: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.core.ci:298: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.core.ci:215: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.core.ci:210: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.core.ci:205: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.core.ci:200: referenced as `TouchEvent`
	cmplGfx/lib/micro.ui.core.ci:189: referenced as `TouchEvent`
}
TouchEvent.release: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'release'
.file: 'cmplGfx/lib/micro.ui.core.ci:168'
.owner: TouchEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1251: referenced as `release`
	cmplGfx/lib/micro.ui.ci:1197: referenced as `release`
	cmplGfx/lib/micro.ui.ci:1173: referenced as `release`
	cmplGfx/lib/micro.ui.ci:1148: referenced as `release`
	cmplGfx/lib/micro.ui.ci:367: referenced as `release`
	cmplGfx/lib/micro.ui.ci:269: referenced as `release`
	cmplGfx/lib/micro.ui.ci:250: referenced as `release`
	cmplGfx/lib/micro.ui.ci:112: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:714: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:704: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:679: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:668: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:661: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:311: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:216: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:211: referenced as `release`
	cmplGfx/lib/micro.ui.core.ci:206: referenced as `release`
}
TouchEvent.isShift: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'isShift'
.file: 'cmplGfx/lib/micro.ui.core.ci:170'
.owner: TouchEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1252: referenced as `isShift`
	cmplGfx/lib/micro.ui.ci:1198: referenced as `isShift`
	cmplGfx/lib/micro.ui.ci:1174: referenced as `isShift`
	cmplGfx/lib/micro.ui.ci:1149: referenced as `isShift`
	cmplGfx/lib/micro.ui.ci:256: referenced as `isShift`
	cmplGfx/lib/micro.ui.ci:115: referenced as `isShift`
}
TouchEvent.isCtrl: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'isCtrl'
.file: 'cmplGfx/lib/micro.ui.core.ci:172'
.owner: TouchEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1253: referenced as `isCtrl`
	cmplGfx/lib/micro.ui.ci:1199: referenced as `isCtrl`
	cmplGfx/lib/micro.ui.ci:1175: referenced as `isCtrl`
	cmplGfx/lib/micro.ui.ci:1150: referenced as `isCtrl`
}
TouchEvent.isAlt: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'isAlt'
.file: 'cmplGfx/lib/micro.ui.core.ci:174'
.owner: TouchEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1254: referenced as `isAlt`
	cmplGfx/lib/micro.ui.ci:1200: referenced as `isAlt`
	cmplGfx/lib/micro.ui.ci:1176: referenced as `isAlt`
	cmplGfx/lib/micro.ui.ci:1151: referenced as `isAlt`
}
TouchEvent.clicks: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'clicks'
.file: 'cmplGfx/lib/micro.ui.core.ci:176'
.owner: TouchEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1255: referenced as `clicks`
	cmplGfx/lib/micro.ui.ci:1201: referenced as `clicks`
	cmplGfx/lib/micro.ui.ci:1177: referenced as `clicks`
	cmplGfx/lib/micro.ui.ci:1152: referenced as `clicks`
	cmplGfx/lib/micro.ui.ci:254: referenced as `clicks`
	cmplGfx/lib/micro.ui.ci:250: referenced as `clicks`
	cmplGfx/lib/micro.ui.ci:250: referenced as `clicks`
	cmplGfx/lib/micro.ui.ci:115: referenced as `clicks`
	cmplGfx/lib/micro.ui.core.ci:722: referenced as `clicks`
	cmplGfx/lib/micro.ui.core.ci:320: referenced as `clicks`
	cmplGfx/lib/micro.ui.core.ci:316: referenced as `clicks`
	cmplGfx/lib/micro.ui.core.ci:211: referenced as `clicks`
}
TouchEvent.button: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'button'
.file: 'cmplGfx/lib/micro.ui.core.ci:178'
.owner: TouchEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1256: referenced as `button`
	cmplGfx/lib/micro.ui.ci:1202: referenced as `button`
	cmplGfx/lib/micro.ui.ci:1178: referenced as `button`
	cmplGfx/lib/micro.ui.ci:1153: referenced as `button`
	cmplGfx/lib/micro.ui.ci:875: referenced as `button`
	cmplGfx/lib/micro.ui.ci:367: referenced as `button`
	cmplGfx/lib/micro.ui.ci:247: referenced as `button`
	cmplGfx/lib/micro.ui.core.ci:661: referenced as `button`
	cmplGfx/lib/micro.ui.core.ci:219: referenced as `button`
}
TouchEvent.dx: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'dx'
.file: 'cmplGfx/lib/micro.ui.core.ci:180'
.owner: TouchEvent
.doc: '@public'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1179: referenced as `dx`
	cmplGfx/lib/micro.ui.ci:875: referenced as `dx`
	cmplGfx/lib/micro.ui.ci:373: referenced as `dx`
	cmplGfx/lib/micro.ui.ci:255: referenced as `dx`
	cmplGfx/lib/micro.ui.core.ci:661: referenced as `dx`
	cmplGfx/lib/micro.ui.core.ci:216: referenced as `dx`
	cmplGfx/lib/micro.ui.core.ci:206: referenced as `dx`
	cmplGfx/lib/micro.ui.core.ci:201: referenced as `dx`
	internal usages: 3
}
TouchEvent.dy: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'dy'
.file: 'cmplGfx/lib/micro.ui.core.ci:182'
.owner: TouchEvent
.doc: '@public'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1180: referenced as `dy`
	cmplGfx/lib/micro.ui.ci:875: referenced as `dy`
	cmplGfx/lib/micro.ui.ci:375: referenced as `dy`
	cmplGfx/lib/micro.ui.core.ci:661: referenced as `dy`
	cmplGfx/lib/micro.ui.core.ci:216: referenced as `dy`
	cmplGfx/lib/micro.ui.core.ci:206: referenced as `dy`
	cmplGfx/lib/micro.ui.core.ci:201: referenced as `dy`
	internal usages: 3
}
TouchEvent.x: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'x'
.file: 'cmplGfx/lib/micro.ui.core.ci:184'
.owner: TouchEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1257: referenced as `x`
	cmplGfx/lib/micro.ui.ci:1203: referenced as `x`
	cmplGfx/lib/micro.ui.ci:1181: referenced as `x`
	cmplGfx/lib/micro.ui.ci:1154: referenced as `x`
	cmplGfx/lib/micro.ui.ci:372: referenced as `x`
	cmplGfx/lib/micro.ui.ci:275: referenced as `x`
	cmplGfx/lib/micro.ui.core.ci:662: referenced as `x`
	cmplGfx/lib/micro.ui.core.ci:190: referenced as `x`
	cmplGfx/lib/micro.ui.core.ci:190: referenced as `x`
}
TouchEvent.y: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.file: 'cmplGfx/lib/micro.ui.core.ci:186'
.owner: TouchEvent
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1258: referenced as `y`
	cmplGfx/lib/micro.ui.ci:1204: referenced as `y`
	cmplGfx/lib/micro.ui.ci:1182: referenced as `y`
	cmplGfx/lib/micro.ui.ci:1155: referenced as `y`
	cmplGfx/lib/micro.ui.ci:374: referenced as `y`
	cmplGfx/lib/micro.ui.core.ci:662: referenced as `y`
	cmplGfx/lib/micro.ui.core.ci:193: referenced as `y`
	cmplGfx/lib/micro.ui.core.ci:193: referenced as `y`
}
TouchEvent.test(event: TouchEvent, rect: Rect): bool: function {
.kind: static function
.base: `function`
.size: 111
.name: 'test'
.file: 'cmplGfx/lib/micro.ui.core.ci:189'
.owner: TouchEvent
.param .result: bool (size: 4, cast: variable(bool))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.param rect: Rect (size: 4, cast: const variable(ref))
.doc: '@public'
.value: {
	if (event.x < rect.x0 || event.x >= rect.x1) {
		return .result := false;
	}
	if (event.y < rect.y0 || event.y >= rect.y1) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (111 bytes)
	cmplGfx/lib/micro.ui.core.ci:190: (48 bytes): if (event.x < rect.x0 || event.x >= rect.x1)
	<test>  : dup.x32 sp(2)
	<test+?>: inc.i32(+20)
	<test+?>: load.i32
	<test+?>: dup.x32 sp(2)
	<test+?>: load.i32
	<test+?>: clt.i32
	<test+?>: dup.x32 sp(0)
	<test+?>: jnz +24
	<test+?>: inc.sp(-4)
	<test+?>: dup.x32 sp(2)
	<test+?>: inc.i32(+20)
	<test+?>: load.i32
	<test+?>: dup.x32 sp(2)
	<test+?>: inc.i32(+8)
	<test+?>: load.i32
	<test+?>: clt.i32
	<test+?>: not.b32
	<test+?>: jz +11
	cmplGfx/lib/micro.ui.core.ci:191: (7 bytes): return .result := false;
	<test+?>: load.z32
	<test+?>: load.sp(+16)
	<test+?>: store.i8
	<test+?>: ret
	cmplGfx/lib/micro.ui.core.ci:193: (52 bytes): if (event.y < rect.y0 || event.y >= rect.y1)
	<test+?>: dup.x32 sp(2)
	<test+?>: inc.i32(+24)
	<test+?>: load.i32
	<test+?>: dup.x32 sp(2)
	<test+?>: inc.i32(+4)
	<test+?>: load.i32
	<test+?>: clt.i32
	<test+?>: dup.x32 sp(0)
	<test+?>: jnz +24
	<test+?>: inc.sp(-4)
	<test+?>: dup.x32 sp(2)
	<test+?>: inc.i32(+24)
	<test+?>: load.i32
	<test+?>: dup.x32 sp(2)
	<test+?>: inc.i32(+12)
	<test+?>: load.i32
	<test+?>: clt.i32
	<test+?>: not.b32
	<test+?>: jz +11
	cmplGfx/lib/micro.ui.core.ci:194: (7 bytes): return .result := false;
	<test+?>: load.z32
	<test+?>: load.sp(+16)
	<test+?>: store.i8
	<test+?>: ret
	cmplGfx/lib/micro.ui.core.ci:196: (11 bytes): return .result := true;
	<test+?>: load.c32 1
	<test+?>: load.sp(+16)
	<test+?>: store.i8
	<test+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:692: referenced as `test`
}
TouchEvent.isMotion(event: TouchEvent): bool: function {
.kind: static function
.base: `function`
.size: 32
.name: 'isMotion'
.file: 'cmplGfx/lib/micro.ui.core.ci:200'
.owner: TouchEvent
.param .result: bool (size: 4, cast: variable(bool))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: '@public'
.value: {
	return .result := (event.dx) || (event.dy);
}
.instructions: (32 bytes)
	cmplGfx/lib/micro.ui.core.ci:201: (32 bytes): return .result := (event.dx) || (event.dy);
	<isMotion>  : dup.x32 sp(1)
	<isMotion+?>: inc.i32(+12)
	<isMotion+?>: load.i32
	<isMotion+?>: i32.2bool
	<isMotion+?>: dup.x32 sp(0)
	<isMotion+?>: jnz +16
	<isMotion+?>: inc.sp(-4)
	<isMotion+?>: dup.x32 sp(1)
	<isMotion+?>: inc.i32(+16)
	<isMotion+?>: load.i32
	<isMotion+?>: i32.2bool
	<isMotion+?>: load.sp(+12)
	<isMotion+?>: store.i8
	<isMotion+?>: ret
.usages:
}
TouchEvent.isPress(event: TouchEvent): bool: function {
.kind: static function
.base: `function`
.size: 46
.name: 'isPress'
.file: 'cmplGfx/lib/micro.ui.core.ci:205'
.owner: TouchEvent
.param .result: bool (size: 4, cast: variable(bool))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: '@public'
.value: {
	return .result := !(event.release || (event.dx) || (event.dy));
}
.instructions: (46 bytes)
	cmplGfx/lib/micro.ui.core.ci:206: (46 bytes): return .result := !(event.release || (event.dx) || (event.dy));
	<isPress>  : dup.x32 sp(1)
	<isPress+?>: load.is8
	<isPress+?>: dup.x32 sp(0)
	<isPress+?>: jnz +16
	<isPress+?>: inc.sp(-4)
	<isPress+?>: dup.x32 sp(1)
	<isPress+?>: inc.i32(+12)
	<isPress+?>: load.i32
	<isPress+?>: i32.2bool
	<isPress+?>: dup.x32 sp(0)
	<isPress+?>: jnz +16
	<isPress+?>: inc.sp(-4)
	<isPress+?>: dup.x32 sp(1)
	<isPress+?>: inc.i32(+16)
	<isPress+?>: load.i32
	<isPress+?>: i32.2bool
	<isPress+?>: not.b32
	<isPress+?>: load.sp(+12)
	<isPress+?>: store.i8
	<isPress+?>: ret
.usages:
}
TouchEvent.isLongPress(event: TouchEvent): bool: function {
.kind: static function
.base: `function`
.size: 28
.name: 'isLongPress'
.file: 'cmplGfx/lib/micro.ui.core.ci:210'
.owner: TouchEvent
.param .result: bool (size: 4, cast: variable(bool))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: '@public'
.value: {
	return .result := event.release && event.clicks < 0;
}
.instructions: (28 bytes)
	cmplGfx/lib/micro.ui.core.ci:211: (28 bytes): return .result := event.release && event.clicks < 0;
	<isLongPress>  : dup.x32 sp(1)
	<isLongPress+?>: load.is8
	<isLongPress+?>: dup.x32 sp(0)
	<isLongPress+?>: jz +17
	<isLongPress+?>: inc.sp(-4)
	<isLongPress+?>: dup.x32 sp(1)
	<isLongPress+?>: inc.i32(+4)
	<isLongPress+?>: load.i32
	<isLongPress+?>: load.z32
	<isLongPress+?>: clt.i32
	<isLongPress+?>: load.sp(+12)
	<isLongPress+?>: store.i8
	<isLongPress+?>: ret
.usages:
}
TouchEvent.isPress(event: TouchEvent, button: int32): bool: function {
.kind: static function
.base: `function`
.size: 66
.name: 'isPress'
.file: 'cmplGfx/lib/micro.ui.core.ci:215'
.owner: TouchEvent
.param .result: bool (size: 4, cast: variable(bool))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.param button: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	if (event.release || (event.dx) || (event.dy)) {
		return .result := false;
	}
	return .result := event.button == button;
}
.instructions: (66 bytes)
	cmplGfx/lib/micro.ui.core.ci:216: (50 bytes): if (event.release || (event.dx) || (event.dy))
	<isPress>  : dup.x32 sp(2)
	<isPress+?>: load.is8
	<isPress+?>: dup.x32 sp(0)
	<isPress+?>: jnz +16
	<isPress+?>: inc.sp(-4)
	<isPress+?>: dup.x32 sp(2)
	<isPress+?>: inc.i32(+12)
	<isPress+?>: load.i32
	<isPress+?>: i32.2bool
	<isPress+?>: dup.x32 sp(0)
	<isPress+?>: jnz +16
	<isPress+?>: inc.sp(-4)
	<isPress+?>: dup.x32 sp(2)
	<isPress+?>: inc.i32(+16)
	<isPress+?>: load.i32
	<isPress+?>: i32.2bool
	<isPress+?>: jz +11
	cmplGfx/lib/micro.ui.core.ci:217: (7 bytes): return .result := false;
	<isPress+?>: load.z32
	<isPress+?>: load.sp(+16)
	<isPress+?>: store.i8
	<isPress+?>: ret
	cmplGfx/lib/micro.ui.core.ci:219: (16 bytes): return .result := event.button == button;
	<isPress+?>: dup.x32 sp(2)
	<isPress+?>: inc.i32(+8)
	<isPress+?>: load.i32
	<isPress+?>: dup.x32 sp(2)
	<isPress+?>: ceq.i32
	<isPress+?>: load.sp(+16)
	<isPress+?>: store.i8
	<isPress+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:685: referenced as `isPress`
}
View: object {
.kind: static const typename(ref)
.base: `object`
.size: 64
.name: 'View'
.file: 'cmplGfx/lib/micro.ui.core.ci:227'
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'View is the base class of all user interface elements.
it has width and height, forming a rectangular shape on screen.
by it's own a view has no position, it must be positioned in a layout.'
.usages:
	cmplGfx/lib/micro.ui.ci:1062: referenced as `View`
	cmplGfx/lib/micro.ui.ci:1052: referenced as `View`
	cmplGfx/lib/micro.ui.ci:1039: referenced as `View`
	cmplGfx/lib/micro.ui.ci:1029: referenced as `View`
	cmplGfx/lib/micro.ui.ci:1024: referenced as `View`
	cmplGfx/lib/micro.ui.ci:1000: referenced as `View`
	cmplGfx/lib/micro.ui.ci:885: referenced as `View`
	cmplGfx/lib/micro.ui.ci:801: referenced as `View`
	cmplGfx/lib/micro.ui.ci:726: referenced as `View`
	cmplGfx/lib/micro.ui.ci:691: referenced as `View`
	cmplGfx/lib/micro.ui.ci:675: referenced as `View`
	cmplGfx/lib/micro.ui.ci:634: referenced as `View`
	cmplGfx/lib/micro.ui.ci:564: referenced as `View`
	cmplGfx/lib/micro.ui.ci:553: referenced as `View`
	cmplGfx/lib/micro.ui.ci:552: referenced as `View`
	cmplGfx/lib/micro.ui.ci:485: referenced as `View`
	cmplGfx/lib/micro.ui.ci:413: referenced as `View`
	cmplGfx/lib/micro.ui.ci:368: referenced as `View`
	cmplGfx/lib/micro.ui.ci:362: referenced as `View`
	cmplGfx/lib/micro.ui.ci:361: referenced as `View`
	cmplGfx/lib/micro.ui.ci:331: referenced as `View`
	cmplGfx/lib/micro.ui.ci:326: referenced as `View`
	cmplGfx/lib/micro.ui.ci:294: referenced as `View`
	cmplGfx/lib/micro.ui.ci:279: referenced as `View`
	cmplGfx/lib/micro.ui.ci:243: referenced as `View`
	cmplGfx/lib/micro.ui.ci:232: referenced as `View`
	cmplGfx/lib/micro.ui.ci:222: referenced as `View`
	cmplGfx/lib/micro.ui.ci:221: referenced as `View`
	cmplGfx/lib/micro.ui.ci:180: referenced as `View`
	cmplGfx/lib/micro.ui.ci:175: referenced as `View`
	cmplGfx/lib/micro.ui.ci:138: referenced as `View`
	cmplGfx/lib/micro.ui.ci:119: referenced as `View`
	cmplGfx/lib/micro.ui.ci:113: referenced as `View`
	cmplGfx/lib/micro.ui.ci:108: referenced as `View`
	cmplGfx/lib/micro.ui.ci:98: referenced as `View`
	cmplGfx/lib/micro.ui.ci:88: referenced as `View`
	cmplGfx/lib/micro.ui.ci:87: referenced as `View`
	cmplGfx/lib/micro.ui.ci:20: referenced as `View`
	cmplGfx/lib/micro.ui.ci:15: referenced as `View`
	cmplGfx/lib/micro.ui.ci:11: referenced as `View`
	cmplGfx/lib/micro.ui.ci:4: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1305: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1300: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1295: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1292: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1283: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1265: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1246: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1243: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1232: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1231: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1185: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1162: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1156: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1150: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1135: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1120: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1092: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1087: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1076: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1071: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1066: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1055: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1037: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:1020: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:954: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:869: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:798: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:762: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:675: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:639: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:621: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:613: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:611: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:609: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:601: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:572: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:535: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:531: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:530: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:529: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:496: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:489: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:480: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:478: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:474: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:465: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:463: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:459: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:448: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:440: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:432: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:396: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:392: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:389: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:383: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:382: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:363: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:347: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:344: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:331: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:298: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:278: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:275: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:265: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:265: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:260: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:255: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:250: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:250: referenced as `View`
	cmplGfx/lib/micro.ui.core.ci:241: referenced as `View`
}
View.width: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'width'
.file: 'cmplGfx/lib/micro.ui.core.ci:229'
.owner: View
.doc: 'fixed or minimum width of the view'
.value: -5
.usages:
	cmplGfx/lib/micro.ui.ci:985: referenced as `width`
	cmplGfx/lib/micro.ui.ci:727: referenced as `width`
	cmplGfx/lib/micro.ui.ci:407: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:1009: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:1009: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:956: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:926: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:926: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:871: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:841: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:841: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:333: referenced as `width`
	cmplGfx/lib/micro.ui.core.ci:332: referenced as `width`
	internal usages: 9
}
View.height: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'height'
.file: 'cmplGfx/lib/micro.ui.core.ci:232'
.owner: View
.doc: 'fixed or minimum height of the view'
.value: -5
.usages:
	cmplGfx/lib/micro.ui.ci:986: referenced as `height`
	cmplGfx/lib/micro.ui.ci:728: referenced as `height`
	cmplGfx/lib/micro.ui.ci:410: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:1010: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:1010: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:960: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:927: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:927: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:875: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:842: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:842: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:337: referenced as `height`
	cmplGfx/lib/micro.ui.core.ci:336: referenced as `height`
	internal usages: 9
}
View.enabled: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'enabled'
.file: 'cmplGfx/lib/micro.ui.core.ci:235'
.owner: View
.doc: 'the view accepts any user input(event) or not'
.value: true
.usages:
	cmplGfx/lib/micro.ui.ci:1269: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:928: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:921: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:921: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:913: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:913: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:900: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:898: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:729: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:112: referenced as `enabled`
	cmplGfx/lib/micro.ui.ci:97: referenced as `enabled`
	cmplGfx/lib/micro.ui.core.ci:1097: referenced as `enabled`
	cmplGfx/lib/micro.ui.core.ci:676: referenced as `enabled`
	cmplGfx/lib/micro.ui.core.ci:654: referenced as `enabled`
	cmplGfx/lib/micro.ui.core.ci:647: referenced as `enabled`
	cmplGfx/lib/micro.ui.core.ci:629: referenced as `enabled`
	cmplGfx/lib/micro.ui.core.ci:536: referenced as `enabled`
	cmplGfx/lib/micro.ui.core.ci:307: referenced as `enabled`
	cmplGfx/lib/micro.ui.core.ci:279: referenced as `enabled`
	internal usages: 9
}
View.focusable: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'focusable'
.file: 'cmplGfx/lib/micro.ui.core.ci:238'
.owner: View
.doc: 'the view can be active(focused) or not'
.value: true
.usages:
	cmplGfx/lib/micro.ui.ci:730: referenced as `focusable`
	cmplGfx/lib/micro.ui.ci:702: referenced as `focusable`
	cmplGfx/lib/micro.ui.ci:270: referenced as `focusable`
	cmplGfx/lib/micro.ui.ci:70: referenced as `focusable`
	cmplGfx/lib/micro.ui.core.ci:1101: referenced as `focusable`
	cmplGfx/lib/micro.ui.core.ci:718: referenced as `focusable`
	cmplGfx/lib/micro.ui.core.ci:537: referenced as `focusable`
	internal usages: 8
}
View.parent: View {
.kind: variable(ref)
.base: `View`
.size: 4
.name: 'parent'
.file: 'cmplGfx/lib/micro.ui.core.ci:241'
.owner: View
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:1102: referenced as `parent`
	cmplGfx/lib/micro.ui.ci:890: referenced as `parent`
	cmplGfx/lib/micro.ui.ci:664: referenced as `parent`
	cmplGfx/lib/micro.ui.ci:664: referenced as `parent`
	cmplGfx/lib/micro.ui.core.ci:1237: referenced as `parent`
	cmplGfx/lib/micro.ui.core.ci:1232: referenced as `parent`
	cmplGfx/lib/micro.ui.core.ci:610: referenced as `parent`
	cmplGfx/lib/micro.ui.core.ci:355: referenced as `parent`
	cmplGfx/lib/micro.ui.core.ci:267: referenced as `parent`
	cmplGfx/lib/micro.ui.core.ci:266: referenced as `parent`
	cmplGfx/lib/micro.ui.core.ci:266: referenced as `parent`
	cmplGfx/lib/micro.ui.core.ci:251: referenced as `parent`
	internal usages: 11
}
View.style: Style {
.kind: variable(ref)
.base: `Style`
.size: 4
.name: 'style'
.file: 'cmplGfx/lib/micro.ui.core.ci:244'
.owner: View
.doc: 'style to be used when measuring and drawing the view'
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:1009: referenced as `style`
	cmplGfx/lib/micro.ui.ci:987: referenced as `style`
	cmplGfx/lib/micro.ui.ci:969: referenced as `style`
	cmplGfx/lib/micro.ui.ci:665: referenced as `style`
	cmplGfx/lib/micro.ui.ci:637: referenced as `style`
	cmplGfx/lib/micro.ui.ci:577: referenced as `style`
	cmplGfx/lib/micro.ui.ci:562: referenced as `style`
	cmplGfx/lib/micro.ui.ci:321: referenced as `style`
	cmplGfx/lib/micro.ui.ci:319: referenced as `style`
	cmplGfx/lib/micro.ui.ci:302: referenced as `style`
	cmplGfx/lib/micro.ui.ci:284: referenced as `style`
	cmplGfx/lib/micro.ui.ci:143: referenced as `style`
	cmplGfx/lib/micro.ui.ci:124: referenced as `style`
	cmplGfx/lib/micro.ui.ci:9: referenced as `style`
	cmplGfx/lib/micro.ui.core.ci:1225: referenced as `style`
	cmplGfx/lib/micro.ui.core.ci:364: referenced as `style`
	cmplGfx/lib/micro.ui.core.ci:355: referenced as `style`
	cmplGfx/lib/micro.ui.core.ci:348: referenced as `style`
	cmplGfx/lib/micro.ui.core.ci:270: referenced as `style`
	cmplGfx/lib/micro.ui.core.ci:270: referenced as `style`
	cmplGfx/lib/micro.ui.core.ci:269: referenced as `style`
	cmplGfx/lib/micro.ui.core.ci:268: referenced as `style`
	internal usages: 9
}
View.data: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'data'
.file: 'cmplGfx/lib/micro.ui.core.ci:247'
.owner: View
.doc: 'user attached data'
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:846: referenced as `data`
	cmplGfx/lib/micro.ui.ci:760: referenced as `data`
	cmplGfx/lib/micro.ui.ci:713: referenced as `data`
	cmplGfx/lib/micro.ui.ci:701: referenced as `data`
	cmplGfx/lib/micro.ui.ci:694: referenced as `data`
	cmplGfx/lib/micro.ui.ci:679: referenced as `data`
	cmplGfx/lib/micro.ui.ci:678: referenced as `data`
	cmplGfx/lib/micro.ui.ci:666: referenced as `data`
	cmplGfx/lib/micro.ui.ci:658: referenced as `data`
	cmplGfx/lib/micro.ui.ci:652: referenced as `data`
	cmplGfx/lib/micro.ui.ci:642: referenced as `data`
	internal usages: 7
}
View.parent(this: View): View: function {
.kind: static function
.base: `function`
.size: 10
.name: 'parent'
.file: 'cmplGfx/lib/micro.ui.core.ci:250'
.owner: View
.param .result: View (size: 4, cast: variable(ref))
.param this: View (size: 4, cast: variable(ref))
.doc: 'Returns the parent of the view'
.value: {
	return .result := this.parent;
}
.instructions: (10 bytes)
	cmplGfx/lib/micro.ui.core.ci:251: (10 bytes): return .result := this.parent;
	<parent>  : dup.x32 sp(1)
	<parent+?>: inc.i32(+16)
	<parent+?>: load.i32
	<parent+?>: set.x32 sp(3)
	<parent+?>: ret
.usages:
}
View.onClick(this: View): bool: function {
.kind: static function
.base: `function`
.size: 11
.name: 'onClick'
.file: 'cmplGfx/lib/micro.ui.core.ci:255'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is clicked'
.value: {
	return .result := true;
}
.instructions: (11 bytes)
	cmplGfx/lib/micro.ui.core.ci:256: (11 bytes): return .result := true;
	<onClick>  : load.c32 1
	<onClick+?>: load.sp(+12)
	<onClick+?>: store.i8
	<onClick+?>: ret
.usages:
}
View.onClick(this: View): bool: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onClick'
.file: 'cmplGfx/lib/micro.ui.core.ci:255'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is clicked'
.value: onClick
.usages:
	cmplGfx/lib/micro.ui.ci:704: referenced as `onClick`
	cmplGfx/lib/micro.ui.core.ci:327: referenced as `onClick`
	cmplGfx/lib/micro.ui.core.ci:288: referenced as `onClick`
	internal usages: 10
}
View.onReset(this: View): bool: function {
.kind: static function
.base: `function`
.size: 7
.name: 'onReset'
.file: 'cmplGfx/lib/micro.ui.core.ci:260'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is double clicked'
.value: {
	return .result := false;
}
.instructions: (7 bytes)
	cmplGfx/lib/micro.ui.core.ci:261: (7 bytes): return .result := false;
	<onReset>  : load.z32
	<onReset+?>: load.sp(+12)
	<onReset+?>: store.i8
	<onReset+?>: ret
.usages:
}
View.onReset(this: View): bool: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onReset'
.file: 'cmplGfx/lib/micro.ui.core.ci:260'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is double clicked'
.value: onReset
.usages:
	cmplGfx/lib/micro.ui.ci:943: referenced as `onReset`
	cmplGfx/lib/micro.ui.ci:534: referenced as `onReset`
	cmplGfx/lib/micro.ui.ci:251: referenced as `onReset`
	cmplGfx/lib/micro.ui.ci:235: referenced as `onReset`
	cmplGfx/lib/micro.ui.ci:227: referenced as `onReset`
	cmplGfx/lib/micro.ui.ci:93: referenced as `onReset`
	cmplGfx/lib/micro.ui.core.ci:602: referenced as `onReset`
	cmplGfx/lib/micro.ui.core.ci:322: referenced as `onReset`
	cmplGfx/lib/micro.ui.core.ci:318: referenced as `onReset`
	cmplGfx/lib/micro.ui.core.ci:292: referenced as `onReset`
	internal usages: 11
}
View.onCreate(this: View, parent: View): void: function {
.kind: static function
.base: `function`
.size: 183
.name: 'onCreate'
.file: 'cmplGfx/lib/micro.ui.core.ci:265'
.owner: View
.param .result: void (size: 0, cast: variable(void))
.param this: View (size: 4, cast: variable(ref))
.param parent: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is created'
.value: {
	assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
	this.parent := parent;
	if ((this.style) == null) {
		assert((parent.style) != null, "can not create view with a parent without a style");
		this.style := emit(pointer(parent.style));
	}
}
.instructions: (183 bytes)
	cmplGfx/lib/micro.ui.core.ci:266: (81 bytes): assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
	<onCreate>  : load.z32
	<onCreate+?>: load.sp(+4)
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: inc.i32(+16)
	<onCreate+?>: load.i32
	<onCreate+?>: load.ref <?> ;null
	<onCreate+?>: ceq.i32
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: jnz +18
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: inc.i32(+16)
	<onCreate+?>: load.i32
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: ceq.i32
	<onCreate+?>: jz +8
	<onCreate+?>: jmp +35
	<onCreate+?>: load.ref <?> ;"cmplGfx/lib/micro.ui.core.ci"
	<onCreate+?>: load.c32 266
	<onCreate+?>: load.c32 -2
	<onCreate+?>: load.c32 128
	<onCreate+?>: load.ref <?> ;"can not add the same view to different layouts"
	<onCreate+?>: dup.x64 sp(5)
	<onCreate+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:267: (9 bytes): this.parent := parent;
	<onCreate+?>: dup.x32 sp(1)
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: inc.i32(+16)
	<onCreate+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:268: (92 bytes): if ((this.style) == null)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: inc.i32(+20)
	<onCreate+?>: load.i32
	<onCreate+?>: load.ref <?> ;null
	<onCreate+?>: ceq.i32
	<onCreate+?>: jz +79
	cmplGfx/lib/micro.ui.core.ci:269: (61 bytes): assert((parent.style) != null, "can not create view with a parent without a style");
	<onCreate+?>: load.z32
	<onCreate+?>: load.sp(+4)
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: inc.i32(+20)
	<onCreate+?>: load.i32
	<onCreate+?>: load.ref <?> ;null
	<onCreate+?>: ceq.i32
	<onCreate+?>: jnz +8
	<onCreate+?>: jmp +35
	<onCreate+?>: load.ref <?> ;"cmplGfx/lib/micro.ui.core.ci"
	<onCreate+?>: load.c32 269
	<onCreate+?>: load.c32 -2
	<onCreate+?>: load.c32 128
	<onCreate+?>: load.ref <?> ;"can not create view with a parent without a style"
	<onCreate+?>: dup.x64 sp(5)
	<onCreate+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:270: (14 bytes): this.style := emit(pointer(parent.style))
	<onCreate+?>: dup.x32 sp(1)
	<onCreate+?>: inc.i32(+20)
	<onCreate+?>: load.i32
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: inc.i32(+20)
	<onCreate+?>: store.i32
	<onCreate+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:553: referenced as `onCreate`
	cmplGfx/lib/micro.ui.ci:362: referenced as `onCreate`
	cmplGfx/lib/micro.ui.ci:222: referenced as `onCreate`
	cmplGfx/lib/micro.ui.ci:88: referenced as `onCreate`
	cmplGfx/lib/micro.ui.core.ci:611: referenced as `onCreate`
}
View.onCreate(this: View, parent: View): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onCreate'
.file: 'cmplGfx/lib/micro.ui.core.ci:265'
.owner: View
.param .result: void (size: 0, cast: variable(void))
.param this: View (size: 4, cast: variable(ref))
.param parent: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is created'
.value: onCreate
.usages:
	cmplGfx/lib/micro.ui.ci:1349: referenced as `onCreate`
	cmplGfx/lib/micro.ui.ci:1104: referenced as `onCreate`
	cmplGfx/lib/micro.ui.core.ci:614: referenced as `onCreate`
	internal usages: 11
}
View.onDestroy(this: View): void: function {
.kind: static function
.base: `function`
.size: 1
.name: 'onDestroy'
.file: 'cmplGfx/lib/micro.ui.core.ci:275'
.owner: View
.param .result: void (size: 0, cast: variable(void))
.param this: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is destroyed'
.value: {
}
.instructions: (1 byte)
	<onDestroy>  : ret
.usages:
}
View.onDestroy(this: View): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onDestroy'
.file: 'cmplGfx/lib/micro.ui.core.ci:275'
.owner: View
.param .result: void (size: 0, cast: variable(void))
.param this: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is destroyed'
.value: onDestroy
.usages:
	cmplGfx/lib/micro.ui.ci:1111: referenced as `onDestroy`
	cmplGfx/lib/micro.ui.core.ci:622: referenced as `onDestroy`
	internal usages: 11
}
View.onKeyEvent(this: View, event: KeyEvent): bool: function {
.kind: static function
.base: `function`
.size: 120
.name: 'onKeyEvent'
.file: 'cmplGfx/lib/micro.ui.core.ci:278'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.param event: KeyEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a KeyEvent: press or release'
.value: {
	if (!this.enabled) {
		return .result := false;
	}
	if (event.release) {
		return .result := false;
	}
	if (event.key == (' ')) {
		return .result := this.onClick(this);
	}
	if ((event.key) == Window.KEY_CODE_BACK) {
		return .result := this.onReset(this);
	}
	return .result := false;
}
.instructions: (120 bytes)
	cmplGfx/lib/micro.ui.core.ci:279: (18 bytes): if (!this.enabled)
	<onKeyEvent>  : dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jnz +11
	cmplGfx/lib/micro.ui.core.ci:281: (7 bytes): return .result := false;
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:283: (14 bytes): if (event.release)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jz +11
	cmplGfx/lib/micro.ui.core.ci:284: (7 bytes): return .result := false;
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:286: (38 bytes): if (event.key == (' '))
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 32
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +25
	cmplGfx/lib/micro.ui.core.ci:288: (21 bytes): return .result := this.onClick(this);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+32)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:290: (43 bytes): if ((event.key) == Window.KEY_CODE_BACK)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: i32.2i64
	<onKeyEvent+?>: load.c64 65288
	<onKeyEvent+?>: ceq.i64
	<onKeyEvent+?>: jz +25
	cmplGfx/lib/micro.ui.core.ci:292: (21 bytes): return .result := this.onReset(this);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+36)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:294: (7 bytes): return .result := false;
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:243: referenced as `onKeyEvent`
	cmplGfx/lib/micro.ui.ci:232: referenced as `onKeyEvent`
	cmplGfx/lib/micro.ui.ci:108: referenced as `onKeyEvent`
	cmplGfx/lib/micro.ui.ci:98: referenced as `onKeyEvent`
}
View.onKeyEvent(this: View, event: KeyEvent): bool: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onKeyEvent'
.file: 'cmplGfx/lib/micro.ui.core.ci:278'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.param event: KeyEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a KeyEvent: press or release'
.value: onKeyEvent
.usages:
	cmplGfx/lib/micro.ui.ci:1244: referenced as `onKeyEvent`
	cmplGfx/lib/micro.ui.ci:1228: referenced as `onKeyEvent`
	cmplGfx/lib/micro.ui.core.ci:640: referenced as `onKeyEvent`
	internal usages: 11
}
View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool: function {
.kind: static function
.base: `function`
.size: 134
.name: 'onTouchEvent'
.file: 'cmplGfx/lib/micro.ui.core.ci:298'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: const variable(ref))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a TouchEvent: press, motion or release'
.value: {
	if (!this.enabled) {
		return .result := false;
	}
	if (!event.release) {
		return .result := false;
	}
	if (event.clicks < 0) {
		return .result := this.onReset(this);
	}
	if (event.clicks > 1) {
		if (this.onReset(this)) {
			return .result := true;
		}
	}
	return .result := this.onClick(this);
}
.instructions: (134 bytes)
	cmplGfx/lib/micro.ui.core.ci:307: (18 bytes): if (!this.enabled)
	<onTouchEvent>  : dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+12)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jnz +11
	cmplGfx/lib/micro.ui.core.ci:309: (7 bytes): return .result := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:311: (14 bytes): if (!event.release)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jnz +11
	cmplGfx/lib/micro.ui.core.ci:313: (7 bytes): return .result := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:316: (34 bytes): if (event.clicks < 0)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: clt.i32
	<onTouchEvent+?>: jz +25
	cmplGfx/lib/micro.ui.core.ci:318: (21 bytes): return .result := this.onReset(this);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+36)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:320: (47 bytes): if (event.clicks > 1)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: cgt.i32
	<onTouchEvent+?>: jz +34
	cmplGfx/lib/micro.ui.core.ci:322: (30 bytes): if (this.onReset(this))
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+36)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: jz +15
	cmplGfx/lib/micro.ui.core.ci:324: (11 bytes): return .result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:327: (21 bytes): return .result := this.onClick(this);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+32)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:368: referenced as `onTouchEvent`
	cmplGfx/lib/micro.ui.ci:279: referenced as `onTouchEvent`
	cmplGfx/lib/micro.ui.ci:119: referenced as `onTouchEvent`
	cmplGfx/lib/micro.ui.ci:113: referenced as `onTouchEvent`
}
View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onTouchEvent'
.file: 'cmplGfx/lib/micro.ui.core.ci:298'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: const variable(ref))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a TouchEvent: press, motion or release'
.value: onTouchEvent
.usages:
	cmplGfx/lib/micro.ui.ci:1260: referenced as `onTouchEvent`
	cmplGfx/lib/micro.ui.ci:1206: referenced as `onTouchEvent`
	cmplGfx/lib/micro.ui.ci:1184: referenced as `onTouchEvent`
	cmplGfx/lib/micro.ui.ci:1157: referenced as `onTouchEvent`
	cmplGfx/lib/micro.ui.ci:893: referenced as `onTouchEvent`
	cmplGfx/lib/micro.ui.core.ci:709: referenced as `onTouchEvent`
	internal usages: 11
}
View.onMeasure(this: View, rect: Rect): bool: function {
.kind: static function
.base: `function`
.size: 181
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.core.ci:331'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	width: int32 := Math.abs(this.width);
	if (width(rect) < width || this.width > 0) {
		width(rect, width);
	}
	height: int32 := Math.abs(this.height);
	if (height(rect) < height || this.height > 0) {
		height(rect, height);
	}
	return .result := true;
}
.instructions: (181 bytes)
	cmplGfx/lib/micro.ui.core.ci:332: (26 bytes): width: int32 := Math.abs(this.width)
	<onMeasure>  : dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+4)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: load.z32
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jz +11
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: neg.i32
	<onMeasure+?>: jmp +6
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:333: (55 bytes): if (width(rect) < width || this.width > 0)
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: clt.i32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: jnz +17
	<onMeasure+?>: inc.sp(-4)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: inc.i32(+4)
	<onMeasure+?>: load.i32
	<onMeasure+?>: load.z32
	<onMeasure+?>: cgt.i32
	<onMeasure+?>: jz +18
	cmplGfx/lib/micro.ui.core.ci:334: (14 bytes): width(rect, width);
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.ref <?> ;width(rectangle: Rect, width: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:336: (26 bytes): height: int32 := Math.abs(this.height)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: load.z32
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jz +11
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: neg.i32
	<onMeasure+?>: jmp +6
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:337: (59 bytes): if (height(rect) < height || this.height > 0)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+12)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: inc.i32(+4)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: clt.i32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: jnz +17
	<onMeasure+?>: inc.sp(-4)
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: load.z32
	<onMeasure+?>: cgt.i32
	<onMeasure+?>: jz +18
	cmplGfx/lib/micro.ui.core.ci:338: (14 bytes): height(rect, height);
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.ref <?> ;height(rectangle: Rect, height: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:340: (15 bytes): return .result := true;
	<onMeasure+?>: load.c32 1
	<onMeasure+?>: load.sp(+24)
	<onMeasure+?>: store.i8
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:564: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.ci:413: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.ci:294: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.ci:138: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.ci:11: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.core.ci:798: referenced as `onMeasure`
}
View.onMeasure(this: View, rect: Rect): bool: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.core.ci:331'
.owner: View
.param .result: bool (size: 4, cast: variable(bool))
.param this: View (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: onMeasure
.usages:
	cmplGfx/lib/micro.ui.ci:1350: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.ci:1285: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.ci:697: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.core.ci:1275: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.core.ci:765: referenced as `onMeasure`
	internal usages: 10
}
View.onDraw(this: View, offs: Image, rect: Rect): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.core.ci:344'
.owner: View
.param .result: void (size: 0, cast: variable(void))
.param this: View (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.doc: 'Callback function executed when the view needs to be drawn'
.usages:
	cmplGfx/lib/micro.ui.ci:731: referenced as `onDraw`
	cmplGfx/lib/micro.ui.ci:714: referenced as `onDraw`
	cmplGfx/lib/micro.ui.ci:703: referenced as `onDraw`
	cmplGfx/lib/micro.ui.ci:696: referenced as `onDraw`
	cmplGfx/lib/micro.ui.core.ci:538: referenced as `onDraw`
	cmplGfx/lib/micro.ui.core.ci:358: referenced as `onDraw`
	internal usages: 6
}
View.onDraw(this: View, offs: Image, rect: Rect, state: int32): void: function {
.kind: static function
.base: `function`
.size: 181
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.core.ci:347'
.owner: View
.param .result: void (size: 0, cast: variable(void))
.param this: View (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.param state: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	const style: Style := this.style;
	if (state & Style.focused) {
		fillRect(offs, rect, style.focusedColor);
	}
	else if (state & Style.hovered) {
		fillRect(offs, rect, style.hoveredColor);
	}
	else if ((this.parent.style) != pointer(style)) {
		fillRect(offs, rect, style.backgroundColor);
	}
	this.onDraw(this, offs, rect);
	if (state & Style.pressed) {
		drawRect(offs, rect, style.valueColor);
	}
}
.instructions: (181 bytes)
	cmplGfx/lib/micro.ui.core.ci:348: (7 bytes): const style: Style := this.style
	<onDraw>  : dup.x32 sp(8)
	<onDraw+?>: inc.i32(+20)
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:349: (116 bytes): if (state & Style.focused)
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: load.c32 4
	<onDraw+?>: and.b32
	<onDraw+?>: jz +31
	cmplGfx/lib/micro.ui.core.ci:350: (23 bytes): fillRect(offs, rect, style.focusedColor);
	<onDraw+?>: dup.x64 sp(7)
	<onDraw+?>: load.sp(+20)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: inc.i32(+40)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, roi: Rect, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-16)
	<onDraw+?>: jmp +81
	cmplGfx/lib/micro.ui.core.ci:352: (77 bytes): if (state & Style.hovered)
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: b32.and 0x01
	<onDraw+?>: jz +31
	cmplGfx/lib/micro.ui.core.ci:353: (23 bytes): fillRect(offs, rect, style.hoveredColor);
	<onDraw+?>: dup.x64 sp(7)
	<onDraw+?>: load.sp(+20)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: inc.i32(+36)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, roi: Rect, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-16)
	<onDraw+?>: jmp +46
	cmplGfx/lib/micro.ui.core.ci:355: (42 bytes): if ((this.parent.style) != pointer(style))
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+16)
	<onDraw+?>: load.i32
	<onDraw+?>: inc.i32(+20)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: ceq.i32
	<onDraw+?>: jnz +27
	cmplGfx/lib/micro.ui.core.ci:356: (23 bytes): fillRect(offs, rect, style.backgroundColor);
	<onDraw+?>: dup.x64 sp(7)
	<onDraw+?>: load.sp(+20)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: inc.i32(+32)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, roi: Rect, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.core.ci:358: (18 bytes): this.onDraw(this, offs, rect);
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: dup.x64 sp(8)
	<onDraw+?>: dup.x128 sp(6)
	<onDraw+?>: dup.x32 sp(16)
	<onDraw+?>: inc.i32(+60)
	<onDraw+?>: load.i32
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-28)
	cmplGfx/lib/micro.ui.core.ci:359: (35 bytes): if (state & Style.pressed)
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: load.c32 2
	<onDraw+?>: and.b32
	<onDraw+?>: jz +27
	cmplGfx/lib/micro.ui.core.ci:360: (23 bytes): drawRect(offs, rect, style.valueColor);
	<onDraw+?>: dup.x64 sp(7)
	<onDraw+?>: load.sp(+20)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: inc.i32(+44)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;drawRect(image: Image, roi: Rect, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-16)
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:1289: referenced as `onDraw`
	cmplGfx/lib/micro.ui.core.ci:1050: referenced as `onDraw`
}
View.onDraw(this: View, offs: Image, rect: Rect, text: char[*], value: char[*]): void: function {
.kind: static function
.base: `function`
.size: 202
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.core.ci:363'
.owner: View
.param .result: void (size: 0, cast: variable(void))
.param this: View (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.param text: char[*] (size: 4, cast: const variable(ref))
.param value: char[*] (size: 4, cast: const variable(ref))
.value: {
	const style: Style := this.style;
	if ((text) == null) {
		Style.align(style, rect, &rect, value);
		Image.drawText(offs, rect, style.font, value, style.valueColor);
		return;
	}
	if ((value) != null) {
		valueRoi: Rect := rect;
		Style.align(style, valueRoi, &valueRoi, value, Style.right);
		Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
		rect.x1 := valueRoi.x0 - style.padding;
	}
	Style.align(style, rect, &rect, text);
	Image.drawText(offs, rect, style.font, text, style.textColor);
}
.instructions: (202 bytes)
	cmplGfx/lib/micro.ui.core.ci:364: (7 bytes): const style: Style := this.style
	<onDraw>  : dup.x32 sp(9)
	<onDraw+?>: inc.i32(+20)
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:365: (63 bytes): if ((text) == null)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: load.ref <?> ;null
	<onDraw+?>: ceq.i32
	<onDraw+?>: jz +55
	cmplGfx/lib/micro.ui.core.ci:366: (20 bytes): Style.align(style, rect, &rect, value);
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: dup.x128 sp(5)
	<onDraw+?>: load.sp(+36)
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: load.ref <?> ;Style.align(this: Style, parent: Rect, rect: Rect, value: char[*]): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-28)
	cmplGfx/lib/micro.ui.core.ci:367: (26 bytes): Image.drawText(offs, rect, style.font, value, style.valueColor);
	<onDraw+?>: dup.x64 sp(8)
	<onDraw+?>: load.sp(+24)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: inc.i32(+8)
	<onDraw+?>: load.i64
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: inc.i32(+44)
	<onDraw+?>: load.i32
	<onDraw+?>: nfc(108) ;Image.drawText(image: Image, roi: Rect, font: Image, text: char[*], color: int32): void
	cmplGfx/lib/micro.ui.core.ci:368: (5 bytes): return;
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: ret
	cmplGfx/lib/micro.ui.core.ci:371: (81 bytes): if ((value) != null)
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: load.ref <?> ;null
	<onDraw+?>: ceq.i32
	<onDraw+?>: jnz +73
	cmplGfx/lib/micro.ui.core.ci:372: (2 bytes): valueRoi: Rect := rect
	<onDraw+?>: dup.x128 sp(4)
	cmplGfx/lib/micro.ui.core.ci:373: (25 bytes): Style.align(style, valueRoi, &valueRoi, value, Style.right);
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x128 sp(1)
	<onDraw+?>: load.sp(+20)
	<onDraw+?>: dup.x32 sp(12)
	<onDraw+?>: load.c32 4
	<onDraw+?>: load.ref <?> ;Style.align(this: Style, parent: Rect, rect: Rect, value: char[*], align: int32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-32)
	cmplGfx/lib/micro.ui.core.ci:374: (26 bytes): Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
	<onDraw+?>: dup.x64 sp(12)
	<onDraw+?>: load.sp(+8)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: inc.i32(+8)
	<onDraw+?>: load.i64
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: inc.i32(+44)
	<onDraw+?>: load.i32
	<onDraw+?>: nfc(108) ;Image.drawText(image: Image, roi: Rect, font: Image, text: char[*], color: int32): void
	cmplGfx/lib/micro.ui.core.ci:375: (12 bytes): rect.x1 := valueRoi.x0 - style.padding;
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: inc.i32(+4)
	<onDraw+?>: load.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(11)
	<onDraw+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.core.ci:377: (20 bytes): Style.align(style, rect, &rect, text);
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: dup.x128 sp(5)
	<onDraw+?>: load.sp(+36)
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: load.ref <?> ;Style.align(this: Style, parent: Rect, rect: Rect, value: char[*]): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-28)
	cmplGfx/lib/micro.ui.core.ci:378: (26 bytes): Image.drawText(offs, rect, style.font, text, style.textColor);
	<onDraw+?>: dup.x64 sp(8)
	<onDraw+?>: load.sp(+24)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: inc.i32(+8)
	<onDraw+?>: load.i64
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: inc.i32(+48)
	<onDraw+?>: load.i32
	<onDraw+?>: nfc(108) ;Image.drawText(image: Image, roi: Rect, font: Image, text: char[*], color: int32): void
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:326: referenced as `onDraw`
	cmplGfx/lib/micro.ui.ci:175: referenced as `onDraw`
	cmplGfx/lib/micro.ui.ci:15: referenced as `onDraw`
}
focus(view: View): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.name: 'focus'
.file: 'cmplGfx/lib/micro.ui.core.ci:382'
.param .result: void (size: 0, cast: variable(void))
.param view: View (size: 4, cast: variable(ref))
.value: focus
.usages:
	cmplGfx/lib/micro.ui.core.ci:1190: referenced as `focus`
}
invalidate(view: View, layout: bool): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.name: 'invalidate'
.file: 'cmplGfx/lib/micro.ui.core.ci:383'
.param .result: void (size: 0, cast: variable(void))
.param view: View (size: 4, cast: variable(ref))
.param layout: bool (size: 4, cast: variable(bool))
.value: invalidate
.usages:
	cmplGfx/lib/micro.ui.core.ci:589: referenced as `invalidate`
}
Layout: View {
.kind: static const typename(ref)
.base: `View`
.size: 116
.name: 'Layout'
.file: 'cmplGfx/lib/micro.ui.core.ci:389'
.field Item: typename (size: 24, cast: static const typename(val))
.field separator: View (size: 4, cast: variable(ref))
.field items: Layout.Item[*] (size: 4, cast: variable(ref))
.field itemCount: int32 (size: 4, cast: variable(i32))
.field itemCapacity: int32 (size: 4, cast: variable(i32))
.field hoveredIndex: int32 (size: 4, cast: variable(i32))
.field pressedIndex: int32 (size: 4, cast: variable(i32))
.field focusedIndex: int32 (size: 4, cast: variable(i32))
.field paddingTop: int32 (size: 4, cast: variable(i32))
.field paddingLeft: int32 (size: 4, cast: variable(i32))
.field paddingRight: int32 (size: 4, cast: variable(i32))
.field paddingBottom: int32 (size: 4, cast: variable(i32))
.field orientation: int32 (size: 4, cast: variable(i32))
.field clearState: function (size: 396, cast: static function)
.field getPressed: function (size: 114, cast: static function)
.field getFocused: function (size: 114, cast: static function)
.field setFocused: function (size: 283, cast: static function)
.field capacity: function (size: 175, cast: static function)
.field addItems: function (size: 204, cast: static function)
.field size: function (size: 10, cast: static function)
.field getView: function (size: 94, cast: static function)
.field setAlignment: function (size: 94, cast: static function)
.field padding: function (size: 56, cast: static function)
.field onClick: function (size: 58, cast: static function)
.field onReset: function (size: 94, cast: static function)
.field onCreate: function (size: 141, cast: static function)
.field onDestroy: function (size: 86, cast: static function)
.field onKeyEvent: function (size: 89, cast: static function)
.field onTouchEvent: function (size: 799, cast: static function)
.field onMeasure: function (size: 448, cast: static function)
.field onLayout: function (size: 411, cast: static function)
.field onLayout: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 180, cast: static function)
.field Custom: function (size: 364, cast: static function)
.field Row: function (size: 29, cast: static function)
.field Column: function (size: 29, cast: static function)
.field Stack: function (size: 25, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Layout is a view containing other views positioned by it.
the Layout class does not clip its children.
the size of the Layout class should contain all the views.'
.usages:
	cmplGfx/lib/micro.ui.ci:1069: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:1069: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:1052: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:1046: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:1046: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:1029: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:961: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:890: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:890: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:831: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:828: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:746: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:740: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:724: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:719: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:708: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:693: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:679: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:678: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:678: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:666: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:660: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:657: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:654: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:651: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:648: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:641: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:635: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:631: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:630: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:629: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:620: referenced as `Layout`
	cmplGfx/lib/micro.ui.ci:599: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1257: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1257: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1247: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1247: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1244: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1226: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1219: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1196: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1186: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1181: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1175: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1174: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1169: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1168: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1168: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1157: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1151: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1137: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1122: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1106: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1106: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1084: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1076: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1071: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1066: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1056: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1055: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1039: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1029: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1022: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:1022: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:974: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:966: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:966: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:889: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:881: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:881: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:804: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:803: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:749: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:731: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:731: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:644: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:643: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:628: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:618: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:609: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:598: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:593: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:584: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:584: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:578: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:572: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:567: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:530: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:529: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:529: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:513: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:513: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:502: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:502: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:489: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:479: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:479: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:474: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:464: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:464: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:459: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:449: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:449: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:441: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:441: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:433: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:433: referenced as `Layout`
	cmplGfx/lib/micro.ui.core.ci:429: referenced as `Layout`
}
Layout.Item: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'Item'
.file: 'cmplGfx/lib/micro.ui.core.ci:390'
.owner: Layout
.field rect: Rect (size: 16, cast: variable(val))
.field view: View (size: 4, cast: variable(ref))
.field align: int32 (size: 4, cast: variable(i32))
.usages:
	cmplGfx/lib/micro.ui.core.ci:1133: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:1118: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:1031: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:1014: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:933: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:848: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:760: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:674: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:646: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:555: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:523: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:522: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:520: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:494: referenced as `Item`
	cmplGfx/lib/micro.ui.core.ci:398: referenced as `Item`
}
Layout.Item.rect: Rect {
.kind: variable(val)
.base: `Rect`
.size: 16
.name: 'rect'
.file: 'cmplGfx/lib/micro.ui.core.ci:391'
.owner: Layout.Item
.usages:
	cmplGfx/lib/micro.ui.ci:891: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:1134: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:1119: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:1032: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:1015: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:934: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:900: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:849: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:815: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:761: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:709: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:692: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:647: referenced as `rect`
	cmplGfx/lib/micro.ui.core.ci:495: referenced as `rect`
}
Layout.Item.view: View {
.kind: variable(ref)
.base: `View`
.size: 4
.name: 'view'
.file: 'cmplGfx/lib/micro.ui.core.ci:392'
.owner: Layout.Item
.usages:
	cmplGfx/lib/micro.ui.ci:1062: referenced as `view`
	cmplGfx/lib/micro.ui.ci:1039: referenced as `view`
	cmplGfx/lib/micro.ui.ci:790: referenced as `view`
	cmplGfx/lib/micro.ui.ci:636: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:1246: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:1135: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:1120: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:1037: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:1020: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:954: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:869: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:762: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:675: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:647: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:639: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:621: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:613: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:601: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:574: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:559: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:558: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:556: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:496: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:478: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:463: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:448: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:440: referenced as `view`
	cmplGfx/lib/micro.ui.core.ci:432: referenced as `view`
}
Layout.Item.align: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'align'
.file: 'cmplGfx/lib/micro.ui.core.ci:393'
.owner: Layout.Item
.usages:
	cmplGfx/lib/micro.ui.core.ci:1021: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:955: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:870: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:580: referenced as `align`
	cmplGfx/lib/micro.ui.core.ci:557: referenced as `align`
}
Layout.separator: View {
.kind: variable(ref)
.base: `View`
.size: 4
.name: 'separator'
.file: 'cmplGfx/lib/micro.ui.core.ci:396'
.owner: Layout
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:735: referenced as `separator`
	cmplGfx/lib/micro.ui.ci:733: referenced as `separator`
	cmplGfx/lib/micro.ui.ci:725: referenced as `separator`
	cmplGfx/lib/micro.ui.core.ci:540: referenced as `separator`
	cmplGfx/lib/micro.ui.core.ci:533: referenced as `separator`
	cmplGfx/lib/micro.ui.core.ci:532: referenced as `separator`
	internal usages: 6
}
Layout.items: Layout.Item[*] {
.kind: variable(ref)
.base: `Layout.Item[*]`
.size: 4
.name: 'items'
.file: 'cmplGfx/lib/micro.ui.core.ci:398'
.owner: Layout
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:1062: referenced as `items`
	cmplGfx/lib/micro.ui.ci:1039: referenced as `items`
	cmplGfx/lib/micro.ui.ci:891: referenced as `items`
	cmplGfx/lib/micro.ui.ci:790: referenced as `items`
	cmplGfx/lib/micro.ui.ci:636: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:1246: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:1133: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:1118: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:1031: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:1014: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:933: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:900: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:848: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:815: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:760: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:674: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:646: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:639: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:625: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:621: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:613: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:601: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:580: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:574: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:555: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:523: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:522: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:520: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:494: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:478: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:463: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:448: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:440: referenced as `items`
	cmplGfx/lib/micro.ui.core.ci:432: referenced as `items`
	internal usages: 6
}
Layout.itemCount: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'itemCount'
.file: 'cmplGfx/lib/micro.ui.core.ci:399'
.owner: Layout
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:815: referenced as `itemCount`
	cmplGfx/lib/micro.ui.ci:786: referenced as `itemCount`
	cmplGfx/lib/micro.ui.ci:722: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:1245: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:1132: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:1115: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:1030: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:1013: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:932: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:899: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:847: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:814: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:759: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:645: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:620: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:612: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:600: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:579: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:573: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:568: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:562: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:555: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:544: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:523: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:514: referenced as `itemCount`
	cmplGfx/lib/micro.ui.core.ci:493: referenced as `itemCount`
	internal usages: 6
}
Layout.itemCapacity: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'itemCapacity'
.file: 'cmplGfx/lib/micro.ui.core.ci:400'
.owner: Layout
.value: 0
.usages:
	cmplGfx/lib/micro.ui.core.ci:547: referenced as `itemCapacity`
	cmplGfx/lib/micro.ui.core.ci:545: referenced as `itemCapacity`
	cmplGfx/lib/micro.ui.core.ci:522: referenced as `itemCapacity`
	cmplGfx/lib/micro.ui.core.ci:521: referenced as `itemCapacity`
	cmplGfx/lib/micro.ui.core.ci:515: referenced as `itemCapacity`
	internal usages: 6
}
Layout.hoveredIndex: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'hoveredIndex'
.file: 'cmplGfx/lib/micro.ui.core.ci:401'
.owner: Layout
.value: -1
.usages:
	cmplGfx/lib/micro.ui.core.ci:1251: referenced as `hoveredIndex`
	cmplGfx/lib/micro.ui.core.ci:1040: referenced as `hoveredIndex`
	cmplGfx/lib/micro.ui.core.ci:699: referenced as `hoveredIndex`
	cmplGfx/lib/micro.ui.core.ci:693: referenced as `hoveredIndex`
	cmplGfx/lib/micro.ui.core.ci:436: referenced as `hoveredIndex`
	cmplGfx/lib/micro.ui.core.ci:432: referenced as `hoveredIndex`
	cmplGfx/lib/micro.ui.core.ci:431: referenced as `hoveredIndex`
	internal usages: 6
}
Layout.pressedIndex: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'pressedIndex'
.file: 'cmplGfx/lib/micro.ui.core.ci:402'
.owner: Layout
.value: -1
.usages:
	cmplGfx/lib/micro.ui.ci:1062: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.ci:1053: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.ci:880: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:1252: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:1043: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:688: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:685: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:660: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:463: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:460: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:444: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:440: referenced as `pressedIndex`
	cmplGfx/lib/micro.ui.core.ci:439: referenced as `pressedIndex`
	internal usages: 6
}
Layout.focusedIndex: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'focusedIndex'
.file: 'cmplGfx/lib/micro.ui.core.ci:403'
.owner: Layout
.value: -1
.usages:
	cmplGfx/lib/micro.ui.ci:1039: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.ci:1030: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.ci:891: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:1253: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:1138: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:1137: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:1123: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:1122: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:1112: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:1046: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:740: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:732: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:727: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:634: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:505: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:503: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:499: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:497: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:478: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:475: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:452: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:448: referenced as `focusedIndex`
	cmplGfx/lib/micro.ui.core.ci:447: referenced as `focusedIndex`
	internal usages: 6
}
Layout.paddingTop: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'paddingTop'
.file: 'cmplGfx/lib/micro.ui.core.ci:406'
.owner: Layout
.doc: 'Space between layout and its content at top.'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1011: referenced as `paddingTop`
	cmplGfx/lib/micro.ui.ci:709: referenced as `paddingTop`
	cmplGfx/lib/micro.ui.core.ci:976: referenced as `paddingTop`
	cmplGfx/lib/micro.ui.core.ci:797: referenced as `paddingTop`
	cmplGfx/lib/micro.ui.core.ci:585: referenced as `paddingTop`
	internal usages: 4
}
Layout.paddingLeft: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'paddingLeft'
.file: 'cmplGfx/lib/micro.ui.core.ci:408'
.owner: Layout
.doc: 'Space between layout and its content at left.'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1012: referenced as `paddingLeft`
	cmplGfx/lib/micro.ui.ci:710: referenced as `paddingLeft`
	cmplGfx/lib/micro.ui.core.ci:975: referenced as `paddingLeft`
	cmplGfx/lib/micro.ui.core.ci:796: referenced as `paddingLeft`
	cmplGfx/lib/micro.ui.core.ci:586: referenced as `paddingLeft`
	internal usages: 4
}
Layout.paddingRight: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'paddingRight'
.file: 'cmplGfx/lib/micro.ui.core.ci:410'
.owner: Layout
.doc: 'Space between layout and its content at right.'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1013: referenced as `paddingRight`
	cmplGfx/lib/micro.ui.ci:711: referenced as `paddingRight`
	cmplGfx/lib/micro.ui.core.ci:977: referenced as `paddingRight`
	cmplGfx/lib/micro.ui.core.ci:796: referenced as `paddingRight`
	cmplGfx/lib/micro.ui.core.ci:587: referenced as `paddingRight`
	internal usages: 4
}
Layout.paddingBottom: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'paddingBottom'
.file: 'cmplGfx/lib/micro.ui.core.ci:412'
.owner: Layout
.doc: 'Space between layout and its content at bottom.'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1014: referenced as `paddingBottom`
	cmplGfx/lib/micro.ui.ci:712: referenced as `paddingBottom`
	cmplGfx/lib/micro.ui.core.ci:978: referenced as `paddingBottom`
	cmplGfx/lib/micro.ui.core.ci:797: referenced as `paddingBottom`
	cmplGfx/lib/micro.ui.core.ci:588: referenced as `paddingBottom`
	internal usages: 4
}
Layout.orientation: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'orientation'
.file: 'cmplGfx/lib/micro.ui.core.ci:419'
.owner: Layout
.doc: 'Vertical, horizontal or other orientation of the layout
zero represents a stack(Qt) or frame(Android) layout (all child elements are placed on top of each other)
negative value represents a column layout, specifying the number of columns to be used
positive value represents a row layout, specifying the number of rows to be used'
.value: 1
.usages:
	cmplGfx/lib/micro.ui.ci:715: referenced as `orientation`
	cmplGfx/lib/micro.ui.ci:715: referenced as `orientation`
	cmplGfx/lib/micro.ui.core.ci:1057: referenced as `orientation`
	cmplGfx/lib/micro.ui.core.ci:1000: referenced as `orientation`
	cmplGfx/lib/micro.ui.core.ci:994: referenced as `orientation`
	cmplGfx/lib/micro.ui.core.ci:989: referenced as `orientation`
	cmplGfx/lib/micro.ui.core.ci:982: referenced as `orientation`
	cmplGfx/lib/micro.ui.core.ci:750: referenced as `orientation`
	internal usages: 4
}
Layout.clearState(this: Layout, mode: int32): bool: function {
.kind: static function
.base: `function`
.size: 396
.name: 'clearState'
.file: 'cmplGfx/lib/micro.ui.core.ci:429'
.owner: Layout
.param .result: bool (size: 4, cast: variable(bool))
.param this: Layout (size: 4, cast: variable(ref))
.param mode: int32 (size: 4, cast: variable(i32))
.value: {
	result: bool := false;
	if ((mode & Style.hovered) && this.hoveredIndex >= 0) {
		view: View := this.items[this.hoveredIndex].view;
		if ((layout) != null) {
			clearState(layout, mode);
		}
		this.hoveredIndex := -1;
		result := true;
	}
	if ((mode & Style.pressed) && this.pressedIndex >= 0) {
		view: View := this.items[this.pressedIndex].view;
		if ((layout) != null) {
			clearState(layout, mode);
		}
		this.pressedIndex := -1;
		result := true;
	}
	if ((mode & Style.focused) && this.focusedIndex >= 0) {
		view: View := this.items[this.focusedIndex].view;
		if ((layout) != null) {
			clearState(layout, mode);
		}
		this.focusedIndex := -1;
		result := true;
	}
	return .result := result;
}
.instructions: (396 bytes)
	cmplGfx/lib/micro.ui.core.ci:430: (1 byte): result: bool := false
	<clearState>  : load.z32
	cmplGfx/lib/micro.ui.core.ci:431: (124 bytes): if ((mode & Style.hovered) && this.hoveredIndex >= 0)
	<clearState+?>: dup.x32 sp(2)
	<clearState+?>: b32.and 0x01
	<clearState+?>: i32.2bool
	<clearState+?>: dup.x32 sp(0)
	<clearState+?>: jz +18
	<clearState+?>: inc.sp(-4)
	<clearState+?>: dup.x32 sp(3)
	<clearState+?>: inc.i32(+80)
	<clearState+?>: load.i32
	<clearState+?>: load.z32
	<clearState+?>: clt.i32
	<clearState+?>: not.b32
	<clearState+?>: jz +99
	cmplGfx/lib/micro.ui.core.ci:432: (23 bytes): view: View := this.items[this.hoveredIndex].view
	<clearState+?>: dup.x32 sp(3)
	<clearState+?>: inc.i32(+68)
	<clearState+?>: load.i32
	<clearState+?>: dup.x32 sp(4)
	<clearState+?>: inc.i32(+80)
	<clearState+?>: load.i32
	<clearState+?>: mad.u32 24
	<clearState+?>: inc.i32(+16)
	<clearState+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:433: (46 bytes): if ((layout) != null)
	<clearState+?>: dup.x32 sp(0)
	<clearState+?>: load.ref <?> ;Layout
	<clearState+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<clearState+?>: dup.x32 sp(0)
	<clearState+?>: load.ref <?> ;null
	<clearState+?>: ceq.i32
	<clearState+?>: jnz +23
	cmplGfx/lib/micro.ui.core.ci:434: (19 bytes): clearState(layout, mode);
	<clearState+?>: load.z32
	<clearState+?>: dup.x32 sp(1)
	<clearState+?>: dup.x32 sp(6)
	<clearState+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<clearState+?>: call
	<clearState+?>: inc.sp(-8)
	<clearState+?>: inc.sp(-4)
	<clearState+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:436: (12 bytes): this.hoveredIndex := -1;
	<clearState+?>: load.c32 -1
	<clearState+?>: dup.x32 sp(5)
	<clearState+?>: inc.i32(+80)
	<clearState+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:437: (10 bytes): result := true;
	<clearState+?>: load.c32 1
	<clearState+?>: load.sp(+8)
	<clearState+?>: store.i8
	<clearState+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:439: (128 bytes): if ((mode & Style.pressed) && this.pressedIndex >= 0)
	<clearState+?>: dup.x32 sp(2)
	<clearState+?>: load.c32 2
	<clearState+?>: and.b32
	<clearState+?>: i32.2bool
	<clearState+?>: dup.x32 sp(0)
	<clearState+?>: jz +18
	<clearState+?>: inc.sp(-4)
	<clearState+?>: dup.x32 sp(3)
	<clearState+?>: inc.i32(+84)
	<clearState+?>: load.i32
	<clearState+?>: load.z32
	<clearState+?>: clt.i32
	<clearState+?>: not.b32
	<clearState+?>: jz +99
	cmplGfx/lib/micro.ui.core.ci:440: (23 bytes): view: View := this.items[this.pressedIndex].view
	<clearState+?>: dup.x32 sp(3)
	<clearState+?>: inc.i32(+68)
	<clearState+?>: load.i32
	<clearState+?>: dup.x32 sp(4)
	<clearState+?>: inc.i32(+84)
	<clearState+?>: load.i32
	<clearState+?>: mad.u32 24
	<clearState+?>: inc.i32(+16)
	<clearState+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:441: (46 bytes): if ((layout) != null)
	<clearState+?>: dup.x32 sp(0)
	<clearState+?>: load.ref <?> ;Layout
	<clearState+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<clearState+?>: dup.x32 sp(0)
	<clearState+?>: load.ref <?> ;null
	<clearState+?>: ceq.i32
	<clearState+?>: jnz +23
	cmplGfx/lib/micro.ui.core.ci:442: (19 bytes): clearState(layout, mode);
	<clearState+?>: load.z32
	<clearState+?>: dup.x32 sp(1)
	<clearState+?>: dup.x32 sp(6)
	<clearState+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<clearState+?>: call
	<clearState+?>: inc.sp(-8)
	<clearState+?>: inc.sp(-4)
	<clearState+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:444: (12 bytes): this.pressedIndex := -1;
	<clearState+?>: load.c32 -1
	<clearState+?>: dup.x32 sp(5)
	<clearState+?>: inc.i32(+84)
	<clearState+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:445: (10 bytes): result := true;
	<clearState+?>: load.c32 1
	<clearState+?>: load.sp(+8)
	<clearState+?>: store.i8
	<clearState+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:447: (128 bytes): if ((mode & Style.focused) && this.focusedIndex >= 0)
	<clearState+?>: dup.x32 sp(2)
	<clearState+?>: load.c32 4
	<clearState+?>: and.b32
	<clearState+?>: i32.2bool
	<clearState+?>: dup.x32 sp(0)
	<clearState+?>: jz +18
	<clearState+?>: inc.sp(-4)
	<clearState+?>: dup.x32 sp(3)
	<clearState+?>: inc.i32(+88)
	<clearState+?>: load.i32
	<clearState+?>: load.z32
	<clearState+?>: clt.i32
	<clearState+?>: not.b32
	<clearState+?>: jz +99
	cmplGfx/lib/micro.ui.core.ci:448: (23 bytes): view: View := this.items[this.focusedIndex].view
	<clearState+?>: dup.x32 sp(3)
	<clearState+?>: inc.i32(+68)
	<clearState+?>: load.i32
	<clearState+?>: dup.x32 sp(4)
	<clearState+?>: inc.i32(+88)
	<clearState+?>: load.i32
	<clearState+?>: mad.u32 24
	<clearState+?>: inc.i32(+16)
	<clearState+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:449: (46 bytes): if ((layout) != null)
	<clearState+?>: dup.x32 sp(0)
	<clearState+?>: load.ref <?> ;Layout
	<clearState+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<clearState+?>: dup.x32 sp(0)
	<clearState+?>: load.ref <?> ;null
	<clearState+?>: ceq.i32
	<clearState+?>: jnz +23
	cmplGfx/lib/micro.ui.core.ci:450: (19 bytes): clearState(layout, mode);
	<clearState+?>: load.z32
	<clearState+?>: dup.x32 sp(1)
	<clearState+?>: dup.x32 sp(6)
	<clearState+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<clearState+?>: call
	<clearState+?>: inc.sp(-8)
	<clearState+?>: inc.sp(-4)
	<clearState+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:452: (12 bytes): this.focusedIndex := -1;
	<clearState+?>: load.c32 -1
	<clearState+?>: dup.x32 sp(5)
	<clearState+?>: inc.i32(+88)
	<clearState+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:453: (10 bytes): result := true;
	<clearState+?>: load.c32 1
	<clearState+?>: load.sp(+8)
	<clearState+?>: store.i8
	<clearState+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:455: (15 bytes): return .result := result;
	<clearState+?>: load.sp(+0)
	<clearState+?>: load.is8
	<clearState+?>: load.sp(+20)
	<clearState+?>: store.i8
	<clearState+?>: inc.sp(-4)
	<clearState+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:1121: referenced as `clearState`
	cmplGfx/lib/micro.ui.ci:909: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:1206: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:1145: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:743: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:739: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:724: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:706: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:695: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:687: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:682: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:671: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:504: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:498: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:491: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:450: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:442: referenced as `clearState`
	cmplGfx/lib/micro.ui.core.ci:434: referenced as `clearState`
}
Layout.getPressed(this: Layout): View: function {
.kind: static function
.base: `function`
.size: 114
.name: 'getPressed'
.file: 'cmplGfx/lib/micro.ui.core.ci:459'
.owner: Layout
.param .result: View (size: 4, cast: variable(ref))
.param this: Layout (size: 4, cast: const variable(ref))
.doc: 'Returns the pressed view in the current layout'
.value: {
	if (this.pressedIndex < 0) {
		return .result := null;
	}
	view: View := this.items[this.pressedIndex].view;
	if ((layout) != null) {
		child: View := getPressed(layout);
		if ((child) != null) {
			return .result := child;
		}
	}
	return .result := view;
}
.instructions: (114 bytes)
	cmplGfx/lib/micro.ui.core.ci:460: (21 bytes): if (this.pressedIndex < 0)
	<getPressed>  : dup.x32 sp(1)
	<getPressed+?>: inc.i32(+84)
	<getPressed+?>: load.i32
	<getPressed+?>: load.z32
	<getPressed+?>: clt.i32
	<getPressed+?>: jz +12
	cmplGfx/lib/micro.ui.core.ci:461: (8 bytes): return .result := null;
	<getPressed+?>: load.ref <?> ;null
	<getPressed+?>: set.x32 sp(3)
	<getPressed+?>: ret
	cmplGfx/lib/micro.ui.core.ci:463: (23 bytes): view: View := this.items[this.pressedIndex].view
	<getPressed+?>: dup.x32 sp(1)
	<getPressed+?>: inc.i32(+68)
	<getPressed+?>: load.i32
	<getPressed+?>: dup.x32 sp(2)
	<getPressed+?>: inc.i32(+84)
	<getPressed+?>: load.i32
	<getPressed+?>: mad.u32 24
	<getPressed+?>: inc.i32(+16)
	<getPressed+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:464: (67 bytes): if ((layout) != null)
	<getPressed+?>: dup.x32 sp(0)
	<getPressed+?>: load.ref <?> ;Layout
	<getPressed+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<getPressed+?>: dup.x32 sp(0)
	<getPressed+?>: load.ref <?> ;null
	<getPressed+?>: ceq.i32
	<getPressed+?>: jnz +44
	cmplGfx/lib/micro.ui.core.ci:465: (16 bytes): child: View := getPressed(layout)
	<getPressed+?>: inc.sp(+4)
	<getPressed+?>: dup.x32 sp(1)
	<getPressed+?>: load.ref <?> ;Layout.getPressed(this: Layout): View
	<getPressed+?>: call
	<getPressed+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:466: (20 bytes): if ((child) != null)
	<getPressed+?>: dup.x32 sp(0)
	<getPressed+?>: load.ref <?> ;null
	<getPressed+?>: ceq.i32
	<getPressed+?>: jnz +12
	cmplGfx/lib/micro.ui.core.ci:467: (8 bytes): return .result := child;
	<getPressed+?>: mov.x32 sp(5, 0)
	<getPressed+?>: inc.sp(-12)
	<getPressed+?>: ret
	<getPressed+?>: inc.sp(-4)
	<getPressed+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:470: (3 bytes): return .result := view;
	<getPressed+?>: set.x32 sp(3)
	<getPressed+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:1302: referenced as `getPressed`
	cmplGfx/lib/micro.ui.core.ci:465: referenced as `getPressed`
}
Layout.getFocused(this: Layout): View: function {
.kind: static function
.base: `function`
.size: 114
.name: 'getFocused'
.file: 'cmplGfx/lib/micro.ui.core.ci:474'
.owner: Layout
.param .result: View (size: 4, cast: variable(ref))
.param this: Layout (size: 4, cast: const variable(ref))
.doc: 'Returns the focused view in the current layout'
.value: {
	if (this.focusedIndex < 0) {
		return .result := null;
	}
	view: View := this.items[this.focusedIndex].view;
	if ((layout) != null) {
		child: View := getFocused(layout);
		if ((child) != null) {
			return .result := child;
		}
	}
	return .result := view;
}
.instructions: (114 bytes)
	cmplGfx/lib/micro.ui.core.ci:475: (21 bytes): if (this.focusedIndex < 0)
	<getFocused>  : dup.x32 sp(1)
	<getFocused+?>: inc.i32(+88)
	<getFocused+?>: load.i32
	<getFocused+?>: load.z32
	<getFocused+?>: clt.i32
	<getFocused+?>: jz +12
	cmplGfx/lib/micro.ui.core.ci:476: (8 bytes): return .result := null;
	<getFocused+?>: load.ref <?> ;null
	<getFocused+?>: set.x32 sp(3)
	<getFocused+?>: ret
	cmplGfx/lib/micro.ui.core.ci:478: (23 bytes): view: View := this.items[this.focusedIndex].view
	<getFocused+?>: dup.x32 sp(1)
	<getFocused+?>: inc.i32(+68)
	<getFocused+?>: load.i32
	<getFocused+?>: dup.x32 sp(2)
	<getFocused+?>: inc.i32(+88)
	<getFocused+?>: load.i32
	<getFocused+?>: mad.u32 24
	<getFocused+?>: inc.i32(+16)
	<getFocused+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:479: (67 bytes): if ((layout) != null)
	<getFocused+?>: dup.x32 sp(0)
	<getFocused+?>: load.ref <?> ;Layout
	<getFocused+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<getFocused+?>: dup.x32 sp(0)
	<getFocused+?>: load.ref <?> ;null
	<getFocused+?>: ceq.i32
	<getFocused+?>: jnz +44
	cmplGfx/lib/micro.ui.core.ci:480: (16 bytes): child: View := getFocused(layout)
	<getFocused+?>: inc.sp(+4)
	<getFocused+?>: dup.x32 sp(1)
	<getFocused+?>: load.ref <?> ;Layout.getFocused(this: Layout): View
	<getFocused+?>: call
	<getFocused+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:481: (20 bytes): if ((child) != null)
	<getFocused+?>: dup.x32 sp(0)
	<getFocused+?>: load.ref <?> ;null
	<getFocused+?>: ceq.i32
	<getFocused+?>: jnz +12
	cmplGfx/lib/micro.ui.core.ci:482: (8 bytes): return .result := child;
	<getFocused+?>: mov.x32 sp(5, 0)
	<getFocused+?>: inc.sp(-12)
	<getFocused+?>: ret
	<getFocused+?>: inc.sp(-4)
	<getFocused+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:485: (3 bytes): return .result := view;
	<getFocused+?>: set.x32 sp(3)
	<getFocused+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:885: referenced as `getFocused`
	cmplGfx/lib/micro.ui.core.ci:1297: referenced as `getFocused`
	cmplGfx/lib/micro.ui.core.ci:1265: referenced as `getFocused`
	cmplGfx/lib/micro.ui.core.ci:480: referenced as `getFocused`
}
Layout.setFocused(this: Layout, focus: View): bool: function {
.kind: static function
.base: `function`
.size: 283
.name: 'setFocused'
.file: 'cmplGfx/lib/micro.ui.core.ci:489'
.owner: Layout
.param .result: bool (size: 4, cast: variable(bool))
.param this: Layout (size: 4, cast: variable(ref))
.param focus: View (size: 4, cast: variable(ref))
.doc: 'Sets the focused view in the current layout'
.value: {
	if ((focus) == null) {
		clearState(this, Style.focused);
	}
	for (i: int32 := 0; i < this.itemCount; i := i + 1) {
		const item: Item := this.items[i];
		const rect: Rect := item.rect;
		const view: View := item.view;
		if (view == focus && this.focusedIndex != i) {
			clearState(this, Style.focused);
			this.focusedIndex := i;
			return .result := true;
		}
		if ((layout) != null) {
			if (setFocused(layout, focus) && this.focusedIndex != i) {
				clearState(this, Style.focused);
				this.focusedIndex := i;
				return .result := true;
			}
		}
	}
	return .result := false;
}
.instructions: (283 bytes)
	cmplGfx/lib/micro.ui.core.ci:490: (34 bytes): if ((focus) == null)
	<setFocused>  : dup.x32 sp(1)
	<setFocused+?>: load.ref <?> ;null
	<setFocused+?>: ceq.i32
	<setFocused+?>: jz +26
	cmplGfx/lib/micro.ui.core.ci:491: (22 bytes): clearState(this, Style.focused);
	<setFocused+?>: load.z32
	<setFocused+?>: dup.x32 sp(3)
	<setFocused+?>: load.c32 4
	<setFocused+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<setFocused+?>: call
	<setFocused+?>: inc.sp(-8)
	<setFocused+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:493: (242 bytes): for (i: int32 := 0; i < this.itemCount; i := i + 1)
	<setFocused+?>: load.z32
	<setFocused+?>: jmp +223
	cmplGfx/lib/micro.ui.core.ci:494: (13 bytes): const item: Item := this.items[i]
	<setFocused+?>: dup.x32 sp(3)
	<setFocused+?>: inc.i32(+68)
	<setFocused+?>: load.i32
	<setFocused+?>: dup.x32 sp(1)
	<setFocused+?>: mad.u32 24
	cmplGfx/lib/micro.ui.core.ci:495: (2 bytes): const rect: Rect := item.rect
	<setFocused+?>: dup.x32 sp(0)
	cmplGfx/lib/micro.ui.core.ci:496: (7 bytes): const view: View := item.view
	<setFocused+?>: dup.x32 sp(1)
	<setFocused+?>: inc.i32(+16)
	<setFocused+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:497: (76 bytes): if (view == focus && this.focusedIndex != i)
	<setFocused+?>: dup.x32 sp(0)
	<setFocused+?>: dup.x32 sp(6)
	<setFocused+?>: ceq.i32
	<setFocused+?>: dup.x32 sp(0)
	<setFocused+?>: jz +19
	<setFocused+?>: inc.sp(-4)
	<setFocused+?>: dup.x32 sp(6)
	<setFocused+?>: inc.i32(+88)
	<setFocused+?>: load.i32
	<setFocused+?>: dup.x32 sp(4)
	<setFocused+?>: ceq.i32
	<setFocused+?>: not.b32
	<setFocused+?>: jz +50
	cmplGfx/lib/micro.ui.core.ci:498: (22 bytes): clearState(this, Style.focused);
	<setFocused+?>: load.z32
	<setFocused+?>: dup.x32 sp(7)
	<setFocused+?>: load.c32 4
	<setFocused+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<setFocused+?>: call
	<setFocused+?>: inc.sp(-8)
	<setFocused+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:499: (9 bytes): this.focusedIndex := i;
	<setFocused+?>: dup.x32 sp(3)
	<setFocused+?>: dup.x32 sp(7)
	<setFocused+?>: inc.i32(+88)
	<setFocused+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:500: (15 bytes): return .result := true;
	<setFocused+?>: load.c32 1
	<setFocused+?>: load.sp(+32)
	<setFocused+?>: store.i8
	<setFocused+?>: inc.sp(-16)
	<setFocused+?>: ret
	cmplGfx/lib/micro.ui.core.ci:502: (113 bytes): if ((layout) != null)
	<setFocused+?>: dup.x32 sp(0)
	<setFocused+?>: load.ref <?> ;Layout
	<setFocused+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<setFocused+?>: dup.x32 sp(0)
	<setFocused+?>: load.ref <?> ;null
	<setFocused+?>: ceq.i32
	<setFocused+?>: jnz +90
	cmplGfx/lib/micro.ui.core.ci:503: (86 bytes): if (setFocused(layout, focus) && this.focusedIndex != i)
	<setFocused+?>: load.z32
	<setFocused+?>: dup.x32 sp(1)
	<setFocused+?>: dup.x32 sp(8)
	<setFocused+?>: load.ref <?> ;Layout.setFocused(this: Layout, focus: View): bool
	<setFocused+?>: call
	<setFocused+?>: inc.sp(-8)
	<setFocused+?>: dup.x32 sp(0)
	<setFocused+?>: jz +19
	<setFocused+?>: inc.sp(-4)
	<setFocused+?>: dup.x32 sp(7)
	<setFocused+?>: inc.i32(+88)
	<setFocused+?>: load.i32
	<setFocused+?>: dup.x32 sp(5)
	<setFocused+?>: ceq.i32
	<setFocused+?>: not.b32
	<setFocused+?>: jz +50
	cmplGfx/lib/micro.ui.core.ci:504: (22 bytes): clearState(this, Style.focused);
	<setFocused+?>: load.z32
	<setFocused+?>: dup.x32 sp(8)
	<setFocused+?>: load.c32 4
	<setFocused+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<setFocused+?>: call
	<setFocused+?>: inc.sp(-8)
	<setFocused+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:505: (9 bytes): this.focusedIndex := i;
	<setFocused+?>: dup.x32 sp(4)
	<setFocused+?>: dup.x32 sp(8)
	<setFocused+?>: inc.i32(+88)
	<setFocused+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:506: (15 bytes): return .result := true;
	<setFocused+?>: load.c32 1
	<setFocused+?>: load.sp(+36)
	<setFocused+?>: store.i8
	<setFocused+?>: inc.sp(-20)
	<setFocused+?>: ret
	<setFocused+?>: inc.sp(-4)
	<setFocused+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:493: (4 bytes): i := i + 1
	<setFocused+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.core.ci:493: (14 bytes): i < this.itemCount
	<setFocused+?>: dup.x32 sp(0)
	<setFocused+?>: dup.x32 sp(4)
	<setFocused+?>: inc.i32(+72)
	<setFocused+?>: load.i32
	<setFocused+?>: clt.i32
	<setFocused+?>: jnz -229
	<setFocused+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:510: (7 bytes): return .result := false;
	<setFocused+?>: load.z32
	<setFocused+?>: load.sp(+16)
	<setFocused+?>: store.i8
	<setFocused+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:1277: referenced as `setFocused`
	cmplGfx/lib/micro.ui.core.ci:1269: referenced as `setFocused`
	cmplGfx/lib/micro.ui.core.ci:1261: referenced as `setFocused`
	cmplGfx/lib/micro.ui.core.ci:503: referenced as `setFocused`
}
Layout.capacity(this: Layout, capacity: int32): Layout: function {
.kind: static function
.base: `function`
.size: 175
.name: 'capacity'
.file: 'cmplGfx/lib/micro.ui.core.ci:513'
.owner: Layout
.param .result: Layout (size: 4, cast: variable(ref))
.param this: Layout (size: 4, cast: variable(ref))
.param capacity: int32 (size: 4, cast: variable(i32))
.value: {
	assert(capacity >= this.itemCount);
	if (capacity == this.itemCapacity) {
		return;
	}
	items: Item[*] := this.items;
	this.itemCapacity := capacity;
	this.items := (pointer.alloc(null, this.itemCapacity * sizeof(Item)));
	pointer.copy(this.items, items, this.itemCount * sizeof(Item));
	pointer.alloc(items, 0);
	return .result := this;
}
.instructions: (175 bytes)
	cmplGfx/lib/micro.ui.core.ci:514: (58 bytes): assert(capacity >= this.itemCount);
	<capacity>  : load.z32
	<capacity+?>: load.sp(+4)
	<capacity+?>: dup.x32 sp(3)
	<capacity+?>: dup.x32 sp(5)
	<capacity+?>: inc.i32(+72)
	<capacity+?>: load.i32
	<capacity+?>: clt.i32
	<capacity+?>: jnz +8
	<capacity+?>: jmp +35
	<capacity+?>: load.ref <?> ;"cmplGfx/lib/micro.ui.core.ci"
	<capacity+?>: load.c32 514
	<capacity+?>: load.c32 -2
	<capacity+?>: load.c32 128
	<capacity+?>: load.ref <?> ;"assertion failed!"
	<capacity+?>: dup.x64 sp(5)
	<capacity+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<capacity+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:515: (15 bytes): if (capacity == this.itemCapacity)
	<capacity+?>: dup.x32 sp(1)
	<capacity+?>: dup.x32 sp(3)
	<capacity+?>: inc.i32(+76)
	<capacity+?>: load.i32
	<capacity+?>: ceq.i32
	<capacity+?>: jz +5
	cmplGfx/lib/micro.ui.core.ci:517: (1 byte): return;
	<capacity+?>: ret
	cmplGfx/lib/micro.ui.core.ci:520: (7 bytes): items: Item[*] := this.items
	<capacity+?>: dup.x32 sp(2)
	<capacity+?>: inc.i32(+68)
	<capacity+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:521: (9 bytes): this.itemCapacity := capacity;
	<capacity+?>: dup.x32 sp(2)
	<capacity+?>: dup.x32 sp(4)
	<capacity+?>: inc.i32(+76)
	<capacity+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:522: (33 bytes): this.items := (pointer.alloc(null, this.itemCapacity * sizeof(Item)));
	<capacity+?>: load.ref <?> ;null
	<capacity+?>: dup.x32 sp(4)
	<capacity+?>: inc.i32(+76)
	<capacity+?>: load.i32
	<capacity+?>: load.ref <?> ;Layout.Item
	<capacity+?>: nfc(6) ;typename.size(type: typename): int32
	<capacity+?>: mul.i32
	<capacity+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<capacity+?>: dup.x32 sp(4)
	<capacity+?>: inc.i32(+68)
	<capacity+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:523: (34 bytes): pointer.copy(this.items, items, this.itemCount * sizeof(Item));
	<capacity+?>: dup.x32 sp(3)
	<capacity+?>: inc.i32(+68)
	<capacity+?>: load.i32
	<capacity+?>: dup.x32 sp(1)
	<capacity+?>: dup.x32 sp(5)
	<capacity+?>: inc.i32(+72)
	<capacity+?>: load.i32
	<capacity+?>: load.ref <?> ;Layout.Item
	<capacity+?>: nfc(6) ;typename.size(type: typename): int32
	<capacity+?>: mul.i32
	<capacity+?>: nfc(15) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<capacity+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:524: (11 bytes): pointer.alloc(items, 0);
	<capacity+?>: dup.x32 sp(0)
	<capacity+?>: load.z32
	<capacity+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<capacity+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:525: (8 bytes): return .result := this;
	<capacity+?>: mov.x32 sp(4, 3)
	<capacity+?>: inc.sp(-4)
	<capacity+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:551: referenced as `capacity`
}
Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout: function {
.kind: static function
.base: `function`
.size: 204
.name: 'addItems'
.file: 'cmplGfx/lib/micro.ui.core.ci:529'
.owner: Layout
.param .result: Layout (size: 4, cast: variable(ref))
.param this: Layout (size: 4, cast: variable(ref))
.param alignment: int32 (size: 4, cast: variable(i32))
.param views: View[] (size: 8, cast: variable(arr))
.doc: 'Append the given `views` to `this` layout with the given `alignment`'
.value: {
	static separator(this: Layout): View := {
		static onDraw(this: View, offs: Image, rect: Rect): void := {
		};
		if ((this.separator) != null) {
			return .result := this.separator;
		}
		separator: View := {
			separator := create(View);
			separator.enabled := false;
			separator.focusable := false;
			separator.onDraw := onDraw;
			separator.width := -5;
			separator.height := -5;
			separator.parent := (null);
			separator.style := (null);
			separator.data := (null);
			separator.onClick := onClick;
			separator.onReset := onReset;
			separator.onCreate := onCreate;
			separator.onDestroy := onDestroy;
			separator.onKeyEvent := onKeyEvent;
			separator.onTouchEvent := onTouchEvent;
			separator.onMeasure := onMeasure;
		};
		this.separator := separator;
		return .result := separator;
	};
	itemCount: int32 := this.itemCount + (views.length);
	if (itemCount >= this.itemCapacity) {
		capacity: int32 := 2 * this.itemCapacity;
		if (capacity < itemCount) {
			capacity := itemCount;
		}
		capacity(this, capacity);
	}
	for (i: int32 := 0; i < (views.length); i := i + 1) {
		item: Item := this.items[this.itemCount + i];
		item.view := views[i];
		item.align := alignment;
		if ((item.view) == null) {
			item.view := separator(this);
		}
	}
	this.itemCount := itemCount;
	return .result := this;
}
.instructions: (204 bytes)
	cmplGfx/lib/micro.ui.core.ci:544: (10 bytes): itemCount: int32 := this.itemCount + (views.length)
	<addItems>  : dup.x32 sp(4)
	<addItems+?>: inc.i32(+72)
	<addItems+?>: load.i32
	<addItems+?>: dup.x32 sp(3)
	<addItems+?>: add.i32
	cmplGfx/lib/micro.ui.core.ci:545: (65 bytes): if (itemCount >= this.itemCapacity)
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: dup.x32 sp(6)
	<addItems+?>: inc.i32(+76)
	<addItems+?>: load.i32
	<addItems+?>: clt.i32
	<addItems+?>: jnz +55
	cmplGfx/lib/micro.ui.core.ci:547: (13 bytes): capacity: int32 := 2 * this.itemCapacity
	<addItems+?>: load.c32 2
	<addItems+?>: dup.x32 sp(6)
	<addItems+?>: inc.i32(+76)
	<addItems+?>: load.i32
	<addItems+?>: mul.i32
	cmplGfx/lib/micro.ui.core.ci:548: (12 bytes): if (capacity < itemCount)
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: clt.i32
	<addItems+?>: jz +7
	cmplGfx/lib/micro.ui.core.ci:549: (3 bytes): capacity := itemCount;
	<addItems+?>: mov.x32 sp(0, 1)
	cmplGfx/lib/micro.ui.core.ci:551: (22 bytes): capacity(this, capacity);
	<addItems+?>: inc.sp(+4)
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: load.ref <?> ;Layout.capacity(this: Layout, capacity: int32): Layout
	<addItems+?>: call
	<addItems+?>: inc.sp(-8)
	<addItems+?>: inc.sp(-4)
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:554: (112 bytes): for (i: int32 := 0; i < (views.length); i := i + 1)
	<addItems+?>: load.z32
	<addItems+?>: jmp +98
	cmplGfx/lib/micro.ui.core.ci:555: (21 bytes): item: Item := this.items[this.itemCount + i]
	<addItems+?>: dup.x32 sp(6)
	<addItems+?>: inc.i32(+68)
	<addItems+?>: load.i32
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: inc.i32(+72)
	<addItems+?>: load.i32
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: add.i32
	<addItems+?>: mad.u32 24
	cmplGfx/lib/micro.ui.core.ci:556: (16 bytes): item.view := views[i];
	<addItems+?>: dup.x32 sp(4)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: mad.u32 4
	<addItems+?>: load.i32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+16)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:557: (9 bytes): item.align := alignment;
	<addItems+?>: dup.x32 sp(6)
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+20)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:558: (40 bytes): if ((item.view) == null)
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: inc.i32(+16)
	<addItems+?>: load.i32
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: ceq.i32
	<addItems+?>: jz +27
	cmplGfx/lib/micro.ui.core.ci:559: (23 bytes): item.view := separator(this);
	<addItems+?>: inc.sp(+4)
	<addItems+?>: dup.x32 sp(8)
	<addItems+?>: load.ref <?> ;Layout.addItems.separator(this: Layout): View
	<addItems+?>: call
	<addItems+?>: inc.sp(-4)
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+16)
	<addItems+?>: store.i32
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:554: (4 bytes): i := i + 1
	<addItems+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.core.ci:554: (9 bytes): i < (views.length)
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: dup.x32 sp(5)
	<addItems+?>: clt.i32
	<addItems+?>: jnz -99
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:562: (9 bytes): this.itemCount := itemCount;
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: dup.x32 sp(6)
	<addItems+?>: inc.i32(+72)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:563: (8 bytes): return .result := this;
	<addItems+?>: mov.x32 sp(6, 5)
	<addItems+?>: inc.sp(-4)
	<addItems+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:831: referenced as `addItems`
	cmplGfx/lib/micro.ui.ci:828: referenced as `addItems`
	cmplGfx/lib/micro.ui.ci:740: referenced as `addItems`
	cmplGfx/lib/micro.ui.ci:739: referenced as `addItems`
	cmplGfx/lib/micro.ui.ci:738: referenced as `addItems`
	cmplGfx/lib/micro.ui.ci:735: referenced as `addItems`
	cmplGfx/lib/micro.ui.ci:719: referenced as `addItems`
	cmplGfx/lib/micro.ui.core.ci:1157: referenced as `addItems`
	cmplGfx/lib/micro.ui.core.ci:1151: referenced as `addItems`
	cmplGfx/lib/micro.ui.core.ci:1060: referenced as `addItems`
}
Layout.size(this: Layout): int32: function {
.kind: static function
.base: `function`
.size: 10
.name: 'size'
.file: 'cmplGfx/lib/micro.ui.core.ci:567'
.owner: Layout
.param .result: int32 (size: 4, cast: variable(i32))
.param this: Layout (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	return .result := this.itemCount;
}
.instructions: (10 bytes)
	cmplGfx/lib/micro.ui.core.ci:568: (10 bytes): return .result := this.itemCount;
	<size>  : dup.x32 sp(1)
	<size+?>: inc.i32(+72)
	<size+?>: load.i32
	<size+?>: set.x32 sp(3)
	<size+?>: ret
.usages:
}
Layout.getView(this: Layout, idx: int32): View: function {
.kind: static function
.base: `function`
.size: 94
.name: 'getView'
.file: 'cmplGfx/lib/micro.ui.core.ci:572'
.owner: Layout
.param .result: View (size: 4, cast: variable(ref))
.param this: Layout (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	assert(idx >= 0 && idx < this.itemCount);
	return .result := this.items[idx].view;
}
.instructions: (94 bytes)
	cmplGfx/lib/micro.ui.core.ci:573: (73 bytes): assert(idx >= 0 && idx < this.itemCount);
	<getView>  : load.z32
	<getView+?>: load.sp(+4)
	<getView+?>: dup.x32 sp(3)
	<getView+?>: load.z32
	<getView+?>: clt.i32
	<getView+?>: not.b32
	<getView+?>: dup.x32 sp(0)
	<getView+?>: jz +18
	<getView+?>: inc.sp(-4)
	<getView+?>: dup.x32 sp(3)
	<getView+?>: dup.x32 sp(5)
	<getView+?>: inc.i32(+72)
	<getView+?>: load.i32
	<getView+?>: clt.i32
	<getView+?>: jz +8
	<getView+?>: jmp +35
	<getView+?>: load.ref <?> ;"cmplGfx/lib/micro.ui.core.ci"
	<getView+?>: load.c32 573
	<getView+?>: load.c32 -2
	<getView+?>: load.c32 128
	<getView+?>: load.ref <?> ;"assertion failed!"
	<getView+?>: dup.x64 sp(5)
	<getView+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<getView+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:574: (21 bytes): return .result := this.items[idx].view;
	<getView+?>: dup.x32 sp(2)
	<getView+?>: inc.i32(+68)
	<getView+?>: load.i32
	<getView+?>: dup.x32 sp(2)
	<getView+?>: mad.u32 24
	<getView+?>: inc.i32(+16)
	<getView+?>: load.i32
	<getView+?>: set.x32 sp(4)
	<getView+?>: ret
.usages:
}
Layout.setAlignment(this: Layout, idx: int32, alignment: int32): void: function {
.kind: static function
.base: `function`
.size: 94
.name: 'setAlignment'
.file: 'cmplGfx/lib/micro.ui.core.ci:578'
.owner: Layout
.param .result: void (size: 0, cast: variable(void))
.param this: Layout (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param alignment: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	assert(idx >= 0 && idx < this.itemCount);
	this.items[idx].align := alignment;
}
.instructions: (94 bytes)
	cmplGfx/lib/micro.ui.core.ci:579: (73 bytes): assert(idx >= 0 && idx < this.itemCount);
	<setAlignment>  : load.z32
	<setAlignment+?>: load.sp(+4)
	<setAlignment+?>: dup.x32 sp(4)
	<setAlignment+?>: load.z32
	<setAlignment+?>: clt.i32
	<setAlignment+?>: not.b32
	<setAlignment+?>: dup.x32 sp(0)
	<setAlignment+?>: jz +18
	<setAlignment+?>: inc.sp(-4)
	<setAlignment+?>: dup.x32 sp(4)
	<setAlignment+?>: dup.x32 sp(6)
	<setAlignment+?>: inc.i32(+72)
	<setAlignment+?>: load.i32
	<setAlignment+?>: clt.i32
	<setAlignment+?>: jz +8
	<setAlignment+?>: jmp +35
	<setAlignment+?>: load.ref <?> ;"cmplGfx/lib/micro.ui.core.ci"
	<setAlignment+?>: load.c32 579
	<setAlignment+?>: load.c32 -2
	<setAlignment+?>: load.c32 128
	<setAlignment+?>: load.ref <?> ;"assertion failed!"
	<setAlignment+?>: dup.x64 sp(5)
	<setAlignment+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<setAlignment+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:580: (20 bytes): this.items[idx].align := alignment;
	<setAlignment+?>: dup.x32 sp(1)
	<setAlignment+?>: dup.x32 sp(4)
	<setAlignment+?>: inc.i32(+68)
	<setAlignment+?>: load.i32
	<setAlignment+?>: dup.x32 sp(4)
	<setAlignment+?>: mad.u32 24
	<setAlignment+?>: inc.i32(+20)
	<setAlignment+?>: store.i32
	<setAlignment+?>: ret
.usages:
}
Layout.padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout: function {
.kind: static function
.base: `function`
.size: 56
.name: 'padding'
.file: 'cmplGfx/lib/micro.ui.core.ci:584'
.owner: Layout
.param .result: Layout (size: 4, cast: variable(ref))
.param this: Layout (size: 4, cast: variable(ref))
.param top: int32 (size: 4, cast: variable(i32))
.param left: int32 (size: 4, cast: variable(i32))
.param right: int32 (size: 4, cast: variable(i32))
.param bottom: int32 (size: 4, cast: variable(i32))
.doc: 'Set the padding of `this` layout to the given values'
.value: {
	this.paddingTop := top;
	this.paddingLeft := left;
	this.paddingRight := right;
	this.paddingBottom := bottom;
	invalidate(this, true);
	return .result := this;
}
.instructions: (56 bytes)
	cmplGfx/lib/micro.ui.core.ci:585: (9 bytes): this.paddingTop := top;
	<padding>  : dup.x32 sp(4)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: inc.i32(+92)
	<padding+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:586: (9 bytes): this.paddingLeft := left;
	<padding+?>: dup.x32 sp(3)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: inc.i32(+96)
	<padding+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:587: (9 bytes): this.paddingRight := right;
	<padding+?>: dup.x32 sp(2)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: inc.i32(+100)
	<padding+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:588: (9 bytes): this.paddingBottom := bottom;
	<padding+?>: dup.x32 sp(1)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: inc.i32(+104)
	<padding+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:589: (16 bytes): invalidate(this, true);
	<padding+?>: dup.x32 sp(5)
	<padding+?>: load.c32 1
	<padding+?>: load.m32 <?> ;invalidate(view: View, layout: bool): void
	<padding+?>: call
	<padding+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:590: (4 bytes): return .result := this;
	<padding+?>: mov.x32 sp(6, 5)
	<padding+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:1181: referenced as `padding`
	cmplGfx/lib/micro.ui.core.ci:1175: referenced as `padding`
	cmplGfx/lib/micro.ui.core.ci:1169: referenced as `padding`
}
Layout.onClick(this: Layout): bool: function {
.kind: static function
.base: `function`
.size: 58
.name: 'onClick'
.file: 'cmplGfx/lib/micro.ui.core.ci:593'
.owner: Layout
.param .result: bool (size: 4, cast: variable(bool))
.param this: Layout (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is clicked'
.value: {
	error("onClick", this);
	return .result := false;
}
.instructions: (58 bytes)
	cmplGfx/lib/micro.ui.core.ci:594: (51 bytes): error("onClick", this);
	<onClick>  : load.ref <?> ;Layout
	<onClick+?>: dup.x32 sp(2)
	<onClick+?>: load.c32 1
	<onClick+?>: load.sp(+4)
	<onClick+?>: load.ref <?> ;"cmplGfx/lib/micro.ui.core.ci"
	<onClick+?>: load.c32 594
	<onClick+?>: load.c32 -1
	<onClick+?>: load.c32 128
	<onClick+?>: load.ref <?> ;"onClick"
	<onClick+?>: dup.x64 sp(5)
	<onClick+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<onClick+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.core.ci:595: (7 bytes): return .result := false;
	<onClick+?>: load.z32
	<onClick+?>: load.sp(+12)
	<onClick+?>: store.i8
	<onClick+?>: ret
.usages:
}
Layout.onReset(this: Layout): bool: function {
.kind: static function
.base: `function`
.size: 94
.name: 'onReset'
.file: 'cmplGfx/lib/micro.ui.core.ci:598'
.owner: Layout
.param .result: bool (size: 4, cast: variable(bool))
.param this: Layout (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is double clicked'
.value: {
	result: bool := false;
	for (i: int32 := 0; i < this.itemCount; i := i + 1) {
		view: View := this.items[i].view;
		if (view.onReset(view)) {
			result := true;
		}
	}
	return .result := result;
}
.instructions: (94 bytes)
	cmplGfx/lib/micro.ui.core.ci:599: (1 byte): result: bool := false
	<onReset>  : load.z32
	cmplGfx/lib/micro.ui.core.ci:600: (78 bytes): for (i: int32 := 0; i < this.itemCount; i := i + 1)
	<onReset+?>: load.z32
	<onReset+?>: jmp +59
	cmplGfx/lib/micro.ui.core.ci:601: (18 bytes): view: View := this.items[i].view
	<onReset+?>: dup.x32 sp(3)
	<onReset+?>: inc.i32(+68)
	<onReset+?>: load.i32
	<onReset+?>: dup.x32 sp(1)
	<onReset+?>: mad.u32 24
	<onReset+?>: inc.i32(+16)
	<onReset+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:602: (29 bytes): if (view.onReset(view))
	<onReset+?>: load.z32
	<onReset+?>: dup.x32 sp(1)
	<onReset+?>: dup.x32 sp(2)
	<onReset+?>: inc.i32(+36)
	<onReset+?>: load.i32
	<onReset+?>: call
	<onReset+?>: inc.sp(-4)
	<onReset+?>: jz +14
	cmplGfx/lib/micro.ui.core.ci:603: (10 bytes): result := true;
	<onReset+?>: load.c32 1
	<onReset+?>: load.sp(+12)
	<onReset+?>: store.i8
	<onReset+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:600: (4 bytes): i := i + 1
	<onReset+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.core.ci:600: (14 bytes): i < this.itemCount
	<onReset+?>: dup.x32 sp(0)
	<onReset+?>: dup.x32 sp(4)
	<onReset+?>: inc.i32(+72)
	<onReset+?>: load.i32
	<onReset+?>: clt.i32
	<onReset+?>: jnz -65
	<onReset+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:606: (15 bytes): return .result := result;
	<onReset+?>: load.sp(+0)
	<onReset+?>: load.is8
	<onReset+?>: load.sp(+16)
	<onReset+?>: store.i8
	<onReset+?>: inc.sp(-4)
	<onReset+?>: ret
.usages:
}
Layout.onCreate(this: Layout, parent: View): void: function {
.kind: static function
.base: `function`
.size: 141
.name: 'onCreate'
.file: 'cmplGfx/lib/micro.ui.core.ci:609'
.owner: Layout
.param .result: void (size: 0, cast: variable(void))
.param this: Layout (size: 4, cast: variable(ref))
.param parent: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is created'
.value: {
	assert((this.parent) == null, "can not add the same layout multiple times");
	View.onCreate(this, parent);
	for (i: int32 := 0; i < this.itemCount; i := i + 1) {
		view: View := this.items[i].view;
		view.onCreate(view, this);
	}
}
.instructions: (141 bytes)
	cmplGfx/lib/micro.ui.core.ci:610: (61 bytes): assert((this.parent) == null, "can not add the same layout multiple times");
	<onCreate>  : load.z32
	<onCreate+?>: load.sp(+4)
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: inc.i32(+16)
	<onCreate+?>: load.i32
	<onCreate+?>: load.ref <?> ;null
	<onCreate+?>: ceq.i32
	<onCreate+?>: jz +8
	<onCreate+?>: jmp +35
	<onCreate+?>: load.ref <?> ;"cmplGfx/lib/micro.ui.core.ci"
	<onCreate+?>: load.c32 610
	<onCreate+?>: load.c32 -2
	<onCreate+?>: load.c32 128
	<onCreate+?>: load.ref <?> ;"can not add the same layout multiple times"
	<onCreate+?>: dup.x64 sp(5)
	<onCreate+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:611: (14 bytes): View.onCreate(this, parent);
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: load.ref <?> ;View.onCreate(this: View, parent: View): void
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:612: (65 bytes): for (i: int32 := 0; i < this.itemCount; i := i + 1)
	<onCreate+?>: load.z32
	<onCreate+?>: jmp +46
	cmplGfx/lib/micro.ui.core.ci:613: (18 bytes): view: View := this.items[i].view
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: inc.i32(+68)
	<onCreate+?>: load.i32
	<onCreate+?>: dup.x32 sp(1)
	<onCreate+?>: mad.u32 24
	<onCreate+?>: inc.i32(+16)
	<onCreate+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:614: (16 bytes): view.onCreate(view, this);
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: dup.x32 sp(5)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: inc.i32(+40)
	<onCreate+?>: load.i32
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-8)
	<onCreate+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:612: (4 bytes): i := i + 1
	<onCreate+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.core.ci:612: (14 bytes): i < this.itemCount
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: inc.i32(+72)
	<onCreate+?>: load.i32
	<onCreate+?>: clt.i32
	<onCreate+?>: jnz -52
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:635: referenced as `onCreate`
	cmplGfx/lib/micro.ui.core.ci:1186: referenced as `onCreate`
}
Layout.onDestroy(this: Layout): void: function {
.kind: static function
.base: `function`
.size: 86
.name: 'onDestroy'
.file: 'cmplGfx/lib/micro.ui.core.ci:618'
.owner: Layout
.param .result: void (size: 0, cast: variable(void))
.param this: Layout (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is destroyed'
.value: {
	for (i: int32 := 0; i < this.itemCount; i := i + 1) {
		view: View := this.items[i].view;
		view.onDestroy(view);
		destroy(view);
	}
	pointer.alloc(this.items, 0);
}
.instructions: (86 bytes)
	cmplGfx/lib/micro.ui.core.ci:620: (69 bytes): for (i: int32 := 0; i < this.itemCount; i := i + 1)
	<onDestroy>  : load.z32
	<onDestroy+?>: jmp +50
	cmplGfx/lib/micro.ui.core.ci:621: (18 bytes): view: View := this.items[i].view
	<onDestroy+?>: dup.x32 sp(2)
	<onDestroy+?>: inc.i32(+68)
	<onDestroy+?>: load.i32
	<onDestroy+?>: dup.x32 sp(1)
	<onDestroy+?>: mad.u32 24
	<onDestroy+?>: inc.i32(+16)
	<onDestroy+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:622: (14 bytes): view.onDestroy(view);
	<onDestroy+?>: dup.x32 sp(0)
	<onDestroy+?>: dup.x32 sp(1)
	<onDestroy+?>: inc.i32(+44)
	<onDestroy+?>: load.i32
	<onDestroy+?>: call
	<onDestroy+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:623: (6 bytes): destroy(view);
	<onDestroy+?>: dup.x32 sp(0)
	<onDestroy+?>: nfc(8) ;object.destroy(this: object): void
	<onDestroy+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:620: (4 bytes): i := i + 1
	<onDestroy+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.core.ci:620: (14 bytes): i < this.itemCount
	<onDestroy+?>: dup.x32 sp(0)
	<onDestroy+?>: dup.x32 sp(3)
	<onDestroy+?>: inc.i32(+72)
	<onDestroy+?>: load.i32
	<onDestroy+?>: clt.i32
	<onDestroy+?>: jnz -56
	<onDestroy+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:625: (16 bytes): pointer.alloc(this.items, 0);
	<onDestroy+?>: dup.x32 sp(1)
	<onDestroy+?>: inc.i32(+68)
	<onDestroy+?>: load.i32
	<onDestroy+?>: load.z32
	<onDestroy+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<onDestroy+?>: inc.sp(-4)
	<onDestroy+?>: ret
.usages:
}
Layout.onKeyEvent(this: Layout, event: KeyEvent): bool: function {
.kind: static function
.base: `function`
.size: 89
.name: 'onKeyEvent'
.file: 'cmplGfx/lib/micro.ui.core.ci:628'
.owner: Layout
.param .result: bool (size: 4, cast: variable(bool))
.param this: Layout (size: 4, cast: variable(ref))
.param event: KeyEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a KeyEvent: press or release'
.value: {
	if (!this.enabled) {
		return .result := false;
	}
	idx: int32 := this.focusedIndex;
	if (idx < 0) {
		return .result := false;
	}
	view: View := this.items[idx].view;
	return .result := view.onKeyEvent(view, event);
}
.instructions: (89 bytes)
	cmplGfx/lib/micro.ui.core.ci:629: (18 bytes): if (!this.enabled)
	<onKeyEvent>  : dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jnz +11
	cmplGfx/lib/micro.ui.core.ci:631: (7 bytes): return .result := false;
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:634: (7 bytes): idx: int32 := this.focusedIndex
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+88)
	<onKeyEvent+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:635: (19 bytes): if (idx < 0)
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: clt.i32
	<onKeyEvent+?>: jz +15
	cmplGfx/lib/micro.ui.core.ci:636: (11 bytes): return .result := false;
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: load.sp(+20)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:639: (18 bytes): view: View := this.items[idx].view
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+68)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: mad.u32 24
	<onKeyEvent+?>: inc.i32(+16)
	<onKeyEvent+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:640: (27 bytes): return .result := view.onKeyEvent(view, event);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: dup.x32 sp(5)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+48)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+24)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:1196: referenced as `onKeyEvent`
}
Layout.onTouchEvent(this: Layout, rect: Rect, event: TouchEvent): bool: function {
.kind: static function
.base: `function`
.size: 799
.name: 'onTouchEvent'
.file: 'cmplGfx/lib/micro.ui.core.ci:643'
.owner: Layout
.param .result: bool (size: 4, cast: variable(bool))
.param this: Layout (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: const variable(ref))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a TouchEvent: press, motion or release'
.value: {
	static findView(this: Layout, x: int32, y: int32): int32 := {
		for (i: int32 := 0; i < this.itemCount; i := i + 1) {
			item: Item := this.items[i];
			if (item.view.enabled && contains(item.rect, x, y)) {
				return .result := i;
			}
		}
		return .result := -1;
	};
	if (!this.enabled) {
		return .result := false;
	}
	result: bool := false;
	active: int32 := this.pressedIndex;
	if (!((event.dx) || (event.dy) || event.release) || !(event.button)) {
		active := findView(this, event.x, event.y);
	}
	if (active < 0) {
		states: int32 := Style.hovered;
		if (event.release) {
			states := states | Style.pressed;
		}
		return .result := clearState(this, states);
	}
	item: Item := this.items[active];
	view: View := item.view;
	if (!view.enabled) {
		states: int32 := Style.hovered;
		if (event.release) {
			states := states | Style.pressed;
		}
		return .result := clearState(this, states);
	}
	if (this.pressedIndex != active && TouchEvent.isPress(event, 1)) {
		clearState(this, Style.pressed);
		this.pressedIndex := active;
		result := true;
	}
	outside: bool := !TouchEvent.test(event, item.rect);
	if (this.hoveredIndex != active || outside) {
		if (clearState(this, Style.hovered)) {
			result := true;
		}
		if (!outside) {
			this.hoveredIndex := active;
			result := true;
		}
	}
	if (event.release && outside) {
		return .result := clearState(this, Style.pressed | Style.hovered);
	}
	if (view.onTouchEvent(view, item.rect, event)) {
		result := true;
	}
	if (!event.release) {
		return .result := result;
	}
	focusable: bool := view.focusable;
	if (outside) {
		focusable := false;
	}
	else if (event.clicks < 0) {
		clearState(this, Style.hovered);
		focusable := false;
	}
	else if (this.focusedIndex == active) {
		focusable := false;
	}
	else if ((layout) != null) {
		if (layout.focusedIndex == -1) {
			focusable := false;
		}
	}
	if (focusable) {
		clearState(this, Style.focused);
		this.focusedIndex := active;
		result := true;
	}
	if (clearState(this, Style.pressed)) {
		return .result := true;
	}
	return .result := result;
}
.instructions: (799 bytes)
	cmplGfx/lib/micro.ui.core.ci:654: (18 bytes): if (!this.enabled)
	<onTouchEvent>  : dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+12)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jnz +11
	cmplGfx/lib/micro.ui.core.ci:656: (7 bytes): return .result := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:659: (1 byte): result: bool := false
	<onTouchEvent+?>: load.z32
	cmplGfx/lib/micro.ui.core.ci:660: (7 bytes): active: int32 := this.pressedIndex
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: inc.i32(+84)
	<onTouchEvent+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:661: (92 bytes): if (!((event.dx) || (event.dy) || event.release) || !(event.button))
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+12)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: i32.2bool
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jnz +16
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+16)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: i32.2bool
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jnz +11
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jnz +17
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+8)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: i32.2bool
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: jz +33
	cmplGfx/lib/micro.ui.core.ci:662: (29 bytes): active := findView(this, event.x, event.y);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+20)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: inc.i32(+24)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.ref <?> ;Layout.onTouchEvent.findView(this: Layout, x: int32, y: int32): int32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:665: (55 bytes): if (active < 0)
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: clt.i32
	<onTouchEvent+?>: jz +51
	cmplGfx/lib/micro.ui.core.ci:667: (5 bytes): states: int32 := Style.hovered
	<onTouchEvent+?>: load.c32 1
	cmplGfx/lib/micro.ui.core.ci:668: (13 bytes): if (event.release)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jz +10
	cmplGfx/lib/micro.ui.core.ci:669: (6 bytes): states := states | Style.pressed;
	<onTouchEvent+?>: load.c32 2
	<onTouchEvent+?>: or.b32
	cmplGfx/lib/micro.ui.core.ci:671: (25 bytes): return .result := clearState(this, states);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: load.sp(+32)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: ret
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:674: (13 bytes): item: Item := this.items[active]
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+68)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: mad.u32 24
	cmplGfx/lib/micro.ui.core.ci:675: (7 bytes): view: View := item.view
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: inc.i32(+16)
	<onTouchEvent+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:676: (58 bytes): if (!view.enabled)
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: inc.i32(+12)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jnz +51
	cmplGfx/lib/micro.ui.core.ci:678: (5 bytes): states: int32 := Style.hovered
	<onTouchEvent+?>: load.c32 1
	cmplGfx/lib/micro.ui.core.ci:679: (13 bytes): if (event.release)
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jz +10
	cmplGfx/lib/micro.ui.core.ci:680: (6 bytes): states := states | Style.pressed;
	<onTouchEvent+?>: load.c32 2
	<onTouchEvent+?>: or.b32
	cmplGfx/lib/micro.ui.core.ci:682: (25 bytes): return .result := clearState(this, states);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(9)
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: load.sp(+40)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-20)
	<onTouchEvent+?>: ret
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:685: (84 bytes): if (this.pressedIndex != active && TouchEvent.isPress(event, 1))
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: inc.i32(+84)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: ceq.i32
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jz +26
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.ref <?> ;TouchEvent.isPress(event: TouchEvent, button: int32): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: jz +45
	cmplGfx/lib/micro.ui.core.ci:687: (22 bytes): clearState(this, Style.pressed);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(8)
	<onTouchEvent+?>: load.c32 2
	<onTouchEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:688: (9 bytes): this.pressedIndex := active;
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: dup.x32 sp(8)
	<onTouchEvent+?>: inc.i32(+84)
	<onTouchEvent+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:689: (10 bytes): result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+16)
	<onTouchEvent+?>: store.i8
	cmplGfx/lib/micro.ui.core.ci:692: (16 bytes): outside: bool := !TouchEvent.test(event, item.rect)
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: load.ref <?> ;TouchEvent.test(event: TouchEvent, rect: Rect): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: not.b32
	cmplGfx/lib/micro.ui.core.ci:693: (90 bytes): if (this.hoveredIndex != active || outside)
	<onTouchEvent+?>: dup.x32 sp(8)
	<onTouchEvent+?>: inc.i32(+80)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: ceq.i32
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jnz +13
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: load.sp(+0)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jz +64
	cmplGfx/lib/micro.ui.core.ci:695: (32 bytes): if (clearState(this, Style.hovered))
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(9)
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: jz +14
	cmplGfx/lib/micro.ui.core.ci:696: (10 bytes): result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	cmplGfx/lib/micro.ui.core.ci:698: (28 bytes): if (!outside)
	<onTouchEvent+?>: load.sp(+0)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jnz +23
	cmplGfx/lib/micro.ui.core.ci:699: (9 bytes): this.hoveredIndex := active;
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: dup.x32 sp(9)
	<onTouchEvent+?>: inc.i32(+80)
	<onTouchEvent+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:700: (10 bytes): result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	cmplGfx/lib/micro.ui.core.ci:704: (56 bytes): if (event.release && outside)
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jz +13
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: load.sp(+0)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jz +38
	cmplGfx/lib/micro.ui.core.ci:706: (34 bytes): return .result := clearState(this, Style.pressed | Style.hovered);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(9)
	<onTouchEvent+?>: load.c32 2
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: or.b32
	<onTouchEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: load.sp(+40)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-20)
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:709: (33 bytes): if (view.onTouchEvent(view, item.rect, event))
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(9)
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+52)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: jz +14
	cmplGfx/lib/micro.ui.core.ci:711: (10 bytes): result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	cmplGfx/lib/micro.ui.core.ci:714: (22 bytes): if (!event.release)
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jnz +19
	cmplGfx/lib/micro.ui.core.ci:715: (15 bytes): return .result := result;
	<onTouchEvent+?>: load.sp(+16)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: load.sp(+40)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-20)
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:718: (7 bytes): focusable: bool := view.focusable
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+13)
	<onTouchEvent+?>: load.is8
	cmplGfx/lib/micro.ui.core.ci:719: (138 bytes): if (outside)
	<onTouchEvent+?>: load.sp(+4)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jz +14
	cmplGfx/lib/micro.ui.core.ci:720: (6 bytes): focusable := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+4)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: jmp +123
	cmplGfx/lib/micro.ui.core.ci:722: (119 bytes): if (event.clicks < 0)
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: inc.i32(+4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: clt.i32
	<onTouchEvent+?>: jz +36
	cmplGfx/lib/micro.ui.core.ci:724: (22 bytes): clearState(this, Style.hovered);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(10)
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:725: (6 bytes): focusable := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+4)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: jmp +78
	cmplGfx/lib/micro.ui.core.ci:727: (74 bytes): if (this.focusedIndex == active)
	<onTouchEvent+?>: dup.x32 sp(9)
	<onTouchEvent+?>: inc.i32(+88)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: ceq.i32
	<onTouchEvent+?>: jz +14
	cmplGfx/lib/micro.ui.core.ci:729: (6 bytes): focusable := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+4)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: jmp +54
	cmplGfx/lib/micro.ui.core.ci:731: (50 bytes): if ((layout) != null)
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: load.ref <?> ;Layout
	<onTouchEvent+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: load.ref <?> ;null
	<onTouchEvent+?>: ceq.i32
	<onTouchEvent+?>: jnz +27
	cmplGfx/lib/micro.ui.core.ci:732: (23 bytes): if (layout.focusedIndex == -1)
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: inc.i32(+88)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.c32 -1
	<onTouchEvent+?>: ceq.i32
	<onTouchEvent+?>: jz +10
	cmplGfx/lib/micro.ui.core.ci:734: (6 bytes): focusable := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+8)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:738: (50 bytes): if (focusable)
	<onTouchEvent+?>: load.sp(+0)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jz +45
	cmplGfx/lib/micro.ui.core.ci:739: (22 bytes): clearState(this, Style.focused);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(10)
	<onTouchEvent+?>: load.c32 4
	<onTouchEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:740: (9 bytes): this.focusedIndex := active;
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(10)
	<onTouchEvent+?>: inc.i32(+88)
	<onTouchEvent+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:741: (10 bytes): result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+24)
	<onTouchEvent+?>: store.i8
	cmplGfx/lib/micro.ui.core.ci:743: (37 bytes): if (clearState(this, Style.pressed))
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(10)
	<onTouchEvent+?>: load.c32 2
	<onTouchEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: jz +19
	cmplGfx/lib/micro.ui.core.ci:744: (15 bytes): return .result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+44)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-24)
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:746: (15 bytes): return .result := result;
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: load.sp(+44)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-24)
	<onTouchEvent+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:871: referenced as `onTouchEvent`
}
Layout.onMeasure(this: Layout, measured: Rect): bool: function {
.kind: static function
.base: `function`
.size: 448
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.core.ci:749'
.owner: Layout
.param .result: bool (size: 4, cast: variable(bool))
.param this: Layout (size: 4, cast: variable(ref))
.param measured: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	dir: int32 := this.orientation;
	N: int32 := Math.abs(dir);
	n: int32 := 0;
	maxWidth: int32 := 0;
	sumWidth: int32 := 0;
	maxHeight: int32 := 0;
	sumHeight: int32 := 0;
	rows: int32 := dir < 0 ? N : 1;
	cols: int32 := dir > 0 ? N : 1;
	for (i: int32 := 0; i < this.itemCount; i := i + 1) {
		item: Item := this.items[i];
		rect: Rect := item.rect;
		view: View := item.view;
		rect.x0 := rect.x1 := 0;
		rect.y0 := rect.y1 := 0;
		if (view.onMeasure(view, &rect)) {
			width: int32 := width(rect);
			height: int32 := height(rect);
			if (n >= N) {
				cols := cols + int32(dir < 0);
				rows := rows + int32(dir > 0);
				n := 0;
			}
			sumWidth := sumWidth + width;
			if (maxWidth < width) {
				maxWidth := width;
			}
			sumHeight := sumHeight + height;
			if (maxHeight < height) {
				maxHeight := height;
			}
			n := n + 1;
		}
	}
	if (rows == 1 && cols == 1) {
		sumWidth := maxWidth;
		sumHeight := maxHeight;
	}
	if (rows > 1) {
		sumWidth := maxWidth * cols;
	}
	if (cols > 1) {
		sumHeight := maxHeight * rows;
	}
	width(measured, sumWidth + this.paddingLeft + this.paddingRight);
	height(measured, sumHeight + this.paddingTop + this.paddingBottom);
	return .result := View.onMeasure(this, &measured);
}
.instructions: (448 bytes)
	cmplGfx/lib/micro.ui.core.ci:750: (7 bytes): dir: int32 := this.orientation
	<onMeasure>  : dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+108)
	<onMeasure+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:751: (21 bytes): N: int32 := Math.abs(dir)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: load.z32
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jz +11
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: neg.i32
	<onMeasure+?>: jmp +6
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:752: (1 byte): n: int32 := 0
	<onMeasure+?>: load.z32
	cmplGfx/lib/micro.ui.core.ci:753: (1 byte): maxWidth: int32 := 0
	<onMeasure+?>: load.z32
	cmplGfx/lib/micro.ui.core.ci:754: (1 byte): sumWidth: int32 := 0
	<onMeasure+?>: load.z32
	cmplGfx/lib/micro.ui.core.ci:755: (1 byte): maxHeight: int32 := 0
	<onMeasure+?>: load.z32
	cmplGfx/lib/micro.ui.core.ci:756: (1 byte): sumHeight: int32 := 0
	<onMeasure+?>: load.z32
	cmplGfx/lib/micro.ui.core.ci:757: (19 bytes): rows: int32 := dir < 0 ? N : 1
	<onMeasure+?>: dup.x32 sp(6)
	<onMeasure+?>: load.z32
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jz +10
	<onMeasure+?>: dup.x32 sp(5)
	<onMeasure+?>: jmp +9
	<onMeasure+?>: load.c32 1
	cmplGfx/lib/micro.ui.core.ci:758: (19 bytes): cols: int32 := dir > 0 ? N : 1
	<onMeasure+?>: dup.x32 sp(7)
	<onMeasure+?>: load.z32
	<onMeasure+?>: cgt.i32
	<onMeasure+?>: jz +10
	<onMeasure+?>: dup.x32 sp(6)
	<onMeasure+?>: jmp +9
	<onMeasure+?>: load.c32 1
	cmplGfx/lib/micro.ui.core.ci:759: (218 bytes): for (i: int32 := 0; i < this.itemCount; i := i + 1)
	<onMeasure+?>: load.z32
	<onMeasure+?>: jmp +199
	cmplGfx/lib/micro.ui.core.ci:760: (13 bytes): item: Item := this.items[i]
	<onMeasure+?>: dup.x32 sp(12)
	<onMeasure+?>: inc.i32(+68)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: mad.u32 24
	cmplGfx/lib/micro.ui.core.ci:761: (2 bytes): rect: Rect := item.rect
	<onMeasure+?>: dup.x32 sp(0)
	cmplGfx/lib/micro.ui.core.ci:762: (7 bytes): view: View := item.view
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: inc.i32(+16)
	<onMeasure+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:763: (13 bytes): rect.x0 := rect.x1 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: store.i32
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:764: (17 bytes): rect.y0 := rect.y1 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: inc.i32(+12)
	<onMeasure+?>: store.i32
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+4)
	<onMeasure+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:765: (135 bytes): if (view.onMeasure(view, &rect))
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: inc.i32(+56)
	<onMeasure+?>: load.i32
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: jz +118
	cmplGfx/lib/micro.ui.core.ci:766: (15 bytes): width: int32 := width(rect)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:767: (19 bytes): height: int32 := height(rect)
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+12)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: inc.i32(+4)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:768: (30 bytes): if (n >= N)
	<onMeasure+?>: dup.x32 sp(12)
	<onMeasure+?>: dup.x32 sp(14)
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jnz +25
	cmplGfx/lib/micro.ui.core.ci:769: (9 bytes): cols := cols + int32(dir < 0);
	<onMeasure+?>: dup.x32 sp(6)
	<onMeasure+?>: dup.x32 sp(15)
	<onMeasure+?>: load.z32
	<onMeasure+?>: clt.i32
	<onMeasure+?>: add.i32
	<onMeasure+?>: set.x32 sp(7)
	cmplGfx/lib/micro.ui.core.ci:770: (9 bytes): rows := rows + int32(dir > 0);
	<onMeasure+?>: dup.x32 sp(7)
	<onMeasure+?>: dup.x32 sp(15)
	<onMeasure+?>: load.z32
	<onMeasure+?>: cgt.i32
	<onMeasure+?>: add.i32
	<onMeasure+?>: set.x32 sp(8)
	cmplGfx/lib/micro.ui.core.ci:771: (3 bytes): n := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: set.x32 sp(13)
	cmplGfx/lib/micro.ui.core.ci:773: (7 bytes): sumWidth := sumWidth + width;
	<onMeasure+?>: dup.x32 sp(10)
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: add.i32
	<onMeasure+?>: set.x32 sp(11)
	cmplGfx/lib/micro.ui.core.ci:774: (12 bytes): if (maxWidth < width)
	<onMeasure+?>: dup.x32 sp(11)
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jz +7
	cmplGfx/lib/micro.ui.core.ci:775: (3 bytes): maxWidth := width;
	<onMeasure+?>: mov.x32 sp(11, 1)
	cmplGfx/lib/micro.ui.core.ci:777: (7 bytes): sumHeight := sumHeight + height;
	<onMeasure+?>: dup.x32 sp(8)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: add.i32
	<onMeasure+?>: set.x32 sp(9)
	cmplGfx/lib/micro.ui.core.ci:778: (12 bytes): if (maxHeight < height)
	<onMeasure+?>: dup.x32 sp(9)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jz +7
	cmplGfx/lib/micro.ui.core.ci:779: (3 bytes): maxHeight := height;
	<onMeasure+?>: mov.x32 sp(9, 0)
	cmplGfx/lib/micro.ui.core.ci:781: (8 bytes): n := n + 1;
	<onMeasure+?>: dup.x32 sp(12)
	<onMeasure+?>: inc.i32(+1)
	<onMeasure+?>: set.x32 sp(13)
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:759: (4 bytes): i := i + 1
	<onMeasure+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.core.ci:759: (14 bytes): i < this.itemCount
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(13)
	<onMeasure+?>: inc.i32(+72)
	<onMeasure+?>: load.i32
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jnz -205
	<onMeasure+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:784: (36 bytes): if (rows == 1 && cols == 1)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.c32 1
	<onMeasure+?>: ceq.i32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: jz +16
	<onMeasure+?>: inc.sp(-4)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: load.c32 1
	<onMeasure+?>: ceq.i32
	<onMeasure+?>: jz +10
	cmplGfx/lib/micro.ui.core.ci:785: (3 bytes): sumWidth := maxWidth;
	<onMeasure+?>: mov.x32 sp(4, 5)
	cmplGfx/lib/micro.ui.core.ci:786: (3 bytes): sumHeight := maxHeight;
	<onMeasure+?>: mov.x32 sp(2, 3)
	cmplGfx/lib/micro.ui.core.ci:788: (19 bytes): if (rows > 1)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.c32 1
	<onMeasure+?>: cgt.i32
	<onMeasure+?>: jz +11
	cmplGfx/lib/micro.ui.core.ci:790: (7 bytes): sumWidth := maxWidth * cols;
	<onMeasure+?>: dup.x32 sp(5)
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: mul.i32
	<onMeasure+?>: set.x32 sp(5)
	cmplGfx/lib/micro.ui.core.ci:792: (19 bytes): if (cols > 1)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: load.c32 1
	<onMeasure+?>: cgt.i32
	<onMeasure+?>: jz +11
	cmplGfx/lib/micro.ui.core.ci:794: (7 bytes): sumHeight := maxHeight * rows;
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: mul.i32
	<onMeasure+?>: set.x32 sp(3)
	cmplGfx/lib/micro.ui.core.ci:796: (30 bytes): width(measured, sumWidth + this.paddingLeft + this.paddingRight);
	<onMeasure+?>: dup.x32 sp(10)
	<onMeasure+?>: dup.x32 sp(5)
	<onMeasure+?>: dup.x32 sp(13)
	<onMeasure+?>: inc.i32(+96)
	<onMeasure+?>: load.i32
	<onMeasure+?>: add.i32
	<onMeasure+?>: dup.x32 sp(13)
	<onMeasure+?>: inc.i32(+100)
	<onMeasure+?>: load.i32
	<onMeasure+?>: add.i32
	<onMeasure+?>: load.ref <?> ;width(rectangle: Rect, width: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:797: (30 bytes): height(measured, sumHeight + this.paddingTop + this.paddingBottom);
	<onMeasure+?>: dup.x32 sp(10)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(13)
	<onMeasure+?>: inc.i32(+92)
	<onMeasure+?>: load.i32
	<onMeasure+?>: add.i32
	<onMeasure+?>: dup.x32 sp(13)
	<onMeasure+?>: inc.i32(+104)
	<onMeasure+?>: load.i32
	<onMeasure+?>: add.i32
	<onMeasure+?>: load.ref <?> ;height(rectangle: Rect, height: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:798: (25 bytes): return .result := View.onMeasure(this, &measured);
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(12)
	<onMeasure+?>: dup.x32 sp(12)
	<onMeasure+?>: load.ref <?> ;View.onMeasure(this: View, rect: Rect): bool
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: load.sp(+52)
	<onMeasure+?>: store.i8
	<onMeasure+?>: inc.sp(-36)
	<onMeasure+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:961: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.ci:648: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.ci:620: referenced as `onMeasure`
	cmplGfx/lib/micro.ui.core.ci:1219: referenced as `onMeasure`
}
Layout.onLayout(this: Layout, measured: Rect): void: function {
.kind: static function
.base: `function`
.size: 411
.name: 'onLayout'
.file: 'cmplGfx/lib/micro.ui.core.ci:803'
.owner: Layout
.param .result: void (size: 0, cast: variable(void))
.param this: Layout (size: 4, cast: variable(ref))
.param measured: Rect (size: 4, cast: variable(ref))
.value: {
	static verticalLayout(this: Layout, measured: Rect, cols: int32): void := {
		rowSpacing: int32 := width(measured) / cols;
		colSpacing: int32 := 0;
		grow: int32 := 0;
		if (true) {
			maxSize: int32 := 0;
			sumSize: int32 := 0;
			rows: int32 := 0;
			n: int32 := cols;
			for (i: int32 := 0; i < this.itemCount; i := i + 1) {
				rect: Rect := this.items[i].rect;
				if (!empty(rect)) {
					if (n >= cols) {
						sumSize := sumSize + maxSize;
						maxSize := 0;
						rows := rows + 1;
						n := 0;
					}
					if (maxSize < height(rect)) {
						maxSize := height(rect);
					}
					if (colSpacing < maxSize) {
						colSpacing := maxSize;
					}
					n := n + 1;
				}
			}
			sumSize := sumSize + maxSize;
			if (rows > 0 && height(measured) > sumSize) {
				grow := (height(measured) - sumSize) / rows;
			}
		}
		r: Rect := {
			r.x0 := measured.x0;
			r.y0 := measured.y0;
			r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
			r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
		};
		n: int32 := cols;
		translateY(r, -colSpacing - grow);
		for (i: int32 := 0; i < this.itemCount; i := i + 1) {
			item: Item := this.items[i];
			rect: Rect := item.rect;
			if (empty(rect)) {
				continue;
			}
			if (n >= cols) {
				positionX(r, measured.x0);
				translateY(r, colSpacing + grow);
				if (cols == 1) {
					colSpacing := height(rect);
				}
				n := 0;
			}
			width(r, rowSpacing);
			height(r, colSpacing + grow);
			view: View := item.view;
			align: int32 := item.align;
			if (view.width > 0 && Style.vertical(align)) {
				align := align & ~Style.vertical;
			}
			if (view.height > 0 && Style.horizontal(align)) {
				align := align & ~Style.horizontal;
			}
			Style.align(r, &rect, align);
			if ((layout) != null) {
				layout.onLayout(layout, &rect);
			}
			translateX(r, rowSpacing);
			n := n + 1;
		}
	};
	static horizontalLayout(this: Layout, measured: Rect, rows: int32): void := {
		colSpacing: int32 := height(measured) / rows;
		rowSpacing: int32 := 0;
		grow: int32 := 0;
		if (true) {
			maxSize: int32 := 0;
			sumSize: int32 := 0;
			cols: int32 := 0;
			n: int32 := rows;
			for (i: int32 := 0; i < this.itemCount; i := i + 1) {
				rect: Rect := this.items[i].rect;
				if (!empty(rect)) {
					if (n >= rows) {
						sumSize := sumSize + maxSize;
						maxSize := 0;
						cols := cols + 1;
						n := 0;
					}
					if (maxSize < width(rect)) {
						maxSize := width(rect);
					}
					if (rowSpacing < width(rect)) {
						rowSpacing := width(rect);
					}
					n := n + 1;
				}
			}
			sumSize := sumSize + maxSize;
			if (cols > 0 && width(measured) > sumSize) {
				grow := (width(measured) - sumSize) / cols;
			}
		}
		r: Rect := {
			r.x0 := measured.x0;
			r.y0 := measured.y0;
			r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
			r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
		};
		n: int32 := rows;
		translateX(r, -rowSpacing - grow);
		for (i: int32 := 0; i < this.itemCount; i := i + 1) {
			item: Item := this.items[i];
			rect: Rect := item.rect;
			if (empty(rect)) {
				continue;
			}
			if (n >= rows) {
				positionY(r, measured.y0);
				translateX(r, rowSpacing + grow);
				if (rows == 1) {
					rowSpacing := width(rect);
				}
				n := 0;
			}
			width(r, rowSpacing + grow);
			height(r, colSpacing);
			view: View := item.view;
			align: int32 := item.align;
			if (view.width > 0 && Style.vertical(align)) {
				align := align & ~Style.vertical;
			}
			if (view.height > 0 && Style.horizontal(align)) {
				align := align & ~Style.horizontal;
			}
			Style.align(r, &rect, align);
			if ((layout) != null) {
				layout.onLayout(layout, &rect);
			}
			translateY(r, colSpacing);
			n := n + 1;
		}
	};
	static addPadding(const this: Layout, rect: Rect, multiplier: int32): void := {
		rect.x0 := rect.x0 - multiplier * this.paddingLeft;
		rect.y0 := rect.y0 - multiplier * this.paddingTop;
		rect.x1 := rect.x1 + multiplier * this.paddingRight;
		rect.y1 := rect.y1 + multiplier * this.paddingBottom;
	};
	addPadding(this, &measured, -1);
	if (this.orientation > 0) {
		verticalLayout(this, &measured, this.orientation);
		addPadding(this, &measured, 1);
		return;
	}
	if (this.orientation < 0) {
		horizontalLayout(this, &measured, -this.orientation);
		addPadding(this, &measured, 1);
		return;
	}
	r: Rect := {
		r.x0 := measured.x0;
		r.y0 := measured.y0;
		r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
		r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
	};
	for (i: int32 := 0; i < this.itemCount; i := i + 1) {
		const item: Item := this.items[i];
		const rect: Rect := item.rect;
		if (empty(rect)) {
			continue;
		}
		const view: View := item.view;
		Style.align(measured, &rect, item.align);
		if ((layout) != null) {
			layout.onLayout(layout, &rect);
		}
	}
	addPadding(this, &measured, 1);
}
.instructions: (411 bytes)
	cmplGfx/lib/micro.ui.core.ci:981: (19 bytes): addPadding(this, &measured, -1);
	<onLayout>  : dup.x32 sp(2)
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: load.c32 -1
	<onLayout+?>: load.ref <?> ;Layout.onLayout.addPadding(this: Layout, rect: Rect, multiplier: int32): void
	<onLayout+?>: call
	<onLayout+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:982: (54 bytes): if (this.orientation > 0)
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: inc.i32(+108)
	<onLayout+?>: load.i32
	<onLayout+?>: load.z32
	<onLayout+?>: cgt.i32
	<onLayout+?>: jz +45
	cmplGfx/lib/micro.ui.core.ci:989: (21 bytes): verticalLayout(this, &measured, this.orientation);
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: dup.x32 sp(4)
	<onLayout+?>: inc.i32(+108)
	<onLayout+?>: load.i32
	<onLayout+?>: load.ref <?> ;Layout.onLayout.verticalLayout(this: Layout, measured: Rect, cols: int32): void
	<onLayout+?>: call
	<onLayout+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:990: (19 bytes): addPadding(this, &measured, 1);
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: load.c32 1
	<onLayout+?>: load.ref <?> ;Layout.onLayout.addPadding(this: Layout, rect: Rect, multiplier: int32): void
	<onLayout+?>: call
	<onLayout+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:991: (1 byte): return;
	<onLayout+?>: ret
	cmplGfx/lib/micro.ui.core.ci:994: (55 bytes): if (this.orientation < 0)
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: inc.i32(+108)
	<onLayout+?>: load.i32
	<onLayout+?>: load.z32
	<onLayout+?>: clt.i32
	<onLayout+?>: jz +46
	cmplGfx/lib/micro.ui.core.ci:1000: (22 bytes): horizontalLayout(this, &measured, -this.orientation);
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: dup.x32 sp(4)
	<onLayout+?>: inc.i32(+108)
	<onLayout+?>: load.i32
	<onLayout+?>: neg.i32
	<onLayout+?>: load.ref <?> ;Layout.onLayout.horizontalLayout(this: Layout, measured: Rect, rows: int32): void
	<onLayout+?>: call
	<onLayout+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:1001: (19 bytes): addPadding(this, &measured, 1);
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: load.c32 1
	<onLayout+?>: load.ref <?> ;Layout.onLayout.addPadding(this: Layout, rect: Rect, multiplier: int32): void
	<onLayout+?>: call
	<onLayout+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:1002: (1 byte): return;
	<onLayout+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1006: (116 bytes): r: Rect := {...}
	<onLayout+?>: inc.sp(+16)
	cmplGfx/lib/micro.ui.core.ci:1007: (5 bytes): r.x0 := measured.x0;
	<onLayout+?>: dup.x32 sp(5)
	<onLayout+?>: load.i32
	<onLayout+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:1008: (9 bytes): r.y0 := measured.y0;
	<onLayout+?>: dup.x32 sp(5)
	<onLayout+?>: inc.i32(+4)
	<onLayout+?>: load.i32
	<onLayout+?>: set.x32 sp(2)
	cmplGfx/lib/micro.ui.core.ci:1009: (45 bytes): r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
	<onLayout+?>: dup.x32 sp(5)
	<onLayout+?>: load.i32
	<onLayout+?>: dup.x32 sp(7)
	<onLayout+?>: inc.i32(+4)
	<onLayout+?>: load.i32
	<onLayout+?>: load.z32
	<onLayout+?>: cgt.i32
	<onLayout+?>: jz +15
	<onLayout+?>: dup.x32 sp(7)
	<onLayout+?>: inc.i32(+4)
	<onLayout+?>: load.i32
	<onLayout+?>: jmp +19
	<onLayout+?>: dup.x32 sp(6)
	<onLayout+?>: dup.x32 sp(0)
	<onLayout+?>: inc.i32(+8)
	<onLayout+?>: load.i32
	<onLayout+?>: dup.x32 sp(1)
	<onLayout+?>: load.i32
	<onLayout+?>: sub.i32
	<onLayout+?>: set.x32 sp(1)
	<onLayout+?>: add.i32
	<onLayout+?>: set.x32 sp(3)
	cmplGfx/lib/micro.ui.core.ci:1010: (53 bytes): r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
	<onLayout+?>: dup.x32 sp(5)
	<onLayout+?>: inc.i32(+4)
	<onLayout+?>: load.i32
	<onLayout+?>: dup.x32 sp(7)
	<onLayout+?>: inc.i32(+8)
	<onLayout+?>: load.i32
	<onLayout+?>: load.z32
	<onLayout+?>: cgt.i32
	<onLayout+?>: jz +15
	<onLayout+?>: dup.x32 sp(7)
	<onLayout+?>: inc.i32(+8)
	<onLayout+?>: load.i32
	<onLayout+?>: jmp +23
	<onLayout+?>: dup.x32 sp(6)
	<onLayout+?>: dup.x32 sp(0)
	<onLayout+?>: inc.i32(+12)
	<onLayout+?>: load.i32
	<onLayout+?>: dup.x32 sp(1)
	<onLayout+?>: inc.i32(+4)
	<onLayout+?>: load.i32
	<onLayout+?>: sub.i32
	<onLayout+?>: set.x32 sp(1)
	<onLayout+?>: add.i32
	<onLayout+?>: set.x32 sp(4)
	cmplGfx/lib/micro.ui.core.ci:1013: (143 bytes): for (i: int32 := 0; i < this.itemCount; i := i + 1)
	<onLayout+?>: load.z32
	<onLayout+?>: jmp +124
	cmplGfx/lib/micro.ui.core.ci:1014: (13 bytes): const item: Item := this.items[i]
	<onLayout+?>: dup.x32 sp(7)
	<onLayout+?>: inc.i32(+68)
	<onLayout+?>: load.i32
	<onLayout+?>: dup.x32 sp(1)
	<onLayout+?>: mad.u32 24
	cmplGfx/lib/micro.ui.core.ci:1015: (2 bytes): const rect: Rect := item.rect
	<onLayout+?>: dup.x32 sp(0)
	cmplGfx/lib/micro.ui.core.ci:1016: (25 bytes): if (empty(rect))
	<onLayout+?>: load.z32
	<onLayout+?>: dup.x32 sp(1)
	<onLayout+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<onLayout+?>: call
	<onLayout+?>: inc.sp(-4)
	<onLayout+?>: jz +12
	cmplGfx/lib/micro.ui.core.ci:1017: (8 bytes): continue;
	<onLayout+?>: inc.sp(-8)
	<onLayout+?>: jmp +80
	cmplGfx/lib/micro.ui.core.ci:1020: (7 bytes): const view: View := item.view
	<onLayout+?>: dup.x32 sp(1)
	<onLayout+?>: inc.i32(+16)
	<onLayout+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:1021: (22 bytes): Style.align(measured, &rect, item.align);
	<onLayout+?>: dup.x32 sp(9)
	<onLayout+?>: load.i128
	<onLayout+?>: dup.x32 sp(5)
	<onLayout+?>: dup.x32 sp(7)
	<onLayout+?>: inc.i32(+20)
	<onLayout+?>: load.i32
	<onLayout+?>: load.ref <?> ;Style.align(parent: Rect, rect: Rect, align: int32): void
	<onLayout+?>: call
	<onLayout+?>: inc.sp(-24)
	cmplGfx/lib/micro.ui.core.ci:1022: (43 bytes): if ((layout) != null)
	<onLayout+?>: dup.x32 sp(0)
	<onLayout+?>: load.ref <?> ;Layout
	<onLayout+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<onLayout+?>: dup.x32 sp(0)
	<onLayout+?>: load.ref <?> ;null
	<onLayout+?>: ceq.i32
	<onLayout+?>: jnz +20
	cmplGfx/lib/micro.ui.core.ci:1023: (16 bytes): layout.onLayout(layout, &rect);
	<onLayout+?>: dup.x32 sp(0)
	<onLayout+?>: dup.x32 sp(3)
	<onLayout+?>: dup.x32 sp(2)
	<onLayout+?>: inc.i32(+112)
	<onLayout+?>: load.i32
	<onLayout+?>: call
	<onLayout+?>: inc.sp(-8)
	<onLayout+?>: inc.sp(-4)
	<onLayout+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:1013: (4 bytes): i := i + 1
	<onLayout+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.core.ci:1013: (14 bytes): i < this.itemCount
	<onLayout+?>: dup.x32 sp(0)
	<onLayout+?>: dup.x32 sp(8)
	<onLayout+?>: inc.i32(+72)
	<onLayout+?>: load.i32
	<onLayout+?>: clt.i32
	<onLayout+?>: jnz -130
	<onLayout+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1026: (19 bytes): addPadding(this, &measured, 1);
	<onLayout+?>: dup.x32 sp(6)
	<onLayout+?>: dup.x32 sp(6)
	<onLayout+?>: load.c32 1
	<onLayout+?>: load.ref <?> ;Layout.onLayout.addPadding(this: Layout, rect: Rect, multiplier: int32): void
	<onLayout+?>: call
	<onLayout+?>: inc.sp(-12)
	<onLayout+?>: inc.sp(-16)
	<onLayout+?>: ret
.usages:
}
Layout.onLayout(this: Layout, measured: Rect): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onLayout'
.file: 'cmplGfx/lib/micro.ui.core.ci:803'
.owner: Layout
.param .result: void (size: 0, cast: variable(void))
.param this: Layout (size: 4, cast: variable(ref))
.param measured: Rect (size: 4, cast: variable(ref))
.value: onLayout
.usages:
	cmplGfx/lib/micro.ui.ci:962: referenced as `onLayout`
	cmplGfx/lib/micro.ui.core.ci:1220: referenced as `onLayout`
	cmplGfx/lib/micro.ui.core.ci:1023: referenced as `onLayout`
	cmplGfx/lib/micro.ui.core.ci:967: referenced as `onLayout`
	cmplGfx/lib/micro.ui.core.ci:882: referenced as `onLayout`
	internal usages: 6
}
Layout.onDraw(this: Layout, offs: Image, parent: Rect): void: function {
.kind: static function
.base: `function`
.size: 180
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.core.ci:1029'
.owner: Layout
.param .result: void (size: 0, cast: variable(void))
.param this: Layout (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param parent: Rect (size: 16, cast: variable(val))
.doc: 'Callback function executed when the view needs to be drawn'
.value: {
	for (i: int32 := 0; i < this.itemCount; i := i + 1) {
		const item: Item := this.items[i];
		const rect: Rect := item.rect;
		if (empty(rect)) {
			continue;
		}
		const view: View := item.view;
		state: int32 := 0;
		if (as(view, Layout) == null) {
			if (i == this.hoveredIndex) {
				state := state | Style.hovered;
			}
			if (i == this.pressedIndex) {
				state := state | Style.pressed;
			}
			if (i == this.focusedIndex) {
				state := state | Style.focused;
			}
		}
		onDraw(view, offs, rect, state);
	}
}
.instructions: (180 bytes)
	cmplGfx/lib/micro.ui.core.ci:1030: (179 bytes): for (i: int32 := 0; i < this.itemCount; i := i + 1)
	<onDraw>  : load.z32
	<onDraw+?>: jmp +160
	cmplGfx/lib/micro.ui.core.ci:1031: (13 bytes): const item: Item := this.items[i]
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: mad.u32 24
	cmplGfx/lib/micro.ui.core.ci:1032: (2 bytes): const rect: Rect := item.rect
	<onDraw+?>: dup.x32 sp(0)
	cmplGfx/lib/micro.ui.core.ci:1033: (25 bytes): if (empty(rect))
	<onDraw+?>: load.z32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: jz +12
	cmplGfx/lib/micro.ui.core.ci:1034: (8 bytes): continue;
	<onDraw+?>: inc.sp(-8)
	<onDraw+?>: jmp +116
	cmplGfx/lib/micro.ui.core.ci:1037: (7 bytes): const view: View := item.view
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: inc.i32(+16)
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:1038: (1 byte): state: int32 := 0
	<onDraw+?>: load.z32
	cmplGfx/lib/micro.ui.core.ci:1039: (81 bytes): if (as(view, Layout) == null)
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: load.ref <?> ;Layout
	<onDraw+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<onDraw+?>: load.ref <?> ;null
	<onDraw+?>: ceq.i32
	<onDraw+?>: jz +64
	cmplGfx/lib/micro.ui.core.ci:1040: (20 bytes): if (i == this.hoveredIndex)
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x32 sp(13)
	<onDraw+?>: inc.i32(+80)
	<onDraw+?>: load.i32
	<onDraw+?>: ceq.i32
	<onDraw+?>: jz +10
	cmplGfx/lib/micro.ui.core.ci:1041: (6 bytes): state := state | Style.hovered;
	<onDraw+?>: load.c32 1
	<onDraw+?>: or.b32
	cmplGfx/lib/micro.ui.core.ci:1043: (20 bytes): if (i == this.pressedIndex)
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x32 sp(13)
	<onDraw+?>: inc.i32(+84)
	<onDraw+?>: load.i32
	<onDraw+?>: ceq.i32
	<onDraw+?>: jz +10
	cmplGfx/lib/micro.ui.core.ci:1044: (6 bytes): state := state | Style.pressed;
	<onDraw+?>: load.c32 2
	<onDraw+?>: or.b32
	cmplGfx/lib/micro.ui.core.ci:1046: (20 bytes): if (i == this.focusedIndex)
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x32 sp(13)
	<onDraw+?>: inc.i32(+88)
	<onDraw+?>: load.i32
	<onDraw+?>: ceq.i32
	<onDraw+?>: jz +10
	cmplGfx/lib/micro.ui.core.ci:1047: (6 bytes): state := state | Style.focused;
	<onDraw+?>: load.c32 4
	<onDraw+?>: or.b32
	cmplGfx/lib/micro.ui.core.ci:1050: (19 bytes): onDraw(view, offs, rect, state);
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: dup.x64 sp(11)
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: load.i128
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: load.ref <?> ;View.onDraw(this: View, offs: Image, rect: Rect, state: int32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-32)
	<onDraw+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.core.ci:1030: (4 bytes): i := i + 1
	<onDraw+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.core.ci:1030: (14 bytes): i < this.itemCount
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+72)
	<onDraw+?>: load.i32
	<onDraw+?>: clt.i32
	<onDraw+?>: jnz -166
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:660: referenced as `onDraw`
	cmplGfx/lib/micro.ui.ci:654: referenced as `onDraw`
	cmplGfx/lib/micro.ui.core.ci:1226: referenced as `onDraw`
}
Layout.Custom(rowsCols: int32, alignment: int32, items: View[]): Layout: function {
.kind: static function
.base: `function`
.size: 364
.name: 'Custom'
.file: 'cmplGfx/lib/micro.ui.core.ci:1055'
.owner: Layout
.param .result: Layout (size: 4, cast: variable(ref))
.param rowsCols: int32 (size: 4, cast: variable(i32))
.param alignment: int32 (size: 4, cast: variable(i32))
.param items: View[] (size: 8, cast: variable(arr))
.doc: 'Create a custom Layout containing the given `items` all of them aligned as `alignment`'
.value: {
	layout: Layout := {
		layout := create(Layout);
		layout.orientation := rowsCols;
		layout.onLayout := onLayout;
		layout.paddingBottom := 0;
		layout.paddingRight := 0;
		layout.paddingLeft := 0;
		layout.paddingTop := 0;
		layout.focusedIndex := -1;
		layout.pressedIndex := -1;
		layout.hoveredIndex := -1;
		layout.itemCapacity := 0;
		layout.itemCount := 0;
		layout.items := (null);
		layout.separator := (null);
		layout.width := -5;
		layout.height := -5;
		layout.enabled := true;
		layout.focusable := true;
		layout.parent := (null);
		layout.style := (null);
		layout.data := (null);
		layout.onClick := onClick;
		layout.onReset := onReset;
		layout.onCreate := onCreate;
		layout.onDestroy := onDestroy;
		layout.onKeyEvent := onKeyEvent;
		layout.onTouchEvent := onTouchEvent;
		layout.onMeasure := onMeasure;
		layout.onDraw := onDraw;
	};
	if (items.length > (0)) {
		addItems(layout, alignment, ...items);
	}
	return .result := layout;
}
.instructions: (364 bytes)
	cmplGfx/lib/micro.ui.core.ci:1056: (329 bytes): layout: Layout := {...}
	<Custom>  : inc.sp(+4)
	cmplGfx/lib/micro.ui.core.ci:1056: (11 bytes): layout := create(Layout);
	<Custom+?>: load.ref <?> ;Layout
	<Custom+?>: nfc(7) ;object.create(type: typename): pointer
	<Custom+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:1057: (9 bytes): layout.orientation := rowsCols;
	<Custom+?>: dup.x32 sp(5)
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+108)
	<Custom+?>: store.i32
	:: (12 bytes): layout.onLayout := onLayout;
	<Custom+?>: load.ref <?> ;Layout.onLayout(this: Layout, measured: Rect): void
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+112)
	<Custom+?>: store.i32
	:: (8 bytes): layout.paddingBottom := 0;
	<Custom+?>: load.z32
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+104)
	<Custom+?>: store.i32
	:: (8 bytes): layout.paddingRight := 0;
	<Custom+?>: load.z32
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+100)
	<Custom+?>: store.i32
	:: (8 bytes): layout.paddingLeft := 0;
	<Custom+?>: load.z32
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+96)
	<Custom+?>: store.i32
	:: (8 bytes): layout.paddingTop := 0;
	<Custom+?>: load.z32
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+92)
	<Custom+?>: store.i32
	:: (12 bytes): layout.focusedIndex := -1;
	<Custom+?>: load.c32 -1
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+88)
	<Custom+?>: store.i32
	:: (12 bytes): layout.pressedIndex := -1;
	<Custom+?>: load.c32 -1
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+84)
	<Custom+?>: store.i32
	:: (12 bytes): layout.hoveredIndex := -1;
	<Custom+?>: load.c32 -1
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+80)
	<Custom+?>: store.i32
	:: (8 bytes): layout.itemCapacity := 0;
	<Custom+?>: load.z32
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+76)
	<Custom+?>: store.i32
	:: (8 bytes): layout.itemCount := 0;
	<Custom+?>: load.z32
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+72)
	<Custom+?>: store.i32
	:: (12 bytes): layout.items := (null);
	<Custom+?>: load.ref <?> ;null
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+68)
	<Custom+?>: store.i32
	:: (12 bytes): layout.separator := (null);
	<Custom+?>: load.ref <?> ;null
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+64)
	<Custom+?>: store.i32
	:: (12 bytes): layout.width := -5;
	<Custom+?>: load.c32 -5
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+4)
	<Custom+?>: store.i32
	:: (12 bytes): layout.height := -5;
	<Custom+?>: load.c32 -5
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+8)
	<Custom+?>: store.i32
	:: (12 bytes): layout.enabled := true;
	<Custom+?>: load.c32 1
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+12)
	<Custom+?>: store.i8
	:: (12 bytes): layout.focusable := true;
	<Custom+?>: load.c32 1
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+13)
	<Custom+?>: store.i8
	:: (12 bytes): layout.parent := (null);
	<Custom+?>: load.ref <?> ;null
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+16)
	<Custom+?>: store.i32
	:: (12 bytes): layout.style := (null);
	<Custom+?>: load.ref <?> ;null
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+20)
	<Custom+?>: store.i32
	:: (17 bytes): layout.data := (null);
	<Custom+?>: load.ref <?> ;pointer
	<Custom+?>: load.ref <?> ;null
	<Custom+?>: dup.x32 sp(2)
	<Custom+?>: inc.i32(+24)
	<Custom+?>: store.i64
	:: (12 bytes): layout.onClick := onClick;
	<Custom+?>: load.ref <?> ;Layout.onClick(this: Layout): bool
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+32)
	<Custom+?>: store.i32
	:: (12 bytes): layout.onReset := onReset;
	<Custom+?>: load.ref <?> ;Layout.onReset(this: Layout): bool
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+36)
	<Custom+?>: store.i32
	:: (12 bytes): layout.onCreate := onCreate;
	<Custom+?>: load.ref <?> ;Layout.onCreate(this: Layout, parent: View): void
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+40)
	<Custom+?>: store.i32
	:: (12 bytes): layout.onDestroy := onDestroy;
	<Custom+?>: load.ref <?> ;Layout.onDestroy(this: Layout): void
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+44)
	<Custom+?>: store.i32
	:: (12 bytes): layout.onKeyEvent := onKeyEvent;
	<Custom+?>: load.ref <?> ;Layout.onKeyEvent(this: Layout, event: KeyEvent): bool
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+48)
	<Custom+?>: store.i32
	:: (12 bytes): layout.onTouchEvent := onTouchEvent;
	<Custom+?>: load.ref <?> ;Layout.onTouchEvent(this: Layout, rect: Rect, event: TouchEvent): bool
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+52)
	<Custom+?>: store.i32
	:: (12 bytes): layout.onMeasure := onMeasure;
	<Custom+?>: load.ref <?> ;Layout.onMeasure(this: Layout, measured: Rect): bool
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+56)
	<Custom+?>: store.i32
	:: (12 bytes): layout.onDraw := onDraw;
	<Custom+?>: load.ref <?> ;Layout.onDraw(this: Layout, offs: Image, parent: Rect): void
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: inc.i32(+60)
	<Custom+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:1059: (32 bytes): if (items.length > (0))
	<Custom+?>: dup.x32 sp(3)
	<Custom+?>: load.z32
	<Custom+?>: cgt.u32
	<Custom+?>: jz +28
	cmplGfx/lib/micro.ui.core.ci:1060: (24 bytes): addItems(layout, alignment, ...items);
	<Custom+?>: inc.sp(+4)
	<Custom+?>: dup.x32 sp(1)
	<Custom+?>: dup.x32 sp(6)
	<Custom+?>: dup.x64 sp(5)
	<Custom+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<Custom+?>: call
	<Custom+?>: inc.sp(-16)
	<Custom+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1062: (3 bytes): return .result := layout;
	<Custom+?>: set.x32 sp(6)
	<Custom+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:1077: referenced as `Custom`
	cmplGfx/lib/micro.ui.core.ci:1072: referenced as `Custom`
	cmplGfx/lib/micro.ui.core.ci:1067: referenced as `Custom`
}
Layout.Row(items: View[]): Layout: function {
.kind: static function
.base: `function`
.size: 29
.name: 'Row'
.file: 'cmplGfx/lib/micro.ui.core.ci:1066'
.owner: Layout
.param .result: Layout (size: 4, cast: variable(ref))
.param items: View[] (size: 8, cast: variable(arr))
.doc: 'Create a Row-layout containing the given `items` arranged vertically in a single row'
.value: {
	return .result := Custom(-1, Style.fill, ...items);
}
.instructions: (29 bytes)
	cmplGfx/lib/micro.ui.core.ci:1067: (29 bytes): return .result := Custom(-1, Style.fill, ...items);
	<Row>  : inc.sp(+4)
	<Row+?>: load.c32 -1
	<Row+?>: load.c32 15
	<Row+?>: dup.x64 sp(4)
	<Row+?>: load.ref <?> ;Layout.Custom(rowsCols: int32, alignment: int32, items: View[]): Layout
	<Row+?>: call
	<Row+?>: inc.sp(-16)
	<Row+?>: set.x32 sp(4)
	<Row+?>: ret
.usages:
}
Layout.Column(items: View[]): Layout: function {
.kind: static function
.base: `function`
.size: 29
.name: 'Column'
.file: 'cmplGfx/lib/micro.ui.core.ci:1071'
.owner: Layout
.param .result: Layout (size: 4, cast: variable(ref))
.param items: View[] (size: 8, cast: variable(arr))
.doc: 'Create a Column-layout containing the given `items` arranged horizontally in a single column'
.value: {
	return .result := Custom(1, Style.fill, ...items);
}
.instructions: (29 bytes)
	cmplGfx/lib/micro.ui.core.ci:1072: (29 bytes): return .result := Custom(1, Style.fill, ...items);
	<Column>  : inc.sp(+4)
	<Column+?>: load.c32 1
	<Column+?>: load.c32 15
	<Column+?>: dup.x64 sp(4)
	<Column+?>: load.ref <?> ;Layout.Custom(rowsCols: int32, alignment: int32, items: View[]): Layout
	<Column+?>: call
	<Column+?>: inc.sp(-16)
	<Column+?>: set.x32 sp(4)
	<Column+?>: ret
.usages:
}
Layout.Stack(items: View[]): Layout: function {
.kind: static function
.base: `function`
.size: 25
.name: 'Stack'
.file: 'cmplGfx/lib/micro.ui.core.ci:1076'
.owner: Layout
.param .result: Layout (size: 4, cast: variable(ref))
.param items: View[] (size: 8, cast: variable(arr))
.doc: 'Create a Stack-layout containing the given `items` stacked on top of each other'
.value: {
	return .result := Custom(0, Style.fill, ...items);
}
.instructions: (25 bytes)
	cmplGfx/lib/micro.ui.core.ci:1077: (25 bytes): return .result := Custom(0, Style.fill, ...items);
	<Stack>  : inc.sp(+4)
	<Stack+?>: load.z32
	<Stack+?>: load.c32 15
	<Stack+?>: dup.x64 sp(4)
	<Stack+?>: load.ref <?> ;Layout.Custom(rowsCols: int32, alignment: int32, items: View[]): Layout
	<Stack+?>: call
	<Stack+?>: inc.sp(-16)
	<Stack+?>: set.x32 sp(4)
	<Stack+?>: ret
.usages:
}
Widget: Layout {
.kind: static const typename(ref)
.base: `Layout`
.size: 132
.name: 'Widget'
.file: 'cmplGfx/lib/micro.ui.core.ci:1084'
.field measure: bool (size: 1, cast: variable(bool))
.field redraw: bool (size: 1, cast: variable(bool))
.field focus: View (size: 4, cast: variable(ref))
.field scrollX: int32 (size: 4, cast: variable(i32))
.field scrollY: int32 (size: 4, cast: variable(i32))
.field focusNext: function (size: 505, cast: static function)
.field addItems: function (size: 28, cast: static function)
.field addItems: function (size: 31, cast: static function)
.field focus: function (size: 13, cast: static function)
.field padding: function (size: 32, cast: static function)
.field padding: function (size: 32, cast: static function)
.field padding: function (size: 32, cast: static function)
.field onCreate: function (size: 72, cast: static function)
.field onKeyEvent: function (size: 184, cast: static function)
.field onMeasure: function (size: 46, cast: static function)
.field onDraw: function (size: 45, cast: static function)
.field Item: typename (size: 24, cast: static const typename(val))
.field separator: View (size: 4, cast: variable(ref))
.field items: Layout.Item[*] (size: 4, cast: variable(ref))
.field itemCount: int32 (size: 4, cast: variable(i32))
.field itemCapacity: int32 (size: 4, cast: variable(i32))
.field hoveredIndex: int32 (size: 4, cast: variable(i32))
.field pressedIndex: int32 (size: 4, cast: variable(i32))
.field focusedIndex: int32 (size: 4, cast: variable(i32))
.field paddingTop: int32 (size: 4, cast: variable(i32))
.field paddingLeft: int32 (size: 4, cast: variable(i32))
.field paddingRight: int32 (size: 4, cast: variable(i32))
.field paddingBottom: int32 (size: 4, cast: variable(i32))
.field orientation: int32 (size: 4, cast: variable(i32))
.field clearState: function (size: 396, cast: static function)
.field getPressed: function (size: 114, cast: static function)
.field getFocused: function (size: 114, cast: static function)
.field setFocused: function (size: 283, cast: static function)
.field capacity: function (size: 175, cast: static function)
.field addItems: function (size: 204, cast: static function)
.field size: function (size: 10, cast: static function)
.field getView: function (size: 94, cast: static function)
.field setAlignment: function (size: 94, cast: static function)
.field padding: function (size: 56, cast: static function)
.field onClick: function (size: 58, cast: static function)
.field onReset: function (size: 94, cast: static function)
.field onCreate: function (size: 141, cast: static function)
.field onDestroy: function (size: 86, cast: static function)
.field onKeyEvent: function (size: 89, cast: static function)
.field onTouchEvent: function (size: 799, cast: static function)
.field onMeasure: function (size: 448, cast: static function)
.field onLayout: function (size: 411, cast: static function)
.field onLayout: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 180, cast: static function)
.field Custom: function (size: 364, cast: static function)
.field Row: function (size: 29, cast: static function)
.field Column: function (size: 29, cast: static function)
.field Stack: function (size: 25, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Widget is a special kind of layout, which can clip the content of its elements.
a widget may clip its children and apply scrolling to them, even show a scrollbar.'
.usages:
	cmplGfx/lib/micro.ui.ci:1347: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:1299: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:1268: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:1101: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:1081: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:1078: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:993: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:984: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:983: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:974: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:946: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:939: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:885: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:871: referenced as `Widget`
	cmplGfx/lib/micro.ui.ci:859: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1306: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1301: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1296: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1284: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1255: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1233: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1233: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1231: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1224: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1218: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1195: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1185: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1180: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1180: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1174: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1162: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1162: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1156: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1156: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1150: referenced as `Widget`
	cmplGfx/lib/micro.ui.core.ci:1150: referenced as `Widget`
}
Widget.measure: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'measure'
.file: 'cmplGfx/lib/micro.ui.core.ci:1085'
.owner: Widget
.value: true
.usages:
	cmplGfx/lib/micro.ui.ci:1286: referenced as `measure`
	cmplGfx/lib/micro.ui.ci:1283: referenced as `measure`
	cmplGfx/lib/micro.ui.core.ci:1307: referenced as `measure`
	cmplGfx/lib/micro.ui.core.ci:1286: referenced as `measure`
	cmplGfx/lib/micro.ui.core.ci:1279: referenced as `measure`
	cmplGfx/lib/micro.ui.core.ci:1187: referenced as `measure`
	internal usages: 2
}
Widget.redraw: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'redraw'
.file: 'cmplGfx/lib/micro.ui.core.ci:1086'
.owner: Widget
.value: true
.usages:
	cmplGfx/lib/micro.ui.ci:1319: referenced as `redraw`
	cmplGfx/lib/micro.ui.ci:1290: referenced as `redraw`
	cmplGfx/lib/micro.ui.core.ci:1288: referenced as `redraw`
	internal usages: 2
}
Widget.focus: View {
.kind: variable(ref)
.base: `View`
.size: 4
.name: 'focus'
.file: 'cmplGfx/lib/micro.ui.core.ci:1087'
.owner: Widget
.value: null
.usages:
	cmplGfx/lib/micro.ui.core.ci:1191: referenced as `focus`
	cmplGfx/lib/micro.ui.core.ci:1190: referenced as `focus`
	cmplGfx/lib/micro.ui.core.ci:1189: referenced as `focus`
	cmplGfx/lib/micro.ui.core.ci:1163: referenced as `focus`
	internal usages: 2
}
Widget.scrollX: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'scrollX'
.file: 'cmplGfx/lib/micro.ui.core.ci:1089'
.owner: Widget
.value: 0
.usages:
	internal usages: 2
}
Widget.scrollY: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'scrollY'
.file: 'cmplGfx/lib/micro.ui.core.ci:1090'
.owner: Widget
.value: 0
.usages:
	internal usages: 2
}
Widget.focusNext(view: View, prev: bool): bool: function {
.kind: static function
.base: `function`
.size: 505
.name: 'focusNext'
.file: 'cmplGfx/lib/micro.ui.core.ci:1092'
.owner: Widget
.param .result: bool (size: 4, cast: variable(bool))
.param view: View (size: 4, cast: variable(ref))
.param prev: bool (size: 4, cast: variable(bool))
.value: {
	if ((view) == null) {
		return .result := false;
	}
	if (!view.enabled) {
		return .result := false;
	}
	if (!view.focusable) {
		return .result := false;
	}
	this: Layout := as(view, Layout);
	if ((this) == null) {
		return .result := true;
	}
	n: int32 := this.focusedIndex;
	if (prev) {
		if (n < 0) {
			n := this.itemCount - 1;
		}
		for (i: int32 := n; i >= 0; i := i - 1) {
			const item: Item := this.items[i];
			const rect: Rect := item.rect;
			const view: View := item.view;
			if (!empty(rect) && focusNext(view, prev)) {
				if (as(view, Layout) != null || i != this.focusedIndex) {
					this.focusedIndex := i;
					return .result := true;
				}
			}
		}
	}
	else {
		if (n < 0) {
			n := 0;
		}
		for (i: int32 := n; i < this.itemCount; i := i + 1) {
			const item: Item := this.items[i];
			const rect: Rect := item.rect;
			const view: View := item.view;
			if (!empty(rect) && focusNext(view, prev)) {
				if (as(view, Layout) != null || i > this.focusedIndex) {
					this.focusedIndex := i;
					return .result := true;
				}
			}
		}
	}
	clearState(this, Style.focused);
	return .result := false;
}
.instructions: (505 bytes)
	cmplGfx/lib/micro.ui.core.ci:1093: (19 bytes): if ((view) == null)
	<focusNext>  : dup.x32 sp(2)
	<focusNext+?>: load.ref <?> ;null
	<focusNext+?>: ceq.i32
	<focusNext+?>: jz +11
	cmplGfx/lib/micro.ui.core.ci:1095: (7 bytes): return .result := false;
	<focusNext+?>: load.z32
	<focusNext+?>: load.sp(+16)
	<focusNext+?>: store.i8
	<focusNext+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1097: (18 bytes): if (!view.enabled)
	<focusNext+?>: dup.x32 sp(2)
	<focusNext+?>: inc.i32(+12)
	<focusNext+?>: load.is8
	<focusNext+?>: jnz +11
	cmplGfx/lib/micro.ui.core.ci:1099: (7 bytes): return .result := false;
	<focusNext+?>: load.z32
	<focusNext+?>: load.sp(+16)
	<focusNext+?>: store.i8
	<focusNext+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1101: (18 bytes): if (!view.focusable)
	<focusNext+?>: dup.x32 sp(2)
	<focusNext+?>: inc.i32(+13)
	<focusNext+?>: load.is8
	<focusNext+?>: jnz +11
	cmplGfx/lib/micro.ui.core.ci:1103: (7 bytes): return .result := false;
	<focusNext+?>: load.z32
	<focusNext+?>: load.sp(+16)
	<focusNext+?>: store.i8
	<focusNext+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1106: (11 bytes): this: Layout := as(view, Layout)
	<focusNext+?>: dup.x32 sp(2)
	<focusNext+?>: load.ref <?> ;Layout
	<focusNext+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	cmplGfx/lib/micro.ui.core.ci:1107: (27 bytes): if ((this) == null)
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: load.ref <?> ;null
	<focusNext+?>: ceq.i32
	<focusNext+?>: jz +19
	cmplGfx/lib/micro.ui.core.ci:1109: (15 bytes): return .result := true;
	<focusNext+?>: load.c32 1
	<focusNext+?>: load.sp(+20)
	<focusNext+?>: store.i8
	<focusNext+?>: inc.sp(-4)
	<focusNext+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1112: (7 bytes): n: int32 := this.focusedIndex
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: inc.i32(+88)
	<focusNext+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:1113: (372 bytes): if (prev)
	<focusNext+?>: load.sp(+12)
	<focusNext+?>: load.is8
	<focusNext+?>: jz +190
	cmplGfx/lib/micro.ui.core.ci:1114: (21 bytes): if (n < 0)
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: load.z32
	<focusNext+?>: clt.i32
	<focusNext+?>: jz +17
	cmplGfx/lib/micro.ui.core.ci:1115: (13 bytes): n := this.itemCount - 1;
	<focusNext+?>: dup.x32 sp(1)
	<focusNext+?>: inc.i32(+72)
	<focusNext+?>: load.i32
	<focusNext+?>: inc.i32(-1)
	<focusNext+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:1117: (161 bytes): for (i: int32 := n; i >= 0; i := i - 1)
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: jmp +147
	cmplGfx/lib/micro.ui.core.ci:1118: (13 bytes): const item: Item := this.items[i]
	<focusNext+?>: dup.x32 sp(2)
	<focusNext+?>: inc.i32(+68)
	<focusNext+?>: load.i32
	<focusNext+?>: dup.x32 sp(1)
	<focusNext+?>: mad.u32 24
	cmplGfx/lib/micro.ui.core.ci:1119: (2 bytes): const rect: Rect := item.rect
	<focusNext+?>: dup.x32 sp(0)
	cmplGfx/lib/micro.ui.core.ci:1120: (7 bytes): const view: View := item.view
	<focusNext+?>: dup.x32 sp(1)
	<focusNext+?>: inc.i32(+16)
	<focusNext+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:1121: (113 bytes): if (!empty(rect) && focusNext(view, prev))
	<focusNext+?>: load.z32
	<focusNext+?>: dup.x32 sp(2)
	<focusNext+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<focusNext+?>: call
	<focusNext+?>: inc.sp(-4)
	<focusNext+?>: not.b32
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: jz +26
	<focusNext+?>: inc.sp(-4)
	<focusNext+?>: load.z32
	<focusNext+?>: dup.x32 sp(1)
	<focusNext+?>: load.sp(+36)
	<focusNext+?>: load.is8
	<focusNext+?>: load.ref <?> ;Widget.focusNext(view: View, prev: bool): bool
	<focusNext+?>: call
	<focusNext+?>: inc.sp(-8)
	<focusNext+?>: jz +71
	cmplGfx/lib/micro.ui.core.ci:1122: (67 bytes): if (as(view, Layout) != null || i != this.focusedIndex)
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: load.ref <?> ;Layout
	<focusNext+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<focusNext+?>: load.ref <?> ;null
	<focusNext+?>: ceq.i32
	<focusNext+?>: not.b32
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: jnz +19
	<focusNext+?>: inc.sp(-4)
	<focusNext+?>: dup.x32 sp(3)
	<focusNext+?>: dup.x32 sp(6)
	<focusNext+?>: inc.i32(+88)
	<focusNext+?>: load.i32
	<focusNext+?>: ceq.i32
	<focusNext+?>: not.b32
	<focusNext+?>: jz +28
	cmplGfx/lib/micro.ui.core.ci:1123: (9 bytes): this.focusedIndex := i;
	<focusNext+?>: dup.x32 sp(3)
	<focusNext+?>: dup.x32 sp(6)
	<focusNext+?>: inc.i32(+88)
	<focusNext+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:1124: (15 bytes): return .result := true;
	<focusNext+?>: load.c32 1
	<focusNext+?>: load.sp(+40)
	<focusNext+?>: store.i8
	<focusNext+?>: inc.sp(-24)
	<focusNext+?>: ret
	<focusNext+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:1117: (4 bytes): i := i - 1
	<focusNext+?>: inc.i32(-1)
	cmplGfx/lib/micro.ui.core.ci:1117: (8 bytes): i >= 0
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: load.z32
	<focusNext+?>: clt.i32
	<focusNext+?>: jz -147
	<focusNext+?>: inc.sp(-4)
	<focusNext+?>: jmp +181
	cmplGfx/lib/micro.ui.core.ci:1129: (11 bytes): if (n < 0)
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: load.z32
	<focusNext+?>: clt.i32
	<focusNext+?>: jz +7
	cmplGfx/lib/micro.ui.core.ci:1130: (3 bytes): n := 0;
	<focusNext+?>: load.z32
	<focusNext+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.core.ci:1132: (166 bytes): for (i: int32 := n; i < this.itemCount; i := i + 1)
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: jmp +146
	cmplGfx/lib/micro.ui.core.ci:1133: (13 bytes): const item: Item := this.items[i]
	<focusNext+?>: dup.x32 sp(2)
	<focusNext+?>: inc.i32(+68)
	<focusNext+?>: load.i32
	<focusNext+?>: dup.x32 sp(1)
	<focusNext+?>: mad.u32 24
	cmplGfx/lib/micro.ui.core.ci:1134: (2 bytes): const rect: Rect := item.rect
	<focusNext+?>: dup.x32 sp(0)
	cmplGfx/lib/micro.ui.core.ci:1135: (7 bytes): const view: View := item.view
	<focusNext+?>: dup.x32 sp(1)
	<focusNext+?>: inc.i32(+16)
	<focusNext+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:1136: (112 bytes): if (!empty(rect) && focusNext(view, prev))
	<focusNext+?>: load.z32
	<focusNext+?>: dup.x32 sp(2)
	<focusNext+?>: load.ref <?> ;empty(rectangle: Rect): bool
	<focusNext+?>: call
	<focusNext+?>: inc.sp(-4)
	<focusNext+?>: not.b32
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: jz +26
	<focusNext+?>: inc.sp(-4)
	<focusNext+?>: load.z32
	<focusNext+?>: dup.x32 sp(1)
	<focusNext+?>: load.sp(+36)
	<focusNext+?>: load.is8
	<focusNext+?>: load.ref <?> ;Widget.focusNext(view: View, prev: bool): bool
	<focusNext+?>: call
	<focusNext+?>: inc.sp(-8)
	<focusNext+?>: jz +70
	cmplGfx/lib/micro.ui.core.ci:1137: (66 bytes): if (as(view, Layout) != null || i > this.focusedIndex)
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: load.ref <?> ;Layout
	<focusNext+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<focusNext+?>: load.ref <?> ;null
	<focusNext+?>: ceq.i32
	<focusNext+?>: not.b32
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: jnz +18
	<focusNext+?>: inc.sp(-4)
	<focusNext+?>: dup.x32 sp(3)
	<focusNext+?>: dup.x32 sp(6)
	<focusNext+?>: inc.i32(+88)
	<focusNext+?>: load.i32
	<focusNext+?>: cgt.i32
	<focusNext+?>: jz +28
	cmplGfx/lib/micro.ui.core.ci:1138: (9 bytes): this.focusedIndex := i;
	<focusNext+?>: dup.x32 sp(3)
	<focusNext+?>: dup.x32 sp(6)
	<focusNext+?>: inc.i32(+88)
	<focusNext+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:1139: (15 bytes): return .result := true;
	<focusNext+?>: load.c32 1
	<focusNext+?>: load.sp(+40)
	<focusNext+?>: store.i8
	<focusNext+?>: inc.sp(-24)
	<focusNext+?>: ret
	<focusNext+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.core.ci:1132: (4 bytes): i := i + 1
	<focusNext+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.core.ci:1132: (14 bytes): i < this.itemCount
	<focusNext+?>: dup.x32 sp(0)
	<focusNext+?>: dup.x32 sp(3)
	<focusNext+?>: inc.i32(+72)
	<focusNext+?>: load.i32
	<focusNext+?>: clt.i32
	<focusNext+?>: jnz -152
	<focusNext+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1145: (22 bytes): clearState(this, Style.focused);
	<focusNext+?>: load.z32
	<focusNext+?>: dup.x32 sp(2)
	<focusNext+?>: load.c32 4
	<focusNext+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<focusNext+?>: call
	<focusNext+?>: inc.sp(-8)
	<focusNext+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1146: (11 bytes): return .result := false;
	<focusNext+?>: load.z32
	<focusNext+?>: load.sp(+24)
	<focusNext+?>: store.i8
	<focusNext+?>: inc.sp(-8)
	<focusNext+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:1278: referenced as `focusNext`
	cmplGfx/lib/micro.ui.core.ci:1208: referenced as `focusNext`
	cmplGfx/lib/micro.ui.core.ci:1207: referenced as `focusNext`
	cmplGfx/lib/micro.ui.core.ci:1136: referenced as `focusNext`
	cmplGfx/lib/micro.ui.core.ci:1121: referenced as `focusNext`
}
Widget.addItems(this: Widget, align: int32, views: View[]): Widget: function {
.kind: static function
.base: `function`
.size: 28
.name: 'addItems'
.file: 'cmplGfx/lib/micro.ui.core.ci:1150'
.owner: Widget
.param .result: Widget (size: 4, cast: variable(ref))
.param this: Widget (size: 4, cast: variable(ref))
.param align: int32 (size: 4, cast: variable(i32))
.param views: View[] (size: 8, cast: variable(arr))
.doc: 'Append the given `views` to `this` widget with the given `alignment`'
.value: {
	Layout.addItems(this, align, ...views);
	return .result := this;
}
.instructions: (28 bytes)
	cmplGfx/lib/micro.ui.core.ci:1151: (24 bytes): Layout.addItems(this, align, ...views);
	<addItems>  : inc.sp(+4)
	<addItems+?>: dup.x32 sp(5)
	<addItems+?>: dup.x32 sp(5)
	<addItems+?>: dup.x64 sp(4)
	<addItems+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<addItems+?>: call
	<addItems+?>: inc.sp(-16)
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1152: (4 bytes): return .result := this;
	<addItems+?>: mov.x32 sp(5, 4)
	<addItems+?>: ret
.usages:
}
Widget.addItems(this: Widget, views: View[]): Widget: function {
.kind: static function
.base: `function`
.size: 31
.name: 'addItems'
.file: 'cmplGfx/lib/micro.ui.core.ci:1156'
.owner: Widget
.param .result: Widget (size: 4, cast: variable(ref))
.param this: Widget (size: 4, cast: variable(ref))
.param views: View[] (size: 8, cast: variable(arr))
.doc: 'Append the given `views` to `this` widget'
.value: {
	Layout.addItems(this, Style.fill, ...views);
	return .result := this;
}
.instructions: (31 bytes)
	cmplGfx/lib/micro.ui.core.ci:1157: (27 bytes): Layout.addItems(this, Style.fill, ...views);
	<addItems>  : inc.sp(+4)
	<addItems+?>: dup.x32 sp(4)
	<addItems+?>: load.c32 15
	<addItems+?>: dup.x64 sp(4)
	<addItems+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<addItems+?>: call
	<addItems+?>: inc.sp(-16)
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1158: (4 bytes): return .result := this;
	<addItems+?>: mov.x32 sp(4, 3)
	<addItems+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:1020: referenced as `addItems`
}
Widget.focus(this: Widget, value: View): Widget: function {
.kind: static function
.base: `function`
.size: 13
.name: 'focus'
.file: 'cmplGfx/lib/micro.ui.core.ci:1162'
.owner: Widget
.param .result: Widget (size: 4, cast: variable(ref))
.param this: Widget (size: 4, cast: variable(ref))
.param value: View (size: 4, cast: variable(ref))
.doc: 'Set the initial focused wie in the widget'
.value: {
	this.focus := value;
	return .result := this;
}
.instructions: (13 bytes)
	cmplGfx/lib/micro.ui.core.ci:1163: (9 bytes): this.focus := value;
	<focus>  : dup.x32 sp(1)
	<focus+?>: dup.x32 sp(3)
	<focus+?>: inc.i32(+120)
	<focus+?>: store.i32
	cmplGfx/lib/micro.ui.core.ci:1164: (4 bytes): return .result := this;
	<focus+?>: mov.x32 sp(3, 2)
	<focus+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:1019: referenced as `focus`
	cmplGfx/lib/micro.ui.ci:990: referenced as `focus`
}
Widget.padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout: function {
.kind: static function
.base: `function`
.size: 32
.name: 'padding'
.file: 'cmplGfx/lib/micro.ui.core.ci:1168'
.owner: Widget
.param .result: Layout (size: 4, cast: variable(ref))
.param this: Layout (size: 4, cast: variable(ref))
.param top: int32 (size: 4, cast: variable(i32))
.param left: int32 (size: 4, cast: variable(i32))
.param right: int32 (size: 4, cast: variable(i32))
.param bottom: int32 (size: 4, cast: variable(i32))
.doc: 'Set the padding of `this` widget to the given values'
.value: {
	Layout.padding(this, top, left, right, bottom);
	return .result := this;
}
.instructions: (32 bytes)
	cmplGfx/lib/micro.ui.core.ci:1169: (28 bytes): Layout.padding(this, top, left, right, bottom);
	<padding>  : inc.sp(+4)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: load.ref <?> ;Layout.padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout
	<padding+?>: call
	<padding+?>: inc.sp(-20)
	<padding+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1170: (4 bytes): return .result := this;
	<padding+?>: mov.x32 sp(6, 5)
	<padding+?>: ret
.usages:
}
Widget.padding(this: Widget, vertical: int32, horizontal: int32): Layout: function {
.kind: static function
.base: `function`
.size: 32
.name: 'padding'
.file: 'cmplGfx/lib/micro.ui.core.ci:1174'
.owner: Widget
.param .result: Layout (size: 4, cast: variable(ref))
.param this: Widget (size: 4, cast: variable(ref))
.param vertical: int32 (size: 4, cast: variable(i32))
.param horizontal: int32 (size: 4, cast: variable(i32))
.doc: 'Set the padding of `this` widget to the given values'
.value: {
	Layout.padding(this, vertical, horizontal, horizontal, vertical);
	return .result := this;
}
.instructions: (32 bytes)
	cmplGfx/lib/micro.ui.core.ci:1175: (28 bytes): Layout.padding(this, vertical, horizontal, horizontal, vertical);
	<padding>  : inc.sp(+4)
	<padding+?>: dup.x32 sp(4)
	<padding+?>: dup.x32 sp(4)
	<padding+?>: dup.x32 sp(4)
	<padding+?>: dup.x32 sp(5)
	<padding+?>: dup.x32 sp(7)
	<padding+?>: load.ref <?> ;Layout.padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout
	<padding+?>: call
	<padding+?>: inc.sp(-20)
	<padding+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1176: (4 bytes): return .result := this;
	<padding+?>: mov.x32 sp(4, 3)
	<padding+?>: ret
.usages:
}
Widget.padding(this: Widget, padding: int32): Widget: function {
.kind: static function
.base: `function`
.size: 32
.name: 'padding'
.file: 'cmplGfx/lib/micro.ui.core.ci:1180'
.owner: Widget
.param .result: Widget (size: 4, cast: variable(ref))
.param this: Widget (size: 4, cast: variable(ref))
.param padding: int32 (size: 4, cast: variable(i32))
.doc: 'Set the padding of `this` widget to the given value'
.value: {
	Layout.padding(this, padding, padding, padding, padding);
	return .result := this;
}
.instructions: (32 bytes)
	cmplGfx/lib/micro.ui.core.ci:1181: (28 bytes): Layout.padding(this, padding, padding, padding, padding);
	<padding>  : inc.sp(+4)
	<padding+?>: dup.x32 sp(3)
	<padding+?>: dup.x32 sp(3)
	<padding+?>: dup.x32 sp(4)
	<padding+?>: dup.x32 sp(5)
	<padding+?>: dup.x32 sp(6)
	<padding+?>: load.ref <?> ;Layout.padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout
	<padding+?>: call
	<padding+?>: inc.sp(-20)
	<padding+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1182: (4 bytes): return .result := this;
	<padding+?>: mov.x32 sp(3, 2)
	<padding+?>: ret
.usages:
}
Widget.onCreate(this: Widget, parent: View): void: function {
.kind: static function
.base: `function`
.size: 72
.name: 'onCreate'
.file: 'cmplGfx/lib/micro.ui.core.ci:1185'
.owner: Widget
.param .result: void (size: 0, cast: variable(void))
.param this: Widget (size: 4, cast: variable(ref))
.param parent: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is created'
.value: {
	Layout.onCreate(this, parent);
	this.measure := true;
	if ((this.focus) != null) {
		focus(this.focus);
		this.focus := (null);
	}
}
.instructions: (72 bytes)
	cmplGfx/lib/micro.ui.core.ci:1186: (14 bytes): Layout.onCreate(this, parent);
	<onCreate>  : dup.x32 sp(2)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: load.ref <?> ;Layout.onCreate(this: Layout, parent: View): void
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:1187: (12 bytes): this.measure := true;
	<onCreate+?>: load.c32 1
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: inc.i32(+116)
	<onCreate+?>: store.i8
	cmplGfx/lib/micro.ui.core.ci:1189: (45 bytes): if ((this.focus) != null)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: inc.i32(+120)
	<onCreate+?>: load.i32
	<onCreate+?>: load.ref <?> ;null
	<onCreate+?>: ceq.i32
	<onCreate+?>: jnz +32
	cmplGfx/lib/micro.ui.core.ci:1190: (16 bytes): focus(this.focus);
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: inc.i32(+120)
	<onCreate+?>: load.i32
	<onCreate+?>: load.m32 <?> ;focus(view: View): void
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1191: (12 bytes): this.focus := (null);
	<onCreate+?>: load.ref <?> ;null
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: inc.i32(+120)
	<onCreate+?>: store.i32
	<onCreate+?>: ret
.usages:
}
Widget.onKeyEvent(this: Widget, event: KeyEvent): bool: function {
.kind: static function
.base: `function`
.size: 184
.name: 'onKeyEvent'
.file: 'cmplGfx/lib/micro.ui.core.ci:1195'
.owner: Widget
.param .result: bool (size: 4, cast: variable(bool))
.param this: Widget (size: 4, cast: variable(ref))
.param event: KeyEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a KeyEvent: press or release'
.value: {
	if (Layout.onKeyEvent(this, event)) {
		return .result := true;
	}
	if (event.release) {
		return .result := false;
	}
	if ((event.key) == Window.KEY_CODE_TAB || (event.key) == Window.KEY_CODE_ENTER) {
		clearState(this, Style.hovered);
		if (!focusNext(this, event.isShift)) {
			return .result := focusNext(this, event.isShift);
		}
		return .result := true;
	}
	return .result := false;
}
.instructions: (184 bytes)
	cmplGfx/lib/micro.ui.core.ci:1196: (30 bytes): if (Layout.onKeyEvent(this, event))
	<onKeyEvent>  : load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.ref <?> ;Layout.onKeyEvent(this: Layout, event: KeyEvent): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: jz +15
	cmplGfx/lib/micro.ui.core.ci:1197: (11 bytes): return .result := true;
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1200: (14 bytes): if (event.release)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jz +11
	cmplGfx/lib/micro.ui.core.ci:1201: (7 bytes): return .result := false;
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1204: (133 bytes): if ((event.key) == Window.KEY_CODE_TAB || (event.key) == Window.KEY_CODE_ENTER)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: i32.2i64
	<onKeyEvent+?>: load.c64 65289
	<onKeyEvent+?>: ceq.i64
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jnz +26
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: i32.2i64
	<onKeyEvent+?>: load.c64 65293
	<onKeyEvent+?>: ceq.i64
	<onKeyEvent+?>: jz +87
	cmplGfx/lib/micro.ui.core.ci:1206: (22 bytes): clearState(this, Style.hovered);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1207: (50 bytes): if (!focusNext(this, event.isShift))
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: load.ref <?> ;Widget.focusNext(view: View, prev: bool): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: jnz +30
	cmplGfx/lib/micro.ui.core.ci:1208: (26 bytes): return .result := focusNext(this, event.isShift);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: load.ref <?> ;Widget.focusNext(view: View, prev: bool): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1210: (11 bytes): return .result := true;
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1213: (7 bytes): return .result := false;
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:946: referenced as `onKeyEvent`
	cmplGfx/lib/micro.ui.ci:939: referenced as `onKeyEvent`
}
Widget.onMeasure(this: Widget, measured: Rect): bool: function {
.kind: static function
.base: `function`
.size: 46
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.core.ci:1218'
.owner: Widget
.param .result: bool (size: 4, cast: variable(bool))
.param this: Widget (size: 4, cast: variable(ref))
.param measured: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	Layout.onMeasure(this, &measured);
	this.onLayout(this, &measured);
	return .result := true;
}
.instructions: (46 bytes)
	cmplGfx/lib/micro.ui.core.ci:1219: (19 bytes): Layout.onMeasure(this, &measured);
	<onMeasure>  : load.z32
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: load.ref <?> ;Layout.onMeasure(this: Layout, measured: Rect): bool
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1220: (16 bytes): this.onLayout(this, &measured);
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: inc.i32(+112)
	<onMeasure+?>: load.i32
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:1221: (11 bytes): return .result := true;
	<onMeasure+?>: load.c32 1
	<onMeasure+?>: load.sp(+16)
	<onMeasure+?>: store.i8
	<onMeasure+?>: ret
.usages:
}
Widget.onDraw(this: Widget, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 45
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.core.ci:1224'
.owner: Widget
.param .result: void (size: 0, cast: variable(void))
.param this: Widget (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.doc: 'Callback function executed when the view needs to be drawn'
.value: {
	fillRect(offs, rect, this.style.backgroundColor);
	Layout.onDraw(this, offs, rect);
}
.instructions: (45 bytes)
	cmplGfx/lib/micro.ui.core.ci:1225: (28 bytes): fillRect(offs, rect, this.style.backgroundColor);
	<onDraw>  : dup.x64 sp(5)
	<onDraw+?>: load.sp(+12)
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: inc.i32(+20)
	<onDraw+?>: load.i32
	<onDraw+?>: inc.i32(+32)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, roi: Rect, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.core.ci:1226: (16 bytes): Layout.onDraw(this, offs, rect);
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: dup.x64 sp(6)
	<onDraw+?>: dup.x128 sp(4)
	<onDraw+?>: load.ref <?> ;Layout.onDraw(this: Layout, offs: Image, parent: Rect): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-28)
	<onDraw+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:974: referenced as `onDraw`
}
getWidget(view: View): Widget: function {
.kind: static function
.base: `function`
.size: 128
.name: 'getWidget'
.file: 'cmplGfx/lib/micro.ui.core.ci:1231'
.param .result: Widget (size: 4, cast: variable(ref))
.param view: View (size: 4, cast: variable(ref))
.doc: 'Return the root widget of the given `view`'
.value: {
	for (v: View := view; (v) != null; v := v.parent) {
		if ((w) != null) {
			return .result := w;
		}
		assert(v != v.parent);
	}
	return .result := null;
}
.instructions: (128 bytes)
	cmplGfx/lib/micro.ui.core.ci:1232: (120 bytes): for (v: View := view; (v) != null; v := v.parent)
	<getWidget>  : dup.x32 sp(1)
	<getWidget+?>: jmp +102
	cmplGfx/lib/micro.ui.core.ci:1233: (35 bytes): if ((w) != null)
	<getWidget+?>: dup.x32 sp(0)
	<getWidget+?>: load.ref <?> ;Widget
	<getWidget+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<getWidget+?>: dup.x32 sp(0)
	<getWidget+?>: load.ref <?> ;null
	<getWidget+?>: ceq.i32
	<getWidget+?>: jnz +12
	cmplGfx/lib/micro.ui.core.ci:1234: (8 bytes): return .result := w;
	<getWidget+?>: mov.x32 sp(4, 0)
	<getWidget+?>: inc.sp(-8)
	<getWidget+?>: ret
	<getWidget+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1237: (58 bytes): assert(v != v.parent);
	<getWidget+?>: load.z32
	<getWidget+?>: load.sp(+4)
	<getWidget+?>: dup.x32 sp(2)
	<getWidget+?>: dup.x32 sp(3)
	<getWidget+?>: inc.i32(+16)
	<getWidget+?>: load.i32
	<getWidget+?>: ceq.i32
	<getWidget+?>: jnz +8
	<getWidget+?>: jmp +35
	<getWidget+?>: load.ref <?> ;"cmplGfx/lib/micro.ui.core.ci"
	<getWidget+?>: load.c32 1237
	<getWidget+?>: load.c32 -2
	<getWidget+?>: load.c32 128
	<getWidget+?>: load.ref <?> ;"assertion failed!"
	<getWidget+?>: dup.x64 sp(5)
	<getWidget+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<getWidget+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.core.ci:1232: (5 bytes): v := v.parent
	<getWidget+?>: inc.i32(+16)
	<getWidget+?>: load.i32
	cmplGfx/lib/micro.ui.core.ci:1232: (12 bytes): (v) != null
	<getWidget+?>: dup.x32 sp(0)
	<getWidget+?>: load.ref <?> ;null
	<getWidget+?>: ceq.i32
	<getWidget+?>: jz -106
	<getWidget+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1239: (8 bytes): return .result := null;
	<getWidget+?>: load.ref <?> ;null
	<getWidget+?>: set.x32 sp(3)
	<getWidget+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:1306: referenced as `getWidget`
	cmplGfx/lib/micro.ui.core.ci:1301: referenced as `getWidget`
	cmplGfx/lib/micro.ui.core.ci:1296: referenced as `getWidget`
	cmplGfx/lib/micro.ui.core.ci:1284: referenced as `getWidget`
	cmplGfx/lib/micro.ui.core.ci:1255: referenced as `getWidget`
}
focus(view: View): void: function {
.kind: static function
.base: `function`
.size: 244
.name: 'focus'
.file: 'cmplGfx/lib/micro.ui.core.ci:1243'
.param .result: void (size: 0, cast: variable(void))
.param view: View (size: 4, cast: variable(ref))
.doc: 'Set the given `view` focused'
.value: {
	static clearFocus(layout: Layout): void := {
		for (i: int32 := 0; i < layout.itemCount; i := i + 1) {
			view: View := layout.items[i].view;
			if ((child) != null) {
				clearFocus(child);
			}
		}
		layout.hoveredIndex := -1;
		layout.pressedIndex := -1;
		layout.focusedIndex := -1;
	};
	widget: Widget := getWidget(view);
	layout: Layout := View.as(view, Layout);
	if ((layout) == null) {
		clearFocus(widget);
		Widget.setFocused(widget, view);
		return;
	}
	focus: View := Layout.getFocused(layout);
	if ((focus) != null) {
		clearFocus(widget);
		Widget.setFocused(widget, focus);
		return;
	}
	rect: Rect := {
		rect.x0 := 0;
		rect.y0 := 0;
		rect.x1 := 0;
		rect.y1 := 0;
	};
	widget.onMeasure(widget, &rect);
	clearFocus(widget);
	Widget.setFocused(widget, view);
	Widget.focusNext(widget, false);
	widget.measure := true;
}
.instructions: (244 bytes)
	cmplGfx/lib/micro.ui.core.ci:1255: (16 bytes): widget: Widget := getWidget(view)
	<focus>  : inc.sp(+4)
	<focus+?>: dup.x32 sp(2)
	<focus+?>: load.ref <?> ;getWidget(view: View): Widget
	<focus+?>: call
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1257: (11 bytes): layout: Layout := View.as(view, Layout)
	<focus+?>: dup.x32 sp(2)
	<focus+?>: load.ref <?> ;Layout
	<focus+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	cmplGfx/lib/micro.ui.core.ci:1258: (48 bytes): if ((layout) == null)
	<focus+?>: dup.x32 sp(0)
	<focus+?>: load.ref <?> ;null
	<focus+?>: ceq.i32
	<focus+?>: jz +40
	cmplGfx/lib/micro.ui.core.ci:1260: (12 bytes): clearFocus(widget);
	<focus+?>: dup.x32 sp(1)
	<focus+?>: load.ref <?> ;focus.clearFocus(layout: Layout): void
	<focus+?>: call
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1261: (19 bytes): Widget.setFocused(widget, view);
	<focus+?>: load.z32
	<focus+?>: dup.x32 sp(2)
	<focus+?>: dup.x32 sp(5)
	<focus+?>: load.ref <?> ;Layout.setFocused(this: Layout, focus: View): bool
	<focus+?>: call
	<focus+?>: inc.sp(-8)
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1262: (5 bytes): return;
	<focus+?>: inc.sp(-8)
	<focus+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1265: (16 bytes): focus: View := Layout.getFocused(layout)
	<focus+?>: inc.sp(+4)
	<focus+?>: dup.x32 sp(1)
	<focus+?>: load.ref <?> ;Layout.getFocused(this: Layout): View
	<focus+?>: call
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1266: (48 bytes): if ((focus) != null)
	<focus+?>: dup.x32 sp(0)
	<focus+?>: load.ref <?> ;null
	<focus+?>: ceq.i32
	<focus+?>: jnz +40
	cmplGfx/lib/micro.ui.core.ci:1268: (12 bytes): clearFocus(widget);
	<focus+?>: dup.x32 sp(2)
	<focus+?>: load.ref <?> ;focus.clearFocus(layout: Layout): void
	<focus+?>: call
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1269: (19 bytes): Widget.setFocused(widget, focus);
	<focus+?>: load.z32
	<focus+?>: dup.x32 sp(3)
	<focus+?>: dup.x32 sp(2)
	<focus+?>: load.ref <?> ;Layout.setFocused(this: Layout, focus: View): bool
	<focus+?>: call
	<focus+?>: inc.sp(-8)
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1270: (5 bytes): return;
	<focus+?>: inc.sp(-12)
	<focus+?>: ret
	cmplGfx/lib/micro.ui.core.ci:1273: (16 bytes): rect: Rect := {...}
	<focus+?>: inc.sp(+16)
	:: (3 bytes): rect.x0 := 0;
	<focus+?>: load.z32
	<focus+?>: set.x32 sp(1)
	:: (3 bytes): rect.y0 := 0;
	<focus+?>: load.z32
	<focus+?>: set.x32 sp(2)
	:: (3 bytes): rect.x1 := 0;
	<focus+?>: load.z32
	<focus+?>: set.x32 sp(3)
	:: (3 bytes): rect.y1 := 0;
	<focus+?>: load.z32
	<focus+?>: set.x32 sp(4)
	cmplGfx/lib/micro.ui.core.ci:1275: (23 bytes): widget.onMeasure(widget, &rect);
	<focus+?>: load.z32
	<focus+?>: dup.x32 sp(7)
	<focus+?>: load.sp(+8)
	<focus+?>: dup.x32 sp(9)
	<focus+?>: inc.i32(+56)
	<focus+?>: load.i32
	<focus+?>: call
	<focus+?>: inc.sp(-8)
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1276: (12 bytes): clearFocus(widget);
	<focus+?>: dup.x32 sp(6)
	<focus+?>: load.ref <?> ;focus.clearFocus(layout: Layout): void
	<focus+?>: call
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1277: (19 bytes): Widget.setFocused(widget, view);
	<focus+?>: load.z32
	<focus+?>: dup.x32 sp(7)
	<focus+?>: dup.x32 sp(10)
	<focus+?>: load.ref <?> ;Layout.setFocused(this: Layout, focus: View): bool
	<focus+?>: call
	<focus+?>: inc.sp(-8)
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1278: (18 bytes): Widget.focusNext(widget, false);
	<focus+?>: load.z32
	<focus+?>: dup.x32 sp(7)
	<focus+?>: load.z32
	<focus+?>: load.ref <?> ;Widget.focusNext(view: View, prev: bool): bool
	<focus+?>: call
	<focus+?>: inc.sp(-8)
	<focus+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1279: (12 bytes): widget.measure := true;
	<focus+?>: load.c32 1
	<focus+?>: dup.x32 sp(7)
	<focus+?>: inc.i32(+116)
	<focus+?>: store.i8
	<focus+?>: inc.sp(-28)
	<focus+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:768: referenced as `focus`
	cmplGfx/lib/micro.ui.ci:766: referenced as `focus`
	cmplGfx/lib/micro.ui.ci:685: referenced as `focus`
}
invalidate(view: View, layout: bool): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'invalidate'
.file: 'cmplGfx/lib/micro.ui.core.ci:1283'
.param .result: void (size: 0, cast: variable(void))
.param view: View (size: 4, cast: variable(ref))
.param layout: bool (size: 4, cast: variable(bool))
.doc: 'Invalidate the view, so the next frame it will be redrawn, and measured in case `layout` is set to true'
.value: {
	widget: Widget := getWidget(view);
	if (layout) {
		widget.measure := true;
	}
	widget.redraw := true;
}
.instructions: (54 bytes)
	cmplGfx/lib/micro.ui.core.ci:1284: (16 bytes): widget: Widget := getWidget(view)
	<invalidate>  : inc.sp(+4)
	<invalidate+?>: dup.x32 sp(3)
	<invalidate+?>: load.ref <?> ;getWidget(view: View): Widget
	<invalidate+?>: call
	<invalidate+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1285: (21 bytes): if (layout)
	<invalidate+?>: load.sp(+8)
	<invalidate+?>: load.is8
	<invalidate+?>: jz +16
	cmplGfx/lib/micro.ui.core.ci:1286: (12 bytes): widget.measure := true;
	<invalidate+?>: load.c32 1
	<invalidate+?>: dup.x32 sp(1)
	<invalidate+?>: inc.i32(+116)
	<invalidate+?>: store.i8
	cmplGfx/lib/micro.ui.core.ci:1288: (12 bytes): widget.redraw := true;
	<invalidate+?>: load.c32 1
	<invalidate+?>: dup.x32 sp(1)
	<invalidate+?>: inc.i32(+117)
	<invalidate+?>: store.i8
	<invalidate+?>: inc.sp(-4)
	<invalidate+?>: ret
.usages:
	cmplGfx/lib/micro.ui.core.ci:1292: referenced as `invalidate`
}
invalidate(view: View): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'invalidate'
.file: 'cmplGfx/lib/micro.ui.core.ci:1292'
.param .result: void (size: 0, cast: void)
.param view: View (size: 4, cast: ref)
.doc: 'Invalidate the view, so the next frame it will be measured and redrawn'
.value: invalidate(view, true)
.usages:
	cmplGfx/lib/micro.ui.ci:929: referenced as `invalidate`
	cmplGfx/lib/micro.ui.ci:922: referenced as `invalidate`
	cmplGfx/lib/micro.ui.ci:914: referenced as `invalidate`
	cmplGfx/lib/micro.ui.ci:773: referenced as `invalidate`
	cmplGfx/lib/micro.ui.ci:684: referenced as `invalidate`
	cmplGfx/lib/micro.ui.ci:610: referenced as `invalidate`
}
isFocused(view: View): bool: function {
.kind: static function
.base: `function`
.size: 45
.name: 'isFocused'
.file: 'cmplGfx/lib/micro.ui.core.ci:1295'
.param .result: bool (size: 4, cast: variable(bool))
.param view: View (size: 4, cast: variable(ref))
.doc: 'Returns weather the given `view` is in focused state or not.'
.value: {
	widget: Widget := getWidget(view);
	return .result := view == Widget.getFocused(widget);
}
.instructions: (45 bytes)
	cmplGfx/lib/micro.ui.core.ci:1296: (16 bytes): widget: Widget := getWidget(view)
	<isFocused>  : inc.sp(+4)
	<isFocused+?>: dup.x32 sp(2)
	<isFocused+?>: load.ref <?> ;getWidget(view: View): Widget
	<isFocused+?>: call
	<isFocused+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1297: (29 bytes): return .result := view == Widget.getFocused(widget);
	<isFocused+?>: dup.x32 sp(2)
	<isFocused+?>: inc.sp(+4)
	<isFocused+?>: dup.x32 sp(2)
	<isFocused+?>: load.ref <?> ;Layout.getFocused(this: Layout): View
	<isFocused+?>: call
	<isFocused+?>: inc.sp(-4)
	<isFocused+?>: ceq.i32
	<isFocused+?>: load.sp(+16)
	<isFocused+?>: store.i8
	<isFocused+?>: inc.sp(-4)
	<isFocused+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:271: referenced as `isFocused`
	cmplGfx/lib/micro.ui.ci:159: referenced as `isFocused`
	cmplGfx/lib/micro.ui.ci:71: referenced as `isFocused`
}
isPressed(view: View): bool: function {
.kind: static function
.base: `function`
.size: 45
.name: 'isPressed'
.file: 'cmplGfx/lib/micro.ui.core.ci:1300'
.param .result: bool (size: 4, cast: variable(bool))
.param view: View (size: 4, cast: variable(ref))
.doc: 'Returns weather the given `view` is in pressed state or not.'
.value: {
	widget: Widget := getWidget(view);
	return .result := view == Widget.getPressed(widget);
}
.instructions: (45 bytes)
	cmplGfx/lib/micro.ui.core.ci:1301: (16 bytes): widget: Widget := getWidget(view)
	<isPressed>  : inc.sp(+4)
	<isPressed+?>: dup.x32 sp(2)
	<isPressed+?>: load.ref <?> ;getWidget(view: View): Widget
	<isPressed+?>: call
	<isPressed+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1302: (29 bytes): return .result := view == Widget.getPressed(widget);
	<isPressed+?>: dup.x32 sp(2)
	<isPressed+?>: inc.sp(+4)
	<isPressed+?>: dup.x32 sp(2)
	<isPressed+?>: load.ref <?> ;Layout.getPressed(this: Layout): View
	<isPressed+?>: call
	<isPressed+?>: inc.sp(-4)
	<isPressed+?>: ceq.i32
	<isPressed+?>: load.sp(+16)
	<isPressed+?>: store.i8
	<isPressed+?>: inc.sp(-4)
	<isPressed+?>: ret
.usages:
}
isDirty(view: View): bool: function {
.kind: static function
.base: `function`
.size: 33
.name: 'isDirty'
.file: 'cmplGfx/lib/micro.ui.core.ci:1305'
.param .result: bool (size: 4, cast: variable(bool))
.param view: View (size: 4, cast: variable(ref))
.doc: 'Returns weather the given `view` needs to be measured or not.'
.value: {
	widget: Widget := getWidget(view);
	return .result := widget.measure;
}
.instructions: (33 bytes)
	cmplGfx/lib/micro.ui.core.ci:1306: (16 bytes): widget: Widget := getWidget(view)
	<isDirty>  : inc.sp(+4)
	<isDirty+?>: dup.x32 sp(2)
	<isDirty+?>: load.ref <?> ;getWidget(view: View): Widget
	<isDirty+?>: call
	<isDirty+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.core.ci:1307: (17 bytes): return .result := widget.measure;
	<isDirty+?>: dup.x32 sp(0)
	<isDirty+?>: inc.i32(+116)
	<isDirty+?>: load.is8
	<isDirty+?>: load.sp(+16)
	<isDirty+?>: store.i8
	<isDirty+?>: inc.sp(-4)
	<isDirty+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:211: referenced as `isDirty`
	cmplGfx/lib/micro.ui.ci:58: referenced as `isDirty`
}
Button: View {
.kind: static const typename(ref)
.base: `View`
.size: 68
.name: 'Button'
.file: 'cmplGfx/lib/micro.ui.ci:4'
.field text: char[*] (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 53, cast: static function)
.field onDraw: function (size: 29, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:837: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:790: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:790: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:777: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:751: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:699: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:677: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:672: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:663: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:14: referenced as `Button`
	cmplGfx/lib/micro.ui.ci:8: referenced as `Button`
}
Button.text: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.name: 'text'
.file: 'cmplGfx/lib/micro.ui.ci:6'
.owner: Button
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:845: referenced as `text`
	cmplGfx/lib/micro.ui.ci:796: referenced as `text`
	cmplGfx/lib/micro.ui.ci:780: referenced as `text`
	cmplGfx/lib/micro.ui.ci:700: referenced as `text`
	cmplGfx/lib/micro.ui.ci:669: referenced as `text`
	cmplGfx/lib/micro.ui.ci:668: referenced as `text`
	cmplGfx/lib/micro.ui.ci:15: referenced as `text`
	cmplGfx/lib/micro.ui.ci:10: referenced as `text`
}
Button.onMeasure(this: Button, rect: Rect): bool: function {
.kind: static function
.base: `function`
.size: 53
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.ci:8'
.owner: Button
.param .result: bool (size: 4, cast: variable(bool))
.param this: Button (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	style: Style := this.style;
	Style.measure(style, &rect, this.text);
	return .result := View.onMeasure(this, &rect);
}
.instructions: (53 bytes)
	cmplGfx/lib/micro.ui.ci:9: (7 bytes): style: Style := this.style
	<onMeasure>  : dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+20)
	<onMeasure+?>: load.i32
	cmplGfx/lib/micro.ui.ci:10: (21 bytes): Style.measure(style, &rect, this.text);
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(5)
	<onMeasure+?>: inc.i32(+64)
	<onMeasure+?>: load.i32
	<onMeasure+?>: load.ref <?> ;Style.measure(this: Style, rect: Rect, text: char[*]): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.ci:11: (25 bytes): return .result := View.onMeasure(this, &rect);
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: load.ref <?> ;View.onMeasure(this: View, rect: Rect): bool
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: load.sp(+20)
	<onMeasure+?>: store.i8
	<onMeasure+?>: inc.sp(-4)
	<onMeasure+?>: ret
.usages:
}
Button.onDraw(this: Button, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 29
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.ci:14'
.owner: Button
.param .result: void (size: 0, cast: variable(void))
.param this: Button (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.doc: 'Callback function executed when the view needs to be drawn'
.value: {
	View.onDraw(this, offs, rect, null, this.text);
}
.instructions: (29 bytes)
	cmplGfx/lib/micro.ui.ci:15: (28 bytes): View.onDraw(this, offs, rect, null, this.text);
	<onDraw>  : dup.x32 sp(7)
	<onDraw+?>: dup.x64 sp(6)
	<onDraw+?>: dup.x128 sp(4)
	<onDraw+?>: load.ref <?> ;null
	<onDraw+?>: dup.x32 sp(15)
	<onDraw+?>: inc.i32(+64)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;View.onDraw(this: View, offs: Image, rect: Rect, text: char[*], value: char[*]): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-36)
	<onDraw+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:672: referenced as `onDraw`
}
Switch: View {
.kind: static const typename(ref)
.base: `View`
.size: 92
.name: 'Switch'
.file: 'cmplGfx/lib/micro.ui.ci:20'
.field onOff: char[*][] (size: 16, cast: static const variable(arr))
.field text: char[*] (size: 4, cast: const variable(ref))
.field states: char[*][] (size: 8, cast: const variable(arr))
.field selected: int32 (size: 4, cast: variable(i32))
.field resetValue: int32 (size: 4, cast: const variable(i32))
.field clickToFocus: bool (size: 1, cast: const variable(bool))
.field checked: function (size: 16, cast: static function)
.field onUpdate: function (size: 115, cast: static function)
.field onUpdate: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 28, cast: static function)
.field onClick: function (size: 128, cast: static function)
.field onCreate: function (size: 78, cast: static function)
.field onKeyEvent: function (size: 231, cast: static function)
.field onTouchEvent: function (size: 145, cast: static function)
.field onMeasure: function (size: 280, cast: static function)
.field onDraw: function (size: 421, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:808: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:802: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:752: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:141: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:122: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:111: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:96: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:91: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:87: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:69: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:65: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:44: referenced as `Switch`
	cmplGfx/lib/micro.ui.ci:39: referenced as `Switch`
}
Switch.onOff: char[*][] {
.kind: static const variable(arr)
.base: `char[*][]`
.size: 16
.name: 'onOff'
.file: 'cmplGfx/lib/micro.ui.ci:21'
.owner: Switch
.value: {
	onOff := onOff.init;
	onOff.init[0] := ("off");
	onOff.init[1] := ("on");
}
.usages:
	cmplGfx/lib/micro.ui.ci:29: referenced as `onOff`
}
Switch.text: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.name: 'text'
.file: 'cmplGfx/lib/micro.ui.ci:27'
.owner: Switch
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:817: referenced as `text`
	cmplGfx/lib/micro.ui.ci:175: referenced as `text`
	cmplGfx/lib/micro.ui.ci:132: referenced as `text`
}
Switch.states: char[*][] {
.kind: const variable(arr)
.base: `char[*][]`
.size: 8
.name: 'states'
.file: 'cmplGfx/lib/micro.ui.ci:29'
.owner: Switch
.doc: '@public'
.value: onOff
.usages:
	cmplGfx/lib/micro.ui.ci:818: referenced as `states`
	cmplGfx/lib/micro.ui.ci:173: referenced as `states`
	cmplGfx/lib/micro.ui.ci:144: referenced as `states`
	cmplGfx/lib/micro.ui.ci:133: referenced as `states`
	cmplGfx/lib/micro.ui.ci:127: referenced as `states`
	cmplGfx/lib/micro.ui.ci:125: referenced as `states`
	cmplGfx/lib/micro.ui.ci:75: referenced as `states`
	cmplGfx/lib/micro.ui.ci:45: referenced as `states`
}
Switch.selected: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'selected'
.file: 'cmplGfx/lib/micro.ui.ci:32'
.owner: Switch
.doc: '@public'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:173: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:116: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:105: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:101: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:92: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:91: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:76: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:61: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:57: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:40: referenced as `selected`
	internal usages: 1
}
Switch.resetValue: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'resetValue'
.file: 'cmplGfx/lib/micro.ui.ci:33'
.owner: Switch
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:90: referenced as `resetValue`
	cmplGfx/lib/micro.ui.ci:66: referenced as `resetValue`
	internal usages: 1
}
Switch.clickToFocus: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'clickToFocus'
.file: 'cmplGfx/lib/micro.ui.ci:36'
.owner: Switch
.doc: 'clicking on a non focused view will not update the value, it will just focus it.'
.value: true
.usages:
	cmplGfx/lib/micro.ui.ci:819: referenced as `clickToFocus`
	cmplGfx/lib/micro.ui.ci:70: referenced as `clickToFocus`
}
Switch.checked(this: Switch): bool: function {
.kind: static function
.base: `function`
.size: 16
.name: 'checked'
.file: 'cmplGfx/lib/micro.ui.ci:39'
.owner: Switch
.param .result: bool (size: 4, cast: variable(bool))
.param this: Switch (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	return .result := this.selected != 0;
}
.instructions: (16 bytes)
	cmplGfx/lib/micro.ui.ci:40: (16 bytes): return .result := this.selected != 0;
	<checked>  : dup.x32 sp(1)
	<checked+?>: inc.i32(+76)
	<checked+?>: load.i32
	<checked+?>: load.z32
	<checked+?>: ceq.i32
	<checked+?>: not.b32
	<checked+?>: load.sp(+12)
	<checked+?>: store.i8
	<checked+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:811: referenced as `checked`
	cmplGfx/lib/micro.ui.ci:164: referenced as `checked`
	cmplGfx/lib/micro.ui.ci:156: referenced as `checked`
}
Switch.onUpdate(this: Switch, selected: int32): bool: function {
.kind: static function
.base: `function`
.size: 115
.name: 'onUpdate'
.file: 'cmplGfx/lib/micro.ui.ci:44'
.owner: Switch
.param .result: bool (size: 4, cast: variable(bool))
.param this: Switch (size: 4, cast: variable(ref))
.param selected: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	maxValue: int32 := this.states.length;
	if (maxValue == 0) {
		maxValue := 2;
	}
	if (selected >= maxValue) {
		selected := maxValue - 1;
	}
	else if (selected < 0) {
		selected := 0;
	}
	if (this.selected == selected) {
		return .result := isDirty(this);
	}
	this.selected := selected;
	return .result := true;
}
.instructions: (115 bytes)
	cmplGfx/lib/micro.ui.ci:45: (7 bytes): maxValue: int32 := this.states.length
	<onUpdate>  : dup.x32 sp(2)
	<onUpdate+?>: inc.i32(+72)
	<onUpdate+?>: load.i32
	cmplGfx/lib/micro.ui.ci:46: (15 bytes): if (maxValue == 0)
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: load.z32
	<onUpdate+?>: ceq.i32
	<onUpdate+?>: jz +11
	cmplGfx/lib/micro.ui.ci:48: (7 bytes): maxValue := 2;
	<onUpdate+?>: load.c32 2
	<onUpdate+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:50: (32 bytes): if (selected >= maxValue)
	<onUpdate+?>: dup.x32 sp(2)
	<onUpdate+?>: dup.x32 sp(1)
	<onUpdate+?>: clt.i32
	<onUpdate+?>: jnz +16
	cmplGfx/lib/micro.ui.ci:51: (8 bytes): selected := maxValue - 1;
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: inc.i32(-1)
	<onUpdate+?>: set.x32 sp(3)
	<onUpdate+?>: jmp +15
	cmplGfx/lib/micro.ui.ci:53: (11 bytes): if (selected < 0)
	<onUpdate+?>: dup.x32 sp(2)
	<onUpdate+?>: load.z32
	<onUpdate+?>: clt.i32
	<onUpdate+?>: jz +7
	cmplGfx/lib/micro.ui.ci:54: (3 bytes): selected := 0;
	<onUpdate+?>: load.z32
	<onUpdate+?>: set.x32 sp(3)
	cmplGfx/lib/micro.ui.ci:57: (37 bytes): if (this.selected == selected)
	<onUpdate+?>: dup.x32 sp(3)
	<onUpdate+?>: inc.i32(+76)
	<onUpdate+?>: load.i32
	<onUpdate+?>: dup.x32 sp(3)
	<onUpdate+?>: ceq.i32
	<onUpdate+?>: jz +27
	cmplGfx/lib/micro.ui.ci:58: (23 bytes): return .result := isDirty(this);
	<onUpdate+?>: load.z32
	<onUpdate+?>: dup.x32 sp(4)
	<onUpdate+?>: load.ref <?> ;isDirty(view: View): bool
	<onUpdate+?>: call
	<onUpdate+?>: inc.sp(-4)
	<onUpdate+?>: load.sp(+20)
	<onUpdate+?>: store.i8
	<onUpdate+?>: inc.sp(-4)
	<onUpdate+?>: ret
	cmplGfx/lib/micro.ui.ci:61: (9 bytes): this.selected := selected;
	<onUpdate+?>: dup.x32 sp(2)
	<onUpdate+?>: dup.x32 sp(4)
	<onUpdate+?>: inc.i32(+76)
	<onUpdate+?>: store.i32
	cmplGfx/lib/micro.ui.ci:62: (15 bytes): return .result := true;
	<onUpdate+?>: load.c32 1
	<onUpdate+?>: load.sp(+20)
	<onUpdate+?>: store.i8
	<onUpdate+?>: inc.sp(-4)
	<onUpdate+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:91: referenced as `onUpdate`
}
Switch.onUpdate(this: Switch, selected: int32): bool: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onUpdate'
.file: 'cmplGfx/lib/micro.ui.ci:44'
.owner: Switch
.param .result: bool (size: 4, cast: variable(bool))
.param this: Switch (size: 4, cast: variable(ref))
.param selected: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: onUpdate
.usages:
	cmplGfx/lib/micro.ui.ci:771: referenced as `onUpdate`
	cmplGfx/lib/micro.ui.ci:117: referenced as `onUpdate`
	cmplGfx/lib/micro.ui.ci:106: referenced as `onUpdate`
	cmplGfx/lib/micro.ui.ci:102: referenced as `onUpdate`
	cmplGfx/lib/micro.ui.ci:84: referenced as `onUpdate`
	cmplGfx/lib/micro.ui.ci:66: referenced as `onUpdate`
	internal usages: 1
}
Switch.onReset(this: Switch): bool: function {
.kind: static function
.base: `function`
.size: 28
.name: 'onReset'
.file: 'cmplGfx/lib/micro.ui.ci:65'
.owner: Switch
.param .result: bool (size: 4, cast: variable(bool))
.param this: Switch (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is double clicked'
.value: {
	return .result := this.onUpdate(this, this.resetValue);
}
.instructions: (28 bytes)
	cmplGfx/lib/micro.ui.ci:66: (28 bytes): return .result := this.onUpdate(this, this.resetValue);
	<onReset>  : load.z32
	<onReset+?>: dup.x32 sp(2)
	<onReset+?>: dup.x32 sp(3)
	<onReset+?>: inc.i32(+80)
	<onReset+?>: load.i32
	<onReset+?>: dup.x32 sp(4)
	<onReset+?>: inc.i32(+88)
	<onReset+?>: load.i32
	<onReset+?>: call
	<onReset+?>: inc.sp(-8)
	<onReset+?>: load.sp(+12)
	<onReset+?>: store.i8
	<onReset+?>: ret
.usages:
}
Switch.onClick(this: Switch): bool: function {
.kind: static function
.base: `function`
.size: 128
.name: 'onClick'
.file: 'cmplGfx/lib/micro.ui.ci:69'
.owner: Switch
.param .result: bool (size: 4, cast: variable(bool))
.param this: Switch (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is clicked'
.value: {
	if (this.focusable && this.clickToFocus) {
		if (!isFocused(this)) {
			return .result := true;
		}
	}
	maxValue: int32 := this.states.length;
	value: int32 := this.selected + 1;
	if (maxValue == 0) {
		maxValue := 2;
	}
	if (value >= maxValue) {
		value := 0;
	}
	return .result := this.onUpdate(this, value);
}
.instructions: (128 bytes)
	cmplGfx/lib/micro.ui.ci:70: (56 bytes): if (this.focusable && this.clickToFocus)
	<onClick>  : dup.x32 sp(1)
	<onClick+?>: inc.i32(+13)
	<onClick+?>: load.is8
	<onClick+?>: dup.x32 sp(0)
	<onClick+?>: jz +15
	<onClick+?>: inc.sp(-4)
	<onClick+?>: dup.x32 sp(1)
	<onClick+?>: inc.i32(+84)
	<onClick+?>: load.is8
	<onClick+?>: jz +32
	cmplGfx/lib/micro.ui.ci:71: (28 bytes): if (!isFocused(this))
	<onClick+?>: load.z32
	<onClick+?>: dup.x32 sp(2)
	<onClick+?>: load.ref <?> ;isFocused(view: View): bool
	<onClick+?>: call
	<onClick+?>: inc.sp(-4)
	<onClick+?>: jnz +15
	cmplGfx/lib/micro.ui.ci:72: (11 bytes): return .result := true;
	<onClick+?>: load.c32 1
	<onClick+?>: load.sp(+12)
	<onClick+?>: store.i8
	<onClick+?>: ret
	cmplGfx/lib/micro.ui.ci:75: (7 bytes): maxValue: int32 := this.states.length
	<onClick+?>: dup.x32 sp(1)
	<onClick+?>: inc.i32(+72)
	<onClick+?>: load.i32
	cmplGfx/lib/micro.ui.ci:76: (11 bytes): value: int32 := this.selected + 1
	<onClick+?>: dup.x32 sp(2)
	<onClick+?>: inc.i32(+76)
	<onClick+?>: load.i32
	<onClick+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:77: (15 bytes): if (maxValue == 0)
	<onClick+?>: dup.x32 sp(1)
	<onClick+?>: load.z32
	<onClick+?>: ceq.i32
	<onClick+?>: jz +11
	cmplGfx/lib/micro.ui.ci:79: (7 bytes): maxValue := 2;
	<onClick+?>: load.c32 2
	<onClick+?>: set.x32 sp(2)
	cmplGfx/lib/micro.ui.ci:81: (12 bytes): if (value >= maxValue)
	<onClick+?>: dup.x32 sp(0)
	<onClick+?>: dup.x32 sp(2)
	<onClick+?>: clt.i32
	<onClick+?>: jnz +7
	cmplGfx/lib/micro.ui.ci:82: (3 bytes): value := 0;
	<onClick+?>: load.z32
	<onClick+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:84: (27 bytes): return .result := this.onUpdate(this, value);
	<onClick+?>: load.z32
	<onClick+?>: dup.x32 sp(4)
	<onClick+?>: dup.x32 sp(2)
	<onClick+?>: dup.x32 sp(6)
	<onClick+?>: inc.i32(+88)
	<onClick+?>: load.i32
	<onClick+?>: call
	<onClick+?>: inc.sp(-8)
	<onClick+?>: load.sp(+20)
	<onClick+?>: store.i8
	<onClick+?>: inc.sp(-8)
	<onClick+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:808: referenced as `onClick`
}
Switch.onCreate(this: Switch, parent: View): void: function {
.kind: static function
.base: `function`
.size: 78
.name: 'onCreate'
.file: 'cmplGfx/lib/micro.ui.ci:87'
.owner: Switch
.param .result: void (size: 0, cast: variable(void))
.param this: Switch (size: 4, cast: variable(ref))
.param parent: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is created'
.value: {
	View.onCreate(this, parent);
	resetValue: int32 := pointer(this.resetValue);
	Switch.onUpdate(this, this.selected);
	resetValue := this.selected;
	this.onReset(this);
}
.instructions: (78 bytes)
	cmplGfx/lib/micro.ui.ci:88: (14 bytes): View.onCreate(this, parent);
	<onCreate>  : dup.x32 sp(2)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: load.ref <?> ;View.onCreate(this: View, parent: View): void
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:90: (6 bytes): resetValue: int32 := pointer(this.resetValue)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: inc.i32(+80)
	cmplGfx/lib/micro.ui.ci:91: (24 bytes): Switch.onUpdate(this, this.selected);
	<onCreate+?>: load.z32
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: dup.x32 sp(5)
	<onCreate+?>: inc.i32(+76)
	<onCreate+?>: load.i32
	<onCreate+?>: load.ref <?> ;Switch.onUpdate(this: Switch, selected: int32): bool
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-8)
	<onCreate+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:92: (10 bytes): resetValue := this.selected;
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: inc.i32(+76)
	<onCreate+?>: load.i32
	<onCreate+?>: dup.x32 sp(1)
	<onCreate+?>: store.i32
	cmplGfx/lib/micro.ui.ci:93: (19 bytes): this.onReset(this);
	<onCreate+?>: load.z32
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: dup.x32 sp(5)
	<onCreate+?>: inc.i32(+36)
	<onCreate+?>: load.i32
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: ret
.usages:
}
Switch.onKeyEvent(this: Switch, event: KeyEvent): bool: function {
.kind: static function
.base: `function`
.size: 231
.name: 'onKeyEvent'
.file: 'cmplGfx/lib/micro.ui.ci:96'
.owner: Switch
.param .result: bool (size: 4, cast: variable(bool))
.param this: Switch (size: 4, cast: variable(ref))
.param event: KeyEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a KeyEvent: press or release'
.value: {
	if (!this.enabled || event.release) {
		return .result := View.onKeyEvent(this, event);
	}
	if (event.key == ('+') || event.key == ('=')) {
		value: int32 := this.selected + 1;
		return .result := this.onUpdate(this, value);
	}
	if (event.key == ('-') || event.key == ('_')) {
		value: int32 := this.selected - 1;
		return .result := this.onUpdate(this, value);
	}
	return .result := View.onKeyEvent(this, event);
}
.instructions: (231 bytes)
	cmplGfx/lib/micro.ui.ci:97: (46 bytes): if (!this.enabled || event.release)
	<onKeyEvent>  : dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: not.b32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jnz +11
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jz +25
	cmplGfx/lib/micro.ui.ci:98: (21 bytes): return .result := View.onKeyEvent(this, event);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.ref <?> ;View.onKeyEvent(this: View, event: KeyEvent): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:100: (82 bytes): if (event.key == ('+') || event.key == ('='))
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 43
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jnz +21
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 61
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +46
	cmplGfx/lib/micro.ui.ci:101: (11 bytes): value: int32 := this.selected + 1
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+76)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:102: (27 bytes): return .result := this.onUpdate(this, value);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: dup.x32 sp(6)
	<onKeyEvent+?>: inc.i32(+88)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+20)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: ret
	<onKeyEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:104: (82 bytes): if (event.key == ('-') || event.key == ('_'))
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 45
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jnz +21
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 95
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +46
	cmplGfx/lib/micro.ui.ci:105: (11 bytes): value: int32 := this.selected - 1
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+76)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: inc.i32(-1)
	cmplGfx/lib/micro.ui.ci:106: (27 bytes): return .result := this.onUpdate(this, value);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: dup.x32 sp(6)
	<onKeyEvent+?>: inc.i32(+88)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+20)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: ret
	<onKeyEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:108: (21 bytes): return .result := View.onKeyEvent(this, event);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.ref <?> ;View.onKeyEvent(this: View, event: KeyEvent): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
.usages:
}
Switch.onTouchEvent(this: Switch, rect: Rect, event: TouchEvent): bool: function {
.kind: static function
.base: `function`
.size: 145
.name: 'onTouchEvent'
.file: 'cmplGfx/lib/micro.ui.ci:111'
.owner: Switch
.param .result: bool (size: 4, cast: variable(bool))
.param this: Switch (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: const variable(ref))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a TouchEvent: press, motion or release'
.value: {
	if (!this.enabled || !event.release) {
		return .result := View.onTouchEvent(this, rect, event);
	}
	if (event.isShift && event.clicks >= 0) {
		value: int32 := this.selected - 1;
		return .result := this.onUpdate(this, value);
	}
	return .result := View.onTouchEvent(this, rect, event);
}
.instructions: (145 bytes)
	cmplGfx/lib/micro.ui.ci:112: (49 bytes): if (!this.enabled || !event.release)
	<onTouchEvent>  : dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+12)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jnz +12
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: jz +27
	cmplGfx/lib/micro.ui.ci:113: (23 bytes): return .result := View.onTouchEvent(this, rect, event);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.ref <?> ;View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:115: (73 bytes): if (event.isShift && event.clicks >= 0)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+1)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jz +18
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: clt.i32
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: jz +46
	cmplGfx/lib/micro.ui.ci:116: (11 bytes): value: int32 := this.selected - 1
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+76)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: inc.i32(-1)
	cmplGfx/lib/micro.ui.ci:117: (27 bytes): return .result := this.onUpdate(this, value);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: inc.i32(+88)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: load.sp(+24)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: ret
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:119: (23 bytes): return .result := View.onTouchEvent(this, rect, event);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.ref <?> ;View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
.usages:
}
Switch.onMeasure(this: Switch, rect: Rect): bool: function {
.kind: static function
.base: `function`
.size: 280
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.ci:122'
.owner: Switch
.param .result: bool (size: 4, cast: variable(bool))
.param this: Switch (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	maxWidth: int32 := 0;
	style: Style := this.style;
	for (i: int32 := 0; i < (this.states.length); i := i + 1) {
		measured: Rect := {
			measured.x0 := 0;
			measured.y0 := 0;
			measured.x1 := 0;
			measured.y1 := 0;
		};
		Style.measure(style, &measured, this.states[i]);
		if (maxWidth < width(measured)) {
			maxWidth := width(measured);
		}
	}
	Style.measure(style, &rect, this.text);
	if (this.states.length == (0)) {
		width(rect, width(rect) + height(rect) * 3 / 2);
	}
	else {
		width(rect, width(rect) + maxWidth);
	}
	return .result := View.onMeasure(this, &rect);
}
.instructions: (280 bytes)
	cmplGfx/lib/micro.ui.ci:123: (1 byte): maxWidth: int32 := 0
	<onMeasure>  : load.z32
	cmplGfx/lib/micro.ui.ci:124: (7 bytes): style: Style := this.style
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: inc.i32(+20)
	<onMeasure+?>: load.i32
	cmplGfx/lib/micro.ui.ci:125: (120 bytes): for (i: int32 := 0; i < (this.states.length); i := i + 1)
	<onMeasure+?>: load.z32
	<onMeasure+?>: jmp +101
	cmplGfx/lib/micro.ui.ci:126: (16 bytes): measured: Rect := {...}
	<onMeasure+?>: inc.sp(+16)
	:: (3 bytes): measured.x0 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: set.x32 sp(1)
	:: (3 bytes): measured.y0 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: set.x32 sp(2)
	:: (3 bytes): measured.x1 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: set.x32 sp(3)
	:: (3 bytes): measured.y1 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: set.x32 sp(4)
	cmplGfx/lib/micro.ui.ci:127: (30 bytes): Style.measure(style, &measured, this.states[i]);
	<onMeasure+?>: dup.x32 sp(5)
	<onMeasure+?>: load.sp(+4)
	<onMeasure+?>: dup.x32 sp(11)
	<onMeasure+?>: inc.i32(+68)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(7)
	<onMeasure+?>: mad.u32 4
	<onMeasure+?>: load.i32
	<onMeasure+?>: load.ref <?> ;Style.measure(this: Style, rect: Rect, text: char[*]): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.ci:128: (43 bytes): if (maxWidth < width(measured))
	<onMeasure+?>: dup.x32 sp(6)
	<onMeasure+?>: load.sp(+4)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jz +23
	cmplGfx/lib/micro.ui.ci:129: (19 bytes): maxWidth := width(measured);
	<onMeasure+?>: load.sp(+0)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: set.x32 sp(7)
	<onMeasure+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.ci:125: (4 bytes): i := i + 1
	<onMeasure+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:125: (14 bytes): i < (this.states.length)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(6)
	<onMeasure+?>: inc.i32(+72)
	<onMeasure+?>: load.i32
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jnz -107
	<onMeasure+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:132: (21 bytes): Style.measure(style, &rect, this.text);
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: dup.x32 sp(6)
	<onMeasure+?>: inc.i32(+64)
	<onMeasure+?>: load.i32
	<onMeasure+?>: load.ref <?> ;Style.measure(this: Style, rect: Rect, text: char[*]): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.ci:133: (106 bytes): if (this.states.length == (0))
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: inc.i32(+72)
	<onMeasure+?>: load.i32
	<onMeasure+?>: load.z32
	<onMeasure+?>: ceq.i32
	<onMeasure+?>: jz +67
	cmplGfx/lib/micro.ui.ci:134: (59 bytes): width(rect, width(rect) + height(rect) * 3 / 2);
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: dup.x32 sp(5)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+12)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: inc.i32(+4)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: load.c32 3
	<onMeasure+?>: mul.i32
	<onMeasure+?>: load.c32 2
	<onMeasure+?>: div.i32
	<onMeasure+?>: add.i32
	<onMeasure+?>: load.ref <?> ;width(rectangle: Rect, width: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: jmp +34
	cmplGfx/lib/micro.ui.ci:136: (30 bytes): width(rect, width(rect) + maxWidth);
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: add.i32
	<onMeasure+?>: load.ref <?> ;width(rectangle: Rect, width: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:138: (25 bytes): return .result := View.onMeasure(this, &rect);
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(5)
	<onMeasure+?>: dup.x32 sp(5)
	<onMeasure+?>: load.ref <?> ;View.onMeasure(this: View, rect: Rect): bool
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: load.sp(+24)
	<onMeasure+?>: store.i8
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: ret
.usages:
}
Switch.onDraw(this: Switch, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 421
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.ci:141'
.owner: Switch
.param .result: void (size: 0, cast: variable(void))
.param this: Switch (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.doc: 'Callback function executed when the view needs to be drawn'
.value: {
	value: char[*] := null;
	style: Style := this.style;
	if (this.states.length == (0)) {
		onOffRect: Rect := {
			onOffRect.x0 := rect.x0;
			onOffRect.y0 := rect.y0;
			onOffRect.x1 := rect.x0 + height(rect) * 3 / 2;
			onOffRect.y1 := rect.y1;
		};
		Style.align(rect, &onOffRect, Style.right);
		rect.x1 := onOffRect.x0;
		padded(onOffRect, -style.padding);
		color: uint32 := style.focusedColor;
		if (checked(this)) {
			color := style.valueColor;
		}
		else if (isFocused(this)) {
			color := style.hoveredColor;
		}
		fillRRect(offs, onOffRect, height(onOffRect) / 2, color);
		if (checked(this)) {
			onOffRect.x0 := onOffRect.x1 - height(onOffRect);
		}
		else {
			onOffRect.x1 := onOffRect.x0 + height(onOffRect);
		}
		padded(onOffRect, -style.padding / 3);
		fillOval(offs, onOffRect, style.textColor);
	}
	else {
		value := (this.states[this.selected]);
	}
	View.onDraw(this, offs, rect, this.text, value);
}
.instructions: (421 bytes)
	cmplGfx/lib/micro.ui.ci:142: (5 bytes): value: char[*] := null
	<onDraw>  : load.ref <?> ;null
	cmplGfx/lib/micro.ui.ci:143: (7 bytes): style: Style := this.style
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: inc.i32(+20)
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.ci:144: (379 bytes): if (this.states.length == (0))
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+72)
	<onDraw+?>: load.i32
	<onDraw+?>: load.z32
	<onDraw+?>: ceq.i32
	<onDraw+?>: jz +349
	cmplGfx/lib/micro.ui.ci:145: (51 bytes): onOffRect: Rect := {...}
	<onDraw+?>: inc.sp(+16)
	cmplGfx/lib/micro.ui.ci:146: (3 bytes): onOffRect.x0 := rect.x0;
	<onDraw+?>: mov.x32 sp(0, 7)
	cmplGfx/lib/micro.ui.ci:147: (3 bytes): onOffRect.y0 := rect.y0;
	<onDraw+?>: mov.x32 sp(1, 8)
	cmplGfx/lib/micro.ui.ci:148: (38 bytes): onOffRect.x1 := rect.x0 + height(rect) * 3 / 2;
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: load.sp(+32)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: inc.i32(+12)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: inc.i32(+4)
	<onDraw+?>: load.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(1)
	<onDraw+?>: load.c32 3
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 2
	<onDraw+?>: div.i32
	<onDraw+?>: add.i32
	<onDraw+?>: set.x32 sp(3)
	cmplGfx/lib/micro.ui.ci:149: (3 bytes): onOffRect.y1 := rect.y1;
	<onDraw+?>: mov.x32 sp(3, 10)
	cmplGfx/lib/micro.ui.ci:151: (21 bytes): Style.align(rect, &onOffRect, Style.right);
	<onDraw+?>: dup.x128 sp(7)
	<onDraw+?>: load.sp(+16)
	<onDraw+?>: load.c32 4
	<onDraw+?>: load.ref <?> ;Style.align(parent: Rect, rect: Rect, align: int32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-24)
	cmplGfx/lib/micro.ui.ci:152: (3 bytes): rect.x1 := onOffRect.x0;
	<onDraw+?>: mov.x32 sp(9, 0)
	cmplGfx/lib/micro.ui.ci:154: (22 bytes): padded(onOffRect, -style.padding);
	<onDraw+?>: load.sp(+0)
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: inc.i32(+4)
	<onDraw+?>: load.i32
	<onDraw+?>: neg.i32
	<onDraw+?>: load.ref <?> ;padded(rect: Rect, padding: int32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:155: (7 bytes): color: uint32 := style.focusedColor
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: inc.i32(+40)
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.ci:156: (56 bytes): if (checked(this))
	<onDraw+?>: load.z32
	<onDraw+?>: dup.x32 sp(15)
	<onDraw+?>: load.ref <?> ;Switch.checked(this: Switch): bool
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: jz +17
	cmplGfx/lib/micro.ui.ci:157: (9 bytes): color := style.valueColor;
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: inc.i32(+44)
	<onDraw+?>: load.i32
	<onDraw+?>: set.x32 sp(1)
	<onDraw+?>: jmp +30
	cmplGfx/lib/micro.ui.ci:159: (26 bytes): if (isFocused(this))
	<onDraw+?>: load.z32
	<onDraw+?>: dup.x32 sp(15)
	<onDraw+?>: load.ref <?> ;isFocused(view: View): bool
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: jz +13
	cmplGfx/lib/micro.ui.ci:160: (9 bytes): color := style.hoveredColor;
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: inc.i32(+36)
	<onDraw+?>: load.i32
	<onDraw+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:162: (53 bytes): fillRRect(offs, onOffRect, height(onOffRect) / 2, color);
	<onDraw+?>: load.sp(+4)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: inc.i32(+12)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: inc.i32(+4)
	<onDraw+?>: load.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(1)
	<onDraw+?>: load.c32 2
	<onDraw+?>: div.i32
	<onDraw+?>: dup.x64 sp(13)
	<onDraw+?>: load.sp(+16)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: load.ref <?> ;fillRRect(image: Image, roi: Rect, rx: int32, ry: int32, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-24)
	<onDraw+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:164: (73 bytes): if (checked(this))
	<onDraw+?>: load.z32
	<onDraw+?>: dup.x32 sp(15)
	<onDraw+?>: load.ref <?> ;Switch.checked(this: Switch): bool
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: jz +34
	cmplGfx/lib/micro.ui.ci:165: (26 bytes): onOffRect.x0 := onOffRect.x1 - height(onOffRect);
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: load.sp(+8)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: inc.i32(+12)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: inc.i32(+4)
	<onDraw+?>: load.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(1)
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(2)
	<onDraw+?>: jmp +30
	cmplGfx/lib/micro.ui.ci:167: (26 bytes): onOffRect.x1 := onOffRect.x0 + height(onOffRect);
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: load.sp(+8)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: inc.i32(+12)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: inc.i32(+4)
	<onDraw+?>: load.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(1)
	<onDraw+?>: add.i32
	<onDraw+?>: set.x32 sp(4)
	cmplGfx/lib/micro.ui.ci:170: (28 bytes): padded(onOffRect, -style.padding / 3);
	<onDraw+?>: load.sp(+4)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: inc.i32(+4)
	<onDraw+?>: load.i32
	<onDraw+?>: neg.i32
	<onDraw+?>: load.c32 3
	<onDraw+?>: div.i32
	<onDraw+?>: load.ref <?> ;padded(rect: Rect, padding: int32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:171: (23 bytes): fillOval(offs, onOffRect, style.textColor);
	<onDraw+?>: dup.x64 sp(12)
	<onDraw+?>: load.sp(+12)
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: inc.i32(+48)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;fillOval(image: Image, roi: Rect, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-16)
	<onDraw+?>: inc.sp(-20)
	<onDraw+?>: jmp +25
	cmplGfx/lib/micro.ui.ci:173: (21 bytes): value := (this.states[this.selected]);
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: inc.i32(+76)
	<onDraw+?>: load.i32
	<onDraw+?>: mad.u32 4
	<onDraw+?>: load.i32
	<onDraw+?>: set.x32 sp(2)
	cmplGfx/lib/micro.ui.ci:175: (25 bytes): View.onDraw(this, offs, rect, this.text, value);
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: dup.x64 sp(8)
	<onDraw+?>: dup.x128 sp(6)
	<onDraw+?>: dup.x32 sp(16)
	<onDraw+?>: inc.i32(+64)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: load.ref <?> ;View.onDraw(this: View, offs: Image, rect: Rect, text: char[*], value: char[*]): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-36)
	<onDraw+?>: inc.sp(-8)
	<onDraw+?>: ret
.usages:
}
Slider: View {
.kind: static const typename(ref)
.base: `View`
.size: 128
.name: 'Slider'
.file: 'cmplGfx/lib/micro.ui.ci:180'
.field text: char[*] (size: 4, cast: const variable(ref))
.field value: float64 (size: 8, cast: variable(f64))
.field _value: float64 (size: 8, cast: variable(f64))
.field minimum: float64 (size: 8, cast: const variable(f64))
.field maximum: float64 (size: 8, cast: const variable(f64))
.field stepSize: float64 (size: 8, cast: const variable(f64))
.field resetValue: float64 (size: 8, cast: const variable(f64))
.field clickToFocus: bool (size: 1, cast: const variable(bool))
.field onUpdate: function (size: 162, cast: static function)
.field onUpdate: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 28, cast: static function)
.field onCreate: function (size: 78, cast: static function)
.field onKeyEvent: function (size: 277, cast: static function)
.field onTouchEvent: function (size: 430, cast: static function)
.field onMeasure: function (size: 273, cast: static function)
.field onDrawSlider: function (size: 183, cast: static function)
.field onDrawSlider: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 216, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:316: referenced as `Slider`
	cmplGfx/lib/micro.ui.ci:298: referenced as `Slider`
	cmplGfx/lib/micro.ui.ci:282: referenced as `Slider`
	cmplGfx/lib/micro.ui.ci:246: referenced as `Slider`
	cmplGfx/lib/micro.ui.ci:230: referenced as `Slider`
	cmplGfx/lib/micro.ui.ci:225: referenced as `Slider`
	cmplGfx/lib/micro.ui.ci:221: referenced as `Slider`
	cmplGfx/lib/micro.ui.ci:217: referenced as `Slider`
	cmplGfx/lib/micro.ui.ci:199: referenced as `Slider`
}
Slider.text: char[*] {
.kind: const variable(ref)
.base: `char[*]`
.size: 4
.name: 'text'
.file: 'cmplGfx/lib/micro.ui.ci:182'
.owner: Slider
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:326: referenced as `text`
	cmplGfx/lib/micro.ui.ci:292: referenced as `text`
}
Slider.value: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'value'
.file: 'cmplGfx/lib/micro.ui.ci:185'
.owner: Slider
.doc: '@public'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:321: referenced as `value`
	cmplGfx/lib/micro.ui.ci:319: referenced as `value`
	cmplGfx/lib/micro.ui.ci:307: referenced as `value`
	cmplGfx/lib/micro.ui.ci:288: referenced as `value`
	cmplGfx/lib/micro.ui.ci:286: referenced as `value`
	cmplGfx/lib/micro.ui.ci:226: referenced as `value`
	cmplGfx/lib/micro.ui.ci:225: referenced as `value`
	cmplGfx/lib/micro.ui.ci:213: referenced as `value`
	cmplGfx/lib/micro.ui.ci:210: referenced as `value`
}
Slider._value: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: '_value'
.file: 'cmplGfx/lib/micro.ui.ci:186'
.owner: Slider
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:259: referenced as `_value`
	cmplGfx/lib/micro.ui.ci:241: referenced as `_value`
	cmplGfx/lib/micro.ui.ci:238: referenced as `_value`
	cmplGfx/lib/micro.ui.ci:206: referenced as `_value`
}
Slider.minimum: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'minimum'
.file: 'cmplGfx/lib/micro.ui.ci:188'
.owner: Slider
.doc: '@public'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:307: referenced as `minimum`
	cmplGfx/lib/micro.ui.ci:307: referenced as `minimum`
	cmplGfx/lib/micro.ui.ci:299: referenced as `minimum`
	cmplGfx/lib/micro.ui.ci:277: referenced as `minimum`
	cmplGfx/lib/micro.ui.ci:276: referenced as `minimum`
	cmplGfx/lib/micro.ui.ci:264: referenced as `minimum`
	cmplGfx/lib/micro.ui.ci:263: referenced as `minimum`
	cmplGfx/lib/micro.ui.ci:257: referenced as `minimum`
	cmplGfx/lib/micro.ui.ci:204: referenced as `minimum`
	cmplGfx/lib/micro.ui.ci:203: referenced as `minimum`
}
Slider.maximum: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'maximum'
.file: 'cmplGfx/lib/micro.ui.ci:190'
.owner: Slider
.doc: '@public'
.value: 1
.usages:
	cmplGfx/lib/micro.ui.ci:307: referenced as `maximum`
	cmplGfx/lib/micro.ui.ci:299: referenced as `maximum`
	cmplGfx/lib/micro.ui.ci:276: referenced as `maximum`
	cmplGfx/lib/micro.ui.ci:261: referenced as `maximum`
	cmplGfx/lib/micro.ui.ci:260: referenced as `maximum`
	cmplGfx/lib/micro.ui.ci:257: referenced as `maximum`
	cmplGfx/lib/micro.ui.ci:201: referenced as `maximum`
	cmplGfx/lib/micro.ui.ci:200: referenced as `maximum`
}
Slider.stepSize: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'stepSize'
.file: 'cmplGfx/lib/micro.ui.ci:192'
.owner: Slider
.doc: '@public'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:318: referenced as `stepSize`
	cmplGfx/lib/micro.ui.ci:318: referenced as `stepSize`
	cmplGfx/lib/micro.ui.ci:285: referenced as `stepSize`
	cmplGfx/lib/micro.ui.ci:285: referenced as `stepSize`
	cmplGfx/lib/micro.ui.ci:208: referenced as `stepSize`
	cmplGfx/lib/micro.ui.ci:208: referenced as `stepSize`
	cmplGfx/lib/micro.ui.ci:207: referenced as `stepSize`
}
Slider.resetValue: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'resetValue'
.file: 'cmplGfx/lib/micro.ui.ci:193'
.owner: Slider
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:224: referenced as `resetValue`
	cmplGfx/lib/micro.ui.ci:218: referenced as `resetValue`
}
Slider.clickToFocus: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'clickToFocus'
.file: 'cmplGfx/lib/micro.ui.ci:196'
.owner: Slider
.doc: 'clicking on a non focused view will not update the value, it will just focus it.'
.value: true
.usages:
	cmplGfx/lib/micro.ui.ci:270: referenced as `clickToFocus`
}
Slider.onUpdate(this: Slider, value: float64): bool: function {
.kind: static function
.base: `function`
.size: 162
.name: 'onUpdate'
.file: 'cmplGfx/lib/micro.ui.ci:199'
.owner: Slider
.param .result: bool (size: 4, cast: variable(bool))
.param this: Slider (size: 4, cast: variable(ref))
.param value: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	if (value > this.maximum) {
		value := this.maximum;
	}
	if (value < this.minimum) {
		value := this.minimum;
	}
	this._value := value;
	if (this.stepSize != (0)) {
		value := Math.round(value / this.stepSize) * this.stepSize;
	}
	if (this.value == value) {
		return .result := isDirty(this);
	}
	this.value := value;
	return .result := true;
}
.instructions: (162 bytes)
	cmplGfx/lib/micro.ui.ci:200: (23 bytes): if (value > this.maximum)
	<onUpdate>  : dup.x64 sp(1)
	<onUpdate+?>: dup.x32 sp(5)
	<onUpdate+?>: inc.i32(+92)
	<onUpdate+?>: load.i64
	<onUpdate+?>: cgt.f64
	<onUpdate+?>: jz +13
	cmplGfx/lib/micro.ui.ci:201: (9 bytes): value := this.maximum;
	<onUpdate+?>: dup.x32 sp(3)
	<onUpdate+?>: inc.i32(+92)
	<onUpdate+?>: load.i64
	<onUpdate+?>: set.x64 sp(3)
	cmplGfx/lib/micro.ui.ci:203: (23 bytes): if (value < this.minimum)
	<onUpdate+?>: dup.x64 sp(1)
	<onUpdate+?>: dup.x32 sp(5)
	<onUpdate+?>: inc.i32(+84)
	<onUpdate+?>: load.i64
	<onUpdate+?>: clt.f64
	<onUpdate+?>: jz +13
	cmplGfx/lib/micro.ui.ci:204: (9 bytes): value := this.minimum;
	<onUpdate+?>: dup.x32 sp(3)
	<onUpdate+?>: inc.i32(+84)
	<onUpdate+?>: load.i64
	<onUpdate+?>: set.x64 sp(3)
	cmplGfx/lib/micro.ui.ci:206: (9 bytes): this._value := value;
	<onUpdate+?>: dup.x64 sp(1)
	<onUpdate+?>: dup.x32 sp(5)
	<onUpdate+?>: inc.i32(+76)
	<onUpdate+?>: store.i64
	cmplGfx/lib/micro.ui.ci:207: (54 bytes): if (this.stepSize != (0))
	<onUpdate+?>: dup.x32 sp(3)
	<onUpdate+?>: inc.i32(+100)
	<onUpdate+?>: load.i64
	<onUpdate+?>: load.z64
	<onUpdate+?>: ceq.f64
	<onUpdate+?>: jnz +45
	cmplGfx/lib/micro.ui.ci:208: (41 bytes): value := Math.round(value / this.stepSize) * this.stepSize;
	<onUpdate+?>: load.z64
	<onUpdate+?>: dup.x64 sp(3)
	<onUpdate+?>: dup.x32 sp(7)
	<onUpdate+?>: inc.i32(+100)
	<onUpdate+?>: load.i64
	<onUpdate+?>: div.f64
	<onUpdate+?>: load.f64 0.500000
	<onUpdate+?>: add.f64
	<onUpdate+?>: load.ref <?> ;Math.floor(x: float64): float64
	<onUpdate+?>: call
	<onUpdate+?>: inc.sp(-8)
	<onUpdate+?>: dup.x32 sp(5)
	<onUpdate+?>: inc.i32(+100)
	<onUpdate+?>: load.i64
	<onUpdate+?>: mul.f64
	<onUpdate+?>: set.x64 sp(3)
	cmplGfx/lib/micro.ui.ci:210: (33 bytes): if (this.value == value)
	<onUpdate+?>: dup.x32 sp(3)
	<onUpdate+?>: inc.i32(+68)
	<onUpdate+?>: load.i64
	<onUpdate+?>: dup.x64 sp(3)
	<onUpdate+?>: ceq.f64
	<onUpdate+?>: jz +23
	cmplGfx/lib/micro.ui.ci:211: (19 bytes): return .result := isDirty(this);
	<onUpdate+?>: load.z32
	<onUpdate+?>: dup.x32 sp(4)
	<onUpdate+?>: load.ref <?> ;isDirty(view: View): bool
	<onUpdate+?>: call
	<onUpdate+?>: inc.sp(-4)
	<onUpdate+?>: load.sp(+20)
	<onUpdate+?>: store.i8
	<onUpdate+?>: ret
	cmplGfx/lib/micro.ui.ci:213: (9 bytes): this.value := value;
	<onUpdate+?>: dup.x64 sp(1)
	<onUpdate+?>: dup.x32 sp(5)
	<onUpdate+?>: inc.i32(+68)
	<onUpdate+?>: store.i64
	cmplGfx/lib/micro.ui.ci:214: (11 bytes): return .result := true;
	<onUpdate+?>: load.c32 1
	<onUpdate+?>: load.sp(+20)
	<onUpdate+?>: store.i8
	<onUpdate+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:225: referenced as `onUpdate`
}
Slider.onUpdate(this: Slider, value: float64): bool: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onUpdate'
.file: 'cmplGfx/lib/micro.ui.ci:199'
.owner: Slider
.param .result: bool (size: 4, cast: variable(bool))
.param this: Slider (size: 4, cast: variable(ref))
.param value: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: onUpdate
.usages:
	cmplGfx/lib/micro.ui.ci:277: referenced as `onUpdate`
	cmplGfx/lib/micro.ui.ci:267: referenced as `onUpdate`
	cmplGfx/lib/micro.ui.ci:241: referenced as `onUpdate`
	cmplGfx/lib/micro.ui.ci:238: referenced as `onUpdate`
	cmplGfx/lib/micro.ui.ci:218: referenced as `onUpdate`
}
Slider.onReset(this: Slider): bool: function {
.kind: static function
.base: `function`
.size: 28
.name: 'onReset'
.file: 'cmplGfx/lib/micro.ui.ci:217'
.owner: Slider
.param .result: bool (size: 4, cast: variable(bool))
.param this: Slider (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is double clicked'
.value: {
	return .result := this.onUpdate(this, this.resetValue);
}
.instructions: (28 bytes)
	cmplGfx/lib/micro.ui.ci:218: (28 bytes): return .result := this.onUpdate(this, this.resetValue);
	<onReset>  : load.z32
	<onReset+?>: dup.x32 sp(2)
	<onReset+?>: dup.x32 sp(3)
	<onReset+?>: inc.i32(+108)
	<onReset+?>: load.i64
	<onReset+?>: dup.x32 sp(5)
	<onReset+?>: inc.i32(+120)
	<onReset+?>: load.i32
	<onReset+?>: call
	<onReset+?>: inc.sp(-12)
	<onReset+?>: load.sp(+12)
	<onReset+?>: store.i8
	<onReset+?>: ret
.usages:
}
Slider.onCreate(this: Slider, parent: View): void: function {
.kind: static function
.base: `function`
.size: 78
.name: 'onCreate'
.file: 'cmplGfx/lib/micro.ui.ci:221'
.owner: Slider
.param .result: void (size: 0, cast: variable(void))
.param this: Slider (size: 4, cast: variable(ref))
.param parent: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is created'
.value: {
	View.onCreate(this, parent);
	resetValue: float64 := pointer(this.resetValue);
	Slider.onUpdate(this, this.value);
	resetValue := this.value;
	this.onReset(this);
}
.instructions: (78 bytes)
	cmplGfx/lib/micro.ui.ci:222: (14 bytes): View.onCreate(this, parent);
	<onCreate>  : dup.x32 sp(2)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: load.ref <?> ;View.onCreate(this: View, parent: View): void
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:224: (6 bytes): resetValue: float64 := pointer(this.resetValue)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: inc.i32(+108)
	cmplGfx/lib/micro.ui.ci:225: (24 bytes): Slider.onUpdate(this, this.value);
	<onCreate+?>: load.z32
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: dup.x32 sp(5)
	<onCreate+?>: inc.i32(+68)
	<onCreate+?>: load.i64
	<onCreate+?>: load.ref <?> ;Slider.onUpdate(this: Slider, value: float64): bool
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-12)
	<onCreate+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:226: (10 bytes): resetValue := this.value;
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: inc.i32(+68)
	<onCreate+?>: load.i64
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: store.i64
	cmplGfx/lib/micro.ui.ci:227: (19 bytes): this.onReset(this);
	<onCreate+?>: load.z32
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: dup.x32 sp(5)
	<onCreate+?>: inc.i32(+36)
	<onCreate+?>: load.i32
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: ret
.usages:
}
Slider.onKeyEvent(this: Slider, event: KeyEvent): bool: function {
.kind: static function
.base: `function`
.size: 277
.name: 'onKeyEvent'
.file: 'cmplGfx/lib/micro.ui.ci:230'
.owner: Slider
.param .result: bool (size: 4, cast: variable(bool))
.param this: Slider (size: 4, cast: variable(ref))
.param event: KeyEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a KeyEvent: press or release'
.value: {
	if (event.release) {
		return .result := View.onKeyEvent(this, event);
	}
	if (event.key == (' ')) {
		return .result := this.onReset(this);
	}
	if (event.key == ('+') || event.key == ('=')) {
		return .result := this.onUpdate(this, this._value + ((event.isShift ? 1 : 10)));
	}
	if (event.key == ('-') || event.key == ('_')) {
		return .result := this.onUpdate(this, this._value - ((event.isShift ? 1 : 10)));
	}
	return .result := View.onKeyEvent(this, event);
}
.instructions: (277 bytes)
	cmplGfx/lib/micro.ui.ci:231: (28 bytes): if (event.release)
	<onKeyEvent>  : dup.x32 sp(1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jz +25
	cmplGfx/lib/micro.ui.ci:232: (21 bytes): return .result := View.onKeyEvent(this, event);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.ref <?> ;View.onKeyEvent(this: View, event: KeyEvent): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:234: (38 bytes): if (event.key == (' '))
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 32
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +25
	cmplGfx/lib/micro.ui.ci:235: (21 bytes): return .result := this.onReset(this);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+36)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:237: (95 bytes): if (event.key == ('+') || event.key == ('='))
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 43
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jnz +21
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 61
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +59
	cmplGfx/lib/micro.ui.ci:238: (55 bytes): return .result := this.onUpdate(this, this._value + ((event.isShift ? 1 : 10)));
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+76)
	<onKeyEvent+?>: load.i64
	<onKeyEvent+?>: dup.x32 sp(5)
	<onKeyEvent+?>: inc.i32(+1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jz +13
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: jmp +9
	<onKeyEvent+?>: load.c32 10
	<onKeyEvent+?>: i32.2f64
	<onKeyEvent+?>: add.f64
	<onKeyEvent+?>: dup.x32 sp(6)
	<onKeyEvent+?>: inc.i32(+120)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-12)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:240: (95 bytes): if (event.key == ('-') || event.key == ('_'))
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 45
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jnz +21
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 95
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +59
	cmplGfx/lib/micro.ui.ci:241: (55 bytes): return .result := this.onUpdate(this, this._value - ((event.isShift ? 1 : 10)));
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+76)
	<onKeyEvent+?>: load.i64
	<onKeyEvent+?>: dup.x32 sp(5)
	<onKeyEvent+?>: inc.i32(+1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jz +13
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: jmp +9
	<onKeyEvent+?>: load.c32 10
	<onKeyEvent+?>: i32.2f64
	<onKeyEvent+?>: sub.f64
	<onKeyEvent+?>: dup.x32 sp(6)
	<onKeyEvent+?>: inc.i32(+120)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-12)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:243: (21 bytes): return .result := View.onKeyEvent(this, event);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.ref <?> ;View.onKeyEvent(this: View, event: KeyEvent): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
.usages:
}
Slider.onTouchEvent(this: Slider, rect: Rect, event: TouchEvent): bool: function {
.kind: static function
.base: `function`
.size: 430
.name: 'onTouchEvent'
.file: 'cmplGfx/lib/micro.ui.ci:246'
.owner: Slider
.param .result: bool (size: 4, cast: variable(bool))
.param this: Slider (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: const variable(ref))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a TouchEvent: press, motion or release'
.value: {
	if (event.button == 0) {
		return .result := false;
	}
	if (event.release && (event.clicks < 0 || event.clicks > 1)) {
		return .result := this.onReset(this);
	}
	if (event.clicks < 1) {
		value: float64 := event.dx;
		if (!event.isShift && value != (0)) {
			value := value * float64(this.maximum - this.minimum) / (width(rect));
		}
		value := value + this._value;
		if (value > this.maximum) {
			value := this.maximum;
		}
		if (value < this.minimum) {
			value := this.minimum;
		}
		return .result := this.onUpdate(this, value);
	}
	if (event.release) {
		if (this.focusable && this.clickToFocus) {
			if (!isFocused(this)) {
				return .result := true;
			}
		}
		value: float64 := event.x - rect.x0;
		value := value * float64(this.maximum - this.minimum) / (width(rect));
		return .result := this.onUpdate(this, this.minimum + value);
	}
	return .result := View.onTouchEvent(this, rect, event);
}
.instructions: (430 bytes)
	cmplGfx/lib/micro.ui.ci:247: (20 bytes): if (event.button == 0)
	<onTouchEvent>  : dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+8)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: ceq.i32
	<onTouchEvent+?>: jz +11
	cmplGfx/lib/micro.ui.ci:248: (7 bytes): return .result := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:250: (70 bytes): if (event.release && (event.clicks < 0 || event.clicks > 1))
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jz +40
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: clt.i32
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jnz +21
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: cgt.i32
	<onTouchEvent+?>: jz +25
	cmplGfx/lib/micro.ui.ci:251: (21 bytes): return .result := this.onReset(this);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+36)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:254: (170 bytes): if (event.clicks < 1)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: clt.i32
	<onTouchEvent+?>: jz +157
	cmplGfx/lib/micro.ui.ci:255: (8 bytes): value: float64 := event.dx
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+12)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: i32.2f64
	cmplGfx/lib/micro.ui.ci:256: (60 bytes): if (!event.isShift && value != (0))
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+1)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jz +13
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x64 sp(0)
	<onTouchEvent+?>: load.z64
	<onTouchEvent+?>: ceq.f64
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: jz +37
	cmplGfx/lib/micro.ui.ci:257: (33 bytes): value := value * float64(this.maximum - this.minimum) / (width(rect));
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+92)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: inc.i32(+84)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: sub.f64
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: inc.i32(+8)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: sub.i32
	<onTouchEvent+?>: set.x32 sp(1)
	<onTouchEvent+?>: i32.2f64
	<onTouchEvent+?>: div.f64
	<onTouchEvent+?>: mul.f64
	cmplGfx/lib/micro.ui.ci:259: (8 bytes): value := value + this._value;
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+76)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: add.f64
	cmplGfx/lib/micro.ui.ci:260: (23 bytes): if (value > this.maximum)
	<onTouchEvent+?>: dup.x64 sp(0)
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: inc.i32(+92)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: cgt.f64
	<onTouchEvent+?>: jz +13
	cmplGfx/lib/micro.ui.ci:261: (9 bytes): value := this.maximum;
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+92)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: set.x64 sp(2)
	cmplGfx/lib/micro.ui.ci:263: (23 bytes): if (value < this.minimum)
	<onTouchEvent+?>: dup.x64 sp(0)
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: inc.i32(+84)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: clt.f64
	<onTouchEvent+?>: jz +13
	cmplGfx/lib/micro.ui.ci:264: (9 bytes): value := this.minimum;
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+84)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: set.x64 sp(2)
	cmplGfx/lib/micro.ui.ci:267: (27 bytes): return .result := this.onUpdate(this, value);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: dup.x64 sp(2)
	<onTouchEvent+?>: dup.x32 sp(9)
	<onTouchEvent+?>: inc.i32(+120)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: load.sp(+28)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: ret
	<onTouchEvent+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:269: (147 bytes): if (event.release)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jz +144
	cmplGfx/lib/micro.ui.ci:270: (56 bytes): if (this.focusable && this.clickToFocus)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+13)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jz +15
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+116)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: jz +32
	cmplGfx/lib/micro.ui.ci:271: (28 bytes): if (!isFocused(this))
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.ref <?> ;isFocused(view: View): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: jnz +15
	cmplGfx/lib/micro.ui.ci:272: (11 bytes): return .result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:275: (12 bytes): value: float64 := event.x - rect.x0
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+20)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: sub.i32
	<onTouchEvent+?>: i32.2f64
	cmplGfx/lib/micro.ui.ci:276: (33 bytes): value := value * float64(this.maximum - this.minimum) / (width(rect));
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: inc.i32(+92)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: inc.i32(+84)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: sub.f64
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: inc.i32(+8)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: sub.i32
	<onTouchEvent+?>: set.x32 sp(1)
	<onTouchEvent+?>: i32.2f64
	<onTouchEvent+?>: div.f64
	<onTouchEvent+?>: mul.f64
	cmplGfx/lib/micro.ui.ci:277: (35 bytes): return .result := this.onUpdate(this, this.minimum + value);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: inc.i32(+84)
	<onTouchEvent+?>: load.i64
	<onTouchEvent+?>: dup.x64 sp(4)
	<onTouchEvent+?>: add.f64
	<onTouchEvent+?>: dup.x32 sp(9)
	<onTouchEvent+?>: inc.i32(+120)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: load.sp(+28)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: ret
	<onTouchEvent+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:279: (23 bytes): return .result := View.onTouchEvent(this, rect, event);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.ref <?> ;View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
.usages:
}
Slider.onMeasure(this: Slider, rect: Rect): bool: function {
.kind: static function
.base: `function`
.size: 273
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.ci:282'
.owner: Slider
.param .result: bool (size: 4, cast: variable(bool))
.param this: Slider (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	value: char[64] := {
		value[0] := (0);
	};
	style: Style := this.style;
	if (this.stepSize != (0) && this.stepSize % (1) == (0)) {
		append(value, 0, int64(this.value), style.format);
	}
	else {
		append(value, 0, this.value, style.format);
	}
	valueRect: Rect := {
		valueRect.x0 := 0;
		valueRect.y0 := 0;
		valueRect.x1 := 0;
		valueRect.y1 := 0;
	};
	Style.measure(style, &valueRect, value);
	Style.measure(style, &rect, this.text);
	width(rect, width(rect) + width(valueRect));
	return .result := View.onMeasure(this, &rect);
}
.instructions: (273 bytes)
	cmplGfx/lib/micro.ui.ci:283: (10 bytes): value: char[64] := {...}
	<onMeasure>  : inc.sp(+64)
	cmplGfx/lib/micro.ui.ci:283: (6 bytes): value[0] := (0);
	<onMeasure+?>: load.z32
	<onMeasure+?>: load.sp(+4)
	<onMeasure+?>: store.i8
	cmplGfx/lib/micro.ui.ci:284: (7 bytes): style: Style := this.style
	<onMeasure+?>: dup.x32 sp(18)
	<onMeasure+?>: inc.i32(+20)
	<onMeasure+?>: load.i32
	cmplGfx/lib/micro.ui.ci:285: (129 bytes): if (this.stepSize != (0) && this.stepSize % (1) == (0))
	<onMeasure+?>: dup.x32 sp(19)
	<onMeasure+?>: inc.i32(+100)
	<onMeasure+?>: load.i64
	<onMeasure+?>: load.z64
	<onMeasure+?>: ceq.f64
	<onMeasure+?>: not.b32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: jz +27
	<onMeasure+?>: inc.sp(-4)
	<onMeasure+?>: dup.x32 sp(19)
	<onMeasure+?>: inc.i32(+100)
	<onMeasure+?>: load.i64
	<onMeasure+?>: load.f64 1.000000
	<onMeasure+?>: mod.f64
	<onMeasure+?>: load.z64
	<onMeasure+?>: ceq.f64
	<onMeasure+?>: jz +52
	cmplGfx/lib/micro.ui.ci:286: (44 bytes): append(value, 0, int64(this.value), style.format);
	<onMeasure+?>: load.z32
	<onMeasure+?>: load.c32 64
	<onMeasure+?>: load.sp(+12)
	<onMeasure+?>: load.z32
	<onMeasure+?>: load.c32 10
	<onMeasure+?>: dup.x32 sp(24)
	<onMeasure+?>: inc.i32(+68)
	<onMeasure+?>: load.i64
	<onMeasure+?>: f64.2i64
	<onMeasure+?>: dup.x32 sp(7)
	<onMeasure+?>: inc.i32(+16)
	<onMeasure+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-28)
	<onMeasure+?>: inc.sp(-4)
	<onMeasure+?>: jmp +42
	cmplGfx/lib/micro.ui.ci:288: (38 bytes): append(value, 0, this.value, style.format);
	<onMeasure+?>: load.z32
	<onMeasure+?>: load.c32 64
	<onMeasure+?>: load.sp(+12)
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(23)
	<onMeasure+?>: inc.i32(+68)
	<onMeasure+?>: load.i64
	<onMeasure+?>: dup.x32 sp(6)
	<onMeasure+?>: inc.i32(+16)
	<onMeasure+?>: load.ref <?> ;append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-24)
	<onMeasure+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:290: (16 bytes): valueRect: Rect := {...}
	<onMeasure+?>: inc.sp(+16)
	:: (3 bytes): valueRect.x0 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: set.x32 sp(1)
	:: (3 bytes): valueRect.y0 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: set.x32 sp(2)
	:: (3 bytes): valueRect.x1 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: set.x32 sp(3)
	:: (3 bytes): valueRect.y1 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: set.x32 sp(4)
	cmplGfx/lib/micro.ui.ci:291: (20 bytes): Style.measure(style, &valueRect, value);
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: load.sp(+4)
	<onMeasure+?>: load.sp(+28)
	<onMeasure+?>: load.ref <?> ;Style.measure(this: Style, rect: Rect, text: char[*]): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.ci:292: (21 bytes): Style.measure(style, &rect, this.text);
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: dup.x32 sp(23)
	<onMeasure+?>: dup.x32 sp(25)
	<onMeasure+?>: inc.i32(+64)
	<onMeasure+?>: load.i32
	<onMeasure+?>: load.ref <?> ;Style.measure(this: Style, rect: Rect, text: char[*]): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.ci:293: (45 bytes): width(rect, width(rect) + width(valueRect));
	<onMeasure+?>: dup.x32 sp(22)
	<onMeasure+?>: dup.x32 sp(23)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: load.sp(+8)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: add.i32
	<onMeasure+?>: load.ref <?> ;width(rectangle: Rect, width: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:294: (25 bytes): return .result := View.onMeasure(this, &rect);
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(24)
	<onMeasure+?>: dup.x32 sp(24)
	<onMeasure+?>: load.ref <?> ;View.onMeasure(this: View, rect: Rect): bool
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: load.sp(+100)
	<onMeasure+?>: store.i8
	<onMeasure+?>: inc.sp(-84)
	<onMeasure+?>: ret
.usages:
}
Slider.onDrawSlider(this: Slider, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 183
.name: 'onDrawSlider'
.file: 'cmplGfx/lib/micro.ui.ci:298'
.owner: Slider
.param .result: void (size: 0, cast: variable(void))
.param this: Slider (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.doc: '@public'
.value: {
	if (this.maximum == this.minimum) {
		return;
	}
	style: Style := this.style;
	const y1: int32 := rect.y1;
	const y0: int32 := y1 - style.padding / 4;
	const x0: int32 := rect.x0;
	const x1: int32 := rect.x1;
	const x: int32 := (x0) + (this.value - this.minimum) * (width(rect)) / (this.maximum - this.minimum);
	if (x > x0) {
		fillRect(offs, x0, y0, x, y1, style.valueColor);
	}
	if (x < x1) {
		fillRect(offs, x, y0, x1, y1, style.focusedColor);
	}
}
.instructions: (183 bytes)
	cmplGfx/lib/micro.ui.ci:299: (20 bytes): if (this.maximum == this.minimum)
	<onDrawSlider>  : dup.x32 sp(7)
	<onDrawSlider+?>: inc.i32(+92)
	<onDrawSlider+?>: load.i64
	<onDrawSlider+?>: dup.x32 sp(9)
	<onDrawSlider+?>: inc.i32(+84)
	<onDrawSlider+?>: load.i64
	<onDrawSlider+?>: ceq.f64
	<onDrawSlider+?>: jz +5
	cmplGfx/lib/micro.ui.ci:300: (1 byte): return;
	<onDrawSlider+?>: ret
	cmplGfx/lib/micro.ui.ci:302: (7 bytes): style: Style := this.style
	<onDrawSlider+?>: dup.x32 sp(7)
	<onDrawSlider+?>: inc.i32(+20)
	<onDrawSlider+?>: load.i32
	cmplGfx/lib/micro.ui.ci:303: (2 bytes): const y1: int32 := rect.y1
	<onDrawSlider+?>: dup.x32 sp(5)
	cmplGfx/lib/micro.ui.ci:304: (16 bytes): const y0: int32 := y1 - style.padding / 4
	<onDrawSlider+?>: dup.x32 sp(0)
	<onDrawSlider+?>: dup.x32 sp(2)
	<onDrawSlider+?>: inc.i32(+4)
	<onDrawSlider+?>: load.i32
	<onDrawSlider+?>: load.c32 4
	<onDrawSlider+?>: div.i32
	<onDrawSlider+?>: sub.i32
	cmplGfx/lib/micro.ui.ci:305: (2 bytes): const x0: int32 := rect.x0
	<onDrawSlider+?>: dup.x32 sp(4)
	cmplGfx/lib/micro.ui.ci:306: (2 bytes): const x1: int32 := rect.x1
	<onDrawSlider+?>: dup.x32 sp(7)
	cmplGfx/lib/micro.ui.ci:307: (55 bytes): const x: int32 := (x0) + (this.value - this.minimum) * (width(rect)) / (this.maximum - this.minimum)
	<onDrawSlider+?>: dup.x32 sp(1)
	<onDrawSlider+?>: i32.2f64
	<onDrawSlider+?>: dup.x32 sp(14)
	<onDrawSlider+?>: inc.i32(+68)
	<onDrawSlider+?>: load.i64
	<onDrawSlider+?>: dup.x32 sp(16)
	<onDrawSlider+?>: inc.i32(+84)
	<onDrawSlider+?>: load.i64
	<onDrawSlider+?>: sub.f64
	<onDrawSlider+?>: load.sp(+40)
	<onDrawSlider+?>: dup.x32 sp(0)
	<onDrawSlider+?>: inc.i32(+8)
	<onDrawSlider+?>: load.i32
	<onDrawSlider+?>: dup.x32 sp(1)
	<onDrawSlider+?>: load.i32
	<onDrawSlider+?>: sub.i32
	<onDrawSlider+?>: set.x32 sp(1)
	<onDrawSlider+?>: i32.2f64
	<onDrawSlider+?>: mul.f64
	<onDrawSlider+?>: dup.x32 sp(16)
	<onDrawSlider+?>: inc.i32(+92)
	<onDrawSlider+?>: load.i64
	<onDrawSlider+?>: dup.x32 sp(18)
	<onDrawSlider+?>: inc.i32(+84)
	<onDrawSlider+?>: load.i64
	<onDrawSlider+?>: sub.f64
	<onDrawSlider+?>: div.f64
	<onDrawSlider+?>: add.f64
	<onDrawSlider+?>: f64.2i32
	cmplGfx/lib/micro.ui.ci:308: (37 bytes): if (x > x0)
	<onDrawSlider+?>: dup.x32 sp(0)
	<onDrawSlider+?>: dup.x32 sp(3)
	<onDrawSlider+?>: cgt.i32
	<onDrawSlider+?>: jz +32
	cmplGfx/lib/micro.ui.ci:309: (28 bytes): fillRect(offs, x0, y0, x, y1, style.valueColor);
	<onDrawSlider+?>: dup.x64 sp(11)
	<onDrawSlider+?>: dup.x32 sp(4)
	<onDrawSlider+?>: dup.x32 sp(6)
	<onDrawSlider+?>: dup.x32 sp(4)
	<onDrawSlider+?>: dup.x32 sp(9)
	<onDrawSlider+?>: load.z32
	<onDrawSlider+?>: dup.x32 sp(12)
	<onDrawSlider+?>: inc.i32(+44)
	<onDrawSlider+?>: load.i32
	<onDrawSlider+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<onDrawSlider+?>: call
	<onDrawSlider+?>: inc.sp(-32)
	cmplGfx/lib/micro.ui.ci:311: (37 bytes): if (x < x1)
	<onDrawSlider+?>: dup.x32 sp(0)
	<onDrawSlider+?>: dup.x32 sp(2)
	<onDrawSlider+?>: clt.i32
	<onDrawSlider+?>: jz +32
	cmplGfx/lib/micro.ui.ci:312: (28 bytes): fillRect(offs, x, y0, x1, y1, style.focusedColor);
	<onDrawSlider+?>: dup.x64 sp(11)
	<onDrawSlider+?>: dup.x32 sp(2)
	<onDrawSlider+?>: dup.x32 sp(6)
	<onDrawSlider+?>: dup.x32 sp(5)
	<onDrawSlider+?>: dup.x32 sp(9)
	<onDrawSlider+?>: load.z32
	<onDrawSlider+?>: dup.x32 sp(12)
	<onDrawSlider+?>: inc.i32(+40)
	<onDrawSlider+?>: load.i32
	<onDrawSlider+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<onDrawSlider+?>: call
	<onDrawSlider+?>: inc.sp(-32)
	<onDrawSlider+?>: inc.sp(-24)
	<onDrawSlider+?>: ret
.usages:
}
Slider.onDrawSlider(this: Slider, offs: Image, rect: Rect): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onDrawSlider'
.file: 'cmplGfx/lib/micro.ui.ci:298'
.owner: Slider
.param .result: void (size: 0, cast: variable(void))
.param this: Slider (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.doc: '@public'
.value: onDrawSlider
.usages:
	cmplGfx/lib/micro.ui.ci:324: referenced as `onDrawSlider`
	cmplGfx/lib/micro.ui.ci:323: referenced as `onDrawSlider`
}
Slider.onDraw(this: Slider, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 216
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.ci:316'
.owner: Slider
.param .result: void (size: 0, cast: variable(void))
.param this: Slider (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.doc: 'Callback function executed when the view needs to be drawn'
.value: {
	value: char[64] := {
		value[0] := (0);
	};
	if (this.stepSize != (0) && this.stepSize % (1) == (0)) {
		append(value, 0, int64(this.value), this.style.format);
	}
	else {
		append(value, 0, this.value, this.style.format);
	}
	if ((this.onDrawSlider) != null) {
		this.onDrawSlider(this, offs, rect);
	}
	View.onDraw(this, offs, rect, this.text, value);
}
.instructions: (216 bytes)
	cmplGfx/lib/micro.ui.ci:317: (10 bytes): value: char[64] := {...}
	<onDraw>  : inc.sp(+64)
	cmplGfx/lib/micro.ui.ci:317: (6 bytes): value[0] := (0);
	<onDraw+?>: load.z32
	<onDraw+?>: load.sp(+4)
	<onDraw+?>: store.i8
	cmplGfx/lib/micro.ui.ci:318: (139 bytes): if (this.stepSize != (0) && this.stepSize % (1) == (0))
	<onDraw+?>: dup.x32 sp(23)
	<onDraw+?>: inc.i32(+100)
	<onDraw+?>: load.i64
	<onDraw+?>: load.z64
	<onDraw+?>: ceq.f64
	<onDraw+?>: not.b32
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: jz +27
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: dup.x32 sp(23)
	<onDraw+?>: inc.i32(+100)
	<onDraw+?>: load.i64
	<onDraw+?>: load.f64 1.000000
	<onDraw+?>: mod.f64
	<onDraw+?>: load.z64
	<onDraw+?>: ceq.f64
	<onDraw+?>: jz +57
	cmplGfx/lib/micro.ui.ci:319: (49 bytes): append(value, 0, int64(this.value), this.style.format);
	<onDraw+?>: load.z32
	<onDraw+?>: load.c32 64
	<onDraw+?>: load.sp(+8)
	<onDraw+?>: load.z32
	<onDraw+?>: load.c32 10
	<onDraw+?>: dup.x32 sp(28)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: load.i64
	<onDraw+?>: f64.2i64
	<onDraw+?>: dup.x32 sp(30)
	<onDraw+?>: inc.i32(+20)
	<onDraw+?>: load.i32
	<onDraw+?>: inc.i32(+16)
	<onDraw+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-28)
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: jmp +47
	cmplGfx/lib/micro.ui.ci:321: (43 bytes): append(value, 0, this.value, this.style.format);
	<onDraw+?>: load.z32
	<onDraw+?>: load.c32 64
	<onDraw+?>: load.sp(+8)
	<onDraw+?>: load.z32
	<onDraw+?>: dup.x32 sp(27)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: load.i64
	<onDraw+?>: dup.x32 sp(29)
	<onDraw+?>: inc.i32(+20)
	<onDraw+?>: load.i32
	<onDraw+?>: inc.i32(+16)
	<onDraw+?>: load.ref <?> ;append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-24)
	<onDraw+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:323: (35 bytes): if ((this.onDrawSlider) != null)
	<onDraw+?>: dup.x32 sp(23)
	<onDraw+?>: inc.i32(+124)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;null
	<onDraw+?>: ceq.i32
	<onDraw+?>: jnz +22
	cmplGfx/lib/micro.ui.ci:324: (18 bytes): this.onDrawSlider(this, offs, rect);
	<onDraw+?>: dup.x32 sp(23)
	<onDraw+?>: dup.x64 sp(22)
	<onDraw+?>: dup.x128 sp(20)
	<onDraw+?>: dup.x32 sp(30)
	<onDraw+?>: inc.i32(+124)
	<onDraw+?>: load.i32
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-28)
	cmplGfx/lib/micro.ui.ci:326: (27 bytes): View.onDraw(this, offs, rect, this.text, value);
	<onDraw+?>: dup.x32 sp(23)
	<onDraw+?>: dup.x64 sp(22)
	<onDraw+?>: dup.x128 sp(20)
	<onDraw+?>: dup.x32 sp(30)
	<onDraw+?>: inc.i32(+64)
	<onDraw+?>: load.i32
	<onDraw+?>: load.sp(+32)
	<onDraw+?>: load.ref <?> ;View.onDraw(this: View, offs: Image, rect: Rect, text: char[*], value: char[*]): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-36)
	<onDraw+?>: inc.sp(-64)
	<onDraw+?>: ret
.usages:
}
Histogram: View {
.kind: static const typename(ref)
.base: `View`
.size: 1096
.name: 'Histogram'
.file: 'cmplGfx/lib/micro.ui.ci:331'
.field lines: bool (size: 1, cast: const variable(bool))
.field color: bool (size: 1, cast: variable(bool))
.field data: argb[256] (size: 1024, cast: variable(val))
.field update: function (size: 32, cast: static function)
.field onUpdate: function (size: 193, cast: static function)
.field onUpdate: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 69, cast: static function)
.field onCreate: function (size: 32, cast: static function)
.field onTouchEvent: function (size: 350, cast: static function)
.field onMeasure: function (size: 81, cast: static function)
.field onDraw: function (size: 817, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:416: referenced as `Histogram`
	cmplGfx/lib/micro.ui.ci:406: referenced as `Histogram`
	cmplGfx/lib/micro.ui.ci:366: referenced as `Histogram`
	cmplGfx/lib/micro.ui.ci:363: referenced as `Histogram`
	cmplGfx/lib/micro.ui.ci:361: referenced as `Histogram`
	cmplGfx/lib/micro.ui.ci:356: referenced as `Histogram`
	cmplGfx/lib/micro.ui.ci:353: referenced as `Histogram`
	cmplGfx/lib/micro.ui.ci:348: referenced as `Histogram`
	cmplGfx/lib/micro.ui.ci:341: referenced as `Histogram`
}
Histogram.lines: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'lines'
.file: 'cmplGfx/lib/micro.ui.ci:333'
.owner: Histogram
.doc: '@public'
.value: false
.usages:
	cmplGfx/lib/micro.ui.ci:425: referenced as `lines`
}
Histogram.color: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'color'
.file: 'cmplGfx/lib/micro.ui.ci:336'
.owner: Histogram
.doc: '@public'
.value: false
.usages:
	cmplGfx/lib/micro.ui.ci:455: referenced as `color`
	cmplGfx/lib/micro.ui.ci:440: referenced as `color`
	cmplGfx/lib/micro.ui.ci:344: referenced as `color`
}
Histogram.data: argb[256] {
.kind: variable(val)
.base: `argb[256]`
.size: 1024
.name: 'data'
.file: 'cmplGfx/lib/micro.ui.ci:338'
.owner: Histogram
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:467: referenced as `data`
	cmplGfx/lib/micro.ui.ci:465: referenced as `data`
	cmplGfx/lib/micro.ui.ci:457: referenced as `data`
	cmplGfx/lib/micro.ui.ci:456: referenced as `data`
	cmplGfx/lib/micro.ui.ci:434: referenced as `data`
	cmplGfx/lib/micro.ui.ci:432: referenced as `data`
	cmplGfx/lib/micro.ui.ci:430: referenced as `data`
	cmplGfx/lib/micro.ui.ci:429: referenced as `data`
	cmplGfx/lib/micro.ui.ci:428: referenced as `data`
	cmplGfx/lib/micro.ui.ci:427: referenced as `data`
	cmplGfx/lib/micro.ui.ci:349: referenced as `data`
	cmplGfx/lib/micro.ui.ci:342: referenced as `data`
}
Histogram.update(this: Histogram, image: Image): void: function {
.kind: static function
.base: `function`
.size: 32
.name: 'update'
.file: 'cmplGfx/lib/micro.ui.ci:341'
.owner: Histogram
.param .result: void (size: 0, cast: variable(void))
.param this: Histogram (size: 4, cast: variable(ref))
.param image: Image (size: 8, cast: variable(val))
.doc: '@public'
.value: {
	data: uint32[*] := pointer(this.data);
	Image.calcRgbHist(image, null, &data);
	this.color := false;
}
.instructions: (32 bytes)
	cmplGfx/lib/micro.ui.ci:342: (6 bytes): data: uint32[*] := pointer(this.data)
	<update>  : dup.x32 sp(3)
	<update+?>: inc.i32(+68)
	cmplGfx/lib/micro.ui.ci:343: (13 bytes): Image.calcRgbHist(image, null, &data);
	<update+?>: dup.x64 sp(2)
	<update+?>: load.ref <?> ;null
	<update+?>: dup.x32 sp(3)
	<update+?>: nfc(117) ;Image.calcRgbHist(image: Image, roi: Rect, lut: uint32[256]): void
	cmplGfx/lib/micro.ui.ci:344: (8 bytes): this.color := false;
	<update+?>: load.z32
	<update+?>: dup.x32 sp(5)
	<update+?>: inc.i32(+65)
	<update+?>: store.i8
	<update+?>: inc.sp(-4)
	<update+?>: ret
.usages:
}
Histogram.onUpdate(this: Histogram, idx: int32, value: int32): bool: function {
.kind: static function
.base: `function`
.size: 193
.name: 'onUpdate'
.file: 'cmplGfx/lib/micro.ui.ci:348'
.owner: Histogram
.param .result: bool (size: 4, cast: variable(bool))
.param this: Histogram (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	this.data[idx] := argb(idx, value, value, value);
	return .result := true;
}
.instructions: (193 bytes)
	cmplGfx/lib/micro.ui.ci:349: (182 bytes): this.data[idx] := argb(idx, value, value, value);
	<onUpdate>  : dup.x32 sp(2)
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: load.c32 255
	<onUpdate+?>: cgt.i32
	<onUpdate+?>: jz +13
	<onUpdate+?>: load.c32 255
	<onUpdate+?>: jmp +19
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: load.z32
	<onUpdate+?>: clt.i32
	<onUpdate+?>: jz +9
	<onUpdate+?>: load.z32
	<onUpdate+?>: jmp +6
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: set.x32 sp(1)
	<onUpdate+?>: b32.shl 0x08
	<onUpdate+?>: dup.x32 sp(2)
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: load.c32 255
	<onUpdate+?>: cgt.i32
	<onUpdate+?>: jz +13
	<onUpdate+?>: load.c32 255
	<onUpdate+?>: jmp +19
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: load.z32
	<onUpdate+?>: clt.i32
	<onUpdate+?>: jz +9
	<onUpdate+?>: load.z32
	<onUpdate+?>: jmp +6
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: set.x32 sp(1)
	<onUpdate+?>: or.b32
	<onUpdate+?>: b32.shl 0x08
	<onUpdate+?>: dup.x32 sp(2)
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: load.c32 255
	<onUpdate+?>: cgt.i32
	<onUpdate+?>: jz +13
	<onUpdate+?>: load.c32 255
	<onUpdate+?>: jmp +19
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: load.z32
	<onUpdate+?>: clt.i32
	<onUpdate+?>: jz +9
	<onUpdate+?>: load.z32
	<onUpdate+?>: jmp +6
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: set.x32 sp(1)
	<onUpdate+?>: or.b32
	<onUpdate+?>: b32.shl 0x08
	<onUpdate+?>: dup.x32 sp(2)
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: load.c32 255
	<onUpdate+?>: cgt.i32
	<onUpdate+?>: jz +13
	<onUpdate+?>: load.c32 255
	<onUpdate+?>: jmp +19
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: load.z32
	<onUpdate+?>: clt.i32
	<onUpdate+?>: jz +9
	<onUpdate+?>: load.z32
	<onUpdate+?>: jmp +6
	<onUpdate+?>: dup.x32 sp(0)
	<onUpdate+?>: set.x32 sp(1)
	<onUpdate+?>: or.b32
	<onUpdate+?>: dup.x32 sp(4)
	<onUpdate+?>: inc.i32(+68)
	<onUpdate+?>: dup.x32 sp(4)
	<onUpdate+?>: mad.u32 4
	<onUpdate+?>: store.i32
	cmplGfx/lib/micro.ui.ci:350: (11 bytes): return .result := true;
	<onUpdate+?>: load.c32 1
	<onUpdate+?>: load.sp(+20)
	<onUpdate+?>: store.i8
	<onUpdate+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:356: referenced as `onUpdate`
}
Histogram.onUpdate(this: Histogram, idx: int32, value: int32): bool: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onUpdate'
.file: 'cmplGfx/lib/micro.ui.ci:348'
.owner: Histogram
.param .result: bool (size: 4, cast: variable(bool))
.param this: Histogram (size: 4, cast: variable(ref))
.param idx: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: onUpdate
.usages:
	cmplGfx/lib/micro.ui.ci:400: referenced as `onUpdate`
}
Histogram.onReset(this: Histogram): bool: function {
.kind: static function
.base: `function`
.size: 69
.name: 'onReset'
.file: 'cmplGfx/lib/micro.ui.ci:353'
.owner: Histogram
.param .result: bool (size: 4, cast: variable(bool))
.param this: Histogram (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is double clicked'
.value: {
	result: bool := false;
	for (i: int32 := 0; i < 256; i := i + 1) {
		result := result | Histogram.onUpdate(this, i, i);
	}
	return .result := result;
}
.instructions: (69 bytes)
	cmplGfx/lib/micro.ui.ci:354: (1 byte): result: bool := false
	<onReset>  : load.z32
	cmplGfx/lib/micro.ui.ci:355: (53 bytes): for (i: int32 := 0; i < 256; i := i + 1)
	<onReset+?>: load.z32
	<onReset+?>: jmp +36
	cmplGfx/lib/micro.ui.ci:356: (28 bytes): result := result | Histogram.onUpdate(this, i, i);
	<onReset+?>: load.sp(+4)
	<onReset+?>: load.is8
	<onReset+?>: load.z32
	<onReset+?>: dup.x32 sp(5)
	<onReset+?>: dup.x32 sp(3)
	<onReset+?>: dup.x32 sp(4)
	<onReset+?>: load.ref <?> ;Histogram.onUpdate(this: Histogram, idx: int32, value: int32): bool
	<onReset+?>: call
	<onReset+?>: inc.sp(-12)
	<onReset+?>: or.b32
	<onReset+?>: load.sp(+8)
	<onReset+?>: store.i8
	cmplGfx/lib/micro.ui.ci:355: (4 bytes): i := i + 1
	<onReset+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:355: (12 bytes): i < 256
	<onReset+?>: dup.x32 sp(0)
	<onReset+?>: load.c32 256
	<onReset+?>: clt.i32
	<onReset+?>: jnz -40
	<onReset+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:358: (15 bytes): return .result := result;
	<onReset+?>: load.sp(+0)
	<onReset+?>: load.is8
	<onReset+?>: load.sp(+16)
	<onReset+?>: store.i8
	<onReset+?>: inc.sp(-4)
	<onReset+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:363: referenced as `onReset`
}
Histogram.onCreate(this: Histogram, parent: View): void: function {
.kind: static function
.base: `function`
.size: 32
.name: 'onCreate'
.file: 'cmplGfx/lib/micro.ui.ci:361'
.owner: Histogram
.param .result: void (size: 0, cast: variable(void))
.param this: Histogram (size: 4, cast: variable(ref))
.param parent: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is created'
.value: {
	View.onCreate(this, parent);
	Histogram.onReset(this);
}
.instructions: (32 bytes)
	cmplGfx/lib/micro.ui.ci:362: (14 bytes): View.onCreate(this, parent);
	<onCreate>  : dup.x32 sp(2)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: load.ref <?> ;View.onCreate(this: View, parent: View): void
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:363: (17 bytes): Histogram.onReset(this);
	<onCreate+?>: load.z32
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: load.ref <?> ;Histogram.onReset(this: Histogram): bool
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: ret
.usages:
}
Histogram.onTouchEvent(this: Histogram, rect: Rect, event: TouchEvent): bool: function {
.kind: static function
.base: `function`
.size: 350
.name: 'onTouchEvent'
.file: 'cmplGfx/lib/micro.ui.ci:366'
.owner: Histogram
.param .result: bool (size: 4, cast: variable(bool))
.param this: Histogram (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: const variable(ref))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a TouchEvent: press, motion or release'
.value: {
	if (event.release || !(event.button)) {
		return .result := View.onTouchEvent(this, rect, event);
	}
	px: int32 := Math.max(0, width(rect) - 256) / 2;
	x0: int32 := event.x - rect.x0 - px;
	x1: int32 := x0 - event.dx;
	y0: int32 := event.y - rect.y0;
	y1: int32 := y0 - event.dy;
	if (x0 > x1) {
		x: int32 := x0;
		x0 := x1;
		x1 := x;
		y: int32 := y0;
		y0 := y1;
		y1 := y;
	}
	y: int32 := y0 << 16;
	dy: int32 := y1 - y0;
	if (x1 != x0) {
		dy := (dy << 16) / (x1 - x0);
	}
	if (x0 < 0) {
		y := y - x0 * dy;
		x0 := 0;
	}
	if (x1 > 256) {
		x1 := 256;
	}
	h: int32 := height(rect);
	for (x: int32 := x0; x < x1; x := x + 1) {
		val: int32 := 255 * (h - (y >> 16)) / h;
		this.onUpdate(this, x, val);
		y := y + dy;
	}
	return .result := true;
}
.instructions: (350 bytes)
	cmplGfx/lib/micro.ui.ci:367: (49 bytes): if (event.release || !(event.button))
	<onTouchEvent>  : dup.x32 sp(1)
	<onTouchEvent+?>: load.is8
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jnz +17
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+8)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: i32.2bool
	<onTouchEvent+?>: not.b32
	<onTouchEvent+?>: jz +27
	cmplGfx/lib/micro.ui.ci:368: (23 bytes): return .result := View.onTouchEvent(this, rect, event);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.ref <?> ;View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:371: (50 bytes): px: int32 := Math.max(0, width(rect) - 256) / 2
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: inc.i32(+8)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: sub.i32
	<onTouchEvent+?>: set.x32 sp(1)
	<onTouchEvent+?>: inc.i32(-256)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: cgt.i32
	<onTouchEvent+?>: jz +10
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: jmp +6
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: mov.x32 sp(2, 0)
	<onTouchEvent+?>: inc.sp(-8)
	<onTouchEvent+?>: load.c32 2
	<onTouchEvent+?>: div.i32
	cmplGfx/lib/micro.ui.ci:372: (14 bytes): x0: int32 := event.x - rect.x0 - px
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: inc.i32(+20)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: sub.i32
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: sub.i32
	cmplGfx/lib/micro.ui.ci:373: (10 bytes): x1: int32 := x0 - event.dx
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: inc.i32(+12)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: sub.i32
	cmplGfx/lib/micro.ui.ci:374: (15 bytes): y0: int32 := event.y - rect.y0
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: inc.i32(+24)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: inc.i32(+4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: sub.i32
	cmplGfx/lib/micro.ui.ci:375: (10 bytes): y1: int32 := y0 - event.dy
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: inc.i32(+16)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: sub.i32
	cmplGfx/lib/micro.ui.ci:377: (29 bytes): if (x0 > x1)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: cgt.i32
	<onTouchEvent+?>: jz +24
	cmplGfx/lib/micro.ui.ci:378: (2 bytes): x: int32 := x0
	<onTouchEvent+?>: dup.x32 sp(3)
	cmplGfx/lib/micro.ui.ci:379: (3 bytes): x0 := x1;
	<onTouchEvent+?>: mov.x32 sp(4, 3)
	cmplGfx/lib/micro.ui.ci:380: (3 bytes): x1 := x;
	<onTouchEvent+?>: mov.x32 sp(3, 0)
	cmplGfx/lib/micro.ui.ci:381: (2 bytes): y: int32 := y0
	<onTouchEvent+?>: dup.x32 sp(2)
	cmplGfx/lib/micro.ui.ci:382: (3 bytes): y0 := y1;
	<onTouchEvent+?>: mov.x32 sp(3, 2)
	cmplGfx/lib/micro.ui.ci:383: (3 bytes): y1 := y;
	<onTouchEvent+?>: mov.x32 sp(2, 0)
	<onTouchEvent+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:385: (4 bytes): y: int32 := y0 << 16
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: b32.shl 0x10
	cmplGfx/lib/micro.ui.ci:386: (5 bytes): dy: int32 := y1 - y0
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: sub.i32
	cmplGfx/lib/micro.ui.ci:387: (17 bytes): if (x1 != x0)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: ceq.i32
	<onTouchEvent+?>: jnz +12
	cmplGfx/lib/micro.ui.ci:388: (8 bytes): dy := (dy << 16) / (x1 - x0);
	<onTouchEvent+?>: b32.shl 0x10
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: sub.i32
	<onTouchEvent+?>: div.i32
	cmplGfx/lib/micro.ui.ci:390: (21 bytes): if (x0 < 0)
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: clt.i32
	<onTouchEvent+?>: jz +17
	cmplGfx/lib/micro.ui.ci:391: (10 bytes): y := y - x0 * dy;
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: mul.i32
	<onTouchEvent+?>: sub.i32
	<onTouchEvent+?>: set.x32 sp(2)
	cmplGfx/lib/micro.ui.ci:392: (3 bytes): x0 := 0;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: set.x32 sp(6)
	cmplGfx/lib/micro.ui.ci:394: (19 bytes): if (x1 > 256)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.c32 256
	<onTouchEvent+?>: cgt.i32
	<onTouchEvent+?>: jz +11
	cmplGfx/lib/micro.ui.ci:395: (7 bytes): x1 := 256;
	<onTouchEvent+?>: load.c32 256
	<onTouchEvent+?>: set.x32 sp(5)
	cmplGfx/lib/micro.ui.ci:397: (19 bytes): h: int32 := height(rect)
	<onTouchEvent+?>: dup.x32 sp(9)
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: inc.i32(+12)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+4)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: sub.i32
	<onTouchEvent+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:398: (73 bytes): for (x: int32 := x0; x < x1; x := x + 1)
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: jmp +58
	cmplGfx/lib/micro.ui.ci:399: (16 bytes): val: int32 := 255 * (h - (y >> 16)) / h
	<onTouchEvent+?>: load.c32 255
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: dup.x32 sp(5)
	<onTouchEvent+?>: b32.sar 0x10
	<onTouchEvent+?>: sub.i32
	<onTouchEvent+?>: mul.i32
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: div.i32
	cmplGfx/lib/micro.ui.ci:400: (23 bytes): this.onUpdate(this, x, val);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(14)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: dup.x32 sp(17)
	<onTouchEvent+?>: inc.i32(+1092)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:401: (7 bytes): y := y + dy;
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: add.i32
	<onTouchEvent+?>: set.x32 sp(5)
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:398: (4 bytes): x := x + 1
	<onTouchEvent+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:398: (9 bytes): x < x1
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: clt.i32
	<onTouchEvent+?>: jnz -59
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:403: (15 bytes): return .result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+52)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-32)
	<onTouchEvent+?>: ret
.usages:
}
Histogram.onMeasure(this: Histogram, rect: Rect): bool: function {
.kind: static function
.base: `function`
.size: 81
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.ci:406'
.owner: Histogram
.param .result: bool (size: 4, cast: variable(bool))
.param this: Histogram (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	if (this.width < 0) {
		width(rect, 256);
	}
	if (this.height < 0) {
		height(rect, 128);
	}
	return .result := View.onMeasure(this, &rect);
}
.instructions: (81 bytes)
	cmplGfx/lib/micro.ui.ci:407: (30 bytes): if (this.width < 0)
	<onMeasure>  : dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+4)
	<onMeasure+?>: load.i32
	<onMeasure+?>: load.z32
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jz +21
	cmplGfx/lib/micro.ui.ci:408: (17 bytes): width(rect, 256);
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.c32 256
	<onMeasure+?>: load.ref <?> ;width(rectangle: Rect, width: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:410: (30 bytes): if (this.height < 0)
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: load.z32
	<onMeasure+?>: clt.i32
	<onMeasure+?>: jz +21
	cmplGfx/lib/micro.ui.ci:411: (17 bytes): height(rect, 128);
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.c32 128
	<onMeasure+?>: load.ref <?> ;height(rectangle: Rect, height: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:413: (21 bytes): return .result := View.onMeasure(this, &rect);
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: load.ref <?> ;View.onMeasure(this: View, rect: Rect): bool
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: load.sp(+16)
	<onMeasure+?>: store.i8
	<onMeasure+?>: ret
.usages:
}
Histogram.onDraw(this: Histogram, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 817
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.ci:416'
.owner: Histogram
.param .result: void (size: 0, cast: variable(void))
.param this: Histogram (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: const variable(val))
.doc: 'Callback function executed when the view needs to be drawn'
.value: {
	px: int32 := (width(rect) - 256) / 2;
	h: int32 := height(rect);
	if (this.lines) {
		y: int32 := rect.y1;
		pb: int32 := bch(this.data[0]) * h / 256;
		pg: int32 := gch(this.data[0]) * h / 256;
		pr: int32 := rch(this.data[0]) * h / 256;
		pl: int32 := ach(this.data[0]) * h / 256;
		for (i: int32 := 1; i < this.data.(length); i := i + 1) {
			x: int32 := rect.x0 + i + px;
			data: argb := this.data[i];
			bv: int32 := bch(data) * h / 256;
			gv: int32 := gch(data) * h / 256;
			rv: int32 := rch(data) * h / 256;
			lv: int32 := ach(data) * h / 256;
			if (this.color) {
				fillRect(offs, x, y - pl, x + 1, y - lv + int32(pl == lv), data.v);
			}
			else {
				fillRect(offs, x, y - pb, x + 1, y - bv + int32(pb == bv), colB);
				fillRect(offs, x, y - pg, x + 1, y - gv + int32(pg == gv), colG);
				fillRect(offs, x, y - pr, x + 1, y - rv + int32(pr == rv), colR);
				fillRect(offs, x, y - pl, x + 1, y - lv + int32(pl == lv), colL);
			}
			pb := bv;
			pg := gv;
			pr := rv;
			pl := lv;
		}
	}
	else if (this.color) {
		for (i: int32 := 0; i < this.data.(length); i := i + 1) {
			data: argb := this.data[i];
			x: int32 := rect.x0 + i + px;
			y1: int32 := rect.y1;
			y0: int32 := y1 - ach(data) * h / 256;
			fillRect(offs, x, y0 - int32(y1 == y0), x + 1, y1, uint32(data));
		}
	}
	else {
		for (i: int32 := 0; i < this.data.(length); i := i + 1) {
			x: int32 := rect.x0 + i + px;
			data: argb := this.data[i];
			bv: int32 := bch(data) * h / 256;
			gv: int32 := gch(data) * h / 256;
			rv: int32 := rch(data) * h / 256;
			lv: int32 := ach(data) * h / 256;
			for (y: int32 := 0; y < h; y := y + 1) {
				b: uint32 := colB * (uint32(y < bv));
				g: uint32 := colG * (uint32(y < gv));
				r: uint32 := colR * (uint32(y < rv));
				l: uint32 := colL * (uint32(y < lv));
				Image.set(offs, x, h - y + rect.y0 - 1, r | g | b | l);
			}
		}
	}
}
.instructions: (817 bytes)
	cmplGfx/lib/micro.ui.ci:423: (27 bytes): px: int32 := (width(rect) - 256) / 2
	<onDraw>  : load.sp(+4)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: inc.i32(+8)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: load.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(1)
	<onDraw+?>: inc.i32(-256)
	<onDraw+?>: load.c32 2
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:424: (21 bytes): h: int32 := height(rect)
	<onDraw+?>: load.sp(+8)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: inc.i32(+12)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: inc.i32(+4)
	<onDraw+?>: load.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:425: (764 bytes): if (this.lines)
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+64)
	<onDraw+?>: load.is8
	<onDraw+?>: jz +434
	cmplGfx/lib/micro.ui.ci:426: (2 bytes): y: int32 := rect.y1
	<onDraw+?>: dup.x32 sp(6)
	cmplGfx/lib/micro.ui.ci:427: (18 bytes): pb: int32 := bch(this.data[0]) * h / 256
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: load.i32
	<onDraw+?>: b32.and 0xff
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:428: (20 bytes): pg: int32 := gch(this.data[0]) * h / 256
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: load.i32
	<onDraw+?>: b32.shr 0x08
	<onDraw+?>: b32.and 0xff
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:429: (20 bytes): pr: int32 := rch(this.data[0]) * h / 256
	<onDraw+?>: dup.x32 sp(12)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: load.i32
	<onDraw+?>: b32.shr 0x10
	<onDraw+?>: b32.and 0xff
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:430: (18 bytes): pl: int32 := ach(this.data[0]) * h / 256
	<onDraw+?>: dup.x32 sp(13)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: load.i32
	<onDraw+?>: b32.shr 0x18
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:432: (344 bytes): for (i: int32 := 1; i < this.data.(length); i := i + 1)
	<onDraw+?>: load.c32 1
	<onDraw+?>: jmp +323
	cmplGfx/lib/micro.ui.ci:433: (8 bytes): x: int32 := rect.x0 + i + px
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: add.i32
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: add.i32
	cmplGfx/lib/micro.ui.ci:434: (13 bytes): data: argb := this.data[i]
	<onDraw+?>: dup.x32 sp(16)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: mad.u32 4
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.ci:435: (13 bytes): bv: int32 := bch(data) * h / 256
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: b32.and 0xff
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:436: (15 bytes): gv: int32 := gch(data) * h / 256
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: b32.shr 0x08
	<onDraw+?>: b32.and 0xff
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:437: (15 bytes): rv: int32 := rch(data) * h / 256
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: b32.shr 0x10
	<onDraw+?>: b32.and 0xff
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:438: (13 bytes): lv: int32 := ach(data) * h / 256
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: b32.shr 0x18
	<onDraw+?>: dup.x32 sp(12)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:440: (222 bytes): if (this.color)
	<onDraw+?>: dup.x32 sp(21)
	<onDraw+?>: inc.i32(+65)
	<onDraw+?>: load.is8
	<onDraw+?>: jz +47
	cmplGfx/lib/micro.ui.ci:441: (39 bytes): fillRect(offs, x, y - pl, x + 1, y - lv + int32(pl == lv), data.v);
	<onDraw+?>: dup.x64 sp(19)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: dup.x32 sp(14)
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+1)
	<onDraw+?>: dup.x32 sp(16)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(13)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: ceq.i32
	<onDraw+?>: add.i32
	<onDraw+?>: load.z32
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-32)
	<onDraw+?>: jmp +172
	cmplGfx/lib/micro.ui.ci:443: (42 bytes): fillRect(offs, x, y - pb, x + 1, y - bv + int32(pb == bv), colB);
	<onDraw+?>: dup.x64 sp(19)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: dup.x32 sp(14)
	<onDraw+?>: dup.x32 sp(14)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+1)
	<onDraw+?>: dup.x32 sp(16)
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(16)
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: ceq.i32
	<onDraw+?>: add.i32
	<onDraw+?>: load.z32
	<onDraw+?>: load.c32 4420038
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-32)
	cmplGfx/lib/micro.ui.ci:444: (42 bytes): fillRect(offs, x, y - pg, x + 1, y - gv + int32(pg == gv), colG);
	<onDraw+?>: dup.x64 sp(19)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: dup.x32 sp(14)
	<onDraw+?>: dup.x32 sp(13)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+1)
	<onDraw+?>: dup.x32 sp(16)
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(15)
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: ceq.i32
	<onDraw+?>: add.i32
	<onDraw+?>: load.z32
	<onDraw+?>: load.c32 7526516
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-32)
	cmplGfx/lib/micro.ui.ci:445: (42 bytes): fillRect(offs, x, y - pr, x + 1, y - rv + int32(pr == rv), colR);
	<onDraw+?>: dup.x64 sp(19)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: dup.x32 sp(14)
	<onDraw+?>: dup.x32 sp(12)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+1)
	<onDraw+?>: dup.x32 sp(16)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(14)
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: ceq.i32
	<onDraw+?>: add.i32
	<onDraw+?>: load.z32
	<onDraw+?>: load.c32 16540005
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-32)
	cmplGfx/lib/micro.ui.ci:446: (42 bytes): fillRect(offs, x, y - pl, x + 1, y - lv + int32(pl == lv), colL);
	<onDraw+?>: dup.x64 sp(19)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: dup.x32 sp(14)
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+1)
	<onDraw+?>: dup.x32 sp(16)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(13)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: ceq.i32
	<onDraw+?>: add.i32
	<onDraw+?>: load.z32
	<onDraw+?>: load.c32 14342874
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-32)
	cmplGfx/lib/micro.ui.ci:449: (3 bytes): pb := bv;
	<onDraw+?>: mov.x32 sp(10, 3)
	cmplGfx/lib/micro.ui.ci:450: (3 bytes): pg := gv;
	<onDraw+?>: mov.x32 sp(9, 2)
	cmplGfx/lib/micro.ui.ci:451: (3 bytes): pr := rv;
	<onDraw+?>: mov.x32 sp(8, 1)
	cmplGfx/lib/micro.ui.ci:452: (3 bytes): pl := lv;
	<onDraw+?>: mov.x32 sp(7, 0)
	<onDraw+?>: inc.sp(-24)
	cmplGfx/lib/micro.ui.ci:432: (4 bytes): i := i + 1
	<onDraw+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:432: (12 bytes): i < this.data.(length)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: load.c32 256
	<onDraw+?>: clt.i32
	<onDraw+?>: jnz -327
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: inc.sp(-20)
	<onDraw+?>: jmp +327
	cmplGfx/lib/micro.ui.ci:455: (323 bytes): if (this.color)
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+65)
	<onDraw+?>: load.is8
	<onDraw+?>: jz +109
	cmplGfx/lib/micro.ui.ci:456: (101 bytes): for (i: int32 := 0; i < this.data.(length); i := i + 1)
	<onDraw+?>: load.z32
	<onDraw+?>: jmp +84
	cmplGfx/lib/micro.ui.ci:457: (13 bytes): data: argb := this.data[i]
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: mad.u32 4
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.ci:458: (8 bytes): x: int32 := rect.x0 + i + px
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: add.i32
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: add.i32
	cmplGfx/lib/micro.ui.ci:459: (2 bytes): y1: int32 := rect.y1
	<onDraw+?>: dup.x32 sp(9)
	cmplGfx/lib/micro.ui.ci:460: (16 bytes): y0: int32 := y1 - ach(data) * h / 256
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: b32.shr 0x18
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	<onDraw+?>: sub.i32
	cmplGfx/lib/micro.ui.ci:461: (33 bytes): fillRect(offs, x, y0 - int32(y1 == y0), x + 1, y1, uint32(data));
	<onDraw+?>: dup.x64 sp(12)
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: ceq.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: inc.i32(+1)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: load.z32
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-32)
	<onDraw+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.ci:456: (4 bytes): i := i + 1
	<onDraw+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:456: (12 bytes): i < this.data.(length)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: load.c32 256
	<onDraw+?>: clt.i32
	<onDraw+?>: jnz -88
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: jmp +211
	cmplGfx/lib/micro.ui.ci:465: (207 bytes): for (i: int32 := 0; i < this.data.(length); i := i + 1)
	<onDraw+?>: load.z32
	<onDraw+?>: jmp +190
	cmplGfx/lib/micro.ui.ci:466: (8 bytes): x: int32 := rect.x0 + i + px
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: add.i32
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: add.i32
	cmplGfx/lib/micro.ui.ci:467: (13 bytes): data: argb := this.data[i]
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: inc.i32(+68)
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: mad.u32 4
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.ci:468: (13 bytes): bv: int32 := bch(data) * h / 256
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: b32.and 0xff
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:469: (15 bytes): gv: int32 := gch(data) * h / 256
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: b32.shr 0x08
	<onDraw+?>: b32.and 0xff
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:470: (15 bytes): rv: int32 := rch(data) * h / 256
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: b32.shr 0x10
	<onDraw+?>: b32.and 0xff
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:471: (13 bytes): lv: int32 := ach(data) * h / 256
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: b32.shr 0x18
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: mul.i32
	<onDraw+?>: load.c32 256
	<onDraw+?>: div.i32
	cmplGfx/lib/micro.ui.ci:472: (101 bytes): for (y: int32 := 0; y < h; y := y + 1)
	<onDraw+?>: load.z32
	<onDraw+?>: jmp +87
	cmplGfx/lib/micro.ui.ci:473: (11 bytes): b: uint32 := colB * (uint32(y < bv))
	<onDraw+?>: load.c32 4420038
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: clt.i32
	<onDraw+?>: mul.i32
	cmplGfx/lib/micro.ui.ci:474: (11 bytes): g: uint32 := colG * (uint32(y < gv))
	<onDraw+?>: load.c32 7526516
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: clt.i32
	<onDraw+?>: mul.i32
	cmplGfx/lib/micro.ui.ci:475: (11 bytes): r: uint32 := colR * (uint32(y < rv))
	<onDraw+?>: load.c32 16540005
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: clt.i32
	<onDraw+?>: mul.i32
	cmplGfx/lib/micro.ui.ci:476: (11 bytes): l: uint32 := colL * (uint32(y < lv))
	<onDraw+?>: load.c32 14342874
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: clt.i32
	<onDraw+?>: mul.i32
	cmplGfx/lib/micro.ui.ci:477: (31 bytes): Image.set(offs, x, h - y + rect.y0 - 1, r | g | b | l);
	<onDraw+?>: dup.x64 sp(19)
	<onDraw+?>: dup.x32 sp(12)
	<onDraw+?>: dup.x32 sp(15)
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: sub.i32
	<onDraw+?>: dup.x32 sp(20)
	<onDraw+?>: add.i32
	<onDraw+?>: inc.i32(-1)
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: or.b32
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: or.b32
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: or.b32
	<onDraw+?>: nfc(105) ;Image.set(image: Image, x: int32, y: int32, color: uint32): void
	<onDraw+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.ci:472: (4 bytes): y := y + 1
	<onDraw+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:472: (9 bytes): y < h
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: clt.i32
	<onDraw+?>: jnz -88
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: inc.sp(-24)
	cmplGfx/lib/micro.ui.ci:465: (4 bytes): i := i + 1
	<onDraw+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:465: (12 bytes): i < this.data.(length)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: load.c32 256
	<onDraw+?>: clt.i32
	<onDraw+?>: jnz -194
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: inc.sp(-8)
	<onDraw+?>: ret
.usages:
}
DebugView: View {
.kind: static const typename(ref)
.base: `View`
.size: 672
.name: 'DebugView'
.file: 'cmplGfx/lib/micro.ui.ci:485'
.field text: char[64] (size: 64, cast: variable(val))
.field started: int64 (size: 8, cast: variable(i64))
.field maxDuration: int64 (size: 8, cast: variable(i64))
.field durations: int64[64] (size: 512, cast: variable(val))
.field measures: int64 (size: 8, cast: variable(i64))
.field draws: int64 (size: 8, cast: variable(i64))
.field startTimer: function (size: 126, cast: static function)
.field update: function (size: 398, cast: static function)
.field onClick: function (size: 21, cast: static function)
.field onReset: function (size: 108, cast: static function)
.field onCreate: function (size: 32, cast: static function)
.field onMeasure: function (size: 101, cast: static function)
.field onDraw: function (size: 363, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'debug view to count draws'
.usages:
	cmplGfx/lib/micro.ui.ci:567: referenced as `DebugView`
	cmplGfx/lib/micro.ui.ci:557: referenced as `DebugView`
	cmplGfx/lib/micro.ui.ci:552: referenced as `DebugView`
	cmplGfx/lib/micro.ui.ci:537: referenced as `DebugView`
	cmplGfx/lib/micro.ui.ci:533: referenced as `DebugView`
	cmplGfx/lib/micro.ui.ci:512: referenced as `DebugView`
	cmplGfx/lib/micro.ui.ci:498: referenced as `DebugView`
}
DebugView.text: char[64] {
.kind: variable(val)
.base: `char[64]`
.size: 64
.name: 'text'
.file: 'cmplGfx/lib/micro.ui.ci:486'
.owner: DebugView
.usages:
	cmplGfx/lib/micro.ui.ci:594: referenced as `text`
	cmplGfx/lib/micro.ui.ci:593: referenced as `text`
	cmplGfx/lib/micro.ui.ci:563: referenced as `text`
	cmplGfx/lib/micro.ui.ci:529: referenced as `text`
	cmplGfx/lib/micro.ui.ci:528: referenced as `text`
	cmplGfx/lib/micro.ui.ci:527: referenced as `text`
	cmplGfx/lib/micro.ui.ci:523: referenced as `text`
	cmplGfx/lib/micro.ui.ci:522: referenced as `text`
	cmplGfx/lib/micro.ui.ci:521: referenced as `text`
	cmplGfx/lib/micro.ui.ci:517: referenced as `text`
	cmplGfx/lib/micro.ui.ci:516: referenced as `text`
	cmplGfx/lib/micro.ui.ci:515: referenced as `text`
}
DebugView.started: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'started'
.file: 'cmplGfx/lib/micro.ui.ci:488'
.owner: DebugView
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:574: referenced as `started`
	cmplGfx/lib/micro.ui.ci:569: referenced as `started`
	cmplGfx/lib/micro.ui.ci:568: referenced as `started`
	cmplGfx/lib/micro.ui.ci:548: referenced as `started`
	cmplGfx/lib/micro.ui.ci:499: referenced as `started`
}
DebugView.maxDuration: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'maxDuration'
.file: 'cmplGfx/lib/micro.ui.ci:489'
.owner: DebugView
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:580: referenced as `maxDuration`
	cmplGfx/lib/micro.ui.ci:578: referenced as `maxDuration`
	cmplGfx/lib/micro.ui.ci:572: referenced as `maxDuration`
	cmplGfx/lib/micro.ui.ci:571: referenced as `maxDuration`
	cmplGfx/lib/micro.ui.ci:547: referenced as `maxDuration`
	cmplGfx/lib/micro.ui.ci:509: referenced as `maxDuration`
	cmplGfx/lib/micro.ui.ci:506: referenced as `maxDuration`
	cmplGfx/lib/micro.ui.ci:505: referenced as `maxDuration`
	cmplGfx/lib/micro.ui.ci:500: referenced as `maxDuration`
}
DebugView.durations: int64[64] {
.kind: variable(val)
.base: `int64[64]`
.size: 512
.name: 'durations'
.file: 'cmplGfx/lib/micro.ui.ci:490'
.owner: DebugView
.usages:
	cmplGfx/lib/micro.ui.ci:584: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:583: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:582: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:581: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:570: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:545: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:544: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:529: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:526: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:509: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:504: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:503: referenced as `durations`
	cmplGfx/lib/micro.ui.ci:502: referenced as `durations`
}
DebugView.measures: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'measures'
.file: 'cmplGfx/lib/micro.ui.ci:493'
.owner: DebugView
.doc: 'Number of measures, initialize to `-1` to ignore'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:559: referenced as `measures`
	cmplGfx/lib/micro.ui.ci:558: referenced as `measures`
	cmplGfx/lib/micro.ui.ci:539: referenced as `measures`
	cmplGfx/lib/micro.ui.ci:538: referenced as `measures`
	cmplGfx/lib/micro.ui.ci:517: referenced as `measures`
	cmplGfx/lib/micro.ui.ci:514: referenced as `measures`
}
DebugView.draws: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'draws'
.file: 'cmplGfx/lib/micro.ui.ci:495'
.owner: DebugView
.doc: 'Number of draw calls, initialize to `-1` to ignore'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:590: referenced as `draws`
	cmplGfx/lib/micro.ui.ci:589: referenced as `draws`
	cmplGfx/lib/micro.ui.ci:542: referenced as `draws`
	cmplGfx/lib/micro.ui.ci:541: referenced as `draws`
	cmplGfx/lib/micro.ui.ci:523: referenced as `draws`
	cmplGfx/lib/micro.ui.ci:520: referenced as `draws`
}
DebugView.startTimer(this: DebugView): void: function {
.kind: static function
.base: `function`
.size: 126
.name: 'startTimer'
.file: 'cmplGfx/lib/micro.ui.ci:498'
.owner: DebugView
.param .result: void (size: 0, cast: variable(void))
.param this: DebugView (size: 4, cast: variable(ref))
.doc: 'Start time measurement until this view is drawn on screen'
.value: {
	this.started := System.millis();
	this.maxDuration := (0);
	for (i: int32 := this.durations.(length) - 1; i >= 1; i := i - 1) {
		duration: int64 := this.durations[i - 1];
		this.durations[i] := duration;
		if (this.maxDuration < duration) {
			this.maxDuration := duration;
		}
	}
	this.durations[0] := this.maxDuration;
}
.instructions: (126 bytes)
	cmplGfx/lib/micro.ui.ci:499: (11 bytes): this.started := System.millis();
	<startTimer>  : nfc(20) ;System.millis(): int64
	<startTimer+?>: dup.x32 sp(3)
	<startTimer+?>: inc.i32(+128)
	<startTimer+?>: store.i64
	cmplGfx/lib/micro.ui.ci:500: (8 bytes): this.maxDuration := (0);
	<startTimer+?>: load.z64
	<startTimer+?>: dup.x32 sp(3)
	<startTimer+?>: inc.i32(+136)
	<startTimer+?>: store.i64
	cmplGfx/lib/micro.ui.ci:502: (92 bytes): for (i: int32 := this.durations.(length) - 1; i >= 1; i := i - 1)
	<startTimer+?>: load.c32 64
	<startTimer+?>: inc.i32(-1)
	<startTimer+?>: jmp +67
	cmplGfx/lib/micro.ui.ci:503: (17 bytes): duration: int64 := this.durations[i - 1]
	<startTimer+?>: dup.x32 sp(2)
	<startTimer+?>: inc.i32(+144)
	<startTimer+?>: dup.x32 sp(1)
	<startTimer+?>: inc.i32(-1)
	<startTimer+?>: mad.u32 8
	<startTimer+?>: load.i64
	cmplGfx/lib/micro.ui.ci:504: (15 bytes): this.durations[i] := duration;
	<startTimer+?>: dup.x64 sp(0)
	<startTimer+?>: dup.x32 sp(6)
	<startTimer+?>: inc.i32(+144)
	<startTimer+?>: dup.x32 sp(5)
	<startTimer+?>: mad.u32 8
	<startTimer+?>: store.i64
	cmplGfx/lib/micro.ui.ci:505: (23 bytes): if (this.maxDuration < duration)
	<startTimer+?>: dup.x32 sp(4)
	<startTimer+?>: inc.i32(+136)
	<startTimer+?>: load.i64
	<startTimer+?>: dup.x64 sp(2)
	<startTimer+?>: clt.i64
	<startTimer+?>: jz +13
	cmplGfx/lib/micro.ui.ci:506: (9 bytes): this.maxDuration := duration;
	<startTimer+?>: dup.x64 sp(0)
	<startTimer+?>: dup.x32 sp(6)
	<startTimer+?>: inc.i32(+136)
	<startTimer+?>: store.i64
	<startTimer+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:502: (4 bytes): i := i - 1
	<startTimer+?>: inc.i32(-1)
	cmplGfx/lib/micro.ui.ci:502: (12 bytes): i >= 1
	<startTimer+?>: dup.x32 sp(0)
	<startTimer+?>: load.c32 1
	<startTimer+?>: clt.i32
	<startTimer+?>: jz -71
	<startTimer+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:509: (14 bytes): this.durations[0] := this.maxDuration;
	<startTimer+?>: dup.x32 sp(1)
	<startTimer+?>: inc.i32(+136)
	<startTimer+?>: load.i64
	<startTimer+?>: dup.x32 sp(3)
	<startTimer+?>: inc.i32(+144)
	<startTimer+?>: store.i64
	<startTimer+?>: ret
.usages:
}
DebugView.update(this: DebugView): void: function {
.kind: static function
.base: `function`
.size: 398
.name: 'update'
.file: 'cmplGfx/lib/micro.ui.ci:512'
.owner: DebugView
.param .result: void (size: 0, cast: variable(void))
.param this: DebugView (size: 4, cast: variable(ref))
.value: {
	pos: int32 := 0;
	if (this.measures > (0)) {
		pos := append(this.text, pos, pos > 0 ? ", " : "");
		pos := append(this.text, pos, "measures: ");
		pos := append(this.text, pos, this.measures);
	}
	if (this.draws > (0)) {
		pos := append(this.text, pos, pos > 0 ? ", " : "");
		pos := append(this.text, pos, "draws: ");
		pos := append(this.text, pos, this.draws);
	}
	if (this.durations[0] > (0) || pos == 0) {
		pos := append(this.text, pos, pos > 0 ? ", " : "");
		pos := append(this.text, pos, "time: ");
		pos := append(this.text, pos, this.durations[0]);
	}
}
.instructions: (398 bytes)
	cmplGfx/lib/micro.ui.ci:513: (1 byte): pos: int32 := 0
	<update>  : load.z32
	cmplGfx/lib/micro.ui.ci:514: (126 bytes): if (this.measures > (0))
	<update+?>: dup.x32 sp(2)
	<update+?>: inc.i32(+656)
	<update+?>: load.i64
	<update+?>: load.z64
	<update+?>: cgt.i64
	<update+?>: jz +117
	cmplGfx/lib/micro.ui.ci:515: (48 bytes): pos := append(this.text, pos, pos > 0 ? ", " : "");
	<update+?>: load.z32
	<update+?>: load.c32 64
	<update+?>: dup.x32 sp(4)
	<update+?>: inc.i32(+64)
	<update+?>: dup.x32 sp(3)
	<update+?>: dup.x32 sp(4)
	<update+?>: load.z32
	<update+?>: cgt.i32
	<update+?>: jz +13
	<update+?>: load.ref <?> ;", "
	<update+?>: jmp +9
	<update+?>: load.ref <?>
	<update+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<update+?>: call
	<update+?>: inc.sp(-16)
	<update+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:516: (31 bytes): pos := append(this.text, pos, "measures: ");
	<update+?>: load.z32
	<update+?>: load.c32 64
	<update+?>: dup.x32 sp(4)
	<update+?>: inc.i32(+64)
	<update+?>: dup.x32 sp(3)
	<update+?>: load.ref <?> ;"measures: "
	<update+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<update+?>: call
	<update+?>: inc.sp(-16)
	<update+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:517: (34 bytes): pos := append(this.text, pos, this.measures);
	<update+?>: load.z32
	<update+?>: load.c32 64
	<update+?>: dup.x32 sp(4)
	<update+?>: inc.i32(+64)
	<update+?>: dup.x32 sp(3)
	<update+?>: dup.x32 sp(6)
	<update+?>: inc.i32(+656)
	<update+?>: load.i64
	<update+?>: i64.2i32
	<update+?>: load.ref <?> ;append(output: char[], pos: int32, value: int32): int32
	<update+?>: call
	<update+?>: inc.sp(-16)
	<update+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:520: (126 bytes): if (this.draws > (0))
	<update+?>: dup.x32 sp(2)
	<update+?>: inc.i32(+664)
	<update+?>: load.i64
	<update+?>: load.z64
	<update+?>: cgt.i64
	<update+?>: jz +117
	cmplGfx/lib/micro.ui.ci:521: (48 bytes): pos := append(this.text, pos, pos > 0 ? ", " : "");
	<update+?>: load.z32
	<update+?>: load.c32 64
	<update+?>: dup.x32 sp(4)
	<update+?>: inc.i32(+64)
	<update+?>: dup.x32 sp(3)
	<update+?>: dup.x32 sp(4)
	<update+?>: load.z32
	<update+?>: cgt.i32
	<update+?>: jz +13
	<update+?>: load.ref <?> ;", "
	<update+?>: jmp +9
	<update+?>: load.ref <?>
	<update+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<update+?>: call
	<update+?>: inc.sp(-16)
	<update+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:522: (31 bytes): pos := append(this.text, pos, "draws: ");
	<update+?>: load.z32
	<update+?>: load.c32 64
	<update+?>: dup.x32 sp(4)
	<update+?>: inc.i32(+64)
	<update+?>: dup.x32 sp(3)
	<update+?>: load.ref <?> ;"draws: "
	<update+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<update+?>: call
	<update+?>: inc.sp(-16)
	<update+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:523: (34 bytes): pos := append(this.text, pos, this.draws);
	<update+?>: load.z32
	<update+?>: load.c32 64
	<update+?>: dup.x32 sp(4)
	<update+?>: inc.i32(+64)
	<update+?>: dup.x32 sp(3)
	<update+?>: dup.x32 sp(6)
	<update+?>: inc.i32(+664)
	<update+?>: load.i64
	<update+?>: i64.2i32
	<update+?>: load.ref <?> ;append(output: char[], pos: int32, value: int32): int32
	<update+?>: call
	<update+?>: inc.sp(-16)
	<update+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:526: (140 bytes): if (this.durations[0] > (0) || pos == 0)
	<update+?>: dup.x32 sp(2)
	<update+?>: inc.i32(+144)
	<update+?>: load.i64
	<update+?>: load.z64
	<update+?>: cgt.i64
	<update+?>: dup.x32 sp(0)
	<update+?>: jnz +12
	<update+?>: inc.sp(-4)
	<update+?>: dup.x32 sp(0)
	<update+?>: load.z32
	<update+?>: ceq.i32
	<update+?>: jz +117
	cmplGfx/lib/micro.ui.ci:527: (48 bytes): pos := append(this.text, pos, pos > 0 ? ", " : "");
	<update+?>: load.z32
	<update+?>: load.c32 64
	<update+?>: dup.x32 sp(4)
	<update+?>: inc.i32(+64)
	<update+?>: dup.x32 sp(3)
	<update+?>: dup.x32 sp(4)
	<update+?>: load.z32
	<update+?>: cgt.i32
	<update+?>: jz +13
	<update+?>: load.ref <?> ;", "
	<update+?>: jmp +9
	<update+?>: load.ref <?>
	<update+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<update+?>: call
	<update+?>: inc.sp(-16)
	<update+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:528: (31 bytes): pos := append(this.text, pos, "time: ");
	<update+?>: load.z32
	<update+?>: load.c32 64
	<update+?>: dup.x32 sp(4)
	<update+?>: inc.i32(+64)
	<update+?>: dup.x32 sp(3)
	<update+?>: load.ref <?> ;"time: "
	<update+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<update+?>: call
	<update+?>: inc.sp(-16)
	<update+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:529: (34 bytes): pos := append(this.text, pos, this.durations[0]);
	<update+?>: load.z32
	<update+?>: load.c32 64
	<update+?>: dup.x32 sp(4)
	<update+?>: inc.i32(+64)
	<update+?>: dup.x32 sp(3)
	<update+?>: dup.x32 sp(6)
	<update+?>: inc.i32(+144)
	<update+?>: load.i64
	<update+?>: i64.2i32
	<update+?>: load.ref <?> ;append(output: char[], pos: int32, value: int32): int32
	<update+?>: call
	<update+?>: inc.sp(-16)
	<update+?>: set.x32 sp(1)
	<update+?>: inc.sp(-4)
	<update+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:592: referenced as `update`
	cmplGfx/lib/micro.ui.ci:561: referenced as `update`
}
DebugView.onClick(this: DebugView): bool: function {
.kind: static function
.base: `function`
.size: 21
.name: 'onClick'
.file: 'cmplGfx/lib/micro.ui.ci:533'
.owner: DebugView
.param .result: bool (size: 4, cast: variable(bool))
.param this: DebugView (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is clicked'
.value: {
	return .result := this.onReset(this);
}
.instructions: (21 bytes)
	cmplGfx/lib/micro.ui.ci:534: (21 bytes): return .result := this.onReset(this);
	<onClick>  : load.z32
	<onClick+?>: dup.x32 sp(2)
	<onClick+?>: dup.x32 sp(3)
	<onClick+?>: inc.i32(+36)
	<onClick+?>: load.i32
	<onClick+?>: call
	<onClick+?>: inc.sp(-4)
	<onClick+?>: load.sp(+12)
	<onClick+?>: store.i8
	<onClick+?>: ret
.usages:
}
DebugView.onReset(this: DebugView): bool: function {
.kind: static function
.base: `function`
.size: 108
.name: 'onReset'
.file: 'cmplGfx/lib/micro.ui.ci:537'
.owner: DebugView
.param .result: bool (size: 4, cast: variable(bool))
.param this: DebugView (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is double clicked'
.value: {
	if (this.measures > (0)) {
		this.measures := (0);
	}
	if (this.draws > (0)) {
		this.draws := (0);
	}
	for (i: int32 := 0; i < this.durations.(length); i := i + 1) {
		this.durations[i] := (0);
	}
	this.maxDuration := (0);
	this.started := (0);
	return .result := true;
}
.instructions: (108 bytes)
	cmplGfx/lib/micro.ui.ci:538: (21 bytes): if (this.measures > (0))
	<onReset>  : dup.x32 sp(1)
	<onReset+?>: inc.i32(+656)
	<onReset+?>: load.i64
	<onReset+?>: load.z64
	<onReset+?>: cgt.i64
	<onReset+?>: jz +12
	cmplGfx/lib/micro.ui.ci:539: (8 bytes): this.measures := (0);
	<onReset+?>: load.z64
	<onReset+?>: dup.x32 sp(3)
	<onReset+?>: inc.i32(+656)
	<onReset+?>: store.i64
	cmplGfx/lib/micro.ui.ci:541: (21 bytes): if (this.draws > (0))
	<onReset+?>: dup.x32 sp(1)
	<onReset+?>: inc.i32(+664)
	<onReset+?>: load.i64
	<onReset+?>: load.z64
	<onReset+?>: cgt.i64
	<onReset+?>: jz +12
	cmplGfx/lib/micro.ui.ci:542: (8 bytes): this.draws := (0);
	<onReset+?>: load.z64
	<onReset+?>: dup.x32 sp(3)
	<onReset+?>: inc.i32(+664)
	<onReset+?>: store.i64
	cmplGfx/lib/micro.ui.ci:544: (39 bytes): for (i: int32 := 0; i < this.durations.(length); i := i + 1)
	<onReset+?>: load.z32
	<onReset+?>: jmp +22
	cmplGfx/lib/micro.ui.ci:545: (14 bytes): this.durations[i] := (0);
	<onReset+?>: load.z64
	<onReset+?>: dup.x32 sp(4)
	<onReset+?>: inc.i32(+144)
	<onReset+?>: dup.x32 sp(3)
	<onReset+?>: mad.u32 8
	<onReset+?>: store.i64
	cmplGfx/lib/micro.ui.ci:544: (4 bytes): i := i + 1
	<onReset+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:544: (12 bytes): i < this.durations.(length)
	<onReset+?>: dup.x32 sp(0)
	<onReset+?>: load.c32 64
	<onReset+?>: clt.i32
	<onReset+?>: jnz -26
	<onReset+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:547: (8 bytes): this.maxDuration := (0);
	<onReset+?>: load.z64
	<onReset+?>: dup.x32 sp(3)
	<onReset+?>: inc.i32(+136)
	<onReset+?>: store.i64
	cmplGfx/lib/micro.ui.ci:548: (8 bytes): this.started := (0);
	<onReset+?>: load.z64
	<onReset+?>: dup.x32 sp(3)
	<onReset+?>: inc.i32(+128)
	<onReset+?>: store.i64
	cmplGfx/lib/micro.ui.ci:549: (11 bytes): return .result := true;
	<onReset+?>: load.c32 1
	<onReset+?>: load.sp(+12)
	<onReset+?>: store.i8
	<onReset+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:554: referenced as `onReset`
}
DebugView.onCreate(this: DebugView, parent: View): void: function {
.kind: static function
.base: `function`
.size: 32
.name: 'onCreate'
.file: 'cmplGfx/lib/micro.ui.ci:552'
.owner: DebugView
.param .result: void (size: 0, cast: variable(void))
.param this: DebugView (size: 4, cast: variable(ref))
.param parent: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is created'
.value: {
	View.onCreate(this, parent);
	onReset(this);
}
.instructions: (32 bytes)
	cmplGfx/lib/micro.ui.ci:553: (14 bytes): View.onCreate(this, parent);
	<onCreate>  : dup.x32 sp(2)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: load.ref <?> ;View.onCreate(this: View, parent: View): void
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:554: (17 bytes): onReset(this);
	<onCreate+?>: load.z32
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: load.ref <?> ;DebugView.onReset(this: DebugView): bool
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: ret
.usages:
}
DebugView.onMeasure(this: DebugView, rect: Rect): bool: function {
.kind: static function
.base: `function`
.size: 101
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.ci:557'
.owner: DebugView
.param .result: bool (size: 4, cast: variable(bool))
.param this: DebugView (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	if (this.measures >= (0)) {
		this.measures := this.measures + (1);
	}
	update(this);
	style: Style := this.style;
	Style.measure(style, &rect, this.text);
	return .result := View.onMeasure(this, &rect);
}
.instructions: (101 bytes)
	cmplGfx/lib/micro.ui.ci:558: (37 bytes): if (this.measures >= (0))
	<onMeasure>  : dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+656)
	<onMeasure+?>: load.i64
	<onMeasure+?>: load.z64
	<onMeasure+?>: clt.i64
	<onMeasure+?>: jnz +28
	cmplGfx/lib/micro.ui.ci:559: (24 bytes): this.measures := this.measures + (1);
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+656)
	<onMeasure+?>: load.i64
	<onMeasure+?>: load.c64 1
	<onMeasure+?>: add.i64
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: inc.i32(+656)
	<onMeasure+?>: store.i64
	cmplGfx/lib/micro.ui.ci:561: (12 bytes): update(this);
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: load.ref <?> ;DebugView.update(this: DebugView): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:562: (7 bytes): style: Style := this.style
	<onMeasure+?>: dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+20)
	<onMeasure+?>: load.i32
	cmplGfx/lib/micro.ui.ci:563: (20 bytes): Style.measure(style, &rect, this.text);
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(5)
	<onMeasure+?>: inc.i32(+64)
	<onMeasure+?>: load.ref <?> ;Style.measure(this: Style, rect: Rect, text: char[*]): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.ci:564: (25 bytes): return .result := View.onMeasure(this, &rect);
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: dup.x32 sp(4)
	<onMeasure+?>: load.ref <?> ;View.onMeasure(this: View, rect: Rect): bool
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: load.sp(+20)
	<onMeasure+?>: store.i8
	<onMeasure+?>: inc.sp(-4)
	<onMeasure+?>: ret
.usages:
}
DebugView.onDraw(this: DebugView, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 363
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.ci:567'
.owner: DebugView
.param .result: void (size: 0, cast: variable(void))
.param this: DebugView (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.doc: 'Callback function executed when the view needs to be drawn'
.value: {
	if (this.started > (0)) {
		duration: int64 := System.millis() - this.started;
		this.durations[0] := duration;
		if (this.maxDuration < duration) {
			this.maxDuration := duration;
		}
		this.started := (0);
	}
	style: Style := this.style;
	if (this.maxDuration > (0)) {
		y0: int32 := rect.y1;
		ys: float64 := (height(rect)) / float64(this.maxDuration);
		xs: float64 := (width(rect)) / float64(this.durations.(length));
		for (i: int32 := 0; i < this.durations.(length); i := i + 1) {
			y1: int32 := (y0) - ys * (this.durations[i]);
			x1: int32 := (rect.x0) + xs * ((this.durations.(length) - i));
			fillRect(offs, (x1) - xs, y0, x1, y1, style.focusedColor);
		}
	}
	if (this.draws >= (0)) {
		this.draws := this.draws + (1);
	}
	update(this);
	Style.align(style, rect, &rect, this.text);
	Image.drawText(offs, rect, style.font, this.text, style.textColor);
}
.instructions: (363 bytes)
	cmplGfx/lib/micro.ui.ci:568: (69 bytes): if (this.started > (0))
	<onDraw>  : dup.x32 sp(7)
	<onDraw+?>: inc.i32(+128)
	<onDraw+?>: load.i64
	<onDraw+?>: load.z64
	<onDraw+?>: cgt.i64
	<onDraw+?>: jz +60
	cmplGfx/lib/micro.ui.ci:569: (12 bytes): duration: int64 := System.millis() - this.started
	<onDraw+?>: nfc(20) ;System.millis(): int64
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+128)
	<onDraw+?>: load.i64
	<onDraw+?>: sub.i64
	cmplGfx/lib/micro.ui.ci:570: (9 bytes): this.durations[0] := duration;
	<onDraw+?>: dup.x64 sp(0)
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: inc.i32(+144)
	<onDraw+?>: store.i64
	cmplGfx/lib/micro.ui.ci:571: (23 bytes): if (this.maxDuration < duration)
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: inc.i32(+136)
	<onDraw+?>: load.i64
	<onDraw+?>: dup.x64 sp(2)
	<onDraw+?>: clt.i64
	<onDraw+?>: jz +13
	cmplGfx/lib/micro.ui.ci:572: (9 bytes): this.maxDuration := duration;
	<onDraw+?>: dup.x64 sp(0)
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: inc.i32(+136)
	<onDraw+?>: store.i64
	cmplGfx/lib/micro.ui.ci:574: (8 bytes): this.started := (0);
	<onDraw+?>: load.z64
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: inc.i32(+128)
	<onDraw+?>: store.i64
	<onDraw+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:577: (7 bytes): style: Style := this.style
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: inc.i32(+20)
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.ci:578: (179 bytes): if (this.maxDuration > (0))
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: inc.i32(+136)
	<onDraw+?>: load.i64
	<onDraw+?>: load.z64
	<onDraw+?>: cgt.i64
	<onDraw+?>: jz +170
	cmplGfx/lib/micro.ui.ci:579: (2 bytes): y0: int32 := rect.y1
	<onDraw+?>: dup.x32 sp(5)
	cmplGfx/lib/micro.ui.ci:580: (31 bytes): ys: float64 := (height(rect)) / float64(this.maxDuration)
	<onDraw+?>: load.sp(+12)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: inc.i32(+12)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: inc.i32(+4)
	<onDraw+?>: load.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(1)
	<onDraw+?>: i32.2f64
	<onDraw+?>: dup.x32 sp(11)
	<onDraw+?>: inc.i32(+136)
	<onDraw+?>: load.i64
	<onDraw+?>: i64.2f64
	<onDraw+?>: div.f64
	cmplGfx/lib/micro.ui.ci:581: (28 bytes): xs: float64 := (width(rect)) / float64(this.durations.(length))
	<onDraw+?>: load.sp(+20)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: inc.i32(+8)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x32 sp(1)
	<onDraw+?>: load.i32
	<onDraw+?>: sub.i32
	<onDraw+?>: set.x32 sp(1)
	<onDraw+?>: i32.2f64
	<onDraw+?>: load.f64 64.000000
	<onDraw+?>: div.f64
	cmplGfx/lib/micro.ui.ci:582: (101 bytes): for (i: int32 := 0; i < this.durations.(length); i := i + 1)
	<onDraw+?>: load.z32
	<onDraw+?>: jmp +84
	cmplGfx/lib/micro.ui.ci:583: (22 bytes): y1: int32 := (y0) - ys * (this.durations[i])
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: i32.2f64
	<onDraw+?>: dup.x64 sp(5)
	<onDraw+?>: dup.x32 sp(18)
	<onDraw+?>: inc.i32(+144)
	<onDraw+?>: dup.x32 sp(5)
	<onDraw+?>: mad.u32 8
	<onDraw+?>: load.i64
	<onDraw+?>: i64.2f64
	<onDraw+?>: mul.f64
	<onDraw+?>: sub.f64
	<onDraw+?>: f64.2i32
	cmplGfx/lib/micro.ui.ci:584: (17 bytes): x1: int32 := (rect.x0) + xs * ((this.durations.(length) - i))
	<onDraw+?>: dup.x32 sp(9)
	<onDraw+?>: i32.2f64
	<onDraw+?>: dup.x64 sp(4)
	<onDraw+?>: load.c32 64
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: sub.i32
	<onDraw+?>: i32.2f64
	<onDraw+?>: mul.f64
	<onDraw+?>: add.f64
	<onDraw+?>: f64.2i32
	cmplGfx/lib/micro.ui.ci:585: (33 bytes): fillRect(offs, (x1) - xs, y0, x1, y1, style.focusedColor);
	<onDraw+?>: dup.x64 sp(14)
	<onDraw+?>: dup.x32 sp(2)
	<onDraw+?>: i32.2f64
	<onDraw+?>: dup.x64 sp(7)
	<onDraw+?>: sub.f64
	<onDraw+?>: f64.2i32
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: load.z32
	<onDraw+?>: dup.x32 sp(15)
	<onDraw+?>: inc.i32(+40)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-32)
	<onDraw+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:582: (4 bytes): i := i + 1
	<onDraw+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:582: (12 bytes): i < this.durations.(length)
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: load.c32 64
	<onDraw+?>: clt.i32
	<onDraw+?>: jnz -88
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: inc.sp(-20)
	cmplGfx/lib/micro.ui.ci:589: (37 bytes): if (this.draws >= (0))
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: inc.i32(+664)
	<onDraw+?>: load.i64
	<onDraw+?>: load.z64
	<onDraw+?>: clt.i64
	<onDraw+?>: jnz +28
	cmplGfx/lib/micro.ui.ci:590: (24 bytes): this.draws := this.draws + (1);
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: inc.i32(+664)
	<onDraw+?>: load.i64
	<onDraw+?>: load.c64 1
	<onDraw+?>: add.i64
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: inc.i32(+664)
	<onDraw+?>: store.i64
	cmplGfx/lib/micro.ui.ci:592: (12 bytes): update(this);
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: load.ref <?> ;DebugView.update(this: DebugView): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:593: (24 bytes): Style.align(style, rect, &rect, this.text);
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: dup.x128 sp(3)
	<onDraw+?>: load.sp(+28)
	<onDraw+?>: dup.x32 sp(14)
	<onDraw+?>: inc.i32(+64)
	<onDraw+?>: load.ref <?> ;Style.align(this: Style, parent: Rect, rect: Rect, value: char[*]): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-28)
	cmplGfx/lib/micro.ui.ci:594: (30 bytes): Image.drawText(offs, rect, style.font, this.text, style.textColor);
	<onDraw+?>: dup.x64 sp(6)
	<onDraw+?>: load.sp(+16)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: inc.i32(+8)
	<onDraw+?>: load.i64
	<onDraw+?>: dup.x32 sp(13)
	<onDraw+?>: inc.i32(+64)
	<onDraw+?>: dup.x32 sp(6)
	<onDraw+?>: inc.i32(+48)
	<onDraw+?>: load.i32
	<onDraw+?>: nfc(108) ;Image.drawText(image: Image, roi: Rect, font: Image, text: char[*], color: int32): void
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: ret
.usages:
}
Panel: Layout {
.kind: static const typename(ref)
.base: `Layout`
.size: 120
.name: 'Panel'
.file: 'cmplGfx/lib/micro.ui.ci:599'
.field visible: bool (size: 1, cast: variable(bool))
.field visible: function (size: 64, cast: static function)
.field onMeasure: function (size: 53, cast: static function)
.field Item: typename (size: 24, cast: static const typename(val))
.field separator: View (size: 4, cast: variable(ref))
.field items: Layout.Item[*] (size: 4, cast: variable(ref))
.field itemCount: int32 (size: 4, cast: variable(i32))
.field itemCapacity: int32 (size: 4, cast: variable(i32))
.field hoveredIndex: int32 (size: 4, cast: variable(i32))
.field pressedIndex: int32 (size: 4, cast: variable(i32))
.field focusedIndex: int32 (size: 4, cast: variable(i32))
.field paddingTop: int32 (size: 4, cast: variable(i32))
.field paddingLeft: int32 (size: 4, cast: variable(i32))
.field paddingRight: int32 (size: 4, cast: variable(i32))
.field paddingBottom: int32 (size: 4, cast: variable(i32))
.field orientation: int32 (size: 4, cast: variable(i32))
.field clearState: function (size: 396, cast: static function)
.field getPressed: function (size: 114, cast: static function)
.field getFocused: function (size: 114, cast: static function)
.field setFocused: function (size: 283, cast: static function)
.field capacity: function (size: 175, cast: static function)
.field addItems: function (size: 204, cast: static function)
.field size: function (size: 10, cast: static function)
.field getView: function (size: 94, cast: static function)
.field setAlignment: function (size: 94, cast: static function)
.field padding: function (size: 56, cast: static function)
.field onClick: function (size: 58, cast: static function)
.field onReset: function (size: 94, cast: static function)
.field onCreate: function (size: 141, cast: static function)
.field onDestroy: function (size: 86, cast: static function)
.field onKeyEvent: function (size: 89, cast: static function)
.field onTouchEvent: function (size: 799, cast: static function)
.field onMeasure: function (size: 448, cast: static function)
.field onLayout: function (size: 411, cast: static function)
.field onLayout: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 180, cast: static function)
.field Custom: function (size: 364, cast: static function)
.field Row: function (size: 29, cast: static function)
.field Column: function (size: 29, cast: static function)
.field Stack: function (size: 25, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:822: referenced as `Panel`
	cmplGfx/lib/micro.ui.ci:753: referenced as `Panel`
	cmplGfx/lib/micro.ui.ci:614: referenced as `Panel`
	cmplGfx/lib/micro.ui.ci:604: referenced as `Panel`
}
Panel.visible: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'visible'
.file: 'cmplGfx/lib/micro.ui.ci:601'
.owner: Panel
.doc: '@public'
.value: false
.usages:
	cmplGfx/lib/micro.ui.ci:615: referenced as `visible`
	cmplGfx/lib/micro.ui.ci:609: referenced as `visible`
	cmplGfx/lib/micro.ui.ci:605: referenced as `visible`
	internal usages: 1
}
Panel.visible(this: Panel, value: bool): bool: function {
.kind: static function
.base: `function`
.size: 64
.name: 'visible'
.file: 'cmplGfx/lib/micro.ui.ci:604'
.owner: Panel
.param .result: bool (size: 4, cast: variable(bool))
.param this: Panel (size: 4, cast: variable(ref))
.param value: bool (size: 4, cast: variable(bool))
.doc: '@public'
.value: {
	if (this.visible == value) {
		return .result := false;
	}
	this.visible := value;
	invalidate(this);
	return .result := true;
}
.instructions: (64 bytes)
	cmplGfx/lib/micro.ui.ci:605: (24 bytes): if (this.visible == value)
	<visible>  : dup.x32 sp(2)
	<visible+?>: inc.i32(+116)
	<visible+?>: load.is8
	<visible+?>: load.sp(+8)
	<visible+?>: load.is8
	<visible+?>: ceq.i32
	<visible+?>: jz +11
	cmplGfx/lib/micro.ui.ci:606: (7 bytes): return .result := false;
	<visible+?>: load.z32
	<visible+?>: load.sp(+16)
	<visible+?>: store.i8
	<visible+?>: ret
	cmplGfx/lib/micro.ui.ci:609: (12 bytes): this.visible := value;
	<visible+?>: load.sp(+4)
	<visible+?>: load.is8
	<visible+?>: dup.x32 sp(3)
	<visible+?>: inc.i32(+116)
	<visible+?>: store.i8
	cmplGfx/lib/micro.ui.ci:610: (17 bytes): invalidate(this);
	<visible+?>: dup.x32 sp(2)
	<visible+?>: load.c32 1
	<visible+?>: load.ref <?> ;invalidate(view: View, layout: bool): void
	<visible+?>: call
	<visible+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:611: (11 bytes): return .result := true;
	<visible+?>: load.c32 1
	<visible+?>: load.sp(+16)
	<visible+?>: store.i8
	<visible+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:772: referenced as `visible`
}
Panel.onMeasure(this: Panel, rect: Rect): bool: function {
.kind: static function
.base: `function`
.size: 53
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.ci:614'
.owner: Panel
.param .result: bool (size: 4, cast: variable(bool))
.param this: Panel (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	if (!this.visible) {
		setSize(rect, 0, 0);
		return .result := false;
	}
	return .result := Layout.onMeasure(this, &rect);
}
.instructions: (53 bytes)
	cmplGfx/lib/micro.ui.ci:615: (32 bytes): if (!this.visible)
	<onMeasure>  : dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+116)
	<onMeasure+?>: load.is8
	<onMeasure+?>: jnz +25
	cmplGfx/lib/micro.ui.ci:617: (14 bytes): setSize(rect, 0, 0);
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.z32
	<onMeasure+?>: load.z32
	<onMeasure+?>: load.ref <?> ;setSize(rectangle: Rect, width: int32, height: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.ci:618: (7 bytes): return .result := false;
	<onMeasure+?>: load.z32
	<onMeasure+?>: load.sp(+16)
	<onMeasure+?>: store.i8
	<onMeasure+?>: ret
	cmplGfx/lib/micro.ui.ci:620: (21 bytes): return .result := Layout.onMeasure(this, &rect);
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: load.ref <?> ;Layout.onMeasure(this: Layout, measured: Rect): bool
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: load.sp(+16)
	<onMeasure+?>: store.i8
	<onMeasure+?>: ret
.usages:
}
TabPage: Layout {
.kind: static const typename(ref)
.base: `Layout`
.size: 128
.name: 'TabPage'
.file: 'cmplGfx/lib/micro.ui.ci:629'
.field tabs: Layout (size: 4, cast: variable(ref))
.field active: Layout (size: 4, cast: variable(ref))
.field background: argb (size: 4, cast: variable(val))
.field onCreate: function (size: 281, cast: static function)
.field onMeasurePage: function (size: 100, cast: static function)
.field onDrawPage: function (size: 60, cast: static function)
.field onDrawBar: function (size: 60, cast: static function)
.field onDrawTab: function (size: 161, cast: static function)
.field onDrawSeparator: function (size: 1, cast: static function)
.field onClickTab: function (size: 138, cast: static function)
.field addItems: function (size: 1354, cast: static function)
.field Item: typename (size: 24, cast: static const typename(val))
.field separator: View (size: 4, cast: variable(ref))
.field items: Layout.Item[*] (size: 4, cast: variable(ref))
.field itemCount: int32 (size: 4, cast: variable(i32))
.field itemCapacity: int32 (size: 4, cast: variable(i32))
.field hoveredIndex: int32 (size: 4, cast: variable(i32))
.field pressedIndex: int32 (size: 4, cast: variable(i32))
.field focusedIndex: int32 (size: 4, cast: variable(i32))
.field paddingTop: int32 (size: 4, cast: variable(i32))
.field paddingLeft: int32 (size: 4, cast: variable(i32))
.field paddingRight: int32 (size: 4, cast: variable(i32))
.field paddingBottom: int32 (size: 4, cast: variable(i32))
.field orientation: int32 (size: 4, cast: variable(i32))
.field clearState: function (size: 396, cast: static function)
.field getPressed: function (size: 114, cast: static function)
.field getFocused: function (size: 114, cast: static function)
.field setFocused: function (size: 283, cast: static function)
.field capacity: function (size: 175, cast: static function)
.field addItems: function (size: 204, cast: static function)
.field size: function (size: 10, cast: static function)
.field getView: function (size: 94, cast: static function)
.field setAlignment: function (size: 94, cast: static function)
.field padding: function (size: 56, cast: static function)
.field onClick: function (size: 58, cast: static function)
.field onReset: function (size: 94, cast: static function)
.field onCreate: function (size: 141, cast: static function)
.field onDestroy: function (size: 86, cast: static function)
.field onKeyEvent: function (size: 89, cast: static function)
.field onTouchEvent: function (size: 799, cast: static function)
.field onMeasure: function (size: 448, cast: static function)
.field onLayout: function (size: 411, cast: static function)
.field onLayout: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 180, cast: static function)
.field Custom: function (size: 364, cast: static function)
.field Row: function (size: 29, cast: static function)
.field Column: function (size: 29, cast: static function)
.field Stack: function (size: 25, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
	cmplGfx/lib/micro.ui.ci:691: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:691: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:679: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:664: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:664: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:658: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:658: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:652: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:652: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:642: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:642: referenced as `TabPage`
	cmplGfx/lib/micro.ui.ci:634: referenced as `TabPage`
}
TabPage.tabs: Layout {
.kind: variable(ref)
.base: `Layout`
.size: 4
.name: 'tabs'
.file: 'cmplGfx/lib/micro.ui.ci:630'
.owner: TabPage
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:738: referenced as `tabs`
	cmplGfx/lib/micro.ui.ci:724: referenced as `tabs`
	cmplGfx/lib/micro.ui.ci:722: referenced as `tabs`
	cmplGfx/lib/micro.ui.ci:718: referenced as `tabs`
	cmplGfx/lib/micro.ui.ci:707: referenced as `tabs`
}
TabPage.active: Layout {
.kind: variable(ref)
.base: `Layout`
.size: 4
.name: 'active'
.file: 'cmplGfx/lib/micro.ui.ci:631'
.owner: TabPage
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:683: referenced as `active`
	cmplGfx/lib/micro.ui.ci:680: referenced as `active`
	cmplGfx/lib/micro.ui.ci:666: referenced as `active`
	cmplGfx/lib/micro.ui.ci:643: referenced as `active`
	cmplGfx/lib/micro.ui.ci:636: referenced as `active`
}
TabPage.background: argb {
.kind: variable(val)
.base: `argb`
.size: 4
.name: 'background'
.file: 'cmplGfx/lib/micro.ui.ci:632'
.owner: TabPage
.value: argb(0)
.usages:
	cmplGfx/lib/micro.ui.ci:659: referenced as `background`
	cmplGfx/lib/micro.ui.ci:653: referenced as `background`
	cmplGfx/lib/micro.ui.ci:638: referenced as `background`
}
TabPage.onCreate(this: TabPage, parent: View): void: function {
.kind: static function
.base: `function`
.size: 281
.name: 'onCreate'
.file: 'cmplGfx/lib/micro.ui.ci:634'
.owner: TabPage
.param .result: void (size: 0, cast: variable(void))
.param this: TabPage (size: 4, cast: variable(ref))
.param parent: View (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view is created'
.value: {
	Layout.onCreate(this, parent);
	this.active := (this.items[1].view);
	style: Style := this.style;
	this.background := mix_rgb8(128, argb(style.backgroundColor), argb(style.hoveredColor));
}
.instructions: (281 bytes)
	cmplGfx/lib/micro.ui.ci:635: (14 bytes): Layout.onCreate(this, parent);
	<onCreate>  : dup.x32 sp(2)
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: load.ref <?> ;Layout.onCreate(this: Layout, parent: View): void
	<onCreate+?>: call
	<onCreate+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:636: (19 bytes): this.active := (this.items[1].view);
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: inc.i32(+68)
	<onCreate+?>: load.i32
	<onCreate+?>: inc.i32(+40)
	<onCreate+?>: load.i32
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: inc.i32(+120)
	<onCreate+?>: store.i32
	cmplGfx/lib/micro.ui.ci:637: (7 bytes): style: Style := this.style
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: inc.i32(+20)
	<onCreate+?>: load.i32
	cmplGfx/lib/micro.ui.ci:638: (236 bytes): this.background := mix_rgb8(128, argb(style.backgroundColor), argb(style.hoveredColor));
	<onCreate+?>: load.c32 128
	<onCreate+?>: dup.x32 sp(1)
	<onCreate+?>: inc.i32(+32)
	<onCreate+?>: load.i32
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: inc.i32(+36)
	<onCreate+?>: load.i32
	<onCreate+?>: dup.x32 sp(1)
	<onCreate+?>: b32.shr 0x10
	<onCreate+?>: b32.and 0xff
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: b32.shr 0x10
	<onCreate+?>: b32.and 0xff
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: sub.i32
	<onCreate+?>: inc.i32(+1)
	<onCreate+?>: mul.i32
	<onCreate+?>: b32.sar 0x08
	<onCreate+?>: add.i32
	<onCreate+?>: set.x32 sp(1)
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: load.c32 255
	<onCreate+?>: cgt.i32
	<onCreate+?>: jz +13
	<onCreate+?>: load.c32 255
	<onCreate+?>: jmp +19
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: load.z32
	<onCreate+?>: clt.i32
	<onCreate+?>: jz +9
	<onCreate+?>: load.z32
	<onCreate+?>: jmp +6
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: set.x32 sp(1)
	<onCreate+?>: b32.shl 0x08
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: b32.shr 0x08
	<onCreate+?>: b32.and 0xff
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: dup.x32 sp(5)
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: b32.shr 0x08
	<onCreate+?>: b32.and 0xff
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: sub.i32
	<onCreate+?>: inc.i32(+1)
	<onCreate+?>: mul.i32
	<onCreate+?>: b32.sar 0x08
	<onCreate+?>: add.i32
	<onCreate+?>: set.x32 sp(1)
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: load.c32 255
	<onCreate+?>: cgt.i32
	<onCreate+?>: jz +13
	<onCreate+?>: load.c32 255
	<onCreate+?>: jmp +19
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: load.z32
	<onCreate+?>: clt.i32
	<onCreate+?>: jz +9
	<onCreate+?>: load.z32
	<onCreate+?>: jmp +6
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: set.x32 sp(1)
	<onCreate+?>: or.b32
	<onCreate+?>: b32.shl 0x08
	<onCreate+?>: dup.x32 sp(2)
	<onCreate+?>: b32.and 0xff
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: dup.x32 sp(5)
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: b32.and 0xff
	<onCreate+?>: dup.x32 sp(3)
	<onCreate+?>: sub.i32
	<onCreate+?>: inc.i32(+1)
	<onCreate+?>: mul.i32
	<onCreate+?>: b32.sar 0x08
	<onCreate+?>: add.i32
	<onCreate+?>: set.x32 sp(1)
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: load.c32 255
	<onCreate+?>: cgt.i32
	<onCreate+?>: jz +13
	<onCreate+?>: load.c32 255
	<onCreate+?>: jmp +19
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: load.z32
	<onCreate+?>: clt.i32
	<onCreate+?>: jz +9
	<onCreate+?>: load.z32
	<onCreate+?>: jmp +6
	<onCreate+?>: dup.x32 sp(0)
	<onCreate+?>: set.x32 sp(1)
	<onCreate+?>: or.b32
	<onCreate+?>: mov.x32 sp(3, 0)
	<onCreate+?>: inc.sp(-12)
	<onCreate+?>: dup.x32 sp(4)
	<onCreate+?>: inc.i32(+124)
	<onCreate+?>: store.i32
	<onCreate+?>: inc.sp(-4)
	<onCreate+?>: ret
.usages:
}
TabPage.onMeasurePage(layout: Layout, rect: Rect): bool: function {
.kind: static function
.base: `function`
.size: 100
.name: 'onMeasurePage'
.file: 'cmplGfx/lib/micro.ui.ci:641'
.owner: TabPage
.param .result: bool (size: 4, cast: variable(bool))
.param layout: Layout (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: variable(ref))
.value: {
	parent: TabPage := as(layout.data, TabPage);
	if ((parent) != null && parent.active != layout) {
		setSize(rect, 0, 0);
		return .result := false;
	}
	return .result := Layout.onMeasure(layout, &rect);
}
.instructions: (100 bytes)
	cmplGfx/lib/micro.ui.ci:642: (16 bytes): parent: TabPage := as(layout.data, TabPage)
	<onMeasurePage>  : dup.x32 sp(2)
	<onMeasurePage+?>: inc.i32(+24)
	<onMeasurePage+?>: load.i32
	<onMeasurePage+?>: load.ref <?> ;TabPage
	<onMeasurePage+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	cmplGfx/lib/micro.ui.ci:643: (59 bytes): if ((parent) != null && parent.active != layout)
	<onMeasurePage+?>: dup.x32 sp(0)
	<onMeasurePage+?>: load.ref <?> ;null
	<onMeasurePage+?>: ceq.i32
	<onMeasurePage+?>: not.b32
	<onMeasurePage+?>: dup.x32 sp(0)
	<onMeasurePage+?>: jz +19
	<onMeasurePage+?>: inc.sp(-4)
	<onMeasurePage+?>: dup.x32 sp(0)
	<onMeasurePage+?>: inc.i32(+120)
	<onMeasurePage+?>: load.i32
	<onMeasurePage+?>: dup.x32 sp(4)
	<onMeasurePage+?>: ceq.i32
	<onMeasurePage+?>: not.b32
	<onMeasurePage+?>: jz +29
	cmplGfx/lib/micro.ui.ci:645: (14 bytes): setSize(rect, 0, 0);
	<onMeasurePage+?>: dup.x32 sp(2)
	<onMeasurePage+?>: load.z32
	<onMeasurePage+?>: load.z32
	<onMeasurePage+?>: load.ref <?> ;setSize(rectangle: Rect, width: int32, height: int32): void
	<onMeasurePage+?>: call
	<onMeasurePage+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.ci:646: (11 bytes): return .result := false;
	<onMeasurePage+?>: load.z32
	<onMeasurePage+?>: load.sp(+20)
	<onMeasurePage+?>: store.i8
	<onMeasurePage+?>: inc.sp(-4)
	<onMeasurePage+?>: ret
	cmplGfx/lib/micro.ui.ci:648: (25 bytes): return .result := Layout.onMeasure(layout, &rect);
	<onMeasurePage+?>: load.z32
	<onMeasurePage+?>: dup.x32 sp(4)
	<onMeasurePage+?>: dup.x32 sp(4)
	<onMeasurePage+?>: load.ref <?> ;Layout.onMeasure(this: Layout, measured: Rect): bool
	<onMeasurePage+?>: call
	<onMeasurePage+?>: inc.sp(-8)
	<onMeasurePage+?>: load.sp(+20)
	<onMeasurePage+?>: store.i8
	<onMeasurePage+?>: inc.sp(-4)
	<onMeasurePage+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:697: referenced as `onMeasurePage`
}
TabPage.onDrawPage(panel: Layout, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 60
.name: 'onDrawPage'
.file: 'cmplGfx/lib/micro.ui.ci:651'
.owner: TabPage
.param .result: void (size: 0, cast: variable(void))
.param panel: Layout (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.value: {
	page: TabPage := as(panel.data, TabPage);
	fillRect(offs, rect, page.background.v);
	Layout.onDraw(panel, offs, rect);
}
.instructions: (60 bytes)
	cmplGfx/lib/micro.ui.ci:652: (16 bytes): page: TabPage := as(panel.data, TabPage)
	<onDrawPage>  : dup.x32 sp(7)
	<onDrawPage+?>: inc.i32(+24)
	<onDrawPage+?>: load.i32
	<onDrawPage+?>: load.ref <?> ;TabPage
	<onDrawPage+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	cmplGfx/lib/micro.ui.ci:653: (23 bytes): fillRect(offs, rect, page.background.v);
	<onDrawPage+?>: dup.x64 sp(6)
	<onDrawPage+?>: load.sp(+16)
	<onDrawPage+?>: dup.x32 sp(3)
	<onDrawPage+?>: inc.i32(+124)
	<onDrawPage+?>: load.i32
	<onDrawPage+?>: load.ref <?> ;fillRect(image: Image, roi: Rect, color: uint32): void
	<onDrawPage+?>: call
	<onDrawPage+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.ci:654: (16 bytes): Layout.onDraw(panel, offs, rect);
	<onDrawPage+?>: dup.x32 sp(8)
	<onDrawPage+?>: dup.x64 sp(7)
	<onDrawPage+?>: dup.x128 sp(5)
	<onDrawPage+?>: load.ref <?> ;Layout.onDraw(this: Layout, offs: Image, parent: Rect): void
	<onDrawPage+?>: call
	<onDrawPage+?>: inc.sp(-28)
	<onDrawPage+?>: inc.sp(-4)
	<onDrawPage+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:696: referenced as `onDrawPage`
}
TabPage.onDrawBar(tabs: Layout, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 60
.name: 'onDrawBar'
.file: 'cmplGfx/lib/micro.ui.ci:657'
.owner: TabPage
.param .result: void (size: 0, cast: variable(void))
.param tabs: Layout (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.value: {
	page: TabPage := as(tabs.data, TabPage);
	fillRect(offs, rect, page.background.v);
	Layout.onDraw(tabs, offs, rect);
}
.instructions: (60 bytes)
	cmplGfx/lib/micro.ui.ci:658: (16 bytes): page: TabPage := as(tabs.data, TabPage)
	<onDrawBar>  : dup.x32 sp(7)
	<onDrawBar+?>: inc.i32(+24)
	<onDrawBar+?>: load.i32
	<onDrawBar+?>: load.ref <?> ;TabPage
	<onDrawBar+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	cmplGfx/lib/micro.ui.ci:659: (23 bytes): fillRect(offs, rect, page.background.v);
	<onDrawBar+?>: dup.x64 sp(6)
	<onDrawBar+?>: load.sp(+16)
	<onDrawBar+?>: dup.x32 sp(3)
	<onDrawBar+?>: inc.i32(+124)
	<onDrawBar+?>: load.i32
	<onDrawBar+?>: load.ref <?> ;fillRect(image: Image, roi: Rect, color: uint32): void
	<onDrawBar+?>: call
	<onDrawBar+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.ci:660: (16 bytes): Layout.onDraw(tabs, offs, rect);
	<onDrawBar+?>: dup.x32 sp(8)
	<onDrawBar+?>: dup.x64 sp(7)
	<onDrawBar+?>: dup.x128 sp(5)
	<onDrawBar+?>: load.ref <?> ;Layout.onDraw(this: Layout, offs: Image, parent: Rect): void
	<onDrawBar+?>: call
	<onDrawBar+?>: inc.sp(-28)
	<onDrawBar+?>: inc.sp(-4)
	<onDrawBar+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:714: referenced as `onDrawBar`
}
TabPage.onDrawTab(tab: Button, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 161
.name: 'onDrawTab'
.file: 'cmplGfx/lib/micro.ui.ci:663'
.owner: TabPage
.param .result: void (size: 0, cast: variable(void))
.param tab: Button (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.value: {
	page: TabPage := as(tab.parent.parent, TabPage);
	style: Style := tab.style;
	if ((page.active) == as(tab.data, Layout)) {
		fillRect(offs, rect, style.focusedColor);
		Style.align(style, rect, &rect, tab.text);
		Image.drawText(offs, rect, style.font, tab.text, style.textColor);
		return;
	}
	Button.onDraw(tab, offs, rect);
}
.instructions: (161 bytes)
	cmplGfx/lib/micro.ui.ci:664: (21 bytes): page: TabPage := as(tab.parent.parent, TabPage)
	<onDrawTab>  : dup.x32 sp(7)
	<onDrawTab+?>: inc.i32(+16)
	<onDrawTab+?>: load.i32
	<onDrawTab+?>: inc.i32(+16)
	<onDrawTab+?>: load.i32
	<onDrawTab+?>: load.ref <?> ;TabPage
	<onDrawTab+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	cmplGfx/lib/micro.ui.ci:665: (7 bytes): style: Style := tab.style
	<onDrawTab+?>: dup.x32 sp(8)
	<onDrawTab+?>: inc.i32(+20)
	<onDrawTab+?>: load.i32
	cmplGfx/lib/micro.ui.ci:666: (112 bytes): if ((page.active) == as(tab.data, Layout))
	<onDrawTab+?>: dup.x32 sp(1)
	<onDrawTab+?>: inc.i32(+120)
	<onDrawTab+?>: load.i32
	<onDrawTab+?>: dup.x32 sp(10)
	<onDrawTab+?>: inc.i32(+24)
	<onDrawTab+?>: load.i32
	<onDrawTab+?>: load.ref <?> ;Layout
	<onDrawTab+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<onDrawTab+?>: ceq.i32
	<onDrawTab+?>: jz +88
	cmplGfx/lib/micro.ui.ci:667: (23 bytes): fillRect(offs, rect, style.focusedColor);
	<onDrawTab+?>: dup.x64 sp(7)
	<onDrawTab+?>: load.sp(+20)
	<onDrawTab+?>: dup.x32 sp(3)
	<onDrawTab+?>: inc.i32(+40)
	<onDrawTab+?>: load.i32
	<onDrawTab+?>: load.ref <?> ;fillRect(image: Image, roi: Rect, color: uint32): void
	<onDrawTab+?>: call
	<onDrawTab+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.ci:668: (25 bytes): Style.align(style, rect, &rect, tab.text);
	<onDrawTab+?>: dup.x32 sp(0)
	<onDrawTab+?>: dup.x128 sp(4)
	<onDrawTab+?>: load.sp(+32)
	<onDrawTab+?>: dup.x32 sp(15)
	<onDrawTab+?>: inc.i32(+64)
	<onDrawTab+?>: load.i32
	<onDrawTab+?>: load.ref <?> ;Style.align(this: Style, parent: Rect, rect: Rect, value: char[*]): void
	<onDrawTab+?>: call
	<onDrawTab+?>: inc.sp(-28)
	cmplGfx/lib/micro.ui.ci:669: (31 bytes): Image.drawText(offs, rect, style.font, tab.text, style.textColor);
	<onDrawTab+?>: dup.x64 sp(7)
	<onDrawTab+?>: load.sp(+20)
	<onDrawTab+?>: dup.x32 sp(3)
	<onDrawTab+?>: inc.i32(+8)
	<onDrawTab+?>: load.i64
	<onDrawTab+?>: dup.x32 sp(14)
	<onDrawTab+?>: inc.i32(+64)
	<onDrawTab+?>: load.i32
	<onDrawTab+?>: dup.x32 sp(6)
	<onDrawTab+?>: inc.i32(+48)
	<onDrawTab+?>: load.i32
	<onDrawTab+?>: nfc(108) ;Image.drawText(image: Image, roi: Rect, font: Image, text: char[*], color: int32): void
	cmplGfx/lib/micro.ui.ci:670: (5 bytes): return;
	<onDrawTab+?>: inc.sp(-8)
	<onDrawTab+?>: ret
	cmplGfx/lib/micro.ui.ci:672: (16 bytes): Button.onDraw(tab, offs, rect);
	<onDrawTab+?>: dup.x32 sp(9)
	<onDrawTab+?>: dup.x64 sp(8)
	<onDrawTab+?>: dup.x128 sp(6)
	<onDrawTab+?>: load.ref <?> ;Button.onDraw(this: Button, offs: Image, rect: Rect): void
	<onDrawTab+?>: call
	<onDrawTab+?>: inc.sp(-28)
	<onDrawTab+?>: inc.sp(-8)
	<onDrawTab+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:703: referenced as `onDrawTab`
}
TabPage.onDrawSeparator(this: View, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 1
.name: 'onDrawSeparator'
.file: 'cmplGfx/lib/micro.ui.ci:675'
.owner: TabPage
.param .result: void (size: 0, cast: variable(void))
.param this: View (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.value: {
}
.instructions: (1 byte)
	<onDrawSeparator>  : ret
.usages:
	cmplGfx/lib/micro.ui.ci:731: referenced as `onDrawSeparator`
}
TabPage.onClickTab(button: Button): bool: function {
.kind: static function
.base: `function`
.size: 138
.name: 'onClickTab'
.file: 'cmplGfx/lib/micro.ui.ci:677'
.owner: TabPage
.param .result: bool (size: 4, cast: variable(bool))
.param button: Button (size: 4, cast: variable(ref))
.value: {
	if ((page) != null) {
		if ((tabs) != null) {
			if (tabs.active == page) {
				return .result := false;
			}
			tabs.active := page;
			invalidate(tabs);
			focus(page);
		}
	}
	return .result := true;
}
.instructions: (138 bytes)
	cmplGfx/lib/micro.ui.ci:678: (127 bytes): if ((page) != null)
	<onClickTab>  : dup.x32 sp(1)
	<onClickTab+?>: inc.i32(+24)
	<onClickTab+?>: load.i32
	<onClickTab+?>: load.ref <?> ;Layout
	<onClickTab+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<onClickTab+?>: dup.x32 sp(0)
	<onClickTab+?>: load.ref <?> ;null
	<onClickTab+?>: ceq.i32
	<onClickTab+?>: jnz +99
	cmplGfx/lib/micro.ui.ci:679: (95 bytes): if ((tabs) != null)
	<onClickTab+?>: dup.x32 sp(0)
	<onClickTab+?>: inc.i32(+24)
	<onClickTab+?>: load.i32
	<onClickTab+?>: load.ref <?> ;Layout
	<onClickTab+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<onClickTab+?>: dup.x32 sp(0)
	<onClickTab+?>: load.ref <?> ;null
	<onClickTab+?>: ceq.i32
	<onClickTab+?>: jnz +67
	cmplGfx/lib/micro.ui.ci:680: (25 bytes): if (tabs.active == page)
	<onClickTab+?>: dup.x32 sp(0)
	<onClickTab+?>: inc.i32(+120)
	<onClickTab+?>: load.i32
	<onClickTab+?>: dup.x32 sp(2)
	<onClickTab+?>: ceq.i32
	<onClickTab+?>: jz +15
	cmplGfx/lib/micro.ui.ci:681: (11 bytes): return .result := false;
	<onClickTab+?>: load.z32
	<onClickTab+?>: load.sp(+20)
	<onClickTab+?>: store.i8
	<onClickTab+?>: inc.sp(-8)
	<onClickTab+?>: ret
	cmplGfx/lib/micro.ui.ci:683: (9 bytes): tabs.active := page;
	<onClickTab+?>: dup.x32 sp(1)
	<onClickTab+?>: dup.x32 sp(1)
	<onClickTab+?>: inc.i32(+120)
	<onClickTab+?>: store.i32
	cmplGfx/lib/micro.ui.ci:684: (17 bytes): invalidate(tabs);
	<onClickTab+?>: dup.x32 sp(0)
	<onClickTab+?>: load.c32 1
	<onClickTab+?>: load.ref <?> ;invalidate(view: View, layout: bool): void
	<onClickTab+?>: call
	<onClickTab+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:685: (12 bytes): focus(page);
	<onClickTab+?>: dup.x32 sp(1)
	<onClickTab+?>: load.ref <?> ;focus(view: View): void
	<onClickTab+?>: call
	<onClickTab+?>: inc.sp(-4)
	<onClickTab+?>: inc.sp(-4)
	<onClickTab+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:688: (11 bytes): return .result := true;
	<onClickTab+?>: load.c32 1
	<onClickTab+?>: load.sp(+12)
	<onClickTab+?>: store.i8
	<onClickTab+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:704: referenced as `onClickTab`
}
TabPage.addItems(this: TabPage, text: char[*], align: int32, views: View[]): TabPage: function {
.kind: static function
.base: `function`
.size: 1354
.name: 'addItems'
.file: 'cmplGfx/lib/micro.ui.ci:691'
.owner: TabPage
.param .result: TabPage (size: 4, cast: variable(ref))
.param this: TabPage (size: 4, cast: variable(ref))
.param text: char[*] (size: 4, cast: const variable(ref))
.param align: int32 (size: 4, cast: variable(i32))
.param views: View[] (size: 8, cast: variable(arr))
.value: {
	padding: typename := 1;
	page: Layout := {
		page := create(Layout);
		page.data := (this);
		page.onDraw := onDrawPage;
		page.onMeasure := onMeasurePage;
		page.separator := (null);
		page.items := (null);
		page.itemCount := 0;
		page.itemCapacity := 0;
		page.hoveredIndex := -1;
		page.pressedIndex := -1;
		page.focusedIndex := -1;
		page.paddingTop := 0;
		page.paddingLeft := 0;
		page.paddingRight := 0;
		page.paddingBottom := 0;
		page.orientation := 1;
		page.onLayout := onLayout;
		page.width := -5;
		page.height := -5;
		page.enabled := true;
		page.focusable := true;
		page.parent := (null);
		page.style := (null);
		page.onClick := onClick;
		page.onReset := onReset;
		page.onCreate := onCreate;
		page.onDestroy := onDestroy;
		page.onKeyEvent := onKeyEvent;
		page.onTouchEvent := onTouchEvent;
	};
	tab: Button := {
		tab := create(Button);
		tab.text := (text);
		tab.data := (page);
		tab.focusable := false;
		tab.onDraw := onDrawTab;
		tab.onClick := onClickTab;
		tab.width := -5;
		tab.height := -5;
		tab.enabled := true;
		tab.parent := (null);
		tab.style := (null);
		tab.onReset := onReset;
		tab.onCreate := onCreate;
		tab.onDestroy := onDestroy;
		tab.onKeyEvent := onKeyEvent;
		tab.onTouchEvent := onTouchEvent;
		tab.onMeasure := onMeasure;
	};
	if ((this.tabs) == null) {
		tabs: Layout := {
			tabs := create(Layout);
			tabs.paddingTop := padding;
			tabs.paddingLeft := padding;
			tabs.paddingRight := padding;
			tabs.paddingBottom := padding;
			tabs.data := (this);
			tabs.onDraw := onDrawBar;
			tabs.orientation := -this.orientation;
			tabs.separator := (null);
			tabs.items := (null);
			tabs.itemCount := 0;
			tabs.itemCapacity := 0;
			tabs.hoveredIndex := -1;
			tabs.pressedIndex := -1;
			tabs.focusedIndex := -1;
			tabs.onLayout := onLayout;
			tabs.width := -5;
			tabs.height := -5;
			tabs.enabled := true;
			tabs.focusable := true;
			tabs.parent := (null);
			tabs.style := (null);
			tabs.onClick := onClick;
			tabs.onReset := onReset;
			tabs.onCreate := onCreate;
			tabs.onDestroy := onDestroy;
			tabs.onKeyEvent := onKeyEvent;
			tabs.onTouchEvent := onTouchEvent;
			tabs.onMeasure := onMeasure;
		};
		this.tabs := tabs;
		Layout.addItems(this, Style.center, tabs);
	}
	if (this.tabs.itemCount > 0) {
		tabs: Layout := this.tabs;
		if ((tabs.separator) == null) {
			separator: View := {
				separator := create(View);
				separator.width := padding;
				separator.height := padding;
				separator.enabled := false;
				separator.focusable := false;
				separator.onDraw := onDrawSeparator;
				separator.parent := (null);
				separator.style := (null);
				separator.data := (null);
				separator.onClick := onClick;
				separator.onReset := onReset;
				separator.onCreate := onCreate;
				separator.onDestroy := onDestroy;
				separator.onKeyEvent := onKeyEvent;
				separator.onTouchEvent := onTouchEvent;
				separator.onMeasure := onMeasure;
			};
			tabs.separator := separator;
		}
		addItems(tabs, 0, tabs.separator);
	}
	addItems(this.tabs, 0, tab);
	addItems(page, align, ...views);
	Layout.addItems(this, Style.fill, page);
	return .result := this;
}
.instructions: (1354 bytes)
	cmplGfx/lib/micro.ui.ci:693: (329 bytes): page: Layout := {...}
	<addItems>  : inc.sp(+4)
	cmplGfx/lib/micro.ui.ci:693: (11 bytes): page := create(Layout);
	<addItems+?>: load.ref <?> ;Layout
	<addItems+?>: nfc(7) ;object.create(type: typename): pointer
	<addItems+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:694: (14 bytes): page.data := (this);
	<addItems+?>: load.ref <?> ;TabPage
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: inc.i32(+24)
	<addItems+?>: store.i64
	cmplGfx/lib/micro.ui.ci:696: (12 bytes): page.onDraw := onDrawPage;
	<addItems+?>: load.ref <?> ;TabPage.onDrawPage(panel: Layout, offs: Image, rect: Rect): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+60)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:697: (12 bytes): page.onMeasure := onMeasurePage;
	<addItems+?>: load.ref <?> ;TabPage.onMeasurePage(layout: Layout, rect: Rect): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+56)
	<addItems+?>: store.i32
	:: (12 bytes): page.separator := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+64)
	<addItems+?>: store.i32
	:: (12 bytes): page.items := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+68)
	<addItems+?>: store.i32
	:: (8 bytes): page.itemCount := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+72)
	<addItems+?>: store.i32
	:: (8 bytes): page.itemCapacity := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+76)
	<addItems+?>: store.i32
	:: (12 bytes): page.hoveredIndex := -1;
	<addItems+?>: load.c32 -1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+80)
	<addItems+?>: store.i32
	:: (12 bytes): page.pressedIndex := -1;
	<addItems+?>: load.c32 -1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+84)
	<addItems+?>: store.i32
	:: (12 bytes): page.focusedIndex := -1;
	<addItems+?>: load.c32 -1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+88)
	<addItems+?>: store.i32
	:: (8 bytes): page.paddingTop := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+92)
	<addItems+?>: store.i32
	:: (8 bytes): page.paddingLeft := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+96)
	<addItems+?>: store.i32
	:: (8 bytes): page.paddingRight := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+100)
	<addItems+?>: store.i32
	:: (8 bytes): page.paddingBottom := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+104)
	<addItems+?>: store.i32
	:: (12 bytes): page.orientation := 1;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+108)
	<addItems+?>: store.i32
	:: (12 bytes): page.onLayout := onLayout;
	<addItems+?>: load.ref <?> ;Layout.onLayout(this: Layout, measured: Rect): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+112)
	<addItems+?>: store.i32
	:: (12 bytes): page.width := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+4)
	<addItems+?>: store.i32
	:: (12 bytes): page.height := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+8)
	<addItems+?>: store.i32
	:: (12 bytes): page.enabled := true;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+12)
	<addItems+?>: store.i8
	:: (12 bytes): page.focusable := true;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+13)
	<addItems+?>: store.i8
	:: (12 bytes): page.parent := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+16)
	<addItems+?>: store.i32
	:: (12 bytes): page.style := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+20)
	<addItems+?>: store.i32
	:: (12 bytes): page.onClick := onClick;
	<addItems+?>: load.ref <?> ;Layout.onClick(this: Layout): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+32)
	<addItems+?>: store.i32
	:: (12 bytes): page.onReset := onReset;
	<addItems+?>: load.ref <?> ;Layout.onReset(this: Layout): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+36)
	<addItems+?>: store.i32
	:: (12 bytes): page.onCreate := onCreate;
	<addItems+?>: load.ref <?> ;Layout.onCreate(this: Layout, parent: View): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+40)
	<addItems+?>: store.i32
	:: (12 bytes): page.onDestroy := onDestroy;
	<addItems+?>: load.ref <?> ;Layout.onDestroy(this: Layout): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+44)
	<addItems+?>: store.i32
	:: (12 bytes): page.onKeyEvent := onKeyEvent;
	<addItems+?>: load.ref <?> ;Layout.onKeyEvent(this: Layout, event: KeyEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+48)
	<addItems+?>: store.i32
	:: (12 bytes): page.onTouchEvent := onTouchEvent;
	<addItems+?>: load.ref <?> ;Layout.onTouchEvent(this: Layout, rect: Rect, event: TouchEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+52)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:699: (202 bytes): tab: Button := {...}
	<addItems+?>: inc.sp(+4)
	cmplGfx/lib/micro.ui.ci:699: (11 bytes): tab := create(Button);
	<addItems+?>: load.ref <?> ;Button
	<addItems+?>: nfc(7) ;object.create(type: typename): pointer
	<addItems+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:700: (9 bytes): tab.text := (text);
	<addItems+?>: dup.x32 sp(6)
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+64)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:701: (14 bytes): tab.data := (page);
	<addItems+?>: load.ref <?> ;Layout
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: inc.i32(+24)
	<addItems+?>: store.i64
	cmplGfx/lib/micro.ui.ci:702: (8 bytes): tab.focusable := false;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+13)
	<addItems+?>: store.i8
	cmplGfx/lib/micro.ui.ci:703: (12 bytes): tab.onDraw := onDrawTab;
	<addItems+?>: load.ref <?> ;TabPage.onDrawTab(tab: Button, offs: Image, rect: Rect): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+60)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:704: (12 bytes): tab.onClick := onClickTab;
	<addItems+?>: load.ref <?> ;TabPage.onClickTab(button: Button): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+32)
	<addItems+?>: store.i32
	:: (12 bytes): tab.width := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+4)
	<addItems+?>: store.i32
	:: (12 bytes): tab.height := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+8)
	<addItems+?>: store.i32
	:: (12 bytes): tab.enabled := true;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+12)
	<addItems+?>: store.i8
	:: (12 bytes): tab.parent := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+16)
	<addItems+?>: store.i32
	:: (12 bytes): tab.style := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+20)
	<addItems+?>: store.i32
	:: (12 bytes): tab.onReset := onReset;
	<addItems+?>: load.ref <?> ;View.onReset(this: View): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+36)
	<addItems+?>: store.i32
	:: (12 bytes): tab.onCreate := onCreate;
	<addItems+?>: load.ref <?> ;View.onCreate(this: View, parent: View): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+40)
	<addItems+?>: store.i32
	:: (12 bytes): tab.onDestroy := onDestroy;
	<addItems+?>: load.ref <?> ;View.onDestroy(this: View): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+44)
	<addItems+?>: store.i32
	:: (12 bytes): tab.onKeyEvent := onKeyEvent;
	<addItems+?>: load.ref <?> ;View.onKeyEvent(this: View, event: KeyEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+48)
	<addItems+?>: store.i32
	:: (12 bytes): tab.onTouchEvent := onTouchEvent;
	<addItems+?>: load.ref <?> ;View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+52)
	<addItems+?>: store.i32
	:: (12 bytes): tab.onMeasure := onMeasure;
	<addItems+?>: load.ref <?> ;Button.onMeasure(this: Button, rect: Rect): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+56)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:707: (415 bytes): if ((this.tabs) == null)
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: inc.i32(+116)
	<addItems+?>: load.i32
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: ceq.i32
	<addItems+?>: jz +402
	cmplGfx/lib/micro.ui.ci:708: (348 bytes): tabs: Layout := {...}
	<addItems+?>: inc.sp(+4)
	cmplGfx/lib/micro.ui.ci:708: (11 bytes): tabs := create(Layout);
	<addItems+?>: load.ref <?> ;Layout
	<addItems+?>: nfc(7) ;object.create(type: typename): pointer
	<addItems+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:709: (12 bytes): tabs.paddingTop := padding;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+92)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:710: (12 bytes): tabs.paddingLeft := padding;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+96)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:711: (12 bytes): tabs.paddingRight := padding;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+100)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:712: (12 bytes): tabs.paddingBottom := padding;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+104)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:713: (14 bytes): tabs.data := (this);
	<addItems+?>: load.ref <?> ;TabPage
	<addItems+?>: dup.x32 sp(9)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: inc.i32(+24)
	<addItems+?>: store.i64
	cmplGfx/lib/micro.ui.ci:714: (12 bytes): tabs.onDraw := onDrawBar;
	<addItems+?>: load.ref <?> ;TabPage.onDrawBar(tabs: Layout, offs: Image, rect: Rect): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+60)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:715: (15 bytes): tabs.orientation := -this.orientation;
	<addItems+?>: dup.x32 sp(8)
	<addItems+?>: inc.i32(+108)
	<addItems+?>: load.i32
	<addItems+?>: neg.i32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+108)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.separator := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+64)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.items := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+68)
	<addItems+?>: store.i32
	:: (8 bytes): tabs.itemCount := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+72)
	<addItems+?>: store.i32
	:: (8 bytes): tabs.itemCapacity := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+76)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.hoveredIndex := -1;
	<addItems+?>: load.c32 -1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+80)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.pressedIndex := -1;
	<addItems+?>: load.c32 -1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+84)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.focusedIndex := -1;
	<addItems+?>: load.c32 -1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+88)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.onLayout := onLayout;
	<addItems+?>: load.ref <?> ;Layout.onLayout(this: Layout, measured: Rect): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+112)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.width := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+4)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.height := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+8)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.enabled := true;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+12)
	<addItems+?>: store.i8
	:: (12 bytes): tabs.focusable := true;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+13)
	<addItems+?>: store.i8
	:: (12 bytes): tabs.parent := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+16)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.style := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+20)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.onClick := onClick;
	<addItems+?>: load.ref <?> ;Layout.onClick(this: Layout): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+32)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.onReset := onReset;
	<addItems+?>: load.ref <?> ;Layout.onReset(this: Layout): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+36)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.onCreate := onCreate;
	<addItems+?>: load.ref <?> ;Layout.onCreate(this: Layout, parent: View): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+40)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.onDestroy := onDestroy;
	<addItems+?>: load.ref <?> ;Layout.onDestroy(this: Layout): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+44)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.onKeyEvent := onKeyEvent;
	<addItems+?>: load.ref <?> ;Layout.onKeyEvent(this: Layout, event: KeyEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+48)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.onTouchEvent := onTouchEvent;
	<addItems+?>: load.ref <?> ;Layout.onTouchEvent(this: Layout, rect: Rect, event: TouchEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+52)
	<addItems+?>: store.i32
	:: (12 bytes): tabs.onMeasure := onMeasure;
	<addItems+?>: load.ref <?> ;Layout.onMeasure(this: Layout, measured: Rect): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+56)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:718: (9 bytes): this.tabs := tabs;
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: dup.x32 sp(9)
	<addItems+?>: inc.i32(+116)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:719: (37 bytes): Layout.addItems(this, Style.center, tabs);
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: load.c32 1
	<addItems+?>: load.sp(+4)
	<addItems+?>: inc.sp(+4)
	<addItems+?>: dup.x32 sp(12)
	<addItems+?>: load.z32
	<addItems+?>: dup.x64 sp(3)
	<addItems+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<addItems+?>: call
	<addItems+?>: mov.x32 sp(7, 4)
	<addItems+?>: inc.sp(-28)
	<addItems+?>: inc.sp(-4)
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:722: (293 bytes): if (this.tabs.itemCount > 0)
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: inc.i32(+116)
	<addItems+?>: load.i32
	<addItems+?>: inc.i32(+72)
	<addItems+?>: load.i32
	<addItems+?>: load.z32
	<addItems+?>: cgt.i32
	<addItems+?>: jz +279
	cmplGfx/lib/micro.ui.ci:724: (7 bytes): tabs: Layout := this.tabs
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: inc.i32(+116)
	<addItems+?>: load.i32
	cmplGfx/lib/micro.ui.ci:725: (222 bytes): if ((tabs.separator) == null)
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: inc.i32(+64)
	<addItems+?>: load.i32
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: ceq.i32
	<addItems+?>: jz +209
	cmplGfx/lib/micro.ui.ci:726: (192 bytes): separator: View := {...}
	<addItems+?>: inc.sp(+4)
	cmplGfx/lib/micro.ui.ci:726: (11 bytes): separator := create(View);
	<addItems+?>: load.ref <?> ;View
	<addItems+?>: nfc(7) ;object.create(type: typename): pointer
	<addItems+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:727: (12 bytes): separator.width := padding;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+4)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:728: (12 bytes): separator.height := padding;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+8)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:729: (8 bytes): separator.enabled := false;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+12)
	<addItems+?>: store.i8
	cmplGfx/lib/micro.ui.ci:730: (8 bytes): separator.focusable := false;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+13)
	<addItems+?>: store.i8
	cmplGfx/lib/micro.ui.ci:731: (12 bytes): separator.onDraw := onDrawSeparator;
	<addItems+?>: load.ref <?> ;TabPage.onDrawSeparator(this: View, offs: Image, rect: Rect): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+60)
	<addItems+?>: store.i32
	:: (12 bytes): separator.parent := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+16)
	<addItems+?>: store.i32
	:: (12 bytes): separator.style := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+20)
	<addItems+?>: store.i32
	:: (17 bytes): separator.data := (null);
	<addItems+?>: load.ref <?> ;pointer
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: inc.i32(+24)
	<addItems+?>: store.i64
	:: (12 bytes): separator.onClick := onClick;
	<addItems+?>: load.ref <?> ;View.onClick(this: View): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+32)
	<addItems+?>: store.i32
	:: (12 bytes): separator.onReset := onReset;
	<addItems+?>: load.ref <?> ;View.onReset(this: View): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+36)
	<addItems+?>: store.i32
	:: (12 bytes): separator.onCreate := onCreate;
	<addItems+?>: load.ref <?> ;View.onCreate(this: View, parent: View): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+40)
	<addItems+?>: store.i32
	:: (12 bytes): separator.onDestroy := onDestroy;
	<addItems+?>: load.ref <?> ;View.onDestroy(this: View): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+44)
	<addItems+?>: store.i32
	:: (12 bytes): separator.onKeyEvent := onKeyEvent;
	<addItems+?>: load.ref <?> ;View.onKeyEvent(this: View, event: KeyEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+48)
	<addItems+?>: store.i32
	:: (12 bytes): separator.onTouchEvent := onTouchEvent;
	<addItems+?>: load.ref <?> ;View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+52)
	<addItems+?>: store.i32
	:: (12 bytes): separator.onMeasure := onMeasure;
	<addItems+?>: load.ref <?> ;View.onMeasure(this: View, rect: Rect): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+56)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:733: (9 bytes): tabs.separator := separator;
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: inc.i32(+64)
	<addItems+?>: store.i32
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:735: (42 bytes): addItems(tabs, 0, tabs.separator);
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: inc.i32(+64)
	<addItems+?>: load.i32
	<addItems+?>: load.c32 1
	<addItems+?>: load.sp(+4)
	<addItems+?>: inc.sp(+4)
	<addItems+?>: dup.x32 sp(4)
	<addItems+?>: load.z32
	<addItems+?>: dup.x64 sp(3)
	<addItems+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<addItems+?>: call
	<addItems+?>: mov.x32 sp(7, 4)
	<addItems+?>: inc.sp(-28)
	<addItems+?>: inc.sp(-4)
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:738: (42 bytes): addItems(this.tabs, 0, tab);
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: load.c32 1
	<addItems+?>: load.sp(+4)
	<addItems+?>: inc.sp(+4)
	<addItems+?>: dup.x32 sp(11)
	<addItems+?>: inc.i32(+116)
	<addItems+?>: load.i32
	<addItems+?>: load.z32
	<addItems+?>: dup.x64 sp(3)
	<addItems+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<addItems+?>: call
	<addItems+?>: mov.x32 sp(7, 4)
	<addItems+?>: inc.sp(-28)
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:739: (24 bytes): addItems(page, align, ...views);
	<addItems+?>: inc.sp(+4)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: dup.x64 sp(6)
	<addItems+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<addItems+?>: call
	<addItems+?>: inc.sp(-16)
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:740: (41 bytes): Layout.addItems(this, Style.fill, page);
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: load.c32 1
	<addItems+?>: load.sp(+4)
	<addItems+?>: inc.sp(+4)
	<addItems+?>: dup.x32 sp(11)
	<addItems+?>: load.c32 15
	<addItems+?>: dup.x64 sp(3)
	<addItems+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<addItems+?>: call
	<addItems+?>: mov.x32 sp(7, 4)
	<addItems+?>: inc.sp(-28)
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:741: (8 bytes): return .result := this;
	<addItems+?>: mov.x32 sp(8, 7)
	<addItems+?>: inc.sp(-8)
	<addItems+?>: ret
.usages:
}
Select: Layout {
.kind: static const typename(ref)
.base: `Layout`
.size: 144
.name: 'Select'
.file: 'cmplGfx/lib/micro.ui.ci:746'
.field text: char[] (size: 8, cast: const variable(arr))
.field states: char[*][2] (size: 8, cast: variable(val))
.field selected: Button (size: 4, cast: variable(ref))
.field header: Switch (size: 4, cast: variable(ref))
.field panel: Panel (size: 4, cast: variable(ref))
.field selectedData: function (size: 45, cast: static function)
.field expand: function (size: 160, cast: static function)
.field onItemClick: function (size: 52, cast: static function)
.field setSelectedIndex: function (size: 173, cast: static function)
.field addItems: function (size: 749, cast: static function)
.field addItem: function (size: 259, cast: static function)
.field addItem: function (size: 28, cast: static function)
.field Item: typename (size: 24, cast: static const typename(val))
.field separator: View (size: 4, cast: variable(ref))
.field items: Layout.Item[*] (size: 4, cast: variable(ref))
.field itemCount: int32 (size: 4, cast: variable(i32))
.field itemCapacity: int32 (size: 4, cast: variable(i32))
.field hoveredIndex: int32 (size: 4, cast: variable(i32))
.field pressedIndex: int32 (size: 4, cast: variable(i32))
.field focusedIndex: int32 (size: 4, cast: variable(i32))
.field paddingTop: int32 (size: 4, cast: variable(i32))
.field paddingLeft: int32 (size: 4, cast: variable(i32))
.field paddingRight: int32 (size: 4, cast: variable(i32))
.field paddingBottom: int32 (size: 4, cast: variable(i32))
.field orientation: int32 (size: 4, cast: variable(i32))
.field clearState: function (size: 396, cast: static function)
.field getPressed: function (size: 114, cast: static function)
.field getFocused: function (size: 114, cast: static function)
.field setFocused: function (size: 283, cast: static function)
.field capacity: function (size: 175, cast: static function)
.field addItems: function (size: 204, cast: static function)
.field size: function (size: 10, cast: static function)
.field getView: function (size: 94, cast: static function)
.field setAlignment: function (size: 94, cast: static function)
.field padding: function (size: 56, cast: static function)
.field onClick: function (size: 58, cast: static function)
.field onReset: function (size: 94, cast: static function)
.field onCreate: function (size: 141, cast: static function)
.field onDestroy: function (size: 86, cast: static function)
.field onKeyEvent: function (size: 89, cast: static function)
.field onTouchEvent: function (size: 799, cast: static function)
.field onMeasure: function (size: 448, cast: static function)
.field onLayout: function (size: 411, cast: static function)
.field onLayout: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 180, cast: static function)
.field Custom: function (size: 364, cast: static function)
.field Row: function (size: 29, cast: static function)
.field Column: function (size: 29, cast: static function)
.field Stack: function (size: 25, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:853: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:853: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:848: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:838: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:836: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:836: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:803: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:801: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:801: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:785: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:785: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:777: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:763: referenced as `Select`
	cmplGfx/lib/micro.ui.ci:756: referenced as `Select`
}
Select.text: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'text'
.file: 'cmplGfx/lib/micro.ui.ci:748'
.owner: Select
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:817: referenced as `text`
}
Select.states: char[*][2] {
.kind: variable(val)
.base: `char[*][2]`
.size: 8
.name: 'states'
.file: 'cmplGfx/lib/micro.ui.ci:749'
.owner: Select
.usages:
	cmplGfx/lib/micro.ui.ci:825: referenced as `states`
	cmplGfx/lib/micro.ui.ci:824: referenced as `states`
	cmplGfx/lib/micro.ui.ci:818: referenced as `states`
	cmplGfx/lib/micro.ui.ci:796: referenced as `states`
	cmplGfx/lib/micro.ui.ci:780: referenced as `states`
}
Select.selected: Button {
.kind: variable(ref)
.base: `Button`
.size: 4
.name: 'selected'
.file: 'cmplGfx/lib/micro.ui.ci:751'
.owner: Select
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:795: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:778: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:766: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:765: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:760: referenced as `selected`
	cmplGfx/lib/micro.ui.ci:757: referenced as `selected`
}
Select.header: Switch {
.kind: variable(ref)
.base: `Switch`
.size: 4
.name: 'header'
.file: 'cmplGfx/lib/micro.ui.ci:752'
.owner: Select
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:826: referenced as `header`
	cmplGfx/lib/micro.ui.ci:771: referenced as `header`
	cmplGfx/lib/micro.ui.ci:768: referenced as `header`
}
Select.panel: Panel {
.kind: variable(ref)
.base: `Panel`
.size: 4
.name: 'panel'
.file: 'cmplGfx/lib/micro.ui.ci:753'
.owner: Select
.value: null
.usages:
	cmplGfx/lib/micro.ui.ci:831: referenced as `panel`
	cmplGfx/lib/micro.ui.ci:827: referenced as `panel`
	cmplGfx/lib/micro.ui.ci:790: referenced as `panel`
	cmplGfx/lib/micro.ui.ci:786: referenced as `panel`
	cmplGfx/lib/micro.ui.ci:772: referenced as `panel`
}
Select.selectedData(select: Select): variant: function {
.kind: static function
.base: `function`
.size: 45
.name: 'selectedData'
.file: 'cmplGfx/lib/micro.ui.ci:756'
.owner: Select
.param .result: variant (size: 8, cast: variable(var))
.param select: Select (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	if ((select.selected) == null) {
		return .result := null;
	}
	return .result := select.selected.data;
}
.instructions: (45 bytes)
	cmplGfx/lib/micro.ui.ci:757: (30 bytes): if ((select.selected) == null)
	<selectedData>  : dup.x32 sp(1)
	<selectedData+?>: inc.i32(+132)
	<selectedData+?>: load.i32
	<selectedData+?>: load.ref <?> ;null
	<selectedData+?>: ceq.i32
	<selectedData+?>: jz +17
	cmplGfx/lib/micro.ui.ci:758: (13 bytes): return .result := null;
	<selectedData+?>: load.ref <?> ;pointer
	<selectedData+?>: load.ref <?> ;null
	<selectedData+?>: set.x64 sp(4)
	<selectedData+?>: ret
	cmplGfx/lib/micro.ui.ci:760: (15 bytes): return .result := select.selected.data;
	<selectedData+?>: dup.x32 sp(1)
	<selectedData+?>: inc.i32(+132)
	<selectedData+?>: load.i32
	<selectedData+?>: inc.i32(+24)
	<selectedData+?>: load.i64
	<selectedData+?>: set.x64 sp(4)
	<selectedData+?>: ret
.usages:
}
Select.expand(select: Select, value: bool): bool: function {
.kind: static function
.base: `function`
.size: 160
.name: 'expand'
.file: 'cmplGfx/lib/micro.ui.ci:763'
.owner: Select
.param .result: bool (size: 4, cast: variable(bool))
.param select: Select (size: 4, cast: variable(ref))
.param value: bool (size: 4, cast: variable(bool))
.value: {
	if (value && (select.selected) != null) {
		focus(select.selected);
	}
	else {
		focus(select.header);
	}
	select.header.onUpdate(select.header, int32(value));
	Panel.visible(select.panel, value);
	invalidate(select);
	return .result := true;
}
.instructions: (160 bytes)
	cmplGfx/lib/micro.ui.ci:765: (71 bytes): if (value && (select.selected) != null)
	<expand>  : load.sp(+4)
	<expand+?>: load.is8
	<expand+?>: dup.x32 sp(0)
	<expand+?>: jz +22
	<expand+?>: inc.sp(-4)
	<expand+?>: dup.x32 sp(2)
	<expand+?>: inc.i32(+132)
	<expand+?>: load.i32
	<expand+?>: load.ref <?> ;null
	<expand+?>: ceq.i32
	<expand+?>: not.b32
	<expand+?>: jz +25
	cmplGfx/lib/micro.ui.ci:766: (17 bytes): focus(select.selected);
	<expand+?>: dup.x32 sp(2)
	<expand+?>: inc.i32(+132)
	<expand+?>: load.i32
	<expand+?>: load.ref <?> ;focus(view: View): void
	<expand+?>: call
	<expand+?>: inc.sp(-4)
	<expand+?>: jmp +21
	cmplGfx/lib/micro.ui.ci:768: (17 bytes): focus(select.header);
	<expand+?>: dup.x32 sp(2)
	<expand+?>: inc.i32(+136)
	<expand+?>: load.i32
	<expand+?>: load.ref <?> ;focus(view: View): void
	<expand+?>: call
	<expand+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:771: (34 bytes): select.header.onUpdate(select.header, int32(value));
	<expand+?>: load.z32
	<expand+?>: dup.x32 sp(3)
	<expand+?>: inc.i32(+136)
	<expand+?>: load.i32
	<expand+?>: load.sp(+12)
	<expand+?>: load.is8
	<expand+?>: dup.x32 sp(5)
	<expand+?>: inc.i32(+136)
	<expand+?>: load.i32
	<expand+?>: inc.i32(+88)
	<expand+?>: load.i32
	<expand+?>: call
	<expand+?>: inc.sp(-8)
	<expand+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:772: (27 bytes): Panel.visible(select.panel, value);
	<expand+?>: load.z32
	<expand+?>: dup.x32 sp(3)
	<expand+?>: inc.i32(+140)
	<expand+?>: load.i32
	<expand+?>: load.sp(+12)
	<expand+?>: load.is8
	<expand+?>: load.ref <?> ;Panel.visible(this: Panel, value: bool): bool
	<expand+?>: call
	<expand+?>: inc.sp(-8)
	<expand+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:773: (17 bytes): invalidate(select);
	<expand+?>: dup.x32 sp(2)
	<expand+?>: load.c32 1
	<expand+?>: load.ref <?> ;invalidate(view: View, layout: bool): void
	<expand+?>: call
	<expand+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:774: (11 bytes): return .result := true;
	<expand+?>: load.c32 1
	<expand+?>: load.sp(+16)
	<expand+?>: store.i8
	<expand+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:811: referenced as `expand`
	cmplGfx/lib/micro.ui.ci:779: referenced as `expand`
}
Select.onItemClick(select: Select, view: Button): bool: function {
.kind: static function
.base: `function`
.size: 52
.name: 'onItemClick'
.file: 'cmplGfx/lib/micro.ui.ci:777'
.owner: Select
.param .result: bool (size: 4, cast: variable(bool))
.param select: Select (size: 4, cast: variable(ref))
.param view: Button (size: 4, cast: variable(ref))
.value: {
	select.selected := view;
	expand(select, false);
	select.states[0] := (view.text);
	return .result := true;
}
.instructions: (52 bytes)
	cmplGfx/lib/micro.ui.ci:778: (9 bytes): select.selected := view;
	<onItemClick>  : dup.x32 sp(1)
	<onItemClick+?>: dup.x32 sp(3)
	<onItemClick+?>: inc.i32(+132)
	<onItemClick+?>: store.i32
	cmplGfx/lib/micro.ui.ci:779: (18 bytes): expand(select, false);
	<onItemClick+?>: load.z32
	<onItemClick+?>: dup.x32 sp(3)
	<onItemClick+?>: load.z32
	<onItemClick+?>: load.ref <?> ;Select.expand(select: Select, value: bool): bool
	<onItemClick+?>: call
	<onItemClick+?>: inc.sp(-8)
	<onItemClick+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:780: (14 bytes): select.states[0] := (view.text);
	<onItemClick+?>: dup.x32 sp(1)
	<onItemClick+?>: inc.i32(+64)
	<onItemClick+?>: load.i32
	<onItemClick+?>: dup.x32 sp(3)
	<onItemClick+?>: inc.i32(+124)
	<onItemClick+?>: store.i32
	cmplGfx/lib/micro.ui.ci:781: (11 bytes): return .result := true;
	<onItemClick+?>: load.c32 1
	<onItemClick+?>: load.sp(+16)
	<onItemClick+?>: store.i8
	<onItemClick+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:840: referenced as `onItemClick`
}
Select.setSelectedIndex(select: Select, index: int32): Select: function {
.kind: static function
.base: `function`
.size: 173
.name: 'setSelectedIndex'
.file: 'cmplGfx/lib/micro.ui.ci:785'
.owner: Select
.param .result: Select (size: 4, cast: variable(ref))
.param select: Select (size: 4, cast: variable(ref))
.param index: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	if (index < 0 || index > select.panel.itemCount) {
		error("invalid index selected", index);
		return .result := select;
	}
	button: Button := as(select.panel.items[index].view, Button);
	if ((button) == null) {
		return .result := select;
	}
	select.selected := button;
	select.states[0] := (button.text);
	return .result := select;
}
.instructions: (173 bytes)
	cmplGfx/lib/micro.ui.ci:786: (90 bytes): if (index < 0 || index > select.panel.itemCount)
	<setSelectedIndex>  : dup.x32 sp(1)
	<setSelectedIndex+?>: load.z32
	<setSelectedIndex+?>: clt.i32
	<setSelectedIndex+?>: dup.x32 sp(0)
	<setSelectedIndex+?>: jnz +23
	<setSelectedIndex+?>: inc.sp(-4)
	<setSelectedIndex+?>: dup.x32 sp(1)
	<setSelectedIndex+?>: dup.x32 sp(3)
	<setSelectedIndex+?>: inc.i32(+140)
	<setSelectedIndex+?>: load.i32
	<setSelectedIndex+?>: inc.i32(+72)
	<setSelectedIndex+?>: load.i32
	<setSelectedIndex+?>: cgt.i32
	<setSelectedIndex+?>: jz +61
	cmplGfx/lib/micro.ui.ci:787: (53 bytes): error("invalid index selected", index);
	<setSelectedIndex+?>: load.ref <?> ;int32
	<setSelectedIndex+?>: load.sp(+8)
	<setSelectedIndex+?>: load.c32 1
	<setSelectedIndex+?>: load.sp(+4)
	<setSelectedIndex+?>: load.ref <?> ;"cmplGfx/lib/micro.ui.ci"
	<setSelectedIndex+?>: load.c32 787
	<setSelectedIndex+?>: load.c32 -1
	<setSelectedIndex+?>: load.c32 128
	<setSelectedIndex+?>: load.ref <?> ;"invalid index selected"
	<setSelectedIndex+?>: dup.x64 sp(5)
	<setSelectedIndex+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<setSelectedIndex+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.ci:788: (4 bytes): return .result := select;
	<setSelectedIndex+?>: mov.x32 sp(3, 2)
	<setSelectedIndex+?>: ret
	cmplGfx/lib/micro.ui.ci:790: (32 bytes): button: Button := as(select.panel.items[index].view, Button)
	<setSelectedIndex+?>: dup.x32 sp(2)
	<setSelectedIndex+?>: inc.i32(+140)
	<setSelectedIndex+?>: load.i32
	<setSelectedIndex+?>: inc.i32(+68)
	<setSelectedIndex+?>: load.i32
	<setSelectedIndex+?>: dup.x32 sp(2)
	<setSelectedIndex+?>: mad.u32 24
	<setSelectedIndex+?>: inc.i32(+16)
	<setSelectedIndex+?>: load.i32
	<setSelectedIndex+?>: load.ref <?> ;Button
	<setSelectedIndex+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	cmplGfx/lib/micro.ui.ci:791: (20 bytes): if ((button) == null)
	<setSelectedIndex+?>: dup.x32 sp(0)
	<setSelectedIndex+?>: load.ref <?> ;null
	<setSelectedIndex+?>: ceq.i32
	<setSelectedIndex+?>: jz +12
	cmplGfx/lib/micro.ui.ci:792: (8 bytes): return .result := select;
	<setSelectedIndex+?>: mov.x32 sp(4, 3)
	<setSelectedIndex+?>: inc.sp(-4)
	<setSelectedIndex+?>: ret
	cmplGfx/lib/micro.ui.ci:795: (9 bytes): select.selected := button;
	<setSelectedIndex+?>: dup.x32 sp(0)
	<setSelectedIndex+?>: dup.x32 sp(4)
	<setSelectedIndex+?>: inc.i32(+132)
	<setSelectedIndex+?>: store.i32
	cmplGfx/lib/micro.ui.ci:796: (14 bytes): select.states[0] := (button.text);
	<setSelectedIndex+?>: dup.x32 sp(0)
	<setSelectedIndex+?>: inc.i32(+64)
	<setSelectedIndex+?>: load.i32
	<setSelectedIndex+?>: dup.x32 sp(4)
	<setSelectedIndex+?>: inc.i32(+124)
	<setSelectedIndex+?>: store.i32
	cmplGfx/lib/micro.ui.ci:797: (8 bytes): return .result := select;
	<setSelectedIndex+?>: mov.x32 sp(4, 3)
	<setSelectedIndex+?>: inc.sp(-4)
	<setSelectedIndex+?>: ret
.usages:
}
Select.addItems(this: Select, align: int32, views: View[]): Select: function {
.kind: static function
.base: `function`
.size: 749
.name: 'addItems'
.file: 'cmplGfx/lib/micro.ui.ci:801'
.owner: Select
.param .result: Select (size: 4, cast: variable(ref))
.param this: Select (size: 4, cast: variable(ref))
.param align: int32 (size: 4, cast: variable(i32))
.param views: View[] (size: 8, cast: variable(arr))
.doc: '@public'
.value: {
	static const Header: struct {
		const select: Select;
		static onReset(this: Header): bool := {
			return .result := false;
		};
		static onClick(this: Header): bool := {
			if (!Switch.onClick(this)) {
				return .result := false;
			}
			expand(this.select, checked(this));
			return .result := true;
		};
		static const onOff: char[*][] := {
			onOff := onOff.init;
			onOff.init[0] := ("off");
			onOff.init[1] := ("on");
		};
		const text: char[*];
		const states: char[*][] := onOff;
		selected: int32 := 0;
		const resetValue: int32 := 0;
		const clickToFocus: bool := true;
		static checked(this: Switch): bool := {
			return .result := this.selected != 0;
		};
		static onUpdate(this: Switch, selected: int32): bool := {
			maxValue: int32 := this.states.length;
			if (maxValue == 0) {
				maxValue := 2;
			}
			if (selected >= maxValue) {
				selected := maxValue - 1;
			}
			else if (selected < 0) {
				selected := 0;
			}
			if (this.selected == selected) {
				return .result := isDirty(this);
			}
			this.selected := selected;
			return .result := true;
		};
		const onUpdate(this: Switch, selected: int32): bool := onUpdate;
		static onReset(this: Switch): bool := {
			return .result := this.onUpdate(this, this.resetValue);
		};
		static onClick(this: Switch): bool := {
			if (this.focusable && this.clickToFocus) {
				if (!isFocused(this)) {
					return .result := true;
				}
			}
			maxValue: int32 := this.states.length;
			value: int32 := this.selected + 1;
			if (maxValue == 0) {
				maxValue := 2;
			}
			if (value >= maxValue) {
				value := 0;
			}
			return .result := this.onUpdate(this, value);
		};
		static onCreate(this: Switch, parent: View): void := {
			View.onCreate(this, parent);
			resetValue: int32 := pointer(this.resetValue);
			Switch.onUpdate(this, this.selected);
			resetValue := this.selected;
			this.onReset(this);
		};
		static onKeyEvent(this: Switch, const event: KeyEvent): bool := {
			if (!this.enabled || event.release) {
				return .result := View.onKeyEvent(this, event);
			}
			if (event.key == ('+') || event.key == ('=')) {
				value: int32 := this.selected + 1;
				return .result := this.onUpdate(this, value);
			}
			if (event.key == ('-') || event.key == ('_')) {
				value: int32 := this.selected - 1;
				return .result := this.onUpdate(this, value);
			}
			return .result := View.onKeyEvent(this, event);
		};
		static onTouchEvent(this: Switch, const rect: Rect, const event: TouchEvent): bool := {
			if (!this.enabled || !event.release) {
				return .result := View.onTouchEvent(this, rect, event);
			}
			if (event.isShift && event.clicks >= 0) {
				value: int32 := this.selected - 1;
				return .result := this.onUpdate(this, value);
			}
			return .result := View.onTouchEvent(this, rect, event);
		};
		static onMeasure(this: Switch, rect: Rect): bool := {
			maxWidth: int32 := 0;
			style: Style := this.style;
			for (i: int32 := 0; i < (this.states.length); i := i + 1) {
				measured: Rect := {
					measured.x0 := 0;
					measured.y0 := 0;
					measured.x1 := 0;
					measured.y1 := 0;
				};
				Style.measure(style, &measured, this.states[i]);
				if (maxWidth < width(measured)) {
					maxWidth := width(measured);
				}
			}
			Style.measure(style, &rect, this.text);
			if (this.states.length == (0)) {
				width(rect, width(rect) + height(rect) * 3 / 2);
			}
			else {
				width(rect, width(rect) + maxWidth);
			}
			return .result := View.onMeasure(this, &rect);
		};
		static onDraw(this: Switch, offs: Image, rect: Rect): void := {
			value: char[*] := null;
			style: Style := this.style;
			if (this.states.length == (0)) {
				onOffRect: Rect := {
					onOffRect.x0 := rect.x0;
					onOffRect.y0 := rect.y0;
					onOffRect.x1 := rect.x0 + height(rect) * 3 / 2;
					onOffRect.y1 := rect.y1;
				};
				Style.align(rect, &onOffRect, Style.right);
				rect.x1 := onOffRect.x0;
				padded(onOffRect, -style.padding);
				color: uint32 := style.focusedColor;
				if (checked(this)) {
					color := style.valueColor;
				}
				else if (isFocused(this)) {
					color := style.hoveredColor;
				}
				fillRRect(offs, onOffRect, height(onOffRect) / 2, color);
				if (checked(this)) {
					onOffRect.x0 := onOffRect.x1 - height(onOffRect);
				}
				else {
					onOffRect.x1 := onOffRect.x0 + height(onOffRect);
				}
				padded(onOffRect, -style.padding / 3);
				fillOval(offs, onOffRect, style.textColor);
			}
			else {
				value := (this.states[this.selected]);
			}
			View.onDraw(this, offs, rect, this.text, value);
		};
		const width: int32 := -5;
		const height: int32 := -5;
		enabled: bool := true;
		focusable: bool := true;
		parent: View := null;
		style: Style := null;
		data: variant := null;
		static parent(this: View): View := {
			return .result := this.parent;
		};
		static onClick(this: View): bool := {
			return .result := true;
		};
		const onClick(this: View): bool := onClick;
		static onReset(this: View): bool := {
			return .result := false;
		};
		const onReset(this: View): bool := onReset;
		static onCreate(this: View, parent: View): void := {
			assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
			this.parent := parent;
			if ((this.style) == null) {
				assert((parent.style) != null, "can not create view with a parent without a style");
				this.style := emit(pointer(parent.style));
			}
		};
		const onCreate(this: View, parent: View): void := onCreate;
		static onDestroy(this: View): void := {
		};
		const onDestroy(this: View): void := onDestroy;
		static onKeyEvent(this: View, const event: KeyEvent): bool := {
			if (!this.enabled) {
				return .result := false;
			}
			if (event.release) {
				return .result := false;
			}
			if (event.key == (' ')) {
				return .result := this.onClick(this);
			}
			if ((event.key) == Window.KEY_CODE_BACK) {
				return .result := this.onReset(this);
			}
			return .result := false;
		};
		const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
		static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
			if (!this.enabled) {
				return .result := false;
			}
			if (!event.release) {
				return .result := false;
			}
			if (event.clicks < 0) {
				return .result := this.onReset(this);
			}
			if (event.clicks > 1) {
				if (this.onReset(this)) {
					return .result := true;
				}
			}
			return .result := this.onClick(this);
		};
		const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
		static onMeasure(this: View, rect: Rect): bool := {
			width: int32 := Math.abs(this.width);
			if (width(rect) < width || this.width > 0) {
				width(rect, width);
			}
			height: int32 := Math.abs(this.height);
			if (height(rect) < height || this.height > 0) {
				height(rect, height);
			}
			return .result := true;
		};
		const onMeasure(this: View, rect: Rect): bool := onMeasure;
		onDraw(this: View, offs: Image, rect: Rect): void;
		static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
			const style: Style := this.style;
			if (state & Style.focused) {
				fillRect(offs, rect, style.focusedColor);
			}
			else if (state & Style.hovered) {
				fillRect(offs, rect, style.hoveredColor);
			}
			else if ((this.parent.style) != pointer(style)) {
				fillRect(offs, rect, style.backgroundColor);
			}
			this.onDraw(this, offs, rect);
			if (state & Style.pressed) {
				drawRect(offs, rect, style.valueColor);
			}
		};
		static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
			const style: Style := this.style;
			if ((text) == null) {
				Style.align(style, rect, &rect, value);
				Image.drawText(offs, rect, style.font, value, style.valueColor);
				return;
			}
			if ((value) != null) {
				valueRoi: Rect := rect;
				Style.align(style, valueRoi, &valueRoi, value, Style.right);
				Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
				rect.x1 := valueRoi.x0 - style.padding;
			}
			Style.align(style, rect, &rect, text);
			Image.drawText(offs, rect, style.font, text, style.textColor);
		};
		const .type: typename;
		static const create(type: typename): pointer := nfc(7);
		static const destroy(this: object): void := nfc(8);
		static const as(this: object, type: typename): pointer := nfc(9);
		static const type(this: object): typename := nfc(10);
	};
	if (this.itemCount == 0) {
		header: Header := {
			header := create(Header);
			header.text := (this.text);
			header.states := (this.states);
			header.clickToFocus := false;
			header.select := this;
			header.selected := 0;
			header.resetValue := 0;
			header.onUpdate := onUpdate;
			header.width := -5;
			header.height := -5;
			header.enabled := true;
			header.focusable := true;
			header.parent := (null);
			header.style := (null);
			header.data := (null);
			header.onClick := onClick;
			header.onReset := onReset;
			header.onCreate := onCreate;
			header.onDestroy := onDestroy;
			header.onKeyEvent := onKeyEvent;
			header.onTouchEvent := onTouchEvent;
			header.onMeasure := onMeasure;
			header.onDraw := onDraw;
		};
		panel: Panel := {
			panel := create(Panel);
			panel.visible := false;
			panel.separator := (null);
			panel.items := (null);
			panel.itemCount := 0;
			panel.itemCapacity := 0;
			panel.hoveredIndex := -1;
			panel.pressedIndex := -1;
			panel.focusedIndex := -1;
			panel.paddingTop := 0;
			panel.paddingLeft := 0;
			panel.paddingRight := 0;
			panel.paddingBottom := 0;
			panel.orientation := 1;
			panel.onLayout := onLayout;
			panel.width := -5;
			panel.height := -5;
			panel.enabled := true;
			panel.focusable := true;
			panel.parent := (null);
			panel.style := (null);
			panel.data := (null);
			panel.onClick := onClick;
			panel.onReset := onReset;
			panel.onCreate := onCreate;
			panel.onDestroy := onDestroy;
			panel.onKeyEvent := onKeyEvent;
			panel.onTouchEvent := onTouchEvent;
			panel.onMeasure := onMeasure;
			panel.onDraw := onDraw;
		};
		this.states[0] := ("<");
		this.states[1] := ("^");
		this.header := (header);
		this.panel := panel;
		Layout.addItems(this, align, header, panel);
	}
	Layout.addItems(this.panel, align, ...views);
	return .result := this;
}
.instructions: (749 bytes)
	cmplGfx/lib/micro.ui.ci:815: (716 bytes): if (this.itemCount == 0)
	<addItems>  : dup.x32 sp(4)
	<addItems+?>: inc.i32(+72)
	<addItems+?>: load.i32
	<addItems+?>: load.z32
	<addItems+?>: ceq.i32
	<addItems+?>: jz +707
	cmplGfx/lib/micro.ui.ci:816: (277 bytes): header: Header := {...}
	<addItems+?>: inc.sp(+4)
	cmplGfx/lib/micro.ui.ci:816: (11 bytes): header := create(Header);
	<addItems+?>: load.ref <?> ;Select.addItems.Header
	<addItems+?>: nfc(7) ;object.create(type: typename): pointer
	<addItems+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:817: (14 bytes): header.text := (this.text);
	<addItems+?>: dup.x32 sp(5)
	<addItems+?>: inc.i32(+116)
	<addItems+?>: load.i32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+64)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:818: (18 bytes): header.states := (this.states);
	<addItems+?>: load.c32 2
	<addItems+?>: dup.x32 sp(6)
	<addItems+?>: inc.i32(+124)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: inc.i32(+68)
	<addItems+?>: store.i64
	cmplGfx/lib/micro.ui.ci:819: (8 bytes): header.clickToFocus := false;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+84)
	<addItems+?>: store.i8
	cmplGfx/lib/micro.ui.ci:820: (9 bytes): header.select := this;
	<addItems+?>: dup.x32 sp(5)
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+92)
	<addItems+?>: store.i32
	:: (8 bytes): header.selected := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+76)
	<addItems+?>: store.i32
	:: (8 bytes): header.resetValue := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+80)
	<addItems+?>: store.i32
	:: (12 bytes): header.onUpdate := onUpdate;
	<addItems+?>: load.ref <?> ;Switch.onUpdate(this: Switch, selected: int32): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+88)
	<addItems+?>: store.i32
	:: (12 bytes): header.width := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+4)
	<addItems+?>: store.i32
	:: (12 bytes): header.height := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+8)
	<addItems+?>: store.i32
	:: (12 bytes): header.enabled := true;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+12)
	<addItems+?>: store.i8
	:: (12 bytes): header.focusable := true;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+13)
	<addItems+?>: store.i8
	:: (12 bytes): header.parent := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+16)
	<addItems+?>: store.i32
	:: (12 bytes): header.style := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+20)
	<addItems+?>: store.i32
	:: (17 bytes): header.data := (null);
	<addItems+?>: load.ref <?> ;pointer
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: inc.i32(+24)
	<addItems+?>: store.i64
	:: (12 bytes): header.onClick := onClick;
	<addItems+?>: load.ref <?> ;Select.addItems.Header.onClick(this: Header): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+32)
	<addItems+?>: store.i32
	:: (12 bytes): header.onReset := onReset;
	<addItems+?>: load.ref <?> ;Select.addItems.Header.onReset(this: Header): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+36)
	<addItems+?>: store.i32
	:: (12 bytes): header.onCreate := onCreate;
	<addItems+?>: load.ref <?> ;Switch.onCreate(this: Switch, parent: View): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+40)
	<addItems+?>: store.i32
	:: (12 bytes): header.onDestroy := onDestroy;
	<addItems+?>: load.ref <?> ;View.onDestroy(this: View): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+44)
	<addItems+?>: store.i32
	:: (12 bytes): header.onKeyEvent := onKeyEvent;
	<addItems+?>: load.ref <?> ;Switch.onKeyEvent(this: Switch, event: KeyEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+48)
	<addItems+?>: store.i32
	:: (12 bytes): header.onTouchEvent := onTouchEvent;
	<addItems+?>: load.ref <?> ;Switch.onTouchEvent(this: Switch, rect: Rect, event: TouchEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+52)
	<addItems+?>: store.i32
	:: (12 bytes): header.onMeasure := onMeasure;
	<addItems+?>: load.ref <?> ;Switch.onMeasure(this: Switch, rect: Rect): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+56)
	<addItems+?>: store.i32
	:: (12 bytes): header.onDraw := onDraw;
	<addItems+?>: load.ref <?> ;Switch.onDraw(this: Switch, offs: Image, rect: Rect): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+60)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:822: (340 bytes): panel: Panel := {...}
	<addItems+?>: inc.sp(+4)
	cmplGfx/lib/micro.ui.ci:822: (11 bytes): panel := create(Panel);
	<addItems+?>: load.ref <?> ;Panel
	<addItems+?>: nfc(7) ;object.create(type: typename): pointer
	<addItems+?>: set.x32 sp(1)
	:: (8 bytes): panel.visible := false;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+116)
	<addItems+?>: store.i8
	:: (12 bytes): panel.separator := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+64)
	<addItems+?>: store.i32
	:: (12 bytes): panel.items := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+68)
	<addItems+?>: store.i32
	:: (8 bytes): panel.itemCount := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+72)
	<addItems+?>: store.i32
	:: (8 bytes): panel.itemCapacity := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+76)
	<addItems+?>: store.i32
	:: (12 bytes): panel.hoveredIndex := -1;
	<addItems+?>: load.c32 -1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+80)
	<addItems+?>: store.i32
	:: (12 bytes): panel.pressedIndex := -1;
	<addItems+?>: load.c32 -1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+84)
	<addItems+?>: store.i32
	:: (12 bytes): panel.focusedIndex := -1;
	<addItems+?>: load.c32 -1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+88)
	<addItems+?>: store.i32
	:: (8 bytes): panel.paddingTop := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+92)
	<addItems+?>: store.i32
	:: (8 bytes): panel.paddingLeft := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+96)
	<addItems+?>: store.i32
	:: (8 bytes): panel.paddingRight := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+100)
	<addItems+?>: store.i32
	:: (8 bytes): panel.paddingBottom := 0;
	<addItems+?>: load.z32
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+104)
	<addItems+?>: store.i32
	:: (12 bytes): panel.orientation := 1;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+108)
	<addItems+?>: store.i32
	:: (12 bytes): panel.onLayout := onLayout;
	<addItems+?>: load.ref <?> ;Layout.onLayout(this: Layout, measured: Rect): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+112)
	<addItems+?>: store.i32
	:: (12 bytes): panel.width := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+4)
	<addItems+?>: store.i32
	:: (12 bytes): panel.height := -5;
	<addItems+?>: load.c32 -5
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+8)
	<addItems+?>: store.i32
	:: (12 bytes): panel.enabled := true;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+12)
	<addItems+?>: store.i8
	:: (12 bytes): panel.focusable := true;
	<addItems+?>: load.c32 1
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+13)
	<addItems+?>: store.i8
	:: (12 bytes): panel.parent := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+16)
	<addItems+?>: store.i32
	:: (12 bytes): panel.style := (null);
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+20)
	<addItems+?>: store.i32
	:: (17 bytes): panel.data := (null);
	<addItems+?>: load.ref <?> ;pointer
	<addItems+?>: load.ref <?> ;null
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: inc.i32(+24)
	<addItems+?>: store.i64
	:: (12 bytes): panel.onClick := onClick;
	<addItems+?>: load.ref <?> ;Layout.onClick(this: Layout): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+32)
	<addItems+?>: store.i32
	:: (12 bytes): panel.onReset := onReset;
	<addItems+?>: load.ref <?> ;Layout.onReset(this: Layout): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+36)
	<addItems+?>: store.i32
	:: (12 bytes): panel.onCreate := onCreate;
	<addItems+?>: load.ref <?> ;Layout.onCreate(this: Layout, parent: View): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+40)
	<addItems+?>: store.i32
	:: (12 bytes): panel.onDestroy := onDestroy;
	<addItems+?>: load.ref <?> ;Layout.onDestroy(this: Layout): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+44)
	<addItems+?>: store.i32
	:: (12 bytes): panel.onKeyEvent := onKeyEvent;
	<addItems+?>: load.ref <?> ;Layout.onKeyEvent(this: Layout, event: KeyEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+48)
	<addItems+?>: store.i32
	:: (12 bytes): panel.onTouchEvent := onTouchEvent;
	<addItems+?>: load.ref <?> ;Layout.onTouchEvent(this: Layout, rect: Rect, event: TouchEvent): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+52)
	<addItems+?>: store.i32
	:: (12 bytes): panel.onMeasure := onMeasure;
	<addItems+?>: load.ref <?> ;Panel.onMeasure(this: Panel, rect: Rect): bool
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+56)
	<addItems+?>: store.i32
	:: (12 bytes): panel.onDraw := onDraw;
	<addItems+?>: load.ref <?> ;Layout.onDraw(this: Layout, offs: Image, parent: Rect): void
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: inc.i32(+60)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:824: (12 bytes): this.states[0] := ("<");
	<addItems+?>: load.ref <?> ;"<"
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: inc.i32(+124)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:825: (12 bytes): this.states[1] := ("^");
	<addItems+?>: load.ref <?> ;"^"
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: inc.i32(+128)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:826: (9 bytes): this.header := (header);
	<addItems+?>: dup.x32 sp(1)
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: inc.i32(+136)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:827: (9 bytes): this.panel := panel;
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: dup.x32 sp(7)
	<addItems+?>: inc.i32(+140)
	<addItems+?>: store.i32
	cmplGfx/lib/micro.ui.ci:828: (40 bytes): Layout.addItems(this, align, header, panel);
	<addItems+?>: dup.x32 sp(0)
	<addItems+?>: dup.x32 sp(2)
	<addItems+?>: load.c32 2
	<addItems+?>: load.sp(+4)
	<addItems+?>: inc.sp(+4)
	<addItems+?>: dup.x32 sp(11)
	<addItems+?>: dup.x32 sp(11)
	<addItems+?>: dup.x64 sp(3)
	<addItems+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<addItems+?>: call
	<addItems+?>: mov.x32 sp(8, 4)
	<addItems+?>: inc.sp(-32)
	<addItems+?>: inc.sp(-4)
	<addItems+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:831: (29 bytes): Layout.addItems(this.panel, align, ...views);
	<addItems+?>: inc.sp(+4)
	<addItems+?>: dup.x32 sp(5)
	<addItems+?>: inc.i32(+140)
	<addItems+?>: load.i32
	<addItems+?>: dup.x32 sp(5)
	<addItems+?>: dup.x64 sp(4)
	<addItems+?>: load.ref <?> ;Layout.addItems(this: Layout, alignment: int32, views: View[]): Layout
	<addItems+?>: call
	<addItems+?>: inc.sp(-16)
	<addItems+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:832: (4 bytes): return .result := this;
	<addItems+?>: mov.x32 sp(5, 4)
	<addItems+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:848: referenced as `addItems`
}
Select.addItem(this: Select, text: char[*], data: variant): Select: function {
.kind: static function
.base: `function`
.size: 259
.name: 'addItem'
.file: 'cmplGfx/lib/micro.ui.ci:836'
.owner: Select
.param .result: Select (size: 4, cast: variable(ref))
.param this: Select (size: 4, cast: variable(ref))
.param text: char[*] (size: 4, cast: const variable(ref))
.param data: variant (size: 8, cast: variable(var))
.doc: '@public'
.value: {
	static const SelectItem: struct {
		const select: Select;
		static onClick(this: SelectItem): bool := {
			return .result := onItemClick(this.select, this);
		};
		const text: char[*];
		static onMeasure(this: Button, rect: Rect): bool := {
			style: Style := this.style;
			Style.measure(style, &rect, this.text);
			return .result := View.onMeasure(this, &rect);
		};
		static onDraw(this: Button, offs: Image, rect: Rect): void := {
			View.onDraw(this, offs, rect, null, this.text);
		};
		const width: int32 := -5;
		const height: int32 := -5;
		enabled: bool := true;
		focusable: bool := true;
		parent: View := null;
		style: Style := null;
		data: variant := null;
		static parent(this: View): View := {
			return .result := this.parent;
		};
		static onClick(this: View): bool := {
			return .result := true;
		};
		const onClick(this: View): bool := onClick;
		static onReset(this: View): bool := {
			return .result := false;
		};
		const onReset(this: View): bool := onReset;
		static onCreate(this: View, parent: View): void := {
			assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
			this.parent := parent;
			if ((this.style) == null) {
				assert((parent.style) != null, "can not create view with a parent without a style");
				this.style := emit(pointer(parent.style));
			}
		};
		const onCreate(this: View, parent: View): void := onCreate;
		static onDestroy(this: View): void := {
		};
		const onDestroy(this: View): void := onDestroy;
		static onKeyEvent(this: View, const event: KeyEvent): bool := {
			if (!this.enabled) {
				return .result := false;
			}
			if (event.release) {
				return .result := false;
			}
			if (event.key == (' ')) {
				return .result := this.onClick(this);
			}
			if ((event.key) == Window.KEY_CODE_BACK) {
				return .result := this.onReset(this);
			}
			return .result := false;
		};
		const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
		static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
			if (!this.enabled) {
				return .result := false;
			}
			if (!event.release) {
				return .result := false;
			}
			if (event.clicks < 0) {
				return .result := this.onReset(this);
			}
			if (event.clicks > 1) {
				if (this.onReset(this)) {
					return .result := true;
				}
			}
			return .result := this.onClick(this);
		};
		const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
		static onMeasure(this: View, rect: Rect): bool := {
			width: int32 := Math.abs(this.width);
			if (width(rect) < width || this.width > 0) {
				width(rect, width);
			}
			height: int32 := Math.abs(this.height);
			if (height(rect) < height || this.height > 0) {
				height(rect, height);
			}
			return .result := true;
		};
		const onMeasure(this: View, rect: Rect): bool := onMeasure;
		onDraw(this: View, offs: Image, rect: Rect): void;
		static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
			const style: Style := this.style;
			if (state & Style.focused) {
				fillRect(offs, rect, style.focusedColor);
			}
			else if (state & Style.hovered) {
				fillRect(offs, rect, style.hoveredColor);
			}
			else if ((this.parent.style) != pointer(style)) {
				fillRect(offs, rect, style.backgroundColor);
			}
			this.onDraw(this, offs, rect);
			if (state & Style.pressed) {
				drawRect(offs, rect, style.valueColor);
			}
		};
		static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
			const style: Style := this.style;
			if ((text) == null) {
				Style.align(style, rect, &rect, value);
				Image.drawText(offs, rect, style.font, value, style.valueColor);
				return;
			}
			if ((value) != null) {
				valueRoi: Rect := rect;
				Style.align(style, valueRoi, &valueRoi, value, Style.right);
				Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
				rect.x1 := valueRoi.x0 - style.padding;
			}
			Style.align(style, rect, &rect, text);
			Image.drawText(offs, rect, style.font, text, style.textColor);
		};
		const .type: typename;
		static const create(type: typename): pointer := nfc(7);
		static const destroy(this: object): void := nfc(8);
		static const as(this: object, type: typename): pointer := nfc(9);
		static const type(this: object): typename := nfc(10);
	};
	item: SelectItem := {
		item := create(SelectItem);
		item.select := this;
		item.text := (text);
		item.data := data;
		item.width := -5;
		item.height := -5;
		item.enabled := true;
		item.focusable := true;
		item.parent := (null);
		item.style := (null);
		item.onClick := onClick;
		item.onReset := onReset;
		item.onCreate := onCreate;
		item.onDestroy := onDestroy;
		item.onKeyEvent := onKeyEvent;
		item.onTouchEvent := onTouchEvent;
		item.onMeasure := onMeasure;
		item.onDraw := onDraw;
	};
	Select.addItems(this, Style.fill, item);
	return .result := this;
}
.instructions: (259 bytes)
	cmplGfx/lib/micro.ui.ci:843: (210 bytes): item: SelectItem := {...}
	<addItem>  : inc.sp(+4)
	cmplGfx/lib/micro.ui.ci:843: (11 bytes): item := create(SelectItem);
	<addItem+?>: load.ref <?> ;Select.addItem.SelectItem
	<addItem+?>: nfc(7) ;object.create(type: typename): pointer
	<addItem+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:844: (9 bytes): item.select := this;
	<addItem+?>: dup.x32 sp(5)
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+68)
	<addItem+?>: store.i32
	cmplGfx/lib/micro.ui.ci:845: (9 bytes): item.text := (text);
	<addItem+?>: dup.x32 sp(4)
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+64)
	<addItem+?>: store.i32
	cmplGfx/lib/micro.ui.ci:846: (9 bytes): item.data := data;
	<addItem+?>: dup.x64 sp(2)
	<addItem+?>: dup.x32 sp(2)
	<addItem+?>: inc.i32(+24)
	<addItem+?>: store.i64
	:: (12 bytes): item.width := -5;
	<addItem+?>: load.c32 -5
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+4)
	<addItem+?>: store.i32
	:: (12 bytes): item.height := -5;
	<addItem+?>: load.c32 -5
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+8)
	<addItem+?>: store.i32
	:: (12 bytes): item.enabled := true;
	<addItem+?>: load.c32 1
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+12)
	<addItem+?>: store.i8
	:: (12 bytes): item.focusable := true;
	<addItem+?>: load.c32 1
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+13)
	<addItem+?>: store.i8
	:: (12 bytes): item.parent := (null);
	<addItem+?>: load.ref <?> ;null
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+16)
	<addItem+?>: store.i32
	:: (12 bytes): item.style := (null);
	<addItem+?>: load.ref <?> ;null
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+20)
	<addItem+?>: store.i32
	:: (12 bytes): item.onClick := onClick;
	<addItem+?>: load.ref <?> ;Select.addItem.SelectItem.onClick(this: SelectItem): bool
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+32)
	<addItem+?>: store.i32
	:: (12 bytes): item.onReset := onReset;
	<addItem+?>: load.ref <?> ;View.onReset(this: View): bool
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+36)
	<addItem+?>: store.i32
	:: (12 bytes): item.onCreate := onCreate;
	<addItem+?>: load.ref <?> ;View.onCreate(this: View, parent: View): void
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+40)
	<addItem+?>: store.i32
	:: (12 bytes): item.onDestroy := onDestroy;
	<addItem+?>: load.ref <?> ;View.onDestroy(this: View): void
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+44)
	<addItem+?>: store.i32
	:: (12 bytes): item.onKeyEvent := onKeyEvent;
	<addItem+?>: load.ref <?> ;View.onKeyEvent(this: View, event: KeyEvent): bool
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+48)
	<addItem+?>: store.i32
	:: (12 bytes): item.onTouchEvent := onTouchEvent;
	<addItem+?>: load.ref <?> ;View.onTouchEvent(this: View, rect: Rect, event: TouchEvent): bool
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+52)
	<addItem+?>: store.i32
	:: (12 bytes): item.onMeasure := onMeasure;
	<addItem+?>: load.ref <?> ;Button.onMeasure(this: Button, rect: Rect): bool
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+56)
	<addItem+?>: store.i32
	:: (12 bytes): item.onDraw := onDraw;
	<addItem+?>: load.ref <?> ;Button.onDraw(this: Button, offs: Image, rect: Rect): void
	<addItem+?>: dup.x32 sp(1)
	<addItem+?>: inc.i32(+60)
	<addItem+?>: store.i32
	cmplGfx/lib/micro.ui.ci:848: (41 bytes): Select.addItems(this, Style.fill, item);
	<addItem+?>: dup.x32 sp(0)
	<addItem+?>: load.c32 1
	<addItem+?>: load.sp(+4)
	<addItem+?>: inc.sp(+4)
	<addItem+?>: dup.x32 sp(9)
	<addItem+?>: load.c32 15
	<addItem+?>: dup.x64 sp(3)
	<addItem+?>: load.ref <?> ;Select.addItems(this: Select, align: int32, views: View[]): Select
	<addItem+?>: call
	<addItem+?>: mov.x32 sp(7, 4)
	<addItem+?>: inc.sp(-28)
	<addItem+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:849: (8 bytes): return .result := this;
	<addItem+?>: mov.x32 sp(6, 5)
	<addItem+?>: inc.sp(-4)
	<addItem+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:854: referenced as `addItem`
}
Select.addItem(this: Select, text: char[*]): Select: function {
.kind: static function
.base: `function`
.size: 28
.name: 'addItem'
.file: 'cmplGfx/lib/micro.ui.ci:853'
.owner: Select
.param .result: Select (size: 4, cast: variable(ref))
.param this: Select (size: 4, cast: variable(ref))
.param text: char[*] (size: 4, cast: const variable(ref))
.doc: '@public'
.value: {
	return .result := addItem(this, text, text);
}
.instructions: (28 bytes)
	cmplGfx/lib/micro.ui.ci:854: (28 bytes): return .result := addItem(this, text, text);
	<addItem>  : inc.sp(+4)
	<addItem+?>: dup.x32 sp(3)
	<addItem+?>: dup.x32 sp(3)
	<addItem+?>: load.ref <?>
	<addItem+?>: dup.x32 sp(5)
	<addItem+?>: load.ref <?> ;Select.addItem(this: Select, text: char[*], data: variant): Select
	<addItem+?>: call
	<addItem+?>: inc.sp(-16)
	<addItem+?>: set.x32 sp(4)
	<addItem+?>: ret
.usages:
}
FxWidget: Widget {
.kind: static const typename(ref)
.base: `Widget`
.size: 152
.name: 'FxWidget'
.file: 'cmplGfx/lib/micro.ui.ci:859'
.field showOriginal: bool (size: 1, cast: variable(bool))
.field align: int32 (size: 4, cast: variable(i32))
.field margin: int32 (size: 4, cast: variable(i32))
.field radius: int32 (size: 4, cast: variable(i32))
.field onTouchEvent: function (size: 213, cast: static function)
.field onKeyEvent: function (size: 637, cast: static function)
.field onMeasure: function (size: 164, cast: static function)
.field onDraw: function (size: 131, cast: static function)
.field onProcess: function (size: 1, cast: static function)
.field onProcess: function (size: 4, cast: const variable(ref))
.field measure: bool (size: 1, cast: variable(bool))
.field redraw: bool (size: 1, cast: variable(bool))
.field focus: View (size: 4, cast: variable(ref))
.field scrollX: int32 (size: 4, cast: variable(i32))
.field scrollY: int32 (size: 4, cast: variable(i32))
.field focusNext: function (size: 505, cast: static function)
.field addItems: function (size: 28, cast: static function)
.field addItems: function (size: 31, cast: static function)
.field focus: function (size: 13, cast: static function)
.field padding: function (size: 32, cast: static function)
.field padding: function (size: 32, cast: static function)
.field padding: function (size: 32, cast: static function)
.field onCreate: function (size: 72, cast: static function)
.field onKeyEvent: function (size: 184, cast: static function)
.field onMeasure: function (size: 46, cast: static function)
.field onDraw: function (size: 45, cast: static function)
.field Item: typename (size: 24, cast: static const typename(val))
.field separator: View (size: 4, cast: variable(ref))
.field items: Layout.Item[*] (size: 4, cast: variable(ref))
.field itemCount: int32 (size: 4, cast: variable(i32))
.field itemCapacity: int32 (size: 4, cast: variable(i32))
.field hoveredIndex: int32 (size: 4, cast: variable(i32))
.field pressedIndex: int32 (size: 4, cast: variable(i32))
.field focusedIndex: int32 (size: 4, cast: variable(i32))
.field paddingTop: int32 (size: 4, cast: variable(i32))
.field paddingLeft: int32 (size: 4, cast: variable(i32))
.field paddingRight: int32 (size: 4, cast: variable(i32))
.field paddingBottom: int32 (size: 4, cast: variable(i32))
.field orientation: int32 (size: 4, cast: variable(i32))
.field clearState: function (size: 396, cast: static function)
.field getPressed: function (size: 114, cast: static function)
.field getFocused: function (size: 114, cast: static function)
.field setFocused: function (size: 283, cast: static function)
.field capacity: function (size: 175, cast: static function)
.field addItems: function (size: 204, cast: static function)
.field size: function (size: 10, cast: static function)
.field getView: function (size: 94, cast: static function)
.field setAlignment: function (size: 94, cast: static function)
.field padding: function (size: 56, cast: static function)
.field onClick: function (size: 58, cast: static function)
.field onReset: function (size: 94, cast: static function)
.field onCreate: function (size: 141, cast: static function)
.field onDestroy: function (size: 86, cast: static function)
.field onKeyEvent: function (size: 89, cast: static function)
.field onTouchEvent: function (size: 799, cast: static function)
.field onMeasure: function (size: 448, cast: static function)
.field onLayout: function (size: 411, cast: static function)
.field onLayout: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 180, cast: static function)
.field Custom: function (size: 364, cast: static function)
.field Row: function (size: 29, cast: static function)
.field Column: function (size: 29, cast: static function)
.field Stack: function (size: 25, cast: static function)
.field width: int32 (size: 4, cast: const variable(i32))
.field height: int32 (size: 4, cast: const variable(i32))
.field enabled: bool (size: 1, cast: variable(bool))
.field focusable: bool (size: 1, cast: variable(bool))
.field parent: View (size: 4, cast: variable(ref))
.field style: Style (size: 4, cast: variable(ref))
.field data: variant (size: 8, cast: variable(var))
.field parent: function (size: 10, cast: static function)
.field onClick: function (size: 11, cast: static function)
.field onClick: function (size: 4, cast: const variable(ref))
.field onReset: function (size: 7, cast: static function)
.field onReset: function (size: 4, cast: const variable(ref))
.field onCreate: function (size: 183, cast: static function)
.field onCreate: function (size: 4, cast: const variable(ref))
.field onDestroy: function (size: 1, cast: static function)
.field onDestroy: function (size: 4, cast: const variable(ref))
.field onKeyEvent: function (size: 120, cast: static function)
.field onKeyEvent: function (size: 4, cast: const variable(ref))
.field onTouchEvent: function (size: 134, cast: static function)
.field onTouchEvent: function (size: 4, cast: const variable(ref))
.field onMeasure: function (size: 181, cast: static function)
.field onMeasure: function (size: 4, cast: const variable(ref))
.field onDraw: function (size: 4, cast: variable(ref))
.field onDraw: function (size: 181, cast: static function)
.field onDraw: function (size: 202, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Widget used to display controls in image processing demos'
.usages:
	cmplGfx/lib/micro.ui.ci:1332: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:1332: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:1025: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:1024: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:1005: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:1000: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:1000: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:979: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:967: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:949: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:895: referenced as `FxWidget`
	cmplGfx/lib/micro.ui.ci:870: referenced as `FxWidget`
}
FxWidget.showOriginal: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'showOriginal'
.file: 'cmplGfx/lib/micro.ui.ci:861'
.owner: FxWidget
.doc: '@public'
.value: false
.usages:
	cmplGfx/lib/micro.ui.ci:934: referenced as `showOriginal`
	cmplGfx/lib/micro.ui.ci:898: referenced as `showOriginal`
	cmplGfx/lib/micro.ui.ci:897: referenced as `showOriginal`
	internal usages: 1
}
FxWidget.align: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'align'
.file: 'cmplGfx/lib/micro.ui.ci:863'
.owner: FxWidget
.doc: '@public'
.value: Style.fill
.usages:
	cmplGfx/lib/micro.ui.ci:1008: referenced as `align`
	cmplGfx/lib/micro.ui.ci:951: referenced as `align`
	cmplGfx/lib/micro.ui.ci:925: referenced as `align`
	cmplGfx/lib/micro.ui.ci:920: referenced as `align`
	cmplGfx/lib/micro.ui.ci:917: referenced as `align`
	cmplGfx/lib/micro.ui.ci:912: referenced as `align`
}
FxWidget.margin: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'margin'
.file: 'cmplGfx/lib/micro.ui.ci:865'
.owner: FxWidget
.doc: '@public'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1007: referenced as `margin`
	cmplGfx/lib/micro.ui.ci:950: referenced as `margin`
}
FxWidget.radius: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'radius'
.file: 'cmplGfx/lib/micro.ui.ci:867'
.owner: FxWidget
.doc: '@public'
.value: 0
.usages:
	cmplGfx/lib/micro.ui.ci:1006: referenced as `radius`
	cmplGfx/lib/micro.ui.ci:972: referenced as `radius`
}
FxWidget.onTouchEvent(this: FxWidget, rect: Rect, event: TouchEvent): bool: function {
.kind: static function
.base: `function`
.size: 213
.name: 'onTouchEvent'
.file: 'cmplGfx/lib/micro.ui.ci:870'
.owner: FxWidget
.param .result: bool (size: 4, cast: variable(bool))
.param this: FxWidget (size: 4, cast: variable(ref))
.param rect: Rect (size: 4, cast: const variable(ref))
.param event: TouchEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a TouchEvent: press, motion or release'
.value: {
	if (Widget.onTouchEvent(this, rect, event)) {
		return .result := true;
	}
	if (!((event.button) && ((event.dx) || (event.dy)))) {
		return .result := false;
	}
	if (this.pressedIndex != -1) {
		return .result := false;
	}
	view: View := Widget.getFocused(this);
	if ((view) == null) {
		return .result := false;
	}
	parent: Layout := as(view.parent, Layout);
	r: Rect := parent.items[parent.focusedIndex].rect;
	return .result := view.onTouchEvent(view, r, event);
}
.instructions: (213 bytes)
	cmplGfx/lib/micro.ui.ci:871: (32 bytes): if (Widget.onTouchEvent(this, rect, event))
	<onTouchEvent>  : load.z32
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.ref <?> ;Layout.onTouchEvent(this: Layout, rect: Rect, event: TouchEvent): bool
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: jz +15
	cmplGfx/lib/micro.ui.ci:872: (11 bytes): return .result := true;
	<onTouchEvent+?>: load.c32 1
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:875: (55 bytes): if (!((event.button) && ((event.dx) || (event.dy))))
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+8)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: i32.2bool
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jz +34
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+12)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: i32.2bool
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: jnz +16
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+16)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: i32.2bool
	<onTouchEvent+?>: jnz +11
	cmplGfx/lib/micro.ui.ci:877: (7 bytes): return .result := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:880: (24 bytes): if (this.pressedIndex != -1)
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: inc.i32(+84)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.c32 -1
	<onTouchEvent+?>: ceq.i32
	<onTouchEvent+?>: jnz +11
	cmplGfx/lib/micro.ui.ci:882: (7 bytes): return .result := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+20)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:885: (16 bytes): view: View := Widget.getFocused(this)
	<onTouchEvent+?>: inc.sp(+4)
	<onTouchEvent+?>: dup.x32 sp(4)
	<onTouchEvent+?>: load.ref <?> ;Layout.getFocused(this: Layout): View
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:886: (23 bytes): if ((view) == null)
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: load.ref <?> ;null
	<onTouchEvent+?>: ceq.i32
	<onTouchEvent+?>: jz +15
	cmplGfx/lib/micro.ui.ci:888: (11 bytes): return .result := false;
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: load.sp(+24)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-4)
	<onTouchEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:890: (16 bytes): parent: Layout := as(view.parent, Layout)
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: inc.i32(+16)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: load.ref <?> ;Layout
	<onTouchEvent+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	cmplGfx/lib/micro.ui.ci:891: (18 bytes): r: Rect := parent.items[parent.focusedIndex].rect
	<onTouchEvent+?>: dup.x32 sp(0)
	<onTouchEvent+?>: inc.i32(+68)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: dup.x32 sp(1)
	<onTouchEvent+?>: inc.i32(+88)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: mad.u32 24
	cmplGfx/lib/micro.ui.ci:893: (29 bytes): return .result := view.onTouchEvent(view, r, event);
	<onTouchEvent+?>: load.z32
	<onTouchEvent+?>: dup.x32 sp(3)
	<onTouchEvent+?>: dup.x32 sp(2)
	<onTouchEvent+?>: dup.x32 sp(7)
	<onTouchEvent+?>: dup.x32 sp(6)
	<onTouchEvent+?>: inc.i32(+52)
	<onTouchEvent+?>: load.i32
	<onTouchEvent+?>: call
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: load.sp(+32)
	<onTouchEvent+?>: store.i8
	<onTouchEvent+?>: inc.sp(-12)
	<onTouchEvent+?>: ret
.usages:
}
FxWidget.onKeyEvent(this: FxWidget, event: KeyEvent): bool: function {
.kind: static function
.base: `function`
.size: 637
.name: 'onKeyEvent'
.file: 'cmplGfx/lib/micro.ui.ci:895'
.owner: FxWidget
.param .result: bool (size: 4, cast: variable(bool))
.param this: FxWidget (size: 4, cast: variable(ref))
.param event: KeyEvent (size: 4, cast: const variable(ref))
.doc: 'Callback function executed when the view receives a KeyEvent: press or release'
.value: {
	if (event.key == ('[') || event.key == (']')) {
		changed: bool := this.showOriginal != event.release;
		this.showOriginal := !event.release && (event.repeat != 0 || !this.enabled);
		if (event.repeat != 0 && event.release == this.enabled) {
			return .result := changed && event.repeat == 1;
		}
		if (event.repeat == 0 && !event.release) {
			return .result := changed;
		}
		clearState(this, Style.hovered);
		if (event.key == ('[')) {
			if (this.align == Style.topLeft) {
				this.enabled := !this.enabled;
				invalidate(this);
				return .result := true;
			}
			this.align := Style.topLeft;
		}
		if (event.key == (']')) {
			if (this.align == Style.topRight) {
				this.enabled := !this.enabled;
				invalidate(this);
				return .result := true;
			}
			this.align := Style.topRight;
		}
		this.enabled := true;
		invalidate(this);
		return .result := true;
	}
	if (event.key == ('\')) {
		this.showOriginal := !event.release;
		return .result := event.repeat == 0 || event.release;
	}
	if (event.release) {
		return .result := Widget.onKeyEvent(this, event);
	}
	if ((event.key) == Window.KEY_CODE_BACK && event.isShift) {
		return .result := this.onReset(this);
	}
	return .result := Widget.onKeyEvent(this, event);
}
.instructions: (637 bytes)
	cmplGfx/lib/micro.ui.ci:896: (472 bytes): if (event.key == ('[') || event.key == (']'))
	<onKeyEvent>  : dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 91
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jnz +21
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 93
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +436
	cmplGfx/lib/micro.ui.ci:897: (12 bytes): changed: bool := this.showOriginal != event.release
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+132)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: not.b32
	cmplGfx/lib/micro.ui.ci:898: (49 bytes): this.showOriginal := !event.release && (event.repeat != 0 || !this.enabled);
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: not.b32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jz +36
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+4)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: not.b32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jnz +16
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: not.b32
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+132)
	<onKeyEvent+?>: store.i8
	cmplGfx/lib/micro.ui.ci:900: (73 bytes): if (event.repeat != 0 && event.release == this.enabled)
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+4)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: not.b32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jz +19
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +42
	cmplGfx/lib/micro.ui.ci:902: (38 bytes): return .result := changed && event.repeat == 1;
	<onKeyEvent+?>: load.sp(+0)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jz +21
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+4)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: load.sp(+20)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:904: (42 bytes): if (event.repeat == 0 && !event.release)
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+4)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jz +12
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: not.b32
	<onKeyEvent+?>: jz +19
	cmplGfx/lib/micro.ui.ci:906: (15 bytes): return .result := changed;
	<onKeyEvent+?>: load.sp(+0)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: load.sp(+20)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:909: (22 bytes): clearState(this, Style.hovered);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.ref <?> ;Layout.clearState(this: Layout, mode: int32): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:911: (93 bytes): if (event.key == ('['))
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 91
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +80
	cmplGfx/lib/micro.ui.ci:912: (64 bytes): if (this.align == Style.topLeft)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+136)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 3
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +51
	cmplGfx/lib/micro.ui.ci:913: (15 bytes): this.enabled := !this.enabled;
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: not.b32
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: store.i8
	cmplGfx/lib/micro.ui.ci:914: (17 bytes): invalidate(this);
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.ref <?> ;invalidate(view: View, layout: bool): void
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:915: (15 bytes): return .result := true;
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.sp(+20)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:917: (12 bytes): this.align := Style.topLeft;
	<onKeyEvent+?>: load.c32 3
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+136)
	<onKeyEvent+?>: store.i32
	cmplGfx/lib/micro.ui.ci:919: (93 bytes): if (event.key == (']'))
	<onKeyEvent+?>: dup.x32 sp(2)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 93
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +80
	cmplGfx/lib/micro.ui.ci:920: (64 bytes): if (this.align == Style.topRight)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+136)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 5
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +51
	cmplGfx/lib/micro.ui.ci:921: (15 bytes): this.enabled := !this.enabled;
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: not.b32
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: store.i8
	cmplGfx/lib/micro.ui.ci:922: (17 bytes): invalidate(this);
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.ref <?> ;invalidate(view: View, layout: bool): void
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:923: (15 bytes): return .result := true;
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.sp(+20)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:925: (12 bytes): this.align := Style.topRight;
	<onKeyEvent+?>: load.c32 5
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+136)
	<onKeyEvent+?>: store.i32
	cmplGfx/lib/micro.ui.ci:928: (12 bytes): this.enabled := true;
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+12)
	<onKeyEvent+?>: store.i8
	cmplGfx/lib/micro.ui.ci:929: (17 bytes): invalidate(this);
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.ref <?> ;invalidate(view: View, layout: bool): void
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:930: (15 bytes): return .result := true;
	<onKeyEvent+?>: load.c32 1
	<onKeyEvent+?>: load.sp(+20)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: ret
	<onKeyEvent+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:933: (56 bytes): if (event.key == ('\'))
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.c32 92
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: jz +43
	cmplGfx/lib/micro.ui.ci:934: (11 bytes): this.showOriginal := !event.release;
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: not.b32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: inc.i32(+132)
	<onKeyEvent+?>: store.i8
	cmplGfx/lib/micro.ui.ci:935: (28 bytes): return .result := event.repeat == 0 || event.release;
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+4)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: ceq.i32
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jnz +11
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:938: (28 bytes): if (event.release)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jz +25
	cmplGfx/lib/micro.ui.ci:939: (21 bytes): return .result := Widget.onKeyEvent(this, event);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.ref <?> ;Widget.onKeyEvent(this: Widget, event: KeyEvent): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:942: (60 bytes): if ((event.key) == Window.KEY_CODE_BACK && event.isShift)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+8)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: i32.2i64
	<onKeyEvent+?>: load.c64 65288
	<onKeyEvent+?>: ceq.i64
	<onKeyEvent+?>: dup.x32 sp(0)
	<onKeyEvent+?>: jz +15
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: dup.x32 sp(1)
	<onKeyEvent+?>: inc.i32(+1)
	<onKeyEvent+?>: load.is8
	<onKeyEvent+?>: jz +25
	cmplGfx/lib/micro.ui.ci:943: (21 bytes): return .result := this.onReset(this);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(4)
	<onKeyEvent+?>: inc.i32(+36)
	<onKeyEvent+?>: load.i32
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-4)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
	cmplGfx/lib/micro.ui.ci:946: (21 bytes): return .result := Widget.onKeyEvent(this, event);
	<onKeyEvent+?>: load.z32
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: dup.x32 sp(3)
	<onKeyEvent+?>: load.ref <?> ;Widget.onKeyEvent(this: Widget, event: KeyEvent): bool
	<onKeyEvent+?>: call
	<onKeyEvent+?>: inc.sp(-8)
	<onKeyEvent+?>: load.sp(+16)
	<onKeyEvent+?>: store.i8
	<onKeyEvent+?>: ret
.usages:
}
FxWidget.onMeasure(this: FxWidget, measured: Rect): bool: function {
.kind: static function
.base: `function`
.size: 164
.name: 'onMeasure'
.file: 'cmplGfx/lib/micro.ui.ci:949'
.owner: FxWidget
.param .result: bool (size: 4, cast: variable(bool))
.param this: FxWidget (size: 4, cast: variable(ref))
.param measured: Rect (size: 4, cast: variable(ref))
.doc: 'Callback function executed when the view needs to be measured'
.value: {
	margin: int32 := this.margin;
	align: int32 := this.align;
	rect: Rect := {
		rect.x0 := margin;
		rect.y0 := margin;
		rect.x1 := width(measured) - margin;
		rect.y1 := height(measured) - margin;
	};
	measured.x1 := measured.x0 := 0;
	measured.y1 := measured.y0 := 0;
	Layout.onMeasure(this, &measured);
	this.onLayout(this, &measured);
	Style.align(rect, &measured, align);
	return .result := true;
}
.instructions: (164 bytes)
	cmplGfx/lib/micro.ui.ci:950: (7 bytes): margin: int32 := this.margin
	<onMeasure>  : dup.x32 sp(2)
	<onMeasure+?>: inc.i32(+140)
	<onMeasure+?>: load.i32
	cmplGfx/lib/micro.ui.ci:951: (7 bytes): align: int32 := this.align
	<onMeasure+?>: dup.x32 sp(3)
	<onMeasure+?>: inc.i32(+136)
	<onMeasure+?>: load.i32
	cmplGfx/lib/micro.ui.ci:952: (54 bytes): rect: Rect := {...}
	<onMeasure+?>: inc.sp(+16)
	cmplGfx/lib/micro.ui.ci:953: (3 bytes): rect.x0 := margin;
	<onMeasure+?>: mov.x32 sp(0, 5)
	cmplGfx/lib/micro.ui.ci:954: (3 bytes): rect.y0 := margin;
	<onMeasure+?>: mov.x32 sp(1, 5)
	cmplGfx/lib/micro.ui.ci:955: (20 bytes): rect.x1 := width(measured) - margin;
	<onMeasure+?>: dup.x32 sp(7)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: dup.x32 sp(6)
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(3)
	cmplGfx/lib/micro.ui.ci:956: (24 bytes): rect.y1 := height(measured) - margin;
	<onMeasure+?>: dup.x32 sp(7)
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: inc.i32(+12)
	<onMeasure+?>: load.i32
	<onMeasure+?>: dup.x32 sp(1)
	<onMeasure+?>: inc.i32(+4)
	<onMeasure+?>: load.i32
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(1)
	<onMeasure+?>: dup.x32 sp(6)
	<onMeasure+?>: sub.i32
	<onMeasure+?>: set.x32 sp(4)
	cmplGfx/lib/micro.ui.ci:959: (13 bytes): measured.x1 := measured.x0 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(9)
	<onMeasure+?>: store.i32
	<onMeasure+?>: dup.x32 sp(8)
	<onMeasure+?>: inc.i32(+8)
	<onMeasure+?>: store.i32
	cmplGfx/lib/micro.ui.ci:960: (17 bytes): measured.y1 := measured.y0 := 0;
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(0)
	<onMeasure+?>: dup.x32 sp(9)
	<onMeasure+?>: inc.i32(+4)
	<onMeasure+?>: store.i32
	<onMeasure+?>: dup.x32 sp(8)
	<onMeasure+?>: inc.i32(+12)
	<onMeasure+?>: store.i32
	cmplGfx/lib/micro.ui.ci:961: (19 bytes): Layout.onMeasure(this, &measured);
	<onMeasure+?>: load.z32
	<onMeasure+?>: dup.x32 sp(9)
	<onMeasure+?>: dup.x32 sp(9)
	<onMeasure+?>: load.ref <?> ;Layout.onMeasure(this: Layout, measured: Rect): bool
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	<onMeasure+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:962: (16 bytes): this.onLayout(this, &measured);
	<onMeasure+?>: dup.x32 sp(8)
	<onMeasure+?>: dup.x32 sp(8)
	<onMeasure+?>: dup.x32 sp(10)
	<onMeasure+?>: inc.i32(+112)
	<onMeasure+?>: load.i32
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:963: (16 bytes): Style.align(rect, &measured, align);
	<onMeasure+?>: dup.x128 sp(0)
	<onMeasure+?>: dup.x32 sp(11)
	<onMeasure+?>: dup.x32 sp(9)
	<onMeasure+?>: load.ref <?> ;Style.align(parent: Rect, rect: Rect, align: int32): void
	<onMeasure+?>: call
	<onMeasure+?>: inc.sp(-24)
	cmplGfx/lib/micro.ui.ci:964: (15 bytes): return .result := true;
	<onMeasure+?>: load.c32 1
	<onMeasure+?>: load.sp(+40)
	<onMeasure+?>: store.i8
	<onMeasure+?>: inc.sp(-24)
	<onMeasure+?>: ret
.usages:
}
FxWidget.onDraw(this: FxWidget, offs: Image, rect: Rect): void: function {
.kind: static function
.base: `function`
.size: 131
.name: 'onDraw'
.file: 'cmplGfx/lib/micro.ui.ci:967'
.owner: FxWidget
.param .result: void (size: 0, cast: variable(void))
.param this: FxWidget (size: 4, cast: variable(ref))
.param offs: Image (size: 8, cast: variable(val))
.param rect: Rect (size: 16, cast: variable(val))
.doc: 'Callback function executed when the view needs to be drawn'
.value: {
	offs := Image.slice(offs, rect);
	style: Style := this.style;
	if (style.backgroundColor != (-1)) {
		r: Rect := {
			r.x0 := 0;
			r.y0 := 0;
			r.x1 := Image.width(offs);
			r.y1 := Image.height(offs);
		};
		fillRRect(offs, r, this.radius, style.backgroundColor);
	}
	Widget.onDraw(this, offs, rect);
	Image.destroy(offs);
}
.instructions: (131 bytes)
	cmplGfx/lib/micro.ui.ci:968: (12 bytes): offs := Image.slice(offs, rect);
	<onDraw>  : dup.x64 sp(5)
	<onDraw+?>: load.sp(+12)
	<onDraw+?>: nfc(92) ;Image.slice(image: Image, rect: Rect): Image
	<onDraw+?>: set.x64 sp(7)
	cmplGfx/lib/micro.ui.ci:969: (7 bytes): style: Style := this.style
	<onDraw+?>: dup.x32 sp(7)
	<onDraw+?>: inc.i32(+20)
	<onDraw+?>: load.i32
	cmplGfx/lib/micro.ui.ci:970: (85 bytes): if (style.backgroundColor != (-1))
	<onDraw+?>: dup.x32 sp(0)
	<onDraw+?>: inc.i32(+32)
	<onDraw+?>: load.i32
	<onDraw+?>: load.c32 -1
	<onDraw+?>: ceq.i32
	<onDraw+?>: jnz +72
	cmplGfx/lib/micro.ui.ci:971: (26 bytes): r: Rect := {...}
	<onDraw+?>: inc.sp(+16)
	cmplGfx/lib/micro.ui.ci:971: (3 bytes): r.x0 := 0;
	<onDraw+?>: load.z32
	<onDraw+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:971: (3 bytes): r.y0 := 0;
	<onDraw+?>: load.z32
	<onDraw+?>: set.x32 sp(2)
	cmplGfx/lib/micro.ui.ci:971: (8 bytes): r.x1 := Image.width(offs);
	<onDraw+?>: dup.x64 sp(10)
	<onDraw+?>: nfc(101) ;Image.width(image: Image): int32
	<onDraw+?>: set.x32 sp(3)
	cmplGfx/lib/micro.ui.ci:971: (8 bytes): r.y1 := Image.height(offs);
	<onDraw+?>: dup.x64 sp(10)
	<onDraw+?>: nfc(102) ;Image.height(image: Image): int32
	<onDraw+?>: set.x32 sp(4)
	cmplGfx/lib/micro.ui.ci:972: (38 bytes): fillRRect(offs, r, this.radius, style.backgroundColor);
	<onDraw+?>: dup.x32 sp(12)
	<onDraw+?>: inc.i32(+144)
	<onDraw+?>: load.i32
	<onDraw+?>: dup.x64 sp(11)
	<onDraw+?>: load.sp(+12)
	<onDraw+?>: dup.x32 sp(3)
	<onDraw+?>: dup.x32 sp(4)
	<onDraw+?>: dup.x32 sp(10)
	<onDraw+?>: inc.i32(+32)
	<onDraw+?>: load.i32
	<onDraw+?>: load.ref <?> ;fillRRect(image: Image, roi: Rect, rx: int32, ry: int32, color: uint32): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-24)
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: inc.sp(-16)
	cmplGfx/lib/micro.ui.ci:974: (16 bytes): Widget.onDraw(this, offs, rect);
	<onDraw+?>: dup.x32 sp(8)
	<onDraw+?>: dup.x64 sp(7)
	<onDraw+?>: dup.x128 sp(5)
	<onDraw+?>: load.ref <?> ;Widget.onDraw(this: Widget, offs: Image, rect: Rect): void
	<onDraw+?>: call
	<onDraw+?>: inc.sp(-28)
	cmplGfx/lib/micro.ui.ci:975: (6 bytes): Image.destroy(offs);
	<onDraw+?>: dup.x64 sp(6)
	<onDraw+?>: nfc(93) ;Image.destroy(image: Image): void
	<onDraw+?>: inc.sp(-4)
	<onDraw+?>: ret
.usages:
}
FxWidget.onProcess(widget: FxWidget): void: function {
.kind: static function
.base: `function`
.size: 1
.name: 'onProcess'
.file: 'cmplGfx/lib/micro.ui.ci:979'
.owner: FxWidget
.param .result: void (size: 0, cast: variable(void))
.param widget: FxWidget (size: 4, cast: variable(ref))
.doc: 'Callback to be executed when the value of a control changes'
.value: {
}
.instructions: (1 byte)
	<onProcess>  : ret
.usages:
	cmplGfx/lib/micro.ui.ci:1025: referenced as `onProcess`
}
FxWidget.onProcess(widget: FxWidget): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'onProcess'
.file: 'cmplGfx/lib/micro.ui.ci:979'
.owner: FxWidget
.param .result: void (size: 0, cast: variable(void))
.param widget: FxWidget (size: 4, cast: variable(ref))
.doc: 'Callback to be executed when the value of a control changes'
.value: onProcess
.usages:
	cmplGfx/lib/micro.ui.ci:1333: referenced as `onProcess`
	cmplGfx/lib/micro.ui.ci:1015: referenced as `onProcess`
}
Widget(width: int32, height: int32, style: Style): Widget: function {
.kind: static function
.base: `function`
.size: 400
.name: 'Widget'
.file: 'cmplGfx/lib/micro.ui.ci:983'
.param .result: Widget (size: 4, cast: variable(ref))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.param style: Style (size: 4, cast: const variable(ref))
.doc: 'Create a widget with the given `width`, `height` and `style`'
.value: {
	widget: Widget := {
		widget := create(Widget);
		widget.width := width;
		widget.height := height;
		widget.style := style;
		widget.measure := true;
		widget.redraw := true;
		widget.focus := (null);
		widget.scrollX := 0;
		widget.scrollY := 0;
		widget.separator := (null);
		widget.items := (null);
		widget.itemCount := 0;
		widget.itemCapacity := 0;
		widget.hoveredIndex := -1;
		widget.pressedIndex := -1;
		widget.focusedIndex := -1;
		widget.paddingTop := 0;
		widget.paddingLeft := 0;
		widget.paddingRight := 0;
		widget.paddingBottom := 0;
		widget.orientation := 1;
		widget.onLayout := onLayout;
		widget.enabled := true;
		widget.focusable := true;
		widget.parent := (null);
		widget.data := (null);
		widget.onClick := onClick;
		widget.onReset := onReset;
		widget.onCreate := onCreate;
		widget.onDestroy := onDestroy;
		widget.onKeyEvent := onKeyEvent;
		widget.onTouchEvent := onTouchEvent;
		widget.onMeasure := onMeasure;
		widget.onDraw := onDraw;
	};
	return .result := Widget.focus(widget, widget);
}
.instructions: (400 bytes)
	cmplGfx/lib/micro.ui.ci:984: (375 bytes): widget: Widget := {...}
	<Widget>  : inc.sp(+4)
	cmplGfx/lib/micro.ui.ci:984: (11 bytes): widget := create(Widget);
	<Widget+?>: load.ref <?> ;Widget
	<Widget+?>: nfc(7) ;object.create(type: typename): pointer
	<Widget+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:985: (9 bytes): widget.width := width;
	<Widget+?>: dup.x32 sp(4)
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+4)
	<Widget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:986: (9 bytes): widget.height := height;
	<Widget+?>: dup.x32 sp(3)
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+8)
	<Widget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:987: (9 bytes): widget.style := style;
	<Widget+?>: dup.x32 sp(2)
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+20)
	<Widget+?>: store.i32
	:: (12 bytes): widget.measure := true;
	<Widget+?>: load.c32 1
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+116)
	<Widget+?>: store.i8
	:: (12 bytes): widget.redraw := true;
	<Widget+?>: load.c32 1
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+117)
	<Widget+?>: store.i8
	:: (12 bytes): widget.focus := (null);
	<Widget+?>: load.ref <?> ;null
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+120)
	<Widget+?>: store.i32
	:: (8 bytes): widget.scrollX := 0;
	<Widget+?>: load.z32
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+124)
	<Widget+?>: store.i32
	:: (8 bytes): widget.scrollY := 0;
	<Widget+?>: load.z32
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+128)
	<Widget+?>: store.i32
	:: (12 bytes): widget.separator := (null);
	<Widget+?>: load.ref <?> ;null
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+64)
	<Widget+?>: store.i32
	:: (12 bytes): widget.items := (null);
	<Widget+?>: load.ref <?> ;null
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+68)
	<Widget+?>: store.i32
	:: (8 bytes): widget.itemCount := 0;
	<Widget+?>: load.z32
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+72)
	<Widget+?>: store.i32
	:: (8 bytes): widget.itemCapacity := 0;
	<Widget+?>: load.z32
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+76)
	<Widget+?>: store.i32
	:: (12 bytes): widget.hoveredIndex := -1;
	<Widget+?>: load.c32 -1
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+80)
	<Widget+?>: store.i32
	:: (12 bytes): widget.pressedIndex := -1;
	<Widget+?>: load.c32 -1
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+84)
	<Widget+?>: store.i32
	:: (12 bytes): widget.focusedIndex := -1;
	<Widget+?>: load.c32 -1
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+88)
	<Widget+?>: store.i32
	:: (8 bytes): widget.paddingTop := 0;
	<Widget+?>: load.z32
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+92)
	<Widget+?>: store.i32
	:: (8 bytes): widget.paddingLeft := 0;
	<Widget+?>: load.z32
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+96)
	<Widget+?>: store.i32
	:: (8 bytes): widget.paddingRight := 0;
	<Widget+?>: load.z32
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+100)
	<Widget+?>: store.i32
	:: (8 bytes): widget.paddingBottom := 0;
	<Widget+?>: load.z32
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+104)
	<Widget+?>: store.i32
	:: (12 bytes): widget.orientation := 1;
	<Widget+?>: load.c32 1
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+108)
	<Widget+?>: store.i32
	:: (12 bytes): widget.onLayout := onLayout;
	<Widget+?>: load.ref <?> ;Layout.onLayout(this: Layout, measured: Rect): void
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+112)
	<Widget+?>: store.i32
	:: (12 bytes): widget.enabled := true;
	<Widget+?>: load.c32 1
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+12)
	<Widget+?>: store.i8
	:: (12 bytes): widget.focusable := true;
	<Widget+?>: load.c32 1
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+13)
	<Widget+?>: store.i8
	:: (12 bytes): widget.parent := (null);
	<Widget+?>: load.ref <?> ;null
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+16)
	<Widget+?>: store.i32
	:: (17 bytes): widget.data := (null);
	<Widget+?>: load.ref <?> ;pointer
	<Widget+?>: load.ref <?> ;null
	<Widget+?>: dup.x32 sp(2)
	<Widget+?>: inc.i32(+24)
	<Widget+?>: store.i64
	:: (12 bytes): widget.onClick := onClick;
	<Widget+?>: load.ref <?> ;Layout.onClick(this: Layout): bool
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+32)
	<Widget+?>: store.i32
	:: (12 bytes): widget.onReset := onReset;
	<Widget+?>: load.ref <?> ;Layout.onReset(this: Layout): bool
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+36)
	<Widget+?>: store.i32
	:: (12 bytes): widget.onCreate := onCreate;
	<Widget+?>: load.ref <?> ;Widget.onCreate(this: Widget, parent: View): void
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+40)
	<Widget+?>: store.i32
	:: (12 bytes): widget.onDestroy := onDestroy;
	<Widget+?>: load.ref <?> ;Layout.onDestroy(this: Layout): void
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+44)
	<Widget+?>: store.i32
	:: (12 bytes): widget.onKeyEvent := onKeyEvent;
	<Widget+?>: load.ref <?> ;Widget.onKeyEvent(this: Widget, event: KeyEvent): bool
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+48)
	<Widget+?>: store.i32
	:: (12 bytes): widget.onTouchEvent := onTouchEvent;
	<Widget+?>: load.ref <?> ;Layout.onTouchEvent(this: Layout, rect: Rect, event: TouchEvent): bool
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+52)
	<Widget+?>: store.i32
	:: (12 bytes): widget.onMeasure := onMeasure;
	<Widget+?>: load.ref <?> ;Widget.onMeasure(this: Widget, measured: Rect): bool
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+56)
	<Widget+?>: store.i32
	:: (12 bytes): widget.onDraw := onDraw;
	<Widget+?>: load.ref <?> ;Widget.onDraw(this: Widget, offs: Image, rect: Rect): void
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: inc.i32(+60)
	<Widget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:989: (25 bytes): return .result := Widget.focus(widget, widget);
	<Widget+?>: inc.sp(+4)
	<Widget+?>: dup.x32 sp(1)
	<Widget+?>: dup.x32 sp(2)
	<Widget+?>: load.ref <?> ;Widget.focus(this: Widget, value: View): Widget
	<Widget+?>: call
	<Widget+?>: inc.sp(-8)
	<Widget+?>: set.x32 sp(6)
	<Widget+?>: inc.sp(-4)
	<Widget+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:997: referenced as `Widget`
}
Widget(width: int32, height: int32): Widget: function {
.kind: static function
.base: `function`
.size: 26
.name: 'Widget'
.file: 'cmplGfx/lib/micro.ui.ci:993'
.param .result: Widget (size: 4, cast: variable(ref))
.param width: int32 (size: 4, cast: variable(i32))
.param height: int32 (size: 4, cast: variable(i32))
.doc: 'Create a widget with the given `width`, `height` and a default style'
.value: {
	static const style: Style := {
		style.format.precision := 2;
		style.format.trimDecimal := false;
		style.format.sign := (0);
		style.format.padChr := (0);
		style.format.width := 0;
		style.align := 0;
		style.padding := 8;
		style.font := Window.font;
		style.backgroundColor := uint32(theme);
		style.hoveredColor := uint32(mix_rgb8(16, theme, accent));
		style.focusedColor := uint32(mix_rgb8(64, theme, accent));
		style.valueColor := uint32(accent);
		style.textColor := uint32(lum(theme) > 127 ? dark : light);
	};
	return .result := Widget(width, height, style);
}
.instructions: (26 bytes)
	cmplGfx/lib/micro.ui.ci:997: (26 bytes): return .result := Widget(width, height, style);
	<Widget>  : inc.sp(+4)
	<Widget+?>: dup.x32 sp(3)
	<Widget+?>: dup.x32 sp(3)
	<Widget+?>: load.ref <?> ;Widget.style
	<Widget+?>: load.ref <?> ;Widget(width: int32, height: int32, style: Style): Widget
	<Widget+?>: call
	<Widget+?>: inc.sp(-12)
	<Widget+?>: set.x32 sp(4)
	<Widget+?>: ret
.usages:
}
FxWidget(onProcess(widget: FxWidget): void, views: View[]): FxWidget: function {
.kind: static function
.base: `function`
.size: 494
.name: 'FxWidget'
.file: 'cmplGfx/lib/micro.ui.ci:1000'
.param .result: FxWidget (size: 4, cast: variable(ref))
.param onProcess: function (size: 4, cast: variable(ref))
.param views: View[] (size: 8, cast: variable(arr))
.doc: 'Create a widget with the given `views` used in image processing demos'
.value: {
	static const style: Style := {
		style.align := Style.left;
		style.format.precision := 2;
		style.format.trimDecimal := false;
		style.format.sign := (0);
		style.format.padChr := (0);
		style.format.width := 0;
		style.padding := 8;
		style.font := Window.font;
		style.backgroundColor := uint32(theme);
		style.hoveredColor := uint32(mix_rgb8(16, theme, accent));
		style.focusedColor := uint32(mix_rgb8(64, theme, accent));
		style.valueColor := uint32(accent);
		style.textColor := uint32(lum(theme) > 127 ? dark : light);
	};
	widget: FxWidget := {
		widget := create(FxWidget);
		widget.radius := 5;
		widget.margin := 10;
		widget.align := Style.topRight;
		widget.style := style;
		widget.paddingTop := 3;
		widget.paddingLeft := 3;
		widget.paddingRight := 3;
		widget.paddingBottom := 3;
		widget.onProcess := onProcess;
		widget.showOriginal := false;
		widget.measure := true;
		widget.redraw := true;
		widget.focus := (null);
		widget.scrollX := 0;
		widget.scrollY := 0;
		widget.separator := (null);
		widget.items := (null);
		widget.itemCount := 0;
		widget.itemCapacity := 0;
		widget.hoveredIndex := -1;
		widget.pressedIndex := -1;
		widget.focusedIndex := -1;
		widget.orientation := 1;
		widget.onLayout := onLayout;
		widget.width := -5;
		widget.height := -5;
		widget.enabled := true;
		widget.focusable := true;
		widget.parent := (null);
		widget.data := (null);
		widget.onClick := onClick;
		widget.onReset := onReset;
		widget.onCreate := onCreate;
		widget.onDestroy := onDestroy;
		widget.onKeyEvent := onKeyEvent;
		widget.onTouchEvent := onTouchEvent;
		widget.onMeasure := onMeasure;
		widget.onDraw := onDraw;
	};
	return .result := Layout.addItems(FxWidget.focus(widget, widget), ...views);
}
.instructions: (494 bytes)
	cmplGfx/lib/micro.ui.ci:1005: (453 bytes): widget: FxWidget := {...}
	<FxWidget>  : inc.sp(+4)
	cmplGfx/lib/micro.ui.ci:1005: (11 bytes): widget := create(FxWidget);
	<FxWidget+?>: load.ref <?> ;FxWidget
	<FxWidget+?>: nfc(7) ;object.create(type: typename): pointer
	<FxWidget+?>: set.x32 sp(1)
	cmplGfx/lib/micro.ui.ci:1006: (12 bytes): widget.radius := 5;
	<FxWidget+?>: load.c32 5
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+144)
	<FxWidget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:1007: (12 bytes): widget.margin := 10;
	<FxWidget+?>: load.c32 10
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+140)
	<FxWidget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:1008: (12 bytes): widget.align := Style.topRight;
	<FxWidget+?>: load.c32 5
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+136)
	<FxWidget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:1009: (12 bytes): widget.style := style;
	<FxWidget+?>: load.ref <?> ;FxWidget.style
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+20)
	<FxWidget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:1011: (12 bytes): widget.paddingTop := 3;
	<FxWidget+?>: load.c32 3
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+92)
	<FxWidget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:1012: (12 bytes): widget.paddingLeft := 3;
	<FxWidget+?>: load.c32 3
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+96)
	<FxWidget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:1013: (12 bytes): widget.paddingRight := 3;
	<FxWidget+?>: load.c32 3
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+100)
	<FxWidget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:1014: (12 bytes): widget.paddingBottom := 3;
	<FxWidget+?>: load.c32 3
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+104)
	<FxWidget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:1015: (9 bytes): widget.onProcess := onProcess;
	<FxWidget+?>: dup.x32 sp(4)
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+148)
	<FxWidget+?>: store.i32
	:: (8 bytes): widget.showOriginal := false;
	<FxWidget+?>: load.z32
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+132)
	<FxWidget+?>: store.i8
	:: (12 bytes): widget.measure := true;
	<FxWidget+?>: load.c32 1
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+116)
	<FxWidget+?>: store.i8
	:: (12 bytes): widget.redraw := true;
	<FxWidget+?>: load.c32 1
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+117)
	<FxWidget+?>: store.i8
	:: (12 bytes): widget.focus := (null);
	<FxWidget+?>: load.ref <?> ;null
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+120)
	<FxWidget+?>: store.i32
	:: (8 bytes): widget.scrollX := 0;
	<FxWidget+?>: load.z32
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+124)
	<FxWidget+?>: store.i32
	:: (8 bytes): widget.scrollY := 0;
	<FxWidget+?>: load.z32
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+128)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.separator := (null);
	<FxWidget+?>: load.ref <?> ;null
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+64)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.items := (null);
	<FxWidget+?>: load.ref <?> ;null
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+68)
	<FxWidget+?>: store.i32
	:: (8 bytes): widget.itemCount := 0;
	<FxWidget+?>: load.z32
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+72)
	<FxWidget+?>: store.i32
	:: (8 bytes): widget.itemCapacity := 0;
	<FxWidget+?>: load.z32
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+76)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.hoveredIndex := -1;
	<FxWidget+?>: load.c32 -1
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+80)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.pressedIndex := -1;
	<FxWidget+?>: load.c32 -1
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+84)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.focusedIndex := -1;
	<FxWidget+?>: load.c32 -1
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+88)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.orientation := 1;
	<FxWidget+?>: load.c32 1
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+108)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.onLayout := onLayout;
	<FxWidget+?>: load.ref <?> ;Layout.onLayout(this: Layout, measured: Rect): void
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+112)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.width := -5;
	<FxWidget+?>: load.c32 -5
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+4)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.height := -5;
	<FxWidget+?>: load.c32 -5
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+8)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.enabled := true;
	<FxWidget+?>: load.c32 1
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+12)
	<FxWidget+?>: store.i8
	:: (12 bytes): widget.focusable := true;
	<FxWidget+?>: load.c32 1
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+13)
	<FxWidget+?>: store.i8
	:: (12 bytes): widget.parent := (null);
	<FxWidget+?>: load.ref <?> ;null
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+16)
	<FxWidget+?>: store.i32
	:: (17 bytes): widget.data := (null);
	<FxWidget+?>: load.ref <?> ;pointer
	<FxWidget+?>: load.ref <?> ;null
	<FxWidget+?>: dup.x32 sp(2)
	<FxWidget+?>: inc.i32(+24)
	<FxWidget+?>: store.i64
	:: (12 bytes): widget.onClick := onClick;
	<FxWidget+?>: load.ref <?> ;Layout.onClick(this: Layout): bool
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+32)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.onReset := onReset;
	<FxWidget+?>: load.ref <?> ;Layout.onReset(this: Layout): bool
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+36)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.onCreate := onCreate;
	<FxWidget+?>: load.ref <?> ;Widget.onCreate(this: Widget, parent: View): void
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+40)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.onDestroy := onDestroy;
	<FxWidget+?>: load.ref <?> ;Layout.onDestroy(this: Layout): void
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+44)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.onKeyEvent := onKeyEvent;
	<FxWidget+?>: load.ref <?> ;FxWidget.onKeyEvent(this: FxWidget, event: KeyEvent): bool
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+48)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.onTouchEvent := onTouchEvent;
	<FxWidget+?>: load.ref <?> ;FxWidget.onTouchEvent(this: FxWidget, rect: Rect, event: TouchEvent): bool
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+52)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.onMeasure := onMeasure;
	<FxWidget+?>: load.ref <?> ;FxWidget.onMeasure(this: FxWidget, measured: Rect): bool
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+56)
	<FxWidget+?>: store.i32
	:: (12 bytes): widget.onDraw := onDraw;
	<FxWidget+?>: load.ref <?> ;FxWidget.onDraw(this: FxWidget, offs: Image, rect: Rect): void
	<FxWidget+?>: dup.x32 sp(1)
	<FxWidget+?>: inc.i32(+60)
	<FxWidget+?>: store.i32
	cmplGfx/lib/micro.ui.ci:1018: (41 bytes): return .result := Layout.addItems(FxWidget.focus(widget, widget), ...views);
	<FxWidget+?>: inc.sp(+4)
	<FxWidget+?>: inc.sp(+4)
	<FxWidget+?>: dup.x32 sp(2)
	<FxWidget+?>: dup.x32 sp(3)
	<FxWidget+?>: load.ref <?> ;Widget.focus(this: Widget, value: View): Widget
	<FxWidget+?>: call
	<FxWidget+?>: inc.sp(-8)
	<FxWidget+?>: dup.x64 sp(4)
	<FxWidget+?>: load.ref <?> ;Widget.addItems(this: Widget, views: View[]): Widget
	<FxWidget+?>: call
	<FxWidget+?>: inc.sp(-12)
	<FxWidget+?>: set.x32 sp(6)
	<FxWidget+?>: inc.sp(-4)
	<FxWidget+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:1025: referenced as `FxWidget`
}
FxWidget(views: View[]): FxWidget: function {
.kind: static function
.base: `function`
.size: 24
.name: 'FxWidget'
.file: 'cmplGfx/lib/micro.ui.ci:1024'
.param .result: FxWidget (size: 4, cast: variable(ref))
.param views: View[] (size: 8, cast: variable(arr))
.doc: '@public'
.value: {
	return .result := FxWidget(FxWidget.onProcess, ...views);
}
.instructions: (24 bytes)
	cmplGfx/lib/micro.ui.ci:1025: (24 bytes): return .result := FxWidget(FxWidget.onProcess, ...views);
	<FxWidget>  : inc.sp(+4)
	<FxWidget+?>: load.ref <?> ;FxWidget.onProcess(widget: FxWidget): void
	<FxWidget+?>: dup.x64 sp(3)
	<FxWidget+?>: load.ref <?> ;FxWidget(onProcess(widget: FxWidget): void, views: View[]): FxWidget
	<FxWidget+?>: call
	<FxWidget+?>: inc.sp(-12)
	<FxWidget+?>: set.x32 sp(4)
	<FxWidget+?>: ret
.usages:
}
hasFocused(this: Layout, items: View[]): bool: function {
.kind: static function
.base: `function`
.size: 178
.name: 'hasFocused'
.file: 'cmplGfx/lib/micro.ui.ci:1029'
.param .result: bool (size: 4, cast: variable(bool))
.param this: Layout (size: 4, cast: const variable(ref))
.param items: View[] (size: 8, cast: variable(arr))
.doc: '@public'
.value: {
	if (this.focusedIndex < 0) {
		return .result := false;
	}
	if (items.length == (0)) {
		return .result := true;
	}
	view: View := this.items[this.focusedIndex].view;
	for (i: int32 := 0; i < (items.length); i := i + 1) {
		if (items[i] == view) {
			return .result := true;
		}
	}
	if ((layout) != null) {
		return .result := hasFocused(layout, ...items);
	}
	return .result := false;
}
.instructions: (178 bytes)
	cmplGfx/lib/micro.ui.ci:1030: (20 bytes): if (this.focusedIndex < 0)
	<hasFocused>  : dup.x32 sp(3)
	<hasFocused+?>: inc.i32(+88)
	<hasFocused+?>: load.i32
	<hasFocused+?>: load.z32
	<hasFocused+?>: clt.i32
	<hasFocused+?>: jz +11
	cmplGfx/lib/micro.ui.ci:1032: (7 bytes): return .result := false;
	<hasFocused+?>: load.z32
	<hasFocused+?>: load.sp(+20)
	<hasFocused+?>: store.i8
	<hasFocused+?>: ret
	cmplGfx/lib/micro.ui.ci:1034: (19 bytes): if (items.length == (0))
	<hasFocused+?>: dup.x32 sp(2)
	<hasFocused+?>: load.z32
	<hasFocused+?>: ceq.i32
	<hasFocused+?>: jz +15
	cmplGfx/lib/micro.ui.ci:1036: (11 bytes): return .result := true;
	<hasFocused+?>: load.c32 1
	<hasFocused+?>: load.sp(+20)
	<hasFocused+?>: store.i8
	<hasFocused+?>: ret
	cmplGfx/lib/micro.ui.ci:1039: (23 bytes): view: View := this.items[this.focusedIndex].view
	<hasFocused+?>: dup.x32 sp(3)
	<hasFocused+?>: inc.i32(+68)
	<hasFocused+?>: load.i32
	<hasFocused+?>: dup.x32 sp(4)
	<hasFocused+?>: inc.i32(+88)
	<hasFocused+?>: load.i32
	<hasFocused+?>: mad.u32 24
	<hasFocused+?>: inc.i32(+16)
	<hasFocused+?>: load.i32
	cmplGfx/lib/micro.ui.ci:1040: (53 bytes): for (i: int32 := 0; i < (items.length); i := i + 1)
	<hasFocused+?>: load.z32
	<hasFocused+?>: jmp +39
	cmplGfx/lib/micro.ui.ci:1041: (31 bytes): if (items[i] == view)
	<hasFocused+?>: dup.x32 sp(3)
	<hasFocused+?>: dup.x32 sp(1)
	<hasFocused+?>: mad.u32 4
	<hasFocused+?>: load.i32
	<hasFocused+?>: dup.x32 sp(2)
	<hasFocused+?>: ceq.i32
	<hasFocused+?>: jz +19
	cmplGfx/lib/micro.ui.ci:1042: (15 bytes): return .result := true;
	<hasFocused+?>: load.c32 1
	<hasFocused+?>: load.sp(+28)
	<hasFocused+?>: store.i8
	<hasFocused+?>: inc.sp(-8)
	<hasFocused+?>: ret
	cmplGfx/lib/micro.ui.ci:1040: (4 bytes): i := i + 1
	<hasFocused+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:1040: (9 bytes): i < (items.length)
	<hasFocused+?>: dup.x32 sp(0)
	<hasFocused+?>: dup.x32 sp(5)
	<hasFocused+?>: clt.i32
	<hasFocused+?>: jnz -40
	<hasFocused+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:1046: (52 bytes): if ((layout) != null)
	<hasFocused+?>: dup.x32 sp(0)
	<hasFocused+?>: load.ref <?> ;Layout
	<hasFocused+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<hasFocused+?>: dup.x32 sp(0)
	<hasFocused+?>: load.ref <?> ;null
	<hasFocused+?>: ceq.i32
	<hasFocused+?>: jnz +29
	cmplGfx/lib/micro.ui.ci:1047: (25 bytes): return .result := hasFocused(layout, ...items);
	<hasFocused+?>: load.z32
	<hasFocused+?>: dup.x32 sp(1)
	<hasFocused+?>: dup.x64 sp(5)
	<hasFocused+?>: load.ref <?> ;hasFocused(this: Layout, items: View[]): bool
	<hasFocused+?>: call
	<hasFocused+?>: inc.sp(-12)
	<hasFocused+?>: load.sp(+28)
	<hasFocused+?>: store.i8
	<hasFocused+?>: inc.sp(-8)
	<hasFocused+?>: ret
	<hasFocused+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:1049: (11 bytes): return .result := false;
	<hasFocused+?>: load.z32
	<hasFocused+?>: load.sp(+24)
	<hasFocused+?>: store.i8
	<hasFocused+?>: inc.sp(-4)
	<hasFocused+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:1047: referenced as `hasFocused`
}
hasPressed(this: Layout, items: View[]): bool: function {
.kind: static function
.base: `function`
.size: 178
.name: 'hasPressed'
.file: 'cmplGfx/lib/micro.ui.ci:1052'
.param .result: bool (size: 4, cast: variable(bool))
.param this: Layout (size: 4, cast: const variable(ref))
.param items: View[] (size: 8, cast: variable(arr))
.doc: '@public'
.value: {
	if (this.pressedIndex < 0) {
		return .result := false;
	}
	if (items.length == (0)) {
		return .result := true;
	}
	view: View := this.items[this.pressedIndex].view;
	for (i: int32 := 0; i < (items.length); i := i + 1) {
		if (items[i] == view) {
			return .result := true;
		}
	}
	if ((layout) != null) {
		return .result := hasPressed(layout, ...items);
	}
	return .result := false;
}
.instructions: (178 bytes)
	cmplGfx/lib/micro.ui.ci:1053: (20 bytes): if (this.pressedIndex < 0)
	<hasPressed>  : dup.x32 sp(3)
	<hasPressed+?>: inc.i32(+84)
	<hasPressed+?>: load.i32
	<hasPressed+?>: load.z32
	<hasPressed+?>: clt.i32
	<hasPressed+?>: jz +11
	cmplGfx/lib/micro.ui.ci:1055: (7 bytes): return .result := false;
	<hasPressed+?>: load.z32
	<hasPressed+?>: load.sp(+20)
	<hasPressed+?>: store.i8
	<hasPressed+?>: ret
	cmplGfx/lib/micro.ui.ci:1057: (19 bytes): if (items.length == (0))
	<hasPressed+?>: dup.x32 sp(2)
	<hasPressed+?>: load.z32
	<hasPressed+?>: ceq.i32
	<hasPressed+?>: jz +15
	cmplGfx/lib/micro.ui.ci:1059: (11 bytes): return .result := true;
	<hasPressed+?>: load.c32 1
	<hasPressed+?>: load.sp(+20)
	<hasPressed+?>: store.i8
	<hasPressed+?>: ret
	cmplGfx/lib/micro.ui.ci:1062: (23 bytes): view: View := this.items[this.pressedIndex].view
	<hasPressed+?>: dup.x32 sp(3)
	<hasPressed+?>: inc.i32(+68)
	<hasPressed+?>: load.i32
	<hasPressed+?>: dup.x32 sp(4)
	<hasPressed+?>: inc.i32(+84)
	<hasPressed+?>: load.i32
	<hasPressed+?>: mad.u32 24
	<hasPressed+?>: inc.i32(+16)
	<hasPressed+?>: load.i32
	cmplGfx/lib/micro.ui.ci:1063: (53 bytes): for (i: int32 := 0; i < (items.length); i := i + 1)
	<hasPressed+?>: load.z32
	<hasPressed+?>: jmp +39
	cmplGfx/lib/micro.ui.ci:1064: (31 bytes): if (items[i] == view)
	<hasPressed+?>: dup.x32 sp(3)
	<hasPressed+?>: dup.x32 sp(1)
	<hasPressed+?>: mad.u32 4
	<hasPressed+?>: load.i32
	<hasPressed+?>: dup.x32 sp(2)
	<hasPressed+?>: ceq.i32
	<hasPressed+?>: jz +19
	cmplGfx/lib/micro.ui.ci:1065: (15 bytes): return .result := true;
	<hasPressed+?>: load.c32 1
	<hasPressed+?>: load.sp(+28)
	<hasPressed+?>: store.i8
	<hasPressed+?>: inc.sp(-8)
	<hasPressed+?>: ret
	cmplGfx/lib/micro.ui.ci:1063: (4 bytes): i := i + 1
	<hasPressed+?>: inc.i32(+1)
	cmplGfx/lib/micro.ui.ci:1063: (9 bytes): i < (items.length)
	<hasPressed+?>: dup.x32 sp(0)
	<hasPressed+?>: dup.x32 sp(5)
	<hasPressed+?>: clt.i32
	<hasPressed+?>: jnz -40
	<hasPressed+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:1069: (52 bytes): if ((layout) != null)
	<hasPressed+?>: dup.x32 sp(0)
	<hasPressed+?>: load.ref <?> ;Layout
	<hasPressed+?>: nfc(9) ;object.as(this: object, type: typename): pointer
	<hasPressed+?>: dup.x32 sp(0)
	<hasPressed+?>: load.ref <?> ;null
	<hasPressed+?>: ceq.i32
	<hasPressed+?>: jnz +29
	cmplGfx/lib/micro.ui.ci:1070: (25 bytes): return .result := hasPressed(layout, ...items);
	<hasPressed+?>: load.z32
	<hasPressed+?>: dup.x32 sp(1)
	<hasPressed+?>: dup.x64 sp(5)
	<hasPressed+?>: load.ref <?> ;hasPressed(this: Layout, items: View[]): bool
	<hasPressed+?>: call
	<hasPressed+?>: inc.sp(-12)
	<hasPressed+?>: load.sp(+28)
	<hasPressed+?>: store.i8
	<hasPressed+?>: inc.sp(-8)
	<hasPressed+?>: ret
	<hasPressed+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:1072: (11 bytes): return .result := false;
	<hasPressed+?>: load.z32
	<hasPressed+?>: load.sp(+24)
	<hasPressed+?>: store.i8
	<hasPressed+?>: inc.sp(-4)
	<hasPressed+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:1070: referenced as `hasPressed`
}
Window: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Window'
.file: 'cmplGfx/lib/micro.ui.ci:1076'
.field show: function (size: 84, cast: static function)
.field show: function (size: 127, cast: static function)
.field timeoutMax: int32 (size: 0, cast: static const val)
.field timeoutFps: function (size: 0, cast: static inline)
.field show: function (size: 43, cast: static function)
.field show: function (size: 83, cast: static function)
.field show: function (size: 37, cast: static function)
.field show: function (size: 17, cast: static function)
.field show: function (size: 17, cast: static function)
.field show: function (size: 171, cast: static function)
.field show: function (size: 18, cast: static function)
.field show: function (size: 177, cast: static function)
.field KEY_PRESS: int64 (size: 0, cast: static const i64)
.field KEY_RELEASE: int64 (size: 0, cast: static const i64)
.field MOUSE_WHEEL: int64 (size: 0, cast: static const i64)
.field MOUSE_PRESS: int64 (size: 0, cast: static const i64)
.field MOUSE_MOTION: int64 (size: 0, cast: static const i64)
.field MOUSE_RELEASE: int64 (size: 0, cast: static const i64)
.field FINGER_PRESS: int64 (size: 0, cast: static const i64)
.field FINGER_MOTION: int64 (size: 0, cast: static const i64)
.field FINGER_RELEASE: int64 (size: 0, cast: static const i64)
.field EVENT_TIMEOUT: int64 (size: 0, cast: static const i64)
.field WINDOW_INIT: int64 (size: 0, cast: static const i64)
.field WINDOW_CLOSE: int64 (size: 0, cast: static const i64)
.field WINDOW_ENTER: int64 (size: 0, cast: static const i64)
.field WINDOW_LEAVE: int64 (size: 0, cast: static const i64)
.field KEY_CODE_ESC: int64 (size: 0, cast: static const i64)
.field KEY_CODE_BACK: int64 (size: 0, cast: static const i64)
.field KEY_CODE_TAB: int64 (size: 0, cast: static const i64)
.field KEY_CODE_ENTER: int64 (size: 0, cast: static const i64)
.field KEY_CODE_CAPSLOCK: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PRINT_SCREEN: int64 (size: 0, cast: static const i64)
.field KEY_CODE_SCROLL_LOCK: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PAUSE: int64 (size: 0, cast: static const i64)
.field KEY_CODE_INSERT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_HOME: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PAGE_UP: int64 (size: 0, cast: static const i64)
.field KEY_CODE_DELETE: int64 (size: 0, cast: static const i64)
.field KEY_CODE_END: int64 (size: 0, cast: static const i64)
.field KEY_CODE_PAGE_DOWN: int64 (size: 0, cast: static const i64)
.field KEY_CODE_RIGHT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_LEFT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_DOWN: int64 (size: 0, cast: static const i64)
.field KEY_CODE_UP: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_ALT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_ALT: int64 (size: 0, cast: static const i64)
.field KEY_CODE_L_GUI: int64 (size: 0, cast: static const i64)
.field KEY_CODE_R_GUI: int64 (size: 0, cast: static const i64)
.field KEY_MASK_SHIFT: int64 (size: 0, cast: static const i64)
.field KEY_MASK_CTRL: int64 (size: 0, cast: static const i64)
.field KEY_MASK_ALT: int64 (size: 0, cast: static const i64)
.field show: function (size: 0, cast: static const inline)
.field setTitle: function (size: 0, cast: static const inline)
.field quit: function (size: 0, cast: static const inline)
.field font: function (size: 0, cast: static const inline)
.field font: Image (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplGfx/lib/micro.ui.ci:1343: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1328: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1324: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1320: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1313: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1311: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1308: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1306: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1303: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1301: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1297: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1295: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1295: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1277: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1273: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1271: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1247: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1233: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1232: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1231: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1230: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1212: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1211: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1210: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1209: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1186: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1159: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1124: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1119: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1115: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1109: referenced as `Window`
	cmplGfx/lib/micro.ui.ci:1106: referenced as `Window`
}
Window.show(offscreen: Image, widget: Widget): void: function {
.kind: static function
.base: `function`
.size: 84
.name: 'show'
.file: 'cmplGfx/lib/micro.ui.ci:1078'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param offscreen: Image (size: 8, cast: variable(val))
.param widget: Widget (size: 4, cast: variable(ref))
.doc: 'Show the given `widget` in a window drawn to the `offscreen` image'
.value: {
	static const WindowData: struct {
		offscreen: Image;
		widget: Widget;
		rect: Rect;
		timeout: int64 := 0;
		clicks: int32 := 0;
		time: int64 := 0;
		button: int32 := 0;
		lastX: int32 := 0;
		lastY: int32 := 0;
		isShift: bool := false;
		isCtrl: bool := false;
		isAlt: bool := false;
		key: int32 := 0;
		repeat: int32 := 0;
	};
	static dispatchEvent(window: WindowData, widget: Widget, action: int32, button: int32, x: int32, y: int32): bool := {
		if ((widget.parent) == null) {
			widget.onCreate(widget, widget);
		}
		if ((action) == Window.WINDOW_INIT) {
			return .result := true;
		}
		if ((action) == Window.WINDOW_CLOSE) {
			widget.onDestroy(widget);
			Widget.destroy(widget);
			return .result := false;
		}
		if ((action) == Window.WINDOW_ENTER) {
			return .result := false;
		}
		if ((action) == Window.WINDOW_LEAVE) {
			return .result := Widget.clearState(widget, Style.hovered);
		}
		if ((action) == Window.MOUSE_PRESS) {
			if (window.button != button || window.lastX != x || window.lastY != y) {
				window.clicks := 0;
			}
			now: int64 := System.millis();
			if (((now - window.time)) / 1000.000000 > 0.500000) {
				window.clicks := 0;
			}
			window.time := now;
			if (button == 1) {
				window.timeout := now + (1000);
			}
			else {
				window.timeout := (0);
			}
			window.button := button;
			window.lastX := x;
			window.lastY := y;
			window.clicks := window.clicks + 1;
			if (button != 1) {
				return .result := false;
			}
			event: TouchEvent := {
				event.release := false;
				event.isShift := window.isShift;
				event.isCtrl := window.isCtrl;
				event.isAlt := window.isAlt;
				event.clicks := window.clicks;
				event.button := button;
				event.x := x - window.rect.x0;
				event.y := y - window.rect.y0;
				event.dx := 0;
				event.dy := 0;
			};
			return .result := widget.onTouchEvent(widget, window.rect, event);
		}
		if ((action) == Window.MOUSE_MOTION) {
			lastX: int32 := window.lastX;
			lastY: int32 := window.lastY;
			window.time := System.millis();
			window.timeout := (0);
			window.button := button;
			window.lastX := x;
			window.lastY := y;
			window.clicks := 0;
			if (button != 0 && button != 1) {
				return .result := false;
			}
			event: TouchEvent := {
				event.release := false;
				event.isShift := window.isShift;
				event.isCtrl := window.isCtrl;
				event.isAlt := window.isAlt;
				event.clicks := window.clicks;
				event.button := button;
				event.dx := x - lastX;
				event.dy := y - lastY;
				event.x := x - window.rect.x0;
				event.y := y - window.rect.y0;
			};
			return .result := widget.onTouchEvent(widget, window.rect, event);
		}
		if ((action) == Window.MOUSE_RELEASE) {
			now: int64 := System.millis();
			if (((now - window.time)) / 1000.000000 > 0.500000) {
				window.clicks := 0;
			}
			window.timeout := (0);
			if (button != 1) {
				return .result := false;
			}
			event: TouchEvent := {
				event.release := true;
				event.isShift := window.isShift;
				event.isCtrl := window.isCtrl;
				event.isAlt := window.isAlt;
				event.clicks := window.clicks;
				event.button := button;
				event.x := x - window.rect.x0;
				event.y := y - window.rect.y0;
				event.dx := 0;
				event.dy := 0;
			};
			return .result := widget.onTouchEvent(widget, window.rect, event);
		}
		if ((action) == Window.KEY_PRESS) {
			window.isShift := ((y) & Window.KEY_MASK_SHIFT) != (0);
			window.isCtrl := ((y) & Window.KEY_MASK_CTRL) != (0);
			window.isAlt := ((y) & Window.KEY_MASK_ALT) != (0);
			if (window.key != button) {
				window.key := button;
				window.repeat := 0;
			}
			else {
				window.repeat := window.repeat + 1;
			}
			event: KeyEvent := {
				event.release := false;
				event.isShift := window.isShift;
				event.isCtrl := window.isCtrl;
				event.isAlt := window.isAlt;
				event.repeat := window.repeat;
				event.key := button;
			};
			return .result := widget.onKeyEvent(widget, event);
		}
		if ((action) == Window.KEY_RELEASE) {
			window.isShift := ((y) & Window.KEY_MASK_SHIFT) != (0);
			window.isCtrl := ((y) & Window.KEY_MASK_CTRL) != (0);
			window.isAlt := ((y) & Window.KEY_MASK_ALT) != (0);
			event: KeyEvent := {
				event.release := true;
				event.isShift := window.isShift;
				event.isCtrl := window.isCtrl;
				event.isAlt := window.isAlt;
				event.repeat := window.repeat;
				event.key := button;
			};
			window.key := 0;
			window.repeat := 0;
			return .result := widget.onKeyEvent(widget, event);
		}
		if ((action) == Window.EVENT_TIMEOUT) {
			if (window.timeout > (0)) {
				event: TouchEvent := {
					event.release := true;
					event.isShift := window.isShift;
					event.isCtrl := window.isCtrl;
					event.isAlt := window.isAlt;
					event.clicks := -1;
					event.button := window.button;
					event.x := window.lastX - window.rect.x0;
					event.y := window.lastY - window.rect.y0;
					event.dx := 0;
					event.dy := 0;
				};
				return .result := widget.onTouchEvent(widget, window.rect, event);
			}
		}
		debug("event not processed", action);
		return .result := false;
	};
	static draw(window: WindowData, widget: Widget): int32 := {
		if (!widget.enabled) {
			return .result := Window.timeoutMax;
		}
		timeout: int64 := Window.timeoutMax;
		if (window.timeout > (0)) {
			timeout := window.timeout - System.millis();
			if (timeout < (0)) {
				timeout := (Window.timeoutMax);
			}
		}
		offs: Image := window.offscreen;
		rect: Rect := window.rect;
		if (widget.measure) {
			setSize(rect, Image.width(offs), Image.height(offs));
			widget.onMeasure(widget, &rect);
			widget.measure := false;
		}
		Widget.onDraw(widget, offs, rect, 0);
		widget.redraw := false;
		return .result := timeout;
	};
	static windowEvent(win: WindowData, action: int32, button: int32, x: int32, y: int32): int32 := {
		if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
			return .result := Window.quit();
		}
		widget: Widget := win.widget;
		if ((action) == Window.FINGER_PRESS) {
			action := (Window.MOUSE_PRESS);
			button := 1;
		}
		if ((action) == Window.FINGER_MOTION) {
			action := (Window.MOUSE_MOTION);
			button := 1;
		}
		if ((action) == Window.FINGER_RELEASE) {
			action := (Window.MOUSE_RELEASE);
			button := 1;
		}
		if (!dispatchEvent(win, widget, action, button, x, y)) {
			if (!widget.redraw) {
				return .result := Window.timeoutMax;
			}
			return .result := draw(win, widget);
		}
		if (button == 0 && (action) == Window.MOUSE_MOTION) {
			return .result := draw(win, widget);
		}
		if (button != 0 && (action) == Window.MOUSE_PRESS) {
			return .result := draw(win, widget);
		}
		if ((fxWidget) != null) {
			fxWidget.onProcess(fxWidget);
		}
		return .result := draw(win, widget);
	};
	window: WindowData := {
		window.offscreen := offscreen;
		window.widget := widget;
		window.rect.x0 := 0;
		window.rect.y0 := 0;
		window.rect.x1 := 0;
		window.rect.y1 := 0;
		window.timeout := (0);
		window.clicks := 0;
		window.time := (0);
		window.button := 0;
		window.lastX := 0;
		window.lastY := 0;
		window.isShift := false;
		window.isCtrl := false;
		window.isAlt := false;
		window.key := 0;
		window.repeat := 0;
	};
	return .result := Window.show(offscreen, window, windowEvent);
}
.instructions: (84 bytes)
	cmplGfx/lib/micro.ui.ci:1338: (64 bytes): window: WindowData := {...}
	<show>  : inc.sp(+80)
	cmplGfx/lib/micro.ui.ci:1339: (3 bytes): window.offscreen := offscreen;
	<show+?>: mov.x64 sp(0, 22)
	cmplGfx/lib/micro.ui.ci:1340: (3 bytes): window.widget := widget;
	<show+?>: mov.x32 sp(2, 21)
	:: (3 bytes): window.rect.x0 := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(5)
	:: (3 bytes): window.rect.y0 := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(6)
	:: (3 bytes): window.rect.x1 := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(7)
	:: (3 bytes): window.rect.y1 := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(8)
	:: (3 bytes): window.timeout := (0);
	<show+?>: load.z64
	<show+?>: set.x64 sp(10)
	:: (3 bytes): window.clicks := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(11)
	:: (3 bytes): window.time := (0);
	<show+?>: load.z64
	<show+?>: set.x64 sp(14)
	:: (3 bytes): window.button := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(15)
	:: (3 bytes): window.lastX := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(16)
	:: (3 bytes): window.lastY := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(17)
	:: (6 bytes): window.isShift := false;
	<show+?>: load.z32
	<show+?>: load.sp(+72)
	<show+?>: store.i8
	:: (6 bytes): window.isCtrl := false;
	<show+?>: load.z32
	<show+?>: load.sp(+73)
	<show+?>: store.i8
	:: (6 bytes): window.isAlt := false;
	<show+?>: load.z32
	<show+?>: load.sp(+74)
	<show+?>: store.i8
	:: (3 bytes): window.key := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(19)
	:: (3 bytes): window.repeat := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(20)
	cmplGfx/lib/micro.ui.ci:1343: (20 bytes): return .result := Window.show(offscreen, window, windowEvent);
	<show+?>: dup.x64 sp(22)
	<show+?>: load.sp(+8)
	<show+?>: load.ref <?> ;Window.show.windowEvent(win: WindowData, action: int32, button: int32, x: int32, y: int32): int32
	<show+?>: nfc(128) ;Window.show(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void
	<show+?>: inc.sp(-80)
	<show+?>: ret
.usages:
	cmplGfx/lib/micro.ui.ci:1352: referenced as `show`
}
Window.show(widget: Widget): void: function {
.kind: static function
.base: `function`
.size: 127
.name: 'show'
.file: 'cmplGfx/lib/micro.ui.ci:1347'
.owner: Window
.param .result: void (size: 0, cast: variable(void))
.param widget: Widget (size: 4, cast: variable(ref))
.doc: 'Show the given `widget` in a window'
.value: {
	rect: Rect := {
		rect.x0 := 0;
		rect.y0 := 0;
		rect.x1 := 0;
		rect.y1 := 0;
	};
	widget.onCreate(widget, widget);
	widget.onMeasure(widget, &rect);
	offscreen: Image := Image(width(rect), height(rect), 32);
	show(offscreen, widget);
	Image.destroy(offscreen);
}
.instructions: (127 bytes)
	cmplGfx/lib/micro.ui.ci:1348: (16 bytes): rect: Rect := {...}
	<show>  : inc.sp(+16)
	:: (3 bytes): rect.x0 := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(1)
	:: (3 bytes): rect.y0 := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(2)
	:: (3 bytes): rect.x1 := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(3)
	:: (3 bytes): rect.y1 := 0;
	<show+?>: load.z32
	<show+?>: set.x32 sp(4)
	cmplGfx/lib/micro.ui.ci:1349: (16 bytes): widget.onCreate(widget, widget);
	<show+?>: dup.x32 sp(5)
	<show+?>: dup.x32 sp(6)
	<show+?>: dup.x32 sp(7)
	<show+?>: inc.i32(+40)
	<show+?>: load.i32
	<show+?>: call
	<show+?>: inc.sp(-8)
	cmplGfx/lib/micro.ui.ci:1350: (23 bytes): widget.onMeasure(widget, &rect);
	<show+?>: load.z32
	<show+?>: dup.x32 sp(6)
	<show+?>: load.sp(+8)
	<show+?>: dup.x32 sp(8)
	<show+?>: inc.i32(+56)
	<show+?>: load.i32
	<show+?>: call
	<show+?>: inc.sp(-8)
	<show+?>: inc.sp(-4)
	cmplGfx/lib/micro.ui.ci:1351: (47 bytes): offscreen: Image := Image(width(rect), height(rect), 32)
	<show+?>: load.sp(+0)
	<show+?>: dup.x32 sp(0)
	<show+?>: inc.i32(+8)
	<show+?>: load.i32
	<show+?>: dup.x32 sp(1)
	<show+?>: load.i32
	<show+?>: sub.i32
	<show+?>: set.x32 sp(1)
	<show+?>: load.sp(+4)
	<show+?>: dup.x32 sp(0)
	<show+?>: inc.i32(+12)
	<show+?>: load.i32
	<show+?>: dup.x32 sp(1)
	<show+?>: inc.i32(+4)
	<show+?>: load.i32
	<show+?>: sub.i32
	<show+?>: set.x32 sp(1)
	<show+?>: load.c32 32
	<show+?>: nfc(89) ;Image.create(width: int32, height: int32, depth: int32): Image
	cmplGfx/lib/micro.ui.ci:1352: (14 bytes): show(offscreen, widget);
	<show+?>: dup.x64 sp(0)
	<show+?>: dup.x32 sp(9)
	<show+?>: load.ref <?> ;Window.show(offscreen: Image, widget: Widget): void
	<show+?>: call
	<show+?>: inc.sp(-12)
	cmplGfx/lib/micro.ui.ci:1353: (6 bytes): Image.destroy(offscreen);
	<show+?>: dup.x64 sp(0)
	<show+?>: nfc(93) ;Image.destroy(image: Image): void
	<show+?>: inc.sp(-24)
	<show+?>: ret
.usages:
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'integer'
.file: 'cmplStd/test/test.ci:5'
.value: int64
.usages:
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitldz32'
.file: 'cmplStd/test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitldz64'
.file: 'cmplStd/test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitA'
.file: 'cmplStd/test/lang/emit.ci:6'
.value: 42
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitB'
.file: 'cmplStd/test/lang/emit.ci:7'
.value: 96
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitAddI32'
.file: 'cmplStd/test/lang/emit.ci:10'
.doc: 'Emit the calculation of `emitA + emitB`'
.value: emit(int32(emitA), int32(emitB), add.i32)
.usages:
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitDivI32'
.file: 'cmplStd/test/lang/emit.ci:13'
.doc: 'Emit the calculation of `10 / 5`'
.value: emit(int32(10), int32(5), div.i32)
.usages:
}
emitNfcF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'emitNfcF32'
.file: 'cmplStd/test/lang/emit.ci:16'
.doc: 'Emit the calculation of `float32.sin(3.14f / 2)`'
.value: emit(float32(3.140000), float32(2), div.f32, float32.sin)
.usages:
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'floatAsInt32'
.file: 'cmplStd/test/lang/emit.ci:19'
.param .result: int32 (size: 4, cast: i32)
.param value: float32 (size: 4, cast: f32)
.doc: 'interpret a 32 bit floating point number as an 32 bit integer'
.value: int32(emit(float32(value)))
.usages:
	cmplStd/test/lang/emit.ci:24: referenced as `floatAsInt32`
	cmplStd/test/lang/emit.ci:23: referenced as `floatAsInt32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'floatAsInt64'
.file: 'cmplStd/test/lang/emit.ci:21'
.param .result: int64 (size: 8, cast: i64)
.param value: float64 (size: 8, cast: f64)
.doc: 'interpret a 64 bit floating point number as an 64 bit integer'
.value: int64(emit(float64(value)))
.usages:
	cmplStd/test/lang/emit.ci:26: referenced as `floatAsInt64`
	cmplStd/test/lang/emit.ci:25: referenced as `floatAsInt64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitFloatAsInt1'
.file: 'cmplStd/test/lang/emit.ci:23'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitFloatAsInt2'
.file: 'cmplStd/test/lang/emit.ci:24'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitFloatAsInt3'
.file: 'cmplStd/test/lang/emit.ci:25'
.value: floatAsInt64(500)
.usages:
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitFloatAsInt4'
.file: 'cmplStd/test/lang/emit.ci:26'
.value: floatAsInt64(500)
.usages:
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.name: 'emitSlice'
.file: 'cmplStd/test/lang/emit.ci:30'
.value: emit(int32(3), pointer("string"))
.usages:
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'zero'
.file: 'cmplStd/test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: 0
.usages:
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `zero`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'last'
.file: 'cmplStd/test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: b
.usages:
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `last`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sum'
.file: 'cmplStd/test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: a + b
.usages:
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `sum`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'any'
.file: 'cmplStd/test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: i32)
.value: (a) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `any`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.value: a < b ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `min`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.value: a > b ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `max`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i3'
.file: 'cmplStd/test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i6'
.file: 'cmplStd/test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i2'
.file: 'cmplStd/test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i8'
.file: 'cmplStd/test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:15'
.value: zero(3, 6)
.usages:
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:16'
.value: zero(i3, i6)
.usages:
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:17'
.value: zero(i3 + 1, i6 + 1)
.usages:
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:19'
.value: last(3, 6)
.usages:
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:20'
.value: last(i3, i6)
.usages:
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:21'
.value: last(i3 + 1, i6 + 1) - 1
.usages:
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:23'
.value: sum(3, 6)
.usages:
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:24'
.value: sum(i3, i6)
.usages:
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:25'
.value: sum(i3 + 1, i6 + 1) - 2
.usages:
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:27'
.value: any(3, 6)
.usages:
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:28'
.value: any(i3, i6)
.usages:
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:29'
.value: any(i3 + 1, i6 + 1) - 1
.usages:
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:31'
.value: min(3, 6)
.usages:
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:32'
.value: min(i3, i6)
.usages:
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:33'
.value: min(i3 + 1, i6 + 1) - 1
.usages:
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'max2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:35'
.value: max(3, 6)
.usages:
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'max2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:36'
.value: max(i3, i6)
.usages:
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'max2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:37'
.value: max(i3 + 1, i6 + 1) - 1
.usages:
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sumLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: sum(a, sum(b, sum(c, d)))
.usages:
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `sumLr`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sumRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: sum(sum(sum(a, b), c), d)
.usages:
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `sumRl`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:41'
.value: sumLr(3, 6, 2, 8)
.usages:
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:42'
.value: sumRl(3, 6, 2, 8)
.usages:
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:43'
.value: sumLr(i3, i6, i2, i8)
.usages:
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:44'
.value: sumRl(i3, i6, i2, i8)
.usages:
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:45'
.value: sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
.usages:
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:46'
.value: sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
.usages:
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'anyLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: any(a, any(b, any(c, d)))
.usages:
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `anyLr`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'anyRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: any(any(any(a, b), c), d)
.usages:
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `anyRl`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:50'
.value: anyLr(3, 6, 2, 8)
.usages:
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:51'
.value: anyRl(3, 6, 2, 8)
.usages:
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:52'
.value: anyLr(i3, i6, i2, i8)
.usages:
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:53'
.value: anyRl(i3, i6, i2, i8)
.usages:
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:54'
.value: anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:55'
.value: anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'minLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: min(a, min(b, min(c, d)))
.usages:
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `minLr`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'minRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: min(min(min(a, b), c), d)
.usages:
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `minRl`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:59'
.value: minLr(3, 6, 2, 8)
.usages:
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:60'
.value: minRl(3, 6, 2, 8)
.usages:
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:61'
.value: minLr(i3, i6, i2, i8)
.usages:
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:62'
.value: minRl(i3, i6, i2, i8)
.usages:
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:63'
.value: minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:64'
.value: minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'maxLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: max(a, max(b, max(c, d)))
.usages:
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `maxLr`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'maxRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: max(max(max(a, b), c), d)
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `maxRl`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:68'
.value: maxLr(3, 6, 2, 8)
.usages:
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:69'
.value: maxRl(3, 6, 2, 8)
.usages:
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:70'
.value: maxLr(i3, i6, i2, i8)
.usages:
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:71'
.value: maxRl(i3, i6, i2, i8)
.usages:
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:72'
.value: maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:73'
.value: maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:3'
.value: 1
.usages:
	cmplStd/test/lang/overload.inline.ci:9: referenced as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, cast: i32)
.value: 2
.usages:
	cmplStd/test/lang/overload.inline.ci:10: referenced as `overload`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.value: 3
.usages:
	cmplStd/test/lang/overload.inline.ci:11: referenced as `overload`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, cast: i32)
.param a: float32 (size: 4, cast: f32)
.value: 4
.usages:
	cmplStd/test/lang/overload.inline.ci:12: referenced as `overload`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: 5
.usages:
	cmplStd/test/lang/overload.inline.ci:13: referenced as `overload`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload1'
.file: 'cmplStd/test/lang/overload.inline.ci:9'
.value: overload
.usages:
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload2'
.file: 'cmplStd/test/lang/overload.inline.ci:10'
.value: overload()
.usages:
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload3'
.file: 'cmplStd/test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload4'
.file: 'cmplStd/test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload5'
.file: 'cmplStd/test/lang/overload.inline.ci:13'
.value: overload(0, 0)
.usages:
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	cmplStd/test/lang/overload.inline.ci:25: referenced as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, cast: val)
.param value: float64 (size: 8, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, cast: val)
.param value: float64 (size: 8, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, cast: val)
.param value: Fahrenheit (size: 8, cast: val)
.value: Celsius((value.degrees - (32)) / 1.800000)
.usages:
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, cast: val)
.param value: Celsius (size: 8, cast: val)
.value: Fahrenheit(value.degrees * 1.800000 + (32))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.name: 'boilC'
.file: 'cmplStd/test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.name: 'boilF'
.file: 'cmplStd/test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'realloc'
.file: 'cmplStd/test/lang/memory.ci:3'
.param .result: pointer (size: 4, cast: ref)
.param data: pointer (size: 4, cast: ref)
.param size: int32 (size: 4, cast: i32)
.value: pointer.alloc(data, size)
.usages:
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'malloc'
.file: 'cmplStd/test/lang/memory.ci:4'
.param .result: pointer (size: 4, cast: ref)
.param size: int32 (size: 4, cast: i32)
.value: pointer.alloc(null, size)
.usages:
	cmplStd/test/lang/memory.ci:10: referenced as `malloc`
	cmplStd/test/lang/memory.ci:9: referenced as `malloc`
	cmplStd/test/lang/memory.ci:8: referenced as `malloc`
	cmplStd/test/lang/memory.ci:7: referenced as `malloc`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'free'
.file: 'cmplStd/test/lang/memory.ci:5'
.param .result: pointer (size: 4, cast: ref)
.param data: pointer (size: 4, cast: ref)
.value: pointer.alloc(data, 0)
.usages:
	cmplStd/test/lang/memory.ci:20: referenced as `free`
	cmplStd/test/lang/memory.ci:19: referenced as `free`
	cmplStd/test/lang/memory.ci:18: referenced as `free`
	cmplStd/test/lang/memory.ci:17: referenced as `free`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p1'
.file: 'cmplStd/test/lang/memory.ci:7'
.value: malloc(1024)
.usages:
	cmplStd/test/lang/memory.ci:17: referenced as `p1`
	cmplStd/test/lang/memory.ci:14: referenced as `p1`
	cmplStd/test/lang/memory.ci:13: referenced as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p2'
.file: 'cmplStd/test/lang/memory.ci:8'
.value: malloc(80)
.usages:
	cmplStd/test/lang/memory.ci:18: referenced as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p3'
.file: 'cmplStd/test/lang/memory.ci:9'
.value: malloc(160)
.usages:
	cmplStd/test/lang/memory.ci:19: referenced as `p3`
	cmplStd/test/lang/memory.ci:14: referenced as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p4'
.file: 'cmplStd/test/lang/memory.ci:10'
.value: malloc(820)
.usages:
	cmplStd/test/lang/memory.ci:20: referenced as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'val1'
.file: 'cmplStd/test/lang/memory.ci:23'
.value: 42
.usages:
	cmplStd/test/lang/memory.ci:32: referenced as `val1`
	cmplStd/test/lang/memory.ci:30: referenced as `val1`
	cmplStd/test/lang/memory.ci:29: referenced as `val1`
	cmplStd/test/lang/memory.ci:26: referenced as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'val2'
.file: 'cmplStd/test/lang/memory.ci:24'
.value: 96
.usages:
	cmplStd/test/lang/memory.ci:33: referenced as `val2`
	cmplStd/test/lang/memory.ci:29: referenced as `val2`
	cmplStd/test/lang/memory.ci:27: referenced as `val2`
}
noError(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 1
.name: 'noError'
.file: 'cmplStd/test/lang/tryExec.ci:3'
.param .result: void (size: 0, cast: variable(void))
.param ptr: pointer (size: 4, cast: variable(ref))
.value: {
}
.instructions: (1 byte)
	<noError>  : ret
.usages:
	cmplStd/test/lang/tryExec.ci:39: referenced as `noError`
}
stackOverflow(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 24
.name: 'stackOverflow'
.file: 'cmplStd/test/lang/tryExec.ci:6'
.param .result: void (size: 0, cast: variable(void))
.param ptr: pointer (size: 4, cast: variable(ref))
.value: {
	data: uint8[8192] := {
	};
	stackOverflow(ptr);
}
.instructions: (24 bytes)
	cmplStd/test/lang/tryExec.ci:8: (4 bytes): data: uint8[8192] := {...}
	<stackOverflow>  : inc.sp(+8192)
	cmplStd/test/lang/tryExec.ci:9: (15 bytes): stackOverflow(ptr);
	<stackOverflow+?>: load.sp(+8196)
	<stackOverflow+?>: load.i32
	<stackOverflow+?>: load.ref <?> ;stackOverflow(ptr: pointer): void
	<stackOverflow+?>: call
	<stackOverflow+?>: inc.sp(-4)
	<stackOverflow+?>: inc.sp(-8192)
	<stackOverflow+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:41: referenced as `stackOverflow`
	cmplStd/test/lang/tryExec.ci:9: referenced as `stackOverflow`
}
divisionByZero(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 12
.name: 'divisionByZero'
.file: 'cmplStd/test/lang/tryExec.ci:12'
.param .result: void (size: 0, cast: variable(void))
.param args: pointer (size: 4, cast: variable(ref))
.value: {
	value: int32 := 3 / 0;
}
.instructions: (12 bytes)
	cmplStd/test/lang/tryExec.ci:13: (7 bytes): value: int32 := 3 / 0
	<divisionByZero>  : load.c32 3
	<divisionByZero+?>: load.z32
	<divisionByZero+?>: div.i32
	<divisionByZero+?>: inc.sp(-4)
	<divisionByZero+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:42: referenced as `divisionByZero`
}
abortExecution(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 83
.name: 'abortExecution'
.file: 'cmplStd/test/lang/tryExec.ci:16'
.param .result: void (size: 0, cast: variable(void))
.param args: pointer (size: 4, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		details.message := ("assertion failed");
		details.expected := 97;
		details.returned := 77;
	};
	abort("fatal error", details);
}
.instructions: (83 bytes)
	cmplStd/test/lang/tryExec.ci:22: (25 bytes): details: NotEquals := {...}
	<abortExecution>  : inc.sp(+16)
	cmplStd/test/lang/tryExec.ci:23: (7 bytes): details.message := ("assertion failed");
	<abortExecution+?>: load.ref <?> ;"assertion failed"
	<abortExecution+?>: set.x32 sp(1)
	cmplStd/test/lang/tryExec.ci:24: (7 bytes): details.expected := 97;
	<abortExecution+?>: load.c32 97
	<abortExecution+?>: set.x32 sp(2)
	cmplStd/test/lang/tryExec.ci:25: (7 bytes): details.returned := 77;
	<abortExecution+?>: load.c32 77
	<abortExecution+?>: set.x32 sp(3)
	cmplStd/test/lang/tryExec.ci:27: (53 bytes): abort("fatal error", details);
	<abortExecution+?>: load.ref <?> ;abortExecution.NotEquals
	<abortExecution+?>: load.sp(+4)
	<abortExecution+?>: load.c32 1
	<abortExecution+?>: load.sp(+4)
	<abortExecution+?>: load.ref <?> ;"cmplStd/test/lang/tryExec.ci"
	<abortExecution+?>: load.c32 27
	<abortExecution+?>: load.c32 -2
	<abortExecution+?>: load.c32 128
	<abortExecution+?>: load.ref <?> ;"fatal error"
	<abortExecution+?>: dup.x64 sp(5)
	<abortExecution+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<abortExecution+?>: inc.sp(-16)
	<abortExecution+?>: inc.sp(-16)
	<abortExecution+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:45: referenced as `abortExecution`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 13
.name: 'invalidMemoryAccess'
.file: 'cmplStd/test/lang/tryExec.ci:30'
.param .result: void (size: 0, cast: variable(void))
.param args: pointer (size: 4, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes)
	cmplStd/test/lang/tryExec.ci:31: (5 bytes): i32Ref: int32 := null
	<invalidMemoryAccess>  : load.ref <?> ;null
	cmplStd/test/lang/tryExec.ci:32: (3 bytes): i32Val: int32 := i32Ref
	<invalidMemoryAccess+?>: dup.x32 sp(0)
	<invalidMemoryAccess+?>: load.i32
	<invalidMemoryAccess+?>: inc.sp(-8)
	<invalidMemoryAccess+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:44: referenced as `invalidMemoryAccess`
}
invalidInstruction(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 2
.name: 'invalidInstruction'
.file: 'cmplStd/test/lang/tryExec.ci:35'
.param .result: void (size: 0, cast: variable(void))
.param args: pointer (size: 4, cast: variable(ref))
.value: {
	emit(load.z32, ret);
}
.instructions: (2 bytes)
	cmplStd/test/lang/tryExec.ci:36: (2 bytes): emit(load.z32, ret);
	<invalidInstruction>  : load.z32
	<invalidInstruction+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:43: referenced as `invalidInstruction`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr0'
.file: 'cmplStd/test/lang/tryExec.ci:39'
.value: tryExec(null, noError)
.usages:
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr1'
.file: 'cmplStd/test/lang/tryExec.ci:40'
.value: tryExec(null, null)
.usages:
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr2'
.file: 'cmplStd/test/lang/tryExec.ci:41'
.value: tryExec(null, stackOverflow)
.usages:
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr3'
.file: 'cmplStd/test/lang/tryExec.ci:42'
.value: tryExec(null, divisionByZero)
.usages:
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr4'
.file: 'cmplStd/test/lang/tryExec.ci:43'
.value: tryExec(null, invalidInstruction)
.usages:
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr5'
.file: 'cmplStd/test/lang/tryExec.ci:44'
.value: tryExec(null, invalidMemoryAccess)
.usages:
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr6'
.file: 'cmplStd/test/lang/tryExec.ci:45'
.value: tryExec(null, abortExecution)
.usages:
}
arr: int32[5] {
.kind: variable(val)
.base: `int32[5]`
.size: 20
.name: 'arr'
.file: 'cmplStd/test/lang/pointer.ci:1'
.value: {
	arr[0] := 1;
	arr[1] := 2;
	arr[2] := 3;
	arr[3] := 4;
	arr[4] := 5;
}
.usages:
	cmplStd/test/lang/pointer.ci:9: referenced as `arr`
	cmplStd/test/lang/pointer.ci:7: referenced as `arr`
	cmplStd/test/lang/pointer.ci:6: referenced as `arr`
	cmplStd/test/lang/pointer.ci:5: referenced as `arr`
	cmplStd/test/lang/pointer.ci:4: referenced as `arr`
	cmplStd/test/lang/pointer.ci:3: referenced as `arr`
	cmplStd/test/lang/pointer.ci:2: referenced as `arr`
}
ptr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptr'
.file: 'cmplStd/test/lang/pointer.ci:2'
.value: arr
.usages:
	cmplStd/test/lang/pointer.ci:14: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:13: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:12: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:11: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:10: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:9: referenced as `ptr`
}
a0: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a0'
.file: 'cmplStd/test/lang/pointer.ci:3'
.value: arr[0]
.usages:
	cmplStd/test/lang/pointer.ci:10: referenced as `a0`
}
a1: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a1'
.file: 'cmplStd/test/lang/pointer.ci:4'
.value: arr[1]
.usages:
	cmplStd/test/lang/pointer.ci:11: referenced as `a1`
}
a2: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a2'
.file: 'cmplStd/test/lang/pointer.ci:5'
.value: arr[2]
.usages:
	cmplStd/test/lang/pointer.ci:12: referenced as `a2`
}
a3: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a3'
.file: 'cmplStd/test/lang/pointer.ci:6'
.value: arr[3]
.usages:
	cmplStd/test/lang/pointer.ci:13: referenced as `a3`
}
a4: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a4'
.file: 'cmplStd/test/lang/pointer.ci:7'
.value: arr[4]
.usages:
	cmplStd/test/lang/pointer.ci:14: referenced as `a4`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.name: 'value'
.file: 'cmplStd/test/lang/init.reference.ci:7'
.value: 42
.usages:
	cmplStd/test/lang/init.reference.ci:99: referenced as `value`
	cmplStd/test/lang/init.reference.ci:97: referenced as `value`
	cmplStd/test/lang/init.reference.ci:96: referenced as `value`
	cmplStd/test/lang/init.reference.ci:95: referenced as `value`
	cmplStd/test/lang/init.reference.ci:27: referenced as `value`
	cmplStd/test/lang/init.reference.ci:10: referenced as `value`
	cmplStd/test/lang/init.reference.ci:9: referenced as `value`
	cmplStd/test/lang/init.reference.ci:8: referenced as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'valueRef'
.file: 'cmplStd/test/lang/init.reference.ci:8'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:29: referenced as `valueRef`
	cmplStd/test/lang/init.reference.ci:12: referenced as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'valuePtr'
.file: 'cmplStd/test/lang/init.reference.ci:9'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:30: referenced as `valuePtr`
	cmplStd/test/lang/init.reference.ci:13: referenced as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'valueVar'
.file: 'cmplStd/test/lang/init.reference.ci:10'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:31: referenced as `valueVar`
	cmplStd/test/lang/init.reference.ci:14: referenced as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'fromRef'
.file: 'cmplStd/test/lang/init.reference.ci:12'
.value: valueRef
.usages:
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'fromPtr'
.file: 'cmplStd/test/lang/init.reference.ci:13'
.value: valuePtr
.usages:
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'fromVar'
.file: 'cmplStd/test/lang/init.reference.ci:14'
.value: valueVar
.usages:
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'nullRef'
.file: 'cmplStd/test/lang/init.reference.ci:16'
.value: null
.usages:
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'nullPtr'
.file: 'cmplStd/test/lang/init.reference.ci:17'
.value: null
.usages:
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'nullVar'
.file: 'cmplStd/test/lang/init.reference.ci:18'
.value: null
.usages:
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'nullTyp'
.file: 'cmplStd/test/lang/init.reference.ci:19'
.value: null
.usages:
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'nullFun'
.file: 'cmplStd/test/lang/init.reference.ci:20'
.value: null
.usages:
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.name: 'nullObj'
.file: 'cmplStd/test/lang/init.reference.ci:21'
.value: null
.usages:
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'typePtr'
.file: 'cmplStd/test/lang/init.reference.ci:23'
.value: int64
.usages:
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'typeVar'
.file: 'cmplStd/test/lang/init.reference.ci:24'
.value: int64
.usages:
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeTyp'
.file: 'cmplStd/test/lang/init.reference.ci:25'
.value: int64
.usages:
	cmplStd/test/lang/init.reference.ci:32: referenced as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'local'
.file: 'cmplStd/test/lang/init.reference.ci:27'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:28: referenced as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'copyVal'
.file: 'cmplStd/test/lang/init.reference.ci:28'
.value: local
.usages:
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'copyRef'
.file: 'cmplStd/test/lang/init.reference.ci:29'
.value: valueRef
.usages:
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'copyPtr'
.file: 'cmplStd/test/lang/init.reference.ci:30'
.value: valuePtr
.usages:
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'copyVar'
.file: 'cmplStd/test/lang/init.reference.ci:31'
.value: valueVar
.usages:
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'copyTyp'
.file: 'cmplStd/test/lang/init.reference.ci:32'
.value: typeTyp
.usages:
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrVoid'
.file: 'cmplStd/test/lang/init.reference.ci:35'
.value: void
.usages:
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrBool'
.file: 'cmplStd/test/lang/init.reference.ci:36'
.value: bool
.usages:
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrChar'
.file: 'cmplStd/test/lang/init.reference.ci:37'
.value: char
.usages:
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt8'
.file: 'cmplStd/test/lang/init.reference.ci:38'
.value: int8
.usages:
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt16'
.file: 'cmplStd/test/lang/init.reference.ci:39'
.value: int16
.usages:
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt32'
.file: 'cmplStd/test/lang/init.reference.ci:40'
.value: int32
.usages:
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt64'
.file: 'cmplStd/test/lang/init.reference.ci:41'
.value: int64
.usages:
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint8'
.file: 'cmplStd/test/lang/init.reference.ci:42'
.value: uint8
.usages:
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint16'
.file: 'cmplStd/test/lang/init.reference.ci:43'
.value: uint16
.usages:
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint32'
.file: 'cmplStd/test/lang/init.reference.ci:44'
.value: uint32
.usages:
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint64'
.file: 'cmplStd/test/lang/init.reference.ci:45'
.value: uint64
.usages:
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:46'
.value: float32
.usages:
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:47'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:105: referenced as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrTypename'
.file: 'cmplStd/test/lang/init.reference.ci:48'
.value: typename
.usages:
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFunction'
.file: 'cmplStd/test/lang/init.reference.ci:49'
.value: function
.usages:
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrPointer'
.file: 'cmplStd/test/lang/init.reference.ci:50'
.value: pointer
.usages:
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrVariant'
.file: 'cmplStd/test/lang/init.reference.ci:51'
.value: variant
.usages:
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrObject'
.file: 'cmplStd/test/lang/init.reference.ci:52'
.value: object
.usages:
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varVoid'
.file: 'cmplStd/test/lang/init.reference.ci:55'
.value: void
.usages:
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varBool'
.file: 'cmplStd/test/lang/init.reference.ci:56'
.value: bool
.usages:
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varChar'
.file: 'cmplStd/test/lang/init.reference.ci:57'
.value: char
.usages:
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt8'
.file: 'cmplStd/test/lang/init.reference.ci:58'
.value: int8
.usages:
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt16'
.file: 'cmplStd/test/lang/init.reference.ci:59'
.value: int16
.usages:
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt32'
.file: 'cmplStd/test/lang/init.reference.ci:60'
.value: int32
.usages:
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt64'
.file: 'cmplStd/test/lang/init.reference.ci:61'
.value: int64
.usages:
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint8'
.file: 'cmplStd/test/lang/init.reference.ci:62'
.value: uint8
.usages:
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint16'
.file: 'cmplStd/test/lang/init.reference.ci:63'
.value: uint16
.usages:
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint32'
.file: 'cmplStd/test/lang/init.reference.ci:64'
.value: uint32
.usages:
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint64'
.file: 'cmplStd/test/lang/init.reference.ci:65'
.value: uint64
.usages:
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:66'
.value: float32
.usages:
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:67'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:108: referenced as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varTypename'
.file: 'cmplStd/test/lang/init.reference.ci:68'
.value: typename
.usages:
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFunction'
.file: 'cmplStd/test/lang/init.reference.ci:69'
.value: function
.usages:
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varPointer'
.file: 'cmplStd/test/lang/init.reference.ci:70'
.value: pointer
.usages:
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varVariant'
.file: 'cmplStd/test/lang/init.reference.ci:71'
.value: variant
.usages:
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varObject'
.file: 'cmplStd/test/lang/init.reference.ci:72'
.value: object
.usages:
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typVoid'
.file: 'cmplStd/test/lang/init.reference.ci:75'
.value: void
.usages:
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typBool'
.file: 'cmplStd/test/lang/init.reference.ci:76'
.value: bool
.usages:
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typChar'
.file: 'cmplStd/test/lang/init.reference.ci:77'
.value: char
.usages:
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt8'
.file: 'cmplStd/test/lang/init.reference.ci:78'
.value: int8
.usages:
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt16'
.file: 'cmplStd/test/lang/init.reference.ci:79'
.value: int16
.usages:
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt32'
.file: 'cmplStd/test/lang/init.reference.ci:80'
.value: int32
.usages:
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt64'
.file: 'cmplStd/test/lang/init.reference.ci:81'
.value: int64
.usages:
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint8'
.file: 'cmplStd/test/lang/init.reference.ci:82'
.value: uint8
.usages:
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint16'
.file: 'cmplStd/test/lang/init.reference.ci:83'
.value: uint16
.usages:
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint32'
.file: 'cmplStd/test/lang/init.reference.ci:84'
.value: uint32
.usages:
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint64'
.file: 'cmplStd/test/lang/init.reference.ci:85'
.value: uint64
.usages:
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:86'
.value: float32
.usages:
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:87'
.value: float64
.usages:
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typTypename'
.file: 'cmplStd/test/lang/init.reference.ci:88'
.value: typename
.usages:
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFunction'
.file: 'cmplStd/test/lang/init.reference.ci:89'
.value: function
.usages:
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typPointer'
.file: 'cmplStd/test/lang/init.reference.ci:90'
.value: pointer
.usages:
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typVariant'
.file: 'cmplStd/test/lang/init.reference.ci:91'
.value: variant
.usages:
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typObject'
.file: 'cmplStd/test/lang/init.reference.ci:92'
.value: object
.usages:
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'valueOfPtr'
.file: 'cmplStd/test/lang/init.reference.ci:95'
.value: pointer(value)
.usages:
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'valueOfVar'
.file: 'cmplStd/test/lang/init.reference.ci:96'
.value: variant(value)
.usages:
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'valueOfTyp'
.file: 'cmplStd/test/lang/init.reference.ci:97'
.value: typename(value)
.usages:
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeOfValue'
.file: 'cmplStd/test/lang/init.reference.ci:99'
.value: typename(value)
.usages:
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'copyPtrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:105'
.value: ptrFloat64
.usages:
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'copyVarFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:108'
.value: varFloat64
.usages:
}
variable: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'variable'
.file: 'cmplStd/test/lang/init.variable.ci:3'
.doc: 'Uninitialized variables will be initialized with default type initializer: 0'
.usages:
}
constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'cmplStd/test/lang/init.variable.ci:7'
.doc: 'Constant variables must be explicitly initialized'
.value: 42
.usages:
}
ComplexVal: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'ComplexVal'
.file: 'cmplStd/test/lang/init.variable.ci:9'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `ComplexVal`
}
ComplexVal.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:10'
.owner: ComplexVal
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `re`
}
ComplexVal.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:11'
.owner: ComplexVal
.value: 0
.usages:
	internal usages: 1
}
ComplexObj: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.name: 'ComplexObj'
.file: 'cmplStd/test/lang/init.variable.ci:13'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `ComplexObj`
	cmplStd/test/lang/init.variable.ci:33: referenced as `ComplexObj`
}
ComplexObj.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:14'
.owner: ComplexObj
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `re`
	cmplStd/test/lang/init.variable.ci:33: referenced as `re`
}
ComplexObj.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:15'
.owner: ComplexObj
.value: 0
.usages:
	internal usages: 2
}
valInitImplicit: ComplexVal {
.kind: variable(val)
.base: `ComplexVal`
.size: 16
.name: 'valInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:24'
.doc: 'Value types must be explicitly initialized
the initializer will be extended with implicit field initializers
{re: 8} => {
valInitImplicit.re := 8;
valInitImplicit.im := 0;
}'
.value: {
	valInitImplicit.re := (8);
	valInitImplicit.im := (0);
}
.usages:
}
objInitImplicit: ComplexObj {
.kind: variable(ref)
.base: `ComplexObj`
.size: 4
.name: 'objInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:33'
.doc: 'Reference types must be explicitly initialized
the initializer will be extended with instance creation
{re: 8} => {
objInitImplicit := Object.create(ComplexObj);
objInitImplicit.re := 8;
objInitImplicit.im := 0;
}'
.value: {
	objInitImplicit := create(ComplexObj);
	objInitImplicit.re := (8);
	objInitImplicit.im := (0);
}
.usages:
}
objInitExplicit: object {
.kind: variable(ref)
.base: `object`
.size: 4
.name: 'objInitExplicit'
.file: 'cmplStd/test/lang/init.variable.ci:41'
.doc: 'variable type can be base type of the explicit initializer type
ComplexObj {re: 8} => {
objInitExplicit := Object.create(ComplexObj);
objInitExplicit.re := 8;
objInitExplicit.im := 0;
}'
.value: {
	objInitExplicit := create(ComplexObj);
	objInitExplicit.re := (8);
	objInitExplicit.im := (0);
}
.usages:
}
empty(): void: function {
.kind: static function
.base: `function`
.size: 1
.name: 'empty'
.file: 'cmplStd/test/lang/function.ci:4'
.param .result: void (size: 0, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte)
	<empty>  : ret
.usages:
}
funAdd(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.name: 'funAdd'
.file: 'cmplStd/test/lang/function.ci:7'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return .result := x + y;
}
.instructions: (8 bytes)
	cmplStd/test/lang/function.ci:8: (8 bytes): return .result := x + y;
	<funAdd>  : dup.x32 sp(2)
	<funAdd+?>: dup.x32 sp(2)
	<funAdd+?>: add.i32
	<funAdd+?>: set.x32 sp(4)
	<funAdd+?>: ret
.usages:
	cmplStd/test/lang/function.ci:15: referenced as `funAdd`
	cmplStd/test/lang/function.ci:12: referenced as `funAdd`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funAddResult'
.file: 'cmplStd/test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(2, 7)
.usages:
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funAddRef'
.file: 'cmplStd/test/lang/function.ci:15'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	cmplStd/test/lang/function.ci:18: referenced as `funAddRef`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funAddRefResult'
.file: 'cmplStd/test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(2, 8)
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:21'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:27: referenced as `funMul`
	cmplStd/test/lang/function.ci:24: referenced as `funMul`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funMulResult'
.file: 'cmplStd/test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(2, 6)
.usages:
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funMulRef'
.file: 'cmplStd/test/lang/function.ci:27'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:30: referenced as `funMulRef`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funMulRefResult'
.file: 'cmplStd/test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(2, 7)
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:33'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	cmplStd/test/lang/function.ci:34: (8 bytes): return .result := x * y;
	<funMul>  : dup.x32 sp(2)
	<funMul+?>: dup.x32 sp(2)
	<funMul+?>: mul.i32
	<funMul+?>: set.x32 sp(4)
	<funMul+?>: ret
.usages:
}
fib(n: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 54
.name: 'fib'
.file: 'cmplStd/test/lang/function.ci:38'
.param .result: uint32 (size: 4, cast: variable(u32))
.param n: uint32 (size: 4, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (n <= (1)) {
		return .result := n;
	}
	return .result := fib(n - (1)) + fib(n - (2));
}
.instructions: (54 bytes)
	cmplStd/test/lang/function.ci:39: (16 bytes): if (n <= (1))
	<fib>  : dup.x32 sp(1)
	<fib+?>: load.c32 1
	<fib+?>: cgt.u32
	<fib+?>: jnz +8
	cmplStd/test/lang/function.ci:40: (4 bytes): return .result := n;
	<fib+?>: mov.x32 sp(2, 1)
	<fib+?>: ret
	cmplStd/test/lang/function.ci:42: (38 bytes): return .result := fib(n - (1)) + fib(n - (2));
	<fib+?>: load.z32
	<fib+?>: dup.x32 sp(2)
	<fib+?>: inc.i32(-1)
	<fib+?>: load.ref <?> ;fib(n: uint32): uint32
	<fib+?>: call
	<fib+?>: inc.sp(-4)
	<fib+?>: load.z32
	<fib+?>: dup.x32 sp(3)
	<fib+?>: inc.i32(-2)
	<fib+?>: load.ref <?> ;fib(n: uint32): uint32
	<fib+?>: call
	<fib+?>: inc.sp(-4)
	<fib+?>: add.i32
	<fib+?>: set.x32 sp(3)
	<fib+?>: ret
.usages:
	cmplStd/test/lang/function.ci:46: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'fibonacci_13'
.file: 'cmplStd/test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofVoid'
.file: 'cmplStd/test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofBool'
.file: 'cmplStd/test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofChar'
.file: 'cmplStd/test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt8'
.file: 'cmplStd/test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt16'
.file: 'cmplStd/test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt32'
.file: 'cmplStd/test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt64'
.file: 'cmplStd/test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint8'
.file: 'cmplStd/test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint16'
.file: 'cmplStd/test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint32'
.file: 'cmplStd/test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint64'
.file: 'cmplStd/test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFloat32'
.file: 'cmplStd/test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFloat64'
.file: 'cmplStd/test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofPointer'
.file: 'cmplStd/test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofVariant'
.file: 'cmplStd/test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofTypename'
.file: 'cmplStd/test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFunction'
.file: 'cmplStd/test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofObject'
.file: 'cmplStd/test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.name: 'RecordSizeof'
.file: 'cmplStd/test/lang/reflect.ci:22'
.field x: int64 (size: 8, cast: variable(i64))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:26: referenced as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.name: 'RecordSizeofExt'
.file: 'cmplStd/test/lang/reflect.ci:26'
.field y: int32 (size: 4, cast: variable(i32))
.field x: int64 (size: 8, cast: variable(i64))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.file: 'cmplStd/test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofRecord'
.file: 'cmplStd/test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	cmplStd/test/lang/reflect.ci:37: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:35: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:34: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:33: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:32: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:31: referenced as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'nameOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:33'
.value: typeofRecord.size
.usages:
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'fileOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lineOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase'
.file: 'cmplStd/test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	cmplStd/test/lang/reflect.ci:44: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:42: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:41: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:40: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:39: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:38: referenced as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'nameOfBase'
.file: 'cmplStd/test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase'
.file: 'cmplStd/test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase'
.file: 'cmplStd/test/lang/reflect.ci:40'
.value: typeofBase.size
.usages:
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'fileOfBase'
.file: 'cmplStd/test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lineOfBase'
.file: 'cmplStd/test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase1'
.file: 'cmplStd/test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:46: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:45: referenced as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase2'
.file: 'cmplStd/test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `typeofBase2`
	cmplStd/test/lang/reflect.ci:49: referenced as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'RecordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:2'
.field Inner: typename (size: 8, cast: static const typename(val))
.field member: int32 (size: 4, cast: variable(i32))
.field constant: int32 (size: 4, cast: const variable(i32))
.field memberInit: int32 (size: 4, cast: variable(i32))
.field constantInit: int32 (size: 4, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, cast: const variable(val))
.field global: int32 (size: 4, cast: static variable(i32))
.field globalInit: int32 (size: 4, cast: static variable(i32))
.field globalConstant: int32 (size: 4, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, cast: static const variable(val))
.doc: 'test and documentation of member initializations'
.usages:
	cmplStd/test/lang/init.member.ci:52: referenced as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Inner'
.file: 'cmplStd/test/lang/init.member.ci:4'
.owner: RecordMemberTest
.field member: int32 (size: 4, cast: variable(i32))
.field constant: int32 (size: 4, cast: const variable(i32))
.usages:
	cmplStd/test/lang/init.member.ci:49: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:46: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:43: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:25: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:22: referenced as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:5'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:64: referenced as `member`
	cmplStd/test/lang/init.member.ci:59: referenced as `member`
	cmplStd/test/lang/init.member.ci:49: referenced as `member`
	cmplStd/test/lang/init.member.ci:46: referenced as `member`
	internal usages: 1
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:65: referenced as `constant`
	cmplStd/test/lang/init.member.ci:60: referenced as `constant`
	cmplStd/test/lang/init.member.ci:49: referenced as `constant`
	cmplStd/test/lang/init.member.ci:46: referenced as `constant`
	cmplStd/test/lang/init.member.ci:43: referenced as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:10'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:53: referenced as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:13'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:54: referenced as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'memberInit'
.file: 'cmplStd/test/lang/init.member.ci:16'
.owner: RecordMemberTest
.value: 2
.usages:
	cmplStd/test/lang/init.member.ci:55: referenced as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constantInit'
.file: 'cmplStd/test/lang/init.member.ci:19'
.owner: RecordMemberTest
.value: 3
.usages:
	cmplStd/test/lang/init.member.ci:56: referenced as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'memberRec'
.file: 'cmplStd/test/lang/init.member.ci:22'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:58: referenced as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'constantRec'
.file: 'cmplStd/test/lang/init.member.ci:25'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:63: referenced as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.name: 'global'
.file: 'cmplStd/test/lang/init.member.ci:34'
.owner: RecordMemberTest
.usages:
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.name: 'globalInit'
.file: 'cmplStd/test/lang/init.member.ci:37'
.owner: RecordMemberTest
.value: 1
.usages:
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.name: 'globalConstant'
.file: 'cmplStd/test/lang/init.member.ci:40'
.owner: RecordMemberTest
.value: 2
.usages:
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalRec'
.file: 'cmplStd/test/lang/init.member.ci:43'
.owner: RecordMemberTest
.value: {
	globalRec.constant := 4;
	globalRec.member := (0);
}
.usages:
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalRecInit'
.file: 'cmplStd/test/lang/init.member.ci:46'
.owner: RecordMemberTest
.value: {
	globalRecInit.member := 4;
	globalRecInit.constant := 5;
}
.usages:
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalConstantRec'
.file: 'cmplStd/test/lang/init.member.ci:49'
.owner: RecordMemberTest
.value: {
	globalConstantRec.member := 6;
	globalConstantRec.constant := 7;
}
.usages:
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.name: 'recordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:52'
.value: {
	recordMemberTest.member := 10;
	recordMemberTest.constant := 11;
	recordMemberTest.memberInit := 12;
	recordMemberTest.constantInit := 13;
	recordMemberTest.memberRec.member := 14;
	recordMemberTest.memberRec.constant := 15;
	recordMemberTest.constantRec.member := 16;
	recordMemberTest.constantRec.constant := 17;
}
.usages:
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'RecordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:4'
.field staticMethod: function (size: 54, cast: static function)
.field forwardMethod: function (size: 4, cast: static variable(ref))
.field abstractMethod: function (size: 4, cast: variable(ref))
.field delegateMethod: function (size: 4, cast: variable(ref))
.field virtualMethod: function (size: 54, cast: static function)
.field virtualMethod: function (size: 4, cast: const variable(ref))
.field forwardMethod: function (size: 54, cast: static function)
.doc: 'static, virtual and abstract methods'
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:90: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:87: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:84: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:62: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:57: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:47: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:40: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:32: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:25: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:18: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:10: referenced as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace("staticMethod", x);
}
.instructions: (54 bytes)
	cmplStd/test/lang/init.method.ci:11: (53 bytes): trace("staticMethod", x);
	<staticMethod>  : load.ref <?> ;int32
	<staticMethod+?>: load.sp(+8)
	<staticMethod+?>: load.c32 1
	<staticMethod+?>: load.sp(+4)
	<staticMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+?>: load.c32 11
	<staticMethod+?>: load.c32 14
	<staticMethod+?>: load.c32 128
	<staticMethod+?>: load.ref <?> ;"staticMethod"
	<staticMethod+?>: dup.x64 sp(5)
	<staticMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<staticMethod+?>: inc.sp(-16)
	<staticMethod+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:101: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:87: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:78: referenced as `staticMethod`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 0, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	cmplStd/test/lang/init.method.ci:32: referenced as `forwardMethod`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'abstractMethod'
.file: 'cmplStd/test/lang/init.method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 0, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `abstractMethod`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'delegateMethod'
.file: 'cmplStd/test/lang/init.method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 0, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	internal usages: 1
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: {
	trace("virtualMethod", x);
}
.instructions: (54 bytes)
	cmplStd/test/lang/init.method.ci:41: (53 bytes): trace("virtualMethod", x);
	<virtualMethod>  : load.ref <?> ;int32
	<virtualMethod+?>: load.sp(+8)
	<virtualMethod+?>: load.c32 1
	<virtualMethod+?>: load.sp(+4)
	<virtualMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+?>: load.c32 41
	<virtualMethod+?>: load.c32 14
	<virtualMethod+?>: load.c32 128
	<virtualMethod+?>: load.ref <?> ;"virtualMethod"
	<virtualMethod+?>: dup.x64 sp(5)
	<virtualMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<virtualMethod+?>: inc.sp(-16)
	<virtualMethod+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `virtualMethod`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:93: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:79: referenced as `virtualMethod`
	internal usages: 1
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace("forwardMethod", x);
}
.instructions: (54 bytes)
	cmplStd/test/lang/init.method.ci:48: (53 bytes): trace("forwardMethod", x);
	<forwardMethod>  : load.ref <?> ;int32
	<forwardMethod+?>: load.sp(+8)
	<forwardMethod+?>: load.c32 1
	<forwardMethod+?>: load.sp(+4)
	<forwardMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<forwardMethod+?>: load.c32 48
	<forwardMethod+?>: load.c32 14
	<forwardMethod+?>: load.c32 128
	<forwardMethod+?>: load.ref <?> ;"forwardMethod"
	<forwardMethod+?>: dup.x64 sp(5)
	<forwardMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<forwardMethod+?>: inc.sp(-16)
	<forwardMethod+?>: ret
.usages:
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'globalFunction'
.file: 'cmplStd/test/lang/init.method.ci:57'
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.value: {
	trace("globalFunction", x);
}
.instructions: (54 bytes)
	cmplStd/test/lang/init.method.ci:58: (53 bytes): trace("globalFunction", x);
	<globalFunction>  : load.ref <?> ;int32
	<globalFunction+?>: load.sp(+8)
	<globalFunction+?>: load.c32 1
	<globalFunction+?>: load.sp(+4)
	<globalFunction+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<globalFunction+?>: load.c32 58
	<globalFunction+?>: load.c32 14
	<globalFunction+?>: load.c32 128
	<globalFunction+?>: load.ref <?> ;"globalFunction"
	<globalFunction+?>: dup.x64 sp(5)
	<globalFunction+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<globalFunction+?>: inc.sp(-16)
	<globalFunction+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `globalFunction`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.name: 'recordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:62'
.doc: 'create an instance of the type '
.value: {
	recordMethodTest.abstractMethod := globalFunction;
	recordMethodTest.delegateMethod := forwardMethod;
	recordMethodTest.virtualMethod := virtualMethod;
}
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:102: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:98: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:97: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:79: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:78: referenced as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 65
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:84'
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if ((this) != null) {
		RecordMethodTest.staticMethod(this, x);
	}
}
.instructions: (65 bytes)
	cmplStd/test/lang/init.method.ci:85: (36 bytes): debug("extension.staticMethod");
	<staticMethod>  : load.z32
	<staticMethod+?>: load.sp(+4)
	<staticMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+?>: load.c32 85
	<staticMethod+?>: load.c32 14
	<staticMethod+?>: load.z32
	<staticMethod+?>: load.ref <?> ;"extension.staticMethod"
	<staticMethod+?>: dup.x64 sp(5)
	<staticMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<staticMethod+?>: inc.sp(-8)
	cmplStd/test/lang/init.method.ci:86: (28 bytes): if ((this) != null)
	<staticMethod+?>: load.sp(+8)
	<staticMethod+?>: load.ref <?> ;null
	<staticMethod+?>: ceq.i32
	<staticMethod+?>: jnz +18
	cmplStd/test/lang/init.method.ci:87: (14 bytes): RecordMethodTest.staticMethod(this, x);
	<staticMethod+?>: dup.x128 sp(2)
	<staticMethod+?>: dup.x32 sp(5)
	<staticMethod+?>: load.ref <?> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+?>: call
	<staticMethod+?>: inc.sp(-20)
	<staticMethod+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:97: referenced as `staticMethod`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 62
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:90'
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if ((this) != null) {
		this.virtualMethod(this, x);
	}
}
.instructions: (62 bytes)
	cmplStd/test/lang/init.method.ci:91: (36 bytes): debug("extension.virtualMethod");
	<virtualMethod>  : load.z32
	<virtualMethod+?>: load.sp(+4)
	<virtualMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+?>: load.c32 91
	<virtualMethod+?>: load.c32 14
	<virtualMethod+?>: load.z32
	<virtualMethod+?>: load.ref <?> ;"extension.virtualMethod"
	<virtualMethod+?>: dup.x64 sp(5)
	<virtualMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<virtualMethod+?>: inc.sp(-8)
	cmplStd/test/lang/init.method.ci:92: (25 bytes): if ((this) != null)
	<virtualMethod+?>: load.sp(+8)
	<virtualMethod+?>: load.ref <?> ;null
	<virtualMethod+?>: ceq.i32
	<virtualMethod+?>: jnz +15
	cmplStd/test/lang/init.method.ci:93: (11 bytes): this.virtualMethod(this, x);
	<virtualMethod+?>: dup.x128 sp(2)
	<virtualMethod+?>: dup.x32 sp(5)
	<virtualMethod+?>: dup.x32 sp(9)
	<virtualMethod+?>: call
	<virtualMethod+?>: inc.sp(-20)
	<virtualMethod+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:98: referenced as `virtualMethod`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'rgbF32'
.file: 'cmplStd/test/lang/recUnion.ci:2'
.field r: float32 (size: 4, cast: variable(f32))
.field g: float32 (size: 4, cast: variable(f32))
.field b: float32 (size: 4, cast: variable(f32))
.usages:
	cmplStd/test/lang/recUnion.ci:23: referenced as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.name: 'rgbU8'
.file: 'cmplStd/test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, cast: variable(u32))
.field g: uint8 (size: 1, cast: variable(u32))
.field r: uint8 (size: 1, cast: variable(u32))
.usages:
	cmplStd/test/lang/recUnion.ci:28: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:27: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:26: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:18: referenced as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `b`
	cmplStd/test/lang/recUnion.ci:28: referenced as `b`
	cmplStd/test/lang/recUnion.ci:27: referenced as `b`
	cmplStd/test/lang/recUnion.ci:26: referenced as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `g`
	cmplStd/test/lang/recUnion.ci:28: referenced as `g`
	cmplStd/test/lang/recUnion.ci:27: referenced as `g`
	cmplStd/test/lang/recUnion.ci:26: referenced as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `r`
	cmplStd/test/lang/recUnion.ci:28: referenced as `r`
	cmplStd/test/lang/recUnion.ci:27: referenced as `r`
	cmplStd/test/lang/recUnion.ci:26: referenced as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.name: 'color'
.file: 'cmplStd/test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, cast: variable(u32))
.field rgb: rgbU8 (size: 3, cast: variable(val))
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `color`
	cmplStd/test/lang/recUnion.ci:30: referenced as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'col'
.file: 'cmplStd/test/lang/recUnion.ci:17'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:30: referenced as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'rgb'
.file: 'cmplStd/test/lang/recUnion.ci:18'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.name: 'Color'
.file: 'cmplStd/test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, cast: variable(val))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.name: 'value'
.file: 'cmplStd/test/lang/recUnion.ci:23'
.owner: Color
.usages:
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'black'
.file: 'cmplStd/test/lang/recUnion.ci:26'
.value: {
	black.r := (0);
	black.g := (0);
	black.b := (0);
}
.usages:
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'green'
.file: 'cmplStd/test/lang/recUnion.ci:27'
.value: {
	green.r := (0);
	green.g := (255);
	green.b := (0);
}
.usages:
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'white'
.file: 'cmplStd/test/lang/recUnion.ci:28'
.value: {
	white.r := (255);
	white.g := (255);
	white.b := (255);
}
.usages:
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.name: 'cyan'
.file: 'cmplStd/test/lang/recUnion.ci:30'
.value: {
	cyan.col := (65535);
}
.usages:
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.name: 'blue'
.file: 'cmplStd/test/lang/recUnion.ci:31'
.value: {
	blue.rgb.r := (0);
	blue.rgb.g := (0);
	blue.rgb.b := (255);
}
.usages:
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'record_pack0'
.file: 'cmplStd/test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.name: 'record_pack1'
.file: 'cmplStd/test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.name: 'record_pack2'
.file: 'cmplStd/test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'record_pack4'
.file: 'cmplStd/test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'record_pack8'
.file: 'cmplStd/test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'record_packDef'
.file: 'cmplStd/test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'a'
.file: 'cmplStd/test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	cmplStd/test/lang/useOperator.ci:260: referenced as `a`
	cmplStd/test/lang/useOperator.ci:237: referenced as `a`
	cmplStd/test/lang/useOperator.ci:214: referenced as `a`
	cmplStd/test/lang/useOperator.ci:191: referenced as `a`
	cmplStd/test/lang/useOperator.ci:168: referenced as `a`
	cmplStd/test/lang/useOperator.ci:145: referenced as `a`
	cmplStd/test/lang/useOperator.ci:122: referenced as `a`
	cmplStd/test/lang/useOperator.ci:99: referenced as `a`
	cmplStd/test/lang/useOperator.ci:76: referenced as `a`
	cmplStd/test/lang/useOperator.ci:53: referenced as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'b'
.file: 'cmplStd/test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	cmplStd/test/lang/useOperator.ci:261: referenced as `b`
	cmplStd/test/lang/useOperator.ci:238: referenced as `b`
	cmplStd/test/lang/useOperator.ci:215: referenced as `b`
	cmplStd/test/lang/useOperator.ci:192: referenced as `b`
	cmplStd/test/lang/useOperator.ci:169: referenced as `b`
	cmplStd/test/lang/useOperator.ci:146: referenced as `b`
	cmplStd/test/lang/useOperator.ci:123: referenced as `b`
	cmplStd/test/lang/useOperator.ci:100: referenced as `b`
	cmplStd/test/lang/useOperator.ci:77: referenced as `b`
	cmplStd/test/lang/useOperator.ci:54: referenced as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'shift'
.file: 'cmplStd/test/lang/useOperator.ci:5'
.value: 2
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:228: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:227: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:205: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:204: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:182: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:181: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:159: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:158: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:136: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:135: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:113: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:112: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:90: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:89: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:67: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:66: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:44: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:43: referenced as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolA'
.file: 'cmplStd/test/lang/useOperator.ci:7'
.value: true
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolB'
.file: 'cmplStd/test/lang/useOperator.ci:8'
.value: !false
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:22: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolAnd'
.file: 'cmplStd/test/lang/useOperator.ci:17'
.value: boolA & boolB
.usages:
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolIor'
.file: 'cmplStd/test/lang/useOperator.ci:18'
.value: boolA | boolB
.usages:
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolXor'
.file: 'cmplStd/test/lang/useOperator.ci:19'
.value: boolA ^ boolB
.usages:
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolNot'
.file: 'cmplStd/test/lang/useOperator.ci:22'
.value: !boolB
.usages:
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCeq'
.file: 'cmplStd/test/lang/useOperator.ci:23'
.value: boolA == boolB
.usages:
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCne'
.file: 'cmplStd/test/lang/useOperator.ci:24'
.value: boolA != boolB
.usages:
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolClt'
.file: 'cmplStd/test/lang/useOperator.ci:25'
.value: boolA < boolB
.usages:
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCle'
.file: 'cmplStd/test/lang/useOperator.ci:26'
.value: boolA <= boolB
.usages:
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCgt'
.file: 'cmplStd/test/lang/useOperator.ci:27'
.value: boolA > boolB
.usages:
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCge'
.file: 'cmplStd/test/lang/useOperator.ci:28'
.value: boolA >= boolB
.usages:
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrA'
.file: 'cmplStd/test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:44: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:43: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrB'
.file: 'cmplStd/test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:45: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:34: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:33: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:32: referenced as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrPls'
.file: 'cmplStd/test/lang/useOperator.ci:32'
.value: +chrB
.usages:
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrNeg'
.file: 'cmplStd/test/lang/useOperator.ci:33'
.value: -chrB
.usages:
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrCmt'
.file: 'cmplStd/test/lang/useOperator.ci:34'
.value: ~chrB
.usages:
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrAdd'
.file: 'cmplStd/test/lang/useOperator.ci:35'
.value: chrA + chrB
.usages:
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrSub'
.file: 'cmplStd/test/lang/useOperator.ci:36'
.value: chrA - chrB
.usages:
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrMul'
.file: 'cmplStd/test/lang/useOperator.ci:37'
.value: chrA * chrB
.usages:
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrDiv'
.file: 'cmplStd/test/lang/useOperator.ci:38'
.value: chrA / chrB
.usages:
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrMod'
.file: 'cmplStd/test/lang/useOperator.ci:39'
.value: chrA % chrB
.usages:
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrAnd'
.file: 'cmplStd/test/lang/useOperator.ci:40'
.value: chrA & chrB
.usages:
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrIor'
.file: 'cmplStd/test/lang/useOperator.ci:41'
.value: chrA | chrB
.usages:
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrXor'
.file: 'cmplStd/test/lang/useOperator.ci:42'
.value: chrA ^ chrB
.usages:
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrShl'
.file: 'cmplStd/test/lang/useOperator.ci:43'
.value: (chrA) << shift
.usages:
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrShr'
.file: 'cmplStd/test/lang/useOperator.ci:44'
.value: (chrA) >> shift
.usages:
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrNot'
.file: 'cmplStd/test/lang/useOperator.ci:45'
.value: !(chrB)
.usages:
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:46'
.value: chrA == chrB
.usages:
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCne'
.file: 'cmplStd/test/lang/useOperator.ci:47'
.value: chrA != chrB
.usages:
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrClt'
.file: 'cmplStd/test/lang/useOperator.ci:48'
.value: chrA < chrB
.usages:
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCle'
.file: 'cmplStd/test/lang/useOperator.ci:49'
.value: chrA <= chrB
.usages:
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCgt'
.file: 'cmplStd/test/lang/useOperator.ci:50'
.value: chrA > chrB
.usages:
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCge'
.file: 'cmplStd/test/lang/useOperator.ci:51'
.value: chrA >= chrB
.usages:
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8A'
.file: 'cmplStd/test/lang/useOperator.ci:53'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:67: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:66: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8B'
.file: 'cmplStd/test/lang/useOperator.ci:54'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:68: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:57: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:56: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:55: referenced as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:55'
.value: +i8B
.usages:
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:56'
.value: -i8B
.usages:
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:57'
.value: ~i8B
.usages:
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Add'
.file: 'cmplStd/test/lang/useOperator.ci:58'
.value: i8A + i8B
.usages:
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:59'
.value: i8A - i8B
.usages:
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:60'
.value: i8A * i8B
.usages:
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Div'
.file: 'cmplStd/test/lang/useOperator.ci:61'
.value: i8A / i8B
.usages:
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:62'
.value: i8A % i8B
.usages:
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8And'
.file: 'cmplStd/test/lang/useOperator.ci:63'
.value: i8A & i8B
.usages:
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:64'
.value: i8A | i8B
.usages:
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:65'
.value: i8A ^ i8B
.usages:
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:66'
.value: (i8A) << shift
.usages:
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:67'
.value: (i8A) >> shift
.usages:
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Not'
.file: 'cmplStd/test/lang/useOperator.ci:68'
.value: !(i8B)
.usages:
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:69'
.value: i8A == i8B
.usages:
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:70'
.value: i8A != i8B
.usages:
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:71'
.value: i8A < i8B
.usages:
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:72'
.value: i8A <= i8B
.usages:
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:73'
.value: i8A > i8B
.usages:
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:74'
.value: i8A >= i8B
.usages:
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8A'
.file: 'cmplStd/test/lang/useOperator.ci:76'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:90: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:89: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8B'
.file: 'cmplStd/test/lang/useOperator.ci:77'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:91: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:80: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:79: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:78: referenced as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:78'
.value: +u8B
.usages:
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:79'
.value: -u8B
.usages:
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:80'
.value: ~u8B
.usages:
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Add'
.file: 'cmplStd/test/lang/useOperator.ci:81'
.value: u8A + u8B
.usages:
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:82'
.value: u8A - u8B
.usages:
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:83'
.value: u8A * u8B
.usages:
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Div'
.file: 'cmplStd/test/lang/useOperator.ci:84'
.value: u8A / u8B
.usages:
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:85'
.value: u8A % u8B
.usages:
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8And'
.file: 'cmplStd/test/lang/useOperator.ci:86'
.value: u8A & u8B
.usages:
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:87'
.value: u8A | u8B
.usages:
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:88'
.value: u8A ^ u8B
.usages:
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:89'
.value: (u8A) << shift
.usages:
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:90'
.value: (u8A) >> shift
.usages:
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Not'
.file: 'cmplStd/test/lang/useOperator.ci:91'
.value: !(u8B)
.usages:
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:92'
.value: u8A == u8B
.usages:
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:93'
.value: u8A != u8B
.usages:
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:94'
.value: u8A < u8B
.usages:
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:95'
.value: u8A <= u8B
.usages:
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:96'
.value: u8A > u8B
.usages:
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:97'
.value: u8A >= u8B
.usages:
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16A'
.file: 'cmplStd/test/lang/useOperator.ci:99'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:113: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:112: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16B'
.file: 'cmplStd/test/lang/useOperator.ci:100'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:114: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:103: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:102: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:101: referenced as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:101'
.value: +i16B
.usages:
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:102'
.value: -i16B
.usages:
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:103'
.value: ~i16B
.usages:
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Add'
.file: 'cmplStd/test/lang/useOperator.ci:104'
.value: i16A + i16B
.usages:
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:105'
.value: i16A - i16B
.usages:
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:106'
.value: i16A * i16B
.usages:
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Div'
.file: 'cmplStd/test/lang/useOperator.ci:107'
.value: i16A / i16B
.usages:
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:108'
.value: i16A % i16B
.usages:
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16And'
.file: 'cmplStd/test/lang/useOperator.ci:109'
.value: i16A & i16B
.usages:
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:110'
.value: i16A | i16B
.usages:
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:111'
.value: i16A ^ i16B
.usages:
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:112'
.value: (i16A) << shift
.usages:
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:113'
.value: (i16A) >> shift
.usages:
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Not'
.file: 'cmplStd/test/lang/useOperator.ci:114'
.value: !(i16B)
.usages:
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:115'
.value: i16A == i16B
.usages:
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:116'
.value: i16A != i16B
.usages:
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:117'
.value: i16A < i16B
.usages:
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:118'
.value: i16A <= i16B
.usages:
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:119'
.value: i16A > i16B
.usages:
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:120'
.value: i16A >= i16B
.usages:
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16A'
.file: 'cmplStd/test/lang/useOperator.ci:122'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:136: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:135: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16B'
.file: 'cmplStd/test/lang/useOperator.ci:123'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:137: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:126: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:125: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:124: referenced as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:124'
.value: +u16B
.usages:
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:125'
.value: -u16B
.usages:
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:126'
.value: ~u16B
.usages:
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Add'
.file: 'cmplStd/test/lang/useOperator.ci:127'
.value: u16A + u16B
.usages:
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:128'
.value: u16A - u16B
.usages:
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:129'
.value: u16A * u16B
.usages:
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Div'
.file: 'cmplStd/test/lang/useOperator.ci:130'
.value: u16A / u16B
.usages:
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:131'
.value: u16A % u16B
.usages:
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16And'
.file: 'cmplStd/test/lang/useOperator.ci:132'
.value: u16A & u16B
.usages:
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:133'
.value: u16A | u16B
.usages:
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:134'
.value: u16A ^ u16B
.usages:
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:135'
.value: (u16A) << shift
.usages:
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:136'
.value: (u16A) >> shift
.usages:
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Not'
.file: 'cmplStd/test/lang/useOperator.ci:137'
.value: !(u16B)
.usages:
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:138'
.value: u16A == u16B
.usages:
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:139'
.value: u16A != u16B
.usages:
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:140'
.value: u16A < u16B
.usages:
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:141'
.value: u16A <= u16B
.usages:
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:142'
.value: u16A > u16B
.usages:
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:143'
.value: u16A >= u16B
.usages:
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32A'
.file: 'cmplStd/test/lang/useOperator.ci:145'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:159: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:158: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32B'
.file: 'cmplStd/test/lang/useOperator.ci:146'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:160: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:149: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:148: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:147: referenced as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:147'
.value: +i32B
.usages:
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:148'
.value: -i32B
.usages:
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:149'
.value: ~i32B
.usages:
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Add'
.file: 'cmplStd/test/lang/useOperator.ci:150'
.value: i32A + i32B
.usages:
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:151'
.value: i32A - i32B
.usages:
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:152'
.value: i32A * i32B
.usages:
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Div'
.file: 'cmplStd/test/lang/useOperator.ci:153'
.value: i32A / i32B
.usages:
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:154'
.value: i32A % i32B
.usages:
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32And'
.file: 'cmplStd/test/lang/useOperator.ci:155'
.value: i32A & i32B
.usages:
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:156'
.value: i32A | i32B
.usages:
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:157'
.value: i32A ^ i32B
.usages:
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:158'
.value: i32A << shift
.usages:
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:159'
.value: i32A >> shift
.usages:
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Not'
.file: 'cmplStd/test/lang/useOperator.ci:160'
.value: !(i32B)
.usages:
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:161'
.value: i32A == i32B
.usages:
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:162'
.value: i32A != i32B
.usages:
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:163'
.value: i32A < i32B
.usages:
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:164'
.value: i32A <= i32B
.usages:
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:165'
.value: i32A > i32B
.usages:
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:166'
.value: i32A >= i32B
.usages:
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32A'
.file: 'cmplStd/test/lang/useOperator.ci:168'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:182: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:181: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32B'
.file: 'cmplStd/test/lang/useOperator.ci:169'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:183: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:172: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:171: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:170: referenced as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:170'
.value: +u32B
.usages:
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:171'
.value: -u32B
.usages:
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:172'
.value: ~u32B
.usages:
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Add'
.file: 'cmplStd/test/lang/useOperator.ci:173'
.value: u32A + u32B
.usages:
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:174'
.value: u32A - u32B
.usages:
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:175'
.value: u32A * u32B
.usages:
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Div'
.file: 'cmplStd/test/lang/useOperator.ci:176'
.value: u32A / u32B
.usages:
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:177'
.value: u32A % u32B
.usages:
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32And'
.file: 'cmplStd/test/lang/useOperator.ci:178'
.value: u32A & u32B
.usages:
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:179'
.value: u32A | u32B
.usages:
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:180'
.value: u32A ^ u32B
.usages:
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:181'
.value: u32A << shift
.usages:
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:182'
.value: u32A >> shift
.usages:
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Not'
.file: 'cmplStd/test/lang/useOperator.ci:183'
.value: !(u32B)
.usages:
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:184'
.value: u32A == u32B
.usages:
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:185'
.value: u32A != u32B
.usages:
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:186'
.value: u32A < u32B
.usages:
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:187'
.value: u32A <= u32B
.usages:
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:188'
.value: u32A > u32B
.usages:
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:189'
.value: u32A >= u32B
.usages:
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64A'
.file: 'cmplStd/test/lang/useOperator.ci:191'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:205: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:204: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64B'
.file: 'cmplStd/test/lang/useOperator.ci:192'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:206: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:195: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:194: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:193: referenced as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:193'
.value: +i64B
.usages:
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:194'
.value: -i64B
.usages:
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:195'
.value: ~i64B
.usages:
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Add'
.file: 'cmplStd/test/lang/useOperator.ci:196'
.value: i64A + i64B
.usages:
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:197'
.value: i64A - i64B
.usages:
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:198'
.value: i64A * i64B
.usages:
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Div'
.file: 'cmplStd/test/lang/useOperator.ci:199'
.value: i64A / i64B
.usages:
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:200'
.value: i64A % i64B
.usages:
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64And'
.file: 'cmplStd/test/lang/useOperator.ci:201'
.value: i64A & i64B
.usages:
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:202'
.value: i64A | i64B
.usages:
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:203'
.value: i64A ^ i64B
.usages:
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:204'
.value: i64A << shift
.usages:
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:205'
.value: i64A >> shift
.usages:
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Not'
.file: 'cmplStd/test/lang/useOperator.ci:206'
.value: !(i64B)
.usages:
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:207'
.value: i64A == i64B
.usages:
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:208'
.value: i64A != i64B
.usages:
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:209'
.value: i64A < i64B
.usages:
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:210'
.value: i64A <= i64B
.usages:
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:211'
.value: i64A > i64B
.usages:
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:212'
.value: i64A >= i64B
.usages:
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64A'
.file: 'cmplStd/test/lang/useOperator.ci:214'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:228: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:227: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64B'
.file: 'cmplStd/test/lang/useOperator.ci:215'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:229: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:218: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:217: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:216: referenced as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:216'
.value: +u64B
.usages:
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:217'
.value: -u64B
.usages:
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:218'
.value: ~u64B
.usages:
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Add'
.file: 'cmplStd/test/lang/useOperator.ci:219'
.value: u64A + u64B
.usages:
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:220'
.value: u64A - u64B
.usages:
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:221'
.value: u64A * u64B
.usages:
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Div'
.file: 'cmplStd/test/lang/useOperator.ci:222'
.value: u64A / u64B
.usages:
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:223'
.value: u64A % u64B
.usages:
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64And'
.file: 'cmplStd/test/lang/useOperator.ci:224'
.value: u64A & u64B
.usages:
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:225'
.value: u64A | u64B
.usages:
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:226'
.value: u64A ^ u64B
.usages:
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:227'
.value: u64A << shift
.usages:
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:228'
.value: u64A >> shift
.usages:
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Not'
.file: 'cmplStd/test/lang/useOperator.ci:229'
.value: !(u64B)
.usages:
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:230'
.value: u64A == u64B
.usages:
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:231'
.value: u64A != u64B
.usages:
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:232'
.value: u64A < u64B
.usages:
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:233'
.value: u64A <= u64B
.usages:
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:234'
.value: u64A > u64B
.usages:
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:235'
.value: u64A >= u64B
.usages:
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32A'
.file: 'cmplStd/test/lang/useOperator.ci:237'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32B'
.file: 'cmplStd/test/lang/useOperator.ci:238'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:252: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:240: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:239: referenced as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:239'
.value: +f32B
.usages:
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:240'
.value: -f32B
.usages:
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Add'
.file: 'cmplStd/test/lang/useOperator.ci:242'
.value: f32A + f32B
.usages:
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:243'
.value: f32A - f32B
.usages:
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:244'
.value: f32A * f32B
.usages:
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Div'
.file: 'cmplStd/test/lang/useOperator.ci:245'
.value: f32A / f32B
.usages:
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:246'
.value: f32A % f32B
.usages:
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Not'
.file: 'cmplStd/test/lang/useOperator.ci:252'
.value: !(f32B)
.usages:
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:253'
.value: f32A == f32B
.usages:
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:254'
.value: f32A != f32B
.usages:
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:255'
.value: f32A < f32B
.usages:
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:256'
.value: f32A <= f32B
.usages:
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:257'
.value: f32A > f32B
.usages:
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:258'
.value: f32A >= f32B
.usages:
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64A'
.file: 'cmplStd/test/lang/useOperator.ci:260'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64B'
.file: 'cmplStd/test/lang/useOperator.ci:261'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:275: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:263: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:262: referenced as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:262'
.value: +f64B
.usages:
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:263'
.value: -f64B
.usages:
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Add'
.file: 'cmplStd/test/lang/useOperator.ci:265'
.value: f64A + f64B
.usages:
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:266'
.value: f64A - f64B
.usages:
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:267'
.value: f64A * f64B
.usages:
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Div'
.file: 'cmplStd/test/lang/useOperator.ci:268'
.value: f64A / f64B
.usages:
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:269'
.value: f64A % f64B
.usages:
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Not'
.file: 'cmplStd/test/lang/useOperator.ci:275'
.value: !(f64B)
.usages:
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:276'
.value: f64A == f64B
.usages:
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:277'
.value: f64A != f64B
.usages:
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:278'
.value: f64A < f64B
.usages:
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:279'
.value: f64A <= f64B
.usages:
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:280'
.value: f64A > f64B
.usages:
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:281'
.value: f64A >= f64B
.usages:
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrA'
.file: 'cmplStd/test/lang/useOperator.ci:283'
.value: null
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrA`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrB'
.file: 'cmplStd/test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrB`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'ptrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:299'
.value: ptrA == ptrB
.usages:
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'ptrCne'
.file: 'cmplStd/test/lang/useOperator.ci:300'
.value: ptrA != ptrB
.usages:
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 't'
.file: 'cmplStd/test/lang/stmt.if.ci:26'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:65: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:62: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:59: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:56: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:53: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:50: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:43: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:36: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:32: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:28: referenced as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'forIdx'
.file: 'cmplStd/test/lang/stmt.for.ci:12'
.usages:
	cmplStd/test/lang/stmt.for.ci:14: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'pi64'
.file: 'cmplStd/test/math/test.Bits.ci:3'
.value: 3.141593
.usages:
	cmplStd/test/math/test.Bits.ci:44: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:43: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:43: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:42: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:42: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:39: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:38: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:37: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:6: referenced as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'e64'
.file: 'cmplStd/test/math/test.Bits.ci:4'
.value: 2.718282
.usages:
	cmplStd/test/math/test.Bits.ci:40: referenced as `e64`
	cmplStd/test/math/test.Bits.ci:40: referenced as `e64`
	cmplStd/test/math/test.Bits.ci:40: referenced as `e64`
	cmplStd/test/math/test.Bits.ci:7: referenced as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'pi32'
.file: 'cmplStd/test/math/test.Bits.ci:6'
.value: pi64
.usages:
	cmplStd/test/math/test.Bits.ci:53: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:52: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:52: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:51: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:51: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:48: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:47: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:46: referenced as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'e32'
.file: 'cmplStd/test/math/test.Bits.ci:7'
.value: e64
.usages:
	cmplStd/test/math/test.Bits.ci:49: referenced as `e32`
	cmplStd/test/math/test.Bits.ci:49: referenced as `e32`
	cmplStd/test/math/test.Bits.ci:49: referenced as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb888'
.file: 'cmplStd/test/math/test.Bits.ci:10'
.param .result: int32 (size: 4, cast: i32)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: r << 16 & 16711680 | g << 8 & 65280 | b & 255
.usages:
	cmplStd/test/math/test.Bits.ci:19: referenced as `rgb888`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb565'
.file: 'cmplStd/test/math/test.Bits.ci:12'
.param .result: int32 (size: 4, cast: i32)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31
.usages:
	cmplStd/test/math/test.Bits.ci:18: referenced as `rgb565`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r_comp'
.file: 'cmplStd/test/math/test.Bits.ci:14'
.value: 14 << 3
.usages:
	cmplStd/test/math/test.Bits.ci:19: referenced as `r_comp`
	cmplStd/test/math/test.Bits.ci:18: referenced as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'g_comp'
.file: 'cmplStd/test/math/test.Bits.ci:15'
.value: 63 << 2
.usages:
	cmplStd/test/math/test.Bits.ci:19: referenced as `g_comp`
	cmplStd/test/math/test.Bits.ci:18: referenced as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'b_comp'
.file: 'cmplStd/test/math/test.Bits.ci:16'
.value: 31 << 3
.usages:
	cmplStd/test/math/test.Bits.ci:19: referenced as `b_comp`
	cmplStd/test/math/test.Bits.ci:18: referenced as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r5g6b5'
.file: 'cmplStd/test/math/test.Bits.ci:18'
.value: rgb565(r_comp, g_comp, b_comp)
.usages:
	cmplStd/test/math/test.Bits.ci:66: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:65: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:63: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:62: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:60: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:59: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:58: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:57: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:56: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:55: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:27: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:26: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:25: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:23: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:22: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:21: referenced as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r8g8b8'
.file: 'cmplStd/test/math/test.Bits.ci:19'
.value: rgb888(r_comp, g_comp, b_comp)
.usages:
	cmplStd/test/math/test.Bits.ci:35: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:34: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:33: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:31: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:30: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:29: referenced as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtR5'
.file: 'cmplStd/test/math/test.Bits.ci:21'
.value: Bits.zxt32(r5g6b5, 11, 5)
.usages:
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtG6'
.file: 'cmplStd/test/math/test.Bits.ci:22'
.value: Bits.zxt32(r5g6b5, 5, 6)
.usages:
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtB5'
.file: 'cmplStd/test/math/test.Bits.ci:23'
.value: Bits.zxt32(r5g6b5, 0, 5)
.usages:
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtR5'
.file: 'cmplStd/test/math/test.Bits.ci:25'
.value: Bits.sxt32(r5g6b5, 11, 5)
.usages:
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtG6'
.file: 'cmplStd/test/math/test.Bits.ci:26'
.value: Bits.sxt32(r5g6b5, 5, 6)
.usages:
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtB5'
.file: 'cmplStd/test/math/test.Bits.ci:27'
.value: Bits.sxt32(r5g6b5, 0, 5)
.usages:
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtR8'
.file: 'cmplStd/test/math/test.Bits.ci:29'
.value: Bits.zxt32(r8g8b8, 16, 8)
.usages:
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtG8'
.file: 'cmplStd/test/math/test.Bits.ci:30'
.value: Bits.zxt32(r8g8b8, 8, 8)
.usages:
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtB8'
.file: 'cmplStd/test/math/test.Bits.ci:31'
.value: Bits.zxt32(r8g8b8, 0, 8)
.usages:
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtR8'
.file: 'cmplStd/test/math/test.Bits.ci:33'
.value: Bits.sxt32(r8g8b8, 16, 8)
.usages:
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtG8'
.file: 'cmplStd/test/math/test.Bits.ci:34'
.value: Bits.sxt32(r8g8b8, 8, 8)
.usages:
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtB8'
.file: 'cmplStd/test/math/test.Bits.ci:35'
.value: Bits.sxt32(r8g8b8, 0, 8)
.usages:
}
testSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testSin_f64'
.file: 'cmplStd/test/math/test.Bits.ci:37'
.value: Math.sin(pi64 / (2))
.usages:
}
testCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testCos_f64'
.file: 'cmplStd/test/math/test.Bits.ci:38'
.value: Math.cos(pi64 / (2))
.usages:
}
testTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testTan_f64'
.file: 'cmplStd/test/math/test.Bits.ci:39'
.value: Math.tan(pi64 / (4))
.usages:
}
testLog_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testLog_f64'
.file: 'cmplStd/test/math/test.Bits.ci:40'
.value: Math.log(e64 * e64 * e64)
.usages:
}
testExp_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testExp_f64'
.file: 'cmplStd/test/math/test.Bits.ci:41'
.value: Math.exp(1.000000)
.usages:
}
testPow_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testPow_f64'
.file: 'cmplStd/test/math/test.Bits.ci:42'
.value: Math.pow(pi64 * pi64, 0.500000)
.usages:
}
testSqrt_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testSqrt_f64'
.file: 'cmplStd/test/math/test.Bits.ci:43'
.value: Math.sqrt(pi64 * pi64)
.usages:
}
testAtan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testAtan_f64'
.file: 'cmplStd/test/math/test.Bits.ci:44'
.value: Math.atan2(pi64, 1.000000)
.usages:
}
testSin_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testSin_f32'
.file: 'cmplStd/test/math/test.Bits.ci:46'
.value: Math.sin(pi32 / (2))
.usages:
}
testCos_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testCos_f32'
.file: 'cmplStd/test/math/test.Bits.ci:47'
.value: Math.cos(pi32 / (2))
.usages:
}
testTan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testTan_f32'
.file: 'cmplStd/test/math/test.Bits.ci:48'
.value: Math.tan(pi32 / (4))
.usages:
}
testLog_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testLog_f32'
.file: 'cmplStd/test/math/test.Bits.ci:49'
.value: Math.log(e32 * e32 * e32)
.usages:
}
testExp_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testExp_f32'
.file: 'cmplStd/test/math/test.Bits.ci:50'
.value: Math.exp(1.000000)
.usages:
}
testPow_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testPow_f32'
.file: 'cmplStd/test/math/test.Bits.ci:51'
.value: Math.pow(pi32 * pi32, 0.500000)
.usages:
}
testSqrt_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testSqrt_f32'
.file: 'cmplStd/test/math/test.Bits.ci:52'
.value: Math.sqrt(pi32 * pi32)
.usages:
}
testAtan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testAtan_f32'
.file: 'cmplStd/test/math/test.Bits.ci:53'
.value: Math.atan2(pi32, 1.000000)
.usages:
}
testPopulation_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testPopulation_u32'
.file: 'cmplStd/test/math/test.Bits.ci:55'
.value: Bits.countOnes(r5g6b5)
.usages:
}
testSwapBits_u32: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'testSwapBits_u32'
.file: 'cmplStd/test/math/test.Bits.ci:56'
.value: Bits.swapBits(r5g6b5)
.usages:
}
testBitScanReverse_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testBitScanReverse_u32'
.file: 'cmplStd/test/math/test.Bits.ci:57'
.value: Bits.scanReverse(r5g6b5)
.usages:
}
testBitScanForward_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testBitScanForward_u32'
.file: 'cmplStd/test/math/test.Bits.ci:58'
.value: Bits.scanForward(r5g6b5)
.usages:
}
testHighBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testHighBit_u32'
.file: 'cmplStd/test/math/test.Bits.ci:59'
.value: Bits.keepMsb(r5g6b5)
.usages:
}
testLowBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testLowBit_u32'
.file: 'cmplStd/test/math/test.Bits.ci:60'
.value: Bits.keepLsb(r5g6b5)
.usages:
}
testZeroExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testZeroExtend_u32'
.file: 'cmplStd/test/math/test.Bits.ci:62'
.value: Bits.zxt32(r5g6b5, 0, 5)
.usages:
}
testSignExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testSignExtend_u32'
.file: 'cmplStd/test/math/test.Bits.ci:63'
.value: Bits.sxt32(r5g6b5, 0, 5)
.usages:
}
testZeroExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testZeroExtend_u64'
.file: 'cmplStd/test/math/test.Bits.ci:65'
.value: Bits.zxt64(r5g6b5, 0, 5)
.usages:
}
testSignExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testSignExtend_u64'
.file: 'cmplStd/test/math/test.Bits.ci:66'
.value: Bits.sxt64(r5g6b5, 0, 5)
.usages:
}
testMathFloor_pos_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_0'
.file: 'cmplStd/test/math/test.Math.ci:3'
.value: Math.floor(3.000000)
.usages:
}
testMathFloor_pos_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_2'
.file: 'cmplStd/test/math/test.Math.ci:4'
.value: Math.floor(3.200000)
.usages:
}
testMathFloor_pos_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_5'
.file: 'cmplStd/test/math/test.Math.ci:5'
.value: Math.floor(3.500000)
.usages:
}
testMathFloor_pos_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_7'
.file: 'cmplStd/test/math/test.Math.ci:6'
.value: Math.floor(3.700000)
.usages:
}
testMathFloor_pos_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_9'
.file: 'cmplStd/test/math/test.Math.ci:7'
.value: Math.floor(3.900000)
.usages:
}
testMathFloor_neg_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_0'
.file: 'cmplStd/test/math/test.Math.ci:8'
.value: Math.floor(-3.000000)
.usages:
}
testMathFloor_neg_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_2'
.file: 'cmplStd/test/math/test.Math.ci:9'
.value: Math.floor(-3.200000)
.usages:
}
testMathFloor_neg_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_5'
.file: 'cmplStd/test/math/test.Math.ci:10'
.value: Math.floor(-3.500000)
.usages:
}
testMathFloor_neg_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_7'
.file: 'cmplStd/test/math/test.Math.ci:11'
.value: Math.floor(-3.700000)
.usages:
}
testMathFloor_neg_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_9'
.file: 'cmplStd/test/math/test.Math.ci:12'
.value: Math.floor(-3.900000)
.usages:
}
testMathRound_pos_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_0'
.file: 'cmplStd/test/math/test.Math.ci:14'
.value: Math.round(3.000000)
.usages:
}
testMathRound_pos_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_2'
.file: 'cmplStd/test/math/test.Math.ci:15'
.value: Math.round(3.200000)
.usages:
}
testMathRound_pos_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_5'
.file: 'cmplStd/test/math/test.Math.ci:16'
.value: Math.round(3.500000)
.usages:
}
testMathRound_pos_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_7'
.file: 'cmplStd/test/math/test.Math.ci:17'
.value: Math.round(3.700000)
.usages:
}
testMathRound_pos_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_9'
.file: 'cmplStd/test/math/test.Math.ci:18'
.value: Math.round(3.900000)
.usages:
}
testMathRound_neg_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_0'
.file: 'cmplStd/test/math/test.Math.ci:19'
.value: Math.round(-3.000000)
.usages:
}
testMathRound_neg_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_2'
.file: 'cmplStd/test/math/test.Math.ci:20'
.value: Math.round(-3.200000)
.usages:
}
testMathRound_neg_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_5'
.file: 'cmplStd/test/math/test.Math.ci:21'
.value: Math.round(-3.500000)
.usages:
}
testMathRound_neg_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_7'
.file: 'cmplStd/test/math/test.Math.ci:22'
.value: Math.round(-3.700000)
.usages:
}
testMathRound_neg_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_9'
.file: 'cmplStd/test/math/test.Math.ci:23'
.value: Math.round(-3.900000)
.usages:
}
testMathCeil_pos_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_0'
.file: 'cmplStd/test/math/test.Math.ci:25'
.value: Math.ceil(3.000000)
.usages:
}
testMathCeil_pos_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_2'
.file: 'cmplStd/test/math/test.Math.ci:26'
.value: Math.ceil(3.200000)
.usages:
}
testMathCeil_pos_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_5'
.file: 'cmplStd/test/math/test.Math.ci:27'
.value: Math.ceil(3.500000)
.usages:
}
testMathCeil_pos_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_7'
.file: 'cmplStd/test/math/test.Math.ci:28'
.value: Math.ceil(3.700000)
.usages:
}
testMathCeil_pos_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_9'
.file: 'cmplStd/test/math/test.Math.ci:29'
.value: Math.ceil(3.900000)
.usages:
}
testMathCeil_neg_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_0'
.file: 'cmplStd/test/math/test.Math.ci:30'
.value: Math.ceil(-3.000000)
.usages:
}
testMathCeil_neg_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_2'
.file: 'cmplStd/test/math/test.Math.ci:31'
.value: Math.ceil(-3.200000)
.usages:
}
testMathCeil_neg_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_5'
.file: 'cmplStd/test/math/test.Math.ci:32'
.value: Math.ceil(-3.500000)
.usages:
}
testMathCeil_neg_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_7'
.file: 'cmplStd/test/math/test.Math.ci:33'
.value: Math.ceil(-3.700000)
.usages:
}
testMathCeil_neg_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_9'
.file: 'cmplStd/test/math/test.Math.ci:34'
.value: Math.ceil(-3.900000)
.usages:
}
testMathSign_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_1F'
.file: 'cmplStd/test/math/test.Math.ci:36'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_2F'
.file: 'cmplStd/test/math/test.Math.ci:37'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_3F'
.file: 'cmplStd/test/math/test.Math.ci:38'
.value: Math.sign(-0.900000)
.usages:
}
testMathSign_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_1f'
.file: 'cmplStd/test/math/test.Math.ci:39'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_2f'
.file: 'cmplStd/test/math/test.Math.ci:40'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_3f'
.file: 'cmplStd/test/math/test.Math.ci:41'
.value: Math.sign(-0.900000)
.usages:
}
testMathAbs_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_1F'
.file: 'cmplStd/test/math/test.Math.ci:43'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_2F'
.file: 'cmplStd/test/math/test.Math.ci:44'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_3F'
.file: 'cmplStd/test/math/test.Math.ci:45'
.value: Math.abs(-0.900000)
.usages:
}
testMathAbs_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_1f'
.file: 'cmplStd/test/math/test.Math.ci:46'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_2f'
.file: 'cmplStd/test/math/test.Math.ci:47'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_3f'
.file: 'cmplStd/test/math/test.Math.ci:48'
.value: Math.abs(-0.900000)
.usages:
}
testMathMin_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMin_1f'
.file: 'cmplStd/test/math/test.Math.ci:50'
.value: Math.min(1.000000, 2.000000)
.usages:
}
testMathMax_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMax_2f'
.file: 'cmplStd/test/math/test.Math.ci:51'
.value: Math.max(1.000000, 2.000000)
.usages:
}
testMathMin_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMin_1F'
.file: 'cmplStd/test/math/test.Math.ci:52'
.value: Math.min(1.000000, 2.000000)
.usages:
}
testMathMax_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMax_2F'
.file: 'cmplStd/test/math/test.Math.ci:53'
.value: Math.max(1.000000, 2.000000)
.usages:
}
testMathClamp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathClamp_1f'
.file: 'cmplStd/test/math/test.Math.ci:55'
.value: Math.clamp(10.000000, 0.000000, 1.000000)
.usages:
}
testMathClamp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathClamp_1F'
.file: 'cmplStd/test/math/test.Math.ci:56'
.value: Math.clamp(10.000000, 0.000000, 1.000000)
.usages:
}
testMathMix_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMix_1f'
.file: 'cmplStd/test/math/test.Math.ci:58'
.value: Math.mix(0.000000, 2.000000, 0.500000)
.usages:
}
testMathMix_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMix_1F'
.file: 'cmplStd/test/math/test.Math.ci:59'
.value: Math.mix(0.000000, 2.000000, 0.500000)
.usages:
}
testMathSmooth_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSmooth_1f'
.file: 'cmplStd/test/math/test.Math.ci:61'
.value: Math.smoothstep(0.000000, 1.000000, 1.000000)
.usages:
}
testMathSmooth_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSmooth_1F'
.file: 'cmplStd/test/math/test.Math.ci:62'
.value: Math.smoothstep(0.000000, 1.000000, 1.000000)
.usages:
}
testMathMin_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMin_nan'
.file: 'cmplStd/test/math/test.Math.ci:64'
.value: Math.min()
.usages:
}
testMathMin_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMin_1'
.file: 'cmplStd/test/math/test.Math.ci:65'
.value: Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6)
.usages:
}
testMathMax_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMax_nan'
.file: 'cmplStd/test/math/test.Math.ci:66'
.value: Math.max()
.usages:
}
testMathMax_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMax_9'
.file: 'cmplStd/test/math/test.Math.ci:67'
.value: Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6)
.usages:
}
testMathSum_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSum_0'
.file: 'cmplStd/test/math/test.Math.ci:69'
.value: Math.sum()
.usages:
}
testMathSum_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSum_1'
.file: 'cmplStd/test/math/test.Math.ci:70'
.value: Math.sum(1)
.usages:
}
testMathSum_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSum_3'
.file: 'cmplStd/test/math/test.Math.ci:71'
.value: Math.sum(1, 2)
.usages:
}
testMathSum_55: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSum_55'
.file: 'cmplStd/test/math/test.Math.ci:72'
.value: Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
.usages:
}
testMathEval_x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_x'
.file: 'cmplStd/test/math/test.Math.ci:74'
.value: 10
.usages:
	cmplStd/test/math/test.Math.ci:81: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:80: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:79: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:78: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:77: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:76: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:75: referenced as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_0'
.file: 'cmplStd/test/math/test.Math.ci:75'
.value: Math.eval(testMathEval_x)
.usages:
}
testMathEval_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_1'
.file: 'cmplStd/test/math/test.Math.ci:76'
.value: Math.eval(testMathEval_x, 1.000000)
.usages:
}
testMathEval_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_2'
.file: 'cmplStd/test/math/test.Math.ci:77'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000)
.usages:
}
testMathEval_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_3'
.file: 'cmplStd/test/math/test.Math.ci:78'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000)
.usages:
}
testMathEval_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_4'
.file: 'cmplStd/test/math/test.Math.ci:79'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000)
.usages:
}
testMathEval_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_5'
.file: 'cmplStd/test/math/test.Math.ci:80'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
.usages:
}
testMathEval_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_6'
.file: 'cmplStd/test/math/test.Math.ci:81'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
.usages:
}
testMathSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSin_f64'
.file: 'cmplStd/test/math/test.Math.ci:83'
.value: Math.sin(Math.pi / (2))
.usages:
}
testMathCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCos_f64'
.file: 'cmplStd/test/math/test.Math.ci:84'
.value: Math.cos(Math.pi / (2))
.usages:
}
testMathTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathTan_f64'
.file: 'cmplStd/test/math/test.Math.ci:85'
.value: Math.tan(Math.pi / (4))
.usages:
}
testMathSinh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSinh_f64'
.file: 'cmplStd/test/math/test.Math.ci:86'
.value: Math.sinh(Math.pi / (2))
.usages:
}
testMathCosh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCosh_f64'
.file: 'cmplStd/test/math/test.Math.ci:87'
.value: Math.cosh(Math.pi / (2))
.usages:
}
testMathAsin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAsin_f64'
.file: 'cmplStd/test/math/test.Math.ci:89'
.value: Math.asin(0.200000)
.usages:
}
testMathAcos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAcos_f64'
.file: 'cmplStd/test/math/test.Math.ci:90'
.value: Math.acos(0.200000)
.usages:
}
testMathAbsMod_f64_0a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_0a'
.file: 'cmplStd/test/math/test.Math.ci:93'
.value: Math.absMod(10.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_0b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_0b'
.file: 'cmplStd/test/math/test.Math.ci:94'
.value: Math.absMod(0.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_0c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_0c'
.file: 'cmplStd/test/math/test.Math.ci:95'
.value: Math.absMod(-10.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_9a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_9a'
.file: 'cmplStd/test/math/test.Math.ci:97'
.value: Math.absMod(19.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_9b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_9b'
.file: 'cmplStd/test/math/test.Math.ci:98'
.value: Math.absMod(9.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_9c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_9c'
.file: 'cmplStd/test/math/test.Math.ci:99'
.value: Math.absMod(-1.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_9d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_9d'
.file: 'cmplStd/test/math/test.Math.ci:100'
.value: Math.absMod(-11.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_8a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_8a'
.file: 'cmplStd/test/math/test.Math.ci:102'
.value: Math.absMod(18.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_8b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_8b'
.file: 'cmplStd/test/math/test.Math.ci:103'
.value: Math.absMod(8.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_8c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_8c'
.file: 'cmplStd/test/math/test.Math.ci:104'
.value: Math.absMod(-2.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_8d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_8d'
.file: 'cmplStd/test/math/test.Math.ci:105'
.value: Math.absMod(-12.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_0a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_0a'
.file: 'cmplStd/test/math/test.Math.ci:107'
.value: Math.absMod(10.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_0b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_0b'
.file: 'cmplStd/test/math/test.Math.ci:108'
.value: Math.absMod(0.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_0c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_0c'
.file: 'cmplStd/test/math/test.Math.ci:109'
.value: Math.absMod(-10.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_9a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_9a'
.file: 'cmplStd/test/math/test.Math.ci:111'
.value: Math.absMod(19.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_9b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_9b'
.file: 'cmplStd/test/math/test.Math.ci:112'
.value: Math.absMod(9.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_9c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_9c'
.file: 'cmplStd/test/math/test.Math.ci:113'
.value: Math.absMod(-1.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_9d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_9d'
.file: 'cmplStd/test/math/test.Math.ci:114'
.value: Math.absMod(-11.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_8a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_8a'
.file: 'cmplStd/test/math/test.Math.ci:116'
.value: Math.absMod(18.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_8b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_8b'
.file: 'cmplStd/test/math/test.Math.ci:117'
.value: Math.absMod(8.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_8c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_8c'
.file: 'cmplStd/test/math/test.Math.ci:118'
.value: Math.absMod(-2.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_8d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_8d'
.file: 'cmplStd/test/math/test.Math.ci:119'
.value: Math.absMod(-12.000000, 10.000000)
.usages:
}
Neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Neg'
.file: 'cmplStd/test/math/test.Complex.ci:3'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: Complex(-a.re, -a.im)
.usages:
	cmplStd/test/math/test.Complex.ci:11: referenced as `Neg`
}
Add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Add'
.file: 'cmplStd/test/math/test.Complex.ci:4'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a.re + b.re, a.im + b.im)
.usages:
	cmplStd/test/math/test.Complex.ci:14: referenced as `Add`
}
Sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Sub'
.file: 'cmplStd/test/math/test.Complex.ci:5'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a.re - b.re, a.im - b.im)
.usages:
	cmplStd/test/math/test.Complex.ci:17: referenced as `Sub`
}
Mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Mul'
.file: 'cmplStd/test/math/test.Complex.ci:6'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re)
.usages:
	cmplStd/test/math/test.Complex.ci:20: referenced as `Mul`
}
valA: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'valA'
.file: 'cmplStd/test/math/test.Complex.ci:8'
.value: {
	valA.re := (9);
	valA.im := (2);
}
.usages:
	cmplStd/test/math/test.Complex.ci:21: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:20: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:18: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:17: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:15: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:14: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:12: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:11: referenced as `valA`
}
valB: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'valB'
.file: 'cmplStd/test/math/test.Complex.ci:9'
.value: {
	valB.re := (2);
	valB.im := (3);
}
.usages:
	cmplStd/test/math/test.Complex.ci:21: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:20: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:18: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:17: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:15: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:14: referenced as `valB`
}
Neg: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'Neg'
.file: 'cmplStd/test/math/test.Complex.ci:11'
.value: Neg(valA)
.usages:
}
neg: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'neg'
.file: 'cmplStd/test/math/test.Complex.ci:12'
.value: neg(valA)
.usages:
}
Add: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'Add'
.file: 'cmplStd/test/math/test.Complex.ci:14'
.value: Add(valA, valB)
.usages:
}
add: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'add'
.file: 'cmplStd/test/math/test.Complex.ci:15'
.value: add(valA, valB)
.usages:
}
Sub: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'Sub'
.file: 'cmplStd/test/math/test.Complex.ci:17'
.value: Sub(valA, valB)
.usages:
}
sub: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'sub'
.file: 'cmplStd/test/math/test.Complex.ci:18'
.value: sub(valA, valB)
.usages:
}
Mul: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'Mul'
.file: 'cmplStd/test/math/test.Complex.ci:20'
.value: Mul(valA, valB)
.usages:
}
mul: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'mul'
.file: 'cmplStd/test/math/test.Complex.ci:21'
.value: mul(valA, valB)
.usages:
}
.main: function {
.kind: static function
.base: `function`
.size: 22550
.name: '.main'
.print: '.main'
.field typename: typename (size: 160, cast: static const typename(ref))
.field void: typename (size: 0, cast: static const typename(void))
.field bool: typename (size: 1, cast: static const typename(bool))
.field char: typename (size: 1, cast: static const typename(i32))
.field int8: typename (size: 1, cast: static const typename(i32))
.field int16: typename (size: 2, cast: static const typename(i32))
.field int32: typename (size: 4, cast: static const typename(i32))
.field int64: typename (size: 8, cast: static const typename(i64))
.field uint8: typename (size: 1, cast: static const typename(u32))
.field uint16: typename (size: 2, cast: static const typename(u32))
.field uint32: typename (size: 4, cast: static const typename(u32))
.field uint64: typename (size: 8, cast: static const typename(u64))
.field float32: typename (size: 4, cast: static const typename(f32))
.field float64: typename (size: 8, cast: static const typename(f64))
.field pointer: typename (size: 4, cast: static const typename(ref))
.field variant: typename (size: 8, cast: static const typename(var))
.field function: typename (size: 4, cast: static const typename(ref))
.field object: typename (size: 4, cast: static const typename(ref))
.field null: pointer (size: 0, cast: static const inline)
.field int: typename (size: 0, cast: static const inline)
.field .cstr: char (size: 4, cast: static const typename(arr))
.field emit: function (size: 0, cast: static const typename(void))
.field halt: function (size: 0, cast: static const inline)
.field preferNativeCalls: int64 (size: 0, cast: static const i64)
.field raise: function (size: 0, cast: static const inline)
.field tryExec: function (size: 0, cast: static const inline)
.field System: typename (size: 0, cast: static const typename(void))
.field true: bool (size: 0, cast: static const val)
.field false: bool (size: 0, cast: static const val)
.field byte: typename (size: 0, cast: inline)
.field float: typename (size: 0, cast: inline)
.field double: typename (size: 0, cast: inline)
.field sizeof: function (size: 0, cast: inline)
.field verbose: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field NotEquals: typename (size: 24, cast: static const typename(val))
.field NotEquals: function (size: 15, cast: static function)
.field abort: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assertEq: function (size: 118, cast: static function)
.field assertEq: function (size: 0, cast: inline)
.field inc: function (size: 0, cast: inline)
.field Bits: typename (size: 0, cast: static const typename(void))
.field Math: typename (size: 0, cast: static const typename(void))
.field Fixed: typename (size: 8, cast: static const typename(val))
.field Fixed: function (size: 0, cast: inline)
.field int32: function (size: 0, cast: inline)
.field Fixed: function (size: 95, cast: static function)
.field float64: function (size: 87, cast: static function)
.field Complex: typename (size: 16, cast: static const typename(val))
.field Complex: function (size: 7, cast: static function)
.field Complex: function (size: 7, cast: static function)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 139, cast: static function)
.field div: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field abs: function (size: 0, cast: inline)
.field arg: function (size: 0, cast: inline)
.field inv: function (size: 31, cast: static function)
.field conj: function (size: 0, cast: inline)
.field exp: function (size: 0, cast: inline)
.field log: function (size: 0, cast: inline)
.field pow: function (size: 151, cast: static function)
.field pow: function (size: 0, cast: inline)
.field sin: function (size: 0, cast: inline)
.field cos: function (size: 0, cast: inline)
.field tan: function (size: 0, cast: inline)
.field cot: function (size: 0, cast: inline)
.field sec: function (size: 0, cast: inline)
.field csc: function (size: 0, cast: inline)
.field sinh: function (size: 0, cast: inline)
.field cosh: function (size: 0, cast: inline)
.field tanh: function (size: 0, cast: inline)
.field coth: function (size: 0, cast: inline)
.field sech: function (size: 0, cast: inline)
.field csch: function (size: 0, cast: inline)
.field toCartesian: function (size: 0, cast: inline)
.field toPolar: function (size: 0, cast: inline)
.field vec4f: typename (size: 16, cast: static const typename(val))
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field abs: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field clamp: function (size: 0, cast: inline)
.field clamp: function (size: 0, cast: inline)
.field mix: function (size: 0, cast: inline)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field cross: function (size: 0, cast: inline)
.field length: function (size: 0, cast: inline)
.field normalize: function (size: 0, cast: inline)
.field eval: function (size: 0, cast: inline)
.field mat4f: typename (size: 64, cast: static const typename(val))
.field mat4f: function (size: 49, cast: static function)
.field mat4f: function (size: 21, cast: static function)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field transpose: function (size: 49, cast: static function)
.field mul: function (size: 265, cast: static function)
.field rotation: function (size: 491, cast: static function)
.field rotation: function (size: 243, cast: static function)
.field translation: function (size: 88, cast: static function)
.field scale: function (size: 217, cast: static function)
.field inverse: function (size: 632, cast: static function)
.field vec2d: typename (size: 16, cast: static const typename(val))
.field vec2d: function (size: 7, cast: static function)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field ceq: function (size: 0, cast: inline)
.field dot: function (size: 0, cast: inline)
.field Timeunit: int64 (size: 8, cast: static const typename(ERR))
.field convert: function (size: 31, cast: static function)
.field convert: function (size: 33, cast: static function)
.field Duration: typename (size: 8, cast: static const typename(val))
.field Duration: function (size: 22, cast: static function)
.field Timestamp: typename (size: 8, cast: static const typename(val))
.field Timestamp: function (size: 22, cast: static function)
.field Timezone: typename (size: 16, cast: static const typename(val))
.field Month: uint8 (size: 1, cast: static const typename(ERR))
.field Month: function (size: 0, cast: inline)
.field indexOf: function (size: 0, cast: inline)
.field Weekday: uint8 (size: 1, cast: static const typename(ERR))
.field Weekday: function (size: 0, cast: inline)
.field indexOf: function (size: 0, cast: inline)
.field Calendar: uint8 (size: 1, cast: static const typename(ERR))
.field Datetime: typename (size: 40, cast: static const typename(val))
.field Timestamp: function (size: 626, cast: static function)
.field Datetime: function (size: 630, cast: static function)
.field Datetime: function (size: 0, cast: inline)
.field Datetime: function (size: 97, cast: static function)
.field Datetime: function (size: 55, cast: static function)
.field Datetime: function (size: 46, cast: static function)
.field Datetime: function (size: 43, cast: static function)
.field Datetime: function (size: 51, cast: static function)
.field length: function (size: 38, cast: static function)
.field indexOf: function (size: 50, cast: static function)
.field lastIndexOf: function (size: 50, cast: static function)
.field startsWith: function (size: 73, cast: static function)
.field endsWith: function (size: 126, cast: static function)
.field compare: function (size: 63, cast: static function)
.field ignCaseCmp: function (size: 36, cast: static function)
.field caseCmp: function (size: 14, cast: static function)
.field toHex: function (size: 0, cast: inline)
.field startsWith: function (size: 0, cast: inline)
.field endsWith: function (size: 0, cast: inline)
.field compare: function (size: 0, cast: inline)
.field equals: function (size: 0, cast: inline)
.field contains: function (size: 0, cast: inline)
.field float64: function (size: 423, cast: static function)
.field FormatFlags: typename (size: 16, cast: static const typename(val))
.field append: function (size: 119, cast: static function)
.field append: function (size: 687, cast: static function)
.field append: function (size: 121, cast: static function)
.field append: function (size: 649, cast: static function)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field DatetimeFormat: typename (size: 80, cast: static const typename(val))
.field format: function (size: 25, cast: static function)
.field append: function (size: 31, cast: static function)
.field Closeable: object (size: 8, cast: static const typename(ref))
.field ByteReader: Closeable (size: 12, cast: static const typename(ref))
.field ByteWriter: Closeable (size: 16, cast: static const typename(ref))
.field CopyReader: ByteReader (size: 20, cast: static const typename(ref))
.field ByteBuffer: typename (size: 40, cast: static const typename(val))
.field unicode: typename (size: 0, cast: inline)
.field TextReader: Closeable (size: 16, cast: static const typename(ref))
.field TextWriter: Closeable (size: 36, cast: static const typename(ref))
.field Base64Encoder: ByteWriter (size: 1060, cast: static const typename(ref))
.field Base64Decoder: ByteReader (size: 24, cast: static const typename(ref))
.field AsciiReader: TextReader (size: 16, cast: static const typename(ref))
.field AsciiWriter: TextWriter (size: 36, cast: static const typename(ref))
.field Utf8Reader: TextReader (size: 16, cast: static const typename(ref))
.field Utf8Writer: TextWriter (size: 36, cast: static const typename(ref))
.field Easing: typename (size: 0, cast: static const typename(void))
.field in: function (size: 29, cast: static function)
.field out: function (size: 49, cast: static function)
.field inOut: function (size: 118, cast: static function)
.field outIn: function (size: 118, cast: static function)
.field scalar: typename (size: 0, cast: inline)
.field Polynomial: TextWriter.Writeable (size: 20, cast: static const typename(ref))
.field Polynomial: function (size: 0, cast: inline)
.field Polynomial: function (size: 81, cast: static function)
.field File: typename (size: 8, cast: static const typename(val))
.field read: function (size: 57, cast: static function)
.field write: function (size: 33, cast: static function)
.field FileReader: ByteReader (size: 20, cast: static const typename(ref))
.field FileWriter: ByteWriter (size: 24, cast: static const typename(ref))
.field BufferedFileWriter: FileWriter (size: 1052, cast: static const typename(ref))
.field FileReader: function (size: 49, cast: static function)
.field FileWriter: function (size: 80, cast: static function)
.field BufferedFileWriter: function (size: 100, cast: static function)
.field Rect: typename (size: 16, cast: static const typename(val))
.field Image: typename (size: 8, cast: static const typename(val))
.field Mesh: typename (size: 160, cast: static const typename(ref))
.field gradient: function (size: 0, cast: static const inline)
.field camera: function (size: 0, cast: static const inline)
.field lights: typename (size: 0, cast: static const typename(void))
.field Window: typename (size: 0, cast: static const typename(void))
.field empty: function (size: 44, cast: static function)
.field contains: function (size: 74, cast: static function)
.field width: function (size: 0, cast: inline)
.field width: function (size: 14, cast: static function)
.field height: function (size: 0, cast: inline)
.field height: function (size: 18, cast: static function)
.field setSize: function (size: 31, cast: static function)
.field positionX: function (size: 27, cast: static function)
.field positionY: function (size: 35, cast: static function)
.field position: function (size: 29, cast: static function)
.field adjust: function (size: 61, cast: static function)
.field padded: function (size: 61, cast: static function)
.field translate: function (size: 0, cast: inline)
.field translateX: function (size: 27, cast: static function)
.field translateY: function (size: 35, cast: static function)
.field argb: typename (size: 4, cast: static const typename(val))
.field argb: function (size: 0, cast: inline)
.field uint32: function (size: 0, cast: inline)
.field sat_s8: function (size: 0, cast: inline)
.field sat_u8: function (size: 0, cast: inline)
.field pack: function (size: 0, cast: inline)
.field pack: function (size: 0, cast: inline)
.field pack: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field gray: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field ach: function (size: 0, cast: inline)
.field rch: function (size: 0, cast: inline)
.field gch: function (size: 0, cast: inline)
.field bch: function (size: 0, cast: inline)
.field lum: function (size: 0, cast: inline)
.field hue: function (size: 206, cast: static function)
.field mix_s8: function (size: 0, cast: inline)
.field mix_s16: function (size: 0, cast: inline)
.field mix_rgb8: function (size: 0, cast: inline)
.field lerpLut: function (size: 219, cast: static function)
.field alphaLut: function (size: 388, cast: static function)
.field vec4f: function (size: 0, cast: inline)
.field argb: function (size: 0, cast: inline)
.field lum: function (size: 0, cast: inline)
.field rgb2hsl: function (size: 554, cast: static function)
.field hsl2rgb: function (size: 168, cast: static function)
.field Image: function (size: 0, cast: inline)
.field Image: function (size: 163, cast: static function)
.field Image: function (size: 0, cast: inline)
.field clip: function (size: 116, cast: static function)
.field set: function (size: 0, cast: inline)
.field drawAntiAliased: typename (size: 0, cast: inline)
.field fillRect: function (size: 124, cast: static function)
.field fillRect: function (size: 0, cast: inline)
.field drawRect: function (size: 275, cast: static function)
.field drawRect: function (size: 0, cast: inline)
.field fillRect: function (size: 58, cast: static function)
.field drawRect: function (size: 62, cast: static function)
.field fillRRect: function (size: 562, cast: static function)
.field drawRRect: function (size: 645, cast: static function)
.field fillRRect: function (size: 0, cast: inline)
.field drawRRect: function (size: 0, cast: inline)
.field fillRRect: function (size: 61, cast: static function)
.field fillRRect: function (size: 0, cast: inline)
.field fillOval: function (size: 0, cast: inline)
.field drawOval: function (size: 0, cast: inline)
.field fillOval: function (size: 117, cast: static function)
.field drawOval: function (size: 117, cast: static function)
.field drawLineIncl: function (size: 1362, cast: static function)
.field drawLine: function (size: 63, cast: static function)
.field drawBezier: function (size: 197, cast: static function)
.field drawBezier: function (size: 233, cast: static function)
.field fill: function (size: 33, cast: static function)
.field drawText: function (size: 47, cast: static function)
.field blend: function (size: 548, cast: static function)
.field blend: function (size: 93, cast: static function)
.field blend: function (size: 134, cast: static function)
.field blendAlpha: function (size: 54, cast: static function)
.field blendDstAlpha: function (size: 56, cast: static function)
.field copy: function (size: 31, cast: static function)
.field Image: function (size: 46, cast: static function)
.field tile: function (size: 325, cast: static function)
.field eval: function (size: 491, cast: static function)
.field transform: function (size: 1354, cast: static function)
.field resize: function (size: 0, cast: inline)
.field Image: function (size: 567, cast: static function)
.field Image: function (size: 56, cast: static function)
.field Image: function (size: 0, cast: inline)
.field Image: function (size: 0, cast: inline)
.field blur: function (size: 934, cast: static function)
.field colorMap: function (size: 951, cast: static function)
.field colorMat: function (size: 684, cast: static function)
.field Mesh: function (size: 124, cast: static function)
.field Camera: typename (size: 64, cast: static const typename(val))
.field Window: typename (size: 0, cast: static const typename(void))
.field Style: typename (size: 56, cast: static const typename(val))
.field KeyEvent: typename (size: 16, cast: static const typename(val))
.field TouchEvent: typename (size: 32, cast: static const typename(val))
.field View: object (size: 64, cast: static const typename(ref))
.field focus: function (size: 4, cast: static variable(ref))
.field invalidate: function (size: 4, cast: static variable(ref))
.field Layout: View (size: 116, cast: static const typename(ref))
.field Widget: Layout (size: 132, cast: static const typename(ref))
.field getWidget: function (size: 128, cast: static function)
.field focus: function (size: 244, cast: static function)
.field invalidate: function (size: 54, cast: static function)
.field invalidate: function (size: 0, cast: inline)
.field isFocused: function (size: 45, cast: static function)
.field isPressed: function (size: 45, cast: static function)
.field isDirty: function (size: 33, cast: static function)
.field Button: View (size: 68, cast: static const typename(ref))
.field Switch: View (size: 92, cast: static const typename(ref))
.field Slider: View (size: 128, cast: static const typename(ref))
.field Histogram: View (size: 1096, cast: static const typename(ref))
.field DebugView: View (size: 672, cast: static const typename(ref))
.field Panel: Layout (size: 120, cast: static const typename(ref))
.field TabPage: Layout (size: 128, cast: static const typename(ref))
.field Select: Layout (size: 144, cast: static const typename(ref))
.field FxWidget: Widget (size: 152, cast: static const typename(ref))
.field Widget: function (size: 400, cast: static function)
.field Widget: function (size: 26, cast: static function)
.field FxWidget: function (size: 494, cast: static function)
.field FxWidget: function (size: 24, cast: static function)
.field hasFocused: function (size: 178, cast: static function)
.field hasPressed: function (size: 178, cast: static function)
.field Window: typename (size: 0, cast: static const typename(void))
.field integer: typename (size: 0, cast: inline)
.field emitldz32: int32 (size: 4, cast: variable(i32))
.field emitldz64: int64 (size: 8, cast: variable(i64))
.field emitA: int32 (size: 4, cast: variable(i32))
.field emitB: int32 (size: 4, cast: variable(i32))
.field emitAddI32: int32 (size: 4, cast: variable(i32))
.field emitDivI32: int32 (size: 4, cast: variable(i32))
.field emitNfcF32: float32 (size: 4, cast: variable(f32))
.field floatAsInt32: function (size: 0, cast: inline)
.field floatAsInt64: function (size: 0, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, cast: variable(i64))
.field emitSlice: char[] (size: 8, cast: variable(arr))
.field zero: function (size: 0, cast: inline)
.field last: function (size: 0, cast: inline)
.field sum: function (size: 0, cast: inline)
.field any: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field i3: int32 (size: 4, cast: variable(i32))
.field i6: int32 (size: 4, cast: variable(i32))
.field i2: int32 (size: 4, cast: variable(i32))
.field i8: int32 (size: 4, cast: variable(i32))
.field zeroVal: int32 (size: 4, cast: variable(i32))
.field zeroVar: int32 (size: 4, cast: variable(i32))
.field zeroXpr: int32 (size: 4, cast: variable(i32))
.field lastVal: int32 (size: 4, cast: variable(i32))
.field lastVar: int32 (size: 4, cast: variable(i32))
.field lastXpr: int32 (size: 4, cast: variable(i32))
.field sum2Val: int32 (size: 4, cast: variable(i32))
.field sum2Var: int32 (size: 4, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, cast: variable(i32))
.field any2Val: int32 (size: 4, cast: variable(i32))
.field any2Var: int32 (size: 4, cast: variable(i32))
.field any2Xpr: int32 (size: 4, cast: variable(i32))
.field min2Val: int32 (size: 4, cast: variable(i32))
.field min2Var: int32 (size: 4, cast: variable(i32))
.field min2Xpr: int32 (size: 4, cast: variable(i32))
.field max2Val: int32 (size: 4, cast: variable(i32))
.field max2Var: int32 (size: 4, cast: variable(i32))
.field max2Xpr: int32 (size: 4, cast: variable(i32))
.field sumLr: function (size: 0, cast: inline)
.field sumRl: function (size: 0, cast: inline)
.field sumRlVal: int32 (size: 4, cast: variable(i32))
.field sumLrVal: int32 (size: 4, cast: variable(i32))
.field sumRlVar: int32 (size: 4, cast: variable(i32))
.field sumLrVar: int32 (size: 4, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, cast: variable(i32))
.field anyLr: function (size: 0, cast: inline)
.field anyRl: function (size: 0, cast: inline)
.field anyRlVal: int32 (size: 4, cast: variable(i32))
.field anyLrVal: int32 (size: 4, cast: variable(i32))
.field anyRlVar: int32 (size: 4, cast: variable(i32))
.field anyLrVar: int32 (size: 4, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, cast: variable(i32))
.field minLr: function (size: 0, cast: inline)
.field minRl: function (size: 0, cast: inline)
.field minRlVal: int32 (size: 4, cast: variable(i32))
.field minLrVal: int32 (size: 4, cast: variable(i32))
.field minRlVar: int32 (size: 4, cast: variable(i32))
.field minLrVar: int32 (size: 4, cast: variable(i32))
.field minRlXpr: int32 (size: 4, cast: variable(i32))
.field minLrXpr: int32 (size: 4, cast: variable(i32))
.field maxLr: function (size: 0, cast: inline)
.field maxRl: function (size: 0, cast: inline)
.field maxRlVal: int32 (size: 4, cast: variable(i32))
.field maxLrVal: int32 (size: 4, cast: variable(i32))
.field maxRlVar: int32 (size: 4, cast: variable(i32))
.field maxLrVar: int32 (size: 4, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, cast: variable(i32))
.field overload: typename (size: 0, cast: inline)
.field overload: function (size: 0, cast: inline)
.field overload: function (size: 0, cast: inline)
.field overload: function (size: 0, cast: inline)
.field overload: function (size: 0, cast: inline)
.field overload1: float32 (size: 4, cast: variable(f32))
.field overload2: float32 (size: 4, cast: variable(f32))
.field overload3: float32 (size: 4, cast: variable(f32))
.field overload4: float32 (size: 4, cast: variable(f32))
.field overload5: float32 (size: 4, cast: variable(f32))
.field Celsius: typename (size: 8, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, cast: static const typename(val))
.field Celsius: function (size: 0, cast: inline)
.field Fahrenheit: function (size: 0, cast: inline)
.field Celsius: function (size: 0, cast: inline)
.field Fahrenheit: function (size: 0, cast: inline)
.field boilC: Celsius (size: 8, cast: variable(val))
.field boilF: Fahrenheit (size: 8, cast: variable(val))
.field realloc: function (size: 0, cast: inline)
.field malloc: function (size: 0, cast: inline)
.field free: function (size: 0, cast: inline)
.field p1: pointer (size: 4, cast: variable(ref))
.field p2: pointer (size: 4, cast: variable(ref))
.field p3: pointer (size: 4, cast: variable(ref))
.field p4: pointer (size: 4, cast: variable(ref))
.field val1: int64 (size: 8, cast: variable(i64))
.field val2: int64 (size: 8, cast: variable(i64))
.field noError: function (size: 1, cast: static function)
.field stackOverflow: function (size: 24, cast: static function)
.field divisionByZero: function (size: 12, cast: static function)
.field abortExecution: function (size: 83, cast: static function)
.field invalidMemoryAccess: function (size: 13, cast: static function)
.field invalidInstruction: function (size: 2, cast: static function)
.field tryExecErr0: int32 (size: 4, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, cast: variable(i32))
.field arr: int32[5] (size: 20, cast: variable(val))
.field ptr: pointer (size: 4, cast: variable(ref))
.field a0: int32 (size: 4, cast: variable(ref))
.field a1: int32 (size: 4, cast: variable(ref))
.field a2: int32 (size: 4, cast: variable(ref))
.field a3: int32 (size: 4, cast: variable(ref))
.field a4: int32 (size: 4, cast: variable(ref))
.field value: int64 (size: 8, cast: static variable(i64))
.field valueRef: int64 (size: 4, cast: variable(ref))
.field valuePtr: pointer (size: 4, cast: variable(ref))
.field valueVar: variant (size: 8, cast: variable(var))
.field fromRef: int64 (size: 8, cast: variable(i64))
.field fromPtr: int64 (size: 4, cast: variable(ref))
.field fromVar: int64 (size: 4, cast: variable(ref))
.field nullRef: int64 (size: 4, cast: variable(ref))
.field nullPtr: pointer (size: 4, cast: variable(ref))
.field nullVar: variant (size: 8, cast: variable(var))
.field nullTyp: typename (size: 4, cast: variable(ref))
.field nullFun: function (size: 4, cast: variable(ref))
.field nullObj: object (size: 4, cast: variable(ref))
.field typePtr: pointer (size: 4, cast: variable(ref))
.field typeVar: variant (size: 8, cast: variable(var))
.field typeTyp: typename (size: 4, cast: variable(ref))
.field local: int64 (size: 8, cast: variable(i64))
.field copyVal: int64 (size: 8, cast: variable(i64))
.field copyRef: int64 (size: 4, cast: variable(ref))
.field copyPtr: pointer (size: 4, cast: variable(ref))
.field copyVar: variant (size: 8, cast: variable(var))
.field copyTyp: typename (size: 4, cast: variable(ref))
.field ptrVoid: pointer (size: 4, cast: variable(ref))
.field ptrBool: pointer (size: 4, cast: variable(ref))
.field ptrChar: pointer (size: 4, cast: variable(ref))
.field ptrInt8: pointer (size: 4, cast: variable(ref))
.field ptrInt16: pointer (size: 4, cast: variable(ref))
.field ptrInt32: pointer (size: 4, cast: variable(ref))
.field ptrInt64: pointer (size: 4, cast: variable(ref))
.field ptrUint8: pointer (size: 4, cast: variable(ref))
.field ptrUint16: pointer (size: 4, cast: variable(ref))
.field ptrUint32: pointer (size: 4, cast: variable(ref))
.field ptrUint64: pointer (size: 4, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, cast: variable(ref))
.field ptrTypename: pointer (size: 4, cast: variable(ref))
.field ptrFunction: pointer (size: 4, cast: variable(ref))
.field ptrPointer: pointer (size: 4, cast: variable(ref))
.field ptrVariant: pointer (size: 4, cast: variable(ref))
.field ptrObject: pointer (size: 4, cast: variable(ref))
.field varVoid: variant (size: 8, cast: variable(var))
.field varBool: variant (size: 8, cast: variable(var))
.field varChar: variant (size: 8, cast: variable(var))
.field varInt8: variant (size: 8, cast: variable(var))
.field varInt16: variant (size: 8, cast: variable(var))
.field varInt32: variant (size: 8, cast: variable(var))
.field varInt64: variant (size: 8, cast: variable(var))
.field varUint8: variant (size: 8, cast: variable(var))
.field varUint16: variant (size: 8, cast: variable(var))
.field varUint32: variant (size: 8, cast: variable(var))
.field varUint64: variant (size: 8, cast: variable(var))
.field varFloat32: variant (size: 8, cast: variable(var))
.field varFloat64: variant (size: 8, cast: variable(var))
.field varTypename: variant (size: 8, cast: variable(var))
.field varFunction: variant (size: 8, cast: variable(var))
.field varPointer: variant (size: 8, cast: variable(var))
.field varVariant: variant (size: 8, cast: variable(var))
.field varObject: variant (size: 8, cast: variable(var))
.field typVoid: typename (size: 4, cast: variable(ref))
.field typBool: typename (size: 4, cast: variable(ref))
.field typChar: typename (size: 4, cast: variable(ref))
.field typInt8: typename (size: 4, cast: variable(ref))
.field typInt16: typename (size: 4, cast: variable(ref))
.field typInt32: typename (size: 4, cast: variable(ref))
.field typInt64: typename (size: 4, cast: variable(ref))
.field typUint8: typename (size: 4, cast: variable(ref))
.field typUint16: typename (size: 4, cast: variable(ref))
.field typUint32: typename (size: 4, cast: variable(ref))
.field typUint64: typename (size: 4, cast: variable(ref))
.field typFloat32: typename (size: 4, cast: variable(ref))
.field typFloat64: typename (size: 4, cast: variable(ref))
.field typTypename: typename (size: 4, cast: variable(ref))
.field typFunction: typename (size: 4, cast: variable(ref))
.field typPointer: typename (size: 4, cast: variable(ref))
.field typVariant: typename (size: 4, cast: variable(ref))
.field typObject: typename (size: 4, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, cast: variable(ref))
.field valueOfVar: variant (size: 8, cast: variable(var))
.field valueOfTyp: typename (size: 4, cast: variable(ref))
.field typeOfValue: typename (size: 4, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, cast: variable(ref))
.field variable: int32 (size: 4, cast: variable(i32))
.field constant: int32 (size: 4, cast: const variable(i32))
.field ComplexVal: typename (size: 16, cast: static const typename(val))
.field ComplexObj: object (size: 20, cast: static const typename(ref))
.field valInitImplicit: ComplexVal (size: 16, cast: variable(val))
.field objInitImplicit: ComplexObj (size: 4, cast: variable(ref))
.field objInitExplicit: object (size: 4, cast: variable(ref))
.field empty: function (size: 1, cast: static function)
.field funAdd: function (size: 8, cast: static function)
.field funAddResult: int32 (size: 4, cast: variable(i32))
.field funAddRef: function (size: 4, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, cast: variable(i32))
.field funMul: function (size: 4, cast: variable(ref))
.field funMulResult: int32 (size: 4, cast: variable(i32))
.field funMulRef: function (size: 4, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, cast: variable(i32))
.field funMul: function (size: 8, cast: static function)
.field fib: function (size: 54, cast: static function)
.field fibonacci_13: uint32 (size: 4, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, cast: variable(i32))
.field sizeofBool: int32 (size: 4, cast: variable(i32))
.field sizeofChar: int32 (size: 4, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, cast: variable(i32))
.field sizeofObject: int32 (size: 4, cast: variable(i32))
.field RecordSizeof: object (size: 12, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, cast: variable(i32))
.field typeofBase: typename (size: 4, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, cast: variable(ref))
.field lineOfBase: int32 (size: 4, cast: variable(i32))
.field typeofBase1: typename (size: 4, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, cast: variable(i32))
.field typeofBase2: typename (size: 4, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, cast: variable(i32))
.field RecordMemberTest: typename (size: 32, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, cast: variable(val))
.field RecordMethodTest: typename (size: 16, cast: static const typename(val))
.field globalFunction: function (size: 54, cast: static function)
.field recordMethodTest: RecordMethodTest (size: 16, cast: variable(val))
.field staticMethod: function (size: 65, cast: static function)
.field virtualMethod: function (size: 62, cast: static function)
.field rgbF32: typename (size: 16, cast: static const typename(val))
.field rgbU8: typename (size: 3, cast: static const typename(val))
.field color: typename (size: 4, cast: static const typename(val))
.field Color: object (size: 20, cast: static const typename(ref))
.field black: rgbU8 (size: 3, cast: variable(val))
.field green: rgbU8 (size: 3, cast: variable(val))
.field white: rgbU8 (size: 3, cast: variable(val))
.field cyan: color (size: 4, cast: variable(val))
.field blue: color (size: 4, cast: variable(val))
.field record_pack0: typename (size: 8, cast: static const typename(val))
.field record_pack1: typename (size: 17, cast: static const typename(val))
.field record_pack2: typename (size: 20, cast: static const typename(val))
.field record_pack4: typename (size: 24, cast: static const typename(val))
.field record_pack8: typename (size: 32, cast: static const typename(val))
.field record_packDef: typename (size: 32, cast: static const typename(val))
.field a: typename (size: 0, cast: inline)
.field b: typename (size: 0, cast: inline)
.field shift: int32 (size: 4, cast: variable(i32))
.field boolA: bool (size: 1, cast: variable(bool))
.field boolB: bool (size: 1, cast: variable(bool))
.field boolAnd: bool (size: 1, cast: variable(bool))
.field boolIor: bool (size: 1, cast: variable(bool))
.field boolXor: bool (size: 1, cast: variable(bool))
.field boolNot: bool (size: 1, cast: variable(bool))
.field boolCeq: bool (size: 1, cast: variable(bool))
.field boolCne: bool (size: 1, cast: variable(bool))
.field boolClt: bool (size: 1, cast: variable(bool))
.field boolCle: bool (size: 1, cast: variable(bool))
.field boolCgt: bool (size: 1, cast: variable(bool))
.field boolCge: bool (size: 1, cast: variable(bool))
.field chrA: char (size: 1, cast: variable(i32))
.field chrB: char (size: 1, cast: variable(i32))
.field chrPls: char (size: 1, cast: variable(i32))
.field chrNeg: char (size: 1, cast: variable(i32))
.field chrCmt: char (size: 1, cast: variable(i32))
.field chrAdd: char (size: 1, cast: variable(i32))
.field chrSub: char (size: 1, cast: variable(i32))
.field chrMul: char (size: 1, cast: variable(i32))
.field chrDiv: char (size: 1, cast: variable(i32))
.field chrMod: char (size: 1, cast: variable(i32))
.field chrAnd: char (size: 1, cast: variable(i32))
.field chrIor: char (size: 1, cast: variable(i32))
.field chrXor: char (size: 1, cast: variable(i32))
.field chrShl: char (size: 1, cast: variable(i32))
.field chrShr: char (size: 1, cast: variable(i32))
.field chrNot: bool (size: 1, cast: variable(bool))
.field chrCeq: bool (size: 1, cast: variable(bool))
.field chrCne: bool (size: 1, cast: variable(bool))
.field chrClt: bool (size: 1, cast: variable(bool))
.field chrCle: bool (size: 1, cast: variable(bool))
.field chrCgt: bool (size: 1, cast: variable(bool))
.field chrCge: bool (size: 1, cast: variable(bool))
.field i8A: int8 (size: 1, cast: variable(i32))
.field i8B: int8 (size: 1, cast: variable(i32))
.field i8Pls: int8 (size: 1, cast: variable(i32))
.field i8Neg: int8 (size: 1, cast: variable(i32))
.field i8Cmt: int8 (size: 1, cast: variable(i32))
.field i8Add: int8 (size: 1, cast: variable(i32))
.field i8Sub: int8 (size: 1, cast: variable(i32))
.field i8Mul: int8 (size: 1, cast: variable(i32))
.field i8Div: int8 (size: 1, cast: variable(i32))
.field i8Mod: int8 (size: 1, cast: variable(i32))
.field i8And: int8 (size: 1, cast: variable(i32))
.field i8Ior: int8 (size: 1, cast: variable(i32))
.field i8Xor: int8 (size: 1, cast: variable(i32))
.field i8Shl: int8 (size: 1, cast: variable(i32))
.field i8Shr: int8 (size: 1, cast: variable(i32))
.field i8Not: bool (size: 1, cast: variable(bool))
.field i8Ceq: bool (size: 1, cast: variable(bool))
.field i8Cne: bool (size: 1, cast: variable(bool))
.field i8Clt: bool (size: 1, cast: variable(bool))
.field i8Cle: bool (size: 1, cast: variable(bool))
.field i8Cgt: bool (size: 1, cast: variable(bool))
.field i8Cge: bool (size: 1, cast: variable(bool))
.field u8A: uint8 (size: 1, cast: variable(u32))
.field u8B: uint8 (size: 1, cast: variable(u32))
.field u8Pls: uint8 (size: 1, cast: variable(u32))
.field u8Neg: uint8 (size: 1, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, cast: variable(u32))
.field u8Add: uint8 (size: 1, cast: variable(u32))
.field u8Sub: uint8 (size: 1, cast: variable(u32))
.field u8Mul: uint8 (size: 1, cast: variable(u32))
.field u8Div: uint8 (size: 1, cast: variable(u32))
.field u8Mod: uint8 (size: 1, cast: variable(u32))
.field u8And: uint8 (size: 1, cast: variable(u32))
.field u8Ior: uint8 (size: 1, cast: variable(u32))
.field u8Xor: uint8 (size: 1, cast: variable(u32))
.field u8Shl: uint8 (size: 1, cast: variable(u32))
.field u8Shr: uint8 (size: 1, cast: variable(u32))
.field u8Not: bool (size: 1, cast: variable(bool))
.field u8Ceq: bool (size: 1, cast: variable(bool))
.field u8Cne: bool (size: 1, cast: variable(bool))
.field u8Clt: bool (size: 1, cast: variable(bool))
.field u8Cle: bool (size: 1, cast: variable(bool))
.field u8Cgt: bool (size: 1, cast: variable(bool))
.field u8Cge: bool (size: 1, cast: variable(bool))
.field i16A: int16 (size: 2, cast: variable(i32))
.field i16B: int16 (size: 2, cast: variable(i32))
.field i16Pls: int16 (size: 2, cast: variable(i32))
.field i16Neg: int16 (size: 2, cast: variable(i32))
.field i16Cmt: int16 (size: 2, cast: variable(i32))
.field i16Add: int16 (size: 2, cast: variable(i32))
.field i16Sub: int16 (size: 2, cast: variable(i32))
.field i16Mul: int16 (size: 2, cast: variable(i32))
.field i16Div: int16 (size: 2, cast: variable(i32))
.field i16Mod: int16 (size: 2, cast: variable(i32))
.field i16And: int16 (size: 2, cast: variable(i32))
.field i16Ior: int16 (size: 2, cast: variable(i32))
.field i16Xor: int16 (size: 2, cast: variable(i32))
.field i16Shl: int16 (size: 2, cast: variable(i32))
.field i16Shr: int16 (size: 2, cast: variable(i32))
.field i16Not: bool (size: 1, cast: variable(bool))
.field i16Ceq: bool (size: 1, cast: variable(bool))
.field i16Cne: bool (size: 1, cast: variable(bool))
.field i16Clt: bool (size: 1, cast: variable(bool))
.field i16Cle: bool (size: 1, cast: variable(bool))
.field i16Cgt: bool (size: 1, cast: variable(bool))
.field i16Cge: bool (size: 1, cast: variable(bool))
.field u16A: uint16 (size: 2, cast: variable(u32))
.field u16B: uint16 (size: 2, cast: variable(u32))
.field u16Pls: uint16 (size: 2, cast: variable(u32))
.field u16Neg: uint16 (size: 2, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, cast: variable(u32))
.field u16Add: uint16 (size: 2, cast: variable(u32))
.field u16Sub: uint16 (size: 2, cast: variable(u32))
.field u16Mul: uint16 (size: 2, cast: variable(u32))
.field u16Div: uint16 (size: 2, cast: variable(u32))
.field u16Mod: uint16 (size: 2, cast: variable(u32))
.field u16And: uint16 (size: 2, cast: variable(u32))
.field u16Ior: uint16 (size: 2, cast: variable(u32))
.field u16Xor: uint16 (size: 2, cast: variable(u32))
.field u16Shl: uint16 (size: 2, cast: variable(u32))
.field u16Shr: uint16 (size: 2, cast: variable(u32))
.field u16Not: bool (size: 1, cast: variable(bool))
.field u16Ceq: bool (size: 1, cast: variable(bool))
.field u16Cne: bool (size: 1, cast: variable(bool))
.field u16Clt: bool (size: 1, cast: variable(bool))
.field u16Cle: bool (size: 1, cast: variable(bool))
.field u16Cgt: bool (size: 1, cast: variable(bool))
.field u16Cge: bool (size: 1, cast: variable(bool))
.field i32A: int32 (size: 4, cast: variable(i32))
.field i32B: int32 (size: 4, cast: variable(i32))
.field i32Pls: int32 (size: 4, cast: variable(i32))
.field i32Neg: int32 (size: 4, cast: variable(i32))
.field i32Cmt: int32 (size: 4, cast: variable(i32))
.field i32Add: int32 (size: 4, cast: variable(i32))
.field i32Sub: int32 (size: 4, cast: variable(i32))
.field i32Mul: int32 (size: 4, cast: variable(i32))
.field i32Div: int32 (size: 4, cast: variable(i32))
.field i32Mod: int32 (size: 4, cast: variable(i32))
.field i32And: int32 (size: 4, cast: variable(i32))
.field i32Ior: int32 (size: 4, cast: variable(i32))
.field i32Xor: int32 (size: 4, cast: variable(i32))
.field i32Shl: int32 (size: 4, cast: variable(i32))
.field i32Shr: int32 (size: 4, cast: variable(i32))
.field i32Not: bool (size: 1, cast: variable(bool))
.field i32Ceq: bool (size: 1, cast: variable(bool))
.field i32Cne: bool (size: 1, cast: variable(bool))
.field i32Clt: bool (size: 1, cast: variable(bool))
.field i32Cle: bool (size: 1, cast: variable(bool))
.field i32Cgt: bool (size: 1, cast: variable(bool))
.field i32Cge: bool (size: 1, cast: variable(bool))
.field u32A: uint32 (size: 4, cast: variable(u32))
.field u32B: uint32 (size: 4, cast: variable(u32))
.field u32Pls: uint32 (size: 4, cast: variable(u32))
.field u32Neg: uint32 (size: 4, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, cast: variable(u32))
.field u32Add: uint32 (size: 4, cast: variable(u32))
.field u32Sub: uint32 (size: 4, cast: variable(u32))
.field u32Mul: uint32 (size: 4, cast: variable(u32))
.field u32Div: uint32 (size: 4, cast: variable(u32))
.field u32Mod: uint32 (size: 4, cast: variable(u32))
.field u32And: uint32 (size: 4, cast: variable(u32))
.field u32Ior: uint32 (size: 4, cast: variable(u32))
.field u32Xor: uint32 (size: 4, cast: variable(u32))
.field u32Shl: uint32 (size: 4, cast: variable(u32))
.field u32Shr: uint32 (size: 4, cast: variable(u32))
.field u32Not: bool (size: 1, cast: variable(bool))
.field u32Ceq: bool (size: 1, cast: variable(bool))
.field u32Cne: bool (size: 1, cast: variable(bool))
.field u32Clt: bool (size: 1, cast: variable(bool))
.field u32Cle: bool (size: 1, cast: variable(bool))
.field u32Cgt: bool (size: 1, cast: variable(bool))
.field u32Cge: bool (size: 1, cast: variable(bool))
.field i64A: int64 (size: 8, cast: variable(i64))
.field i64B: int64 (size: 8, cast: variable(i64))
.field i64Pls: int64 (size: 8, cast: variable(i64))
.field i64Neg: int64 (size: 8, cast: variable(i64))
.field i64Cmt: int64 (size: 8, cast: variable(i64))
.field i64Add: int64 (size: 8, cast: variable(i64))
.field i64Sub: int64 (size: 8, cast: variable(i64))
.field i64Mul: int64 (size: 8, cast: variable(i64))
.field i64Div: int64 (size: 8, cast: variable(i64))
.field i64Mod: int64 (size: 8, cast: variable(i64))
.field i64And: int64 (size: 8, cast: variable(i64))
.field i64Ior: int64 (size: 8, cast: variable(i64))
.field i64Xor: int64 (size: 8, cast: variable(i64))
.field i64Shl: int64 (size: 8, cast: variable(i64))
.field i64Shr: int64 (size: 8, cast: variable(i64))
.field i64Not: bool (size: 1, cast: variable(bool))
.field i64Ceq: bool (size: 1, cast: variable(bool))
.field i64Cne: bool (size: 1, cast: variable(bool))
.field i64Clt: bool (size: 1, cast: variable(bool))
.field i64Cle: bool (size: 1, cast: variable(bool))
.field i64Cgt: bool (size: 1, cast: variable(bool))
.field i64Cge: bool (size: 1, cast: variable(bool))
.field u64A: uint64 (size: 8, cast: variable(u64))
.field u64B: uint64 (size: 8, cast: variable(u64))
.field u64Pls: uint64 (size: 8, cast: variable(u64))
.field u64Neg: uint64 (size: 8, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, cast: variable(u64))
.field u64Add: uint64 (size: 8, cast: variable(u64))
.field u64Sub: uint64 (size: 8, cast: variable(u64))
.field u64Mul: uint64 (size: 8, cast: variable(u64))
.field u64Div: uint64 (size: 8, cast: variable(u64))
.field u64Mod: uint64 (size: 8, cast: variable(u64))
.field u64And: uint64 (size: 8, cast: variable(u64))
.field u64Ior: uint64 (size: 8, cast: variable(u64))
.field u64Xor: uint64 (size: 8, cast: variable(u64))
.field u64Shl: uint64 (size: 8, cast: variable(u64))
.field u64Shr: uint64 (size: 8, cast: variable(u64))
.field u64Not: bool (size: 1, cast: variable(bool))
.field u64Ceq: bool (size: 1, cast: variable(bool))
.field u64Cne: bool (size: 1, cast: variable(bool))
.field u64Clt: bool (size: 1, cast: variable(bool))
.field u64Cle: bool (size: 1, cast: variable(bool))
.field u64Cgt: bool (size: 1, cast: variable(bool))
.field u64Cge: bool (size: 1, cast: variable(bool))
.field f32A: float32 (size: 4, cast: variable(f32))
.field f32B: float32 (size: 4, cast: variable(f32))
.field f32Pls: float32 (size: 4, cast: variable(f32))
.field f32Neg: float32 (size: 4, cast: variable(f32))
.field f32Add: float32 (size: 4, cast: variable(f32))
.field f32Sub: float32 (size: 4, cast: variable(f32))
.field f32Mul: float32 (size: 4, cast: variable(f32))
.field f32Div: float32 (size: 4, cast: variable(f32))
.field f32Mod: float32 (size: 4, cast: variable(f32))
.field f32Not: bool (size: 1, cast: variable(bool))
.field f32Ceq: bool (size: 1, cast: variable(bool))
.field f32Cne: bool (size: 1, cast: variable(bool))
.field f32Clt: bool (size: 1, cast: variable(bool))
.field f32Cle: bool (size: 1, cast: variable(bool))
.field f32Cgt: bool (size: 1, cast: variable(bool))
.field f32Cge: bool (size: 1, cast: variable(bool))
.field f64A: float64 (size: 8, cast: variable(f64))
.field f64B: float64 (size: 8, cast: variable(f64))
.field f64Pls: float64 (size: 8, cast: variable(f64))
.field f64Neg: float64 (size: 8, cast: variable(f64))
.field f64Add: float64 (size: 8, cast: variable(f64))
.field f64Sub: float64 (size: 8, cast: variable(f64))
.field f64Mul: float64 (size: 8, cast: variable(f64))
.field f64Div: float64 (size: 8, cast: variable(f64))
.field f64Mod: float64 (size: 8, cast: variable(f64))
.field f64Not: bool (size: 1, cast: variable(bool))
.field f64Ceq: bool (size: 1, cast: variable(bool))
.field f64Cne: bool (size: 1, cast: variable(bool))
.field f64Clt: bool (size: 1, cast: variable(bool))
.field f64Cle: bool (size: 1, cast: variable(bool))
.field f64Cgt: bool (size: 1, cast: variable(bool))
.field f64Cge: bool (size: 1, cast: variable(bool))
.field ptrA: pointer (size: 4, cast: variable(ref))
.field ptrB: pointer (size: 4, cast: variable(ref))
.field ptrCeq: bool (size: 1, cast: variable(bool))
.field ptrCne: bool (size: 1, cast: variable(bool))
.field t: int32 (size: 4, cast: variable(i32))
.field forIdx: int32 (size: 4, cast: variable(i32))
.field pi64: float64 (size: 8, cast: variable(f64))
.field e64: float64 (size: 8, cast: variable(f64))
.field pi32: float32 (size: 4, cast: variable(f32))
.field e32: float32 (size: 4, cast: variable(f32))
.field rgb888: function (size: 0, cast: inline)
.field rgb565: function (size: 0, cast: inline)
.field r_comp: int32 (size: 4, cast: variable(i32))
.field g_comp: int32 (size: 4, cast: variable(i32))
.field b_comp: int32 (size: 4, cast: variable(i32))
.field r5g6b5: int32 (size: 4, cast: variable(i32))
.field r8g8b8: int32 (size: 4, cast: variable(i32))
.field zxtR5: int32 (size: 4, cast: variable(i32))
.field zxtG6: int32 (size: 4, cast: variable(i32))
.field zxtB5: int32 (size: 4, cast: variable(i32))
.field sxtR5: int32 (size: 4, cast: variable(i32))
.field sxtG6: int32 (size: 4, cast: variable(i32))
.field sxtB5: int32 (size: 4, cast: variable(i32))
.field zxtR8: int32 (size: 4, cast: variable(i32))
.field zxtG8: int32 (size: 4, cast: variable(i32))
.field zxtB8: int32 (size: 4, cast: variable(i32))
.field sxtR8: int32 (size: 4, cast: variable(i32))
.field sxtG8: int32 (size: 4, cast: variable(i32))
.field sxtB8: int32 (size: 4, cast: variable(i32))
.field testSin_f64: float64 (size: 8, cast: variable(f64))
.field testCos_f64: float64 (size: 8, cast: variable(f64))
.field testTan_f64: float64 (size: 8, cast: variable(f64))
.field testLog_f64: float64 (size: 8, cast: variable(f64))
.field testExp_f64: float64 (size: 8, cast: variable(f64))
.field testPow_f64: float64 (size: 8, cast: variable(f64))
.field testSqrt_f64: float64 (size: 8, cast: variable(f64))
.field testAtan_f64: float64 (size: 8, cast: variable(f64))
.field testSin_f32: float32 (size: 4, cast: variable(f32))
.field testCos_f32: float32 (size: 4, cast: variable(f32))
.field testTan_f32: float32 (size: 4, cast: variable(f32))
.field testLog_f32: float32 (size: 4, cast: variable(f32))
.field testExp_f32: float32 (size: 4, cast: variable(f32))
.field testPow_f32: float32 (size: 4, cast: variable(f32))
.field testSqrt_f32: float32 (size: 4, cast: variable(f32))
.field testAtan_f32: float32 (size: 4, cast: variable(f32))
.field testPopulation_u32: int32 (size: 4, cast: variable(i32))
.field testSwapBits_u32: uint32 (size: 4, cast: variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, cast: variable(i32))
.field testBitScanForward_u32: int32 (size: 4, cast: variable(i32))
.field testHighBit_u32: int32 (size: 4, cast: variable(i32))
.field testLowBit_u32: int32 (size: 4, cast: variable(i32))
.field testZeroExtend_u32: int32 (size: 4, cast: variable(i32))
.field testSignExtend_u32: int32 (size: 4, cast: variable(i32))
.field testZeroExtend_u64: int32 (size: 4, cast: variable(i32))
.field testSignExtend_u64: int32 (size: 4, cast: variable(i32))
.field testMathFloor_pos_3_0: float64 (size: 8, cast: variable(f64))
.field testMathFloor_pos_3_2: float64 (size: 8, cast: variable(f64))
.field testMathFloor_pos_3_5: float64 (size: 8, cast: variable(f64))
.field testMathFloor_pos_3_7: float64 (size: 8, cast: variable(f64))
.field testMathFloor_pos_3_9: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_0: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_2: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_5: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_7: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_9: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_0: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_2: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_5: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_7: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_9: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_0: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_2: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_5: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_7: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_9: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_0: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_2: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_5: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_7: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_9: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_0: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_2: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_5: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_7: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_9: float64 (size: 8, cast: variable(f64))
.field testMathSign_1F: float64 (size: 8, cast: variable(f64))
.field testMathSign_2F: float64 (size: 8, cast: variable(f64))
.field testMathSign_3F: float64 (size: 8, cast: variable(f64))
.field testMathSign_1f: float64 (size: 8, cast: variable(f64))
.field testMathSign_2f: float64 (size: 8, cast: variable(f64))
.field testMathSign_3f: float64 (size: 8, cast: variable(f64))
.field testMathAbs_1F: float64 (size: 8, cast: variable(f64))
.field testMathAbs_2F: float64 (size: 8, cast: variable(f64))
.field testMathAbs_3F: float64 (size: 8, cast: variable(f64))
.field testMathAbs_1f: float64 (size: 8, cast: variable(f64))
.field testMathAbs_2f: float64 (size: 8, cast: variable(f64))
.field testMathAbs_3f: float64 (size: 8, cast: variable(f64))
.field testMathMin_1f: float64 (size: 8, cast: variable(f64))
.field testMathMax_2f: float64 (size: 8, cast: variable(f64))
.field testMathMin_1F: float64 (size: 8, cast: variable(f64))
.field testMathMax_2F: float64 (size: 8, cast: variable(f64))
.field testMathClamp_1f: float64 (size: 8, cast: variable(f64))
.field testMathClamp_1F: float64 (size: 8, cast: variable(f64))
.field testMathMix_1f: float64 (size: 8, cast: variable(f64))
.field testMathMix_1F: float64 (size: 8, cast: variable(f64))
.field testMathSmooth_1f: float64 (size: 8, cast: variable(f64))
.field testMathSmooth_1F: float64 (size: 8, cast: variable(f64))
.field testMathMin_nan: float64 (size: 8, cast: variable(f64))
.field testMathMin_1: float64 (size: 8, cast: variable(f64))
.field testMathMax_nan: float64 (size: 8, cast: variable(f64))
.field testMathMax_9: float64 (size: 8, cast: variable(f64))
.field testMathSum_0: float64 (size: 8, cast: variable(f64))
.field testMathSum_1: float64 (size: 8, cast: variable(f64))
.field testMathSum_3: float64 (size: 8, cast: variable(f64))
.field testMathSum_55: float64 (size: 8, cast: variable(f64))
.field testMathEval_x: float64 (size: 8, cast: variable(f64))
.field testMathEval_0: float64 (size: 8, cast: variable(f64))
.field testMathEval_1: float64 (size: 8, cast: variable(f64))
.field testMathEval_2: float64 (size: 8, cast: variable(f64))
.field testMathEval_3: float64 (size: 8, cast: variable(f64))
.field testMathEval_4: float64 (size: 8, cast: variable(f64))
.field testMathEval_5: float64 (size: 8, cast: variable(f64))
.field testMathEval_6: float64 (size: 8, cast: variable(f64))
.field testMathSin_f64: float64 (size: 8, cast: variable(f64))
.field testMathCos_f64: float64 (size: 8, cast: variable(f64))
.field testMathTan_f64: float64 (size: 8, cast: variable(f64))
.field testMathSinh_f64: float64 (size: 8, cast: variable(f64))
.field testMathCosh_f64: float64 (size: 8, cast: variable(f64))
.field testMathAsin_f64: float64 (size: 8, cast: variable(f64))
.field testMathAcos_f64: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_0a: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, cast: variable(f32))
.field Neg: function (size: 0, cast: inline)
.field Add: function (size: 0, cast: inline)
.field Sub: function (size: 0, cast: inline)
.field Mul: function (size: 0, cast: inline)
.field valA: Complex (size: 16, cast: variable(val))
.field valB: Complex (size: 16, cast: variable(val))
.field Neg: Complex (size: 16, cast: variable(val))
.field neg: Complex (size: 16, cast: variable(val))
.field Add: Complex (size: 16, cast: variable(val))
.field add: Complex (size: 16, cast: variable(val))
.field Sub: Complex (size: 16, cast: variable(val))
.field sub: Complex (size: 16, cast: variable(val))
.field Mul: Complex (size: 16, cast: variable(val))
.field mul: Complex (size: 16, cast: variable(val))
.field .main: function (size: 22550, cast: static function)
.value: {
	{
		byte: typename := uint8;
		float: typename := float32;
		double: typename := float64;
		sizeof(type: typename): int32 := typename.size(type);
		static if (typename(raise) == function) {
			verbose(const message: char[*], const details: variant[]): void := raise(raise.verbose, raise.noTrace, message, ...details);
			debug(const message: char[*], const details: variant[]): void := raise(raise.debug, raise.noTrace, message, ...details);
			trace(const message: char[*], const details: variant[]): void := raise(raise.debug, raise.defTrace, message, ...details);
			info(const message: char[*], const details: variant[]): void := raise(raise.info, raise.noTrace, message, ...details);
			warn(const message: char[*], const details: variant[]): void := raise(raise.warn, raise.noTrace, message, ...details);
			error(const message: char[*], const details: variant[]): void := raise(raise.error, raise.defTrace, message, ...details);
			abort(const message: char[*], const details: variant[]): void := raise(raise.abort, raise.defTrace, message, ...details);
			abort(): void := raise(raise.abort, raise.defTrace, "execution aborted!");
			assert(condition: bool, const message: char[*], const details: variant[]): void := void(condition ? void(0) : raise(raise.abort, raise.defTrace, message, ...details));
			assert(condition: bool, const details: variant[]): void := void(condition ? void(0) : raise(raise.abort, raise.defTrace, "assertion failed!", ...details));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const extras: variant[];
			};
			static NotEquals(const expected: variant, const returned: variant): NotEquals := {
				return .result := {
			.result.expected := expected;
			.result.returned := returned;
			.result.extras := (null);
		};
			};
			abort(const message: char[*], const detail: NotEquals): void := raise(raise.abort, raise.defTrace, message, detail);
			assert(condition: bool, const message: char[*], const detail: NotEquals): void := void(condition ? void(0) : abort(message, detail));
			static assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (returned == expected) {
					return;
				}
				extras: variant[1] := {
					extras[0] := (message);
				};
				detail: NotEquals := {
					detail.expected := (expected);
					detail.returned := (returned);
					detail.extras := (extras);
				};
				raise(raise.abort, raise.defTrace, "assertion failed", detail);
			};
			assertEq(expected: int32, returned: int32): void := assertEq(expected, returned, null);
		}
		static if (int32 == int32) {
			inc(ptr: pointer, val: int32): pointer := pointer(emit(pointer(ptr), int32(val), add.i32));
		}
		static if (int32 == int64) {
			inc(ptr: pointer, val: int32): pointer := pointer(emit(pointer(ptr), int32(val), add.i64));
		}
		static const Bits: struct {
			static signed(value: uint8): int8 := int8(value);
			static signed(value: uint16): int16 := int16(value);
			static signed(value: uint32): int32 := int32(value);
			static signed(value: uint64): int64 := int64(value);
			static unsigned(value: int8): uint8 := uint8(value);
			static unsigned(value: int16): uint16 := uint16(value);
			static unsigned(value: int32): uint32 := uint32(value);
			static unsigned(value: int64): uint64 := uint64(value);
			static fromFloat32(value: float32): uint32 := uint32(emit(float32(value)));
			static fromFloat64(value: float64): uint64 := uint64(emit(float64(value)));
			static asFloat32(value: uint32): float32 := float32(emit(uint32(value)));
			static asFloat64(value: uint64): float64 := float64(emit(uint64(value)));
			static asFloat64(hi: uint32, lo: uint32): float64 := float64(emit(uint64(uint64(hi) << 32 | (lo))));
			static zxt32(value: int32, offs: int32, count: int32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.zxt)) != null) {
					return .result := uint32.zxt(value, offs, count);
				}
				return .result := uint32(value << (32 - (offs + count))) >> (32 - count);
			};
			static sxt32(value: int32, offs: int32, count: int32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.sxt)) != null) {
					return .result := uint32.sxt(value, offs, count);
				}
				return .result := int32(value << (32 - (offs + count))) >> (32 - count);
			};
			static zxt64(value: int64, offs: int32, count: int32): int64 := {
				static if ((preferNativeCalls) && (typename(uint64.zxt)) != null) {
					return .result := uint64.zxt(value, offs, count);
				}
				return .result := uint64(value << (64 - (offs + count))) >> (64 - count);
			};
			static sxt64(value: int64, offs: int32, count: int32): int64 := {
				static if ((preferNativeCalls) && (typename(uint64.sxt)) != null) {
					return .result := uint64.sxt(value, offs, count);
				}
				return .result := int64(value << (64 - (offs + count))) >> (64 - count);
			};
			static swapBytes(x: uint64): uint64 := {
				x := (x & (4294967295)) << 32 | (x & (-4294967296)) >> 32;
				x := (x & (281470681808895)) << 16 | (x & (-281470681808896)) >> 16;
				x := (x & (71777214294589695)) << 8 | (x & (-71777214294589696)) >> 8;
				return .result := x;
			};
			static swapBytes(x: uint32): uint32 := {
				x := (((x & (65535)) << 16) | ((x) & 4294901760) >> 16);
				x := (((x & (16711935)) << 8) | ((x) & 4278255360) >> 8);
				return .result := x;
			};
			static swapBytes(x: uint16): uint16 := {
				return .result := ((x) & 255) << 8 | ((x) & 65280) >> 8;
			};
			static swapBytes(x: int64): int64 := int64(swapBytes(uint64(x)));
			static swapBytes(x: int32): int32 := int32(swapBytes(uint32(x)));
			static swapBytes(x: int16): int16 := int16(swapBytes(uint16(x)));
			static scanReverse(x: uint64): int32 := {
				static if ((preferNativeCalls) && (typename(uint64.bsr)) != null) {
					return .result := uint64.bsr(x);
				}
				if (x == (0)) {
					return .result := -1;
				}
				result: int32 := 0;
				if (x & (-4294967296)) {
					result := result + 32;
					x := x >> 32;
				}
				if (x & (4294901760)) {
					result := result + 16;
					x := x >> 16;
				}
				if (x & (65280)) {
					result := result + 8;
					x := x >> 8;
				}
				if (x & (240)) {
					result := result + 4;
					x := x >> 4;
				}
				if (x & (12)) {
					result := result + 2;
					x := x >> 2;
				}
				if (x & (2)) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanReverse(x: int64): int32 := scanReverse(uint64(x));
			static scanReverse(x: uint32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.bsr)) != null) {
					return .result := uint32.bsr(x);
				}
				if (x == (0)) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x) & 4294901760) {
					result := result + 16;
					x := x >> 16;
				}
				if (x & (65280)) {
					result := result + 8;
					x := x >> 8;
				}
				if (x & (240)) {
					result := result + 4;
					x := x >> 4;
				}
				if (x & (12)) {
					result := result + 2;
					x := x >> 2;
				}
				if (x & (2)) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanReverse(x: int32): int32 := scanReverse(uint32(x));
			static scanReverse(x: uint16): int32 := {
				if ((x) == 0) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x) & 65280) {
					result := result + 8;
					x := ((x) >> 8);
				}
				if ((x) & 240) {
					result := result + 4;
					x := ((x) >> 4);
				}
				if ((x) & 12) {
					result := result + 2;
					x := ((x) >> 2);
				}
				if ((x) & 2) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanReverse(x: int16): int32 := scanReverse(uint16(x));
			static scanReverse(x: uint8): int32 := {
				if ((x) == 0) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x) & 240) {
					result := result + 4;
					x := ((x) >> 4);
				}
				if ((x) & 12) {
					result := result + 2;
					x := ((x) >> 2);
				}
				if ((x) & 2) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanReverse(x: int8): int32 := scanReverse(uint8(x));
			static scanForward(x: uint64): int32 := {
				static if ((preferNativeCalls) && (typename(uint64.bsf)) != null) {
					return .result := uint64.bsf(x);
				}
				if (x == (0)) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x & (4294967295)) == (0)) {
					result := result + 32;
					x := x >> 32;
				}
				if ((x & (65535)) == (0)) {
					result := result + 16;
					x := x >> 16;
				}
				if ((x & (255)) == (0)) {
					result := result + 8;
					x := x >> 8;
				}
				if ((x & (15)) == (0)) {
					result := result + 4;
					x := x >> 4;
				}
				if ((x & (3)) == (0)) {
					result := result + 2;
					x := x >> 2;
				}
				if ((x & (1)) == (0)) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanForward(x: int64): int32 := scanForward(uint64(x));
			static scanForward(x: uint32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.bsf)) != null) {
					return .result := uint32.bsf(x);
				}
				if (x == (0)) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x & (65535)) == (0)) {
					result := result + 16;
					x := x >> 16;
				}
				if ((x & (255)) == (0)) {
					result := result + 8;
					x := x >> 8;
				}
				if ((x & (15)) == (0)) {
					result := result + 4;
					x := x >> 4;
				}
				if ((x & (3)) == (0)) {
					result := result + 2;
					x := x >> 2;
				}
				if ((x & (1)) == (0)) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanForward(x: int32): int32 := scanForward(uint32(x));
			static scanForward(x: uint16): int32 := {
				if ((x) == 0) {
					return .result := -1;
				}
				result: int32 := 0;
				if (((x) & 255) == 0) {
					result := result + 8;
					x := ((x) >> 8);
				}
				if (((x) & 15) == 0) {
					result := result + 4;
					x := ((x) >> 4);
				}
				if (((x) & 3) == 0) {
					result := result + 2;
					x := ((x) >> 2);
				}
				if (((x) & 1) == 0) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanForward(x: int16): int32 := scanForward(uint16(x));
			static scanForward(x: uint8): int32 := {
				if ((x) == 0) {
					return .result := -1;
				}
				result: int32 := 0;
				if (((x) & 15) == 0) {
					result := result + 4;
					x := ((x) >> 4);
				}
				if (((x) & 3) == 0) {
					result := result + 2;
					x := ((x) >> 2);
				}
				if (((x) & 1) == 0) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanForward(x: int8): int32 := scanForward(uint8(x));
			static keepMsb(x: uint64): uint64 := {
				static if ((preferNativeCalls) && (typename(uint64.hib)) != null) {
					return .result := uint64.hib(x);
				}
				x := x | x >> 1;
				x := x | x >> 2;
				x := x | x >> 4;
				x := x | x >> 8;
				x := x | x >> 16;
				x := x | x >> 32;
				return .result := x - (x >> 1);
			};
			static keepMsb(x: int64): uint64 := keepMsb(uint64(x));
			static keepMsb(x: uint32): uint32 := {
				static if ((preferNativeCalls) && (typename(uint32.hib)) != null) {
					return .result := uint32.hib(x);
				}
				x := x | x >> 1;
				x := x | x >> 2;
				x := x | x >> 4;
				x := x | x >> 8;
				x := x | x >> 16;
				return .result := x - (x >> 1);
			};
			static keepMsb(x: int32): uint32 := keepMsb(uint32(x));
			static keepLsb(x: uint64): uint64 := uint64(x & -x);
			static keepLsb(x: int64): uint64 := keepLsb(uint64(x));
			static keepLsb(x: uint32): uint32 := uint32(x & -x);
			static keepLsb(x: int32): uint32 := keepLsb(uint32(x));
			static keepLsb(x: uint16): uint16 := uint16(x & -x);
			static keepLsb(x: int16): uint16 := keepLsb(uint16(x));
			static keepLsb(x: uint8): uint8 := uint8(x & -x);
			static keepLsb(x: int8): uint8 := keepLsb(uint8(x));
			static countOnes(x: uint64): int32 := {
				static if ((preferNativeCalls) && (typename(uint64.pop)) != null) {
					return .result := uint64.pop(x);
				}
				x := x - ((x >> 1) & (6148914691236517205));
				x := (x & (3689348814741910323)) + ((x >> 2) & (3689348814741910323));
				x := (x + (x >> 4)) & (1085102592571150095);
				x := x + (x >> 8);
				x := x + (x >> 16);
				x := x + (x >> 32);
				return .result := x & (63);
			};
			static countOnes(x: int64): int32 := countOnes(uint64(x));
			static countOnes(x: uint32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.pop)) != null) {
					return .result := uint32.pop(x);
				}
				x := x - ((x >> 1) & (1431655765));
				x := (x & (858993459)) + ((x >> 2) & (858993459));
				x := (x + (x >> 4)) & (252645135);
				x := x + (x >> 8);
				x := x + (x >> 16);
				return .result := x & (63);
			};
			static countOnes(x: int32): int32 := countOnes(uint32(x));
			static swapBits(x: uint64): uint64 := {
				static if ((preferNativeCalls) && (typename(uint64.swap)) != null) {
					return .result := uint64.swap(x);
				}
				x := ((x >> 1) & (6148914691236517205)) | ((x & (6148914691236517205)) << 1);
				x := ((x >> 2) & (3689348814741910323)) | ((x & (3689348814741910323)) << 2);
				x := ((x >> 4) & (1085102592571150095)) | ((x & (1085102592571150095)) << 4);
				x := ((x >> 8) & (71777214294589695)) | ((x & (71777214294589695)) << 8);
				x := ((x >> 16) & (281470681808895)) | ((x & (281470681808895)) << 16);
				return .result := (x >> 32) | (x << 32);
			};
			static swapBits(x: int64): uint64 := swapBits(uint64(x));
			static swapBits(x: uint32): uint32 := {
				static if ((preferNativeCalls) && (typename(uint32.swap)) != null) {
					return .result := uint32.swap(x);
				}
				x := ((x >> 1) & (1431655765)) | ((x & (1431655765)) << 1);
				x := ((x >> 2) & (858993459)) | ((x & (858993459)) << 2);
				x := ((x >> 4) & (252645135)) | ((x & (252645135)) << 4);
				x := ((x >> 8) & (16711935)) | ((x & (16711935)) << 8);
				return .result := (x >> 16) | (x << 16);
			};
			static swapBits(x: int32): uint32 := swapBits(uint32(x));
			static swapBits(x: uint16): uint16 := {
				x := ((((x) >> 1) & 21845) | (((x) & 21845) << 1));
				x := ((((x) >> 2) & 13107) | (((x) & 13107) << 2));
				x := ((((x) >> 4) & 3855) | (((x) & 3855) << 4));
				return .result := ((x) >> 8) | ((x) << 8);
			};
			static swapBits(x: int16): uint16 := swapBits(uint16(x));
			static swapBits(x: uint8): uint8 := {
				x := ((((x) >> 1) & 85) | (((x) & 85) << 1));
				x := ((((x) >> 2) & 51) | (((x) & 51) << 2));
				return .result := ((x) >> 4) | ((x) << 4);
			};
			static swapBits(x: int8): uint8 := swapBits(uint8(x));
			static clamp(value: int32, max: int32): int32 := {
				value := value & ~(value >> 31);
				value := value - max;
				value := value & (value >> 31);
				value := value + max;
				return .result := value;
			};
			static clamp(value: int32, min: int32, max: int32): int32 := {
				return .result := clamp(value - min, max - min) + min;
			};
		};
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static const smallestNormal: float64 := 0.000000;
			static isNan(x: float64): bool := {
				return .result := x != x;
			};
			static isInf(x: float64): bool := {
				return .result := x != (0) && x == (2) * x;
			};
			static isFinite(x: float64): bool := {
				return .result := x - x == (0);
			};
			static isInf(x: float64, sign: int32): bool := {
				if (isFinite(x)) {
					return .result := false;
				}
				if (sign == 0) {
					return .result := true;
				}
				return .result := sign < 0 ? x < (0) : x > (0);
			};
			static floor(x: float64): float64 := {
				mod: float64 := x % (1);
				if (mod < (0)) {
					mod := mod + (1);
				}
				return .result := x - mod;
			};
			static floor(x: float32): float32 := {
				mod: float32 := x % (1);
				if (mod < (0)) {
					mod := mod + (1);
				}
				return .result := x - mod;
			};
			static ceil(x: float64): float64 := -floor(-x);
			static ceil(x: float32): float32 := -floor(-x);
			static round(x: float64): float64 := floor(x + 0.500000);
			static round(x: float32): float32 := floor(x + 0.500000);
			static sign(x: int32): int32 := int32(x > 0) - int32(x < 0);
			static sign(x: int64): int32 := int32(x > (0)) - int32(x < (0));
			static sign(x: uint32): int32 := int32(x > (0));
			static sign(x: uint64): int32 := int32(x > (0));
			static sign(x: float32): int32 := int32(x > (0)) - int32(x < (0));
			static sign(x: float64): int32 := int32(x > (0)) - int32(x < (0));
			static absMod(val: float32, mod: float32): float32 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static absMod(val: float64, mod: float64): float64 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static abs(x: int32): int32 := x < 0 ? -x : x;
			static abs(x: int64): int64 := x < (0) ? -x : x;
			static abs(x: uint32): uint32 := x;
			static abs(x: uint64): uint64 := x;
			static abs(x: float32): float32 := x < (0) ? -x : x;
			static abs(x: float64): float64 := x < (0) ? -x : x;
			static min(a: int32, b: int32): int32 := a < b ? a : b;
			static min(a: int64, b: int64): int64 := a < b ? a : b;
			static min(a: uint32, b: uint32): uint32 := a < b ? a : b;
			static min(a: uint64, b: uint64): uint64 := a < b ? a : b;
			static min(a: float32, b: float32): float32 := a < b ? a : b;
			static min(a: float64, b: float64): float64 := a < b ? a : b;
			static max(a: int32, b: int32): int32 := a > b ? a : b;
			static max(a: int64, b: int64): int64 := a > b ? a : b;
			static max(a: uint32, b: uint32): uint32 := a > b ? a : b;
			static max(a: uint64, b: uint64): uint64 := a > b ? a : b;
			static max(a: float32, b: float32): float32 := a > b ? a : b;
			static max(a: float64, b: float64): float64 := a > b ? a : b;
			static clamp(value: int32, min: int32, max: int32): int32 := min(max(value, min), max);
			static clamp(value: int64, min: int64, max: int64): int64 := min(max(value, min), max);
			static clamp(value: uint32, min: uint32, max: uint32): uint32 := min(max(value, min), max);
			static clamp(value: uint64, min: uint64, max: uint64): uint64 := min(max(value, min), max);
			static clamp(value: float32, min: float32, max: float32): float32 := min(max(value, min), max);
			static clamp(value: float64, min: float64, max: float64): float64 := min(max(value, min), max);
			static mix(a: float32, b: float32, t: float32): float32 := a + t * (b - a);
			static mix(a: float64, b: float64, t: float64): float64 := a + t * (b - a);
			static smoothstep(t: float32): float32 := t * t * ((3) - (2) * t);
			static smoothstep(min: float32, max: float32, t: float32): float32 := smoothstep(clamp((t - min) / (max - min), 0.000000, 1.000000));
			static smoothstep(t: float64): float64 := t * t * ((3) - (2) * t);
			static smoothstep(min: float64, max: float64, t: float64): float64 := smoothstep(clamp((t - min) / (max - min), 0.000000, 1.000000));
			static min(values: float64[]): float64 := {
				if (values.length == (0)) {
					return .result := nan;
				}
				result: float64 := values[0];
				for (i: int32 := 1; i < (values.length); i := i + 1) {
					if (result > values[i]) {
						result := values[i];
					}
				}
				return .result := result;
			};
			static max(values: float64[]): float64 := {
				if (values.length == (0)) {
					return .result := nan;
				}
				result: float64 := values[0];
				for (i: int32 := 1; i < (values.length); i := i + 1) {
					if (result < values[i]) {
						result := values[i];
					}
				}
				return .result := result;
			};
			static sum(values: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; i < (values.length); i := i + 1) {
					result := result + values[i];
				}
				return .result := result;
			};
			static mean(values: float64[]): float64 := {
				return .result := sum(...values) / (Bits.signed(values.length));
			};
			static eval(x: float64, a0: float64): float64 := a0;
			static eval(x: float64, a0: float64, a1: float64): float64 := a0 + x * a1;
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := a0 + x * eval(x, a1, a2);
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := a0 + x * eval(x, a1, a2, a3);
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64, a4: float64): float64 := a0 + x * eval(x, a1, a2, a3, a4);
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64, a4: float64, a5: float64): float64 := a0 + x * eval(x, a1, a2, a3, a4, a5);
			static eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
					result := result * x + polynomial[i];
				}
				return .result := result;
			};
			static modf(x: float64, intPart: float64): float64 := {
				if (x < (1)) {
					if (x < (0)) {
						result: float64 := modf(-x, &intPart);
						intPart := -intPart;
						return .result := -result;
					}
					intPart := (0);
					return .result := x;
				}
				result: float64 := x % (1);
				intPart := x - result;
				return .result := result;
			};
			static copysign(x: float64, y: float64): float64 := {
				sign: uint64 := Bits.fromFloat64(y) & (1 << 63);
				val: uint64 := Bits.fromFloat64(x) & ~(1 << 63);
				return .result := Bits.asFloat64(sign | val);
			};
			static frexp(f: float64, exp: int32): float64 := {
				mask: typename := 2047;
				shift: typename := 64 - 11 - 1;
				bias: typename := 1023;
				signMask: typename := 1 << 63;
				fracMask: typename := 1 << shift - 1;
				if (f == (0)) {
					exp := 0;
					return .result := f;
				}
				if (isInf(f) || isNan(f)) {
					exp := 0;
					return .result := f;
				}
				if (abs(f) < smallestNormal) {
					f := f * (1 << 52);
					exp := exp - 52;
				}
				else {
					exp := 0;
				}
				x: uint64 := Bits.fromFloat64(f);
				exp := exp + int32((x >> shift) & mask) - bias + 1;
				x := x & ~(mask << shift);
				x := x | (-1 + (bias)) << shift;
				return .result := Bits.asFloat64(x);
			};
			static ldexp(f: float64, exp: int32): float64 := {
				mask: typename := 2047;
				shift: typename := 64 - 11 - 1;
				bias: typename := 1023;
				signMask: typename := 1 << 63;
				fracMask: typename := 1 << shift - 1;
				if (f == (0)) {
					return .result := f;
				}
				if (f != f || f - f != (0)) {
					return .result := f;
				}
				if (abs(f) < smallestNormal) {
					f := f * (1 << 52);
					exp := exp - 52;
				}
				x: uint64 := Bits.fromFloat64(f);
				exp := ((exp) + ((int32(x >> shift)) & mask) - (bias));
				if (exp < -1075) {
					return .result := copysign(0.000000, f);
				}
				if (exp > 1023) {
					return .result := copysign(inf, f);
				}
				m: float64 := 1;
				if (exp < -1022) {
					exp := exp + 53;
					m := (1) / float64(1 << 53);
				}
				x := x & ~(mask << shift);
				x := x | uint64(exp + bias) << shift;
				return .result := m * Bits.asFloat64(x);
			};
			static log(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.log)) != null) {
					return .result := float64.log(x);
				}
				if (x <= (0)) {
					if (x == (0)) {
						return .result := -inf;
					}
					return .result := nan;
				}
				exp: int32;
				x := frexp(x, &exp);
				for ( ; x < 0.500000; ) {
					x := x * (2);
					exp := exp - 1;
				}
				if (x < sqrto2) {
					x := x * (2);
					exp := exp - 1;
				}
				z: float64 := (x - (1)) / (x + (1));
				zsq: float64 := z * z;
				p: float64 := eval(zsq, p0, p1, p2, p3);
				q: float64 := eval(zsq, q0, q1, q2 + zsq);
				return .result := p / q * z + (exp) * log2;
			};
			static log(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.log)) != null) {
					return .result := float32.log(x);
				}
				return .result := float32(log(float64(x)));
			};
			static log2(x: float64): float64 := log(x) / ln2;
			static log10(x: float64): float64 := log(x) / ln10;
			static log(x: float64, base: float64): float64 := log(x) / log(base);
			static exp(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.exp)) != null) {
					return .result := float64.exp(x);
				}
				if (isNan(x)) {
					return .result := x;
				}
				if (x > MAXLOG) {
					return .result := inf;
				}
				if (x < MINLOG) {
					return .result := 0;
				}
				px: float64 := floor(LOG2E * x + 0.500000);
				x := x - px * c1;
				x := x - px * c2;
				xx: float64 := x * x;
				p: float64 := x * eval(xx, p2, p1, p0);
				q: float64 := eval(xx, q3, q2, q1, q0);
				return .result := ldexp((1) + (2) * p / (q - p), px);
			};
			static exp(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.exp)) != null) {
					return .result := float32.exp(x);
				}
				return .result := float32(exp(float64(x)));
			};
			static sqrt(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.sqrt)) != null) {
					return .result := float64.sqrt(x);
				}
				if (x == (0) || isNan(x) || isInf(x, 1)) {
					return .result := x;
				}
				if (x < (0)) {
					return .result := nan;
				}
				mask: typename := 2047;
				shift: typename := 64 - 11 - 1;
				bias: typename := 1023;
				ix: uint64 := Bits.fromFloat64(x);
				exp: int32 := int32((ix >> shift) & mask);
				if (exp == 0) {
					for ( ; (ix & (1 << shift)) == (0); ) {
						ix := ix << 1;
						exp := exp - 1;
					}
					exp := exp + 1;
				}
				exp := exp - bias;
				ix := ix & ~(mask << shift);
				ix := ix | 1 << shift;
				if ((exp & 1) == 1) {
					ix := ix << 1;
				}
				exp := exp >> 1;
				ix := ix << 1;
				s: uint64 := 0;
				q: uint64 := 0;
				r: uint64 := 1 << (shift + 1);
				for ( ; r != (0); ) {
					t: uint64 := s + r;
					if (t <= ix) {
						s := t + r;
						ix := ix - t;
						q := q + r;
					}
					ix := ix << 1;
					r := r >> 1;
				}
				if (ix != (0)) {
					q := q + (q & (1));
				}
				ix := (q >> 1) + (uint64(exp - 1 + bias) << shift);
				return .result := Bits.asFloat64(ix);
			};
			static sqrt(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.sqrt)) != null) {
					return .result := float32.sqrt(x);
				}
				return .result := float32(sqrt(float64(x)));
			};
			static pow(x: float64, y: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.pow)) != null) {
					return .result := float64.pow(x, y);
				}
				if (y == (0)) {
					return .result := 1;
				}
				flip: int32 := 0;
				if (y < (0)) {
					y := -y;
					flip := 1;
				}
				ye: float64;
				xy: float64 := 1;
				y1: float64 := modf(y, &ye);
				if (y1 != 0.000000) {
					if (x <= 0.000000) {
						if (x == (0) && !(flip)) {
							return .result := 0;
						}
						return .result := nan;
					}
					if (y1 > 0.500000) {
						y1 := y1 - (1);
						ye := ye + (1);
					}
					xy := exp(y1 * log(x));
				}
				if (ye > (2147483647)) {
					if (x <= (0)) {
						if (x == (0) && !(flip)) {
							return .result := 0;
						}
						return .result := nan;
					}
					if (flip) {
						if (y == 0.500000) {
							return .result := (1) / sqrt(x);
						}
						y := -y;
					}
					else if (y == 0.500000) {
						return .result := sqrt(x);
					}
					return .result := exp(y * log(x));
				}
				ex: int32;
				x := frexp(x, &ex);
				ey: int32 := 0;
				i: int64 := ye;
				if (i) {
					for ( ; ; ) {
						if (i & (1)) {
							xy := xy * x;
							ey := ey + ex;
						}
						i := i >> 1;
						if (i == (0)) {
							break;
						}
						x := x * x;
						ex := ex << 1;
						if (x < 0.500000) {
							x := x + x;
							ex := ex - 1;
						}
					}
				}
				if (flip) {
					xy := 1.000000 / xy;
					ey := -ey;
				}
				return .result := ldexp(xy, ey);
			};
			static pow(x: float32, y: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.pow)) != null) {
					return .result := float32.pow(x, y);
				}
				return .result := float32(pow(float64(x), float64(y)));
			};
			static sincos(x: float64, quad: int32): float64 := {
				if (x < (0)) {
					x := -x;
					quad := quad + 2;
				}
				y: float64;
				x := x * (2) / pi;
				if (x > (32764)) {
					e: float64;
					y := modf(x, &e);
					e := e + (quad);
					f: float64;
					modf(0.250000 * e, &f);
					quad := (e - (4) * f);
				}
				else {
					k: int32 := x;
					y := x - (k);
					quad := quad + k;
					quad := quad & 3;
				}
				if (quad & 1) {
					y := (1) - y;
				}
				if (quad > 1) {
					y := -y;
				}
				ysq: float64 := y * y;
				p: float64 := y * eval(ysq, p0, p1, p2, p3, p4);
				q: float64 := eval(ysq, q0, q1, q2, q3 + ysq);
				return .result := p / q;
			};
			static tancot(x: float64, flag: int32): float64 := {
				sign: float64 := 1;
				if (x < (0)) {
					x := -x;
					sign := (-1);
				}
				if (x > lossth) {
					return .result := 0;
				}
				y: float64 := floor(x / (pi / (4)));
				z: float64 := ldexp(y, -3);
				z := floor(z);
				z := y - ldexp(z, 3);
				j: int32 := z;
				if (j & 1) {
					j := j + 1;
					y := y + 1.000000;
				}
				z := ((x - y * dp1) - y * dp2) - y * dp3;
				zz: float64 := z * z;
				if (zz > 0.000000) {
					y := z + z * (zz * eval(zz, p2, p1, p0) / eval(zz, q4, q3, q2, q1, q0));
				}
				else {
					y := z;
				}
				if (j & 2) {
					if (flag) {
						y := -y;
					}
					else {
						y := (-1) / y;
					}
				}
				else if (flag) {
					y := (1) / y;
				}
				return .result := sign * y;
			};
			static atan(x: float64): float64 := {
				static xatan(x: float64): float64 := {
					z: float64 := x * x;
					p: float64 := eval(z, p0, p1, p2, p3, p4);
					q: float64 := eval(z, q0, q1, q2, q3, q4 + z);
					return .result := p / q * x;
				};
				static satan(x: float64): float64 := {
					if (x < sq2m1) {
						return .result := xatan(x);
					}
					if (x > sq2p1) {
						return .result := pi / (2) - xatan((1) / x);
					}
					return .result := pi / (4) + xatan((x - (1)) / (x + (1)));
				};
				if (x > (0)) {
					return .result := satan(x);
				}
				return .result := -satan(-x);
			};
			static atan2(arg1: float64, arg2: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.atan2)) != null) {
					return .result := float64.atan2(arg1, arg2);
				}
				if (arg1 + arg2 == arg1) {
					if (arg1 >= (0)) {
						return .result := pi / (2);
					}
					return .result := -pi / (2);
				}
				arg1 := atan(arg1 / arg2);
				if (arg2 < (0)) {
					if (arg1 <= (0)) {
						return .result := arg1 + pi;
					}
					return .result := arg1 - pi;
				}
				return .result := arg1;
			};
			static atan2(y: float32, x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.atan2)) != null) {
					return .result := float32.atan2(y, x);
				}
				return .result := float32(atan2(float64(y), float64(x)));
			};
			static sin(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.sin)) != null) {
					return .result := float64.sin(x);
				}
				return .result := sincos(x, 0);
			};
			static sin(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.sin)) != null) {
					return .result := float32.sin(x);
				}
				return .result := float32(sin(float64(x)));
			};
			static sinh(x: float64): float64 := x == (0) ? (0) : (exp(x) - exp(-x)) / (2);
			static asin(x: float64): float64 := atan2(x, sqrt(((1) + x) * ((1) - x)));
			static asinh(x: float64): float64 := log(x + sqrt((x * x) + (1)));
			static cos(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.cos)) != null) {
					return .result := float64.cos(x);
				}
				if (x < (0)) {
					x := -x;
				}
				return .result := sincos(x, 1);
			};
			static cos(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.cos)) != null) {
					return .result := float32.cos(x);
				}
				return .result := float32(cos(float64(x)));
			};
			static cosh(x: float64): float64 := x == (0) ? (1) : (exp(x) + exp(-x)) / (2);
			static acos(x: float64): float64 := atan2(sqrt(((1) + x) * ((1) - x)), x);
			static acosh(x: float64): float64 := log(x + sqrt(x * x - (1)));
			static tan(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.tan)) != null) {
					return .result := float64.tan(x);
				}
				if (x == (0)) {
					return .result := x;
				}
				if (x != x) {
					return .result := x;
				}
				if (x == (2) * x) {
					return .result := nan;
				}
				return .result := tancot(x, 0);
			};
			static tan(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.tan)) != null) {
					return .result := float32.tan(x);
				}
				return .result := float32(tan(float64(x)));
			};
			static tanh(x: float64): float64 := (1) - (2) / (exp((2) * x) + (1));
			static atanh(x: float64): float64 := x >= (1) ? inf : x <= (-1) ? -inf : 0.500000 * log(((1) + x) / ((1) - x));
			static cot(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.cot)) != null) {
					return .result := float64.cot(x);
				}
				if (x == (0)) {
					return .result := inf;
				}
				return .result := tancot(x, 1);
			};
			static coth(x: float64): float64 := (1) / tanh(x);
			static acot(x: float64): float64 := x == (0) ? pi / (2) : atan((1) / x);
			static acoth(x: float64): float64 := x == (1) ? inf : x == (-1) ? -inf : 0.500000 * log((x + (1)) / (x - (1)));
			static sec(x: float64): float64 := (1) / cos(x);
			static sech(x: float64): float64 := (1) / cosh(x);
			static asec(x: float64): float64 := x == (0) ? inf : acos((1) / x);
			static asech(x: float64): float64 := x == (0) ? inf : x == (1) ? (0) : log((sqrt((1) - x * x) + (1)) / x);
			static csc(x: float64): float64 := (1) / sin(x);
			static csch(x: float64): float64 := (1) / sinh(x);
			static acsc(x: float64): float64 := x == (0) ? inf : asin((1) / x);
			static acsch(x: float64): float64 := x == (0) ? inf : x < (0) ? log(((1) - sqrt((1) + x * x)) / x) : log(((1) + sqrt((1) + x * x)) / x);
			static radians(degrees: float64): float64 := float64(degrees * pi / (180));
			static degrees(radians: float64): float64 := float64(radians * (180) / pi);
		};
		static const Fixed: struct {
			value: int32 := 0;
			static const precision: int32 := 20;
			static const one: int32 := 1048576;
			static const nan: int32 := (2147483648);
			static const inf: int32 := 2147483647;
			static const half: int32 := 524288;
			static const mask: int32 := 1048575;
			static const pow2max: int32 := 11534336;
			static const mpi_28: int32 := 843314856;
			static const ln2_28: int32 := 186065279;
			static const lg2_28: int32 := 80807124;
			static const l2e_28: int32 := 387270501;
			static const l2t_28: int32 := 891723282;
			static const d2r_28: int32 := 4685082;
			static const r2d_24: int32 := 961263668;
			static const piMul2: int32 := 6588397;
			static const piDiv2: int32 := 1647099;
			static const pi: int32 := 3294198;
			static const ln2: int32 := 726817;
			static const lg2: int32 := 315652;
			static const l2e: int32 := 1512775;
			static const l2t: int32 := 3483294;
			static as(value: int32): Fixed := {
				return .result := {
			.result.value := value;
		};
			};
			static neg(a: Fixed): Fixed := {
				return .result := {
			.result.value := -a.value;
		};
			};
			static add(a: Fixed, b: Fixed): Fixed := {
				return .result := {
			.result.value := a.value + b.value;
		};
			};
			static sub(a: Fixed, b: Fixed): Fixed := {
				return .result := {
			.result.value := a.value - b.value;
		};
			};
			static mul(a: Fixed, b: Fixed): Fixed := {
				return .result := {
			.result.value := ((int64(a.value) * (b.value)) >> precision);
		};
			};
			static mul(a: Fixed, b: int32): Fixed := {
				return .result := {
			.result.value := a.value * b;
		};
			};
			static mul_28(a: Fixed, b: int32): Fixed := {
				return .result := {
			.result.value := (int64(a.value) * (b) >> 28);
		};
			};
			static div(a: Fixed, b: Fixed): Fixed := {
				if (b.value == 0) {
					if (a.value == 0) {
						return .result := as(nan);
					}
					return .result := as(a.value < 0 ? -inf : inf);
				}
				return .result := {
			.result.value := ((int64(a.value) << precision) / (b.value));
		};
			};
			static div(a: Fixed, b: int32): Fixed := {
				return .result := {
			.result.value := a.value / b;
		};
			};
			static mod(a: Fixed, b: Fixed): Fixed := {
				return .result := {
			.result.value := a.value % b.value;
		};
			};
			static inv(x: Fixed): Fixed := {
				if (x.value == 0) {
					return .result := {
			.result.value := inf;
		};
				}
				value: int64 := (int64(one) << precision) / (x.value);
				if (value >> 31 != value >> 63) {
					return .result := {
			.result.value := value < (0) ? -inf : inf;
		};
				}
				return .result := {
			.result.value := (value);
		};
			};
			static fract(x: Fixed): Fixed := {
				if (x.value < 0) {
					return .result := {
			.result.value := -(-x.value & mask);
		};
				}
				return .result := {
			.result.value := x.value & (nan | mask);
		};
			};
			static floor(x: Fixed): Fixed := {
				return .result := {
			.result.value := x.value & ~mask;
		};
			};
			static ceil(x: Fixed): Fixed := {
				return .result := neg(floor(neg(x)));
			};
			static round(x: Fixed): Fixed := {
				return .result := floor(as(x.value + half));
			};
			static isFinite(x: Fixed): bool := {
				if (x.value == nan) {
					return .result := false;
				}
				if (x.value == inf) {
					return .result := false;
				}
				if (x.value == -inf) {
					return .result := false;
				}
				return .result := true;
			};
			static isNan(x: Fixed): bool := {
				return .result := x.value == nan;
			};
			static compare(a: Fixed, b: Fixed): int32 := {
				return .result := int32(a.value < b.value) - int32(a.value > b.value);
			};
			static log2(x: Fixed): Fixed := {
				static const tbl_log2: uint32[257] := {
					tbl_log2[0] := (0);
					tbl_log2[1] := (6039313);
					tbl_log2[2] := (12055173);
					tbl_log2[3] := (18047761);
					tbl_log2[4] := (24017256);
					tbl_log2[5] := (29963835);
					tbl_log2[6] := (35887674);
					tbl_log2[7] := (41788946);
					tbl_log2[8] := (47667822);
					tbl_log2[9] := (53524472);
					tbl_log2[10] := (59359063);
					tbl_log2[11] := (65171760);
					tbl_log2[12] := (70962727);
					tbl_log2[13] := (76732127);
					tbl_log2[14] := (82480119);
					tbl_log2[15] := (88206861);
					tbl_log2[16] := (93912510);
					tbl_log2[17] := (99597221);
					tbl_log2[18] := (105261147);
					tbl_log2[19] := (110904439);
					tbl_log2[20] := (116527248);
					tbl_log2[21] := (122129720);
					tbl_log2[22] := (127712004);
					tbl_log2[23] := (133274243);
					tbl_log2[24] := (138816582);
					tbl_log2[25] := (144339162);
					tbl_log2[26] := (149842123);
					tbl_log2[27] := (155325605);
					tbl_log2[28] := (160789745);
					tbl_log2[29] := (166234678);
					tbl_log2[30] := (171660540);
					tbl_log2[31] := (177067464);
					tbl_log2[32] := (182455580);
					tbl_log2[33] := (187825021);
					tbl_log2[34] := (193175914);
					tbl_log2[35] := (198508387);
					tbl_log2[36] := (203822568);
					tbl_log2[37] := (209118580);
					tbl_log2[38] := (214396547);
					tbl_log2[39] := (219656593);
					tbl_log2[40] := (224898838);
					tbl_log2[41] := (230123403);
					tbl_log2[42] := (235330406);
					tbl_log2[43] := (240519966);
					tbl_log2[44] := (245692198);
					tbl_log2[45] := (250847217);
					tbl_log2[46] := (255985139);
					tbl_log2[47] := (261106076);
					tbl_log2[48] := (266210140);
					tbl_log2[49] := (271297442);
					tbl_log2[50] := (276368091);
					tbl_log2[51] := (281422197);
					tbl_log2[52] := (286459866);
					tbl_log2[53] := (291481206);
					tbl_log2[54] := (296486322);
					tbl_log2[55] := (301475318);
					tbl_log2[56] := (306448299);
					tbl_log2[57] := (311405365);
					tbl_log2[58] := (316346620);
					tbl_log2[59] := (321272163);
					tbl_log2[60] := (326182094);
					tbl_log2[61] := (331076512);
					tbl_log2[62] := (335955515);
					tbl_log2[63] := (340819198);
					tbl_log2[64] := (345667659);
					tbl_log2[65] := (350500992);
					tbl_log2[66] := (355319292);
					tbl_log2[67] := (360122651);
					tbl_log2[68] := (364911161);
					tbl_log2[69] := (369684916);
					tbl_log2[70] := (374444004);
					tbl_log2[71] := (379188516);
					tbl_log2[72] := (383918541);
					tbl_log2[73] := (388634167);
					tbl_log2[74] := (393335482);
					tbl_log2[75] := (398022572);
					tbl_log2[76] := (402695523);
					tbl_log2[77] := (407354419);
					tbl_log2[78] := (411999346);
					tbl_log2[79] := (416630387);
					tbl_log2[80] := (421247625);
					tbl_log2[81] := (425851141);
					tbl_log2[82] := (430441017);
					tbl_log2[83] := (435017333);
					tbl_log2[84] := (439580170);
					tbl_log2[85] := (444129606);
					tbl_log2[86] := (448665721);
					tbl_log2[87] := (453188591);
					tbl_log2[88] := (457698295);
					tbl_log2[89] := (462194907);
					tbl_log2[90] := (466678505);
					tbl_log2[91] := (471149164);
					tbl_log2[92] := (475606957);
					tbl_log2[93] := (480051958);
					tbl_log2[94] := (484484242);
					tbl_log2[95] := (488903880);
					tbl_log2[96] := (493310944);
					tbl_log2[97] := (497705506);
					tbl_log2[98] := (502087636);
					tbl_log2[99] := (506457405);
					tbl_log2[100] := (510814881);
					tbl_log2[101] := (515160135);
					tbl_log2[102] := (519493235);
					tbl_log2[103] := (523814247);
					tbl_log2[104] := (528123240);
					tbl_log2[105] := (532420281);
					tbl_log2[106] := (536705434);
					tbl_log2[107] := (540978766);
					tbl_log2[108] := (545240343);
					tbl_log2[109] := (549490227);
					tbl_log2[110] := (553728484);
					tbl_log2[111] := (557955177);
					tbl_log2[112] := (562170369);
					tbl_log2[113] := (566374122);
					tbl_log2[114] := (570566498);
					tbl_log2[115] := (574747559);
					tbl_log2[116] := (578917365);
					tbl_log2[117] := (583075977);
					tbl_log2[118] := (587223454);
					tbl_log2[119] := (591359857);
					tbl_log2[120] := (595485245);
					tbl_log2[121] := (599599675);
					tbl_log2[122] := (603703206);
					tbl_log2[123] := (607795895);
					tbl_log2[124] := (611877800);
					tbl_log2[125] := (615948977);
					tbl_log2[126] := (620009483);
					tbl_log2[127] := (624059372);
					tbl_log2[128] := (628098702);
					tbl_log2[129] := (632127526);
					tbl_log2[130] := (636145899);
					tbl_log2[131] := (640153876);
					tbl_log2[132] := (644151509);
					tbl_log2[133] := (648138852);
					tbl_log2[134] := (652115958);
					tbl_log2[135] := (656082880);
					tbl_log2[136] := (660039669);
					tbl_log2[137] := (663986377);
					tbl_log2[138] := (667923055);
					tbl_log2[139] := (671849754);
					tbl_log2[140] := (675766525);
					tbl_log2[141] := (679673417);
					tbl_log2[142] := (683570481);
					tbl_log2[143] := (687457765);
					tbl_log2[144] := (691335319);
					tbl_log2[145] := (695203191);
					tbl_log2[146] := (699061430);
					tbl_log2[147] := (702910083);
					tbl_log2[148] := (706749198);
					tbl_log2[149] := (710578821);
					tbl_log2[150] := (714399001);
					tbl_log2[151] := (718209783);
					tbl_log2[152] := (722011213);
					tbl_log2[153] := (725803337);
					tbl_log2[154] := (729586201);
					tbl_log2[155] := (733359850);
					tbl_log2[156] := (737124328);
					tbl_log2[157] := (740879680);
					tbl_log2[158] := (744625950);
					tbl_log2[159] := (748363182);
					tbl_log2[160] := (752091420);
					tbl_log2[161] := (755810706);
					tbl_log2[162] := (759521084);
					tbl_log2[163] := (763222596);
					tbl_log2[164] := (766915284);
					tbl_log2[165] := (770599191);
					tbl_log2[166] := (774274358);
					tbl_log2[167] := (777940826);
					tbl_log2[168] := (781598636);
					tbl_log2[169] := (785247830);
					tbl_log2[170] := (788888447);
					tbl_log2[171] := (792520529);
					tbl_log2[172] := (796144114);
					tbl_log2[173] := (799759243);
					tbl_log2[174] := (803365955);
					tbl_log2[175] := (806964288);
					tbl_log2[176] := (810554283);
					tbl_log2[177] := (814135977);
					tbl_log2[178] := (817709409);
					tbl_log2[179] := (821274616);
					tbl_log2[180] := (824831638);
					tbl_log2[181] := (828380510);
					tbl_log2[182] := (831921270);
					tbl_log2[183] := (835453956);
					tbl_log2[184] := (838978604);
					tbl_log2[185] := (842495250);
					tbl_log2[186] := (846003931);
					tbl_log2[187] := (849504683);
					tbl_log2[188] := (852997541);
					tbl_log2[189] := (856482541);
					tbl_log2[190] := (859959719);
					tbl_log2[191] := (863429109);
					tbl_log2[192] := (866890746);
					tbl_log2[193] := (870344665);
					tbl_log2[194] := (873790900);
					tbl_log2[195] := (877229485);
					tbl_log2[196] := (880660455);
					tbl_log2[197] := (884083842);
					tbl_log2[198] := (887499680);
					tbl_log2[199] := (890908002);
					tbl_log2[200] := (894308843);
					tbl_log2[201] := (897702233);
					tbl_log2[202] := (901088206);
					tbl_log2[203] := (904466794);
					tbl_log2[204] := (907838029);
					tbl_log2[205] := (911201943);
					tbl_log2[206] := (914558569);
					tbl_log2[207] := (917907937);
					tbl_log2[208] := (921250078);
					tbl_log2[209] := (924585025);
					tbl_log2[210] := (927912807);
					tbl_log2[211] := (931233455);
					tbl_log2[212] := (934547001);
					tbl_log2[213] := (937853474);
					tbl_log2[214] := (941152904);
					tbl_log2[215] := (944445322);
					tbl_log2[216] := (947730757);
					tbl_log2[217] := (951009239);
					tbl_log2[218] := (954280797);
					tbl_log2[219] := (957545460);
					tbl_log2[220] := (960803257);
					tbl_log2[221] := (964054217);
					tbl_log2[222] := (967298369);
					tbl_log2[223] := (970535741);
					tbl_log2[224] := (973766362);
					tbl_log2[225] := (976990259);
					tbl_log2[226] := (980207460);
					tbl_log2[227] := (983417994);
					tbl_log2[228] := (986621888);
					tbl_log2[229] := (989819169);
					tbl_log2[230] := (993009864);
					tbl_log2[231] := (996194001);
					tbl_log2[232] := (999371606);
					tbl_log2[233] := (1002542706);
					tbl_log2[234] := (1005707329);
					tbl_log2[235] := (1008865499);
					tbl_log2[236] := (1012017244);
					tbl_log2[237] := (1015162589);
					tbl_log2[238] := (1018301561);
					tbl_log2[239] := (1021434184);
					tbl_log2[240] := (1024560486);
					tbl_log2[241] := (1027680491);
					tbl_log2[242] := (1030794225);
					tbl_log2[243] := (1033901713);
					tbl_log2[244] := (1037002979);
					tbl_log2[245] := (1040098049);
					tbl_log2[246] := (1043186947);
					tbl_log2[247] := (1046269698);
					tbl_log2[248] := (1049346327);
					tbl_log2[249] := (1052416857);
					tbl_log2[250] := (1055481313);
					tbl_log2[251] := (1058539719);
					tbl_log2[252] := (1061592098);
					tbl_log2[253] := (1064638475);
					tbl_log2[254] := (1067678872);
					tbl_log2[255] := (1070713314);
					tbl_log2[256] := (1073741824);
				};
				if (x.value <= 0) {
					if (x.value == 0) {
						return .result := {
			.result.value := -inf;
		};
					}
					return .result := {
			.result.value := nan;
		};
				}
				n: int32 := Bits.scanReverse(x.value);
				static if (precision < 8) {
					error_not_implemented_yet
				}
				idx: uint32 := (n > 8 ? x.value >> n - 8 : x.value << 8 - n) & 255;
				value: int32 := tbl_log2[idx];
				static if (precision > 8) {
					mix: uint32 := (n > 16 ? x.value >> n - 16 : x.value << 16 - n) & 255;
					value := value + (mix * (tbl_log2[idx + (1)] - (value)) >> 8);
				}
				return .result := {
			.result.value := (n - precision << precision) + (value >> 30 - precision);
		};
			};
			static log(x: Fixed): Fixed := {
				x := log2(x);
				if (!isFinite(x)) {
					return .result := x;
				}
				return .result := mul_28(x, ln2_28);
			};
			static log10(x: Fixed): Fixed := {
				x := log2(x);
				if (!isFinite(x)) {
					return .result := x;
				}
				return .result := mul_28(x, lg2_28);
			};
			static log(x: Fixed, base: Fixed): Fixed := {
				x := log2(x);
				if (!isFinite(x)) {
					return .result := x;
				}
				base := log2(base);
				if (!isFinite(base)) {
					return .result := base;
				}
				return .result := div(x, base);
			};
			static pow2(x: Fixed): Fixed := {
				static const tbl_pow2: uint32[257] := {
					tbl_pow2[0] := (1073741824);
					tbl_pow2[1] := (1076653033);
					tbl_pow2[2] := (1079572135);
					tbl_pow2[3] := (1082499152);
					tbl_pow2[4] := (1085434105);
					tbl_pow2[5] := (1088377016);
					tbl_pow2[6] := (1091327905);
					tbl_pow2[7] := (1094286795);
					tbl_pow2[8] := (1097253708);
					tbl_pow2[9] := (1100228664);
					tbl_pow2[10] := (1103211687);
					tbl_pow2[11] := (1106202797);
					tbl_pow2[12] := (1109202017);
					tbl_pow2[13] := (1112209369);
					tbl_pow2[14] := (1115224875);
					tbl_pow2[15] := (1118248556);
					tbl_pow2[16] := (1121280435);
					tbl_pow2[17] := (1124320535);
					tbl_pow2[18] := (1127368877);
					tbl_pow2[19] := (1130425484);
					tbl_pow2[20] := (1133490379);
					tbl_pow2[21] := (1136563583);
					tbl_pow2[22] := (1139645119);
					tbl_pow2[23] := (1142735011);
					tbl_pow2[24] := (1145833280);
					tbl_pow2[25] := (1148939949);
					tbl_pow2[26] := (1152055041);
					tbl_pow2[27] := (1155178579);
					tbl_pow2[28] := (1158310586);
					tbl_pow2[29] := (1161451085);
					tbl_pow2[30] := (1164600098);
					tbl_pow2[31] := (1167757649);
					tbl_pow2[32] := (1170923761);
					tbl_pow2[33] := (1174098458);
					tbl_pow2[34] := (1177281762);
					tbl_pow2[35] := (1180473696);
					tbl_pow2[36] := (1183674285);
					tbl_pow2[37] := (1186883552);
					tbl_pow2[38] := (1190101520);
					tbl_pow2[39] := (1193328212);
					tbl_pow2[40] := (1196563653);
					tbl_pow2[41] := (1199807866);
					tbl_pow2[42] := (1203060875);
					tbl_pow2[43] := (1206322704);
					tbl_pow2[44] := (1209593377);
					tbl_pow2[45] := (1212872917);
					tbl_pow2[46] := (1216161349);
					tbl_pow2[47] := (1219458697);
					tbl_pow2[48] := (1222764985);
					tbl_pow2[49] := (1226080238);
					tbl_pow2[50] := (1229404478);
					tbl_pow2[51] := (1232737732);
					tbl_pow2[52] := (1236080023);
					tbl_pow2[53] := (1239431376);
					tbl_pow2[54] := (1242791815);
					tbl_pow2[55] := (1246161366);
					tbl_pow2[56] := (1249540052);
					tbl_pow2[57] := (1252927899);
					tbl_pow2[58] := (1256324931);
					tbl_pow2[59] := (1259731173);
					tbl_pow2[60] := (1263146651);
					tbl_pow2[61] := (1266571389);
					tbl_pow2[62] := (1270005412);
					tbl_pow2[63] := (1273448746);
					tbl_pow2[64] := (1276901416);
					tbl_pow2[65] := (1280363447);
					tbl_pow2[66] := (1283834865);
					tbl_pow2[67] := (1287315694);
					tbl_pow2[68] := (1290805961);
					tbl_pow2[69] := (1294305691);
					tbl_pow2[70] := (1297814910);
					tbl_pow2[71] := (1301333643);
					tbl_pow2[72] := (1304861916);
					tbl_pow2[73] := (1308399756);
					tbl_pow2[74] := (1311947188);
					tbl_pow2[75] := (1315504237);
					tbl_pow2[76] := (1319070931);
					tbl_pow2[77] := (1322647295);
					tbl_pow2[78] := (1326233356);
					tbl_pow2[79] := (1329829139);
					tbl_pow2[80] := (1333434672);
					tbl_pow2[81] := (1337049980);
					tbl_pow2[82] := (1340675090);
					tbl_pow2[83] := (1344310029);
					tbl_pow2[84] := (1347954823);
					tbl_pow2[85] := (1351609500);
					tbl_pow2[86] := (1355274085);
					tbl_pow2[87] := (1358948606);
					tbl_pow2[88] := (1362633089);
					tbl_pow2[89] := (1366327562);
					tbl_pow2[90] := (1370032052);
					tbl_pow2[91] := (1373746586);
					tbl_pow2[92] := (1377471191);
					tbl_pow2[93] := (1381205894);
					tbl_pow2[94] := (1384950723);
					tbl_pow2[95] := (1388705705);
					tbl_pow2[96] := (1392470868);
					tbl_pow2[97] := (1396246240);
					tbl_pow2[98] := (1400031847);
					tbl_pow2[99] := (1403827719);
					tbl_pow2[100] := (1407633882);
					tbl_pow2[101] := (1411450365);
					tbl_pow2[102] := (1415277195);
					tbl_pow2[103] := (1419114400);
					tbl_pow2[104] := (1422962010);
					tbl_pow2[105] := (1426820051);
					tbl_pow2[106] := (1430688553);
					tbl_pow2[107] := (1434567543);
					tbl_pow2[108] := (1438457050);
					tbl_pow2[109] := (1442357103);
					tbl_pow2[110] := (1446267730);
					tbl_pow2[111] := (1450188959);
					tbl_pow2[112] := (1454120821);
					tbl_pow2[113] := (1458063342);
					tbl_pow2[114] := (1462016553);
					tbl_pow2[115] := (1465980482);
					tbl_pow2[116] := (1469955158);
					tbl_pow2[117] := (1473940611);
					tbl_pow2[118] := (1477936869);
					tbl_pow2[119] := (1481943963);
					tbl_pow2[120] := (1485961920);
					tbl_pow2[121] := (1489990772);
					tbl_pow2[122] := (1494030547);
					tbl_pow2[123] := (1498081274);
					tbl_pow2[124] := (1502142985);
					tbl_pow2[125] := (1506215708);
					tbl_pow2[126] := (1510299473);
					tbl_pow2[127] := (1514394310);
					tbl_pow2[128] := (1518500249);
					tbl_pow2[129] := (1522617321);
					tbl_pow2[130] := (1526745556);
					tbl_pow2[131] := (1530884983);
					tbl_pow2[132] := (1535035633);
					tbl_pow2[133] := (1539197537);
					tbl_pow2[134] := (1543370725);
					tbl_pow2[135] := (1547555227);
					tbl_pow2[136] := (1551751075);
					tbl_pow2[137] := (1555958299);
					tbl_pow2[138] := (1560176930);
					tbl_pow2[139] := (1564406999);
					tbl_pow2[140] := (1568648537);
					tbl_pow2[141] := (1572901574);
					tbl_pow2[142] := (1577166143);
					tbl_pow2[143] := (1581442274);
					tbl_pow2[144] := (1585729999);
					tbl_pow2[145] := (1590029349);
					tbl_pow2[146] := (1594340356);
					tbl_pow2[147] := (1598663051);
					tbl_pow2[148] := (1602997467);
					tbl_pow2[149] := (1607343634);
					tbl_pow2[150] := (1611701584);
					tbl_pow2[151] := (1616071351);
					tbl_pow2[152] := (1620452965);
					tbl_pow2[153] := (1624846458);
					tbl_pow2[154] := (1629251864);
					tbl_pow2[155] := (1633669214);
					tbl_pow2[156] := (1638098541);
					tbl_pow2[157] := (1642539876);
					tbl_pow2[158] := (1646993254);
					tbl_pow2[159] := (1651458705);
					tbl_pow2[160] := (1655936264);
					tbl_pow2[161] := (1660425963);
					tbl_pow2[162] := (1664927834);
					tbl_pow2[163] := (1669441912);
					tbl_pow2[164] := (1673968228);
					tbl_pow2[165] := (1678506816);
					tbl_pow2[166] := (1683057710);
					tbl_pow2[167] := (1687620942);
					tbl_pow2[168] := (1692196547);
					tbl_pow2[169] := (1696784557);
					tbl_pow2[170] := (1701385007);
					tbl_pow2[171] := (1705997929);
					tbl_pow2[172] := (1710623359);
					tbl_pow2[173] := (1715261329);
					tbl_pow2[174] := (1719911875);
					tbl_pow2[175] := (1724575029);
					tbl_pow2[176] := (1729250826);
					tbl_pow2[177] := (1733939301);
					tbl_pow2[178] := (1738640487);
					tbl_pow2[179] := (1743354420);
					tbl_pow2[180] := (1748081133);
					tbl_pow2[181] := (1752820662);
					tbl_pow2[182] := (1757573041);
					tbl_pow2[183] := (1762338305);
					tbl_pow2[184] := (1767116488);
					tbl_pow2[185] := (1771907627);
					tbl_pow2[186] := (1776711756);
					tbl_pow2[187] := (1781528911);
					tbl_pow2[188] := (1786359125);
					tbl_pow2[189] := (1791202436);
					tbl_pow2[190] := (1796058879);
					tbl_pow2[191] := (1800928488);
					tbl_pow2[192] := (1805811301);
					tbl_pow2[193] := (1810707352);
					tbl_pow2[194] := (1815616678);
					tbl_pow2[195] := (1820539314);
					tbl_pow2[196] := (1825475297);
					tbl_pow2[197] := (1830424662);
					tbl_pow2[198] := (1835387447);
					tbl_pow2[199] := (1840363687);
					tbl_pow2[200] := (1845353419);
					tbl_pow2[201] := (1850356680);
					tbl_pow2[202] := (1855373506);
					tbl_pow2[203] := (1860403934);
					tbl_pow2[204] := (1865448001);
					tbl_pow2[205] := (1870505743);
					tbl_pow2[206] := (1875577199);
					tbl_pow2[207] := (1880662405);
					tbl_pow2[208] := (1885761398);
					tbl_pow2[209] := (1890874215);
					tbl_pow2[210] := (1896000895);
					tbl_pow2[211] := (1901141475);
					tbl_pow2[212] := (1906295993);
					tbl_pow2[213] := (1911464486);
					tbl_pow2[214] := (1916646992);
					tbl_pow2[215] := (1921843549);
					tbl_pow2[216] := (1927054195);
					tbl_pow2[217] := (1932278969);
					tbl_pow2[218] := (1937517909);
					tbl_pow2[219] := (1942771053);
					tbl_pow2[220] := (1948038440);
					tbl_pow2[221] := (1953320108);
					tbl_pow2[222] := (1958616096);
					tbl_pow2[223] := (1963926443);
					tbl_pow2[224] := (1969251187);
					tbl_pow2[225] := (1974590369);
					tbl_pow2[226] := (1979944027);
					tbl_pow2[227] := (1985312199);
					tbl_pow2[228] := (1990694927);
					tbl_pow2[229] := (1996092248);
					tbl_pow2[230] := (2001504204);
					tbl_pow2[231] := (2006930832);
					tbl_pow2[232] := (2012372173);
					tbl_pow2[233] := (2017828268);
					tbl_pow2[234] := (2023299155);
					tbl_pow2[235] := (2028784876);
					tbl_pow2[236] := (2034285470);
					tbl_pow2[237] := (2039800977);
					tbl_pow2[238] := (2045331439);
					tbl_pow2[239] := (2050876895);
					tbl_pow2[240] := (2056437386);
					tbl_pow2[241] := (2062012953);
					tbl_pow2[242] := (2067603638);
					tbl_pow2[243] := (2073209480);
					tbl_pow2[244] := (2078830521);
					tbl_pow2[245] := (2084466802);
					tbl_pow2[246] := (2090118365);
					tbl_pow2[247] := (2095785251);
					tbl_pow2[248] := (2101467501);
					tbl_pow2[249] := (2107165158);
					tbl_pow2[250] := (2112878262);
					tbl_pow2[251] := (2118606856);
					tbl_pow2[252] := (2124350982);
					tbl_pow2[253] := (2130110682);
					tbl_pow2[254] := (2135885998);
					tbl_pow2[255] := (2141676972);
					tbl_pow2[256] := (2147483648);
				};
				if (x.value > pow2max) {
					return .result := as(inf);
				}
				if (x.value <= -pow2max) {
					if (isNan(x)) {
						return .result := x;
					}
					return .result := as(0);
				}
				idx: uint32 := (x.value >> (precision - 8)) & 255;
				static if (precision < 8) {
					error_not_implemented_yet
				}
				q: uint32 := tbl_pow2[idx];
				static if (precision > 8) {
					mix: uint32 := (precision > 16 ? x.value >> (precision - 16) : x.value << (16 - precision)) & 255;
					q := q + (mix * (tbl_pow2[idx + (1)] - q) >> 8);
				}
				n: int32 := (x.value >> precision) - (30 - precision);
				return .result := as(n < 0 ? q >> -n : q << n);
			};
			static exp(x: Fixed): Fixed := {
				return .result := pow2(mul_28(x, l2e_28));
			};
			static exp10(x: Fixed): Fixed := {
				return .result := pow2(mul_28(x, l2t_28));
			};
			static sqrt(x: Fixed): Fixed := {
				if (x.value <= 0) {
					if (x.value < 0) {
						return .result := as(nan);
					}
					return .result := as(0);
				}
				static if ((precision & 1) != 0) {
					return .result := pow2(div(log2(x), 2));
				}
				root: uint32 := 0;
				remHi: uint32 := 0;
				remLo: uint32 := x.value;
				for (count: uint32 := 16 + (precision >> 1); count != (0); count := count - (1)) {
					remHi := (remHi << 2) | (remLo >> 30);
					remLo := remLo << 2;
					root := root << 1;
					testDiv: uint32 := (root << 1) + (1);
					if (remHi >= testDiv) {
						remHi := remHi - testDiv;
						root := root + (1);
					}
				}
				return .result := as(root);
			};
			static pow(x: Fixed, y: Fixed): Fixed := {
				if (y.value == 0 || x.value == one) {
					return .result := as(one);
				}
				if (y.value == one) {
					return .result := x;
				}
				if (y.value == half) {
					return .result := sqrt(x);
				}
				if (x.value == nan || y.value == nan) {
					return .result := as(nan);
				}
				if (x.value == 0) {
					if (y.value < 0) {
						return .result := as(inf);
					}
					return .result := as(0);
				}
				if ((y.value & mask) == 0) {
					res: int32 := one;
					sqr: int64 := x.value;
					pow: int32 := (y.value < 0 ? -y.value : y.value) >> precision;
					for ( ; pow != 0; ) {
						if ((pow & 1) != 0) {
							res := ((res) * sqr >> precision);
						}
						sqr := sqr * sqr >> precision;
						pow := pow >> 1;
					}
					return .result := y.value < 0 ? inv(as(res)) : as(res);
				}
				return .result := pow2(mul(y, log2(x)));
			};
			static horner(x: int32, a0: int32, a1: int32): int32 := a0 + int32((a1) * int64(x) >> precision);
			static horner(x: int32, a0: int32, a1: int32, a2: int32): int32 := horner(x, a0, horner(x, a1, a2));
			static horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32): int32 := horner(x, a0, horner(x, a1, a2, a3));
			static horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32, a4: int32): int32 := horner(x, a0, horner(x, a1, a2, a3, a4));
			static horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32, a4: int32, a5: int32): int32 := horner(x, a0, horner(x, a1, a2, a3, a4, a5));
			static sin(x: Fixed): Fixed := {
				x.value := x.value % piMul2;
				if (x.value < 0) {
					x.value := x.value + piMul2;
				}
				sign: int32 := 1;
				if (x.value >= pi) {
					x.value := x.value - pi;
					sign := -1;
				}
				if (x.value >= piDiv2) {
					x.value := pi - x.value;
				}
				xsq: int32 := int64(x.value) * (x.value) >> precision;
				res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5);
				return .result := mul(x, as(sign * res));
			};
			static sinh(x: Fixed): Fixed := {
				if (x.value == 0) {
					return .result := as(0);
				}
				if (!isFinite(x)) {
					return .result := x;
				}
				return .result := div(sub(exp(x), exp(neg(x))), 2);
			};
			static cos(x: Fixed): Fixed := {
				x.value := x.value % piMul2;
				if (x.value < 0) {
					x.value := x.value + piMul2;
				}
				if (x.value > pi) {
					x.value := piMul2 - x.value;
				}
				sign: int32 := 1;
				if (x.value >= piDiv2) {
					x.value := x.value - pi;
					sign := -1;
				}
				xsq: int32 := int64(x.value) * (x.value) >> precision;
				res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5);
				return .result := as(sign * res);
			};
			static tan(x: Fixed): Fixed := {
				return .result := div(sin(x), cos(x));
			};
			static degrees(radians: Fixed): Fixed := {
				return .result := as((radians.value) * int64(r2d_24) >> 24);
			};
			static radians(degrees: Fixed): Fixed := {
				return .result := mul_28(degrees, d2r_28);
			};
		};
		Fixed(value: int32): Fixed := Fixed.as(value << Fixed.precision);
		int32(const value: Fixed): int32 := value.value >> Fixed.precision;
		static Fixed(value: float64): Fixed := {
			result: Fixed := Fixed.as(value * ((1 << Fixed.precision)));
			if (result.value == Fixed.nan) {
				if (value != value) {
					result.value := Fixed.nan;
				}
				else if (value > (0)) {
					result.value := Fixed.inf;
				}
				else if (value < (0)) {
					result.value := -Fixed.inf;
				}
			}
			return .result := result;
		};
		static float64(value: Fixed): float64 := {
			if (value.value == Fixed.nan) {
				return .result := Math.nan;
			}
			if (value.value == Fixed.inf) {
				return .result := Math.inf;
			}
			if (value.value == -Fixed.inf) {
				return .result := -Math.inf;
			}
			return .result := (value.value) / float64(1 << Fixed.precision);
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static Complex(value: float64): Complex := {
			return .result := {
			.result.re := value;
			.result.im := (0);
		};
		};
		static Complex(real: float64, imaginary: float64): Complex := {
			return .result := {
			.result.re := real;
			.result.im := imaginary;
		};
		};
		neg(a: Complex): Complex := Complex(emit(struct(a), neg.p2d));
		add(a: Complex, b: Complex): Complex := Complex(emit(struct(a), struct(b), add.p2d));
		add(a: Complex, b: float64): Complex := Complex(a.re + b, a.im);
		add(a: float64, b: Complex): Complex := Complex(a + b.re, b.im);
		sub(a: Complex, b: Complex): Complex := Complex(emit(struct(a), struct(b), sub.p2d));
		sub(a: Complex, b: float64): Complex := Complex(a.re - b, a.im);
		sub(a: float64, b: Complex): Complex := Complex(a - b.re, b.im);
		mul(a: Complex, b: Complex): Complex := Complex(emit(struct(a), struct(b), swz.x2, mul.p2d, add.f64, struct(a), struct(b), mul.p2d, swz.x2, sub.f64));
		mul(a: Complex, b: float64): Complex := Complex(a.re * b, a.im * b);
		mul(a: float64, b: Complex): Complex := Complex(a * b.re, a * b.im);
		static div(a: Complex, b: Complex): Complex := {
			if (Math.abs(b.re) >= Math.abs(b.im)) {
				r: float64 := b.im / b.re;
				den: float64 := b.re + r * b.im;
				return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
			}
			r: float64 := b.re / b.im;
			den: float64 := b.im + r * b.re;
			return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
		};
		div(a: Complex, b: float64): Complex := div(a, Complex(b));
		div(a: float64, b: Complex): Complex := div(Complex(a), b);
		abs(a: Complex): float64 := Math.sqrt(a.re * a.re + a.im * a.im);
		arg(a: Complex): float64 := Math.atan2(a.re, a.im);
		static inv(a: Complex): Complex := {
			d: float64 := a.re * a.re + a.im * a.im;
			return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
		};
		conj(a: Complex): Complex := Complex(a.re, -a.im);
		exp(a: Complex): Complex := Complex(Math.exp(a.re) * Math.cos(a.im), Math.exp(a.re) * Math.sin(a.im));
		log(a: Complex): Complex := Complex(Math.log(abs(a)), arg(a));
		static pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := b.re * t + b.im * Math.log(r);
			v: float64 := Math.pow(r, b.re) * Math.exp(-b.im * t);
			return .result := {
			.result.re := v * Math.cos(u);
			.result.im := v * Math.sin(u);
		};
		};
		pow(a: Complex, b: float64): Complex := pow(a, Complex(b));
		sin(a: Complex): Complex := Complex(Math.sin(a.re) * Math.cosh(a.im), +Math.cos(a.re) * Math.sinh(a.im));
		cos(a: Complex): Complex := Complex(Math.cos(a.re) * Math.cosh(a.im), -Math.sin(a.re) * Math.sinh(a.im));
		tan(a: Complex): Complex := div(sin(a), cos(a));
		cot(a: Complex): Complex := div(cos(a), sin(a));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sinh(a: Complex): Complex := div(sub(exp(a), exp(neg(a))), 2);
		cosh(a: Complex): Complex := div(add(exp(a), exp(neg(a))), 2);
		tanh(a: Complex): Complex := div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
		coth(a: Complex): Complex := div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(x.re * Math.cos(x.im), x.re * Math.sin(x.im));
		toPolar(x: Complex): Complex := Complex(abs(x), arg(x));
		static const vec4f: struct {
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
			data: float32[4];
		};
		vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := vec4f(emit(struct(w), struct(z), struct(y), struct(x)));
		vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(x, y, z, 1.000000);
		vec4f(x: float32, y: float32): vec4f := vec4f(x, y, 0.000000, 1.000000);
		vec4f(xyz: vec4f, w: float32): vec4f := vec4f(xyz.x, xyz.y, xyz.z, w);
		vec4f(val: float32): vec4f := vec4f(val, val, val, val);
		neg(rhs: vec4f): vec4f := vec4f(emit(struct(rhs), neg.p4f));
		add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), add.p4f));
		sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
		mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
		div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), div.p4f));
		add(a: float32, b: vec4f): vec4f := add(vec4f(a), b);
		add(a: vec4f, b: float32): vec4f := add(a, vec4f(b));
		sub(a: float32, b: vec4f): vec4f := sub(vec4f(a), b);
		sub(a: vec4f, b: float32): vec4f := sub(a, vec4f(b));
		mul(a: float32, b: vec4f): vec4f := mul(vec4f(a), b);
		mul(a: vec4f, b: float32): vec4f := mul(a, vec4f(b));
		div(a: float32, b: vec4f): vec4f := div(vec4f(a), b);
		div(a: vec4f, b: float32): vec4f := div(a, vec4f(b));
		abs(a: vec4f): vec4f := vec4f(Math.abs(a.x), Math.abs(a.y), Math.abs(a.z), Math.abs(a.w));
		min(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), min.p4f));
		max(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), max.p4f));
		clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f := min(max(vec, min), max);
		clamp(vec: vec4f, min: float32, max: float32): vec4f := clamp(vec, vec4f(min), vec4f(max));
		mix(a: vec4f, b: vec4f, t: float32): vec4f := vec4f(Math.mix(a.x, b.x, t), Math.mix(a.y, b.y, t), Math.mix(a.z, b.z, t), Math.mix(a.w, b.w, t));
		dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dp3));
		dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dph));
		dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dp4));
		cross(const a: vec4f, const b: vec4f): vec4f := vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
		length(v: vec4f): float32 := Math.sqrt(dp3(v, v));
		normalize(const v: vec4f): vec4f := div(v, vec4f(length(v)));
		eval(const v: vec4f, x: float32): float32 := float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
		static const mat4f: struct {
			m: float32[4][4];
			data: float32[16];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return .result := {
			.result.xx := xx;
			.result.xy := xy;
			.result.xz := xz;
			.result.xw := xw;
			.result.yx := yx;
			.result.yy := yy;
			.result.yz := yz;
			.result.yw := yw;
			.result.zx := zx;
			.result.zy := zy;
			.result.zz := zz;
			.result.zw := zw;
			.result.wx := wx;
			.result.wy := wy;
			.result.wz := wz;
			.result.ww := ww;
		};
		};
		static mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
		};
		dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000);
		dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
		dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));
		static transpose(const mat: mat4f): mat4f := {
			return .result := {
			.result.xx := mat.xx;
			.result.xy := mat.yx;
			.result.xz := mat.zx;
			.result.xw := mat.wx;
			.result.yx := mat.xy;
			.result.yy := mat.yy;
			.result.yz := mat.zy;
			.result.yw := mat.wy;
			.result.zx := mat.xz;
			.result.zy := mat.yz;
			.result.zz := mat.zz;
			.result.zw := mat.wz;
			.result.wx := mat.xw;
			.result.wy := mat.yw;
			.result.wz := mat.zw;
			.result.ww := mat.ww;
		};
		};
		static mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := transpose(rhs);
			return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
		};
		static rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if ((len) < 0.000000) {
				trace("invalid direction of rotation", direction);
				return .result := {
			.result.x := vec4f(0, 0, 0, 0);
			.result.y := vec4f(0, 0, 0, 0);
			.result.z := vec4f(0, 0, 0, 0);
			.result.w := vec4f(0, 0, 0, 0);
		};
			}
			x: float32 := direction.x / len;
			y: float32 := direction.y / len;
			z: float32 := direction.z / len;
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := x * x;
			xy: float32 := x * y;
			xz: float32 := x * z;
			yy: float32 := y * y;
			yz: float32 := y * z;
			zz: float32 := z * z;
			s: float32 := Math.sin(angle);
			c: float32 := Math.cos(angle);
			k: float32 := (1) - c;
			return .result := {
			.result.xx := xx + (yy + zz) * c;
			.result.xy := xy * k - z * s;
			.result.xz := xz * k + y * s;
			.result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
			.result.yx := xy * k + z * s;
			.result.yy := yy + (xx + zz) * c;
			.result.yz := yz * k - x * s;
			.result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
			.result.zx := xz * k - y * s;
			.result.zy := yz * k + x * s;
			.result.zz := zz + (xx + yy) * c;
			.result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
			.result.w := vec4f(0, 0, 0, 1);
		};
		};
		static rotation(const direction: vec4f, angle: float32): mat4f := {
			xx: float32 := direction.x * direction.x;
			yy: float32 := direction.y * direction.y;
			zz: float32 := direction.z * direction.z;
			xy: float32 := direction.x * direction.y;
			xz: float32 := direction.x * direction.z;
			yz: float32 := direction.y * direction.z;
			s: float32 := Math.sin(angle);
			c: float32 := Math.cos(angle);
			k: float32 := (1) - c;
			tmp: vec4f := mul(direction, s);
			return .result := {
			.result.xx := k * xx + c;
			.result.xy := k * xy - tmp.z;
			.result.xz := k * xz + tmp.y;
			.result.xw := (0);
			.result.yx := k * xy + tmp.z;
			.result.yy := k * yy + c;
			.result.yz := k * yz - tmp.x;
			.result.yw := (0);
			.result.zx := k * xz - tmp.y;
			.result.zy := k * yz + tmp.x;
			.result.zz := k * zz + c;
			.result.zw := (0);
			.result.w := vec4f(0, 0, 0, 1);
		};
		};
		static translation(const direction: vec4f, amount: float32): mat4f := {
			return .result := {
			.result.xx := (1);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := direction.x * amount;
			.result.yx := (0);
			.result.yy := (1);
			.result.yz := (0);
			.result.yw := direction.y * amount;
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := (1);
			.result.zw := direction.z * amount;
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
		};
		static scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := ((val < (0) ? -val : val)) < 0.000000 ? (0) : (1) / val;
			return .result := {
			.result.xx := rcp(direction.x * amount);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := (0);
			.result.yx := (0);
			.result.yy := rcp(direction.y * amount);
			.result.yz := (0);
			.result.yw := (0);
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := rcp(direction.z * amount);
			.result.zw := (0);
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
		};
		static inverse(const mat: mat4f): mat4f := {
			a00: float32 := mat.xx;
			a01: float32 := mat.xy;
			a02: float32 := mat.xz;
			a03: float32 := mat.xw;
			a10: float32 := mat.yx;
			a11: float32 := mat.yy;
			a12: float32 := mat.yz;
			a13: float32 := mat.yw;
			a20: float32 := mat.zx;
			a21: float32 := mat.zy;
			a22: float32 := mat.zz;
			a23: float32 := mat.zw;
			a30: float32 := mat.wx;
			a31: float32 := mat.wy;
			a32: float32 := mat.wz;
			a33: float32 := mat.ww;
			b00: float32 := a00 * a11 - a01 * a10;
			b01: float32 := a00 * a12 - a02 * a10;
			b02: float32 := a00 * a13 - a03 * a10;
			b03: float32 := a01 * a12 - a02 * a11;
			b04: float32 := a01 * a13 - a03 * a11;
			b05: float32 := a02 * a13 - a03 * a12;
			b06: float32 := a20 * a31 - a21 * a30;
			b07: float32 := a20 * a32 - a22 * a30;
			b08: float32 := a20 * a33 - a23 * a30;
			b09: float32 := a21 * a32 - a22 * a31;
			b10: float32 := a21 * a33 - a23 * a31;
			b11: float32 := a22 * a33 - a23 * a32;
			det: float32 := b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
			return .result := {
			.result.xx := (a11 * b11 - a12 * b10 + a13 * b09) / det;
			.result.xy := (a02 * b10 - a01 * b11 - a03 * b09) / det;
			.result.xz := (a31 * b05 - a32 * b04 + a33 * b03) / det;
			.result.xw := (a22 * b04 - a21 * b05 - a23 * b03) / det;
			.result.yx := (a12 * b08 - a10 * b11 - a13 * b07) / det;
			.result.yy := (a00 * b11 - a02 * b08 + a03 * b07) / det;
			.result.yz := (a32 * b02 - a30 * b05 - a33 * b01) / det;
			.result.yw := (a20 * b05 - a22 * b02 + a23 * b01) / det;
			.result.zx := (a10 * b10 - a11 * b08 + a13 * b06) / det;
			.result.zy := (a01 * b08 - a00 * b10 - a03 * b06) / det;
			.result.zz := (a30 * b04 - a31 * b02 + a33 * b00) / det;
			.result.zw := (a21 * b02 - a20 * b04 - a23 * b00) / det;
			.result.wx := (a11 * b07 - a10 * b09 - a12 * b06) / det;
			.result.wy := (a00 * b09 - a01 * b07 + a02 * b06) / det;
			.result.wz := (a31 * b01 - a30 * b03 - a32 * b00) / det;
			.result.ww := (a20 * b03 - a21 * b01 + a22 * b00) / det;
		};
		};
		static const vec2d: struct {
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
			data: float64[2];
		};
		static vec2d(x: float64, y: float64): vec2d := {
			return .result := {
			.result.x := x;
			.result.y := y;
		};
		};
		add(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), add.p2d));
		sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), sub.p2d));
		mul(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), mul.p2d));
		div(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), div.p2d));
		min(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), min.p2d));
		max(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), max.p2d));
		ceq(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), ceq.p2d));
		dot(const a: vec2d, const b: vec2d): float64 := a.x * b.x + a.y * b.y;
		static const Timeunit: struct {
			static const Nanos: int64 := (1);
			static const Micros: int64 := (1000);
			static const Millis: int64 := (1000000);
			static const Seconds: int64 := (1000000000);
			static const Minutes: int64 := (60000000000);
			static const Hours: int64 := (3600000000000);
			static const Days: int64 := (86400000000000);
		};
		static convert(value: int64, from: Timeunit, to: Timeunit): int64 := {
			if (from > to) {
				return .result := value * (from / to);
			}
			return .result := value / (to / from);
		};
		static convert(value: float64, from: Timeunit, to: Timeunit): float64 := {
			if (from > to) {
				return .result := value * ((from / to));
			}
			return .result := value / ((to / from));
		};
		static const Duration: struct {
			const value: int64 := 0;
			static const precision: Timeunit := Timeunit.(Millis);
			static value(duration: Duration, precision: Timeunit): int64 := {
				return .result := convert(duration.value, Duration.precision, precision);
			};
			static add(lhs: Duration, rhs: Duration): Duration := {
				return .result := {
			.result.value := lhs.value + rhs.value;
		};
			};
		};
		static Duration(value: int64, precision: Timeunit): Duration := {
			return .result := {
			.result.value := convert(value, precision, Duration.precision);
		};
		};
		static const Timestamp: struct {
			value: int64 := 0;
			static const precision: Timeunit := Timeunit.(Millis);
			static value(timestamp: Timestamp, precision: Timeunit): int64 := {
				return .result := convert(timestamp.value, Timestamp.precision, precision);
			};
			static diff(a: Timestamp, b: Timestamp, precision: Timeunit): int64 := {
				return .result := convert(a.value - b.value, Timestamp.precision, precision);
			};
			static diff(a: Timestamp, b: Timestamp): Duration := {
				return .result := Duration(a.value - b.value, Timestamp.precision);
			};
			static compare(a: Timestamp, b: Timestamp): int32 := {
				return .result := int32(a.value > b.value) - int32(a.value < b.value);
			};
			static equal(a: Timestamp, b: Timestamp, precision: Timeunit): bool := {
				return .result := value(a, precision) == value(b, precision);
			};
			static equal(a: Timestamp, b: Timestamp): bool := {
				return .result := a.value == b.value;
			};
			static add(lhs: Timestamp, value: int64, precision: Timeunit): Timestamp := {
				return .result := {
			.result.value := lhs.value + convert(value, precision, Timestamp.precision);
		};
			};
			static floor(value: Timestamp, precision: Timeunit): Timestamp := {
				if (precision <= (Timestamp.precision)) {
					trace("small precision", precision);
					return .result := value;
				}
				one: int64 := convert(1, precision, Timestamp.precision);
				return .result := {
			.result.value := value.value - value.value % one;
		};
			};
			static ceil(value: Timestamp, precision: Timeunit): Timestamp := {
				if (precision <= (Timestamp.precision)) {
					trace("small precision", precision);
					return .result := value;
				}
				one: int64 := convert(1, precision, Timestamp.precision);
				part: int64 := value.value % one;
				if (part == (0)) {
					return .result := value;
				}
				return .result := {
			.result.value := value.value - part + one;
		};
			};
			static distribute(this: Timestamp, unit: Timeunit, duration: uint64): Timestamp := {
				abort("not implemented");
				return .result := {
			.result.value := (0);
		};
			};
			static distribute(this: Timestamp, unit: Timeunit, start: int32, end: int32): Timestamp := {
				return .result := distribute(this, unit, end - start);
			};
			static now(): Timestamp := {
				return .result := {
			.result.value := convert(System.millis(), Timeunit.(Millis), Timestamp.precision);
		};
			};
		};
		static Timestamp(value: int64, precision: Timeunit): Timestamp := {
			return .result := {
			.result.value := convert(value, precision, Timestamp.precision);
		};
		};
		static const Timezone: struct {
			const name: char[];
			offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration;
			static offset(const zone: Timezone, timestamp: Timestamp): Duration := {
				isDaylightSaving: bool;
				return .result := zone.offset(zone, timestamp, &isDaylightSaving);
			};
			static utc(): Timezone := {
				static offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration := {
					isDaylightSaving := false;
					return .result := {
			.result.value := (0);
		};
				};
				return .result := {
			.result.offset := offset;
			.result.name := ("UTC");
		};
			};
			static lookup(const name: char[]): Timezone := {
				abort("todo");
			};
			static local(): Timezone := {
				warn("using fake timezone");
				static offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration := {
					isDaylightSaving := false;
					return .result := Duration(3, Timeunit.(Hours));
				};
				return .result := {
			.result.offset := offset;
			.result.name := ("GMT+3");
		};
			};
		};
		static const Month: struct {
			static const January: uint8 := (1);
			static const February: uint8 := (2);
			static const March: uint8 := (3);
			static const April: uint8 := (4);
			static const May: uint8 := (5);
			static const June: uint8 := (6);
			static const July: uint8 := (7);
			static const August: uint8 := (8);
			static const September: uint8 := (9);
			static const October: uint8 := (10);
			static const November: uint8 := (11);
			static const December: uint8 := (12);
		};
		Month(index: int32): Month := Month(emit(int32(index + (Month.(January)))));
		indexOf(value: Month): int32 := int32(value - (Month.(January)));
		static const Weekday: struct {
			static const Monday: uint8 := (1);
			static const Tuesday: uint8 := (2);
			static const Wednesday: uint8 := (3);
			static const Thursday: uint8 := (4);
			static const Friday: uint8 := (5);
			static const Saturday: uint8 := (6);
			static const Sunday: uint8 := (7);
		};
		Weekday(index: int32): Weekday := Weekday(emit(int32(index + (Weekday.(Monday)))));
		indexOf(value: Weekday): int32 := int32(value - (Weekday.(Monday)));
		static const Calendar: struct {
			static const Gregorian: uint8 := (0);
		};
		static const Datetime: struct {
			const year: int32;
			const month: Month;
			const day: uint8;
			const hour: uint8 := 0;
			const minute: uint8 := 0;
			const second: uint8 := 0;
			const millis: uint16 := 0;
			const timezone: Timezone;
			const weekOfYear: uint8;
			const dayOfYear: uint16;
			const dayOfWeek: Weekday;
			const leapYear: bool;
			static const DaysToMonth365: int32[13] := {
				DaysToMonth365[0] := 0;
				DaysToMonth365[1] := 31;
				DaysToMonth365[2] := 59;
				DaysToMonth365[3] := 90;
				DaysToMonth365[4] := 120;
				DaysToMonth365[5] := 151;
				DaysToMonth365[6] := 181;
				DaysToMonth365[7] := 212;
				DaysToMonth365[8] := 243;
				DaysToMonth365[9] := 273;
				DaysToMonth365[10] := 304;
				DaysToMonth365[11] := 334;
				DaysToMonth365[12] := 365;
			};
			static const DaysToMonth366: int32[13] := {
				DaysToMonth366[0] := 0;
				DaysToMonth366[1] := 31;
				DaysToMonth366[2] := 60;
				DaysToMonth366[3] := 91;
				DaysToMonth366[4] := 121;
				DaysToMonth366[5] := 152;
				DaysToMonth366[6] := 182;
				DaysToMonth366[7] := 213;
				DaysToMonth366[8] := 244;
				DaysToMonth366[9] := 274;
				DaysToMonth366[10] := 305;
				DaysToMonth366[11] := 335;
				DaysToMonth366[12] := 366;
			};
			static const DaysTil1970: int32 := 719162;
			static isLeapYear(year: int32): bool := {
				if (year % 4 != 0) {
					return .result := false;
				}
				if (year % 100 != 0) {
					return .result := true;
				}
				if (year % 400 != 0) {
					return .result := false;
				}
				return .result := true;
			};
			static add(cal: Datetime, years: int32, months: int32, days: int32): Datetime := {
				year: int32 := cal.year + years;
				month: int32 := indexOf(cal.month) + months;
				if (month >= 12) {
					year := year + month / 12;
					month := month % 12;
				}
				else if (month < 0) {
					year := year + month / 12 - 1;
					month := 12 - (-month % 12);
				}
				assert(days == 0);
				return .result := {
			.result.year := year;
			.result.month := Month(month % 12);
			.result.day := cal.day;
			.result.hour := cal.hour;
			.result.minute := cal.minute;
			.result.second := cal.second;
			.result.millis := cal.millis;
			.result.timezone := cal.timezone;
			.result.weekOfYear := cal.weekOfYear;
			.result.dayOfYear := cal.dayOfYear;
			.result.dayOfWeek := cal.dayOfWeek;
			.result.leapYear := isLeapYear(year);
		};
			};
		};
		static Timestamp(value: Datetime): Timestamp := {
			year: int32 := value.year;
			if (year < 0 || year > 9999) {
				trace("invalid year", year);
				return .result := Timestamp(1 << 63, Timestamp.precision);
			}
			month: int32 := value.month;
			if (month < (Month.(January)) || month > (Month.(December))) {
				trace("invalid month", month);
				month := Math.clamp(month, int32(Month.(January)), int32(Month.(December)));
			}
			const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365;
			day: int32 := value.day;
			daysInYear: int32 := DaysToMonth[month - 1];
			daysInMonth: int32 := DaysToMonth[month] - daysInYear;
			if (day < 1 || day > daysInMonth) {
				trace("invalid day of month", day);
				day := Math.clamp(day, 1, daysInMonth);
			}
			y: int32 := year - 1;
			d: int64 := y * 365 + y / 4 - y / 100 + y / 400 + daysInYear + day - 1 - Datetime.DaysTil1970;
			t: int64 := (((d * (24) + (value.hour)) * (60) + (value.minute)) * (60) + (value.second)) * (1000) + (value.millis);
			return .result := Timestamp(t, Timeunit.(Millis));
		};
		static Datetime(timestamp: Timestamp, calendar: Calendar, timezone: Timezone): Datetime := {
			assert(calendar == (Calendar.(Gregorian)));
			offset: Duration := Timezone.offset(timezone, timestamp);
			timestamp := Timestamp.add(timestamp, offset.value, Duration.precision);
			n: int32 := (Datetime.DaysTil1970) + Timestamp.value(timestamp, Timeunit.(Days));
			dayOfWeek: int32 := n % 7;
			y400: int32 := n / DaysPer400Years;
			n := n - y400 * DaysPer400Years;
			y100: int32 := n / DaysPer100Years;
			if (y100 == 4) {
				y100 := 3;
			}
			n := n - y100 * DaysPer100Years;
			y4: int32 := n / DaysPer4Years;
			n := n - y4 * DaysPer4Years;
			y1: int32 := n / DaysPerYear;
			if (y1 == 4) {
				y1 := 3;
			}
			year: int32 := y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1;
			n := n - y1 * DaysPerYear;
			m: int32 := n >> 5 + 1;
			const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365;
			for ( ; n >= DaysToMonth[m]; ) {
				m := m + 1;
			}
			return .result := {
			.result.year := year;
			.result.month := Month(m - 1);
			.result.day := (n - DaysToMonth[m - 1] + 1);
			.result.hour := (Timestamp.value(timestamp, Timeunit.(Hours)) % (24));
			.result.minute := (Timestamp.value(timestamp, Timeunit.(Minutes)) % (60));
			.result.second := (Timestamp.value(timestamp, Timeunit.(Seconds)) % (60));
			.result.millis := (Timestamp.value(timestamp, Timeunit.(Millis)) % (1000));
			.result.timezone := timezone;
			.result.dayOfYear := (n + 1);
			.result.dayOfWeek := Weekday(dayOfWeek);
			.result.weekOfYear := ((n - dayOfWeek + indexOf(Weekday.(Thursday))) / 7 + 1);
			.result.leapYear := (DaysToMonth) == Datetime.DaysToMonth366;
		};
		};
		Datetime(timestamp: Timestamp): Datetime := Datetime(timestamp, Calendar.(Gregorian), Timezone.utc());
		static Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime := {
			return .result := {
			.result.year := year;
			.result.month := Month(month - 1);
			.result.day := (day);
			.result.hour := (hour);
			.result.minute := (minute);
			.result.second := (second);
			.result.millis := (millis);
			.result.timezone := zone;
			.result.weekOfYear := (0);
			.result.dayOfYear := (0);
			.result.dayOfWeek := Weekday.(Monday);
			.result.leapYear := Datetime.isLeapYear(year);
		};
		};
		static Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32): Datetime := {
			return .result := Datetime(year, month, day, hour, minute, second, millis, Timezone.utc());
		};
		static Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, zone: Timezone): Datetime := {
			return .result := Datetime(year, month, day, hour, minute, second, 0, zone);
		};
		static Datetime(year: int32, month: int32, day: int32, zone: Timezone): Datetime := {
			return .result := Datetime(year, month, day, 0, 0, 0, 0, zone);
		};
		static Datetime(year: int32, month: int32, day: int32): Datetime := {
			return .result := Datetime(year, month, day, 0, 0, 0, 0, Timezone.utc());
		};
		static length(const str: char[*]): int32 := {
			if ((str) == null) {
				return .result := 0;
			}
			result: int32 := 0;
			for ( ; str[result]; result := result + 1) ;
			return .result := result;
		};
		static indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					return .result := i;
				}
			}
			return .result := -1;
		};
		static lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := -1;
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					result := i;
				}
			}
			return .result := result;
		};
		static startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
				if (cmp(str[i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (strLen < withLen) {
				return .result := false;
			}
			for (i: int32 := 0; i < withLen; i := i + 1) {
				if (cmp(str[strLen - withLen + i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; result == 0; i := i + 1) {
				result := cmp(str[i], with[i]);
				if ((str[i]) == 0) {
					break;
				}
			}
			return .result := result;
		};
		static ignCaseCmp(chr: char, with: char): int32 := {
			static ignCase(chr: char): char := {
				if (chr < 'A') {
					return .result := chr;
				}
				if (chr > 'Z') {
					return .result := chr;
				}
				return .result := chr - 'A' + 'a';
			};
			return .result := ignCase(chr) - ignCase(with);
		};
		static caseCmp(chr: char, with: char): int32 := {
			return .result := chr - with;
		};
		toHex(value: int32): int32 := int32("0123456789abcdef"[value & 15]);
		startsWith(const str: char[*], const with: char[*]): bool := startsWith(str, with, caseCmp);
		endsWith(const str: char[*], const with: char[*]): bool := endsWith(str, with, caseCmp);
		compare(const str: char[*], const with: char[*]): int32 := compare(str, with, caseCmp);
		equals(const str: char[*], const with: char[*]): bool := compare(str, with, caseCmp) == 0;
		contains(const str: char[*], chr: char): bool := indexOf(str, chr) >= 0;
		static float64(const value: char[]): float64 := {
			result: float64 := 0;
			static if ((preferNativeCalls) && (typename(float64.parse)) != null) {
				len: int32 := float64.parse(value, &result);
				if (len > 0 && len < (value.length) && (value[len]) == 0) {
					return .result := result;
				}
				return .result := Math.nan;
			}
			sign: float64 := 1;
			decimal: float64 := 0;
			for (i: int32 := 0; i < (value.length) && (value[i]) != 0; i := i + 1) {
				chr: char := value[i];
				if (chr >= '0' && chr <= '9') {
					result := result * (10) + ((chr - '0'));
					decimal := decimal * (10);
				}
				else if (chr == '.') {
					if (decimal != (0)) {
						return .result := Math.nan;
					}
					decimal := (1);
				}
				else if (chr == '-' && i == 0) {
					sign := (-1);
				}
				else if (chr == '+' && i == 0) {
					sign := (1);
				}
				else {
					return .result := Math.nan;
				}
			}
			if (decimal == (0)) {
				if (value.length > (0)) {
					return .result := sign * result;
				}
			}
			return .result := sign * result / decimal;
		};
		static const FormatFlags: struct {
			const sign: char := 0;
			const padChr: char := 0;
			const width: int32 := 0;
			const precision: int32 := 10;
			const trimDecimal: bool := true;
			static read(const format: char[], pos: int32): FormatFlags := {
				chr: int32 := format[pos];
				if (chr != ('%')) {
					return .result := {
			.result.trimDecimal := true;
			.result.precision := 10;
			.result.width := 0;
			.result.padChr := (0);
			.result.sign := (0);
		};
				}
				pos := pos + 1;
				chr := (format[pos]);
				if (chr == ('%')) {
					return .result := {
			.result.trimDecimal := true;
			.result.precision := 10;
			.result.width := 0;
			.result.padChr := (0);
			.result.sign := (0);
		};
				}
				sgnChr: int32 := 0;
				if (chr == ('-') || chr == ('+')) {
					pos := pos + 1;
					sgnChr := chr;
					chr := (format[pos]);
				}
				padChr: int32 := ' ';
				if (chr == ('0')) {
					pos := pos + 1;
					padChr := chr;
					chr := (format[pos]);
				}
				padLen: int32 := 0;
				for ( ; chr >= ('0') && chr <= ('9'); ) {
					pos := pos + 1;
					padLen := padLen * 10 + chr - ('0');
					chr := (format[pos]);
				}
				precision: int32 := 0;
				if (chr == ('.')) {
					pos := pos + 1;
					chr := (format[pos]);
					for ( ; chr >= ('0') && chr <= ('9'); ) {
						pos := pos + 1;
						precision := precision * 10 + chr - ('0');
						chr := (format[pos]);
					}
				}
				return .result := {
			.result.sign := (sgnChr);
			.result.width := padLen;
			.result.padChr := (padChr);
			.result.precision := precision;
			.result.trimDecimal := true;
		};
			};
			static defPad(const this: FormatFlags, width: int32, padChr: char): FormatFlags := {
				if (this.width == 0) {
					return .result := {
			.result.sign := this.sign;
			.result.precision := this.precision;
			.result.padChr := padChr;
			.result.width := width;
			.result.trimDecimal := true;
		};
				}
				return .result := this;
			};
		};
		static append(output: char[], pos: int32, const value: char[*]): int32 := {
			if ((value) == null) {
				return .result := append(output, pos, "NULL");
			}
			for (i: int32 := 0; value[i]; i := i + 1) {
				if (pos >= (output.length)) {
					break;
				}
				output[pos] := value[i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static append(output: char[], pos: int32, radix: int32, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80] := {
			};
			assert(radix > 1, "radix is too small", radix);
			assert(radix < (radixDigits.length), "radix is too big", radix);
			for ( ; value > (0); value := value / (radix)) {
				digits[len := len + 1] := radixDigits[value % (radix)];
			}
			if (len == 0) {
				digits[len := len + 1] := '0';
			}
			maxLen: int32 := format.width - len;
			padChr: char := format.padChr;
			if (padChr == '') {
				padChr := ' ';
			}
			if ((format.sign) != 0) {
				maxLen := maxLen - 1;
				if (contains(whiteSpace, padChr)) {
					for ( ; maxLen > 0; maxLen := maxLen - 1) {
						assert(pos < (output.length));
						output[pos] := padChr;
						pos := pos + 1;
					}
				}
				assert(pos < (output.length));
				output[pos] := format.sign;
				pos := pos + 1;
			}
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
			for (i: int32 := 0; i < len; i := i + 1) {
				assert(i < (output.length));
				output[pos] := digits[len - i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static append(output: char[], pos: int32, radix: int32, value: int64, const format: FormatFlags): int32 := {
			if (value < (0)) {
				signedFormat: FormatFlags := {
					signedFormat.sign := '-';
					signedFormat.padChr := format.padChr;
					signedFormat.width := format.width;
					signedFormat.precision := format.precision;
					signedFormat.trimDecimal := true;
				};
				return .result := append(output, pos, radix, uint64(-value), signedFormat);
			}
			return .result := append(output, pos, radix, uint64(value), format);
		};
		static append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				formatInt.sign := value < (0) ? '-' : format.sign;
				formatInt.padChr := format.padChr;
				formatInt.width := format.width - format.precision - 1;
				formatInt.precision := 10;
				formatInt.trimDecimal := true;
			};
			end: int32 := pos + format.width;
			if (end >= (output.length)) {
				end := (output.length - (1));
			}
			const beg: int32 := pos;
			fraction: float64 := Math.modf(Math.abs(value), &value);
			pos := append(output, pos, 10, uint64(int64(value)), formatInt);
			dotIndex: int32 := pos;
			pos := append(output, pos, ".");
			end := Math.max(end, pos + format.precision);
			if (end >= (output.length)) {
				end := (output.length - (1));
			}
			fraction := fraction + Math.pow(10.000000, float64(pos - end)) / (2);
			if (fraction >= (1)) {
				fraction := fraction % (1);
				pos := append(output, beg, 10, uint64(int64(value + (1))), formatInt);
				dotIndex := pos;
				pos := append(output, pos, ".");
				end := Math.max(end, pos + format.precision);
				if (end >= (output.length)) {
					end := (output.length - (1));
				}
			}
			for ( ; pos < end; pos := pos + 1) {
				fraction := Math.modf(fraction * (10), &value);
				output[pos] := (('0') + int32(value));
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			if (!format.trimDecimal) {
				output[pos] := (0);
				return .result := pos;
			}
			for (i: int32 := pos - 1; i >= dotIndex; i := i - 1) {
				if (output[i] != '0') {
					if (i == dotIndex) {
						output[i] := (0);
						return .result := i;
					}
					output[i + 1] := (0);
					return .result := i + 1;
				}
			}
			return .result := pos;
		};
		append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(output, pos, 10, uint64(value), format);
		append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(output, pos, 10, uint64(value), format);
		append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(output, pos, 10, uint64(value), format);
		append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(output, pos, 10, uint64(value), format);
		append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(output, pos, 10, int64(value), format);
		append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(output, pos, 10, int64(value), format);
		append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(output, pos, 10, int64(value), format);
		append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(output, pos, 10, int64(value), format);
		append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(output, pos, float64(value), format);
		static const DatetimeFormat: struct {
			const monthsLong: char[][];
			const monthsShort: char[][];
			const weeksLong: char[][];
			const weeksShort: char[][];
			const amPmUpper: char[][];
			const amPmLower: char[][];
			const dateLong: char[] := "%A %d %B %Y";
			const timeLong: char[] := "%r";
			const dateShort: char[] := "%x";
			const timeShort: char[] := "%I:%M %p";
			static format(const formatter: DatetimeFormat, output: char[], end: int32, const value: Datetime, const format: char[]): int32 := {
				hours24to12(hour: int32): int32 := hour > 12 ? hour - 12 : hour == 0 ? 12 : hour;
				if (pointer(format) == null) {
					return .result := format(formatter, output, end, value, "%Y.%m.%d");
				}
				chr: char := 0;
				for (pos: int32 := 0; pos < (format.length); pos := pos + 1) {
					if (end >= (output.length)) {
						output[output.length - (1)] := (0);
						return .result := output.length - (1);
					}
					chr := format[pos];
					if (chr != '%') {
						output[end] := chr;
						end := end + 1;
						continue;
					}
					flags: FormatFlags := FormatFlags.read(format, &pos);
					chr := format[pos];
					if (chr == '%') {
						end := append(output, end, "%");
					}
					else if (chr == 'a') {
						end := append(output, end, formatter.weeksShort[indexOf(value.dayOfWeek)]);
					}
					else if (chr == 'A') {
						end := append(output, end, formatter.weeksLong[indexOf(value.dayOfWeek)]);
					}
					else if (chr == 'b') {
						end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
					}
					else if (chr == 'B') {
						end := append(output, end, formatter.monthsLong[indexOf(value.month)]);
					}
					else if (chr == 'C') {
						end := append(output, end, value.year / 100, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'd') {
						end := append(output, end, value.day, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'D') {
						end := format(formatter, output, end, value, "%m/%d/%y");
					}
					else if (chr == 'e') {
						end := append(output, end, value.day, FormatFlags.defPad(flags, 2, ' '));
					}
					else if (chr == 'F') {
						end := format(formatter, output, end, value, "%04Y-%m-%d");
					}
					else if (chr == 'h') {
						end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
					}
					else if (chr == 'H') {
						end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'I') {
						end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'j') {
						end := append(output, end, value.dayOfYear, FormatFlags.defPad(flags, 3, '0'));
					}
					else if (chr == 'k') {
						end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, ' '));
					}
					else if (chr == 'l') {
						end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, ' '));
					}
					else if (chr == 'm') {
						end := append(output, end, indexOf(value.month) + 1, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'M') {
						end := append(output, end, value.minute, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'n') {
						end := append(output, end, "\n");
					}
					else if (chr == 'N') {
						end := append(output, end, (value.millis) * 1000000, FormatFlags.defPad(flags, 9, '0'));
					}
					else if (chr == 'p') {
						end := append(output, end, formatter.amPmUpper[int32((value.hour) < 12)]);
					}
					else if (chr == 'P') {
						end := append(output, end, formatter.amPmLower[int32((value.hour) < 12)]);
					}
					else if (chr == 'R') {
						end := format(formatter, output, end, value, "%H:%M");
					}
					else if (chr == 's') {
						end := append(output, end, typename.value(Timestamp(value), Timeunit.(Seconds)), flags);
					}
					else if (chr == 'S') {
						end := append(output, end, value.second, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 't') {
						end := append(output, end, "\t");
					}
					else if (chr == 'T') {
						end := format(formatter, output, end, value, "%H:%M:%S");
					}
					else if (chr == 'u') {
						end := append(output, end, indexOf(value.dayOfWeek) + 1, flags);
					}
					else if (chr == 'W') {
						end := append(output, end, value.weekOfYear, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'x') {
						end := format(formatter, output, end, value, formatter.dateShort);
					}
					else if (chr == 'X') {
						end := format(formatter, output, end, value, formatter.timeShort);
					}
					else if (chr == 'y') {
						end := append(output, end, value.year % 100, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'Y') {
						end := append(output, end, value.year, flags);
					}
					else {
						abort("unimplemented or invalid format character", chr);
					}
				}
				if (end >= (output.length)) {
					end := (output.length - (1));
				}
				output[end] := (0);
				return .result := end;
			};
			static format(const formatter: DatetimeFormat, output: char[], const value: Datetime, const format: char[]): int32 := {
				return .result := format(formatter, output, 0, value, format);
			};
		};
		static format(const value: Datetime, output: char[], const format: char[]): int32 := {
			static const monthsLongEn: char[][] := {
				monthsLongEn := monthsLongEn.init;
				monthsLongEn.init[0] := ("January");
				monthsLongEn.init[1] := ("February");
				monthsLongEn.init[2] := ("March");
				monthsLongEn.init[3] := ("April");
				monthsLongEn.init[4] := ("May");
				monthsLongEn.init[5] := ("June");
				monthsLongEn.init[6] := ("July");
				monthsLongEn.init[7] := ("August");
				monthsLongEn.init[8] := ("September");
				monthsLongEn.init[9] := ("October");
				monthsLongEn.init[10] := ("November");
				monthsLongEn.init[11] := ("December");
			};
			static const monthsShortEn: char[][] := {
				monthsShortEn := monthsShortEn.init;
				monthsShortEn.init[0] := ("Jan");
				monthsShortEn.init[1] := ("Feb");
				monthsShortEn.init[2] := ("Mar");
				monthsShortEn.init[3] := ("Apr");
				monthsShortEn.init[4] := ("May");
				monthsShortEn.init[5] := ("Jun");
				monthsShortEn.init[6] := ("Jul");
				monthsShortEn.init[7] := ("Aug");
				monthsShortEn.init[8] := ("Sep");
				monthsShortEn.init[9] := ("Oct");
				monthsShortEn.init[10] := ("Nov");
				monthsShortEn.init[11] := ("Dec");
			};
			static const weeksLongEn: char[][] := {
				weeksLongEn := weeksLongEn.init;
				weeksLongEn.init[0] := ("Monday");
				weeksLongEn.init[1] := ("Tuesday");
				weeksLongEn.init[2] := ("Wednesday");
				weeksLongEn.init[3] := ("Thursday");
				weeksLongEn.init[4] := ("Friday");
				weeksLongEn.init[5] := ("Saturday");
				weeksLongEn.init[6] := ("Sunday");
			};
			static const weeksShortEn: char[][] := {
				weeksShortEn := weeksShortEn.init;
				weeksShortEn.init[0] := ("Mon");
				weeksShortEn.init[1] := ("Tue");
				weeksShortEn.init[2] := ("Wed");
				weeksShortEn.init[3] := ("Thu");
				weeksShortEn.init[4] := ("Fri");
				weeksShortEn.init[5] := ("Sat");
				weeksShortEn.init[6] := ("Sun");
			};
			static const amPmUpperEn: char[][] := {
				amPmUpperEn := amPmUpperEn.init;
				amPmUpperEn.init[0] := ("AM");
				amPmUpperEn.init[1] := ("PM");
			};
			static const amPmLowerEn: char[][] := {
				amPmLowerEn := amPmLowerEn.init;
				amPmLowerEn.init[0] := ("am");
				amPmLowerEn.init[1] := ("pm");
			};
			static const fmtEN: DatetimeFormat := {
				fmtEN.monthsLong := (monthsLongEn);
				fmtEN.monthsShort := (monthsShortEn);
				fmtEN.weeksLong := (weeksLongEn);
				fmtEN.weeksShort := (weeksShortEn);
				fmtEN.amPmUpper := (amPmUpperEn);
				fmtEN.amPmLower := (amPmLowerEn);
				fmtEN.dateLong := ("%A %d %B %Y");
				fmtEN.timeLong := ("%r");
				fmtEN.dateShort := ("%x");
				fmtEN.timeShort := ("%I:%M %p");
			};
			return .result := DatetimeFormat.format(fmtEN, output, value, format);
		};
		static append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				format.sign := (0);
				format.padChr := (0);
				format.width := 0;
				format.precision := 10;
				format.trimDecimal := true;
			};
			return .result := append(output, pos, value, format);
		};
		static const Closeable: struct {
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const ByteReader: struct {
			read(this: ByteReader, bytes: uint8[]): int32;
			static read(this: ByteReader): int32 := {
				bytes: uint8[1] := {
					bytes[0] := (0);
				};
				if (read(this, bytes) <= 0) {
					return .result := -1;
				}
				return .result := bytes[0];
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const ByteWriter: struct {
			write(this: ByteWriter, bytes: uint8[]): void;
			flush(this: ByteWriter): void;
			static write(this: ByteWriter, oneByte: uint8): void := {
				bytes: uint8[1] := {
					bytes[0] := oneByte;
				};
				return .result := this.write(this, bytes);
			};
			static copy(this: ByteWriter, reader: ByteReader): int32 := {
				buffer: uint8[4096] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					read: int32 := reader.read(reader, buffer);
					if (read <= 0) {
						return .result := result;
					}
					this.write(this, buffer[...read]);
					result := result + read;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const CopyReader: struct {
			const source: ByteReader;
			const clone: ByteWriter;
			static read(this: CopyReader, bytes: uint8[]): int32 := {
				result: int32 := read(this.source, bytes);
				if (result > 0) {
					this.clone.write(this.clone, bytes[...result]);
				}
				return .result := result;
			};
			static close(this: CopyReader): void := {
				Closeable.closeSafe(this.source);
				Closeable.closeSafe(this.clone);
			};
			read(this: ByteReader, bytes: uint8[]): int32;
			static read(this: ByteReader): int32 := {
				bytes: uint8[1] := {
					bytes[0] := (0);
				};
				if (read(this, bytes) <= 0) {
					return .result := -1;
				}
				return .result := bytes[0];
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const ByteBuffer: struct {
			position: int32 := 0;
			capacity: int32 := 32;
			length: int32 := 0;
			buffer: uint8[*] := pointer.alloc(null, capacity);
			static read(this: ByteBuffer, bytes: uint8[]): int32 := {
				if (this.position >= this.length) {
					return .result := -1;
				}
				for (i: int32 := 0; i < (bytes.length); i := i + 1) {
					if (this.position >= this.length) {
						return .result := i;
					}
					bytes[i] := this.buffer[this.position];
					this.position := this.position + 1;
				}
				return .result := bytes.length;
			};
			const read(this: ByteBuffer, bytes: uint8[]): int32 := read;
			static read(this: ByteBuffer): int32 := {
				if (this.position >= this.length) {
					return .result := -1;
				}
				result: int32 := this.buffer[this.position];
				this.position := this.position + 1;
				return .result := result;
			};
			const read(this: ByteBuffer): int32 := read;
			static write(this: ByteBuffer, bytes: uint8[]): void := {
				size: int32 := this.position + (bytes.length);
				if (size >= this.capacity) {
					this.capacity := this.capacity * 2;
					if (size > 2 * this.capacity) {
						this.capacity := size * 2;
					}
					new: uint8[*] := pointer.alloc(null, this.capacity);
					for (i: int32 := 0; i < this.position; i := i + 1) {
						new[i] := this.buffer[i];
					}
					pointer.alloc(this.buffer, 0);
					this.buffer := (new);
				}
				for (i: int32 := 0; i < (bytes.length); i := i + 1) {
					this.buffer[this.position] := bytes[i];
					this.position := this.position + 1;
				}
			};
			const write(this: ByteBuffer, bytes: uint8[]): void := write;
			static flush(this: ByteBuffer): void := {
			};
			const flush(this: ByteBuffer): void := flush;
			static close(this: ByteBuffer): void := {
				pointer.alloc(this.buffer, 0);
				this.buffer := (null);
				this.position := 0;
				this.capacity := 0;
				this.length := 0;
			};
			const close(this: ByteBuffer): void := close;
		};
		unicode: typename := uint32;
		static const TextReader: struct {
			const reader: ByteReader;
			decode(this: TextReader, chars: uint32[]): int32;
			static close(this: TextReader): void := {
				Closeable.closeSafe(this.reader);
			};
			static decode(this: TextReader): int32 := {
				chars: uint32[1] := {
					chars[0] := (0);
				};
				if (decode(this, chars) <= 0) {
					return .result := -1;
				}
				return .result := chars[0] & (16777215);
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const TextWriter: struct {
			static const Writeable: struct {
				write(this: Writeable, writer: TextWriter): void;
				const .type: typename;
				static const create(type: typename): pointer := nfc(7);
				static const destroy(this: object): void := nfc(8);
				static const as(this: object, type: typename): pointer := nfc(9);
				static const type(this: object): typename := nfc(10);
			};
			const writer: ByteWriter;
			const format: FormatFlags;
			encode(this: TextWriter, chars: uint32[]): void;
			static flush(this: TextWriter): void := {
				this.writer.flush(this.writer);
			};
			const flush(this: TextWriter): void := flush;
			static close(this: TextWriter): void := {
				Closeable.closeSafe(this.writer);
			};
			static write(this: TextWriter, value: char[]): TextWriter := {
				this.writer.write(this.writer, value);
				return .result := this;
			};
			static write(this: TextWriter, value: char): TextWriter := {
				buffer: char[1] := {
					buffer[0] := value;
				};
				return .result := write(this, buffer);
			};
			static write(this: TextWriter, value: bool): TextWriter := {
				if (value) {
					return .result := write(this, "true");
				}
				return .result := write(this, "false");
			};
			static write(this: TextWriter, value: int32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: int64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: Writeable): TextWriter := {
				value.write(value, this);
				return .result := this;
			};
			static writeln(this: TextWriter): TextWriter := {
				return .result := write(this, "\n");
			};
			static writeln(this: TextWriter, value: Writeable): TextWriter := {
				return .result := writeln(write(this, value));
			};
			static copy(writer: TextWriter, reader: TextReader): int32 := {
				buffer: uint32[1024] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					n: int32 := reader.decode(reader, buffer);
					if (n <= 0) {
						return .result := result;
					}
					encode(writer, buffer[...n]);
					result := result + n;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Base64Encoder: struct {
			static const lookup: uint8[] := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
			const writer: ByteWriter;
			buffer: uint8[1024];
			bufferSize: int32 := 0;
			padding: int32 := 0;
			const wrap: int32 := 80;
			wrapSize: int32 := 0;
			static flushBuffer(this: Base64Encoder): void := {
				writer: ByteWriter := this.writer;
				size: int32 := this.bufferSize;
				wrap: int32 := this.wrap - this.wrapSize;
				if (wrap > size || this.wrap == 0) {
					wrap := size;
				}
				writer.write(writer, this.buffer[...wrap]);
				this.wrapSize := this.wrapSize + wrap;
				for ( ; wrap < size; ) {
					writer.write(writer, "\n");
					len: int32 := Math.min(size - wrap, this.wrap);
					buffer: uint8[*] := inc(this.buffer, wrap);
					writer.write(writer, buffer[...len]);
					this.wrapSize := len;
					wrap := wrap + len;
				}
				this.bufferSize := 0;
			};
			static write(this: Base64Encoder, data: uint8[]): void := {
				assert(buffer.(length) > 3);
				writer: ByteWriter := this.writer;
				buffer: uint8[] := this.buffer;
				size: int32 := this.bufferSize;
				i: int32 := 0;
				if (size > 3 && buffer[size - 1] == ('=') && data.length > (0)) {
					if (buffer[size - 2] == ('=')) {
						if (data.length < (2)) {
							b: int32 := ((this.padding << 6) | (((data[i]) & 255) << 2));
							buffer[size - 3] := lookup[b >> 6 & 63];
							buffer[size - 2] := lookup[b & 63];
							this.padding := b;
							return;
						}
						b: int32 := (this.padding << 12) | (((data[i]) & 255) << 8) | ((data[i + 1]) & 255);
						buffer[size - 3] := lookup[b >> 12 & 63];
						buffer[size - 2] := lookup[b >> 6 & 63];
						buffer[size - 1] := lookup[b & 63];
						i := i + 2;
					}
					else {
						b: int32 := (this.padding << 6) | ((data[i]) & 255);
						buffer[size - 2] := lookup[b >> 6 & 63];
						buffer[size - 1] := lookup[b & 63];
						i := i + 1;
					}
				}
				for (n: int32 := data.length - (2); i < n; i := i + 3) {
					if (size + 4 > (buffer.length)) {
						flushBuffer(this);
					}
					b: int32 := (((data[i + 0]) & 255) << 16) | (((data[i + 1]) & 255) << 8) | (((data[i + 2]) & 255) << 0);
					buffer[size + 0] := lookup[b >> 18 & 63];
					buffer[size + 1] := lookup[b >> 12 & 63];
					buffer[size + 2] := lookup[b >> 6 & 63];
					buffer[size + 3] := lookup[b & 63];
					size := size + 4;
				}
				if (left) {
					if (size + 4 > (buffer.length)) {
						flushBuffer(this);
					}
					if (left == 2) {
						b: int32 := (((data[i + 0]) & 255) << 10) | (((data[i + 1]) & 255) << 2);
						buffer[size + 0] := lookup[b >> 12 & 63];
						buffer[size + 1] := lookup[b >> 6 & 63];
						buffer[size + 2] := lookup[b & 63];
						buffer[size + 3] := ('=');
						this.padding := b;
						size := size + 4;
					}
					else {
						b: int32 := ((data[i]) & 255) << 4;
						buffer[size + 0] := lookup[(b >> 6) & 63];
						buffer[size + 1] := lookup[(b >> 0) & 63];
						buffer[size + 2] := ('=');
						buffer[size + 3] := ('=');
						this.padding := b;
						size := size + 4;
					}
				}
			};
			static flush(this: Base64Encoder): void := {
				flushBuffer(this);
				flush(this.writer);
			};
			static close(this: Base64Encoder): void := {
				flushBuffer(this);
			};
			write(this: ByteWriter, bytes: uint8[]): void;
			flush(this: ByteWriter): void;
			static write(this: ByteWriter, oneByte: uint8): void := {
				bytes: uint8[1] := {
					bytes[0] := oneByte;
				};
				return .result := this.write(this, bytes);
			};
			static copy(this: ByteWriter, reader: ByteReader): int32 := {
				buffer: uint8[4096] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					read: int32 := reader.read(reader, buffer);
					if (read <= 0) {
						return .result := result;
					}
					this.write(this, buffer[...read]);
					result := result + read;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Base64Decoder: struct {
			static const lookup: int32[256] := {
				lookup[0] := -1;
				lookup[1] := -1;
				lookup[2] := -1;
				lookup[3] := -1;
				lookup[4] := -1;
				lookup[5] := -1;
				lookup[6] := -1;
				lookup[7] := -1;
				lookup[8] := -1;
				lookup[9] := -1;
				lookup[10] := -1;
				lookup[11] := -1;
				lookup[12] := -1;
				lookup[13] := -1;
				lookup[14] := -1;
				lookup[15] := -1;
				lookup[16] := -1;
				lookup[17] := -1;
				lookup[18] := -1;
				lookup[19] := -1;
				lookup[20] := -1;
				lookup[21] := -1;
				lookup[22] := -1;
				lookup[23] := -1;
				lookup[24] := -1;
				lookup[25] := -1;
				lookup[26] := -1;
				lookup[27] := -1;
				lookup[28] := -1;
				lookup[29] := -1;
				lookup[30] := -1;
				lookup[31] := -1;
				lookup[32] := -1;
				lookup[33] := -1;
				lookup[34] := -1;
				lookup[35] := -1;
				lookup[36] := -1;
				lookup[37] := -1;
				lookup[38] := -1;
				lookup[39] := -1;
				lookup[40] := -1;
				lookup[41] := -1;
				lookup[42] := -1;
				lookup[43] := 62;
				lookup[44] := -1;
				lookup[45] := -1;
				lookup[46] := -1;
				lookup[47] := 63;
				lookup[48] := 52;
				lookup[49] := 53;
				lookup[50] := 54;
				lookup[51] := 55;
				lookup[52] := 56;
				lookup[53] := 57;
				lookup[54] := 58;
				lookup[55] := 59;
				lookup[56] := 60;
				lookup[57] := 61;
				lookup[58] := -1;
				lookup[59] := -1;
				lookup[60] := -1;
				lookup[61] := -2;
				lookup[62] := -1;
				lookup[63] := -1;
				lookup[64] := -1;
				lookup[65] := 0;
				lookup[66] := 1;
				lookup[67] := 2;
				lookup[68] := 3;
				lookup[69] := 4;
				lookup[70] := 5;
				lookup[71] := 6;
				lookup[72] := 7;
				lookup[73] := 8;
				lookup[74] := 9;
				lookup[75] := 10;
				lookup[76] := 11;
				lookup[77] := 12;
				lookup[78] := 13;
				lookup[79] := 14;
				lookup[80] := 15;
				lookup[81] := 16;
				lookup[82] := 17;
				lookup[83] := 18;
				lookup[84] := 19;
				lookup[85] := 20;
				lookup[86] := 21;
				lookup[87] := 22;
				lookup[88] := 23;
				lookup[89] := 24;
				lookup[90] := 25;
				lookup[91] := -1;
				lookup[92] := -1;
				lookup[93] := -1;
				lookup[94] := -1;
				lookup[95] := -1;
				lookup[96] := -1;
				lookup[97] := 26;
				lookup[98] := 27;
				lookup[99] := 28;
				lookup[100] := 29;
				lookup[101] := 30;
				lookup[102] := 31;
				lookup[103] := 32;
				lookup[104] := 33;
				lookup[105] := 34;
				lookup[106] := 35;
				lookup[107] := 36;
				lookup[108] := 37;
				lookup[109] := 38;
				lookup[110] := 39;
				lookup[111] := 40;
				lookup[112] := 41;
				lookup[113] := 42;
				lookup[114] := 43;
				lookup[115] := 44;
				lookup[116] := 45;
				lookup[117] := 46;
				lookup[118] := 47;
				lookup[119] := 48;
				lookup[120] := 49;
				lookup[121] := 50;
				lookup[122] := 51;
				lookup[123] := -1;
				lookup[124] := -1;
				lookup[125] := -1;
				lookup[126] := -1;
				lookup[127] := -1;
				lookup[128] := -1;
				lookup[129] := -1;
				lookup[130] := -1;
				lookup[131] := -1;
				lookup[132] := -1;
				lookup[133] := -1;
				lookup[134] := -1;
				lookup[135] := -1;
				lookup[136] := -1;
				lookup[137] := -1;
				lookup[138] := -1;
				lookup[139] := -1;
				lookup[140] := -1;
				lookup[141] := -1;
				lookup[142] := -1;
				lookup[143] := -1;
				lookup[144] := -1;
				lookup[145] := -1;
				lookup[146] := -1;
				lookup[147] := -1;
				lookup[148] := -1;
				lookup[149] := -1;
				lookup[150] := -1;
				lookup[151] := -1;
				lookup[152] := -1;
				lookup[153] := -1;
				lookup[154] := -1;
				lookup[155] := -1;
				lookup[156] := -1;
				lookup[157] := -1;
				lookup[158] := -1;
				lookup[159] := -1;
				lookup[160] := -1;
				lookup[161] := -1;
				lookup[162] := -1;
				lookup[163] := -1;
				lookup[164] := -1;
				lookup[165] := -1;
				lookup[166] := -1;
				lookup[167] := -1;
				lookup[168] := -1;
				lookup[169] := -1;
				lookup[170] := -1;
				lookup[171] := -1;
				lookup[172] := -1;
				lookup[173] := -1;
				lookup[174] := -1;
				lookup[175] := -1;
				lookup[176] := -1;
				lookup[177] := -1;
				lookup[178] := -1;
				lookup[179] := -1;
				lookup[180] := -1;
				lookup[181] := -1;
				lookup[182] := -1;
				lookup[183] := -1;
				lookup[184] := -1;
				lookup[185] := -1;
				lookup[186] := -1;
				lookup[187] := -1;
				lookup[188] := -1;
				lookup[189] := -1;
				lookup[190] := -1;
				lookup[191] := -1;
				lookup[192] := -1;
				lookup[193] := -1;
				lookup[194] := -1;
				lookup[195] := -1;
				lookup[196] := -1;
				lookup[197] := -1;
				lookup[198] := -1;
				lookup[199] := -1;
				lookup[200] := -1;
				lookup[201] := -1;
				lookup[202] := -1;
				lookup[203] := -1;
				lookup[204] := -1;
				lookup[205] := -1;
				lookup[206] := -1;
				lookup[207] := -1;
				lookup[208] := -1;
				lookup[209] := -1;
				lookup[210] := -1;
				lookup[211] := -1;
				lookup[212] := -1;
				lookup[213] := -1;
				lookup[214] := -1;
				lookup[215] := -1;
				lookup[216] := -1;
				lookup[217] := -1;
				lookup[218] := -1;
				lookup[219] := -1;
				lookup[220] := -1;
				lookup[221] := -1;
				lookup[222] := -1;
				lookup[223] := -1;
				lookup[224] := -1;
				lookup[225] := -1;
				lookup[226] := -1;
				lookup[227] := -1;
				lookup[228] := -1;
				lookup[229] := -1;
				lookup[230] := -1;
				lookup[231] := -1;
				lookup[232] := -1;
				lookup[233] := -1;
				lookup[234] := -1;
				lookup[235] := -1;
				lookup[236] := -1;
				lookup[237] := -1;
				lookup[238] := -1;
				lookup[239] := -1;
				lookup[240] := -1;
				lookup[241] := -1;
				lookup[242] := -1;
				lookup[243] := -1;
				lookup[244] := -1;
				lookup[245] := -1;
				lookup[246] := -1;
				lookup[247] := -1;
				lookup[248] := -1;
				lookup[249] := -1;
				lookup[250] := -1;
				lookup[251] := -1;
				lookup[252] := -1;
				lookup[253] := -1;
				lookup[254] := -1;
				lookup[255] := -1;
			};
			const reader: ByteReader;
			bitsDecoded: int32 := 0;
			charDecoded: int32 := 0;
			static read(this: Base64Decoder, data: uint8[]): int32 := {
				isWhite(c: char): bool := c == ' ' || c == '\t' || c == '\n' || c == '\r';
				in: uint8[1] := {
					in[0] := (0);
				};
				reader: ByteReader := this.reader;
				bitsDecoded: typename := this.bitsDecoded;
				charDecoded: typename := this.charDecoded;
				for (i: int32 := 0; i < (data.length); ) {
					if (reader.read(reader, in) <= 0) {
						return .result := i;
					}
					else if (in[0] == ('=')) {
						bitsDecoded := bitsDecoded - 2;
					}
					else if (!isWhite(in[0])) {
						bitsDecoded := bitsDecoded + 6;
						charDecoded := charDecoded << 6;
						charDecoded := charDecoded | lookup[in[0]] & 63;
						if (bitsDecoded >= 8) {
							bitsDecoded := bitsDecoded - 8;
							data[i] := uint8(charDecoded >> bitsDecoded);
							i := i + 1;
						}
					}
				}
				return .result := data.length;
			};
			static close(this: Base64Decoder): void := {
				assert(this.bitsDecoded == 0, "unprocessed bits remaining.", this.bitsDecoded);
			};
			read(this: ByteReader, bytes: uint8[]): int32;
			static read(this: ByteReader): int32 := {
				bytes: uint8[1] := {
					bytes[0] := (0);
				};
				if (read(this, bytes) <= 0) {
					return .result := -1;
				}
				return .result := bytes[0];
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const AsciiReader: struct {
			static decode(this: AsciiReader, chars: uint32[]): int32 := {
				reader: ByteReader := this.reader;
				for (i: int32 := 0; i < (chars.length); i := i + 1) {
					value: uint8[1] := {
					};
					if (reader.read(reader, value) <= 0) {
						return .result := i;
					}
					chars[i] := (value[0]);
				}
				return .result := chars.length;
			};
			const reader: ByteReader;
			decode(this: TextReader, chars: uint32[]): int32;
			static close(this: TextReader): void := {
				Closeable.closeSafe(this.reader);
			};
			static decode(this: TextReader): int32 := {
				chars: uint32[1] := {
					chars[0] := (0);
				};
				if (decode(this, chars) <= 0) {
					return .result := -1;
				}
				return .result := chars[0] & (16777215);
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const AsciiWriter: struct {
			static encode(this: TextWriter, chars: uint32[]): void := {
				writer: ByteWriter := this.writer;
				for (i: int32 := 0; i < (chars.length); i := i + 1) {
					value: uint8[1] := {
						value[0] := (chars[i]);
					};
					writer.write(writer, value);
				}
			};
			static const Writeable: struct {
				write(this: Writeable, writer: TextWriter): void;
				const .type: typename;
				static const create(type: typename): pointer := nfc(7);
				static const destroy(this: object): void := nfc(8);
				static const as(this: object, type: typename): pointer := nfc(9);
				static const type(this: object): typename := nfc(10);
			};
			const writer: ByteWriter;
			const format: FormatFlags;
			encode(this: TextWriter, chars: uint32[]): void;
			static flush(this: TextWriter): void := {
				this.writer.flush(this.writer);
			};
			const flush(this: TextWriter): void := flush;
			static close(this: TextWriter): void := {
				Closeable.closeSafe(this.writer);
			};
			static write(this: TextWriter, value: char[]): TextWriter := {
				this.writer.write(this.writer, value);
				return .result := this;
			};
			static write(this: TextWriter, value: char): TextWriter := {
				buffer: char[1] := {
					buffer[0] := value;
				};
				return .result := write(this, buffer);
			};
			static write(this: TextWriter, value: bool): TextWriter := {
				if (value) {
					return .result := write(this, "true");
				}
				return .result := write(this, "false");
			};
			static write(this: TextWriter, value: int32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: int64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: Writeable): TextWriter := {
				value.write(value, this);
				return .result := this;
			};
			static writeln(this: TextWriter): TextWriter := {
				return .result := write(this, "\n");
			};
			static writeln(this: TextWriter, value: Writeable): TextWriter := {
				return .result := writeln(write(this, value));
			};
			static copy(writer: TextWriter, reader: TextReader): int32 := {
				buffer: uint32[1024] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					n: int32 := reader.decode(reader, buffer);
					if (n <= 0) {
						return .result := result;
					}
					encode(writer, buffer[...n]);
					result := result + n;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Utf8Reader: struct {
			static decode(this: Utf8Reader, chars: uint32[]): int32 := {
				buff: uint8[1] := {
					buff[0] := (0);
				};
				ext: uint8[3] := {
					ext[0] := (0);
				};
				reader: ByteReader := this.reader;
				for (i: int32 := 0; i < (chars.length); i := i + 1) {
					if (reader.read(reader, buff) <= 0) {
						return .result := i;
					}
					if (((buff[0]) & 128) == 0) {
						chars[i] := (buff[0]);
					}
					else if (((buff[0]) & 224) == 192) {
						if (reader.read(reader, ext[...1]) != 1) {
							error("invalid codepoint");
							return .result := i;
						}
						assert(((ext[0]) & 192) == 128, "10xxxxxx");
						chars[i] := (((buff[0]) & 31) << 6 | ((ext[0]) & 63));
					}
					else if (((buff[0]) & 240) == 224) {
						if (reader.read(reader, ext[...2]) != 2) {
							error("invalid codepoint");
							return .result := i;
						}
						assert(((ext[0]) & 192) == 128, "10xxxxxx");
						assert(((ext[1]) & 192) == 128, "10xxxxxx");
						chars[i] := (((buff[0]) & 15) << 12 | ((ext[0]) & 63) << 6 | ((ext[1]) & 63));
					}
					else if (((buff[0]) & 248) == 240) {
						if (reader.read(reader, ext[...3]) != 3) {
							error("invalid codepoint");
							return .result := i;
						}
						assert(((ext[0]) & 192) == 128, "10xxxxxx");
						assert(((ext[1]) & 192) == 128, "10xxxxxx");
						assert(((ext[2]) & 192) == 128, "10xxxxxx");
						chars[i] := (((buff[0]) & 7) << 18 | ((ext[0]) & 63) << 12 | ((ext[1]) & 63) << 6 | ((ext[2]) & 63));
					}
				}
				return .result := chars.length;
			};
			const reader: ByteReader;
			decode(this: TextReader, chars: uint32[]): int32;
			static close(this: TextReader): void := {
				Closeable.closeSafe(this.reader);
			};
			static decode(this: TextReader): int32 := {
				chars: uint32[1] := {
					chars[0] := (0);
				};
				if (decode(this, chars) <= 0) {
					return .result := -1;
				}
				return .result := chars[0] & (16777215);
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Utf8Writer: struct {
			static encode(this: Utf8Writer, chars: uint32[]): void := {
				writer: ByteWriter := this.writer;
				for (i: int32 := 0; i < (chars.length); i := i + 1) {
					cp: uint32 := chars[i];
					if (cp < (128)) {
						bytes: uint8[1] := {
							bytes[0] := (cp);
						};
						writer.write(writer, bytes[...1]);
					}
					else if (cp < (2048)) {
						bytes: uint8[2] := {
							bytes[0] := (192 | ((cp >> 6)));
							bytes[1] := (128 | ((cp & (63))));
						};
						writer.write(writer, bytes[...2]);
					}
					else if (cp < (65536)) {
						bytes: uint8[3] := {
							bytes[0] := (224 | ((cp >> 12)));
							bytes[1] := (128 | (((cp >> 6) & (63))));
							bytes[2] := (128 | ((cp & (63))));
						};
						writer.write(writer, bytes[...3]);
					}
					else {
						bytes: uint8[4] := {
							bytes[0] := (240 | ((cp >> 18)));
							bytes[1] := (128 | (((cp >> 12) & (63))));
							bytes[2] := (128 | (((cp >> 6) & (63))));
							bytes[3] := (128 | ((cp & (63))));
						};
						writer.write(writer, bytes[...4]);
					}
				}
			};
			static const Writeable: struct {
				write(this: Writeable, writer: TextWriter): void;
				const .type: typename;
				static const create(type: typename): pointer := nfc(7);
				static const destroy(this: object): void := nfc(8);
				static const as(this: object, type: typename): pointer := nfc(9);
				static const type(this: object): typename := nfc(10);
			};
			const writer: ByteWriter;
			const format: FormatFlags;
			encode(this: TextWriter, chars: uint32[]): void;
			static flush(this: TextWriter): void := {
				this.writer.flush(this.writer);
			};
			const flush(this: TextWriter): void := flush;
			static close(this: TextWriter): void := {
				Closeable.closeSafe(this.writer);
			};
			static write(this: TextWriter, value: char[]): TextWriter := {
				this.writer.write(this.writer, value);
				return .result := this;
			};
			static write(this: TextWriter, value: char): TextWriter := {
				buffer: char[1] := {
					buffer[0] := value;
				};
				return .result := write(this, buffer);
			};
			static write(this: TextWriter, value: bool): TextWriter := {
				if (value) {
					return .result := write(this, "true");
				}
				return .result := write(this, "false");
			};
			static write(this: TextWriter, value: int32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: int64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: Writeable): TextWriter := {
				value.write(value, this);
				return .result := this;
			};
			static writeln(this: TextWriter): TextWriter := {
				return .result := write(this, "\n");
			};
			static writeln(this: TextWriter, value: Writeable): TextWriter := {
				return .result := writeln(write(this, value));
			};
			static copy(writer: TextWriter, reader: TextReader): int32 := {
				buffer: uint32[1024] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					n: int32 := reader.decode(reader, buffer);
					if (n <= 0) {
						return .result := result;
					}
					encode(writer, buffer[...n]);
					result := result + n;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Easing: struct {
			static linear(t: float64): float64 := {
				return .result := t;
			};
			static quad(t: float64): float64 := {
				return .result := t * t;
			};
			static cubic(t: float64): float64 := {
				return .result := t * t * t;
			};
			static quart(t: float64): float64 := {
				return .result := t * t * t * t;
			};
			static quint(t: float64): float64 := {
				return .result := t * t * t * t * t;
			};
			static expo(t: float64): float64 := {
				return .result := t == (0) ? (0) : Math.pow(2.000000, (10) * (t - (1)));
			};
			static sine(t: float64): float64 := {
				return .result := -Math.cos(t * Math.pi / (2)) + (1);
			};
			static circle(t: float64): float64 := {
				return .result := -(Math.sqrt((1) - t * t) - (1));
			};
			static elastic(t: float64): float64 := {
				if (t == 0.000000 || t == 1.000000) {
					return .result := t;
				}
				t := t - 1.000000;
				return .result := -Math.pow(2.000000, 10.000000 * t) * Math.sin((t - 0.300000 / 4.000000) * (2.000000 * Math.pi) / 0.300000);
			};
			static back(t: float64): float64 := {
				s: typename := 1.701580;
				return .result := t * t * ((s + (1)) * t - s);
			};
			static bounce(t: float64): float64 := {
				static Helper(t: float64, c: float64, a: float64): float64 := {
					if (t == (1)) {
						return .result := c;
					}
					if (t < ((4) / 11.000000)) {
						return .result := c * (7.562500 * t * t);
					}
					if (t < ((8) / 11.000000)) {
						t := t - ((6) / 11.000000);
						return .result := -a * ((1) - (7.562500 * t * t + 0.750000)) + c;
					}
					if (t < ((10) / 11.000000)) {
						t := t - (((9) / 11.000000));
						return .result := -a * ((1) - (7.562500 * t * t + 0.937500)) + c;
					}
					t := t - ((21) / 22.000000);
					return .result := -a * ((1) - (7.562500 * t * t + 0.984375)) + c;
				};
				a: typename := 1.701580;
				return .result := (1) - Helper((1) - t, 1, a);
			};
		};
		static in(ease(ratio: float64): float64, ratio: float64): float64 := {
			if ((ease) == null) {
				return .result := ratio;
			}
			return .result := ease(ratio);
		};
		static out(ease(ratio: float64): float64, ratio: float64): float64 := {
			if ((ease) == null) {
				return .result := ratio;
			}
			return .result := 1.000000 - ease((1) - ratio);
		};
		static inOut(ease(ratio: float64): float64, ratio: float64): float64 := {
			if ((ease) == null) {
				return .result := ratio;
			}
			ratio := ratio * (2);
			return .result := (ratio < (1)) ? 0.500000 * ease(ratio) : 0.500000 * out(ease, ratio - (1)) + 0.500000;
		};
		static outIn(ease(ratio: float64): float64, ratio: float64): float64 := {
			if ((ease) == null) {
				return .result := ratio;
			}
			ratio := ratio * (2);
			return .result := (ratio < (1)) ? 0.500000 * out(ease, ratio) : 0.500000 * ease(ratio - (1)) + 0.500000;
		};
		scalar: typename := float64;
		static const Polynomial: struct {
			coefficients: float64[*];
			capacity: int32;
			static const c_zero: float64 := (0);
			static const c_unit: float64 := (1);
			static write(this: Polynomial, writer: TextWriter): void := {
				first: bool := true;
				for (i: int32 := this.capacity - 1; i >= 0; i := i - 1) {
					if (this.coefficients[i] == c_zero && !(first && i == 0)) {
						continue;
					}
					value: float64 := this.coefficients[i];
					if (value < c_zero) {
						value := -value;
						if (!first) {
							TextWriter.write(writer, " - ");
						}
						else {
							TextWriter.write(writer, "-");
						}
					}
					else if (!first) {
						TextWriter.write(writer, " + ");
					}
					if (value != c_unit || i == 0) {
						TextWriter.write(writer, value, writer.format);
					}
					if (i > 0) {
						TextWriter.write(writer, "x");
						if (i > 1) {
							TextWriter.write(writer, "^");
							TextWriter.write(writer, i, writer.format);
						}
					}
					first := false;
				}
			};
			static destroy(this: Polynomial): void := {
				pointer.alloc(this.coefficients, 0);
			};
			const destroy(this: Polynomial): void := destroy;
			static create(degree: int32, values: float64[]): Polynomial := {
				capacity: int32 := Math.max(0, degree) + 1;
				assert(capacity >= (values.length));
				coefficients: float64[*] := pointer.alloc(null, capacity * sizeof(float64));
				result: Polynomial := {
					result := create(Polynomial);
					result.coefficients := (coefficients);
					result.capacity := capacity;
					result.destroy := destroy;
					result.write := write;
				};
				for (i: int32 := 0; i < (values.length); i := i + 1) {
					result.coefficients[i] := values[i];
				}
				for (i: int32 := values.length; i < capacity; i := i + 1) {
					result.coefficients[i] := c_zero;
				}
				return .result := result;
			};
			static degree(this: Polynomial): int32 := {
				for (i: int32 := this.capacity - 1; i > 0; i := i - 1) {
					if (this.coefficients[i] != c_zero) {
						return .result := i;
					}
				}
				return .result := 0;
			};
			static get(const this: Polynomial, index: int32): float64 := {
				assert(index >= 0, "negative index", index);
				if (index >= this.capacity) {
					return .result := c_zero;
				}
				return .result := this.coefficients[index];
			};
			static set(this: Polynomial, index: int32, value: float64): float64 := {
				assert(index >= 0, "negative index", index);
				assert(index < this.capacity, "invalid index");
				return .result := this.coefficients[index];
			};
			static neg(const a: Polynomial): Polynomial := {
				result: Polynomial := create(degree(a), null);
				for (i: int32 := 0; i < result.capacity; i := i + 1) {
					result.coefficients[i] := -get(a, i);
				}
				return .result := result;
			};
			static add(const a: Polynomial, const b: Polynomial): Polynomial := {
				result: Polynomial := create(Math.max(degree(a), degree(b)), null);
				for (i: int32 := 0; i < result.capacity; i := i + 1) {
					result.coefficients[i] := get(a, i) + get(b, i);
				}
				return .result := result;
			};
			static sub(const a: Polynomial, const b: Polynomial): Polynomial := {
				result: Polynomial := create(Math.max(degree(a), degree(b)), null);
				for (i: int32 := 0; i < result.capacity; i := i + 1) {
					result.coefficients[i] := get(a, i) - get(b, i);
				}
				return .result := result;
			};
			static mul(const a: Polynomial, const b: Polynomial): Polynomial := {
				degreeA: int32 := degree(a);
				degreeB: int32 := degree(b);
				result: Polynomial := create(degreeA + degreeB, null);
				for (i: int32 := 0; i <= degreeA; i := i + 1) {
					for (j: int32 := 0; j <= degreeB; j := j + 1) {
						result.coefficients[i + j] := result.coefficients[i + j] + get(a, i) * get(b, j);
					}
				}
				return .result := result;
			};
			static evaluate(const this: Polynomial, value: float64): float64 := {
				result: float64 := c_zero;
				for (i: int32 := degree(this); i >= 0; i := i - 1) {
					result := result * value + this.coefficients[i];
				}
				return .result := result;
			};
			static derivative(const this: Polynomial): Polynomial := {
				result: Polynomial := create(degree(this) - 1, null);
				for (i: int32 := 0; i < result.capacity; i := i + 1) {
					result.coefficients[i] := ((i + 1)) * this.coefficients[i + 1];
				}
				return .result := result;
			};
			static integral(const this: Polynomial, c: float64): Polynomial := {
				result: Polynomial := create(degree(this) + 1, null);
				result.coefficients[0] := c;
				for (i: int32 := 1; i < result.capacity; i := i + 1) {
					result.coefficients[i] := this.coefficients[i - 1] / (i);
				}
				return .result := result;
			};
			write(this: Writeable, writer: TextWriter): void;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		Polynomial(const copy: Polynomial): Polynomial := Polynomial.create(Polynomial.degree(copy), copy.coefficients);
		static Polynomial(values: float64[]): Polynomial := {
			result: Polynomial := Polynomial.create(values.length - (1), null);
			for (i: int32 := 0; i < (values.length); i := i + 1) {
				result.coefficients[i] := values[values.length - (i) - (1)];
			}
			return .result := result;
		};
	}
	{
		static read(file: File): int32 := {
			buff: uint8[1] := {
				buff[0] := (0);
			};
			if (File.read(file, buff) <= 0) {
				return .result := -1;
			}
			return .result := (buff[0]) & 255;
		};
		static write(file: File, value: int32): int32 := {
			buff: uint8[1] := {
				buff[0] := (value);
			};
			return .result := File.write(file, buff);
		};
		static if (typename(Closeable) == object) {
			static const FileReader: struct {
				const file: File;
				static read(this: FileReader, bytes: uint8[]): int32 := {
					return .result := File.read(this.file, bytes);
				};
				static close(this: FileReader): void := {
					File.close(this.file);
				};
				read(this: ByteReader, bytes: uint8[]): int32;
				static read(this: ByteReader): int32 := {
					bytes: uint8[1] := {
						bytes[0] := (0);
					};
					if (read(this, bytes) <= 0) {
						return .result := -1;
					}
					return .result := bytes[0];
				};
				close(this: Closeable): void;
				static closeSafe(this: Closeable): void := {
					if ((this.close) == null) {
						return;
					}
					this.close(this);
				};
				const .type: typename;
				static const create(type: typename): pointer := nfc(7);
				static const destroy(this: object): void := nfc(8);
				static const as(this: object, type: typename): pointer := nfc(9);
				static const type(this: object): typename := nfc(10);
			};
			static const FileWriter: struct {
				const file: File;
				static write(this: FileWriter, bytes: uint8[]): void := {
					wrote: int32 := File.write(this.file, bytes);
					assert(wrote == (bytes.length));
				};
				static flush(this: FileWriter): void := {
					File.flush(this.file);
				};
				static close(this: FileWriter): void := {
					File.close(this.file);
				};
				write(this: ByteWriter, bytes: uint8[]): void;
				flush(this: ByteWriter): void;
				static write(this: ByteWriter, oneByte: uint8): void := {
					bytes: uint8[1] := {
						bytes[0] := oneByte;
					};
					return .result := this.write(this, bytes);
				};
				static copy(this: ByteWriter, reader: ByteReader): int32 := {
					buffer: uint8[4096] := {
					};
					result: int32 := 0;
					for ( ; ; ) {
						read: int32 := reader.read(reader, buffer);
						if (read <= 0) {
							return .result := result;
						}
						this.write(this, buffer[...read]);
						result := result + read;
					}
					return .result := result;
				};
				close(this: Closeable): void;
				static closeSafe(this: Closeable): void := {
					if ((this.close) == null) {
						return;
					}
					this.close(this);
				};
				const .type: typename;
				static const create(type: typename): pointer := nfc(7);
				static const destroy(this: object): void := nfc(8);
				static const as(this: object, type: typename): pointer := nfc(9);
				static const type(this: object): typename := nfc(10);
			};
			static const BufferedFileWriter: struct {
				buffer: uint8[1024];
				bufferSize: int32 := 0;
				static flushBuffer(this: BufferedFileWriter): void := {
					wrote: int32 := File.write(this.file, this.buffer[...this.bufferSize]);
					assert(wrote == this.bufferSize);
					this.bufferSize := 0;
				};
				static write(this: BufferedFileWriter, bytes: uint8[]): void := {
					if (this.bufferSize + (bytes.length) > this.buffer.(length)) {
						if (this.bufferSize > 0) {
							flushBuffer(this);
						}
						if (bytes.length > (this.buffer.(length) / 2)) {
							FileWriter.write(this, bytes);
							return;
						}
					}
					buffer: uint8[*] := this.buffer;
					bufferSize: int32 := this.bufferSize;
					for (i: int32 := 0; i < (bytes.length); i := i + 1) {
						buffer[bufferSize + i] := bytes[i];
					}
					this.bufferSize := this.bufferSize + (bytes.length);
				};
				static flush(this: BufferedFileWriter): void := {
					flushBuffer(this);
					FileWriter.flush(this);
				};
				static close(this: BufferedFileWriter): void := {
					flushBuffer(this);
					FileWriter.close(this);
				};
				const file: File;
				static write(this: FileWriter, bytes: uint8[]): void := {
					wrote: int32 := File.write(this.file, bytes);
					assert(wrote == (bytes.length));
				};
				static flush(this: FileWriter): void := {
					File.flush(this.file);
				};
				static close(this: FileWriter): void := {
					File.close(this.file);
				};
				write(this: ByteWriter, bytes: uint8[]): void;
				flush(this: ByteWriter): void;
				static write(this: ByteWriter, oneByte: uint8): void := {
					bytes: uint8[1] := {
						bytes[0] := oneByte;
					};
					return .result := this.write(this, bytes);
				};
				static copy(this: ByteWriter, reader: ByteReader): int32 := {
					buffer: uint8[4096] := {
					};
					result: int32 := 0;
					for ( ; ; ) {
						read: int32 := reader.read(reader, buffer);
						if (read <= 0) {
							return .result := result;
						}
						this.write(this, buffer[...read]);
						result := result + read;
					}
					return .result := result;
				};
				close(this: Closeable): void;
				static closeSafe(this: Closeable): void := {
					if ((this.close) == null) {
						return;
					}
					this.close(this);
				};
				const .type: typename;
				static const create(type: typename): pointer := nfc(7);
				static const destroy(this: object): void := nfc(8);
				static const as(this: object, type: typename): pointer := nfc(9);
				static const type(this: object): typename := nfc(10);
			};
			static FileReader(const path: char[*]): FileReader := {
				return .result := {
			.result := create(FileReader);
			.result.file := File.open(path);
			.result.read := read;
			.result.close := close;
		};
			};
			static FileWriter(const path: char[*], append: bool): FileWriter := {
				return .result := {
			.result := create(FileWriter);
			.result.file := append ? File.append(path) : File.create(path);
			.result.write := write;
			.result.flush := flush;
			.result.close := close;
		};
			};
			static BufferedFileWriter(const path: char[*], append: bool): BufferedFileWriter := {
				return .result := {
			.result := create(BufferedFileWriter);
			.result.buffer := (null);
			.result.file := append ? File.append(path) : File.create(path);
			.result.bufferSize := 0;
			.result.write := write;
			.result.flush := flush;
			.result.close := close;
		};
			};
		}
	}
	{
		static const Rect: struct {
			x0: int32 := 0;
			y0: int32 := 0;
			x1: int32 := 0;
			y1: int32 := 0;
		};
	}
	{
		static empty(const rectangle: Rect): bool := {
			return .result := rectangle.x0 >= rectangle.x1 || rectangle.y0 >= rectangle.y1;
		};
		static contains(const rect: Rect, x: int32, y: int32): bool := {
			return .result := x >= rect.x0 && x < rect.x1 && y >= rect.y0 && y < rect.y1;
		};
		width(const rectangle: Rect): int32 := rectangle.x1 - rectangle.x0;
		static width(rectangle: Rect, width: int32): void := {
			rectangle.x1 := rectangle.x0 + width;
		};
		height(const rectangle: Rect): int32 := rectangle.y1 - rectangle.y0;
		static height(rectangle: Rect, height: int32): void := {
			rectangle.y1 := rectangle.y0 + height;
		};
		static setSize(rectangle: Rect, width: int32, height: int32): void := {
			rectangle.x1 := rectangle.x0 + width;
			rectangle.y1 := rectangle.y0 + height;
		};
		static positionX(rectangle: Rect, x: int32): void := {
			rectangle.x1 := x + rectangle.x1 - rectangle.x0;
			rectangle.x0 := x;
		};
		static positionY(rectangle: Rect, y: int32): void := {
			rectangle.y1 := y + rectangle.y1 - rectangle.y0;
			rectangle.y0 := y;
		};
		static position(rectangle: Rect, x: int32, y: int32): void := {
			positionX(rectangle, x);
			positionY(rectangle, y);
		};
		static adjust(rect: Rect, dx0: int32, dy0: int32, dx1: int32, dy1: int32): void := {
			rect.x0 := rect.x0 + dx0;
			rect.y0 := rect.y0 + dy0;
			rect.x1 := rect.x1 + dx1;
			rect.y1 := rect.y1 + dy1;
		};
		static padded(rect: Rect, padding: int32): void := {
			rect.x0 := rect.x0 - padding;
			rect.y0 := rect.y0 - padding;
			rect.x1 := rect.x1 + padding;
			rect.y1 := rect.y1 + padding;
		};
		translate(rectangle: Rect, dx: int32, dy: int32): void := adjust(rectangle, dx, dy, dx, dy);
		static translateX(rectangle: Rect, dx: int32): void := {
			rectangle.x0 := rectangle.x0 + dx;
			rectangle.x1 := rectangle.x1 + dx;
		};
		static translateY(rectangle: Rect, dy: int32): void := {
			rectangle.y0 := rectangle.y0 + dy;
			rectangle.y1 := rectangle.y1 + dy;
		};
		static const argb: struct {
			v: uint32;
			<?>: <?>;
			b: uint8 := b: uint8;
			g: uint8 := g: uint8;
			r: uint8 := r: uint8;
			a: uint8 := a: uint8;
		};
		argb(argb: uint32): argb := argb(emit(struct(argb)));
		uint32(value: argb): uint32 := uint32(emit(struct(value)));
		sat_s8(c: int32): uint32 := uint32(c > 255 ? 255 : c < 0 ? 0 : c);
		sat_u8(c: uint32): uint32 := uint32(c > (255) ? 255 : (c));
		pack(c: uint32): argb := argb((((c << 8) | c) << 8) | c);
		pack(r: uint32, g: uint32, b: uint32): argb := argb((((r << 8) | g) << 8) | b);
		pack(a: uint32, r: uint32, g: uint32, b: uint32): argb := argb((((((a << 8) | r) << 8) | g) << 8) | b);
		gray(c: int32): argb := pack(sat_s8(c));
		gray(c: uint32): argb := pack(sat_s8(c));
		gray(c: float32): argb := gray(int32(c * (255)));
		gray(c: float64): argb := gray(int32(c * (255)));
		argb(r: int32, g: int32, b: int32): argb := pack(sat_s8(r), sat_s8(g), sat_s8(b));
		argb(r: uint32, g: uint32, b: uint32): argb := pack(sat_u8(r), sat_u8(g), sat_u8(b));
		argb(r: float32, g: float32, b: float32): argb := argb(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		argb(r: float64, g: float64, b: float64): argb := argb(int32(r * (255)), int32(g * (255)), int32(b * (255)));
		argb(a: int32, r: int32, g: int32, b: int32): argb := pack(sat_s8(a), sat_s8(r), sat_s8(g), sat_s8(b));
		argb(a: uint32, r: uint32, g: uint32, b: uint32): argb := pack(sat_u8(a), sat_u8(r), sat_u8(g), sat_u8(b));
		argb(a: float32, r: float32, g: float32, b: float32): argb := argb(int32(a * (255)), int32(r * (255)), int32(g * (255)), int32(b * (255)));
		argb(a: float64, r: float64, g: float64, b: float64): argb := argb(int32(a * (255)), int32(r * (255)), int32(g * (255)), int32(b * (255)));
		ach(color: argb): int32 := int32((uint32(color) >> 24));
		rch(color: argb): int32 := int32(uint32(color) >> 16 & (255));
		gch(color: argb): int32 := int32(uint32(color) >> 8 & (255));
		bch(color: argb): int32 := int32(uint32(color) & (255));
		lum(color: argb): int32 := int32((19595 * rch(color) + 38470 * gch(color) + 7471 * bch(color)) >> 16);
		static hue(rgb: argb): uint32 := {
			r: int32 := rch(rgb);
			g: int32 := gch(rgb);
			b: int32 := bch(rgb);
			min: int32 := r;
			max: int32 := r;
			if (min > g) {
				min := g;
			}
			if (min > b) {
				min := b;
			}
			if (max < g) {
				max := g;
			}
			if (max < b) {
				max := b;
			}
			if (max == min) {
				return .result := 0;
			}
			hue: int32 := 0;
			if (max == r) {
				hue := ((g - b) * 60) / (max - min);
			}
			else if (max == g) {
				hue := ((b - r) * 60) / (max - min) + 120;
			}
			else if (max == b) {
				hue := ((r - g) * 60) / (max - min) + 240;
			}
			if (hue < 0) {
				hue := hue + 360;
			}
			return .result := hue;
		};
		mix_s8(t: int32, a: uint32, b: uint32): int32 := int32(a + ((t * ((b - a + (1))) >> 8)));
		mix_s16(t: int32, a: uint32, b: uint32): int32 := int32(a + ((t * ((b - a + (1))) >> 16)));
		mix_rgb8(t: int32, a: argb, b: argb): argb := argb(mix_s8(t, rch(a), rch(b)), mix_s8(t, gch(a), gch(b)), mix_s8(t, bch(a), bch(b)));
		static lerpLut(lut: argb[], colors: argb[]): void := {
			dt: int32 := (colors.length - (1) << 16) / (lut.length - (1));
			for (i: int32 := 0; i < (lut.length); i := i + 1) {
				t: int32 := i * dt;
				c1: argb := colors[t >> 16];
				c2: argb := colors[(t >> 16) + 1];
				a: int32 := mix_s16(t & 65535, ach(c1), ach(c2));
				r: int32 := mix_s16(t & 65535, rch(c1), rch(c2));
				g: int32 := mix_s16(t & 65535, gch(c1), gch(c2));
				b: int32 := mix_s16(t & 65535, bch(c1), bch(c2));
				lut[i].v := (a << 24 | r << 16 | g << 8 | b);
			}
		};
		static alphaLut(lut: uint32[], hardness: int32, alpha: int32, reflect: bool): void := {
			mid: int32 := hardness <= 0 ? -1 : 255;
			div: int32 := 256 - (sat_u8(hardness < 0 ? -hardness : hardness));
			for (i: int32 := 0; i < (lut.length); i := i + 1) {
				t: int32 := i * 255 / ((lut.length - (1)));
				lut[i] := sat_s8((t - mid) * 255 / div + mid);
				if (alpha < 0) {
					lut[i] := (255 - (255 - (lut[i])) * -alpha / 255);
				}
				else {
					lut[i] := (255 - (lut[i] * (alpha) / (255)));
				}
			}
			if (reflect) {
				end: int32 := lut.length - (1);
				mid: int32 := lut.length / (2);
				for (i: int32 := end; i >= mid; i := i - 1) {
					lut[i] := lut[end];
					end := end - 2;
				}
				for (i: int32 := 0; i < mid; i := i + 1) {
					lut[i] := lut[lut.length - (i) - (1)];
				}
			}
		};
		static if ((typename(vec4f)) != null) {
			vec4f(rgb: argb): vec4f := vec4f((rch(rgb)) / 255.000000, (gch(rgb)) / 255.000000, (bch(rgb)) / 255.000000, (ach(rgb)) / 255.000000);
			argb(const vec: vec4f): argb := argb(vec.w, vec.x, vec.y, vec.z);
			lum(const vec: vec4f): float32 := 0.299000 * vec.x + 0.587000 * vec.y + 0.114000 * vec.z;
			static rgb2hsl(rgb: vec4f): vec4f := {
				min(x: float32, y: float32): float32 := x < y ? x : y;
				max(x: float32, y: float32): float32 := x > y ? x : y;
				clamp(value: float32, min: float32, max: float32): float32 := min(max(value, min), max);
				fmin: float32 := min(min(rgb.x, rgb.y), rgb.z);
				fmax: float32 := max(max(rgb.x, rgb.y), rgb.z);
				delta: float32 := fmax - fmin;
				lum: float32 := (fmax + fmin) / (2);
				if (delta == (0)) {
					return .result := {
			.result.x := (0);
			.result.y := (0);
			.result.z := lum;
		};
				}
				sat: float32;
				if (lum < 0.500000) {
					sat := delta / (fmax + fmin);
				}
				else {
					sat := delta / ((2) - fmax - fmin);
				}
				deltaR: float32 := (((fmax - rgb.x) / (6)) + (delta / (2))) / delta;
				deltaG: float32 := (((fmax - rgb.y) / (6)) + (delta / (2))) / delta;
				deltaB: float32 := (((fmax - rgb.z) / (6)) + (delta / (2))) / delta;
				hue: float32;
				if (rgb.x == fmax) {
					hue := deltaB - deltaG;
				}
				else if (rgb.y == fmax) {
					hue := ((1) / 3.000000) + deltaR - deltaB;
				}
				else if (rgb.z == fmax) {
					hue := ((2) / 3.000000) + deltaG - deltaR;
				}
				if (hue < (0)) {
					hue := hue + (1);
				}
				else if (hue > (1)) {
					hue := hue - (1);
				}
				return .result := {
			.result.x := clamp(hue, 0, 1);
			.result.y := clamp(sat, 0, 1);
			.result.z := clamp(lum, 0, 1);
		};
			};
			static hsl2rgb(hsl: vec4f): vec4f := {
				static hue2rgb(f1: float32, f2: float32, hue: float32): float32 := {
					if (hue < (0)) {
						hue := hue + (1);
					}
					else if (hue > (1)) {
						hue := hue - (1);
					}
					if (hue < 1.000000 / (6)) {
						return .result := f1 + (f2 - f1) * (6) * hue;
					}
					if (hue < 1.000000 / (2)) {
						return .result := f2;
					}
					if (hue < 2.000000 / (3)) {
						return .result := f1 + (f2 - f1) * (((2) / 3.000000) - hue) * (6);
					}
					return .result := f1;
				};
				if (hsl.y == (0)) {
					return .result := vec4f(hsl.z);
				}
				f2: float32;
				if (hsl.z < 0.500000) {
					f2 := hsl.z * ((1) + hsl.y);
				}
				else {
					f2 := (hsl.z + hsl.y) - (hsl.y * hsl.z);
				}
				f1: float32 := (2) * hsl.z - f2;
				return .result := {
			.result.x := hue2rgb(f1, f2, hsl.x + ((1) / 3.000000));
			.result.y := hue2rgb(f1, f2, hsl.x);
			.result.z := hue2rgb(f1, f2, hsl.x - ((1) / 3.000000));
		};
			};
		}
		Image(width: int32, height: int32, depth: int32): Image := Image.create(width, height, depth);
		static Image(const fileName: char[*], depth: int32): Image := {
			static if ((typename(Image.openPng)) != null) {
				if (endsWith(fileName, ".png", ignCaseCmp)) {
					return .result := Image.openPng(fileName, depth);
				}
			}
			static if ((typename(Image.openJpg)) != null) {
				if (endsWith(fileName, ".jpeg", ignCaseCmp)) {
					return .result := Image.openJpg(fileName, depth);
				}
				if (endsWith(fileName, ".jpg", ignCaseCmp)) {
					return .result := Image.openJpg(fileName, depth);
				}
			}
			static if ((typename(Image.openBmp)) != null) {
				if (endsWith(fileName, ".bmp", ignCaseCmp)) {
					return .result := Image.openBmp(fileName, depth);
				}
			}
			return .result := Image.openImg(fileName, depth);
		};
		Image(const fileName: char[*]): Image := Image(fileName, 32);
		static clip(image: Image, roi: Rect): bool := {
			if (roi.x0 < 0) {
				roi.x0 := 0;
			}
			if (roi.y0 < 0) {
				roi.y0 := 0;
			}
			width: int32 := Image.width(image);
			if (roi.x1 > width) {
				roi.x1 := width;
			}
			height: int32 := Image.height(image);
			if (roi.y1 > height) {
				roi.y1 := height;
			}
			return .result := !empty(roi);
		};
		set(image: Image, x: int32, y: int32, color: argb): void := Image.set(image, x, y, uint32(color));
		static if ((typename(drawAntiAliased)) == null) {
			drawAntiAliased: typename := true;
		}
		static fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, incl: int32, color: uint32): void := {
			static if ((preferNativeCalls) && (typename(Image.fillRect)) != null) {
				return .result := Image.fillRect(image, x0, y0, x1, y1, incl, color);
			}
			if (x0 > x1) {
				t: int32 := x0;
				x0 := x1;
				x1 := t;
			}
			if (y0 > y1) {
				t: int32 := y0;
				y0 := y1;
				y1 := t;
			}
			x1 := x1 + incl;
			y1 := y1 + incl;
			for (y: int32 := y0; y < y1; y := y + 1) {
				for (x: int32 := x0; x < x1; x := x + 1) {
					Image.set(image, x, y, color);
				}
			}
		};
		fillRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void := fillRect(image, x0, y0, x1, y1, 0, color);
		static drawRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, width: int32, color: uint32): void := {
			if (y0 > y1) {
				t: int32 := y1;
				y1 := y0;
				y0 := t;
			}
			if (x0 > x1) {
				t: int32 := x1;
				x1 := x0;
				x0 := t;
			}
			half1: int32 := (width - 0) / 2;
			half2: int32 := (width - 1) / 2;
			x0 := x0 - half1;
			y0 := y0 - half1;
			x1 := x1 + half2;
			y1 := y1 + half2;
			if (x1 - x0 <= 2 * width || y1 - y0 <= 2 * width) {
				return .result := fillRect(image, x0, y0, x1, y1, color);
			}
			fillRect(image, x0, y0, x1, y0 + width, color);
			fillRect(image, x0, y0 + width, x0 + width, y1 - width, color);
			fillRect(image, x1 - width, y0 + width, x1, y1 - width, color);
			fillRect(image, x0, y1 - width, x1, y1, color);
		};
		drawRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void := drawRect(image, x0, y0, x1, y1, 1, color);
		static fillRect(image: Image, const roi: Rect, color: uint32): void := {
			if (empty(roi)) {
				return;
			}
			fillRect(image, roi.x0, roi.y0, roi.x1, roi.y1, color);
		};
		static drawRect(image: Image, const roi: Rect, color: uint32): void := {
			if (empty(roi)) {
				return;
			}
			drawRect(image, roi.x0, roi.y0, roi.x1, roi.y1, 1, color);
		};
		static fillRRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, rx: int32, ry: int32, color: uint32): void := {
			if (x0 > x1) {
				t: int32 := x0;
				x0 := x1;
				x1 := t;
			}
			if (y0 > y1) {
				t: int32 := y0;
				y0 := y1;
				y1 := t;
			}
			x1 := x1 - int32(x1 > x0);
			y1 := y1 - int32(y1 > y0);
			dx: int32 := x1 - x0;
			dy: int32 := y1 - y0;
			if (dx < 3 || dy < 3) {
				return .result := fillRect(image, x0, y0, x1, y1, 1, color);
			}
			ry := Math.min(ry, (dy - int32(dx > 16)) / 2);
			rx := Math.min(rx, (dx - int32(dy > 16)) / 2);
			if (rx < 8 || ry < 8) {
				if (rx < 1 || ry < 1) {
					return .result := fillRect(image, x0, y0, x1, y1, 1, color);
				}
				rx := rx + int32(rx == 7) - int32(rx == 6);
				ry := ry + int32(ry == 7) - int32(ry == 6);
			}
			sx: int64 := rx * rx;
			sy: int64 := ry * ry;
			rdy: int64 := sx * (ry);
			rdx: int64 := 0;
			r: int64 := rdy / (2);
			x0 := x0 + rx;
			x1 := x1 - rx;
			for ( ; y0 < y1; ) {
				fillRect(image, x0, y0, x1, y0, 1, color);
				fillRect(image, x0, y1, x1, y1, 1, color);
				if (r >= (0)) {
					x0 := x0 - 1;
					x1 := x1 + 1;
					r := r - (rdx := rdx + sy);
				}
				if (r < (0)) {
					y0 := y0 + 1;
					y1 := y1 - 1;
					r := r + (rdy := rdy - sx);
				}
			}
			fillRect(image, x0, y0, x1, y1, 1, color);
		};
		static drawRRect(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, rx: int32, ry: int32, color: uint32): void := {
			if (x0 > x1) {
				t: int32 := x0;
				x0 := x1;
				x1 := t;
			}
			if (y0 > y1) {
				t: int32 := y0;
				y0 := y1;
				y1 := t;
			}
			x1 := x1 - int32(x1 > x0);
			y1 := y1 - int32(y1 > y0);
			dx: int32 := x1 - x0;
			dy: int32 := y1 - y0;
			if (dx < 2 || dy < 2) {
				return .result := fillRect(image, x0, y0, x1, y1, 1, color);
			}
			ry := Math.min(ry, (dy - int32(dx > 16)) / 2);
			rx := Math.min(rx, (dx - int32(dy > 16)) / 2);
			if (rx < 8 || ry < 8) {
				if (rx < 1 || ry < 1) {
					return .result := drawRect(image, x0, y0, x1 + 1, y1 + 1, 1, color);
				}
				rx := rx + int32(rx == 7) - int32(rx == 6);
				ry := ry + int32(ry == 7) - int32(ry == 6);
			}
			sx: int64 := rx * rx;
			sy: int64 := ry * ry;
			rdy: int64 := sx * (ry);
			rdx: int64 := 0;
			r: int64 := rdy / (2);
			x0 := x0 + rx;
			x1 := x1 - rx;
			fillRect(image, x0, y0, x1, y0, 1, color);
			fillRect(image, x0, y1, x1, y1, 1, color);
			for ( ; y0 < y1; ) {
				Image.set(image, x0, y0, color);
				Image.set(image, x1, y0, color);
				Image.set(image, x0, y1, color);
				Image.set(image, x1, y1, color);
				if (r >= (0)) {
					x0 := x0 - 1;
					x1 := x1 + 1;
					r := r - (rdx := rdx + sy);
				}
				if (r < (0)) {
					y0 := y0 + 1;
					y1 := y1 - 1;
					r := r + (rdy := rdy - sx);
				}
			}
			fillRect(image, x0, y0, x0, y1, 1, color);
			fillRect(image, x1, y0, x1, y1, 1, color);
		};
		fillRRect(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, r: int32, color: uint32): void := fillRRect(image, x1, y1, x2, y2, r, r, color);
		drawRRect(image: Image, x1: int32, y1: int32, x2: int32, y2: int32, r: int32, color: uint32): void := drawRRect(image, x1, y1, x2, y2, r, r, color);
		static fillRRect(image: Image, const roi: Rect, rx: int32, ry: int32, color: uint32): void := {
			if (empty(roi)) {
				return;
			}
			fillRRect(image, roi.x0, roi.y0, roi.x1, roi.y1, rx, ry, color);
		};
		fillRRect(image: Image, const roi: Rect, r: int32, color: uint32): void := fillRRect(image, roi, r, r, color);
		fillOval(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void := fillRRect(image, x0, y0, x1, y1, Math.abs(x0 - x1), Math.abs(y0 - y1), color);
		drawOval(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void := drawRRect(image, x0, y0, x1, y1, Math.abs(x0 - x1), Math.abs(y0 - y1), color);
		static fillOval(image: Image, const roi: Rect, color: uint32): void := {
			if (empty(roi)) {
				return;
			}
			fillOval(image, roi.x0, roi.y0, roi.x1, roi.y1, color);
		};
		static drawOval(image: Image, const roi: Rect, color: uint32): void := {
			if (empty(roi)) {
				return;
			}
			drawOval(image, roi.x0, roi.y0, roi.x1, roi.y1, color);
		};
		static drawLineIncl(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void := {
			mix(image: Image, x0: int32, y0: int32, alpha: int32, color: uint32): void := set(image, x0, y0, mix_rgb8(alpha, argb(uint32(Image.get(image, x0, y0))), argb(color)));
			if (x0 == x1 || y0 == y1) {
				return .result := fillRect(image, x0, y0, x1, y1, 1, color);
			}
			dx: int32 := x1 - x0;
			dy: int32 := y1 - y0;
			if (Math.abs(dx) > Math.abs(dy)) {
				if (x0 > x1) {
					x: int32 := x0;
					x0 := x1;
					x1 := x;
					y0 := y1;
				}
				y: int32 := y0 << 16;
				dy := (dy << 16) / dx;
				if (x1 > Image.width(image)) {
					x1 := Image.width(image);
				}
				if (x0 < 0) {
					y := y - dy * x0;
					x0 := 0;
				}
				static if (true) {
					for (x: int32 := x0; x <= x1; x := x + 1) {
						alpha: uint32 := (~y >> 8) & 255;
						mix(image, x, y >> 16, alpha, color);
						mix(image, x, (y >> 16) + 1, 255 - (alpha), color);
						y := y + dy;
					}
				}
				else {
					y := y + 32768;
					for (x: int32 := x0; x <= x1; x := x + 1) {
						Image.set(image, x, y >> 16, color);
						y := y + dy;
					}
				}
			}
			else {
				if (y0 > y1) {
					y: int32 := y0;
					y0 := y1;
					y1 := y;
					x0 := x1;
				}
				x: int32 := x0 << 16;
				dx := (dx << 16) / dy;
				if (y1 > Image.height(image)) {
					y1 := Image.height(image);
				}
				if (y0 < 0) {
					x := x - dx * y0;
					y0 := 0;
				}
				static if (true) {
					for (y: int32 := y0; y <= y1; y := y + 1) {
						alpha: int32 := (~x >> 8) & 255;
						mix(image, x >> 16, y, alpha, color);
						mix(image, (x >> 16) + 1, y, 255 - alpha, color);
						x := x + dx;
					}
				}
				else {
					x := x + 32768;
					for (y: int32 := y0; y <= y1; y := y + 1) {
						Image.set(image, x >> 16, y, color);
						x := x + dx;
					}
				}
			}
		};
		static drawLine(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, color: uint32): void := {
			p(a: int32, b: int32): int32 := a - int32(b < a);
			return .result := drawLineIncl(image, p(x0, x1), p(y0, y1), p(x1, x0), p(y1, y0), color);
		};
		static drawBezier(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, x2: int32, y2: int32, color: uint32): void := {
			px_0: int32 := x0;
			py_0: int32 := y0;
			px_1: int32 := 2 * (x1 - x0);
			py_1: int32 := 2 * (y1 - y0);
			px_2: int32 := x2 - 2 * x1 + x0;
			py_2: int32 := y2 - 2 * y1 + y0;
			dt: float64 := 1.000000 / (128);
			for (t: float64 := dt; t < (1); t := t + dt) {
				x1 := (((px_2) * t + (px_1)) * t + (px_0));
				y1 := (((py_2) * t + (py_1)) * t + (py_0));
				drawLineIncl(image, x0, y0, x1, y1, color);
				x0 := x1;
				y0 := y1;
			}
			drawLine(image, x0, y0, x2, y2, color);
		};
		static drawBezier(image: Image, x0: int32, y0: int32, x1: int32, y1: int32, x2: int32, y2: int32, x3: int32, y3: int32, color: uint32): void := {
			px_0: int32 := x0;
			py_0: int32 := y0;
			px_1: int32 := 3 * (x1 - x0);
			py_1: int32 := 3 * (y1 - y0);
			px_2: int32 := 3 * (x2 - x1) - px_1;
			py_2: int32 := 3 * (y2 - y1) - py_1;
			px_3: int32 := x3 - px_2 - px_1 - px_0;
			py_3: int32 := y3 - py_2 - py_1 - py_0;
			dt: float64 := 1.000000 / (128);
			for (t: float64 := dt; t < (1); t := t + dt) {
				x1 := ((((px_3) * t + (px_2)) * t + (px_1)) * t + (px_0));
				y1 := ((((py_3) * t + (py_2)) * t + (py_1)) * t + (py_0));
				drawLineIncl(image, x0, y0, x1, y1, color);
				x0 := x1;
				y0 := y1;
			}
			drawLine(image, x0, y0, x3, y3, color);
		};
		static fill(image: Image, color: uint32): Image := {
			fillRect(image, 0, 0, Image.width(image), Image.height(image), color);
			return .result := image;
		};
		static drawText(image: Image, x: int32, y: int32, font: Image, const text: char[*], color: int32): void := {
			rect: Rect := {
				rect.x0 := x;
				rect.y0 := y;
				rect.x1 := Image.width(image);
				rect.y1 := Image.height(image);
			};
			return .result := Image.drawText(image, rect, font, text, color);
		};
		static blend(image: Image, x0: int32, y0: int32, const src: Image, const roi: Rect, extra: pointer, blend(extra: pointer, base: argb, with: argb): argb): void := {
			static if ((preferNativeCalls) && (typename(Image.blend)) != null) {
				return .result := Image.blend(image, x0, y0, src, roi, extra, pointer(blend));
			}
			rect: Rect := {
				rect.x0 := (roi) != null ? roi.x0 : 0;
				rect.y0 := (roi) != null ? roi.y0 : 0;
				rect.x1 := (roi) != null ? roi.x1 : Image.width(src);
				rect.y1 := (roi) != null ? roi.y1 : Image.height(src);
			};
			if (x0 < 0) {
				rect.x0 := rect.x0 - x0;
			}
			if (y0 < 0) {
				rect.y0 := rect.y0 - y0;
			}
			if (!clip(src, &rect)) {
				return;
			}
			positionX(rect, x0 < 0 ? 0 : x0);
			positionY(rect, y0 < 0 ? 0 : y0);
			if (!clip(image, &rect)) {
				return;
			}
			assert(Image.depth(image) == 32 && Image.depth(src) == 32);
			if ((blend) == null) {
				for (y: int32 := rect.y0; y < rect.y1; y := y + 1) {
					for (x: int32 := rect.x0; x < rect.x1; x := x + 1) {
						Image.set(image, x, y, Image.get(src, x - x0, y - y0));
					}
				}
				return;
			}
			for (y: int32 := rect.y0; y < rect.y1; y := y + 1) {
				for (x: int32 := rect.x0; x < rect.x1; x := x + 1) {
					base: argb := argb(Image.get(image, x, y));
					with: argb := argb(Image.get(src, x - x0, y - y0));
					set(image, x, y, blend(extra, base, with));
				}
			}
		};
		static blend(image: Image, x0: int32, y0: int32, const src: Image, const roi: Rect, blend(base: vec4f, with: vec4f): vec4f): void := {
			static if ((preferNativeCalls) && (typename(Image.blend.blendVec4f)) != null) {
				return .result := Image.blend(image, x0, y0, src, roi, blend, Image.blend.blendVec4f);
			}
			static blendVec4f(blend(base: vec4f, with: vec4f): vec4f, base: argb, with: argb): argb := {
				return .result := argb(blend(vec4f(base), vec4f(with)));
			};
			if ((blend) == null) {
				return .result := blend(image, x0, y0, src, roi, null, null);
			}
			return .result := blend(image, x0, y0, src, roi, blend, blendVec4f);
		};
		static blend(image: Image, const roi: Rect, col: argb): void := {
			static if ((preferNativeCalls) && (typename(Image.blend.color)) != null) {
				return .result := Image.blend(image, (roi) != null ? roi.x0 : 0, (roi) != null ? roi.y0 : 0, image, roi, col, Image.blend.color);
			}
			static blender(const color: argb, base: argb, with: argb): argb := {
				alpha: int32 := ach(color);
				return .result := {
			.result.b := (mix_s8(alpha, bch(color), bch(base)));
			.result.g := (mix_s8(alpha, gch(color), gch(base)));
			.result.r := (mix_s8(alpha, rch(color), rch(base)));
			.result.a := (alpha);
		};
			};
			return .result := blend(image, (roi) != null ? roi.x0 : 0, (roi) != null ? roi.y0 : 0, image, roi, col, blender);
		};
		static blendAlpha(image: Image, x: int32, y: int32, const src: Image, const roi: Rect, alpha: int32): void := {
			static if ((preferNativeCalls) && (typename(Image.blend.alpha)) != null) {
				return .result := Image.blend(image, x, y, src, roi, alpha, Image.blend.alpha);
			}
			static blender(const alpha: int32, base: argb, with: argb): argb := {
				return .result := {
			.result.b := (sat_s8(mix_s8(alpha, bch(base), bch(with))));
			.result.g := (sat_s8(mix_s8(alpha, gch(base), gch(with))));
			.result.r := (sat_s8(mix_s8(alpha, rch(base), rch(with))));
			.result.a := (alpha);
		};
			};
			return .result := blend(image, x, y, src, roi, alpha, blender);
		};
		static blendDstAlpha(image: Image, x: int32, y: int32, const src: Image, const roi: Rect): void := {
			static if ((preferNativeCalls) && (typename(Image.blend.dstAlpha)) != null) {
				return .result := Image.blend(image, x, y, src, roi, null, Image.blend.dstAlpha);
			}
			static blender(null: pointer, base: argb, with: argb): argb := {
				alpha: int32 := ach(base);
				return .result := {
			.result.b := (mix_s8(alpha, bch(base), bch(with)));
			.result.g := (mix_s8(alpha, gch(base), gch(with)));
			.result.r := (mix_s8(alpha, rch(base), rch(with)));
			.result.a := (alpha);
		};
			};
			return .result := blend(image, x, y, src, roi, null, blender);
		};
		static copy(image: Image, x: int32, y: int32, src: Image, const roi: Rect): void := {
			return .result := blend(image, x, y, src, roi, null, null);
		};
		static Image(copy: Image): Image := {
			result: Image := Image.create(Image.width(copy), Image.height(copy), Image.depth(copy));
			copy(result, 0, 0, copy, null);
			return .result := result;
		};
		static tile(image: Image, x: int32, y: int32, src: Image, const roi: Rect): void := {
			rect: Rect := {
				rect.x0 := (roi) != null ? roi.x0 : 0;
				rect.y0 := (roi) != null ? roi.y0 : 0;
				rect.x1 := (roi) != null ? roi.x1 : Image.width(src);
				rect.y1 := (roi) != null ? roi.y1 : Image.height(src);
			};
			if (!clip(src, &rect)) {
				return;
			}
			if (x < 0) {
				x := -(-x % width(rect));
			}
			if (y < 0) {
				y := -(-y % height(rect));
			}
			width: int32 := Image.width(image);
			height: int32 := Image.height(image);
			for (j: int32 := y; j < height; j := j + height(rect)) {
				for (i: int32 := x; i < width; i := i + width(rect)) {
					copy(image, i, j, src, rect);
				}
			}
		};
		static eval(image: Image, const roi: Rect, aspect: float32, time: float32, eval(in: vec4f): vec4f): void := {
			rect: Rect := {
				rect.x0 := (roi) != null ? roi.x0 : 0;
				rect.y0 := (roi) != null ? roi.y0 : 0;
				rect.x1 := (roi) != null ? roi.x1 : Image.width(image);
				rect.y1 := (roi) != null ? roi.y1 : Image.height(image);
			};
			if (!clip(image, &rect)) {
				return;
			}
			w: float32 := Image.width(image);
			h: float32 := Image.height(image);
			if (aspect == (0)) {
				aspect := w / h;
			}
			h := h * aspect;
			in: vec4f := vec4f(0, 0, 0, time);
			for (y: int32 := rect.y0; y < rect.y1; y := y + 1) {
				in.y := (y) / h;
				for (x: int32 := rect.x0; x < rect.x1; x := x + 1) {
					in.x := (x) / w;
					set(image, x, y, argb(eval(in)));
				}
			}
		};
		static transform(image: Image, const rect: Rect, src: Image, const roi: Rect, interpolate: int32, const mat: mat4f): void := {
			static if ((preferNativeCalls) && (typename(Image.transform)) != null) {
				return .result := Image.transform(image, rect, src, roi, interpolate, pointer(mat.data));
			}
			assert(Image.depth(image) == 32);
			assert(Image.depth(src) == 32);
			dRec: Rect := {
				dRec.x0 := (rect) != null ? rect.x0 : 0;
				dRec.y0 := (rect) != null ? rect.y0 : 0;
				dRec.x1 := (rect) != null ? rect.x1 : Image.width(image);
				dRec.y1 := (rect) != null ? rect.y1 : Image.height(image);
			};
			sRec: Rect := {
				sRec.x0 := (roi) != null ? roi.x0 : 0;
				sRec.y0 := (roi) != null ? roi.y0 : 0;
				sRec.x1 := (roi) != null ? roi.x1 : Image.width(src);
				sRec.y1 := (roi) != null ? roi.y1 : Image.height(src);
			};
			if ((mat) == null) {
				scale: mat4f := {
					scale.x := vec4f(float32(width(sRec)) / (width(dRec)), 0, 0, sRec.x0);
					scale.y := vec4f(0, float32(height(sRec)) / (height(dRec)), 0, sRec.y0);
					scale.z := vec4f(0, 0, 1, 0);
					scale.w := vec4f(0, 0, 0, 1);
				};
				scale := mul(scale, translation(vec4f(dRec.x0, dRec.y0, 0, 0), -1));
				return .result := transform(image, rect, src, roi, interpolate, scale);
			}
			if (!clip(image, &dRec)) {
				return;
			}
			if (!clip(src, &sRec)) {
				return;
			}
			if (interpolate == 0) {
				for (y: int32 := dRec.y0; y < dRec.y1; y := y + 1) {
					for (x: int32 := dRec.x0; x < dRec.x1; x := x + 1) {
						t: vec4f := dph(mat, vec4f(x, y, 0, 1));
						Image.set(image, x, y, Image.get(src, t.x, t.y));
					}
				}
				return;
			}
			transform: mat4f := mul(scale(vec4f(Image.width(src), Image.height(src), 0, 0), 1), mat);
			for (y: int32 := dRec.y0; y < dRec.y1; y := y + 1) {
				for (x: int32 := dRec.x0; x < dRec.x1; x := x + 1) {
					t: vec4f := dph(transform, vec4f(x, y, 0, 1));
					set(image, x, y, argb(Image.tex(src, t.x, t.y)));
				}
			}
		};
		resize(destination: Image, const rect: Rect, const source: Image, const region: Rect, interpolation: int32): void := transform(destination, rect, source, region, interpolation, null);
		static Image(image: Image, width: int32, height: int32, align: int32, maxScale: float64): Image := {
			alignVertical: int32 := align & fitVertical;
			alignHorizontal: int32 := align & fitHorizontal;
			fitWidth: bool := alignVertical == fitVertical;
			fitHeight: bool := alignHorizontal == fitHorizontal;
			scale: float64 := 1;
			if (fitWidth && fitHeight) {
				widthScale: float64 := (width) / float64(Image.width(image));
				heightScale: float64 := (height) / float64(Image.height(image));
				if (align & fill) {
					scale := Math.max(widthScale, heightScale);
				}
				else {
					scale := Math.min(widthScale, heightScale);
				}
			}
			else if (fitWidth) {
				scale := (width) / float64(Image.width(image));
			}
			else if (fitHeight) {
				scale := (height) / float64(Image.height(image));
			}
			if (scale > maxScale) {
				scale := maxScale;
			}
			tx: float64 := 0;
			if (fitWidth || alignVertical == center) {
				tx := ((width) - (Image.width(image)) * scale) / (2);
			}
			else if (alignVertical == right) {
				tx := ((width) - (Image.width(image)) * scale);
			}
			ty: float64 := 0;
			if (fitHeight || alignHorizontal == center) {
				ty := ((height) - (Image.height(image)) * scale) / (2);
			}
			else if (alignHorizontal == bottom) {
				ty := ((height) - (Image.height(image)) * scale);
			}
			mat: mat4f := {
				mat.x.x := ((1) / scale);
				mat.x.y := (0);
				mat.x.z := (0);
				mat.x.w := (-tx / scale);
				mat.y.x := (0);
				mat.y.y := ((1) / scale);
				mat.y.z := (0);
				mat.y.w := (-ty / scale);
				mat.z.x := (0);
				mat.z.y := (0);
				mat.z.z := ((1) / scale);
				mat.z.w := (0);
				mat.w.x := (0);
				mat.w.y := (0);
				mat.w.z := (0);
				mat.w.w := (1);
			};
			result: Image := Image(width, height, Image.depth(image));
			transform(result, null, image, null, (align & highRes) ? 1 : 0, mat);
			return .result := result;
		};
		static Image(const fileName: char[*], width: int32, height: int32, depth: int32, align: int32, maxScale: float64): Image := {
			image: Image := Image(fileName, depth);
			result: Image := Image(image, width, height, align, maxScale);
			Image.destroy(image);
			return .result := result;
		};
		Image(const fileName: char[*], width: int32, height: int32, depth: int32, align: int32): Image := Image(fileName, width, height, depth, align, Math.inf);
		Image(const fileName: char[*], width: int32, height: int32, depth: int32): Image := Image(fileName, width, height, depth, -1, Math.inf);
		static blur(image: Image, radius: int32, sigma: float64): void := {
			static if ((preferNativeCalls) && (typename(Image.blur)) != null) {
				return .result := Image.blur(image, radius, sigma);
			}
			static gauss(x: float64, sigma: float64): float64 := {
				SQRT_2_PI_INV: typename := 0.398942;
				t: float64 := x / sigma;
				return .result := SQRT_2_PI_INV * Math.exp(-0.500000 * t * t) / sigma;
			};
			kernel: int32[1024] := {
			};
			size: int32 := radius * 2 + 1;
			assert(size < kernel.(length));
			kernelSum: float64 := 0;
			kernelFlt: float64[1024] := {
			};
			for (i: int32 := 0; i < size; i := i + 1) {
				kernelFlt[i] := gauss(radius - i, sigma);
				kernelSum := kernelSum + kernelFlt[i];
			}
			for (i: int32 := 0; i < size; i := i + 1) {
				kernel[i] := ((65536) * (kernelFlt[i] / kernelSum));
			}
			width: int32 := Image.width(image);
			height: int32 := Image.height(image);
			tmp: Image := Image.create(width, height, Image.depth(image));
			for (y: int32 := 0; y < height; y := y + 1) {
				for (x: int32 := 0; x < width; x := x + 1) {
					r: int32 := 0;
					g: int32 := 0;
					b: int32 := 0;
					for (i: int32 := 0; i < size; i := i + 1) {
						_x: int32 := x + i - radius;
						if (_x >= 0 && _x < width) {
							col: argb := argb(Image.get(image, _x, y));
							_k: int32 := kernel[i];
							r := r + _k * rch(col);
							g := g + _k * gch(col);
							b := b + _k * bch(col);
						}
					}
					set(tmp, x, y, argb(r >> 16, g >> 16, b >> 16));
				}
			}
			for (y: int32 := 0; y < height; y := y + 1) {
				for (x: int32 := 0; x < width; x := x + 1) {
					r: int32 := 0;
					g: int32 := 0;
					b: int32 := 0;
					for (i: int32 := 0; i < size; i := i + 1) {
						_y: int32 := y + i - radius;
						if (_y >= 0 && _y < height) {
							col: argb := argb(Image.get(tmp, x, _y));
							_k: int32 := kernel[i];
							r := r + _k * rch(col);
							g := g + _k * gch(col);
							b := b + _k * bch(col);
						}
					}
					set(image, x, y, argb(r >> 16, g >> 16, b >> 16));
				}
			}
			Image.destroy(tmp);
		};
		static colorMap(image: Image, const roi: Rect, const lut: argb[256]): void := {
			static if ((preferNativeCalls) && (typename(Image.colorMap)) != null) {
				return .result := Image.colorMap(image, roi, pointer(lut));
			}
			assert(Image.depth(image) == 32);
			r: Rect := {
				r.x0 := (roi) != null ? roi.x0 : 0;
				r.y0 := (roi) != null ? roi.y0 : 0;
				r.x1 := (roi) != null ? roi.x1 : Image.width(image);
				r.y1 := (roi) != null ? roi.y1 : Image.height(image);
			};
			if (!clip(image, &r)) {
				return;
			}
			useLuminosity: bool := false;
			for (i: int32 := 0; i < 256; i := i + 1) {
				if (ach(lut[i]) != i) {
					useLuminosity := true;
					break;
				}
			}
			if (!useLuminosity) {
				for (y: int32 := r.y0; y < r.y1; y := y + 1) {
					for (x: int32 := r.x0; x < r.x1; x := x + 1) {
						col: argb := argb(Image.get(image, x, y));
						col.r := lut[rch(col)].r;
						col.g := lut[gch(col)].g;
						col.b := lut[bch(col)].b;
						set(image, x, y, col);
					}
				}
				return;
			}
			fxpBits: typename := 16;
			fxp(v: float64): int32 := int32(v * ((1 << fxpBits)));
			static const rgb2luv: int32[] := {
				rgb2luv := rgb2luv.init;
				rgb2luv.init[0] := fxp(0.299000);
				rgb2luv.init[1] := fxp(0.587000);
				rgb2luv.init[2] := fxp(0.114000);
				rgb2luv.init[3] := 0;
				rgb2luv.init[4] := fxp(-0.147000);
				rgb2luv.init[5] := fxp(-0.289000);
				rgb2luv.init[6] := fxp(0.437000);
				rgb2luv.init[7] := 0;
				rgb2luv.init[8] := fxp(0.615000);
				rgb2luv.init[9] := fxp(-0.515000);
				rgb2luv.init[10] := fxp(-0.100000);
				rgb2luv.init[11] := 0;
			};
			static const luv2rgb: int32[] := {
				luv2rgb := luv2rgb.init;
				luv2rgb.init[0] := fxp(1);
				luv2rgb.init[1] := fxp(0.000000);
				luv2rgb.init[2] := fxp(1.140000);
				luv2rgb.init[3] := 0;
				luv2rgb.init[4] := fxp(1);
				luv2rgb.init[5] := fxp(-0.394000);
				luv2rgb.init[6] := fxp(-0.581000);
				luv2rgb.init[7] := 0;
				luv2rgb.init[8] := fxp(1);
				luv2rgb.init[9] := fxp(2.028000);
				luv2rgb.init[10] := fxp(0.000000);
				luv2rgb.init[11] := 0;
			};
			for (y: int32 := r.y0; y < r.y1; y := y + 1) {
				for (x: int32 := r.x0; x < r.x1; x := x + 1) {
					col: argb := argb(Image.get(image, x, y));
					r: int32 := rch(lut[rch(col)]);
					g: int32 := gch(lut[gch(col)]);
					b: int32 := bch(lut[bch(col)]);
					l: int32 := (r * rgb2luv[0] + g * rgb2luv[1] + b * rgb2luv[2]) >> fxpBits;
					u: int32 := (r * rgb2luv[4] + g * rgb2luv[5] + b * rgb2luv[6]) >> fxpBits;
					v: int32 := (r * rgb2luv[8] + g * rgb2luv[9] + b * rgb2luv[10]) >> fxpBits;
					l := ach(lut[sat_s8(l)]);
					col.r := (sat_s8((l * luv2rgb[0] + u * luv2rgb[1] + v * luv2rgb[2]) >> fxpBits));
					col.g := (sat_s8((l * luv2rgb[4] + u * luv2rgb[5] + v * luv2rgb[6]) >> fxpBits));
					col.b := (sat_s8((l * luv2rgb[8] + u * luv2rgb[9] + v * luv2rgb[10]) >> fxpBits));
					set(image, x, y, col);
				}
			}
		};
		static colorMat(image: Image, const roi: Rect, const mat: mat4f): void := {
			static if ((preferNativeCalls) && (typename(Image.colorMat)) != null) {
				return .result := Image.colorMat(image, roi, mat.data);
			}
			assert(Image.depth(image) == 32);
			r: Rect := {
				r.x0 := (roi) != null ? roi.x0 : 0;
				r.y0 := (roi) != null ? roi.y0 : 0;
				r.x1 := (roi) != null ? roi.x1 : Image.width(image);
				r.y1 := (roi) != null ? roi.y1 : Image.height(image);
			};
			if (!clip(image, &r)) {
				return;
			}
			m00: int32 := (65536) * mat.xx;
			m01: int32 := (65536) * mat.xy;
			m02: int32 := (65536) * mat.xz;
			m03: int32 := (256 * 65536) * mat.xw;
			m10: int32 := (65536) * mat.yx;
			m11: int32 := (65536) * mat.yy;
			m12: int32 := (65536) * mat.yz;
			m13: int32 := (256 * 65536) * mat.yw;
			m20: int32 := (65536) * mat.zx;
			m21: int32 := (65536) * mat.zy;
			m22: int32 := (65536) * mat.zz;
			m23: int32 := (256 * 65536) * mat.zw;
			for (y: int32 := r.y0; y < r.y1; y := y + 1) {
				for (x: int32 := r.x0; x < r.x1; x := x + 1) {
					col: argb := argb(Image.get(image, x, y));
					r: int32 := rch(col);
					g: int32 := gch(col);
					b: int32 := bch(col);
					col.r := (sat_s8((r * m00 + g * m01 + b * m02 + m03) >> 16));
					col.g := (sat_s8((r * m10 + g * m11 + b * m12 + m13) >> 16));
					col.b := (sat_s8((r * m20 + g * m21 + b * m22 + m23) >> 16));
					set(image, x, y, col);
				}
			}
		};
		static Mesh(const fileName: char[*]): Mesh := {
			if (endsWith(fileName, ".obj", ignCaseCmp)) {
				return .result := Mesh.openObj(fileName);
			}
			if (endsWith(fileName, ".3ds", ignCaseCmp)) {
				return .result := Mesh.open3ds(fileName);
			}
			abort("unknown file extension", fileName);
		};
		static const Camera: struct {
			position: vec4f := vec4f(0, 0, 0, 1);
			forward: vec4f := vec4f(0, 0, 0, 1);
			right: vec4f := vec4f(0, 0, 0, 1);
			up: vec4f := vec4f(0, 1, 0, 1);
			static projection(fov: float32, asp: float32, n: float32, f: float32): mat4f := {
				bot: float32 := 1;
				nf: float32 := n - f;
				if (fov == (0)) {
					return .result := {
			.result.x := vec4f((1) / asp, 0, 0, 0);
			.result.y := vec4f(0, (1) / bot, 0, 0);
			.result.z := vec4f(0, 0, (2) / nf, -(f + n) / nf);
			.result.w := vec4f(0, 0, 0, 1);
		};
				}
				bot := (Math.tan(Math.radians(fov)));
				asp := asp * bot;
				return .result := {
			.result.x := vec4f(n / asp, 0, 0, 0);
			.result.y := vec4f(0, n / bot, 0, 0);
			.result.z := vec4f(0, 0, (n + f) / nf, (-2) * n * f / nf);
			.result.w := vec4f(0, 0, 1, 0);
		};
			};
			static lookAt(position: vec4f, target: vec4f, up: vec4f): Camera := {
				forward: vec4f := normalize(sub(target, position));
				right: vec4f := normalize(cross(up, forward));
				return .result := {
			.result.position := position;
			.result.forward := forward;
			.result.right := right;
			.result.up := cross(forward, right);
		};
			};
			static matrix(const camera: Camera): mat4f := {
				return .result := {
			.result.x := vec4f(camera.right, -dp3(camera.right, camera.position));
			.result.y := vec4f(camera.up, -dp3(camera.up, camera.position));
			.result.z := vec4f(camera.forward, -dp3(camera.forward, camera.position));
			.result.w := vec4f(0, 0, 0, 1);
		};
			};
			static matrix(const camera: Camera, fov: float32, asp: float32, n: float32, f: float32): mat4f := {
				return .result := mul(projection(fov, asp, n, f), matrix(camera));
			};
			static move(camera: Camera, direction: vec4f, amount: float32): void := {
				camera.position := add(camera.position, mul(direction, amount));
			};
			static rotate(camera: Camera, orbit: vec4f, direction: vec4f, amount: float32): void := {
				if (amount == (0)) {
					return;
				}
				matrix: mat4f := rotation(orbit, direction, amount);
				camera.forward := normalize(dp3(matrix, camera.forward));
				camera.right := normalize(dp3(matrix, camera.right));
				camera.up := cross(camera.forward, camera.right);
				camera.position := dph(matrix, camera.position);
			};
		};
		static const Window: struct {
			static const timeoutMax: int32 := 2147483647;
			static timeoutFps(fps: float64): int64 := int64((1000) / fps);
			static show(image: Image, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void := {
				if ((onEvent) == null) {
					return .result := Window.show(image, null, null);
				}
				static delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
					return .result := onEvent(action, button, ex, ey);
				};
				Window.show(image, onEvent, delegate);
			};
			static show(width: int32, height: int32, image0: Image, image1: Image, image2: Image): void := {
				static const Data: struct {
					offs: Image;
					image0: Image;
					image1: Image;
					image2: Image;
				};
				static onEvent(const data: Data, action: int32, button: int32, ex: int32, ey: int32): int32 := {
					if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
						return .result := Window.quit();
					}
					if ((action) == Window.MOUSE_PRESS || (action) == Window.MOUSE_RELEASE) {
						show: Image := data.image0;
						if ((action) == Window.MOUSE_RELEASE) {
							show := data.image0;
						}
						else if (button == 1) {
							show := data.image1;
						}
						else {
							show := data.image2;
						}
						if (Image.width(data.offs) != Image.width(show) || Image.height(data.offs) != Image.height(show)) {
							transform(data.offs, null, show, null, 1, null);
						}
						else {
							copy(data.offs, 0, 0, show, null);
						}
					}
					return .result := Window.timeoutMax;
				};
				offs: Image := Image(width, height, Image.depth(image0));
				data: Data := {
					data.offs := offs;
					data.image0 := image0;
					data.image1 := image1;
					data.image2 := image2;
				};
				onEvent(data, Window.MOUSE_RELEASE, 0, 0, 0);
				Window.show(offs, data, onEvent);
				Image.destroy(offs);
			};
			static show(image0: Image, image1: Image, image2: Image): void := {
				width: int32 := Image.width(image0);
				height: int32 := Image.height(image0);
				return .result := show(width, height, image0, image1, image1);
			};
			static show(image0: Image, image1: Image): void := {
				return .result := show(image0, image1, image1);
			};
			static show(image: Image): void := {
				Window.show(image, image, image);
			};
			static show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void := {
				static const start: int64 := System.millis();
				static const Data: struct {
					lerp: bool := true;
					const offs: Image;
					const thumb: Image;
					const aspect: float32;
					fpsCount: int32 := 0;
					fpsTime: float32 := 0;
					const eval(in: vec4f): vec4f;
				};
				static onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32 := {
					if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
						return .result := Window.quit();
					}
					if ((action) == Window.WINDOW_CLOSE) {
						return .result := Window.quit();
					}
					if ((action) == Window.KEY_RELEASE) {
						if (button == (' ')) {
							text: char[256] := {
							};
							now: int64 := System.millis();
							time: float32 := ((now - start)) / 1000.000000;
							eval(data.offs, null, data.aspect, time, data.eval);
							append(text, append(text, 0, "Millis: "), System.millis() - now);
							Window.setTitle(text);
							return .result := Window.timeoutMax;
						}
						if ((button) == Window.KEY_CODE_TAB) {
							data.lerp := !data.lerp;
						}
						if (button == ('S')) {
							trace("dumping screen");
							Image.saveBmp(data.offs, "out/offs.bmp", 0);
							Image.saveBmp(data.thumb, "out/thumb.bmp", 0);
						}
					}
					time: float32 := ((System.millis() - start)) / 1000.000000;
					eval(data.thumb, null, data.aspect, time, data.eval);
					resize(data.offs, null, data.thumb, null, int32(data.lerp));
					if (time > data.fpsTime) {
						text: char[256] := {
						};
						append(text, append(text, 0, "Fps: "), data.fpsCount);
						Window.setTitle(text);
						data.fpsTime := time + (1);
						data.fpsCount := 0;
					}
					data.fpsCount := data.fpsCount + 1;
					return .result := 0;
				};
				if (animationResolution == 0) {
					aspect: float32 := (width) / float32(height);
					image: Image := Image(width, height, 32);
					eval(image, null, aspect, 0.000000, eval);
					Window.show(image);
					Image.destroy(image);
					return;
				}
				data: Data := {
					data.offs := Image(width, height, 32);
					data.thumb := Image(animationResolution, animationResolution, 32);
					data.aspect := (width) / float32(height);
					data.eval := eval;
					data.lerp := true;
					data.fpsCount := 0;
					data.fpsTime := (0);
				};
				Window.show(data.offs, data, onEvent);
				Image.destroy(data.thumb);
				Image.destroy(data.offs);
			};
			static show(width: int32, height: int32, eval(in: vec4f): vec4f): void := {
				return .result := show(width, height, 0, eval);
			};
			static show(w: int32, h: int32, fovy: float32, mesh: Mesh): void := {
				static const Data: struct {
					fpsCount: int32 := 0;
					fpsShow: int32 := 0;
					fpsTime: int64 := 0;
					mode: int32;
					offs: Image;
					proj: mat4f;
					cam: Camera;
					mesh: Mesh;
					static updateCamera(const this: Data): void := {
						camera: Camera := this.cam;
						camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
					};
				};
				static nextInc(x: int32, mask: int32): int32 := {
					next: int32 := x & mask;
					next := next + (mask & -mask);
					next := next & mask;
					return .result := next | (x & ~mask);
				};
				static nextBit(x: int32, mask: int32): int32 := {
					next: int32 := x & mask;
					if (next == 0) {
						next := mask & -mask;
					}
					else {
						next := (next + next) & mask;
					}
					return .result := next | (x & ~mask);
				};
				static onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32 := {
					static ox: int32 := 0;
					static oy: int32 := 0;
					static const slow: float32 := (1) / 100.000000;
					static const fast: float32 := (5) / 100.000000;
					if ((action) == Window.MOUSE_MOTION || (action) == Window.FINGER_MOTION) {
						camera: Camera := data.cam;
						dx: int32 := ex - ox;
						dy: int32 := ey - oy;
						if (button == 1 || (action) == Window.FINGER_MOTION) {
							orbit: vec4f := vec4f(0, 0, 0);
							Camera.rotate(camera, orbit, camera.up, (dx) * slow);
							Camera.rotate(camera, orbit, camera.right, (dy) * slow);
							Data.updateCamera(data);
						}
						else if (button == 2) {
							orbit: vec4f := camera.position;
							Camera.rotate(camera, orbit, camera.up, (-dx) * slow);
							Camera.rotate(camera, orbit, camera.right, (-dy) * slow);
							Data.updateCamera(data);
						}
						else if (button == 3) {
							Camera.move(camera, camera.forward, (dy) * slow);
							Data.updateCamera(data);
						}
						else if (button == 4) {
							Camera.move(camera, camera.right, (-dx) * slow);
							Camera.move(camera, camera.up, (dy) * slow);
							Data.updateCamera(data);
						}
						ox := ex;
						oy := ey;
					}
					else if ((action) == Window.MOUSE_PRESS || (action) == Window.FINGER_PRESS) {
						ox := ex;
						oy := ey;
						return .result := Window.timeoutMax;
					}
					else if ((action) == Window.MOUSE_WHEEL) {
						camera: Camera := data.cam;
						Camera.move(camera, camera.forward, (ey) * fast);
						Data.updateCamera(data);
					}
					else if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
						return .result := Window.quit();
					}
					else if ((action) == Window.KEY_PRESS) {
						if ((button) == Window.KEY_CODE_ENTER) {
							return .result := onEvent(&data, Window.WINDOW_INIT, button, ex, ey);
						}
						else if (button == ('w')) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.move(camera, camera.forward, +(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if (button == ('s')) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.move(camera, camera.forward, -(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if (button == ('a')) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.move(camera, camera.right, -(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if (button == ('d')) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.move(camera, camera.right, +(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if ((button) == Window.KEY_CODE_UP) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.rotate(camera, camera.position, camera.right, -(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if ((button) == Window.KEY_CODE_DOWN) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.rotate(camera, camera.position, camera.right, +(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if ((button) == Window.KEY_CODE_LEFT) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.rotate(camera, camera.position, camera.up, -(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if ((button) == Window.KEY_CODE_RIGHT) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.rotate(camera, camera.position, camera.up, +(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if (button == ('l')) {
							data.mode := ((data.mode) ^ Mesh.useLights);
						}
						else if (button == ('b')) {
							data.mode := ((data.mode) ^ Mesh.drawBounds);
						}
						else if (button == ('0')) {
							lights.enable(0, !lights.enabled(0));
						}
						else if (button == ('1')) {
							lights.enable(1, !lights.enabled(1));
						}
						else if (button == ('2')) {
							lights.enable(2, !lights.enabled(2));
						}
						else if (button == ('3')) {
							lights.enable(3, !lights.enabled(3));
						}
						else if (button == ('t')) {
							data.mode := ((data.mode) ^ Mesh.useTexture);
						}
						else if (button == ('/')) {
							data.mode := nextInc(data.mode, Mesh.cullMode);
						}
						else if ((button) == Window.KEY_CODE_TAB) {
							data.mode := nextBit(data.mode, Mesh.drawMode);
						}
					}
					else if ((action) == Window.WINDOW_INIT) {
						camera: Camera := data.cam;
						eye: vec4f := {
							eye.x := (0);
							eye.y := (0);
							eye.z := (2);
							eye.w := (1);
						};
						at: vec4f := {
							at.x := (0);
							at.y := (0);
							at.z := (0);
							at.w := (1);
						};
						up: vec4f := {
							up.x := (0);
							up.y := (1);
							up.z := (0);
							up.w := (1);
						};
						data.cam := Camera.lookAt(eye, at, up);
						Data.updateCamera(data);
					}
					rendered: int32 := Image.drawMesh(data.offs, data.mesh, data.mode);
					text: char[256] := {
					};
					pos: int32 := append(text, 0, "Vertices: ");
					pos := append(text, pos, data.mesh.vertices);
					pos := append(text, pos, ", Triangles: ");
					pos := append(text, pos, data.mesh.triangles);
					pos := append(text, pos, "/");
					pos := append(text, pos, rendered);
					pos := append(text, pos, ", Fps: ");
					pos := append(text, pos, data.fpsShow);
					Window.setTitle(text);
					time: int64 := System.millis();
					if (time > data.fpsTime) {
						data.fpsTime := time + (1000);
						data.fpsShow := data.fpsCount;
						data.fpsCount := 0;
					}
					data.fpsCount := data.fpsCount + 1;
					return .result := Window.timeoutMax;
				};
				data: Data := {
					data.mode := (Mesh.useLights | Mesh.cullBack | Mesh.drawFill);
					data.offs := Image.create3d(w, h);
					data.proj := Camera.projection(fovy, (w) / float32(h), 1, 100);
					data.cam.position := vec4f(0, 0, 0, 1);
					data.cam.forward := vec4f(0, 0, 0, 1);
					data.cam.right := vec4f(0, 0, 0, 1);
					data.cam.up := vec4f(0, 1, 0, 1);
					data.mesh := mesh;
					data.fpsCount := 0;
					data.fpsShow := 0;
					data.fpsTime := (0);
				};
				Window.show(data.offs, data, onEvent);
				Image.destroy(data.offs);
			};
			static const KEY_PRESS: int64 := 1;
			static const KEY_RELEASE: int64 := 2;
			static const MOUSE_WHEEL: int64 := 3;
			static const MOUSE_PRESS: int64 := 4;
			static const MOUSE_MOTION: int64 := 5;
			static const MOUSE_RELEASE: int64 := 6;
			static const FINGER_PRESS: int64 := 7;
			static const FINGER_MOTION: int64 := 8;
			static const FINGER_RELEASE: int64 := 9;
			static const EVENT_TIMEOUT: int64 := 10;
			static const WINDOW_INIT: int64 := 100;
			static const WINDOW_CLOSE: int64 := 102;
			static const WINDOW_ENTER: int64 := 103;
			static const WINDOW_LEAVE: int64 := 104;
			static const KEY_CODE_ESC: int64 := 65307;
			static const KEY_CODE_BACK: int64 := 65288;
			static const KEY_CODE_TAB: int64 := 65289;
			static const KEY_CODE_ENTER: int64 := 65293;
			static const KEY_CODE_CAPSLOCK: int64 := 65509;
			static const KEY_CODE_PRINT_SCREEN: int64 := 65377;
			static const KEY_CODE_SCROLL_LOCK: int64 := 65300;
			static const KEY_CODE_PAUSE: int64 := 65299;
			static const KEY_CODE_INSERT: int64 := 65379;
			static const KEY_CODE_HOME: int64 := 65360;
			static const KEY_CODE_PAGE_UP: int64 := 65365;
			static const KEY_CODE_DELETE: int64 := 65535;
			static const KEY_CODE_END: int64 := 65367;
			static const KEY_CODE_PAGE_DOWN: int64 := 65366;
			static const KEY_CODE_RIGHT: int64 := 65363;
			static const KEY_CODE_LEFT: int64 := 65361;
			static const KEY_CODE_DOWN: int64 := 65364;
			static const KEY_CODE_UP: int64 := 65362;
			static const KEY_CODE_L_SHIFT: int64 := 65505;
			static const KEY_CODE_R_SHIFT: int64 := 65506;
			static const KEY_CODE_L_CTRL: int64 := 65507;
			static const KEY_CODE_R_CTRL: int64 := 65508;
			static const KEY_CODE_L_ALT: int64 := 65513;
			static const KEY_CODE_R_ALT: int64 := 65514;
			static const KEY_CODE_L_GUI: int64 := 65515;
			static const KEY_CODE_R_GUI: int64 := 65516;
			static const KEY_MASK_SHIFT: int64 := 1;
			static const KEY_MASK_CTRL: int64 := 2;
			static const KEY_MASK_ALT: int64 := 4;
			static const show(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void := nfc(128);
			static const setTitle(const title: char[*]): void := nfc(129);
			static const quit(): int32 := nfc(130);
			static const font(height: int32): Image := nfc(131);
			static const font: Image := nfc(132);
		};
		static const Style: struct {
			static const dark: argb := argb(1710618);
			static const light: argb := argb(14342874);
			static const blue: argb := argb(33, 149, 246);
			static const green: argb := argb(74, 174, 82);
			static const gray: argb := argb(98, 125, 139);
			static const orange: argb := argb(255, 153, 0);
			static const red: argb := argb(246, 64, 49);
			static const magenta: argb := argb(156, 36, 181);
			static const cyan: argb := argb(0, 149, 139);
			static const theme: argb := dark;
			static const accent: argb := gray;
			const align: int32 := 0;
			const padding: int32 := 8;
			const font: Image := Window.font;
			const format: FormatFlags;
			backgroundColor: uint32 := uint32(theme);
			hoveredColor: uint32 := uint32(mix_rgb8(16, theme, accent));
			focusedColor: uint32 := uint32(mix_rgb8(64, theme, accent));
			valueColor: uint32 := uint32(accent);
			textColor: uint32 := uint32(lum(theme) > 127 ? dark : light);
			static const top: int32 := 1;
			static const left: int32 := 2;
			static const right: int32 := 4;
			static const bottom: int32 := 8;
			static const center: int32 := 0;
			static const topLeft: int32 := 3;
			static const topRight: int32 := 5;
			static const bottomLeft: int32 := 10;
			static const bottomRight: int32 := 12;
			static const vertical: int32 := 6;
			static const verticalTop: int32 := 7;
			static const verticalBottom: int32 := 14;
			static const horizontal: int32 := 9;
			static const horizontalLeft: int32 := 11;
			static const horizontalRight: int32 := 13;
			static const fill: int32 := 15;
			static const hovered: int32 := 1;
			static const pressed: int32 := 2;
			static const focused: int32 := 4;
			static align(parent: Rect, rect: Rect, align: int32): void := {
				vertical: int32 := align & Style.vertical;
				if (vertical == center) {
					positionX(rect, parent.x0 + (width(parent) - width(rect)) / 2);
				}
				else if (vertical == right) {
					positionX(rect, parent.x0 + (width(parent) - width(rect)));
				}
				else if (vertical == left) {
					positionX(rect, parent.x0);
				}
				else {
					rect.x0 := parent.x0;
					rect.x1 := parent.x1;
				}
				horizontal: int32 := align & Style.horizontal;
				if (horizontal == center) {
					positionY(rect, parent.y0 + (height(parent) - height(rect)) / 2);
				}
				else if (horizontal == bottom) {
					positionY(rect, parent.y0 + (height(parent) - height(rect)));
				}
				else if (horizontal == top) {
					positionY(rect, parent.y0);
				}
				else {
					rect.y0 := parent.y0;
					rect.y1 := parent.y1;
				}
			};
			static measure(const this: Style, rect: Rect, const text: char[*]): void := {
				Image.clipText(this.font, &rect, text);
				padded(&rect, this.padding);
			};
			static align(const this: Style, parent: Rect, rect: Rect, const value: char[*], align: int32): void := {
				padded(parent, -this.padding);
				Image.clipText(this.font, &rect, value);
				if ((align & horizontal) == horizontal) {
					align := align & ~horizontal;
				}
				if ((align & vertical) == vertical) {
					align := align & ~vertical;
				}
				align(parent, &rect, align);
			};
			static align(const this: Style, parent: Rect, rect: Rect, const value: char[*]): void := {
				return .result := align(this, parent, &rect, value, this.align);
			};
			static setColor(style: Style, background: argb, accent: argb): void := {
				style.backgroundColor := uint32(background);
				style.hoveredColor := uint32(mix_rgb8(16, background, accent));
				style.focusedColor := uint32(mix_rgb8(64, background, accent));
				style.valueColor := uint32(accent);
				style.textColor := uint32(lum(background) > 127 ? dark : light);
			};
			static vertical(align: int32): bool := (align & vertical) == vertical;
			static horizontal(align: int32): bool := (align & horizontal) == horizontal;
		};
		static const KeyEvent: struct {
			const release: bool;
			const isShift: bool;
			const isCtrl: bool;
			const isAlt: bool;
			const repeat: int32;
			const key: int32;
		};
		static const TouchEvent: struct {
			const release: bool;
			const isShift: bool;
			const isCtrl: bool;
			const isAlt: bool;
			const clicks: int32;
			const button: int32;
			const dx: int32 := 0;
			const dy: int32 := 0;
			const x: int32;
			const y: int32;
			static test(const event: TouchEvent, const rect: Rect): bool := {
				if (event.x < rect.x0 || event.x >= rect.x1) {
					return .result := false;
				}
				if (event.y < rect.y0 || event.y >= rect.y1) {
					return .result := false;
				}
				return .result := true;
			};
			static isMotion(const event: TouchEvent): bool := {
				return .result := (event.dx) || (event.dy);
			};
			static isPress(const event: TouchEvent): bool := {
				return .result := !(event.release || (event.dx) || (event.dy));
			};
			static isLongPress(const event: TouchEvent): bool := {
				return .result := event.release && event.clicks < 0;
			};
			static isPress(const event: TouchEvent, button: int32): bool := {
				if (event.release || (event.dx) || (event.dy)) {
					return .result := false;
				}
				return .result := event.button == button;
			};
		};
		static const View: struct {
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static focus(view: View): void := focus;
		static invalidate(view: View, layout: bool): void := invalidate;
		static const Layout: struct {
			static const Item: struct {
				rect: Rect;
				view: View;
				align: int32;
			};
			separator: View := null;
			items: Item[*] := null;
			itemCount: int32 := 0;
			itemCapacity: int32 := 0;
			hoveredIndex: int32 := -1;
			pressedIndex: int32 := -1;
			focusedIndex: int32 := -1;
			paddingTop: int32 := 0;
			paddingLeft: int32 := 0;
			paddingRight: int32 := 0;
			paddingBottom: int32 := 0;
			orientation: int32 := 1;
			static clearState(this: Layout, mode: int32): bool := {
				result: bool := false;
				if ((mode & Style.hovered) && this.hoveredIndex >= 0) {
					view: View := this.items[this.hoveredIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.hoveredIndex := -1;
					result := true;
				}
				if ((mode & Style.pressed) && this.pressedIndex >= 0) {
					view: View := this.items[this.pressedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.pressedIndex := -1;
					result := true;
				}
				if ((mode & Style.focused) && this.focusedIndex >= 0) {
					view: View := this.items[this.focusedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.focusedIndex := -1;
					result := true;
				}
				return .result := result;
			};
			static getPressed(const this: Layout): View := {
				if (this.pressedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.pressedIndex].view;
				if ((layout) != null) {
					child: View := getPressed(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static getFocused(const this: Layout): View := {
				if (this.focusedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.focusedIndex].view;
				if ((layout) != null) {
					child: View := getFocused(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static setFocused(this: Layout, focus: View): bool := {
				if ((focus) == null) {
					clearState(this, Style.focused);
				}
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					const view: View := item.view;
					if (view == focus && this.focusedIndex != i) {
						clearState(this, Style.focused);
						this.focusedIndex := i;
						return .result := true;
					}
					if ((layout) != null) {
						if (setFocused(layout, focus) && this.focusedIndex != i) {
							clearState(this, Style.focused);
							this.focusedIndex := i;
							return .result := true;
						}
					}
				}
				return .result := false;
			};
			static capacity(this: Layout, capacity: int32): Layout := {
				assert(capacity >= this.itemCount);
				if (capacity == this.itemCapacity) {
					return;
				}
				items: Item[*] := this.items;
				this.itemCapacity := capacity;
				this.items := (pointer.alloc(null, this.itemCapacity * sizeof(Item)));
				pointer.copy(this.items, items, this.itemCount * sizeof(Item));
				pointer.alloc(items, 0);
				return .result := this;
			};
			static addItems(this: Layout, alignment: int32, views: View[]): Layout := {
				static separator(this: Layout): View := {
					static onDraw(this: View, offs: Image, rect: Rect): void := {
					};
					if ((this.separator) != null) {
						return .result := this.separator;
					}
					separator: View := {
						separator := create(View);
						separator.enabled := false;
						separator.focusable := false;
						separator.onDraw := onDraw;
						separator.width := -5;
						separator.height := -5;
						separator.parent := (null);
						separator.style := (null);
						separator.data := (null);
						separator.onClick := onClick;
						separator.onReset := onReset;
						separator.onCreate := onCreate;
						separator.onDestroy := onDestroy;
						separator.onKeyEvent := onKeyEvent;
						separator.onTouchEvent := onTouchEvent;
						separator.onMeasure := onMeasure;
					};
					this.separator := separator;
					return .result := separator;
				};
				itemCount: int32 := this.itemCount + (views.length);
				if (itemCount >= this.itemCapacity) {
					capacity: int32 := 2 * this.itemCapacity;
					if (capacity < itemCount) {
						capacity := itemCount;
					}
					capacity(this, capacity);
				}
				for (i: int32 := 0; i < (views.length); i := i + 1) {
					item: Item := this.items[this.itemCount + i];
					item.view := views[i];
					item.align := alignment;
					if ((item.view) == null) {
						item.view := separator(this);
					}
				}
				this.itemCount := itemCount;
				return .result := this;
			};
			static size(this: Layout): int32 := {
				return .result := this.itemCount;
			};
			static getView(this: Layout, idx: int32): View := {
				assert(idx >= 0 && idx < this.itemCount);
				return .result := this.items[idx].view;
			};
			static setAlignment(this: Layout, idx: int32, alignment: int32): void := {
				assert(idx >= 0 && idx < this.itemCount);
				this.items[idx].align := alignment;
			};
			static padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout := {
				this.paddingTop := top;
				this.paddingLeft := left;
				this.paddingRight := right;
				this.paddingBottom := bottom;
				invalidate(this, true);
				return .result := this;
			};
			static onClick(this: Layout): bool := {
				error("onClick", this);
				return .result := false;
			};
			static onReset(this: Layout): bool := {
				result: bool := false;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					if (view.onReset(view)) {
						result := true;
					}
				}
				return .result := result;
			};
			static onCreate(this: Layout, parent: View): void := {
				assert((this.parent) == null, "can not add the same layout multiple times");
				View.onCreate(this, parent);
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onCreate(view, this);
				}
			};
			static onDestroy(this: Layout): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onDestroy(view);
					destroy(view);
				}
				pointer.alloc(this.items, 0);
			};
			static onKeyEvent(this: Layout, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				idx: int32 := this.focusedIndex;
				if (idx < 0) {
					return .result := false;
				}
				view: View := this.items[idx].view;
				return .result := view.onKeyEvent(view, event);
			};
			static onTouchEvent(this: Layout, const rect: Rect, const event: TouchEvent): bool := {
				static findView(this: Layout, x: int32, y: int32): int32 := {
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						if (item.view.enabled && contains(item.rect, x, y)) {
							return .result := i;
						}
					}
					return .result := -1;
				};
				if (!this.enabled) {
					return .result := false;
				}
				result: bool := false;
				active: int32 := this.pressedIndex;
				if (!((event.dx) || (event.dy) || event.release) || !(event.button)) {
					active := findView(this, event.x, event.y);
				}
				if (active < 0) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				item: Item := this.items[active];
				view: View := item.view;
				if (!view.enabled) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				if (this.pressedIndex != active && TouchEvent.isPress(event, 1)) {
					clearState(this, Style.pressed);
					this.pressedIndex := active;
					result := true;
				}
				outside: bool := !TouchEvent.test(event, item.rect);
				if (this.hoveredIndex != active || outside) {
					if (clearState(this, Style.hovered)) {
						result := true;
					}
					if (!outside) {
						this.hoveredIndex := active;
						result := true;
					}
				}
				if (event.release && outside) {
					return .result := clearState(this, Style.pressed | Style.hovered);
				}
				if (view.onTouchEvent(view, item.rect, event)) {
					result := true;
				}
				if (!event.release) {
					return .result := result;
				}
				focusable: bool := view.focusable;
				if (outside) {
					focusable := false;
				}
				else if (event.clicks < 0) {
					clearState(this, Style.hovered);
					focusable := false;
				}
				else if (this.focusedIndex == active) {
					focusable := false;
				}
				else if ((layout) != null) {
					if (layout.focusedIndex == -1) {
						focusable := false;
					}
				}
				if (focusable) {
					clearState(this, Style.focused);
					this.focusedIndex := active;
					result := true;
				}
				if (clearState(this, Style.pressed)) {
					return .result := true;
				}
				return .result := result;
			};
			static onMeasure(this: Layout, measured: Rect): bool := {
				dir: int32 := this.orientation;
				N: int32 := Math.abs(dir);
				n: int32 := 0;
				maxWidth: int32 := 0;
				sumWidth: int32 := 0;
				maxHeight: int32 := 0;
				sumHeight: int32 := 0;
				rows: int32 := dir < 0 ? N : 1;
				cols: int32 := dir > 0 ? N : 1;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					item: Item := this.items[i];
					rect: Rect := item.rect;
					view: View := item.view;
					rect.x0 := rect.x1 := 0;
					rect.y0 := rect.y1 := 0;
					if (view.onMeasure(view, &rect)) {
						width: int32 := width(rect);
						height: int32 := height(rect);
						if (n >= N) {
							cols := cols + int32(dir < 0);
							rows := rows + int32(dir > 0);
							n := 0;
						}
						sumWidth := sumWidth + width;
						if (maxWidth < width) {
							maxWidth := width;
						}
						sumHeight := sumHeight + height;
						if (maxHeight < height) {
							maxHeight := height;
						}
						n := n + 1;
					}
				}
				if (rows == 1 && cols == 1) {
					sumWidth := maxWidth;
					sumHeight := maxHeight;
				}
				if (rows > 1) {
					sumWidth := maxWidth * cols;
				}
				if (cols > 1) {
					sumHeight := maxHeight * rows;
				}
				width(measured, sumWidth + this.paddingLeft + this.paddingRight);
				height(measured, sumHeight + this.paddingTop + this.paddingBottom);
				return .result := View.onMeasure(this, &measured);
			};
			static onLayout(this: Layout, measured: Rect): void := {
				static verticalLayout(this: Layout, measured: Rect, cols: int32): void := {
					rowSpacing: int32 := width(measured) / cols;
					colSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						rows: int32 := 0;
						n: int32 := cols;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= cols) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									rows := rows + 1;
									n := 0;
								}
								if (maxSize < height(rect)) {
									maxSize := height(rect);
								}
								if (colSpacing < maxSize) {
									colSpacing := maxSize;
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (rows > 0 && height(measured) > sumSize) {
							grow := (height(measured) - sumSize) / rows;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := cols;
					translateY(r, -colSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= cols) {
							positionX(r, measured.x0);
							translateY(r, colSpacing + grow);
							if (cols == 1) {
								colSpacing := height(rect);
							}
							n := 0;
						}
						width(r, rowSpacing);
						height(r, colSpacing + grow);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateX(r, rowSpacing);
						n := n + 1;
					}
				};
				static horizontalLayout(this: Layout, measured: Rect, rows: int32): void := {
					colSpacing: int32 := height(measured) / rows;
					rowSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						cols: int32 := 0;
						n: int32 := rows;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= rows) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									cols := cols + 1;
									n := 0;
								}
								if (maxSize < width(rect)) {
									maxSize := width(rect);
								}
								if (rowSpacing < width(rect)) {
									rowSpacing := width(rect);
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (cols > 0 && width(measured) > sumSize) {
							grow := (width(measured) - sumSize) / cols;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := rows;
					translateX(r, -rowSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= rows) {
							positionY(r, measured.y0);
							translateX(r, rowSpacing + grow);
							if (rows == 1) {
								rowSpacing := width(rect);
							}
							n := 0;
						}
						width(r, rowSpacing + grow);
						height(r, colSpacing);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateY(r, colSpacing);
						n := n + 1;
					}
				};
				static addPadding(const this: Layout, rect: Rect, multiplier: int32): void := {
					rect.x0 := rect.x0 - multiplier * this.paddingLeft;
					rect.y0 := rect.y0 - multiplier * this.paddingTop;
					rect.x1 := rect.x1 + multiplier * this.paddingRight;
					rect.y1 := rect.y1 + multiplier * this.paddingBottom;
				};
				addPadding(this, &measured, -1);
				if (this.orientation > 0) {
					verticalLayout(this, &measured, this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				if (this.orientation < 0) {
					horizontalLayout(this, &measured, -this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				r: Rect := {
					r.x0 := measured.x0;
					r.y0 := measured.y0;
					r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
					r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
				};
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					Style.align(measured, &rect, item.align);
					if ((layout) != null) {
						layout.onLayout(layout, &rect);
					}
				}
				addPadding(this, &measured, 1);
			};
			const onLayout(this: Layout, measured: Rect): void := onLayout;
			static onDraw(this: Layout, offs: Image, parent: Rect): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					state: int32 := 0;
					if (as(view, Layout) == null) {
						if (i == this.hoveredIndex) {
							state := state | Style.hovered;
						}
						if (i == this.pressedIndex) {
							state := state | Style.pressed;
						}
						if (i == this.focusedIndex) {
							state := state | Style.focused;
						}
					}
					onDraw(view, offs, rect, state);
				}
			};
			static Custom(rowsCols: int32, alignment: int32, items: View[]): Layout := {
				layout: Layout := {
					layout := create(Layout);
					layout.orientation := rowsCols;
					layout.onLayout := onLayout;
					layout.paddingBottom := 0;
					layout.paddingRight := 0;
					layout.paddingLeft := 0;
					layout.paddingTop := 0;
					layout.focusedIndex := -1;
					layout.pressedIndex := -1;
					layout.hoveredIndex := -1;
					layout.itemCapacity := 0;
					layout.itemCount := 0;
					layout.items := (null);
					layout.separator := (null);
					layout.width := -5;
					layout.height := -5;
					layout.enabled := true;
					layout.focusable := true;
					layout.parent := (null);
					layout.style := (null);
					layout.data := (null);
					layout.onClick := onClick;
					layout.onReset := onReset;
					layout.onCreate := onCreate;
					layout.onDestroy := onDestroy;
					layout.onKeyEvent := onKeyEvent;
					layout.onTouchEvent := onTouchEvent;
					layout.onMeasure := onMeasure;
					layout.onDraw := onDraw;
				};
				if (items.length > (0)) {
					addItems(layout, alignment, ...items);
				}
				return .result := layout;
			};
			static Row(items: View[]): Layout := {
				return .result := Custom(-1, Style.fill, ...items);
			};
			static Column(items: View[]): Layout := {
				return .result := Custom(1, Style.fill, ...items);
			};
			static Stack(items: View[]): Layout := {
				return .result := Custom(0, Style.fill, ...items);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Widget: struct {
			measure: bool := true;
			redraw: bool := true;
			focus: View := null;
			scrollX: int32 := 0;
			scrollY: int32 := 0;
			static focusNext(view: View, prev: bool): bool := {
				if ((view) == null) {
					return .result := false;
				}
				if (!view.enabled) {
					return .result := false;
				}
				if (!view.focusable) {
					return .result := false;
				}
				this: Layout := as(view, Layout);
				if ((this) == null) {
					return .result := true;
				}
				n: int32 := this.focusedIndex;
				if (prev) {
					if (n < 0) {
						n := this.itemCount - 1;
					}
					for (i: int32 := n; i >= 0; i := i - 1) {
						const item: Item := this.items[i];
						const rect: Rect := item.rect;
						const view: View := item.view;
						if (!empty(rect) && focusNext(view, prev)) {
							if (as(view, Layout) != null || i != this.focusedIndex) {
								this.focusedIndex := i;
								return .result := true;
							}
						}
					}
				}
				else {
					if (n < 0) {
						n := 0;
					}
					for (i: int32 := n; i < this.itemCount; i := i + 1) {
						const item: Item := this.items[i];
						const rect: Rect := item.rect;
						const view: View := item.view;
						if (!empty(rect) && focusNext(view, prev)) {
							if (as(view, Layout) != null || i > this.focusedIndex) {
								this.focusedIndex := i;
								return .result := true;
							}
						}
					}
				}
				clearState(this, Style.focused);
				return .result := false;
			};
			static addItems(this: Widget, align: int32, views: View[]): Widget := {
				Layout.addItems(this, align, ...views);
				return .result := this;
			};
			static addItems(this: Widget, views: View[]): Widget := {
				Layout.addItems(this, Style.fill, ...views);
				return .result := this;
			};
			static focus(this: Widget, value: View): Widget := {
				this.focus := value;
				return .result := this;
			};
			static padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout := {
				Layout.padding(this, top, left, right, bottom);
				return .result := this;
			};
			static padding(this: Widget, vertical: int32, horizontal: int32): Layout := {
				Layout.padding(this, vertical, horizontal, horizontal, vertical);
				return .result := this;
			};
			static padding(this: Widget, padding: int32): Widget := {
				Layout.padding(this, padding, padding, padding, padding);
				return .result := this;
			};
			static onCreate(this: Widget, parent: View): void := {
				Layout.onCreate(this, parent);
				this.measure := true;
				if ((this.focus) != null) {
					focus(this.focus);
					this.focus := (null);
				}
			};
			static onKeyEvent(this: Widget, const event: KeyEvent): bool := {
				if (Layout.onKeyEvent(this, event)) {
					return .result := true;
				}
				if (event.release) {
					return .result := false;
				}
				if ((event.key) == Window.KEY_CODE_TAB || (event.key) == Window.KEY_CODE_ENTER) {
					clearState(this, Style.hovered);
					if (!focusNext(this, event.isShift)) {
						return .result := focusNext(this, event.isShift);
					}
					return .result := true;
				}
				return .result := false;
			};
			static onMeasure(this: Widget, measured: Rect): bool := {
				Layout.onMeasure(this, &measured);
				this.onLayout(this, &measured);
				return .result := true;
			};
			static onDraw(this: Widget, offs: Image, rect: Rect): void := {
				fillRect(offs, rect, this.style.backgroundColor);
				Layout.onDraw(this, offs, rect);
			};
			static const Item: struct {
				rect: Rect;
				view: View;
				align: int32;
			};
			separator: View := null;
			items: Item[*] := null;
			itemCount: int32 := 0;
			itemCapacity: int32 := 0;
			hoveredIndex: int32 := -1;
			pressedIndex: int32 := -1;
			focusedIndex: int32 := -1;
			paddingTop: int32 := 0;
			paddingLeft: int32 := 0;
			paddingRight: int32 := 0;
			paddingBottom: int32 := 0;
			orientation: int32 := 1;
			static clearState(this: Layout, mode: int32): bool := {
				result: bool := false;
				if ((mode & Style.hovered) && this.hoveredIndex >= 0) {
					view: View := this.items[this.hoveredIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.hoveredIndex := -1;
					result := true;
				}
				if ((mode & Style.pressed) && this.pressedIndex >= 0) {
					view: View := this.items[this.pressedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.pressedIndex := -1;
					result := true;
				}
				if ((mode & Style.focused) && this.focusedIndex >= 0) {
					view: View := this.items[this.focusedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.focusedIndex := -1;
					result := true;
				}
				return .result := result;
			};
			static getPressed(const this: Layout): View := {
				if (this.pressedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.pressedIndex].view;
				if ((layout) != null) {
					child: View := getPressed(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static getFocused(const this: Layout): View := {
				if (this.focusedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.focusedIndex].view;
				if ((layout) != null) {
					child: View := getFocused(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static setFocused(this: Layout, focus: View): bool := {
				if ((focus) == null) {
					clearState(this, Style.focused);
				}
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					const view: View := item.view;
					if (view == focus && this.focusedIndex != i) {
						clearState(this, Style.focused);
						this.focusedIndex := i;
						return .result := true;
					}
					if ((layout) != null) {
						if (setFocused(layout, focus) && this.focusedIndex != i) {
							clearState(this, Style.focused);
							this.focusedIndex := i;
							return .result := true;
						}
					}
				}
				return .result := false;
			};
			static capacity(this: Layout, capacity: int32): Layout := {
				assert(capacity >= this.itemCount);
				if (capacity == this.itemCapacity) {
					return;
				}
				items: Item[*] := this.items;
				this.itemCapacity := capacity;
				this.items := (pointer.alloc(null, this.itemCapacity * sizeof(Item)));
				pointer.copy(this.items, items, this.itemCount * sizeof(Item));
				pointer.alloc(items, 0);
				return .result := this;
			};
			static addItems(this: Layout, alignment: int32, views: View[]): Layout := {
				static separator(this: Layout): View := {
					static onDraw(this: View, offs: Image, rect: Rect): void := {
					};
					if ((this.separator) != null) {
						return .result := this.separator;
					}
					separator: View := {
						separator := create(View);
						separator.enabled := false;
						separator.focusable := false;
						separator.onDraw := onDraw;
						separator.width := -5;
						separator.height := -5;
						separator.parent := (null);
						separator.style := (null);
						separator.data := (null);
						separator.onClick := onClick;
						separator.onReset := onReset;
						separator.onCreate := onCreate;
						separator.onDestroy := onDestroy;
						separator.onKeyEvent := onKeyEvent;
						separator.onTouchEvent := onTouchEvent;
						separator.onMeasure := onMeasure;
					};
					this.separator := separator;
					return .result := separator;
				};
				itemCount: int32 := this.itemCount + (views.length);
				if (itemCount >= this.itemCapacity) {
					capacity: int32 := 2 * this.itemCapacity;
					if (capacity < itemCount) {
						capacity := itemCount;
					}
					capacity(this, capacity);
				}
				for (i: int32 := 0; i < (views.length); i := i + 1) {
					item: Item := this.items[this.itemCount + i];
					item.view := views[i];
					item.align := alignment;
					if ((item.view) == null) {
						item.view := separator(this);
					}
				}
				this.itemCount := itemCount;
				return .result := this;
			};
			static size(this: Layout): int32 := {
				return .result := this.itemCount;
			};
			static getView(this: Layout, idx: int32): View := {
				assert(idx >= 0 && idx < this.itemCount);
				return .result := this.items[idx].view;
			};
			static setAlignment(this: Layout, idx: int32, alignment: int32): void := {
				assert(idx >= 0 && idx < this.itemCount);
				this.items[idx].align := alignment;
			};
			static padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout := {
				this.paddingTop := top;
				this.paddingLeft := left;
				this.paddingRight := right;
				this.paddingBottom := bottom;
				invalidate(this, true);
				return .result := this;
			};
			static onClick(this: Layout): bool := {
				error("onClick", this);
				return .result := false;
			};
			static onReset(this: Layout): bool := {
				result: bool := false;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					if (view.onReset(view)) {
						result := true;
					}
				}
				return .result := result;
			};
			static onCreate(this: Layout, parent: View): void := {
				assert((this.parent) == null, "can not add the same layout multiple times");
				View.onCreate(this, parent);
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onCreate(view, this);
				}
			};
			static onDestroy(this: Layout): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onDestroy(view);
					destroy(view);
				}
				pointer.alloc(this.items, 0);
			};
			static onKeyEvent(this: Layout, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				idx: int32 := this.focusedIndex;
				if (idx < 0) {
					return .result := false;
				}
				view: View := this.items[idx].view;
				return .result := view.onKeyEvent(view, event);
			};
			static onTouchEvent(this: Layout, const rect: Rect, const event: TouchEvent): bool := {
				static findView(this: Layout, x: int32, y: int32): int32 := {
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						if (item.view.enabled && contains(item.rect, x, y)) {
							return .result := i;
						}
					}
					return .result := -1;
				};
				if (!this.enabled) {
					return .result := false;
				}
				result: bool := false;
				active: int32 := this.pressedIndex;
				if (!((event.dx) || (event.dy) || event.release) || !(event.button)) {
					active := findView(this, event.x, event.y);
				}
				if (active < 0) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				item: Item := this.items[active];
				view: View := item.view;
				if (!view.enabled) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				if (this.pressedIndex != active && TouchEvent.isPress(event, 1)) {
					clearState(this, Style.pressed);
					this.pressedIndex := active;
					result := true;
				}
				outside: bool := !TouchEvent.test(event, item.rect);
				if (this.hoveredIndex != active || outside) {
					if (clearState(this, Style.hovered)) {
						result := true;
					}
					if (!outside) {
						this.hoveredIndex := active;
						result := true;
					}
				}
				if (event.release && outside) {
					return .result := clearState(this, Style.pressed | Style.hovered);
				}
				if (view.onTouchEvent(view, item.rect, event)) {
					result := true;
				}
				if (!event.release) {
					return .result := result;
				}
				focusable: bool := view.focusable;
				if (outside) {
					focusable := false;
				}
				else if (event.clicks < 0) {
					clearState(this, Style.hovered);
					focusable := false;
				}
				else if (this.focusedIndex == active) {
					focusable := false;
				}
				else if ((layout) != null) {
					if (layout.focusedIndex == -1) {
						focusable := false;
					}
				}
				if (focusable) {
					clearState(this, Style.focused);
					this.focusedIndex := active;
					result := true;
				}
				if (clearState(this, Style.pressed)) {
					return .result := true;
				}
				return .result := result;
			};
			static onMeasure(this: Layout, measured: Rect): bool := {
				dir: int32 := this.orientation;
				N: int32 := Math.abs(dir);
				n: int32 := 0;
				maxWidth: int32 := 0;
				sumWidth: int32 := 0;
				maxHeight: int32 := 0;
				sumHeight: int32 := 0;
				rows: int32 := dir < 0 ? N : 1;
				cols: int32 := dir > 0 ? N : 1;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					item: Item := this.items[i];
					rect: Rect := item.rect;
					view: View := item.view;
					rect.x0 := rect.x1 := 0;
					rect.y0 := rect.y1 := 0;
					if (view.onMeasure(view, &rect)) {
						width: int32 := width(rect);
						height: int32 := height(rect);
						if (n >= N) {
							cols := cols + int32(dir < 0);
							rows := rows + int32(dir > 0);
							n := 0;
						}
						sumWidth := sumWidth + width;
						if (maxWidth < width) {
							maxWidth := width;
						}
						sumHeight := sumHeight + height;
						if (maxHeight < height) {
							maxHeight := height;
						}
						n := n + 1;
					}
				}
				if (rows == 1 && cols == 1) {
					sumWidth := maxWidth;
					sumHeight := maxHeight;
				}
				if (rows > 1) {
					sumWidth := maxWidth * cols;
				}
				if (cols > 1) {
					sumHeight := maxHeight * rows;
				}
				width(measured, sumWidth + this.paddingLeft + this.paddingRight);
				height(measured, sumHeight + this.paddingTop + this.paddingBottom);
				return .result := View.onMeasure(this, &measured);
			};
			static onLayout(this: Layout, measured: Rect): void := {
				static verticalLayout(this: Layout, measured: Rect, cols: int32): void := {
					rowSpacing: int32 := width(measured) / cols;
					colSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						rows: int32 := 0;
						n: int32 := cols;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= cols) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									rows := rows + 1;
									n := 0;
								}
								if (maxSize < height(rect)) {
									maxSize := height(rect);
								}
								if (colSpacing < maxSize) {
									colSpacing := maxSize;
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (rows > 0 && height(measured) > sumSize) {
							grow := (height(measured) - sumSize) / rows;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := cols;
					translateY(r, -colSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= cols) {
							positionX(r, measured.x0);
							translateY(r, colSpacing + grow);
							if (cols == 1) {
								colSpacing := height(rect);
							}
							n := 0;
						}
						width(r, rowSpacing);
						height(r, colSpacing + grow);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateX(r, rowSpacing);
						n := n + 1;
					}
				};
				static horizontalLayout(this: Layout, measured: Rect, rows: int32): void := {
					colSpacing: int32 := height(measured) / rows;
					rowSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						cols: int32 := 0;
						n: int32 := rows;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= rows) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									cols := cols + 1;
									n := 0;
								}
								if (maxSize < width(rect)) {
									maxSize := width(rect);
								}
								if (rowSpacing < width(rect)) {
									rowSpacing := width(rect);
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (cols > 0 && width(measured) > sumSize) {
							grow := (width(measured) - sumSize) / cols;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := rows;
					translateX(r, -rowSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= rows) {
							positionY(r, measured.y0);
							translateX(r, rowSpacing + grow);
							if (rows == 1) {
								rowSpacing := width(rect);
							}
							n := 0;
						}
						width(r, rowSpacing + grow);
						height(r, colSpacing);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateY(r, colSpacing);
						n := n + 1;
					}
				};
				static addPadding(const this: Layout, rect: Rect, multiplier: int32): void := {
					rect.x0 := rect.x0 - multiplier * this.paddingLeft;
					rect.y0 := rect.y0 - multiplier * this.paddingTop;
					rect.x1 := rect.x1 + multiplier * this.paddingRight;
					rect.y1 := rect.y1 + multiplier * this.paddingBottom;
				};
				addPadding(this, &measured, -1);
				if (this.orientation > 0) {
					verticalLayout(this, &measured, this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				if (this.orientation < 0) {
					horizontalLayout(this, &measured, -this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				r: Rect := {
					r.x0 := measured.x0;
					r.y0 := measured.y0;
					r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
					r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
				};
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					Style.align(measured, &rect, item.align);
					if ((layout) != null) {
						layout.onLayout(layout, &rect);
					}
				}
				addPadding(this, &measured, 1);
			};
			const onLayout(this: Layout, measured: Rect): void := onLayout;
			static onDraw(this: Layout, offs: Image, parent: Rect): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					state: int32 := 0;
					if (as(view, Layout) == null) {
						if (i == this.hoveredIndex) {
							state := state | Style.hovered;
						}
						if (i == this.pressedIndex) {
							state := state | Style.pressed;
						}
						if (i == this.focusedIndex) {
							state := state | Style.focused;
						}
					}
					onDraw(view, offs, rect, state);
				}
			};
			static Custom(rowsCols: int32, alignment: int32, items: View[]): Layout := {
				layout: Layout := {
					layout := create(Layout);
					layout.orientation := rowsCols;
					layout.onLayout := onLayout;
					layout.paddingBottom := 0;
					layout.paddingRight := 0;
					layout.paddingLeft := 0;
					layout.paddingTop := 0;
					layout.focusedIndex := -1;
					layout.pressedIndex := -1;
					layout.hoveredIndex := -1;
					layout.itemCapacity := 0;
					layout.itemCount := 0;
					layout.items := (null);
					layout.separator := (null);
					layout.width := -5;
					layout.height := -5;
					layout.enabled := true;
					layout.focusable := true;
					layout.parent := (null);
					layout.style := (null);
					layout.data := (null);
					layout.onClick := onClick;
					layout.onReset := onReset;
					layout.onCreate := onCreate;
					layout.onDestroy := onDestroy;
					layout.onKeyEvent := onKeyEvent;
					layout.onTouchEvent := onTouchEvent;
					layout.onMeasure := onMeasure;
					layout.onDraw := onDraw;
				};
				if (items.length > (0)) {
					addItems(layout, alignment, ...items);
				}
				return .result := layout;
			};
			static Row(items: View[]): Layout := {
				return .result := Custom(-1, Style.fill, ...items);
			};
			static Column(items: View[]): Layout := {
				return .result := Custom(1, Style.fill, ...items);
			};
			static Stack(items: View[]): Layout := {
				return .result := Custom(0, Style.fill, ...items);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static getWidget(view: View): Widget := {
			for (v: View := view; (v) != null; v := v.parent) {
				if ((w) != null) {
					return .result := w;
				}
				assert(v != v.parent);
			}
			return .result := null;
		};
		static focus(view: View): void := {
			static clearFocus(layout: Layout): void := {
				for (i: int32 := 0; i < layout.itemCount; i := i + 1) {
					view: View := layout.items[i].view;
					if ((child) != null) {
						clearFocus(child);
					}
				}
				layout.hoveredIndex := -1;
				layout.pressedIndex := -1;
				layout.focusedIndex := -1;
			};
			widget: Widget := getWidget(view);
			layout: Layout := View.as(view, Layout);
			if ((layout) == null) {
				clearFocus(widget);
				Widget.setFocused(widget, view);
				return;
			}
			focus: View := Layout.getFocused(layout);
			if ((focus) != null) {
				clearFocus(widget);
				Widget.setFocused(widget, focus);
				return;
			}
			rect: Rect := {
				rect.x0 := 0;
				rect.y0 := 0;
				rect.x1 := 0;
				rect.y1 := 0;
			};
			widget.onMeasure(widget, &rect);
			clearFocus(widget);
			Widget.setFocused(widget, view);
			Widget.focusNext(widget, false);
			widget.measure := true;
		};
		static invalidate(view: View, layout: bool): void := {
			widget: Widget := getWidget(view);
			if (layout) {
				widget.measure := true;
			}
			widget.redraw := true;
		};
		invalidate(view: View): void := invalidate(view, true);
		static isFocused(view: View): bool := {
			widget: Widget := getWidget(view);
			return .result := view == Widget.getFocused(widget);
		};
		static isPressed(view: View): bool := {
			widget: Widget := getWidget(view);
			return .result := view == Widget.getPressed(widget);
		};
		static isDirty(view: View): bool := {
			widget: Widget := getWidget(view);
			return .result := widget.measure;
		};
		static const Button: struct {
			const text: char[*];
			static onMeasure(this: Button, rect: Rect): bool := {
				style: Style := this.style;
				Style.measure(style, &rect, this.text);
				return .result := View.onMeasure(this, &rect);
			};
			static onDraw(this: Button, offs: Image, rect: Rect): void := {
				View.onDraw(this, offs, rect, null, this.text);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Switch: struct {
			static const onOff: char[*][] := {
				onOff := onOff.init;
				onOff.init[0] := ("off");
				onOff.init[1] := ("on");
			};
			const text: char[*];
			const states: char[*][] := onOff;
			selected: int32 := 0;
			const resetValue: int32 := 0;
			const clickToFocus: bool := true;
			static checked(this: Switch): bool := {
				return .result := this.selected != 0;
			};
			static onUpdate(this: Switch, selected: int32): bool := {
				maxValue: int32 := this.states.length;
				if (maxValue == 0) {
					maxValue := 2;
				}
				if (selected >= maxValue) {
					selected := maxValue - 1;
				}
				else if (selected < 0) {
					selected := 0;
				}
				if (this.selected == selected) {
					return .result := isDirty(this);
				}
				this.selected := selected;
				return .result := true;
			};
			const onUpdate(this: Switch, selected: int32): bool := onUpdate;
			static onReset(this: Switch): bool := {
				return .result := this.onUpdate(this, this.resetValue);
			};
			static onClick(this: Switch): bool := {
				if (this.focusable && this.clickToFocus) {
					if (!isFocused(this)) {
						return .result := true;
					}
				}
				maxValue: int32 := this.states.length;
				value: int32 := this.selected + 1;
				if (maxValue == 0) {
					maxValue := 2;
				}
				if (value >= maxValue) {
					value := 0;
				}
				return .result := this.onUpdate(this, value);
			};
			static onCreate(this: Switch, parent: View): void := {
				View.onCreate(this, parent);
				resetValue: int32 := pointer(this.resetValue);
				Switch.onUpdate(this, this.selected);
				resetValue := this.selected;
				this.onReset(this);
			};
			static onKeyEvent(this: Switch, const event: KeyEvent): bool := {
				if (!this.enabled || event.release) {
					return .result := View.onKeyEvent(this, event);
				}
				if (event.key == ('+') || event.key == ('=')) {
					value: int32 := this.selected + 1;
					return .result := this.onUpdate(this, value);
				}
				if (event.key == ('-') || event.key == ('_')) {
					value: int32 := this.selected - 1;
					return .result := this.onUpdate(this, value);
				}
				return .result := View.onKeyEvent(this, event);
			};
			static onTouchEvent(this: Switch, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled || !event.release) {
					return .result := View.onTouchEvent(this, rect, event);
				}
				if (event.isShift && event.clicks >= 0) {
					value: int32 := this.selected - 1;
					return .result := this.onUpdate(this, value);
				}
				return .result := View.onTouchEvent(this, rect, event);
			};
			static onMeasure(this: Switch, rect: Rect): bool := {
				maxWidth: int32 := 0;
				style: Style := this.style;
				for (i: int32 := 0; i < (this.states.length); i := i + 1) {
					measured: Rect := {
						measured.x0 := 0;
						measured.y0 := 0;
						measured.x1 := 0;
						measured.y1 := 0;
					};
					Style.measure(style, &measured, this.states[i]);
					if (maxWidth < width(measured)) {
						maxWidth := width(measured);
					}
				}
				Style.measure(style, &rect, this.text);
				if (this.states.length == (0)) {
					width(rect, width(rect) + height(rect) * 3 / 2);
				}
				else {
					width(rect, width(rect) + maxWidth);
				}
				return .result := View.onMeasure(this, &rect);
			};
			static onDraw(this: Switch, offs: Image, rect: Rect): void := {
				value: char[*] := null;
				style: Style := this.style;
				if (this.states.length == (0)) {
					onOffRect: Rect := {
						onOffRect.x0 := rect.x0;
						onOffRect.y0 := rect.y0;
						onOffRect.x1 := rect.x0 + height(rect) * 3 / 2;
						onOffRect.y1 := rect.y1;
					};
					Style.align(rect, &onOffRect, Style.right);
					rect.x1 := onOffRect.x0;
					padded(onOffRect, -style.padding);
					color: uint32 := style.focusedColor;
					if (checked(this)) {
						color := style.valueColor;
					}
					else if (isFocused(this)) {
						color := style.hoveredColor;
					}
					fillRRect(offs, onOffRect, height(onOffRect) / 2, color);
					if (checked(this)) {
						onOffRect.x0 := onOffRect.x1 - height(onOffRect);
					}
					else {
						onOffRect.x1 := onOffRect.x0 + height(onOffRect);
					}
					padded(onOffRect, -style.padding / 3);
					fillOval(offs, onOffRect, style.textColor);
				}
				else {
					value := (this.states[this.selected]);
				}
				View.onDraw(this, offs, rect, this.text, value);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Slider: struct {
			const text: char[*];
			value: float64 := 0;
			_value: float64 := 0;
			const minimum: float64 := 0;
			const maximum: float64 := 1;
			const stepSize: float64 := 0;
			const resetValue: float64 := 0;
			const clickToFocus: bool := true;
			static onUpdate(this: Slider, value: float64): bool := {
				if (value > this.maximum) {
					value := this.maximum;
				}
				if (value < this.minimum) {
					value := this.minimum;
				}
				this._value := value;
				if (this.stepSize != (0)) {
					value := Math.round(value / this.stepSize) * this.stepSize;
				}
				if (this.value == value) {
					return .result := isDirty(this);
				}
				this.value := value;
				return .result := true;
			};
			const onUpdate(this: Slider, value: float64): bool := onUpdate;
			static onReset(this: Slider): bool := {
				return .result := this.onUpdate(this, this.resetValue);
			};
			static onCreate(this: Slider, parent: View): void := {
				View.onCreate(this, parent);
				resetValue: float64 := pointer(this.resetValue);
				Slider.onUpdate(this, this.value);
				resetValue := this.value;
				this.onReset(this);
			};
			static onKeyEvent(this: Slider, const event: KeyEvent): bool := {
				if (event.release) {
					return .result := View.onKeyEvent(this, event);
				}
				if (event.key == (' ')) {
					return .result := this.onReset(this);
				}
				if (event.key == ('+') || event.key == ('=')) {
					return .result := this.onUpdate(this, this._value + ((event.isShift ? 1 : 10)));
				}
				if (event.key == ('-') || event.key == ('_')) {
					return .result := this.onUpdate(this, this._value - ((event.isShift ? 1 : 10)));
				}
				return .result := View.onKeyEvent(this, event);
			};
			static onTouchEvent(this: Slider, const rect: Rect, const event: TouchEvent): bool := {
				if (event.button == 0) {
					return .result := false;
				}
				if (event.release && (event.clicks < 0 || event.clicks > 1)) {
					return .result := this.onReset(this);
				}
				if (event.clicks < 1) {
					value: float64 := event.dx;
					if (!event.isShift && value != (0)) {
						value := value * float64(this.maximum - this.minimum) / (width(rect));
					}
					value := value + this._value;
					if (value > this.maximum) {
						value := this.maximum;
					}
					if (value < this.minimum) {
						value := this.minimum;
					}
					return .result := this.onUpdate(this, value);
				}
				if (event.release) {
					if (this.focusable && this.clickToFocus) {
						if (!isFocused(this)) {
							return .result := true;
						}
					}
					value: float64 := event.x - rect.x0;
					value := value * float64(this.maximum - this.minimum) / (width(rect));
					return .result := this.onUpdate(this, this.minimum + value);
				}
				return .result := View.onTouchEvent(this, rect, event);
			};
			static onMeasure(this: Slider, rect: Rect): bool := {
				value: char[64] := {
					value[0] := (0);
				};
				style: Style := this.style;
				if (this.stepSize != (0) && this.stepSize % (1) == (0)) {
					append(value, 0, int64(this.value), style.format);
				}
				else {
					append(value, 0, this.value, style.format);
				}
				valueRect: Rect := {
					valueRect.x0 := 0;
					valueRect.y0 := 0;
					valueRect.x1 := 0;
					valueRect.y1 := 0;
				};
				Style.measure(style, &valueRect, value);
				Style.measure(style, &rect, this.text);
				width(rect, width(rect) + width(valueRect));
				return .result := View.onMeasure(this, &rect);
			};
			static onDrawSlider(this: Slider, offs: Image, rect: Rect): void := {
				if (this.maximum == this.minimum) {
					return;
				}
				style: Style := this.style;
				const y1: int32 := rect.y1;
				const y0: int32 := y1 - style.padding / 4;
				const x0: int32 := rect.x0;
				const x1: int32 := rect.x1;
				const x: int32 := (x0) + (this.value - this.minimum) * (width(rect)) / (this.maximum - this.minimum);
				if (x > x0) {
					fillRect(offs, x0, y0, x, y1, style.valueColor);
				}
				if (x < x1) {
					fillRect(offs, x, y0, x1, y1, style.focusedColor);
				}
			};
			const onDrawSlider(this: Slider, offs: Image, rect: Rect): void := onDrawSlider;
			static onDraw(this: Slider, offs: Image, rect: Rect): void := {
				value: char[64] := {
					value[0] := (0);
				};
				if (this.stepSize != (0) && this.stepSize % (1) == (0)) {
					append(value, 0, int64(this.value), this.style.format);
				}
				else {
					append(value, 0, this.value, this.style.format);
				}
				if ((this.onDrawSlider) != null) {
					this.onDrawSlider(this, offs, rect);
				}
				View.onDraw(this, offs, rect, this.text, value);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Histogram: struct {
			const lines: bool := false;
			color: bool := false;
			data: argb[256];
			static update(this: Histogram, image: Image): void := {
				data: uint32[*] := pointer(this.data);
				Image.calcRgbHist(image, null, &data);
				this.color := false;
			};
			static onUpdate(this: Histogram, idx: int32, value: int32): bool := {
				this.data[idx] := argb(idx, value, value, value);
				return .result := true;
			};
			const onUpdate(this: Histogram, idx: int32, value: int32): bool := onUpdate;
			static onReset(this: Histogram): bool := {
				result: bool := false;
				for (i: int32 := 0; i < 256; i := i + 1) {
					result := result | Histogram.onUpdate(this, i, i);
				}
				return .result := result;
			};
			static onCreate(this: Histogram, parent: View): void := {
				View.onCreate(this, parent);
				Histogram.onReset(this);
			};
			static onTouchEvent(this: Histogram, const rect: Rect, const event: TouchEvent): bool := {
				if (event.release || !(event.button)) {
					return .result := View.onTouchEvent(this, rect, event);
				}
				px: int32 := Math.max(0, width(rect) - 256) / 2;
				x0: int32 := event.x - rect.x0 - px;
				x1: int32 := x0 - event.dx;
				y0: int32 := event.y - rect.y0;
				y1: int32 := y0 - event.dy;
				if (x0 > x1) {
					x: int32 := x0;
					x0 := x1;
					x1 := x;
					y: int32 := y0;
					y0 := y1;
					y1 := y;
				}
				y: int32 := y0 << 16;
				dy: int32 := y1 - y0;
				if (x1 != x0) {
					dy := (dy << 16) / (x1 - x0);
				}
				if (x0 < 0) {
					y := y - x0 * dy;
					x0 := 0;
				}
				if (x1 > 256) {
					x1 := 256;
				}
				h: int32 := height(rect);
				for (x: int32 := x0; x < x1; x := x + 1) {
					val: int32 := 255 * (h - (y >> 16)) / h;
					this.onUpdate(this, x, val);
					y := y + dy;
				}
				return .result := true;
			};
			static onMeasure(this: Histogram, rect: Rect): bool := {
				if (this.width < 0) {
					width(rect, 256);
				}
				if (this.height < 0) {
					height(rect, 128);
				}
				return .result := View.onMeasure(this, &rect);
			};
			static onDraw(this: Histogram, offs: Image, const rect: Rect): void := {
				px: int32 := (width(rect) - 256) / 2;
				h: int32 := height(rect);
				if (this.lines) {
					y: int32 := rect.y1;
					pb: int32 := bch(this.data[0]) * h / 256;
					pg: int32 := gch(this.data[0]) * h / 256;
					pr: int32 := rch(this.data[0]) * h / 256;
					pl: int32 := ach(this.data[0]) * h / 256;
					for (i: int32 := 1; i < this.data.(length); i := i + 1) {
						x: int32 := rect.x0 + i + px;
						data: argb := this.data[i];
						bv: int32 := bch(data) * h / 256;
						gv: int32 := gch(data) * h / 256;
						rv: int32 := rch(data) * h / 256;
						lv: int32 := ach(data) * h / 256;
						if (this.color) {
							fillRect(offs, x, y - pl, x + 1, y - lv + int32(pl == lv), data.v);
						}
						else {
							fillRect(offs, x, y - pb, x + 1, y - bv + int32(pb == bv), colB);
							fillRect(offs, x, y - pg, x + 1, y - gv + int32(pg == gv), colG);
							fillRect(offs, x, y - pr, x + 1, y - rv + int32(pr == rv), colR);
							fillRect(offs, x, y - pl, x + 1, y - lv + int32(pl == lv), colL);
						}
						pb := bv;
						pg := gv;
						pr := rv;
						pl := lv;
					}
				}
				else if (this.color) {
					for (i: int32 := 0; i < this.data.(length); i := i + 1) {
						data: argb := this.data[i];
						x: int32 := rect.x0 + i + px;
						y1: int32 := rect.y1;
						y0: int32 := y1 - ach(data) * h / 256;
						fillRect(offs, x, y0 - int32(y1 == y0), x + 1, y1, uint32(data));
					}
				}
				else {
					for (i: int32 := 0; i < this.data.(length); i := i + 1) {
						x: int32 := rect.x0 + i + px;
						data: argb := this.data[i];
						bv: int32 := bch(data) * h / 256;
						gv: int32 := gch(data) * h / 256;
						rv: int32 := rch(data) * h / 256;
						lv: int32 := ach(data) * h / 256;
						for (y: int32 := 0; y < h; y := y + 1) {
							b: uint32 := colB * (uint32(y < bv));
							g: uint32 := colG * (uint32(y < gv));
							r: uint32 := colR * (uint32(y < rv));
							l: uint32 := colL * (uint32(y < lv));
							Image.set(offs, x, h - y + rect.y0 - 1, r | g | b | l);
						}
					}
				}
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const DebugView: struct {
			text: char[64];
			started: int64 := 0;
			maxDuration: int64 := 0;
			durations: int64[64];
			measures: int64 := 0;
			draws: int64 := 0;
			static startTimer(this: DebugView): void := {
				this.started := System.millis();
				this.maxDuration := (0);
				for (i: int32 := this.durations.(length) - 1; i >= 1; i := i - 1) {
					duration: int64 := this.durations[i - 1];
					this.durations[i] := duration;
					if (this.maxDuration < duration) {
						this.maxDuration := duration;
					}
				}
				this.durations[0] := this.maxDuration;
			};
			static update(this: DebugView): void := {
				pos: int32 := 0;
				if (this.measures > (0)) {
					pos := append(this.text, pos, pos > 0 ? ", " : "");
					pos := append(this.text, pos, "measures: ");
					pos := append(this.text, pos, this.measures);
				}
				if (this.draws > (0)) {
					pos := append(this.text, pos, pos > 0 ? ", " : "");
					pos := append(this.text, pos, "draws: ");
					pos := append(this.text, pos, this.draws);
				}
				if (this.durations[0] > (0) || pos == 0) {
					pos := append(this.text, pos, pos > 0 ? ", " : "");
					pos := append(this.text, pos, "time: ");
					pos := append(this.text, pos, this.durations[0]);
				}
			};
			static onClick(this: DebugView): bool := {
				return .result := this.onReset(this);
			};
			static onReset(this: DebugView): bool := {
				if (this.measures > (0)) {
					this.measures := (0);
				}
				if (this.draws > (0)) {
					this.draws := (0);
				}
				for (i: int32 := 0; i < this.durations.(length); i := i + 1) {
					this.durations[i] := (0);
				}
				this.maxDuration := (0);
				this.started := (0);
				return .result := true;
			};
			static onCreate(this: DebugView, parent: View): void := {
				View.onCreate(this, parent);
				onReset(this);
			};
			static onMeasure(this: DebugView, rect: Rect): bool := {
				if (this.measures >= (0)) {
					this.measures := this.measures + (1);
				}
				update(this);
				style: Style := this.style;
				Style.measure(style, &rect, this.text);
				return .result := View.onMeasure(this, &rect);
			};
			static onDraw(this: DebugView, offs: Image, rect: Rect): void := {
				if (this.started > (0)) {
					duration: int64 := System.millis() - this.started;
					this.durations[0] := duration;
					if (this.maxDuration < duration) {
						this.maxDuration := duration;
					}
					this.started := (0);
				}
				style: Style := this.style;
				if (this.maxDuration > (0)) {
					y0: int32 := rect.y1;
					ys: float64 := (height(rect)) / float64(this.maxDuration);
					xs: float64 := (width(rect)) / float64(this.durations.(length));
					for (i: int32 := 0; i < this.durations.(length); i := i + 1) {
						y1: int32 := (y0) - ys * (this.durations[i]);
						x1: int32 := (rect.x0) + xs * ((this.durations.(length) - i));
						fillRect(offs, (x1) - xs, y0, x1, y1, style.focusedColor);
					}
				}
				if (this.draws >= (0)) {
					this.draws := this.draws + (1);
				}
				update(this);
				Style.align(style, rect, &rect, this.text);
				Image.drawText(offs, rect, style.font, this.text, style.textColor);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Panel: struct {
			visible: bool := false;
			static visible(this: Panel, value: bool): bool := {
				if (this.visible == value) {
					return .result := false;
				}
				this.visible := value;
				invalidate(this);
				return .result := true;
			};
			static onMeasure(this: Panel, rect: Rect): bool := {
				if (!this.visible) {
					setSize(rect, 0, 0);
					return .result := false;
				}
				return .result := Layout.onMeasure(this, &rect);
			};
			static const Item: struct {
				rect: Rect;
				view: View;
				align: int32;
			};
			separator: View := null;
			items: Item[*] := null;
			itemCount: int32 := 0;
			itemCapacity: int32 := 0;
			hoveredIndex: int32 := -1;
			pressedIndex: int32 := -1;
			focusedIndex: int32 := -1;
			paddingTop: int32 := 0;
			paddingLeft: int32 := 0;
			paddingRight: int32 := 0;
			paddingBottom: int32 := 0;
			orientation: int32 := 1;
			static clearState(this: Layout, mode: int32): bool := {
				result: bool := false;
				if ((mode & Style.hovered) && this.hoveredIndex >= 0) {
					view: View := this.items[this.hoveredIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.hoveredIndex := -1;
					result := true;
				}
				if ((mode & Style.pressed) && this.pressedIndex >= 0) {
					view: View := this.items[this.pressedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.pressedIndex := -1;
					result := true;
				}
				if ((mode & Style.focused) && this.focusedIndex >= 0) {
					view: View := this.items[this.focusedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.focusedIndex := -1;
					result := true;
				}
				return .result := result;
			};
			static getPressed(const this: Layout): View := {
				if (this.pressedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.pressedIndex].view;
				if ((layout) != null) {
					child: View := getPressed(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static getFocused(const this: Layout): View := {
				if (this.focusedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.focusedIndex].view;
				if ((layout) != null) {
					child: View := getFocused(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static setFocused(this: Layout, focus: View): bool := {
				if ((focus) == null) {
					clearState(this, Style.focused);
				}
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					const view: View := item.view;
					if (view == focus && this.focusedIndex != i) {
						clearState(this, Style.focused);
						this.focusedIndex := i;
						return .result := true;
					}
					if ((layout) != null) {
						if (setFocused(layout, focus) && this.focusedIndex != i) {
							clearState(this, Style.focused);
							this.focusedIndex := i;
							return .result := true;
						}
					}
				}
				return .result := false;
			};
			static capacity(this: Layout, capacity: int32): Layout := {
				assert(capacity >= this.itemCount);
				if (capacity == this.itemCapacity) {
					return;
				}
				items: Item[*] := this.items;
				this.itemCapacity := capacity;
				this.items := (pointer.alloc(null, this.itemCapacity * sizeof(Item)));
				pointer.copy(this.items, items, this.itemCount * sizeof(Item));
				pointer.alloc(items, 0);
				return .result := this;
			};
			static addItems(this: Layout, alignment: int32, views: View[]): Layout := {
				static separator(this: Layout): View := {
					static onDraw(this: View, offs: Image, rect: Rect): void := {
					};
					if ((this.separator) != null) {
						return .result := this.separator;
					}
					separator: View := {
						separator := create(View);
						separator.enabled := false;
						separator.focusable := false;
						separator.onDraw := onDraw;
						separator.width := -5;
						separator.height := -5;
						separator.parent := (null);
						separator.style := (null);
						separator.data := (null);
						separator.onClick := onClick;
						separator.onReset := onReset;
						separator.onCreate := onCreate;
						separator.onDestroy := onDestroy;
						separator.onKeyEvent := onKeyEvent;
						separator.onTouchEvent := onTouchEvent;
						separator.onMeasure := onMeasure;
					};
					this.separator := separator;
					return .result := separator;
				};
				itemCount: int32 := this.itemCount + (views.length);
				if (itemCount >= this.itemCapacity) {
					capacity: int32 := 2 * this.itemCapacity;
					if (capacity < itemCount) {
						capacity := itemCount;
					}
					capacity(this, capacity);
				}
				for (i: int32 := 0; i < (views.length); i := i + 1) {
					item: Item := this.items[this.itemCount + i];
					item.view := views[i];
					item.align := alignment;
					if ((item.view) == null) {
						item.view := separator(this);
					}
				}
				this.itemCount := itemCount;
				return .result := this;
			};
			static size(this: Layout): int32 := {
				return .result := this.itemCount;
			};
			static getView(this: Layout, idx: int32): View := {
				assert(idx >= 0 && idx < this.itemCount);
				return .result := this.items[idx].view;
			};
			static setAlignment(this: Layout, idx: int32, alignment: int32): void := {
				assert(idx >= 0 && idx < this.itemCount);
				this.items[idx].align := alignment;
			};
			static padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout := {
				this.paddingTop := top;
				this.paddingLeft := left;
				this.paddingRight := right;
				this.paddingBottom := bottom;
				invalidate(this, true);
				return .result := this;
			};
			static onClick(this: Layout): bool := {
				error("onClick", this);
				return .result := false;
			};
			static onReset(this: Layout): bool := {
				result: bool := false;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					if (view.onReset(view)) {
						result := true;
					}
				}
				return .result := result;
			};
			static onCreate(this: Layout, parent: View): void := {
				assert((this.parent) == null, "can not add the same layout multiple times");
				View.onCreate(this, parent);
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onCreate(view, this);
				}
			};
			static onDestroy(this: Layout): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onDestroy(view);
					destroy(view);
				}
				pointer.alloc(this.items, 0);
			};
			static onKeyEvent(this: Layout, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				idx: int32 := this.focusedIndex;
				if (idx < 0) {
					return .result := false;
				}
				view: View := this.items[idx].view;
				return .result := view.onKeyEvent(view, event);
			};
			static onTouchEvent(this: Layout, const rect: Rect, const event: TouchEvent): bool := {
				static findView(this: Layout, x: int32, y: int32): int32 := {
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						if (item.view.enabled && contains(item.rect, x, y)) {
							return .result := i;
						}
					}
					return .result := -1;
				};
				if (!this.enabled) {
					return .result := false;
				}
				result: bool := false;
				active: int32 := this.pressedIndex;
				if (!((event.dx) || (event.dy) || event.release) || !(event.button)) {
					active := findView(this, event.x, event.y);
				}
				if (active < 0) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				item: Item := this.items[active];
				view: View := item.view;
				if (!view.enabled) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				if (this.pressedIndex != active && TouchEvent.isPress(event, 1)) {
					clearState(this, Style.pressed);
					this.pressedIndex := active;
					result := true;
				}
				outside: bool := !TouchEvent.test(event, item.rect);
				if (this.hoveredIndex != active || outside) {
					if (clearState(this, Style.hovered)) {
						result := true;
					}
					if (!outside) {
						this.hoveredIndex := active;
						result := true;
					}
				}
				if (event.release && outside) {
					return .result := clearState(this, Style.pressed | Style.hovered);
				}
				if (view.onTouchEvent(view, item.rect, event)) {
					result := true;
				}
				if (!event.release) {
					return .result := result;
				}
				focusable: bool := view.focusable;
				if (outside) {
					focusable := false;
				}
				else if (event.clicks < 0) {
					clearState(this, Style.hovered);
					focusable := false;
				}
				else if (this.focusedIndex == active) {
					focusable := false;
				}
				else if ((layout) != null) {
					if (layout.focusedIndex == -1) {
						focusable := false;
					}
				}
				if (focusable) {
					clearState(this, Style.focused);
					this.focusedIndex := active;
					result := true;
				}
				if (clearState(this, Style.pressed)) {
					return .result := true;
				}
				return .result := result;
			};
			static onMeasure(this: Layout, measured: Rect): bool := {
				dir: int32 := this.orientation;
				N: int32 := Math.abs(dir);
				n: int32 := 0;
				maxWidth: int32 := 0;
				sumWidth: int32 := 0;
				maxHeight: int32 := 0;
				sumHeight: int32 := 0;
				rows: int32 := dir < 0 ? N : 1;
				cols: int32 := dir > 0 ? N : 1;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					item: Item := this.items[i];
					rect: Rect := item.rect;
					view: View := item.view;
					rect.x0 := rect.x1 := 0;
					rect.y0 := rect.y1 := 0;
					if (view.onMeasure(view, &rect)) {
						width: int32 := width(rect);
						height: int32 := height(rect);
						if (n >= N) {
							cols := cols + int32(dir < 0);
							rows := rows + int32(dir > 0);
							n := 0;
						}
						sumWidth := sumWidth + width;
						if (maxWidth < width) {
							maxWidth := width;
						}
						sumHeight := sumHeight + height;
						if (maxHeight < height) {
							maxHeight := height;
						}
						n := n + 1;
					}
				}
				if (rows == 1 && cols == 1) {
					sumWidth := maxWidth;
					sumHeight := maxHeight;
				}
				if (rows > 1) {
					sumWidth := maxWidth * cols;
				}
				if (cols > 1) {
					sumHeight := maxHeight * rows;
				}
				width(measured, sumWidth + this.paddingLeft + this.paddingRight);
				height(measured, sumHeight + this.paddingTop + this.paddingBottom);
				return .result := View.onMeasure(this, &measured);
			};
			static onLayout(this: Layout, measured: Rect): void := {
				static verticalLayout(this: Layout, measured: Rect, cols: int32): void := {
					rowSpacing: int32 := width(measured) / cols;
					colSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						rows: int32 := 0;
						n: int32 := cols;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= cols) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									rows := rows + 1;
									n := 0;
								}
								if (maxSize < height(rect)) {
									maxSize := height(rect);
								}
								if (colSpacing < maxSize) {
									colSpacing := maxSize;
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (rows > 0 && height(measured) > sumSize) {
							grow := (height(measured) - sumSize) / rows;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := cols;
					translateY(r, -colSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= cols) {
							positionX(r, measured.x0);
							translateY(r, colSpacing + grow);
							if (cols == 1) {
								colSpacing := height(rect);
							}
							n := 0;
						}
						width(r, rowSpacing);
						height(r, colSpacing + grow);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateX(r, rowSpacing);
						n := n + 1;
					}
				};
				static horizontalLayout(this: Layout, measured: Rect, rows: int32): void := {
					colSpacing: int32 := height(measured) / rows;
					rowSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						cols: int32 := 0;
						n: int32 := rows;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= rows) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									cols := cols + 1;
									n := 0;
								}
								if (maxSize < width(rect)) {
									maxSize := width(rect);
								}
								if (rowSpacing < width(rect)) {
									rowSpacing := width(rect);
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (cols > 0 && width(measured) > sumSize) {
							grow := (width(measured) - sumSize) / cols;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := rows;
					translateX(r, -rowSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= rows) {
							positionY(r, measured.y0);
							translateX(r, rowSpacing + grow);
							if (rows == 1) {
								rowSpacing := width(rect);
							}
							n := 0;
						}
						width(r, rowSpacing + grow);
						height(r, colSpacing);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateY(r, colSpacing);
						n := n + 1;
					}
				};
				static addPadding(const this: Layout, rect: Rect, multiplier: int32): void := {
					rect.x0 := rect.x0 - multiplier * this.paddingLeft;
					rect.y0 := rect.y0 - multiplier * this.paddingTop;
					rect.x1 := rect.x1 + multiplier * this.paddingRight;
					rect.y1 := rect.y1 + multiplier * this.paddingBottom;
				};
				addPadding(this, &measured, -1);
				if (this.orientation > 0) {
					verticalLayout(this, &measured, this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				if (this.orientation < 0) {
					horizontalLayout(this, &measured, -this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				r: Rect := {
					r.x0 := measured.x0;
					r.y0 := measured.y0;
					r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
					r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
				};
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					Style.align(measured, &rect, item.align);
					if ((layout) != null) {
						layout.onLayout(layout, &rect);
					}
				}
				addPadding(this, &measured, 1);
			};
			const onLayout(this: Layout, measured: Rect): void := onLayout;
			static onDraw(this: Layout, offs: Image, parent: Rect): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					state: int32 := 0;
					if (as(view, Layout) == null) {
						if (i == this.hoveredIndex) {
							state := state | Style.hovered;
						}
						if (i == this.pressedIndex) {
							state := state | Style.pressed;
						}
						if (i == this.focusedIndex) {
							state := state | Style.focused;
						}
					}
					onDraw(view, offs, rect, state);
				}
			};
			static Custom(rowsCols: int32, alignment: int32, items: View[]): Layout := {
				layout: Layout := {
					layout := create(Layout);
					layout.orientation := rowsCols;
					layout.onLayout := onLayout;
					layout.paddingBottom := 0;
					layout.paddingRight := 0;
					layout.paddingLeft := 0;
					layout.paddingTop := 0;
					layout.focusedIndex := -1;
					layout.pressedIndex := -1;
					layout.hoveredIndex := -1;
					layout.itemCapacity := 0;
					layout.itemCount := 0;
					layout.items := (null);
					layout.separator := (null);
					layout.width := -5;
					layout.height := -5;
					layout.enabled := true;
					layout.focusable := true;
					layout.parent := (null);
					layout.style := (null);
					layout.data := (null);
					layout.onClick := onClick;
					layout.onReset := onReset;
					layout.onCreate := onCreate;
					layout.onDestroy := onDestroy;
					layout.onKeyEvent := onKeyEvent;
					layout.onTouchEvent := onTouchEvent;
					layout.onMeasure := onMeasure;
					layout.onDraw := onDraw;
				};
				if (items.length > (0)) {
					addItems(layout, alignment, ...items);
				}
				return .result := layout;
			};
			static Row(items: View[]): Layout := {
				return .result := Custom(-1, Style.fill, ...items);
			};
			static Column(items: View[]): Layout := {
				return .result := Custom(1, Style.fill, ...items);
			};
			static Stack(items: View[]): Layout := {
				return .result := Custom(0, Style.fill, ...items);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const TabPage: struct {
			tabs: Layout := null;
			active: Layout := null;
			background: argb := argb(0);
			static onCreate(this: TabPage, parent: View): void := {
				Layout.onCreate(this, parent);
				this.active := (this.items[1].view);
				style: Style := this.style;
				this.background := mix_rgb8(128, argb(style.backgroundColor), argb(style.hoveredColor));
			};
			static onMeasurePage(layout: Layout, rect: Rect): bool := {
				parent: TabPage := as(layout.data, TabPage);
				if ((parent) != null && parent.active != layout) {
					setSize(rect, 0, 0);
					return .result := false;
				}
				return .result := Layout.onMeasure(layout, &rect);
			};
			static onDrawPage(panel: Layout, offs: Image, rect: Rect): void := {
				page: TabPage := as(panel.data, TabPage);
				fillRect(offs, rect, page.background.v);
				Layout.onDraw(panel, offs, rect);
			};
			static onDrawBar(tabs: Layout, offs: Image, rect: Rect): void := {
				page: TabPage := as(tabs.data, TabPage);
				fillRect(offs, rect, page.background.v);
				Layout.onDraw(tabs, offs, rect);
			};
			static onDrawTab(tab: Button, offs: Image, rect: Rect): void := {
				page: TabPage := as(tab.parent.parent, TabPage);
				style: Style := tab.style;
				if ((page.active) == as(tab.data, Layout)) {
					fillRect(offs, rect, style.focusedColor);
					Style.align(style, rect, &rect, tab.text);
					Image.drawText(offs, rect, style.font, tab.text, style.textColor);
					return;
				}
				Button.onDraw(tab, offs, rect);
			};
			static onDrawSeparator(this: View, offs: Image, rect: Rect): void := {
			};
			static onClickTab(button: Button): bool := {
				if ((page) != null) {
					if ((tabs) != null) {
						if (tabs.active == page) {
							return .result := false;
						}
						tabs.active := page;
						invalidate(tabs);
						focus(page);
					}
				}
				return .result := true;
			};
			static addItems(this: TabPage, const text: char[*], align: int32, views: View[]): TabPage := {
				padding: typename := 1;
				page: Layout := {
					page := create(Layout);
					page.data := (this);
					page.onDraw := onDrawPage;
					page.onMeasure := onMeasurePage;
					page.separator := (null);
					page.items := (null);
					page.itemCount := 0;
					page.itemCapacity := 0;
					page.hoveredIndex := -1;
					page.pressedIndex := -1;
					page.focusedIndex := -1;
					page.paddingTop := 0;
					page.paddingLeft := 0;
					page.paddingRight := 0;
					page.paddingBottom := 0;
					page.orientation := 1;
					page.onLayout := onLayout;
					page.width := -5;
					page.height := -5;
					page.enabled := true;
					page.focusable := true;
					page.parent := (null);
					page.style := (null);
					page.onClick := onClick;
					page.onReset := onReset;
					page.onCreate := onCreate;
					page.onDestroy := onDestroy;
					page.onKeyEvent := onKeyEvent;
					page.onTouchEvent := onTouchEvent;
				};
				tab: Button := {
					tab := create(Button);
					tab.text := (text);
					tab.data := (page);
					tab.focusable := false;
					tab.onDraw := onDrawTab;
					tab.onClick := onClickTab;
					tab.width := -5;
					tab.height := -5;
					tab.enabled := true;
					tab.parent := (null);
					tab.style := (null);
					tab.onReset := onReset;
					tab.onCreate := onCreate;
					tab.onDestroy := onDestroy;
					tab.onKeyEvent := onKeyEvent;
					tab.onTouchEvent := onTouchEvent;
					tab.onMeasure := onMeasure;
				};
				if ((this.tabs) == null) {
					tabs: Layout := {
						tabs := create(Layout);
						tabs.paddingTop := padding;
						tabs.paddingLeft := padding;
						tabs.paddingRight := padding;
						tabs.paddingBottom := padding;
						tabs.data := (this);
						tabs.onDraw := onDrawBar;
						tabs.orientation := -this.orientation;
						tabs.separator := (null);
						tabs.items := (null);
						tabs.itemCount := 0;
						tabs.itemCapacity := 0;
						tabs.hoveredIndex := -1;
						tabs.pressedIndex := -1;
						tabs.focusedIndex := -1;
						tabs.onLayout := onLayout;
						tabs.width := -5;
						tabs.height := -5;
						tabs.enabled := true;
						tabs.focusable := true;
						tabs.parent := (null);
						tabs.style := (null);
						tabs.onClick := onClick;
						tabs.onReset := onReset;
						tabs.onCreate := onCreate;
						tabs.onDestroy := onDestroy;
						tabs.onKeyEvent := onKeyEvent;
						tabs.onTouchEvent := onTouchEvent;
						tabs.onMeasure := onMeasure;
					};
					this.tabs := tabs;
					Layout.addItems(this, Style.center, tabs);
				}
				if (this.tabs.itemCount > 0) {
					tabs: Layout := this.tabs;
					if ((tabs.separator) == null) {
						separator: View := {
							separator := create(View);
							separator.width := padding;
							separator.height := padding;
							separator.enabled := false;
							separator.focusable := false;
							separator.onDraw := onDrawSeparator;
							separator.parent := (null);
							separator.style := (null);
							separator.data := (null);
							separator.onClick := onClick;
							separator.onReset := onReset;
							separator.onCreate := onCreate;
							separator.onDestroy := onDestroy;
							separator.onKeyEvent := onKeyEvent;
							separator.onTouchEvent := onTouchEvent;
							separator.onMeasure := onMeasure;
						};
						tabs.separator := separator;
					}
					addItems(tabs, 0, tabs.separator);
				}
				addItems(this.tabs, 0, tab);
				addItems(page, align, ...views);
				Layout.addItems(this, Style.fill, page);
				return .result := this;
			};
			static const Item: struct {
				rect: Rect;
				view: View;
				align: int32;
			};
			separator: View := null;
			items: Item[*] := null;
			itemCount: int32 := 0;
			itemCapacity: int32 := 0;
			hoveredIndex: int32 := -1;
			pressedIndex: int32 := -1;
			focusedIndex: int32 := -1;
			paddingTop: int32 := 0;
			paddingLeft: int32 := 0;
			paddingRight: int32 := 0;
			paddingBottom: int32 := 0;
			orientation: int32 := 1;
			static clearState(this: Layout, mode: int32): bool := {
				result: bool := false;
				if ((mode & Style.hovered) && this.hoveredIndex >= 0) {
					view: View := this.items[this.hoveredIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.hoveredIndex := -1;
					result := true;
				}
				if ((mode & Style.pressed) && this.pressedIndex >= 0) {
					view: View := this.items[this.pressedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.pressedIndex := -1;
					result := true;
				}
				if ((mode & Style.focused) && this.focusedIndex >= 0) {
					view: View := this.items[this.focusedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.focusedIndex := -1;
					result := true;
				}
				return .result := result;
			};
			static getPressed(const this: Layout): View := {
				if (this.pressedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.pressedIndex].view;
				if ((layout) != null) {
					child: View := getPressed(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static getFocused(const this: Layout): View := {
				if (this.focusedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.focusedIndex].view;
				if ((layout) != null) {
					child: View := getFocused(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static setFocused(this: Layout, focus: View): bool := {
				if ((focus) == null) {
					clearState(this, Style.focused);
				}
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					const view: View := item.view;
					if (view == focus && this.focusedIndex != i) {
						clearState(this, Style.focused);
						this.focusedIndex := i;
						return .result := true;
					}
					if ((layout) != null) {
						if (setFocused(layout, focus) && this.focusedIndex != i) {
							clearState(this, Style.focused);
							this.focusedIndex := i;
							return .result := true;
						}
					}
				}
				return .result := false;
			};
			static capacity(this: Layout, capacity: int32): Layout := {
				assert(capacity >= this.itemCount);
				if (capacity == this.itemCapacity) {
					return;
				}
				items: Item[*] := this.items;
				this.itemCapacity := capacity;
				this.items := (pointer.alloc(null, this.itemCapacity * sizeof(Item)));
				pointer.copy(this.items, items, this.itemCount * sizeof(Item));
				pointer.alloc(items, 0);
				return .result := this;
			};
			static addItems(this: Layout, alignment: int32, views: View[]): Layout := {
				static separator(this: Layout): View := {
					static onDraw(this: View, offs: Image, rect: Rect): void := {
					};
					if ((this.separator) != null) {
						return .result := this.separator;
					}
					separator: View := {
						separator := create(View);
						separator.enabled := false;
						separator.focusable := false;
						separator.onDraw := onDraw;
						separator.width := -5;
						separator.height := -5;
						separator.parent := (null);
						separator.style := (null);
						separator.data := (null);
						separator.onClick := onClick;
						separator.onReset := onReset;
						separator.onCreate := onCreate;
						separator.onDestroy := onDestroy;
						separator.onKeyEvent := onKeyEvent;
						separator.onTouchEvent := onTouchEvent;
						separator.onMeasure := onMeasure;
					};
					this.separator := separator;
					return .result := separator;
				};
				itemCount: int32 := this.itemCount + (views.length);
				if (itemCount >= this.itemCapacity) {
					capacity: int32 := 2 * this.itemCapacity;
					if (capacity < itemCount) {
						capacity := itemCount;
					}
					capacity(this, capacity);
				}
				for (i: int32 := 0; i < (views.length); i := i + 1) {
					item: Item := this.items[this.itemCount + i];
					item.view := views[i];
					item.align := alignment;
					if ((item.view) == null) {
						item.view := separator(this);
					}
				}
				this.itemCount := itemCount;
				return .result := this;
			};
			static size(this: Layout): int32 := {
				return .result := this.itemCount;
			};
			static getView(this: Layout, idx: int32): View := {
				assert(idx >= 0 && idx < this.itemCount);
				return .result := this.items[idx].view;
			};
			static setAlignment(this: Layout, idx: int32, alignment: int32): void := {
				assert(idx >= 0 && idx < this.itemCount);
				this.items[idx].align := alignment;
			};
			static padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout := {
				this.paddingTop := top;
				this.paddingLeft := left;
				this.paddingRight := right;
				this.paddingBottom := bottom;
				invalidate(this, true);
				return .result := this;
			};
			static onClick(this: Layout): bool := {
				error("onClick", this);
				return .result := false;
			};
			static onReset(this: Layout): bool := {
				result: bool := false;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					if (view.onReset(view)) {
						result := true;
					}
				}
				return .result := result;
			};
			static onCreate(this: Layout, parent: View): void := {
				assert((this.parent) == null, "can not add the same layout multiple times");
				View.onCreate(this, parent);
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onCreate(view, this);
				}
			};
			static onDestroy(this: Layout): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onDestroy(view);
					destroy(view);
				}
				pointer.alloc(this.items, 0);
			};
			static onKeyEvent(this: Layout, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				idx: int32 := this.focusedIndex;
				if (idx < 0) {
					return .result := false;
				}
				view: View := this.items[idx].view;
				return .result := view.onKeyEvent(view, event);
			};
			static onTouchEvent(this: Layout, const rect: Rect, const event: TouchEvent): bool := {
				static findView(this: Layout, x: int32, y: int32): int32 := {
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						if (item.view.enabled && contains(item.rect, x, y)) {
							return .result := i;
						}
					}
					return .result := -1;
				};
				if (!this.enabled) {
					return .result := false;
				}
				result: bool := false;
				active: int32 := this.pressedIndex;
				if (!((event.dx) || (event.dy) || event.release) || !(event.button)) {
					active := findView(this, event.x, event.y);
				}
				if (active < 0) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				item: Item := this.items[active];
				view: View := item.view;
				if (!view.enabled) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				if (this.pressedIndex != active && TouchEvent.isPress(event, 1)) {
					clearState(this, Style.pressed);
					this.pressedIndex := active;
					result := true;
				}
				outside: bool := !TouchEvent.test(event, item.rect);
				if (this.hoveredIndex != active || outside) {
					if (clearState(this, Style.hovered)) {
						result := true;
					}
					if (!outside) {
						this.hoveredIndex := active;
						result := true;
					}
				}
				if (event.release && outside) {
					return .result := clearState(this, Style.pressed | Style.hovered);
				}
				if (view.onTouchEvent(view, item.rect, event)) {
					result := true;
				}
				if (!event.release) {
					return .result := result;
				}
				focusable: bool := view.focusable;
				if (outside) {
					focusable := false;
				}
				else if (event.clicks < 0) {
					clearState(this, Style.hovered);
					focusable := false;
				}
				else if (this.focusedIndex == active) {
					focusable := false;
				}
				else if ((layout) != null) {
					if (layout.focusedIndex == -1) {
						focusable := false;
					}
				}
				if (focusable) {
					clearState(this, Style.focused);
					this.focusedIndex := active;
					result := true;
				}
				if (clearState(this, Style.pressed)) {
					return .result := true;
				}
				return .result := result;
			};
			static onMeasure(this: Layout, measured: Rect): bool := {
				dir: int32 := this.orientation;
				N: int32 := Math.abs(dir);
				n: int32 := 0;
				maxWidth: int32 := 0;
				sumWidth: int32 := 0;
				maxHeight: int32 := 0;
				sumHeight: int32 := 0;
				rows: int32 := dir < 0 ? N : 1;
				cols: int32 := dir > 0 ? N : 1;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					item: Item := this.items[i];
					rect: Rect := item.rect;
					view: View := item.view;
					rect.x0 := rect.x1 := 0;
					rect.y0 := rect.y1 := 0;
					if (view.onMeasure(view, &rect)) {
						width: int32 := width(rect);
						height: int32 := height(rect);
						if (n >= N) {
							cols := cols + int32(dir < 0);
							rows := rows + int32(dir > 0);
							n := 0;
						}
						sumWidth := sumWidth + width;
						if (maxWidth < width) {
							maxWidth := width;
						}
						sumHeight := sumHeight + height;
						if (maxHeight < height) {
							maxHeight := height;
						}
						n := n + 1;
					}
				}
				if (rows == 1 && cols == 1) {
					sumWidth := maxWidth;
					sumHeight := maxHeight;
				}
				if (rows > 1) {
					sumWidth := maxWidth * cols;
				}
				if (cols > 1) {
					sumHeight := maxHeight * rows;
				}
				width(measured, sumWidth + this.paddingLeft + this.paddingRight);
				height(measured, sumHeight + this.paddingTop + this.paddingBottom);
				return .result := View.onMeasure(this, &measured);
			};
			static onLayout(this: Layout, measured: Rect): void := {
				static verticalLayout(this: Layout, measured: Rect, cols: int32): void := {
					rowSpacing: int32 := width(measured) / cols;
					colSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						rows: int32 := 0;
						n: int32 := cols;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= cols) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									rows := rows + 1;
									n := 0;
								}
								if (maxSize < height(rect)) {
									maxSize := height(rect);
								}
								if (colSpacing < maxSize) {
									colSpacing := maxSize;
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (rows > 0 && height(measured) > sumSize) {
							grow := (height(measured) - sumSize) / rows;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := cols;
					translateY(r, -colSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= cols) {
							positionX(r, measured.x0);
							translateY(r, colSpacing + grow);
							if (cols == 1) {
								colSpacing := height(rect);
							}
							n := 0;
						}
						width(r, rowSpacing);
						height(r, colSpacing + grow);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateX(r, rowSpacing);
						n := n + 1;
					}
				};
				static horizontalLayout(this: Layout, measured: Rect, rows: int32): void := {
					colSpacing: int32 := height(measured) / rows;
					rowSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						cols: int32 := 0;
						n: int32 := rows;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= rows) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									cols := cols + 1;
									n := 0;
								}
								if (maxSize < width(rect)) {
									maxSize := width(rect);
								}
								if (rowSpacing < width(rect)) {
									rowSpacing := width(rect);
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (cols > 0 && width(measured) > sumSize) {
							grow := (width(measured) - sumSize) / cols;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := rows;
					translateX(r, -rowSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= rows) {
							positionY(r, measured.y0);
							translateX(r, rowSpacing + grow);
							if (rows == 1) {
								rowSpacing := width(rect);
							}
							n := 0;
						}
						width(r, rowSpacing + grow);
						height(r, colSpacing);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateY(r, colSpacing);
						n := n + 1;
					}
				};
				static addPadding(const this: Layout, rect: Rect, multiplier: int32): void := {
					rect.x0 := rect.x0 - multiplier * this.paddingLeft;
					rect.y0 := rect.y0 - multiplier * this.paddingTop;
					rect.x1 := rect.x1 + multiplier * this.paddingRight;
					rect.y1 := rect.y1 + multiplier * this.paddingBottom;
				};
				addPadding(this, &measured, -1);
				if (this.orientation > 0) {
					verticalLayout(this, &measured, this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				if (this.orientation < 0) {
					horizontalLayout(this, &measured, -this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				r: Rect := {
					r.x0 := measured.x0;
					r.y0 := measured.y0;
					r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
					r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
				};
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					Style.align(measured, &rect, item.align);
					if ((layout) != null) {
						layout.onLayout(layout, &rect);
					}
				}
				addPadding(this, &measured, 1);
			};
			const onLayout(this: Layout, measured: Rect): void := onLayout;
			static onDraw(this: Layout, offs: Image, parent: Rect): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					state: int32 := 0;
					if (as(view, Layout) == null) {
						if (i == this.hoveredIndex) {
							state := state | Style.hovered;
						}
						if (i == this.pressedIndex) {
							state := state | Style.pressed;
						}
						if (i == this.focusedIndex) {
							state := state | Style.focused;
						}
					}
					onDraw(view, offs, rect, state);
				}
			};
			static Custom(rowsCols: int32, alignment: int32, items: View[]): Layout := {
				layout: Layout := {
					layout := create(Layout);
					layout.orientation := rowsCols;
					layout.onLayout := onLayout;
					layout.paddingBottom := 0;
					layout.paddingRight := 0;
					layout.paddingLeft := 0;
					layout.paddingTop := 0;
					layout.focusedIndex := -1;
					layout.pressedIndex := -1;
					layout.hoveredIndex := -1;
					layout.itemCapacity := 0;
					layout.itemCount := 0;
					layout.items := (null);
					layout.separator := (null);
					layout.width := -5;
					layout.height := -5;
					layout.enabled := true;
					layout.focusable := true;
					layout.parent := (null);
					layout.style := (null);
					layout.data := (null);
					layout.onClick := onClick;
					layout.onReset := onReset;
					layout.onCreate := onCreate;
					layout.onDestroy := onDestroy;
					layout.onKeyEvent := onKeyEvent;
					layout.onTouchEvent := onTouchEvent;
					layout.onMeasure := onMeasure;
					layout.onDraw := onDraw;
				};
				if (items.length > (0)) {
					addItems(layout, alignment, ...items);
				}
				return .result := layout;
			};
			static Row(items: View[]): Layout := {
				return .result := Custom(-1, Style.fill, ...items);
			};
			static Column(items: View[]): Layout := {
				return .result := Custom(1, Style.fill, ...items);
			};
			static Stack(items: View[]): Layout := {
				return .result := Custom(0, Style.fill, ...items);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Select: struct {
			const text: char[];
			states: char[*][2];
			selected: Button := null;
			header: Switch := null;
			panel: Panel := null;
			static selectedData(select: Select): variant := {
				if ((select.selected) == null) {
					return .result := null;
				}
				return .result := select.selected.data;
			};
			static expand(select: Select, value: bool): bool := {
				if (value && (select.selected) != null) {
					focus(select.selected);
				}
				else {
					focus(select.header);
				}
				select.header.onUpdate(select.header, int32(value));
				Panel.visible(select.panel, value);
				invalidate(select);
				return .result := true;
			};
			static onItemClick(select: Select, view: Button): bool := {
				select.selected := view;
				expand(select, false);
				select.states[0] := (view.text);
				return .result := true;
			};
			static setSelectedIndex(select: Select, index: int32): Select := {
				if (index < 0 || index > select.panel.itemCount) {
					error("invalid index selected", index);
					return .result := select;
				}
				button: Button := as(select.panel.items[index].view, Button);
				if ((button) == null) {
					return .result := select;
				}
				select.selected := button;
				select.states[0] := (button.text);
				return .result := select;
			};
			static addItems(this: Select, align: int32, views: View[]): Select := {
				static const Header: struct {
					const select: Select;
					static onReset(this: Header): bool := {
						return .result := false;
					};
					static onClick(this: Header): bool := {
						if (!Switch.onClick(this)) {
							return .result := false;
						}
						expand(this.select, checked(this));
						return .result := true;
					};
					static const onOff: char[*][] := {
						onOff := onOff.init;
						onOff.init[0] := ("off");
						onOff.init[1] := ("on");
					};
					const text: char[*];
					const states: char[*][] := onOff;
					selected: int32 := 0;
					const resetValue: int32 := 0;
					const clickToFocus: bool := true;
					static checked(this: Switch): bool := {
						return .result := this.selected != 0;
					};
					static onUpdate(this: Switch, selected: int32): bool := {
						maxValue: int32 := this.states.length;
						if (maxValue == 0) {
							maxValue := 2;
						}
						if (selected >= maxValue) {
							selected := maxValue - 1;
						}
						else if (selected < 0) {
							selected := 0;
						}
						if (this.selected == selected) {
							return .result := isDirty(this);
						}
						this.selected := selected;
						return .result := true;
					};
					const onUpdate(this: Switch, selected: int32): bool := onUpdate;
					static onReset(this: Switch): bool := {
						return .result := this.onUpdate(this, this.resetValue);
					};
					static onClick(this: Switch): bool := {
						if (this.focusable && this.clickToFocus) {
							if (!isFocused(this)) {
								return .result := true;
							}
						}
						maxValue: int32 := this.states.length;
						value: int32 := this.selected + 1;
						if (maxValue == 0) {
							maxValue := 2;
						}
						if (value >= maxValue) {
							value := 0;
						}
						return .result := this.onUpdate(this, value);
					};
					static onCreate(this: Switch, parent: View): void := {
						View.onCreate(this, parent);
						resetValue: int32 := pointer(this.resetValue);
						Switch.onUpdate(this, this.selected);
						resetValue := this.selected;
						this.onReset(this);
					};
					static onKeyEvent(this: Switch, const event: KeyEvent): bool := {
						if (!this.enabled || event.release) {
							return .result := View.onKeyEvent(this, event);
						}
						if (event.key == ('+') || event.key == ('=')) {
							value: int32 := this.selected + 1;
							return .result := this.onUpdate(this, value);
						}
						if (event.key == ('-') || event.key == ('_')) {
							value: int32 := this.selected - 1;
							return .result := this.onUpdate(this, value);
						}
						return .result := View.onKeyEvent(this, event);
					};
					static onTouchEvent(this: Switch, const rect: Rect, const event: TouchEvent): bool := {
						if (!this.enabled || !event.release) {
							return .result := View.onTouchEvent(this, rect, event);
						}
						if (event.isShift && event.clicks >= 0) {
							value: int32 := this.selected - 1;
							return .result := this.onUpdate(this, value);
						}
						return .result := View.onTouchEvent(this, rect, event);
					};
					static onMeasure(this: Switch, rect: Rect): bool := {
						maxWidth: int32 := 0;
						style: Style := this.style;
						for (i: int32 := 0; i < (this.states.length); i := i + 1) {
							measured: Rect := {
								measured.x0 := 0;
								measured.y0 := 0;
								measured.x1 := 0;
								measured.y1 := 0;
							};
							Style.measure(style, &measured, this.states[i]);
							if (maxWidth < width(measured)) {
								maxWidth := width(measured);
							}
						}
						Style.measure(style, &rect, this.text);
						if (this.states.length == (0)) {
							width(rect, width(rect) + height(rect) * 3 / 2);
						}
						else {
							width(rect, width(rect) + maxWidth);
						}
						return .result := View.onMeasure(this, &rect);
					};
					static onDraw(this: Switch, offs: Image, rect: Rect): void := {
						value: char[*] := null;
						style: Style := this.style;
						if (this.states.length == (0)) {
							onOffRect: Rect := {
								onOffRect.x0 := rect.x0;
								onOffRect.y0 := rect.y0;
								onOffRect.x1 := rect.x0 + height(rect) * 3 / 2;
								onOffRect.y1 := rect.y1;
							};
							Style.align(rect, &onOffRect, Style.right);
							rect.x1 := onOffRect.x0;
							padded(onOffRect, -style.padding);
							color: uint32 := style.focusedColor;
							if (checked(this)) {
								color := style.valueColor;
							}
							else if (isFocused(this)) {
								color := style.hoveredColor;
							}
							fillRRect(offs, onOffRect, height(onOffRect) / 2, color);
							if (checked(this)) {
								onOffRect.x0 := onOffRect.x1 - height(onOffRect);
							}
							else {
								onOffRect.x1 := onOffRect.x0 + height(onOffRect);
							}
							padded(onOffRect, -style.padding / 3);
							fillOval(offs, onOffRect, style.textColor);
						}
						else {
							value := (this.states[this.selected]);
						}
						View.onDraw(this, offs, rect, this.text, value);
					};
					const width: int32 := -5;
					const height: int32 := -5;
					enabled: bool := true;
					focusable: bool := true;
					parent: View := null;
					style: Style := null;
					data: variant := null;
					static parent(this: View): View := {
						return .result := this.parent;
					};
					static onClick(this: View): bool := {
						return .result := true;
					};
					const onClick(this: View): bool := onClick;
					static onReset(this: View): bool := {
						return .result := false;
					};
					const onReset(this: View): bool := onReset;
					static onCreate(this: View, parent: View): void := {
						assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
						this.parent := parent;
						if ((this.style) == null) {
							assert((parent.style) != null, "can not create view with a parent without a style");
							this.style := emit(pointer(parent.style));
						}
					};
					const onCreate(this: View, parent: View): void := onCreate;
					static onDestroy(this: View): void := {
					};
					const onDestroy(this: View): void := onDestroy;
					static onKeyEvent(this: View, const event: KeyEvent): bool := {
						if (!this.enabled) {
							return .result := false;
						}
						if (event.release) {
							return .result := false;
						}
						if (event.key == (' ')) {
							return .result := this.onClick(this);
						}
						if ((event.key) == Window.KEY_CODE_BACK) {
							return .result := this.onReset(this);
						}
						return .result := false;
					};
					const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
					static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
						if (!this.enabled) {
							return .result := false;
						}
						if (!event.release) {
							return .result := false;
						}
						if (event.clicks < 0) {
							return .result := this.onReset(this);
						}
						if (event.clicks > 1) {
							if (this.onReset(this)) {
								return .result := true;
							}
						}
						return .result := this.onClick(this);
					};
					const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
					static onMeasure(this: View, rect: Rect): bool := {
						width: int32 := Math.abs(this.width);
						if (width(rect) < width || this.width > 0) {
							width(rect, width);
						}
						height: int32 := Math.abs(this.height);
						if (height(rect) < height || this.height > 0) {
							height(rect, height);
						}
						return .result := true;
					};
					const onMeasure(this: View, rect: Rect): bool := onMeasure;
					onDraw(this: View, offs: Image, rect: Rect): void;
					static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
						const style: Style := this.style;
						if (state & Style.focused) {
							fillRect(offs, rect, style.focusedColor);
						}
						else if (state & Style.hovered) {
							fillRect(offs, rect, style.hoveredColor);
						}
						else if ((this.parent.style) != pointer(style)) {
							fillRect(offs, rect, style.backgroundColor);
						}
						this.onDraw(this, offs, rect);
						if (state & Style.pressed) {
							drawRect(offs, rect, style.valueColor);
						}
					};
					static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
						const style: Style := this.style;
						if ((text) == null) {
							Style.align(style, rect, &rect, value);
							Image.drawText(offs, rect, style.font, value, style.valueColor);
							return;
						}
						if ((value) != null) {
							valueRoi: Rect := rect;
							Style.align(style, valueRoi, &valueRoi, value, Style.right);
							Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
							rect.x1 := valueRoi.x0 - style.padding;
						}
						Style.align(style, rect, &rect, text);
						Image.drawText(offs, rect, style.font, text, style.textColor);
					};
					const .type: typename;
					static const create(type: typename): pointer := nfc(7);
					static const destroy(this: object): void := nfc(8);
					static const as(this: object, type: typename): pointer := nfc(9);
					static const type(this: object): typename := nfc(10);
				};
				if (this.itemCount == 0) {
					header: Header := {
						header := create(Header);
						header.text := (this.text);
						header.states := (this.states);
						header.clickToFocus := false;
						header.select := this;
						header.selected := 0;
						header.resetValue := 0;
						header.onUpdate := onUpdate;
						header.width := -5;
						header.height := -5;
						header.enabled := true;
						header.focusable := true;
						header.parent := (null);
						header.style := (null);
						header.data := (null);
						header.onClick := onClick;
						header.onReset := onReset;
						header.onCreate := onCreate;
						header.onDestroy := onDestroy;
						header.onKeyEvent := onKeyEvent;
						header.onTouchEvent := onTouchEvent;
						header.onMeasure := onMeasure;
						header.onDraw := onDraw;
					};
					panel: Panel := {
						panel := create(Panel);
						panel.visible := false;
						panel.separator := (null);
						panel.items := (null);
						panel.itemCount := 0;
						panel.itemCapacity := 0;
						panel.hoveredIndex := -1;
						panel.pressedIndex := -1;
						panel.focusedIndex := -1;
						panel.paddingTop := 0;
						panel.paddingLeft := 0;
						panel.paddingRight := 0;
						panel.paddingBottom := 0;
						panel.orientation := 1;
						panel.onLayout := onLayout;
						panel.width := -5;
						panel.height := -5;
						panel.enabled := true;
						panel.focusable := true;
						panel.parent := (null);
						panel.style := (null);
						panel.data := (null);
						panel.onClick := onClick;
						panel.onReset := onReset;
						panel.onCreate := onCreate;
						panel.onDestroy := onDestroy;
						panel.onKeyEvent := onKeyEvent;
						panel.onTouchEvent := onTouchEvent;
						panel.onMeasure := onMeasure;
						panel.onDraw := onDraw;
					};
					this.states[0] := ("<");
					this.states[1] := ("^");
					this.header := (header);
					this.panel := panel;
					Layout.addItems(this, align, header, panel);
				}
				Layout.addItems(this.panel, align, ...views);
				return .result := this;
			};
			static addItem(this: Select, const text: char[*], data: variant): Select := {
				static const SelectItem: struct {
					const select: Select;
					static onClick(this: SelectItem): bool := {
						return .result := onItemClick(this.select, this);
					};
					const text: char[*];
					static onMeasure(this: Button, rect: Rect): bool := {
						style: Style := this.style;
						Style.measure(style, &rect, this.text);
						return .result := View.onMeasure(this, &rect);
					};
					static onDraw(this: Button, offs: Image, rect: Rect): void := {
						View.onDraw(this, offs, rect, null, this.text);
					};
					const width: int32 := -5;
					const height: int32 := -5;
					enabled: bool := true;
					focusable: bool := true;
					parent: View := null;
					style: Style := null;
					data: variant := null;
					static parent(this: View): View := {
						return .result := this.parent;
					};
					static onClick(this: View): bool := {
						return .result := true;
					};
					const onClick(this: View): bool := onClick;
					static onReset(this: View): bool := {
						return .result := false;
					};
					const onReset(this: View): bool := onReset;
					static onCreate(this: View, parent: View): void := {
						assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
						this.parent := parent;
						if ((this.style) == null) {
							assert((parent.style) != null, "can not create view with a parent without a style");
							this.style := emit(pointer(parent.style));
						}
					};
					const onCreate(this: View, parent: View): void := onCreate;
					static onDestroy(this: View): void := {
					};
					const onDestroy(this: View): void := onDestroy;
					static onKeyEvent(this: View, const event: KeyEvent): bool := {
						if (!this.enabled) {
							return .result := false;
						}
						if (event.release) {
							return .result := false;
						}
						if (event.key == (' ')) {
							return .result := this.onClick(this);
						}
						if ((event.key) == Window.KEY_CODE_BACK) {
							return .result := this.onReset(this);
						}
						return .result := false;
					};
					const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
					static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
						if (!this.enabled) {
							return .result := false;
						}
						if (!event.release) {
							return .result := false;
						}
						if (event.clicks < 0) {
							return .result := this.onReset(this);
						}
						if (event.clicks > 1) {
							if (this.onReset(this)) {
								return .result := true;
							}
						}
						return .result := this.onClick(this);
					};
					const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
					static onMeasure(this: View, rect: Rect): bool := {
						width: int32 := Math.abs(this.width);
						if (width(rect) < width || this.width > 0) {
							width(rect, width);
						}
						height: int32 := Math.abs(this.height);
						if (height(rect) < height || this.height > 0) {
							height(rect, height);
						}
						return .result := true;
					};
					const onMeasure(this: View, rect: Rect): bool := onMeasure;
					onDraw(this: View, offs: Image, rect: Rect): void;
					static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
						const style: Style := this.style;
						if (state & Style.focused) {
							fillRect(offs, rect, style.focusedColor);
						}
						else if (state & Style.hovered) {
							fillRect(offs, rect, style.hoveredColor);
						}
						else if ((this.parent.style) != pointer(style)) {
							fillRect(offs, rect, style.backgroundColor);
						}
						this.onDraw(this, offs, rect);
						if (state & Style.pressed) {
							drawRect(offs, rect, style.valueColor);
						}
					};
					static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
						const style: Style := this.style;
						if ((text) == null) {
							Style.align(style, rect, &rect, value);
							Image.drawText(offs, rect, style.font, value, style.valueColor);
							return;
						}
						if ((value) != null) {
							valueRoi: Rect := rect;
							Style.align(style, valueRoi, &valueRoi, value, Style.right);
							Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
							rect.x1 := valueRoi.x0 - style.padding;
						}
						Style.align(style, rect, &rect, text);
						Image.drawText(offs, rect, style.font, text, style.textColor);
					};
					const .type: typename;
					static const create(type: typename): pointer := nfc(7);
					static const destroy(this: object): void := nfc(8);
					static const as(this: object, type: typename): pointer := nfc(9);
					static const type(this: object): typename := nfc(10);
				};
				item: SelectItem := {
					item := create(SelectItem);
					item.select := this;
					item.text := (text);
					item.data := data;
					item.width := -5;
					item.height := -5;
					item.enabled := true;
					item.focusable := true;
					item.parent := (null);
					item.style := (null);
					item.onClick := onClick;
					item.onReset := onReset;
					item.onCreate := onCreate;
					item.onDestroy := onDestroy;
					item.onKeyEvent := onKeyEvent;
					item.onTouchEvent := onTouchEvent;
					item.onMeasure := onMeasure;
					item.onDraw := onDraw;
				};
				Select.addItems(this, Style.fill, item);
				return .result := this;
			};
			static addItem(this: Select, const text: char[*]): Select := {
				return .result := addItem(this, text, text);
			};
			static const Item: struct {
				rect: Rect;
				view: View;
				align: int32;
			};
			separator: View := null;
			items: Item[*] := null;
			itemCount: int32 := 0;
			itemCapacity: int32 := 0;
			hoveredIndex: int32 := -1;
			pressedIndex: int32 := -1;
			focusedIndex: int32 := -1;
			paddingTop: int32 := 0;
			paddingLeft: int32 := 0;
			paddingRight: int32 := 0;
			paddingBottom: int32 := 0;
			orientation: int32 := 1;
			static clearState(this: Layout, mode: int32): bool := {
				result: bool := false;
				if ((mode & Style.hovered) && this.hoveredIndex >= 0) {
					view: View := this.items[this.hoveredIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.hoveredIndex := -1;
					result := true;
				}
				if ((mode & Style.pressed) && this.pressedIndex >= 0) {
					view: View := this.items[this.pressedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.pressedIndex := -1;
					result := true;
				}
				if ((mode & Style.focused) && this.focusedIndex >= 0) {
					view: View := this.items[this.focusedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.focusedIndex := -1;
					result := true;
				}
				return .result := result;
			};
			static getPressed(const this: Layout): View := {
				if (this.pressedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.pressedIndex].view;
				if ((layout) != null) {
					child: View := getPressed(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static getFocused(const this: Layout): View := {
				if (this.focusedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.focusedIndex].view;
				if ((layout) != null) {
					child: View := getFocused(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static setFocused(this: Layout, focus: View): bool := {
				if ((focus) == null) {
					clearState(this, Style.focused);
				}
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					const view: View := item.view;
					if (view == focus && this.focusedIndex != i) {
						clearState(this, Style.focused);
						this.focusedIndex := i;
						return .result := true;
					}
					if ((layout) != null) {
						if (setFocused(layout, focus) && this.focusedIndex != i) {
							clearState(this, Style.focused);
							this.focusedIndex := i;
							return .result := true;
						}
					}
				}
				return .result := false;
			};
			static capacity(this: Layout, capacity: int32): Layout := {
				assert(capacity >= this.itemCount);
				if (capacity == this.itemCapacity) {
					return;
				}
				items: Item[*] := this.items;
				this.itemCapacity := capacity;
				this.items := (pointer.alloc(null, this.itemCapacity * sizeof(Item)));
				pointer.copy(this.items, items, this.itemCount * sizeof(Item));
				pointer.alloc(items, 0);
				return .result := this;
			};
			static addItems(this: Layout, alignment: int32, views: View[]): Layout := {
				static separator(this: Layout): View := {
					static onDraw(this: View, offs: Image, rect: Rect): void := {
					};
					if ((this.separator) != null) {
						return .result := this.separator;
					}
					separator: View := {
						separator := create(View);
						separator.enabled := false;
						separator.focusable := false;
						separator.onDraw := onDraw;
						separator.width := -5;
						separator.height := -5;
						separator.parent := (null);
						separator.style := (null);
						separator.data := (null);
						separator.onClick := onClick;
						separator.onReset := onReset;
						separator.onCreate := onCreate;
						separator.onDestroy := onDestroy;
						separator.onKeyEvent := onKeyEvent;
						separator.onTouchEvent := onTouchEvent;
						separator.onMeasure := onMeasure;
					};
					this.separator := separator;
					return .result := separator;
				};
				itemCount: int32 := this.itemCount + (views.length);
				if (itemCount >= this.itemCapacity) {
					capacity: int32 := 2 * this.itemCapacity;
					if (capacity < itemCount) {
						capacity := itemCount;
					}
					capacity(this, capacity);
				}
				for (i: int32 := 0; i < (views.length); i := i + 1) {
					item: Item := this.items[this.itemCount + i];
					item.view := views[i];
					item.align := alignment;
					if ((item.view) == null) {
						item.view := separator(this);
					}
				}
				this.itemCount := itemCount;
				return .result := this;
			};
			static size(this: Layout): int32 := {
				return .result := this.itemCount;
			};
			static getView(this: Layout, idx: int32): View := {
				assert(idx >= 0 && idx < this.itemCount);
				return .result := this.items[idx].view;
			};
			static setAlignment(this: Layout, idx: int32, alignment: int32): void := {
				assert(idx >= 0 && idx < this.itemCount);
				this.items[idx].align := alignment;
			};
			static padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout := {
				this.paddingTop := top;
				this.paddingLeft := left;
				this.paddingRight := right;
				this.paddingBottom := bottom;
				invalidate(this, true);
				return .result := this;
			};
			static onClick(this: Layout): bool := {
				error("onClick", this);
				return .result := false;
			};
			static onReset(this: Layout): bool := {
				result: bool := false;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					if (view.onReset(view)) {
						result := true;
					}
				}
				return .result := result;
			};
			static onCreate(this: Layout, parent: View): void := {
				assert((this.parent) == null, "can not add the same layout multiple times");
				View.onCreate(this, parent);
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onCreate(view, this);
				}
			};
			static onDestroy(this: Layout): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onDestroy(view);
					destroy(view);
				}
				pointer.alloc(this.items, 0);
			};
			static onKeyEvent(this: Layout, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				idx: int32 := this.focusedIndex;
				if (idx < 0) {
					return .result := false;
				}
				view: View := this.items[idx].view;
				return .result := view.onKeyEvent(view, event);
			};
			static onTouchEvent(this: Layout, const rect: Rect, const event: TouchEvent): bool := {
				static findView(this: Layout, x: int32, y: int32): int32 := {
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						if (item.view.enabled && contains(item.rect, x, y)) {
							return .result := i;
						}
					}
					return .result := -1;
				};
				if (!this.enabled) {
					return .result := false;
				}
				result: bool := false;
				active: int32 := this.pressedIndex;
				if (!((event.dx) || (event.dy) || event.release) || !(event.button)) {
					active := findView(this, event.x, event.y);
				}
				if (active < 0) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				item: Item := this.items[active];
				view: View := item.view;
				if (!view.enabled) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				if (this.pressedIndex != active && TouchEvent.isPress(event, 1)) {
					clearState(this, Style.pressed);
					this.pressedIndex := active;
					result := true;
				}
				outside: bool := !TouchEvent.test(event, item.rect);
				if (this.hoveredIndex != active || outside) {
					if (clearState(this, Style.hovered)) {
						result := true;
					}
					if (!outside) {
						this.hoveredIndex := active;
						result := true;
					}
				}
				if (event.release && outside) {
					return .result := clearState(this, Style.pressed | Style.hovered);
				}
				if (view.onTouchEvent(view, item.rect, event)) {
					result := true;
				}
				if (!event.release) {
					return .result := result;
				}
				focusable: bool := view.focusable;
				if (outside) {
					focusable := false;
				}
				else if (event.clicks < 0) {
					clearState(this, Style.hovered);
					focusable := false;
				}
				else if (this.focusedIndex == active) {
					focusable := false;
				}
				else if ((layout) != null) {
					if (layout.focusedIndex == -1) {
						focusable := false;
					}
				}
				if (focusable) {
					clearState(this, Style.focused);
					this.focusedIndex := active;
					result := true;
				}
				if (clearState(this, Style.pressed)) {
					return .result := true;
				}
				return .result := result;
			};
			static onMeasure(this: Layout, measured: Rect): bool := {
				dir: int32 := this.orientation;
				N: int32 := Math.abs(dir);
				n: int32 := 0;
				maxWidth: int32 := 0;
				sumWidth: int32 := 0;
				maxHeight: int32 := 0;
				sumHeight: int32 := 0;
				rows: int32 := dir < 0 ? N : 1;
				cols: int32 := dir > 0 ? N : 1;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					item: Item := this.items[i];
					rect: Rect := item.rect;
					view: View := item.view;
					rect.x0 := rect.x1 := 0;
					rect.y0 := rect.y1 := 0;
					if (view.onMeasure(view, &rect)) {
						width: int32 := width(rect);
						height: int32 := height(rect);
						if (n >= N) {
							cols := cols + int32(dir < 0);
							rows := rows + int32(dir > 0);
							n := 0;
						}
						sumWidth := sumWidth + width;
						if (maxWidth < width) {
							maxWidth := width;
						}
						sumHeight := sumHeight + height;
						if (maxHeight < height) {
							maxHeight := height;
						}
						n := n + 1;
					}
				}
				if (rows == 1 && cols == 1) {
					sumWidth := maxWidth;
					sumHeight := maxHeight;
				}
				if (rows > 1) {
					sumWidth := maxWidth * cols;
				}
				if (cols > 1) {
					sumHeight := maxHeight * rows;
				}
				width(measured, sumWidth + this.paddingLeft + this.paddingRight);
				height(measured, sumHeight + this.paddingTop + this.paddingBottom);
				return .result := View.onMeasure(this, &measured);
			};
			static onLayout(this: Layout, measured: Rect): void := {
				static verticalLayout(this: Layout, measured: Rect, cols: int32): void := {
					rowSpacing: int32 := width(measured) / cols;
					colSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						rows: int32 := 0;
						n: int32 := cols;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= cols) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									rows := rows + 1;
									n := 0;
								}
								if (maxSize < height(rect)) {
									maxSize := height(rect);
								}
								if (colSpacing < maxSize) {
									colSpacing := maxSize;
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (rows > 0 && height(measured) > sumSize) {
							grow := (height(measured) - sumSize) / rows;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := cols;
					translateY(r, -colSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= cols) {
							positionX(r, measured.x0);
							translateY(r, colSpacing + grow);
							if (cols == 1) {
								colSpacing := height(rect);
							}
							n := 0;
						}
						width(r, rowSpacing);
						height(r, colSpacing + grow);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateX(r, rowSpacing);
						n := n + 1;
					}
				};
				static horizontalLayout(this: Layout, measured: Rect, rows: int32): void := {
					colSpacing: int32 := height(measured) / rows;
					rowSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						cols: int32 := 0;
						n: int32 := rows;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= rows) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									cols := cols + 1;
									n := 0;
								}
								if (maxSize < width(rect)) {
									maxSize := width(rect);
								}
								if (rowSpacing < width(rect)) {
									rowSpacing := width(rect);
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (cols > 0 && width(measured) > sumSize) {
							grow := (width(measured) - sumSize) / cols;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := rows;
					translateX(r, -rowSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= rows) {
							positionY(r, measured.y0);
							translateX(r, rowSpacing + grow);
							if (rows == 1) {
								rowSpacing := width(rect);
							}
							n := 0;
						}
						width(r, rowSpacing + grow);
						height(r, colSpacing);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateY(r, colSpacing);
						n := n + 1;
					}
				};
				static addPadding(const this: Layout, rect: Rect, multiplier: int32): void := {
					rect.x0 := rect.x0 - multiplier * this.paddingLeft;
					rect.y0 := rect.y0 - multiplier * this.paddingTop;
					rect.x1 := rect.x1 + multiplier * this.paddingRight;
					rect.y1 := rect.y1 + multiplier * this.paddingBottom;
				};
				addPadding(this, &measured, -1);
				if (this.orientation > 0) {
					verticalLayout(this, &measured, this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				if (this.orientation < 0) {
					horizontalLayout(this, &measured, -this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				r: Rect := {
					r.x0 := measured.x0;
					r.y0 := measured.y0;
					r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
					r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
				};
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					Style.align(measured, &rect, item.align);
					if ((layout) != null) {
						layout.onLayout(layout, &rect);
					}
				}
				addPadding(this, &measured, 1);
			};
			const onLayout(this: Layout, measured: Rect): void := onLayout;
			static onDraw(this: Layout, offs: Image, parent: Rect): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					state: int32 := 0;
					if (as(view, Layout) == null) {
						if (i == this.hoveredIndex) {
							state := state | Style.hovered;
						}
						if (i == this.pressedIndex) {
							state := state | Style.pressed;
						}
						if (i == this.focusedIndex) {
							state := state | Style.focused;
						}
					}
					onDraw(view, offs, rect, state);
				}
			};
			static Custom(rowsCols: int32, alignment: int32, items: View[]): Layout := {
				layout: Layout := {
					layout := create(Layout);
					layout.orientation := rowsCols;
					layout.onLayout := onLayout;
					layout.paddingBottom := 0;
					layout.paddingRight := 0;
					layout.paddingLeft := 0;
					layout.paddingTop := 0;
					layout.focusedIndex := -1;
					layout.pressedIndex := -1;
					layout.hoveredIndex := -1;
					layout.itemCapacity := 0;
					layout.itemCount := 0;
					layout.items := (null);
					layout.separator := (null);
					layout.width := -5;
					layout.height := -5;
					layout.enabled := true;
					layout.focusable := true;
					layout.parent := (null);
					layout.style := (null);
					layout.data := (null);
					layout.onClick := onClick;
					layout.onReset := onReset;
					layout.onCreate := onCreate;
					layout.onDestroy := onDestroy;
					layout.onKeyEvent := onKeyEvent;
					layout.onTouchEvent := onTouchEvent;
					layout.onMeasure := onMeasure;
					layout.onDraw := onDraw;
				};
				if (items.length > (0)) {
					addItems(layout, alignment, ...items);
				}
				return .result := layout;
			};
			static Row(items: View[]): Layout := {
				return .result := Custom(-1, Style.fill, ...items);
			};
			static Column(items: View[]): Layout := {
				return .result := Custom(1, Style.fill, ...items);
			};
			static Stack(items: View[]): Layout := {
				return .result := Custom(0, Style.fill, ...items);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const FxWidget: struct {
			showOriginal: bool := false;
			align: int32 := Style.fill;
			margin: int32 := 0;
			radius: int32 := 0;
			static onTouchEvent(this: FxWidget, const rect: Rect, const event: TouchEvent): bool := {
				if (Widget.onTouchEvent(this, rect, event)) {
					return .result := true;
				}
				if (!((event.button) && ((event.dx) || (event.dy)))) {
					return .result := false;
				}
				if (this.pressedIndex != -1) {
					return .result := false;
				}
				view: View := Widget.getFocused(this);
				if ((view) == null) {
					return .result := false;
				}
				parent: Layout := as(view.parent, Layout);
				r: Rect := parent.items[parent.focusedIndex].rect;
				return .result := view.onTouchEvent(view, r, event);
			};
			static onKeyEvent(this: FxWidget, const event: KeyEvent): bool := {
				if (event.key == ('[') || event.key == (']')) {
					changed: bool := this.showOriginal != event.release;
					this.showOriginal := !event.release && (event.repeat != 0 || !this.enabled);
					if (event.repeat != 0 && event.release == this.enabled) {
						return .result := changed && event.repeat == 1;
					}
					if (event.repeat == 0 && !event.release) {
						return .result := changed;
					}
					clearState(this, Style.hovered);
					if (event.key == ('[')) {
						if (this.align == Style.topLeft) {
							this.enabled := !this.enabled;
							invalidate(this);
							return .result := true;
						}
						this.align := Style.topLeft;
					}
					if (event.key == (']')) {
						if (this.align == Style.topRight) {
							this.enabled := !this.enabled;
							invalidate(this);
							return .result := true;
						}
						this.align := Style.topRight;
					}
					this.enabled := true;
					invalidate(this);
					return .result := true;
				}
				if (event.key == ('\')) {
					this.showOriginal := !event.release;
					return .result := event.repeat == 0 || event.release;
				}
				if (event.release) {
					return .result := Widget.onKeyEvent(this, event);
				}
				if ((event.key) == Window.KEY_CODE_BACK && event.isShift) {
					return .result := this.onReset(this);
				}
				return .result := Widget.onKeyEvent(this, event);
			};
			static onMeasure(this: FxWidget, measured: Rect): bool := {
				margin: int32 := this.margin;
				align: int32 := this.align;
				rect: Rect := {
					rect.x0 := margin;
					rect.y0 := margin;
					rect.x1 := width(measured) - margin;
					rect.y1 := height(measured) - margin;
				};
				measured.x1 := measured.x0 := 0;
				measured.y1 := measured.y0 := 0;
				Layout.onMeasure(this, &measured);
				this.onLayout(this, &measured);
				Style.align(rect, &measured, align);
				return .result := true;
			};
			static onDraw(this: FxWidget, offs: Image, rect: Rect): void := {
				offs := Image.slice(offs, rect);
				style: Style := this.style;
				if (style.backgroundColor != (-1)) {
					r: Rect := {
						r.x0 := 0;
						r.y0 := 0;
						r.x1 := Image.width(offs);
						r.y1 := Image.height(offs);
					};
					fillRRect(offs, r, this.radius, style.backgroundColor);
				}
				Widget.onDraw(this, offs, rect);
				Image.destroy(offs);
			};
			static onProcess(widget: FxWidget): void := {
			};
			const onProcess(widget: FxWidget): void := onProcess;
			measure: bool := true;
			redraw: bool := true;
			focus: View := null;
			scrollX: int32 := 0;
			scrollY: int32 := 0;
			static focusNext(view: View, prev: bool): bool := {
				if ((view) == null) {
					return .result := false;
				}
				if (!view.enabled) {
					return .result := false;
				}
				if (!view.focusable) {
					return .result := false;
				}
				this: Layout := as(view, Layout);
				if ((this) == null) {
					return .result := true;
				}
				n: int32 := this.focusedIndex;
				if (prev) {
					if (n < 0) {
						n := this.itemCount - 1;
					}
					for (i: int32 := n; i >= 0; i := i - 1) {
						const item: Item := this.items[i];
						const rect: Rect := item.rect;
						const view: View := item.view;
						if (!empty(rect) && focusNext(view, prev)) {
							if (as(view, Layout) != null || i != this.focusedIndex) {
								this.focusedIndex := i;
								return .result := true;
							}
						}
					}
				}
				else {
					if (n < 0) {
						n := 0;
					}
					for (i: int32 := n; i < this.itemCount; i := i + 1) {
						const item: Item := this.items[i];
						const rect: Rect := item.rect;
						const view: View := item.view;
						if (!empty(rect) && focusNext(view, prev)) {
							if (as(view, Layout) != null || i > this.focusedIndex) {
								this.focusedIndex := i;
								return .result := true;
							}
						}
					}
				}
				clearState(this, Style.focused);
				return .result := false;
			};
			static addItems(this: Widget, align: int32, views: View[]): Widget := {
				Layout.addItems(this, align, ...views);
				return .result := this;
			};
			static addItems(this: Widget, views: View[]): Widget := {
				Layout.addItems(this, Style.fill, ...views);
				return .result := this;
			};
			static focus(this: Widget, value: View): Widget := {
				this.focus := value;
				return .result := this;
			};
			static padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout := {
				Layout.padding(this, top, left, right, bottom);
				return .result := this;
			};
			static padding(this: Widget, vertical: int32, horizontal: int32): Layout := {
				Layout.padding(this, vertical, horizontal, horizontal, vertical);
				return .result := this;
			};
			static padding(this: Widget, padding: int32): Widget := {
				Layout.padding(this, padding, padding, padding, padding);
				return .result := this;
			};
			static onCreate(this: Widget, parent: View): void := {
				Layout.onCreate(this, parent);
				this.measure := true;
				if ((this.focus) != null) {
					focus(this.focus);
					this.focus := (null);
				}
			};
			static onKeyEvent(this: Widget, const event: KeyEvent): bool := {
				if (Layout.onKeyEvent(this, event)) {
					return .result := true;
				}
				if (event.release) {
					return .result := false;
				}
				if ((event.key) == Window.KEY_CODE_TAB || (event.key) == Window.KEY_CODE_ENTER) {
					clearState(this, Style.hovered);
					if (!focusNext(this, event.isShift)) {
						return .result := focusNext(this, event.isShift);
					}
					return .result := true;
				}
				return .result := false;
			};
			static onMeasure(this: Widget, measured: Rect): bool := {
				Layout.onMeasure(this, &measured);
				this.onLayout(this, &measured);
				return .result := true;
			};
			static onDraw(this: Widget, offs: Image, rect: Rect): void := {
				fillRect(offs, rect, this.style.backgroundColor);
				Layout.onDraw(this, offs, rect);
			};
			static const Item: struct {
				rect: Rect;
				view: View;
				align: int32;
			};
			separator: View := null;
			items: Item[*] := null;
			itemCount: int32 := 0;
			itemCapacity: int32 := 0;
			hoveredIndex: int32 := -1;
			pressedIndex: int32 := -1;
			focusedIndex: int32 := -1;
			paddingTop: int32 := 0;
			paddingLeft: int32 := 0;
			paddingRight: int32 := 0;
			paddingBottom: int32 := 0;
			orientation: int32 := 1;
			static clearState(this: Layout, mode: int32): bool := {
				result: bool := false;
				if ((mode & Style.hovered) && this.hoveredIndex >= 0) {
					view: View := this.items[this.hoveredIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.hoveredIndex := -1;
					result := true;
				}
				if ((mode & Style.pressed) && this.pressedIndex >= 0) {
					view: View := this.items[this.pressedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.pressedIndex := -1;
					result := true;
				}
				if ((mode & Style.focused) && this.focusedIndex >= 0) {
					view: View := this.items[this.focusedIndex].view;
					if ((layout) != null) {
						clearState(layout, mode);
					}
					this.focusedIndex := -1;
					result := true;
				}
				return .result := result;
			};
			static getPressed(const this: Layout): View := {
				if (this.pressedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.pressedIndex].view;
				if ((layout) != null) {
					child: View := getPressed(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static getFocused(const this: Layout): View := {
				if (this.focusedIndex < 0) {
					return .result := null;
				}
				view: View := this.items[this.focusedIndex].view;
				if ((layout) != null) {
					child: View := getFocused(layout);
					if ((child) != null) {
						return .result := child;
					}
				}
				return .result := view;
			};
			static setFocused(this: Layout, focus: View): bool := {
				if ((focus) == null) {
					clearState(this, Style.focused);
				}
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					const view: View := item.view;
					if (view == focus && this.focusedIndex != i) {
						clearState(this, Style.focused);
						this.focusedIndex := i;
						return .result := true;
					}
					if ((layout) != null) {
						if (setFocused(layout, focus) && this.focusedIndex != i) {
							clearState(this, Style.focused);
							this.focusedIndex := i;
							return .result := true;
						}
					}
				}
				return .result := false;
			};
			static capacity(this: Layout, capacity: int32): Layout := {
				assert(capacity >= this.itemCount);
				if (capacity == this.itemCapacity) {
					return;
				}
				items: Item[*] := this.items;
				this.itemCapacity := capacity;
				this.items := (pointer.alloc(null, this.itemCapacity * sizeof(Item)));
				pointer.copy(this.items, items, this.itemCount * sizeof(Item));
				pointer.alloc(items, 0);
				return .result := this;
			};
			static addItems(this: Layout, alignment: int32, views: View[]): Layout := {
				static separator(this: Layout): View := {
					static onDraw(this: View, offs: Image, rect: Rect): void := {
					};
					if ((this.separator) != null) {
						return .result := this.separator;
					}
					separator: View := {
						separator := create(View);
						separator.enabled := false;
						separator.focusable := false;
						separator.onDraw := onDraw;
						separator.width := -5;
						separator.height := -5;
						separator.parent := (null);
						separator.style := (null);
						separator.data := (null);
						separator.onClick := onClick;
						separator.onReset := onReset;
						separator.onCreate := onCreate;
						separator.onDestroy := onDestroy;
						separator.onKeyEvent := onKeyEvent;
						separator.onTouchEvent := onTouchEvent;
						separator.onMeasure := onMeasure;
					};
					this.separator := separator;
					return .result := separator;
				};
				itemCount: int32 := this.itemCount + (views.length);
				if (itemCount >= this.itemCapacity) {
					capacity: int32 := 2 * this.itemCapacity;
					if (capacity < itemCount) {
						capacity := itemCount;
					}
					capacity(this, capacity);
				}
				for (i: int32 := 0; i < (views.length); i := i + 1) {
					item: Item := this.items[this.itemCount + i];
					item.view := views[i];
					item.align := alignment;
					if ((item.view) == null) {
						item.view := separator(this);
					}
				}
				this.itemCount := itemCount;
				return .result := this;
			};
			static size(this: Layout): int32 := {
				return .result := this.itemCount;
			};
			static getView(this: Layout, idx: int32): View := {
				assert(idx >= 0 && idx < this.itemCount);
				return .result := this.items[idx].view;
			};
			static setAlignment(this: Layout, idx: int32, alignment: int32): void := {
				assert(idx >= 0 && idx < this.itemCount);
				this.items[idx].align := alignment;
			};
			static padding(this: Layout, top: int32, left: int32, right: int32, bottom: int32): Layout := {
				this.paddingTop := top;
				this.paddingLeft := left;
				this.paddingRight := right;
				this.paddingBottom := bottom;
				invalidate(this, true);
				return .result := this;
			};
			static onClick(this: Layout): bool := {
				error("onClick", this);
				return .result := false;
			};
			static onReset(this: Layout): bool := {
				result: bool := false;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					if (view.onReset(view)) {
						result := true;
					}
				}
				return .result := result;
			};
			static onCreate(this: Layout, parent: View): void := {
				assert((this.parent) == null, "can not add the same layout multiple times");
				View.onCreate(this, parent);
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onCreate(view, this);
				}
			};
			static onDestroy(this: Layout): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					view: View := this.items[i].view;
					view.onDestroy(view);
					destroy(view);
				}
				pointer.alloc(this.items, 0);
			};
			static onKeyEvent(this: Layout, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				idx: int32 := this.focusedIndex;
				if (idx < 0) {
					return .result := false;
				}
				view: View := this.items[idx].view;
				return .result := view.onKeyEvent(view, event);
			};
			static onTouchEvent(this: Layout, const rect: Rect, const event: TouchEvent): bool := {
				static findView(this: Layout, x: int32, y: int32): int32 := {
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						if (item.view.enabled && contains(item.rect, x, y)) {
							return .result := i;
						}
					}
					return .result := -1;
				};
				if (!this.enabled) {
					return .result := false;
				}
				result: bool := false;
				active: int32 := this.pressedIndex;
				if (!((event.dx) || (event.dy) || event.release) || !(event.button)) {
					active := findView(this, event.x, event.y);
				}
				if (active < 0) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				item: Item := this.items[active];
				view: View := item.view;
				if (!view.enabled) {
					states: int32 := Style.hovered;
					if (event.release) {
						states := states | Style.pressed;
					}
					return .result := clearState(this, states);
				}
				if (this.pressedIndex != active && TouchEvent.isPress(event, 1)) {
					clearState(this, Style.pressed);
					this.pressedIndex := active;
					result := true;
				}
				outside: bool := !TouchEvent.test(event, item.rect);
				if (this.hoveredIndex != active || outside) {
					if (clearState(this, Style.hovered)) {
						result := true;
					}
					if (!outside) {
						this.hoveredIndex := active;
						result := true;
					}
				}
				if (event.release && outside) {
					return .result := clearState(this, Style.pressed | Style.hovered);
				}
				if (view.onTouchEvent(view, item.rect, event)) {
					result := true;
				}
				if (!event.release) {
					return .result := result;
				}
				focusable: bool := view.focusable;
				if (outside) {
					focusable := false;
				}
				else if (event.clicks < 0) {
					clearState(this, Style.hovered);
					focusable := false;
				}
				else if (this.focusedIndex == active) {
					focusable := false;
				}
				else if ((layout) != null) {
					if (layout.focusedIndex == -1) {
						focusable := false;
					}
				}
				if (focusable) {
					clearState(this, Style.focused);
					this.focusedIndex := active;
					result := true;
				}
				if (clearState(this, Style.pressed)) {
					return .result := true;
				}
				return .result := result;
			};
			static onMeasure(this: Layout, measured: Rect): bool := {
				dir: int32 := this.orientation;
				N: int32 := Math.abs(dir);
				n: int32 := 0;
				maxWidth: int32 := 0;
				sumWidth: int32 := 0;
				maxHeight: int32 := 0;
				sumHeight: int32 := 0;
				rows: int32 := dir < 0 ? N : 1;
				cols: int32 := dir > 0 ? N : 1;
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					item: Item := this.items[i];
					rect: Rect := item.rect;
					view: View := item.view;
					rect.x0 := rect.x1 := 0;
					rect.y0 := rect.y1 := 0;
					if (view.onMeasure(view, &rect)) {
						width: int32 := width(rect);
						height: int32 := height(rect);
						if (n >= N) {
							cols := cols + int32(dir < 0);
							rows := rows + int32(dir > 0);
							n := 0;
						}
						sumWidth := sumWidth + width;
						if (maxWidth < width) {
							maxWidth := width;
						}
						sumHeight := sumHeight + height;
						if (maxHeight < height) {
							maxHeight := height;
						}
						n := n + 1;
					}
				}
				if (rows == 1 && cols == 1) {
					sumWidth := maxWidth;
					sumHeight := maxHeight;
				}
				if (rows > 1) {
					sumWidth := maxWidth * cols;
				}
				if (cols > 1) {
					sumHeight := maxHeight * rows;
				}
				width(measured, sumWidth + this.paddingLeft + this.paddingRight);
				height(measured, sumHeight + this.paddingTop + this.paddingBottom);
				return .result := View.onMeasure(this, &measured);
			};
			static onLayout(this: Layout, measured: Rect): void := {
				static verticalLayout(this: Layout, measured: Rect, cols: int32): void := {
					rowSpacing: int32 := width(measured) / cols;
					colSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						rows: int32 := 0;
						n: int32 := cols;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= cols) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									rows := rows + 1;
									n := 0;
								}
								if (maxSize < height(rect)) {
									maxSize := height(rect);
								}
								if (colSpacing < maxSize) {
									colSpacing := maxSize;
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (rows > 0 && height(measured) > sumSize) {
							grow := (height(measured) - sumSize) / rows;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := cols;
					translateY(r, -colSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= cols) {
							positionX(r, measured.x0);
							translateY(r, colSpacing + grow);
							if (cols == 1) {
								colSpacing := height(rect);
							}
							n := 0;
						}
						width(r, rowSpacing);
						height(r, colSpacing + grow);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateX(r, rowSpacing);
						n := n + 1;
					}
				};
				static horizontalLayout(this: Layout, measured: Rect, rows: int32): void := {
					colSpacing: int32 := height(measured) / rows;
					rowSpacing: int32 := 0;
					grow: int32 := 0;
					if (true) {
						maxSize: int32 := 0;
						sumSize: int32 := 0;
						cols: int32 := 0;
						n: int32 := rows;
						for (i: int32 := 0; i < this.itemCount; i := i + 1) {
							rect: Rect := this.items[i].rect;
							if (!empty(rect)) {
								if (n >= rows) {
									sumSize := sumSize + maxSize;
									maxSize := 0;
									cols := cols + 1;
									n := 0;
								}
								if (maxSize < width(rect)) {
									maxSize := width(rect);
								}
								if (rowSpacing < width(rect)) {
									rowSpacing := width(rect);
								}
								n := n + 1;
							}
						}
						sumSize := sumSize + maxSize;
						if (cols > 0 && width(measured) > sumSize) {
							grow := (width(measured) - sumSize) / cols;
						}
					}
					r: Rect := {
						r.x0 := measured.x0;
						r.y0 := measured.y0;
						r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
						r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
					};
					n: int32 := rows;
					translateX(r, -rowSpacing - grow);
					for (i: int32 := 0; i < this.itemCount; i := i + 1) {
						item: Item := this.items[i];
						rect: Rect := item.rect;
						if (empty(rect)) {
							continue;
						}
						if (n >= rows) {
							positionY(r, measured.y0);
							translateX(r, rowSpacing + grow);
							if (rows == 1) {
								rowSpacing := width(rect);
							}
							n := 0;
						}
						width(r, rowSpacing + grow);
						height(r, colSpacing);
						view: View := item.view;
						align: int32 := item.align;
						if (view.width > 0 && Style.vertical(align)) {
							align := align & ~Style.vertical;
						}
						if (view.height > 0 && Style.horizontal(align)) {
							align := align & ~Style.horizontal;
						}
						Style.align(r, &rect, align);
						if ((layout) != null) {
							layout.onLayout(layout, &rect);
						}
						translateY(r, colSpacing);
						n := n + 1;
					}
				};
				static addPadding(const this: Layout, rect: Rect, multiplier: int32): void := {
					rect.x0 := rect.x0 - multiplier * this.paddingLeft;
					rect.y0 := rect.y0 - multiplier * this.paddingTop;
					rect.x1 := rect.x1 + multiplier * this.paddingRight;
					rect.y1 := rect.y1 + multiplier * this.paddingBottom;
				};
				addPadding(this, &measured, -1);
				if (this.orientation > 0) {
					verticalLayout(this, &measured, this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				if (this.orientation < 0) {
					horizontalLayout(this, &measured, -this.orientation);
					addPadding(this, &measured, 1);
					return;
				}
				r: Rect := {
					r.x0 := measured.x0;
					r.y0 := measured.y0;
					r.x1 := measured.x0 + (this.width > 0 ? this.width : width(measured));
					r.y1 := measured.y0 + (this.height > 0 ? this.height : height(measured));
				};
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					Style.align(measured, &rect, item.align);
					if ((layout) != null) {
						layout.onLayout(layout, &rect);
					}
				}
				addPadding(this, &measured, 1);
			};
			const onLayout(this: Layout, measured: Rect): void := onLayout;
			static onDraw(this: Layout, offs: Image, parent: Rect): void := {
				for (i: int32 := 0; i < this.itemCount; i := i + 1) {
					const item: Item := this.items[i];
					const rect: Rect := item.rect;
					if (empty(rect)) {
						continue;
					}
					const view: View := item.view;
					state: int32 := 0;
					if (as(view, Layout) == null) {
						if (i == this.hoveredIndex) {
							state := state | Style.hovered;
						}
						if (i == this.pressedIndex) {
							state := state | Style.pressed;
						}
						if (i == this.focusedIndex) {
							state := state | Style.focused;
						}
					}
					onDraw(view, offs, rect, state);
				}
			};
			static Custom(rowsCols: int32, alignment: int32, items: View[]): Layout := {
				layout: Layout := {
					layout := create(Layout);
					layout.orientation := rowsCols;
					layout.onLayout := onLayout;
					layout.paddingBottom := 0;
					layout.paddingRight := 0;
					layout.paddingLeft := 0;
					layout.paddingTop := 0;
					layout.focusedIndex := -1;
					layout.pressedIndex := -1;
					layout.hoveredIndex := -1;
					layout.itemCapacity := 0;
					layout.itemCount := 0;
					layout.items := (null);
					layout.separator := (null);
					layout.width := -5;
					layout.height := -5;
					layout.enabled := true;
					layout.focusable := true;
					layout.parent := (null);
					layout.style := (null);
					layout.data := (null);
					layout.onClick := onClick;
					layout.onReset := onReset;
					layout.onCreate := onCreate;
					layout.onDestroy := onDestroy;
					layout.onKeyEvent := onKeyEvent;
					layout.onTouchEvent := onTouchEvent;
					layout.onMeasure := onMeasure;
					layout.onDraw := onDraw;
				};
				if (items.length > (0)) {
					addItems(layout, alignment, ...items);
				}
				return .result := layout;
			};
			static Row(items: View[]): Layout := {
				return .result := Custom(-1, Style.fill, ...items);
			};
			static Column(items: View[]): Layout := {
				return .result := Custom(1, Style.fill, ...items);
			};
			static Stack(items: View[]): Layout := {
				return .result := Custom(0, Style.fill, ...items);
			};
			const width: int32 := -5;
			const height: int32 := -5;
			enabled: bool := true;
			focusable: bool := true;
			parent: View := null;
			style: Style := null;
			data: variant := null;
			static parent(this: View): View := {
				return .result := this.parent;
			};
			static onClick(this: View): bool := {
				return .result := true;
			};
			const onClick(this: View): bool := onClick;
			static onReset(this: View): bool := {
				return .result := false;
			};
			const onReset(this: View): bool := onReset;
			static onCreate(this: View, parent: View): void := {
				assert((this.parent) == null || this.parent == parent, "can not add the same view to different layouts");
				this.parent := parent;
				if ((this.style) == null) {
					assert((parent.style) != null, "can not create view with a parent without a style");
					this.style := emit(pointer(parent.style));
				}
			};
			const onCreate(this: View, parent: View): void := onCreate;
			static onDestroy(this: View): void := {
			};
			const onDestroy(this: View): void := onDestroy;
			static onKeyEvent(this: View, const event: KeyEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (event.release) {
					return .result := false;
				}
				if (event.key == (' ')) {
					return .result := this.onClick(this);
				}
				if ((event.key) == Window.KEY_CODE_BACK) {
					return .result := this.onReset(this);
				}
				return .result := false;
			};
			const onKeyEvent(this: View, const event: KeyEvent): bool := onKeyEvent;
			static onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := {
				if (!this.enabled) {
					return .result := false;
				}
				if (!event.release) {
					return .result := false;
				}
				if (event.clicks < 0) {
					return .result := this.onReset(this);
				}
				if (event.clicks > 1) {
					if (this.onReset(this)) {
						return .result := true;
					}
				}
				return .result := this.onClick(this);
			};
			const onTouchEvent(this: View, const rect: Rect, const event: TouchEvent): bool := onTouchEvent;
			static onMeasure(this: View, rect: Rect): bool := {
				width: int32 := Math.abs(this.width);
				if (width(rect) < width || this.width > 0) {
					width(rect, width);
				}
				height: int32 := Math.abs(this.height);
				if (height(rect) < height || this.height > 0) {
					height(rect, height);
				}
				return .result := true;
			};
			const onMeasure(this: View, rect: Rect): bool := onMeasure;
			onDraw(this: View, offs: Image, rect: Rect): void;
			static onDraw(this: View, offs: Image, rect: Rect, state: int32): void := {
				const style: Style := this.style;
				if (state & Style.focused) {
					fillRect(offs, rect, style.focusedColor);
				}
				else if (state & Style.hovered) {
					fillRect(offs, rect, style.hoveredColor);
				}
				else if ((this.parent.style) != pointer(style)) {
					fillRect(offs, rect, style.backgroundColor);
				}
				this.onDraw(this, offs, rect);
				if (state & Style.pressed) {
					drawRect(offs, rect, style.valueColor);
				}
			};
			static onDraw(this: View, offs: Image, rect: Rect, const text: char[*], const value: char[*]): void := {
				const style: Style := this.style;
				if ((text) == null) {
					Style.align(style, rect, &rect, value);
					Image.drawText(offs, rect, style.font, value, style.valueColor);
					return;
				}
				if ((value) != null) {
					valueRoi: Rect := rect;
					Style.align(style, valueRoi, &valueRoi, value, Style.right);
					Image.drawText(offs, valueRoi, style.font, value, style.valueColor);
					rect.x1 := valueRoi.x0 - style.padding;
				}
				Style.align(style, rect, &rect, text);
				Image.drawText(offs, rect, style.font, text, style.textColor);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static Widget(width: int32, height: int32, const style: Style): Widget := {
			widget: Widget := {
				widget := create(Widget);
				widget.width := width;
				widget.height := height;
				widget.style := style;
				widget.measure := true;
				widget.redraw := true;
				widget.focus := (null);
				widget.scrollX := 0;
				widget.scrollY := 0;
				widget.separator := (null);
				widget.items := (null);
				widget.itemCount := 0;
				widget.itemCapacity := 0;
				widget.hoveredIndex := -1;
				widget.pressedIndex := -1;
				widget.focusedIndex := -1;
				widget.paddingTop := 0;
				widget.paddingLeft := 0;
				widget.paddingRight := 0;
				widget.paddingBottom := 0;
				widget.orientation := 1;
				widget.onLayout := onLayout;
				widget.enabled := true;
				widget.focusable := true;
				widget.parent := (null);
				widget.data := (null);
				widget.onClick := onClick;
				widget.onReset := onReset;
				widget.onCreate := onCreate;
				widget.onDestroy := onDestroy;
				widget.onKeyEvent := onKeyEvent;
				widget.onTouchEvent := onTouchEvent;
				widget.onMeasure := onMeasure;
				widget.onDraw := onDraw;
			};
			return .result := Widget.focus(widget, widget);
		};
		static Widget(width: int32, height: int32): Widget := {
			static const style: Style := {
				style.format.precision := 2;
				style.format.trimDecimal := false;
				style.format.sign := (0);
				style.format.padChr := (0);
				style.format.width := 0;
				style.align := 0;
				style.padding := 8;
				style.font := Window.font;
				style.backgroundColor := uint32(theme);
				style.hoveredColor := uint32(mix_rgb8(16, theme, accent));
				style.focusedColor := uint32(mix_rgb8(64, theme, accent));
				style.valueColor := uint32(accent);
				style.textColor := uint32(lum(theme) > 127 ? dark : light);
			};
			return .result := Widget(width, height, style);
		};
		static FxWidget(onProcess(widget: FxWidget): void, views: View[]): FxWidget := {
			static const style: Style := {
				style.align := Style.left;
				style.format.precision := 2;
				style.format.trimDecimal := false;
				style.format.sign := (0);
				style.format.padChr := (0);
				style.format.width := 0;
				style.padding := 8;
				style.font := Window.font;
				style.backgroundColor := uint32(theme);
				style.hoveredColor := uint32(mix_rgb8(16, theme, accent));
				style.focusedColor := uint32(mix_rgb8(64, theme, accent));
				style.valueColor := uint32(accent);
				style.textColor := uint32(lum(theme) > 127 ? dark : light);
			};
			widget: FxWidget := {
				widget := create(FxWidget);
				widget.radius := 5;
				widget.margin := 10;
				widget.align := Style.topRight;
				widget.style := style;
				widget.paddingTop := 3;
				widget.paddingLeft := 3;
				widget.paddingRight := 3;
				widget.paddingBottom := 3;
				widget.onProcess := onProcess;
				widget.showOriginal := false;
				widget.measure := true;
				widget.redraw := true;
				widget.focus := (null);
				widget.scrollX := 0;
				widget.scrollY := 0;
				widget.separator := (null);
				widget.items := (null);
				widget.itemCount := 0;
				widget.itemCapacity := 0;
				widget.hoveredIndex := -1;
				widget.pressedIndex := -1;
				widget.focusedIndex := -1;
				widget.orientation := 1;
				widget.onLayout := onLayout;
				widget.width := -5;
				widget.height := -5;
				widget.enabled := true;
				widget.focusable := true;
				widget.parent := (null);
				widget.data := (null);
				widget.onClick := onClick;
				widget.onReset := onReset;
				widget.onCreate := onCreate;
				widget.onDestroy := onDestroy;
				widget.onKeyEvent := onKeyEvent;
				widget.onTouchEvent := onTouchEvent;
				widget.onMeasure := onMeasure;
				widget.onDraw := onDraw;
			};
			return .result := Layout.addItems(FxWidget.focus(widget, widget), ...views);
		};
		static FxWidget(views: View[]): FxWidget := {
			return .result := FxWidget(FxWidget.onProcess, ...views);
		};
		static hasFocused(const this: Layout, items: View[]): bool := {
			if (this.focusedIndex < 0) {
				return .result := false;
			}
			if (items.length == (0)) {
				return .result := true;
			}
			view: View := this.items[this.focusedIndex].view;
			for (i: int32 := 0; i < (items.length); i := i + 1) {
				if (items[i] == view) {
					return .result := true;
				}
			}
			if ((layout) != null) {
				return .result := hasFocused(layout, ...items);
			}
			return .result := false;
		};
		static hasPressed(const this: Layout, items: View[]): bool := {
			if (this.pressedIndex < 0) {
				return .result := false;
			}
			if (items.length == (0)) {
				return .result := true;
			}
			view: View := this.items[this.pressedIndex].view;
			for (i: int32 := 0; i < (items.length); i := i + 1) {
				if (items[i] == view) {
					return .result := true;
				}
			}
			if ((layout) != null) {
				return .result := hasPressed(layout, ...items);
			}
			return .result := false;
		};
		static const Window: struct {
			static show(offscreen: Image, widget: Widget): void := {
				static const WindowData: struct {
					offscreen: Image;
					widget: Widget;
					rect: Rect;
					timeout: int64 := 0;
					clicks: int32 := 0;
					time: int64 := 0;
					button: int32 := 0;
					lastX: int32 := 0;
					lastY: int32 := 0;
					isShift: bool := false;
					isCtrl: bool := false;
					isAlt: bool := false;
					key: int32 := 0;
					repeat: int32 := 0;
				};
				static dispatchEvent(window: WindowData, widget: Widget, action: int32, button: int32, x: int32, y: int32): bool := {
					if ((widget.parent) == null) {
						widget.onCreate(widget, widget);
					}
					if ((action) == Window.WINDOW_INIT) {
						return .result := true;
					}
					if ((action) == Window.WINDOW_CLOSE) {
						widget.onDestroy(widget);
						Widget.destroy(widget);
						return .result := false;
					}
					if ((action) == Window.WINDOW_ENTER) {
						return .result := false;
					}
					if ((action) == Window.WINDOW_LEAVE) {
						return .result := Widget.clearState(widget, Style.hovered);
					}
					if ((action) == Window.MOUSE_PRESS) {
						if (window.button != button || window.lastX != x || window.lastY != y) {
							window.clicks := 0;
						}
						now: int64 := System.millis();
						if (((now - window.time)) / 1000.000000 > 0.500000) {
							window.clicks := 0;
						}
						window.time := now;
						if (button == 1) {
							window.timeout := now + (1000);
						}
						else {
							window.timeout := (0);
						}
						window.button := button;
						window.lastX := x;
						window.lastY := y;
						window.clicks := window.clicks + 1;
						if (button != 1) {
							return .result := false;
						}
						event: TouchEvent := {
							event.release := false;
							event.isShift := window.isShift;
							event.isCtrl := window.isCtrl;
							event.isAlt := window.isAlt;
							event.clicks := window.clicks;
							event.button := button;
							event.x := x - window.rect.x0;
							event.y := y - window.rect.y0;
							event.dx := 0;
							event.dy := 0;
						};
						return .result := widget.onTouchEvent(widget, window.rect, event);
					}
					if ((action) == Window.MOUSE_MOTION) {
						lastX: int32 := window.lastX;
						lastY: int32 := window.lastY;
						window.time := System.millis();
						window.timeout := (0);
						window.button := button;
						window.lastX := x;
						window.lastY := y;
						window.clicks := 0;
						if (button != 0 && button != 1) {
							return .result := false;
						}
						event: TouchEvent := {
							event.release := false;
							event.isShift := window.isShift;
							event.isCtrl := window.isCtrl;
							event.isAlt := window.isAlt;
							event.clicks := window.clicks;
							event.button := button;
							event.dx := x - lastX;
							event.dy := y - lastY;
							event.x := x - window.rect.x0;
							event.y := y - window.rect.y0;
						};
						return .result := widget.onTouchEvent(widget, window.rect, event);
					}
					if ((action) == Window.MOUSE_RELEASE) {
						now: int64 := System.millis();
						if (((now - window.time)) / 1000.000000 > 0.500000) {
							window.clicks := 0;
						}
						window.timeout := (0);
						if (button != 1) {
							return .result := false;
						}
						event: TouchEvent := {
							event.release := true;
							event.isShift := window.isShift;
							event.isCtrl := window.isCtrl;
							event.isAlt := window.isAlt;
							event.clicks := window.clicks;
							event.button := button;
							event.x := x - window.rect.x0;
							event.y := y - window.rect.y0;
							event.dx := 0;
							event.dy := 0;
						};
						return .result := widget.onTouchEvent(widget, window.rect, event);
					}
					if ((action) == Window.KEY_PRESS) {
						window.isShift := ((y) & Window.KEY_MASK_SHIFT) != (0);
						window.isCtrl := ((y) & Window.KEY_MASK_CTRL) != (0);
						window.isAlt := ((y) & Window.KEY_MASK_ALT) != (0);
						if (window.key != button) {
							window.key := button;
							window.repeat := 0;
						}
						else {
							window.repeat := window.repeat + 1;
						}
						event: KeyEvent := {
							event.release := false;
							event.isShift := window.isShift;
							event.isCtrl := window.isCtrl;
							event.isAlt := window.isAlt;
							event.repeat := window.repeat;
							event.key := button;
						};
						return .result := widget.onKeyEvent(widget, event);
					}
					if ((action) == Window.KEY_RELEASE) {
						window.isShift := ((y) & Window.KEY_MASK_SHIFT) != (0);
						window.isCtrl := ((y) & Window.KEY_MASK_CTRL) != (0);
						window.isAlt := ((y) & Window.KEY_MASK_ALT) != (0);
						event: KeyEvent := {
							event.release := true;
							event.isShift := window.isShift;
							event.isCtrl := window.isCtrl;
							event.isAlt := window.isAlt;
							event.repeat := window.repeat;
							event.key := button;
						};
						window.key := 0;
						window.repeat := 0;
						return .result := widget.onKeyEvent(widget, event);
					}
					if ((action) == Window.EVENT_TIMEOUT) {
						if (window.timeout > (0)) {
							event: TouchEvent := {
								event.release := true;
								event.isShift := window.isShift;
								event.isCtrl := window.isCtrl;
								event.isAlt := window.isAlt;
								event.clicks := -1;
								event.button := window.button;
								event.x := window.lastX - window.rect.x0;
								event.y := window.lastY - window.rect.y0;
								event.dx := 0;
								event.dy := 0;
							};
							return .result := widget.onTouchEvent(widget, window.rect, event);
						}
					}
					debug("event not processed", action);
					return .result := false;
				};
				static draw(window: WindowData, widget: Widget): int32 := {
					if (!widget.enabled) {
						return .result := Window.timeoutMax;
					}
					timeout: int64 := Window.timeoutMax;
					if (window.timeout > (0)) {
						timeout := window.timeout - System.millis();
						if (timeout < (0)) {
							timeout := (Window.timeoutMax);
						}
					}
					offs: Image := window.offscreen;
					rect: Rect := window.rect;
					if (widget.measure) {
						setSize(rect, Image.width(offs), Image.height(offs));
						widget.onMeasure(widget, &rect);
						widget.measure := false;
					}
					Widget.onDraw(widget, offs, rect, 0);
					widget.redraw := false;
					return .result := timeout;
				};
				static windowEvent(win: WindowData, action: int32, button: int32, x: int32, y: int32): int32 := {
					if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
						return .result := Window.quit();
					}
					widget: Widget := win.widget;
					if ((action) == Window.FINGER_PRESS) {
						action := (Window.MOUSE_PRESS);
						button := 1;
					}
					if ((action) == Window.FINGER_MOTION) {
						action := (Window.MOUSE_MOTION);
						button := 1;
					}
					if ((action) == Window.FINGER_RELEASE) {
						action := (Window.MOUSE_RELEASE);
						button := 1;
					}
					if (!dispatchEvent(win, widget, action, button, x, y)) {
						if (!widget.redraw) {
							return .result := Window.timeoutMax;
						}
						return .result := draw(win, widget);
					}
					if (button == 0 && (action) == Window.MOUSE_MOTION) {
						return .result := draw(win, widget);
					}
					if (button != 0 && (action) == Window.MOUSE_PRESS) {
						return .result := draw(win, widget);
					}
					if ((fxWidget) != null) {
						fxWidget.onProcess(fxWidget);
					}
					return .result := draw(win, widget);
				};
				window: WindowData := {
					window.offscreen := offscreen;
					window.widget := widget;
					window.rect.x0 := 0;
					window.rect.y0 := 0;
					window.rect.x1 := 0;
					window.rect.y1 := 0;
					window.timeout := (0);
					window.clicks := 0;
					window.time := (0);
					window.button := 0;
					window.lastX := 0;
					window.lastY := 0;
					window.isShift := false;
					window.isCtrl := false;
					window.isAlt := false;
					window.key := 0;
					window.repeat := 0;
				};
				return .result := Window.show(offscreen, window, windowEvent);
			};
			static show(widget: Widget): void := {
				rect: Rect := {
					rect.x0 := 0;
					rect.y0 := 0;
					rect.x1 := 0;
					rect.y1 := 0;
				};
				widget.onCreate(widget, widget);
				widget.onMeasure(widget, &rect);
				offscreen: Image := Image(width(rect), height(rect), 32);
				show(offscreen, widget);
				Image.destroy(offscreen);
			};
			static const timeoutMax: int32 := 2147483647;
			static timeoutFps(fps: float64): int64 := int64((1000) / fps);
			static show(image: Image, onEvent(action: int32, button: int32, ex: int32, ey: int32): int32): void := {
				if ((onEvent) == null) {
					return .result := Window.show(image, null, null);
				}
				static delegate(onEvent(action: int32, button: int32, ex: int32, ey: int32): int32, action: int32, button: int32, ex: int32, ey: int32): int32 := {
					return .result := onEvent(action, button, ex, ey);
				};
				Window.show(image, onEvent, delegate);
			};
			static show(width: int32, height: int32, image0: Image, image1: Image, image2: Image): void := {
				static const Data: struct {
					offs: Image;
					image0: Image;
					image1: Image;
					image2: Image;
				};
				static onEvent(const data: Data, action: int32, button: int32, ex: int32, ey: int32): int32 := {
					if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
						return .result := Window.quit();
					}
					if ((action) == Window.MOUSE_PRESS || (action) == Window.MOUSE_RELEASE) {
						show: Image := data.image0;
						if ((action) == Window.MOUSE_RELEASE) {
							show := data.image0;
						}
						else if (button == 1) {
							show := data.image1;
						}
						else {
							show := data.image2;
						}
						if (Image.width(data.offs) != Image.width(show) || Image.height(data.offs) != Image.height(show)) {
							transform(data.offs, null, show, null, 1, null);
						}
						else {
							copy(data.offs, 0, 0, show, null);
						}
					}
					return .result := Window.timeoutMax;
				};
				offs: Image := Image(width, height, Image.depth(image0));
				data: Data := {
					data.offs := offs;
					data.image0 := image0;
					data.image1 := image1;
					data.image2 := image2;
				};
				onEvent(data, Window.MOUSE_RELEASE, 0, 0, 0);
				Window.show(offs, data, onEvent);
				Image.destroy(offs);
			};
			static show(image0: Image, image1: Image, image2: Image): void := {
				width: int32 := Image.width(image0);
				height: int32 := Image.height(image0);
				return .result := show(width, height, image0, image1, image1);
			};
			static show(image0: Image, image1: Image): void := {
				return .result := show(image0, image1, image1);
			};
			static show(image: Image): void := {
				Window.show(image, image, image);
			};
			static show(width: int32, height: int32, animationResolution: int32, eval(in: vec4f): vec4f): void := {
				static const start: int64 := System.millis();
				static const Data: struct {
					lerp: bool := true;
					const offs: Image;
					const thumb: Image;
					const aspect: float32;
					fpsCount: int32 := 0;
					fpsTime: float32 := 0;
					const eval(in: vec4f): vec4f;
				};
				static onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32 := {
					if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
						return .result := Window.quit();
					}
					if ((action) == Window.WINDOW_CLOSE) {
						return .result := Window.quit();
					}
					if ((action) == Window.KEY_RELEASE) {
						if (button == (' ')) {
							text: char[256] := {
							};
							now: int64 := System.millis();
							time: float32 := ((now - start)) / 1000.000000;
							eval(data.offs, null, data.aspect, time, data.eval);
							append(text, append(text, 0, "Millis: "), System.millis() - now);
							Window.setTitle(text);
							return .result := Window.timeoutMax;
						}
						if ((button) == Window.KEY_CODE_TAB) {
							data.lerp := !data.lerp;
						}
						if (button == ('S')) {
							trace("dumping screen");
							Image.saveBmp(data.offs, "out/offs.bmp", 0);
							Image.saveBmp(data.thumb, "out/thumb.bmp", 0);
						}
					}
					time: float32 := ((System.millis() - start)) / 1000.000000;
					eval(data.thumb, null, data.aspect, time, data.eval);
					resize(data.offs, null, data.thumb, null, int32(data.lerp));
					if (time > data.fpsTime) {
						text: char[256] := {
						};
						append(text, append(text, 0, "Fps: "), data.fpsCount);
						Window.setTitle(text);
						data.fpsTime := time + (1);
						data.fpsCount := 0;
					}
					data.fpsCount := data.fpsCount + 1;
					return .result := 0;
				};
				if (animationResolution == 0) {
					aspect: float32 := (width) / float32(height);
					image: Image := Image(width, height, 32);
					eval(image, null, aspect, 0.000000, eval);
					Window.show(image);
					Image.destroy(image);
					return;
				}
				data: Data := {
					data.offs := Image(width, height, 32);
					data.thumb := Image(animationResolution, animationResolution, 32);
					data.aspect := (width) / float32(height);
					data.eval := eval;
					data.lerp := true;
					data.fpsCount := 0;
					data.fpsTime := (0);
				};
				Window.show(data.offs, data, onEvent);
				Image.destroy(data.thumb);
				Image.destroy(data.offs);
			};
			static show(width: int32, height: int32, eval(in: vec4f): vec4f): void := {
				return .result := show(width, height, 0, eval);
			};
			static show(w: int32, h: int32, fovy: float32, mesh: Mesh): void := {
				static const Data: struct {
					fpsCount: int32 := 0;
					fpsShow: int32 := 0;
					fpsTime: int64 := 0;
					mode: int32;
					offs: Image;
					proj: mat4f;
					cam: Camera;
					mesh: Mesh;
					static updateCamera(const this: Data): void := {
						camera: Camera := this.cam;
						camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
					};
				};
				static nextInc(x: int32, mask: int32): int32 := {
					next: int32 := x & mask;
					next := next + (mask & -mask);
					next := next & mask;
					return .result := next | (x & ~mask);
				};
				static nextBit(x: int32, mask: int32): int32 := {
					next: int32 := x & mask;
					if (next == 0) {
						next := mask & -mask;
					}
					else {
						next := (next + next) & mask;
					}
					return .result := next | (x & ~mask);
				};
				static onEvent(data: Data, action: int32, button: int32, ex: int32, ey: int32): int32 := {
					static ox: int32 := 0;
					static oy: int32 := 0;
					static const slow: float32 := (1) / 100.000000;
					static const fast: float32 := (5) / 100.000000;
					if ((action) == Window.MOUSE_MOTION || (action) == Window.FINGER_MOTION) {
						camera: Camera := data.cam;
						dx: int32 := ex - ox;
						dy: int32 := ey - oy;
						if (button == 1 || (action) == Window.FINGER_MOTION) {
							orbit: vec4f := vec4f(0, 0, 0);
							Camera.rotate(camera, orbit, camera.up, (dx) * slow);
							Camera.rotate(camera, orbit, camera.right, (dy) * slow);
							Data.updateCamera(data);
						}
						else if (button == 2) {
							orbit: vec4f := camera.position;
							Camera.rotate(camera, orbit, camera.up, (-dx) * slow);
							Camera.rotate(camera, orbit, camera.right, (-dy) * slow);
							Data.updateCamera(data);
						}
						else if (button == 3) {
							Camera.move(camera, camera.forward, (dy) * slow);
							Data.updateCamera(data);
						}
						else if (button == 4) {
							Camera.move(camera, camera.right, (-dx) * slow);
							Camera.move(camera, camera.up, (dy) * slow);
							Data.updateCamera(data);
						}
						ox := ex;
						oy := ey;
					}
					else if ((action) == Window.MOUSE_PRESS || (action) == Window.FINGER_PRESS) {
						ox := ex;
						oy := ey;
						return .result := Window.timeoutMax;
					}
					else if ((action) == Window.MOUSE_WHEEL) {
						camera: Camera := data.cam;
						Camera.move(camera, camera.forward, (ey) * fast);
						Data.updateCamera(data);
					}
					else if ((action) == Window.KEY_RELEASE && (button) == Window.KEY_CODE_ESC) {
						return .result := Window.quit();
					}
					else if ((action) == Window.KEY_PRESS) {
						if ((button) == Window.KEY_CODE_ENTER) {
							return .result := onEvent(&data, Window.WINDOW_INIT, button, ex, ey);
						}
						else if (button == ('w')) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.move(camera, camera.forward, +(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if (button == ('s')) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.move(camera, camera.forward, -(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if (button == ('a')) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.move(camera, camera.right, -(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if (button == ('d')) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.move(camera, camera.right, +(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if ((button) == Window.KEY_CODE_UP) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.rotate(camera, camera.position, camera.right, -(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if ((button) == Window.KEY_CODE_DOWN) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.rotate(camera, camera.position, camera.right, +(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if ((button) == Window.KEY_CODE_LEFT) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.rotate(camera, camera.position, camera.up, -(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if ((button) == Window.KEY_CODE_RIGHT) {
							camera: Camera := data.cam;
							shift: bool := bool((ey) & Window.KEY_MASK_SHIFT);
							Camera.rotate(camera, camera.position, camera.up, +(shift ? fast : slow));
							Data.updateCamera(data);
						}
						else if (button == ('l')) {
							data.mode := ((data.mode) ^ Mesh.useLights);
						}
						else if (button == ('b')) {
							data.mode := ((data.mode) ^ Mesh.drawBounds);
						}
						else if (button == ('0')) {
							lights.enable(0, !lights.enabled(0));
						}
						else if (button == ('1')) {
							lights.enable(1, !lights.enabled(1));
						}
						else if (button == ('2')) {
							lights.enable(2, !lights.enabled(2));
						}
						else if (button == ('3')) {
							lights.enable(3, !lights.enabled(3));
						}
						else if (button == ('t')) {
							data.mode := ((data.mode) ^ Mesh.useTexture);
						}
						else if (button == ('/')) {
							data.mode := nextInc(data.mode, Mesh.cullMode);
						}
						else if ((button) == Window.KEY_CODE_TAB) {
							data.mode := nextBit(data.mode, Mesh.drawMode);
						}
					}
					else if ((action) == Window.WINDOW_INIT) {
						camera: Camera := data.cam;
						eye: vec4f := {
							eye.x := (0);
							eye.y := (0);
							eye.z := (2);
							eye.w := (1);
						};
						at: vec4f := {
							at.x := (0);
							at.y := (0);
							at.z := (0);
							at.w := (1);
						};
						up: vec4f := {
							up.x := (0);
							up.y := (1);
							up.z := (0);
							up.w := (1);
						};
						data.cam := Camera.lookAt(eye, at, up);
						Data.updateCamera(data);
					}
					rendered: int32 := Image.drawMesh(data.offs, data.mesh, data.mode);
					text: char[256] := {
					};
					pos: int32 := append(text, 0, "Vertices: ");
					pos := append(text, pos, data.mesh.vertices);
					pos := append(text, pos, ", Triangles: ");
					pos := append(text, pos, data.mesh.triangles);
					pos := append(text, pos, "/");
					pos := append(text, pos, rendered);
					pos := append(text, pos, ", Fps: ");
					pos := append(text, pos, data.fpsShow);
					Window.setTitle(text);
					time: int64 := System.millis();
					if (time > data.fpsTime) {
						data.fpsTime := time + (1000);
						data.fpsShow := data.fpsCount;
						data.fpsCount := 0;
					}
					data.fpsCount := data.fpsCount + 1;
					return .result := Window.timeoutMax;
				};
				data: Data := {
					data.mode := (Mesh.useLights | Mesh.cullBack | Mesh.drawFill);
					data.offs := Image.create3d(w, h);
					data.proj := Camera.projection(fovy, (w) / float32(h), 1, 100);
					data.cam.position := vec4f(0, 0, 0, 1);
					data.cam.forward := vec4f(0, 0, 0, 1);
					data.cam.right := vec4f(0, 0, 0, 1);
					data.cam.up := vec4f(0, 1, 0, 1);
					data.mesh := mesh;
					data.fpsCount := 0;
					data.fpsShow := 0;
					data.fpsTime := (0);
				};
				Window.show(data.offs, data, onEvent);
				Image.destroy(data.offs);
			};
			static const KEY_PRESS: int64 := 1;
			static const KEY_RELEASE: int64 := 2;
			static const MOUSE_WHEEL: int64 := 3;
			static const MOUSE_PRESS: int64 := 4;
			static const MOUSE_MOTION: int64 := 5;
			static const MOUSE_RELEASE: int64 := 6;
			static const FINGER_PRESS: int64 := 7;
			static const FINGER_MOTION: int64 := 8;
			static const FINGER_RELEASE: int64 := 9;
			static const EVENT_TIMEOUT: int64 := 10;
			static const WINDOW_INIT: int64 := 100;
			static const WINDOW_CLOSE: int64 := 102;
			static const WINDOW_ENTER: int64 := 103;
			static const WINDOW_LEAVE: int64 := 104;
			static const KEY_CODE_ESC: int64 := 65307;
			static const KEY_CODE_BACK: int64 := 65288;
			static const KEY_CODE_TAB: int64 := 65289;
			static const KEY_CODE_ENTER: int64 := 65293;
			static const KEY_CODE_CAPSLOCK: int64 := 65509;
			static const KEY_CODE_PRINT_SCREEN: int64 := 65377;
			static const KEY_CODE_SCROLL_LOCK: int64 := 65300;
			static const KEY_CODE_PAUSE: int64 := 65299;
			static const KEY_CODE_INSERT: int64 := 65379;
			static const KEY_CODE_HOME: int64 := 65360;
			static const KEY_CODE_PAGE_UP: int64 := 65365;
			static const KEY_CODE_DELETE: int64 := 65535;
			static const KEY_CODE_END: int64 := 65367;
			static const KEY_CODE_PAGE_DOWN: int64 := 65366;
			static const KEY_CODE_RIGHT: int64 := 65363;
			static const KEY_CODE_LEFT: int64 := 65361;
			static const KEY_CODE_DOWN: int64 := 65364;
			static const KEY_CODE_UP: int64 := 65362;
			static const KEY_CODE_L_SHIFT: int64 := 65505;
			static const KEY_CODE_R_SHIFT: int64 := 65506;
			static const KEY_CODE_L_CTRL: int64 := 65507;
			static const KEY_CODE_R_CTRL: int64 := 65508;
			static const KEY_CODE_L_ALT: int64 := 65513;
			static const KEY_CODE_R_ALT: int64 := 65514;
			static const KEY_CODE_L_GUI: int64 := 65515;
			static const KEY_CODE_R_GUI: int64 := 65516;
			static const KEY_MASK_SHIFT: int64 := 1;
			static const KEY_MASK_CTRL: int64 := 2;
			static const KEY_MASK_ALT: int64 := 4;
			static const show(surf: Image, closure: pointer, onEvent(closure: pointer, action: int32, button: int32, x: int32, y: int32): int32): void := nfc(128);
			static const setTitle(const title: char[*]): void := nfc(129);
			static const quit(): int32 := nfc(130);
			static const font(height: int32): Image := nfc(131);
			static const font: Image := nfc(132);
		};
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32);
		emitDivI32: int32 := emit(int32(10), int32(5), div.i32);
		emitNfcF32: float32 := emit(float32(3.140000), float32(2), div.f32, float32.sin);
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(int32(3), pointer("string"));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := a + b;
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := a < b ? a : b;
		max(a: int32, b: int32): int32 := a > b ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(3, 6);
		zeroVar: int32 := zero(i3, i6);
		zeroXpr: int32 := zero(i3 + 1, i6 + 1);
		lastVal: int32 := last(3, 6);
		lastVar: int32 := last(i3, i6);
		lastXpr: int32 := last(i3 + 1, i6 + 1) - 1;
		sum2Val: int32 := sum(3, 6);
		sum2Var: int32 := sum(i3, i6);
		sum2Xpr: int32 := sum(i3 + 1, i6 + 1) - 2;
		any2Val: int32 := any(3, 6);
		any2Var: int32 := any(i3, i6);
		any2Xpr: int32 := any(i3 + 1, i6 + 1) - 1;
		min2Val: int32 := min(3, 6);
		min2Var: int32 := min(i3, i6);
		min2Xpr: int32 := min(i3 + 1, i6 + 1) - 1;
		max2Val: int32 := max(3, 6);
		max2Var: int32 := max(i3, i6);
		max2Xpr: int32 := max(i3 + 1, i6 + 1) - 1;
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(a, sum(b, sum(c, d)));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(sum(sum(a, b), c), d);
		sumRlVal: int32 := sumLr(3, 6, 2, 8);
		sumLrVal: int32 := sumRl(3, 6, 2, 8);
		sumRlVar: int32 := sumLr(i3, i6, i2, i8);
		sumLrVar: int32 := sumRl(i3, i6, i2, i8);
		sumRlXpr: int32 := sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4;
		sumLrXpr: int32 := sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4;
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(a, any(b, any(c, d)));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(any(any(a, b), c), d);
		anyRlVal: int32 := anyLr(3, 6, 2, 8);
		anyLrVal: int32 := anyRl(3, 6, 2, 8);
		anyRlVar: int32 := anyLr(i3, i6, i2, i8);
		anyLrVar: int32 := anyRl(i3, i6, i2, i8);
		anyRlXpr: int32 := anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		anyLrXpr: int32 := anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(a, min(b, min(c, d)));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(min(min(a, b), c), d);
		minRlVal: int32 := minLr(3, 6, 2, 8);
		minLrVal: int32 := minRl(3, 6, 2, 8);
		minRlVar: int32 := minLr(i3, i6, i2, i8);
		minLrVar: int32 := minRl(i3, i6, i2, i8);
		minRlXpr: int32 := minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		minLrXpr: int32 := minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(a, max(b, max(c, d)));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(max(max(a, b), c), d);
		maxRlVal: int32 := maxLr(3, 6, 2, 8);
		maxLrVal: int32 := maxRl(3, 6, 2, 8);
		maxRlVar: int32 := maxLr(i3, i6, i2, i8);
		maxLrVar: int32 := maxRl(i3, i6, i2, i8);
		maxRlXpr: int32 := maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		maxLrXpr: int32 := maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(0, 0);
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius((value.degrees - (32)) / 1.800000);
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(value.degrees * 1.800000 + (32));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		realloc(data: pointer, size: int32): pointer := pointer.alloc(data, size);
		malloc(size: int32): pointer := pointer.alloc(null, size);
		free(data: pointer): pointer := pointer.alloc(data, 0);
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(p1, 0, 1024);
		pointer.copy(p1, p3, 160);
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug("val1", val1);
		debug("val2", val2);
		pointer.move(pointer(val2), pointer(val1), sizeof(int64));
		pointer.fill(pointer(val1), 0, sizeof(int64));
		debug("val1", val1);
		debug("val2", val2);
		static noError(ptr: pointer): void := {
		};
		static stackOverflow(ptr: pointer): void := {
			data: uint8[8192] := {
			};
			stackOverflow(ptr);
		};
		static divisionByZero(args: pointer): void := {
			value: int32 := 3 / 0;
		};
		static abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				details.message := ("assertion failed");
				details.expected := 97;
				details.returned := 77;
			};
			abort("fatal error", details);
		};
		static invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static invalidInstruction(args: pointer): void := {
			emit(load.z32, ret);
		};
		tryExecErr0: int32 := tryExec(null, noError);
		tryExecErr1: int32 := tryExec(null, null);
		tryExecErr2: int32 := tryExec(null, stackOverflow);
		tryExecErr3: int32 := tryExec(null, divisionByZero);
		tryExecErr4: int32 := tryExec(null, invalidInstruction);
		tryExecErr5: int32 := tryExec(null, invalidMemoryAccess);
		tryExecErr6: int32 := tryExec(null, abortExecution);
		arr: int32[5] := {
			arr[0] := 1;
			arr[1] := 2;
			arr[2] := 3;
			arr[3] := 4;
			arr[4] := 5;
		};
		ptr: pointer := arr;
		a0: int32 := arr[0];
		a1: int32 := arr[1];
		a2: int32 := arr[2];
		a3: int32 := arr[3];
		a4: int32 := arr[4];
		assert((ptr) == arr);
		assert(pointer(a0) == inc(ptr, 0 * sizeof(int32)));
		assert(pointer(a1) == inc(ptr, 1 * sizeof(int32)));
		assert(pointer(a2) == inc(ptr, 2 * sizeof(int32)));
		assert(pointer(a3) == inc(ptr, 3 * sizeof(int32)));
		assert(pointer(a4) == inc(ptr, 4 * sizeof(int32)));
		static if ((typename(int64)) == null) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		variable: int32;
		const constant: int32 := 42;
		static const ComplexVal: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const ComplexObj: struct {
			const re: float64;
			const im: float64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		valInitImplicit: ComplexVal := {
			valInitImplicit.re := (8);
			valInitImplicit.im := (0);
		};
		objInitImplicit: ComplexObj := {
			objInitImplicit := create(ComplexObj);
			objInitImplicit.re := (8);
			objInitImplicit.im := (0);
		};
		objInitExplicit: object := {
			objInitExplicit := create(ComplexObj);
			objInitExplicit.re := (8);
			objInitExplicit.im := (0);
		};
		static empty(): void := {
		};
		static funAdd(x: int32, y: int32): int32 := {
			return .result := x + y;
		};
		funAddResult: int32 := funAdd(2, 7);
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(2, 8);
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(2, 6);
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(2, 7);
		static funMul(x: int32, y: int32): int32 := {
			return .result := x * y;
		};
		static fib(n: uint32): uint32 := {
			if (n <= (1)) {
				return .result := n;
			}
			return .result := fib(n - (1)) + fib(n - (2));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := typeofRecord.size;
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := typeofBase.size;
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner := {
				globalRec.constant := 4;
				globalRec.member := (0);
			};
			static globalRecInit: Inner := {
				globalRecInit.member := 4;
				globalRecInit.constant := 5;
			};
			static const globalConstantRec: Inner := {
				globalConstantRec.member := 6;
				globalConstantRec.constant := 7;
			};
		};
		recordMemberTest: RecordMemberTest := {
			recordMemberTest.member := 10;
			recordMemberTest.constant := 11;
			recordMemberTest.memberInit := 12;
			recordMemberTest.constantInit := 13;
			recordMemberTest.memberRec.member := 14;
			recordMemberTest.memberRec.constant := 15;
			recordMemberTest.constantRec.member := 16;
			recordMemberTest.constantRec.constant := 17;
		};
		static const RecordMethodTest: struct {
			static staticMethod(this: RecordMethodTest, x: int32): void := {
				trace("staticMethod", x);
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			static virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace("virtualMethod", x);
			};
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace("forwardMethod", x);
			};
		};
		static globalFunction(this: RecordMethodTest, x: int32): void := {
			trace("globalFunction", x);
		};
		recordMethodTest: RecordMethodTest := {
			recordMethodTest.abstractMethod := globalFunction;
			recordMethodTest.delegateMethod := forwardMethod;
			recordMethodTest.virtualMethod := virtualMethod;
		};
		RecordMethodTest.staticMethod(recordMethodTest, 1);
		recordMethodTest.virtualMethod(recordMethodTest, 1);
		static staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if ((this) != null) {
				RecordMethodTest.staticMethod(this, x);
			}
		};
		static virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if ((this) != null) {
				this.virtualMethod(this, x);
			}
		};
		staticMethod(recordMethodTest, 2);
		virtualMethod(recordMethodTest, 2);
		RecordMethodTest.staticMethod(recordMethodTest, 3);
		RecordMethodTest.virtualMethod(recordMethodTest, 3);
		recordMethodTest.virtualMethod(recordMethodTest, 3);
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		black: rgbU8 := {
			black.r := (0);
			black.g := (0);
			black.b := (0);
		};
		green: rgbU8 := {
			green.r := (0);
			green.g := (255);
			green.b := (0);
		};
		white: rgbU8 := {
			white.r := (255);
			white.g := (255);
			white.b := (255);
		};
		cyan: color := {
			cyan.col := (65535);
		};
		blue: color := {
			blue.rgb.r := (0);
			blue.rgb.g := (0);
			blue.rgb.b := (255);
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := !false;
		boolAnd: bool := boolA & boolB;
		boolIor: bool := boolA | boolB;
		boolXor: bool := boolA ^ boolB;
		boolNot: bool := !boolB;
		boolCeq: bool := boolA == boolB;
		boolCne: bool := boolA != boolB;
		boolClt: bool := boolA < boolB;
		boolCle: bool := boolA <= boolB;
		boolCgt: bool := boolA > boolB;
		boolCge: bool := boolA >= boolB;
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := +chrB;
		chrNeg: char := -chrB;
		chrCmt: char := ~chrB;
		chrAdd: char := chrA + chrB;
		chrSub: char := chrA - chrB;
		chrMul: char := chrA * chrB;
		chrDiv: char := chrA / chrB;
		chrMod: char := chrA % chrB;
		chrAnd: char := chrA & chrB;
		chrIor: char := chrA | chrB;
		chrXor: char := chrA ^ chrB;
		chrShl: char := (chrA) << shift;
		chrShr: char := (chrA) >> shift;
		chrNot: bool := !(chrB);
		chrCeq: bool := chrA == chrB;
		chrCne: bool := chrA != chrB;
		chrClt: bool := chrA < chrB;
		chrCle: bool := chrA <= chrB;
		chrCgt: bool := chrA > chrB;
		chrCge: bool := chrA >= chrB;
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := +i8B;
		i8Neg: int8 := -i8B;
		i8Cmt: int8 := ~i8B;
		i8Add: int8 := i8A + i8B;
		i8Sub: int8 := i8A - i8B;
		i8Mul: int8 := i8A * i8B;
		i8Div: int8 := i8A / i8B;
		i8Mod: int8 := i8A % i8B;
		i8And: int8 := i8A & i8B;
		i8Ior: int8 := i8A | i8B;
		i8Xor: int8 := i8A ^ i8B;
		i8Shl: int8 := (i8A) << shift;
		i8Shr: int8 := (i8A) >> shift;
		i8Not: bool := !(i8B);
		i8Ceq: bool := i8A == i8B;
		i8Cne: bool := i8A != i8B;
		i8Clt: bool := i8A < i8B;
		i8Cle: bool := i8A <= i8B;
		i8Cgt: bool := i8A > i8B;
		i8Cge: bool := i8A >= i8B;
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := +u8B;
		u8Neg: uint8 := -u8B;
		u8Cmt: uint8 := ~u8B;
		u8Add: uint8 := u8A + u8B;
		u8Sub: uint8 := u8A - u8B;
		u8Mul: uint8 := u8A * u8B;
		u8Div: uint8 := u8A / u8B;
		u8Mod: uint8 := u8A % u8B;
		u8And: uint8 := u8A & u8B;
		u8Ior: uint8 := u8A | u8B;
		u8Xor: uint8 := u8A ^ u8B;
		u8Shl: uint8 := (u8A) << shift;
		u8Shr: uint8 := (u8A) >> shift;
		u8Not: bool := !(u8B);
		u8Ceq: bool := u8A == u8B;
		u8Cne: bool := u8A != u8B;
		u8Clt: bool := u8A < u8B;
		u8Cle: bool := u8A <= u8B;
		u8Cgt: bool := u8A > u8B;
		u8Cge: bool := u8A >= u8B;
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := +i16B;
		i16Neg: int16 := -i16B;
		i16Cmt: int16 := ~i16B;
		i16Add: int16 := i16A + i16B;
		i16Sub: int16 := i16A - i16B;
		i16Mul: int16 := i16A * i16B;
		i16Div: int16 := i16A / i16B;
		i16Mod: int16 := i16A % i16B;
		i16And: int16 := i16A & i16B;
		i16Ior: int16 := i16A | i16B;
		i16Xor: int16 := i16A ^ i16B;
		i16Shl: int16 := (i16A) << shift;
		i16Shr: int16 := (i16A) >> shift;
		i16Not: bool := !(i16B);
		i16Ceq: bool := i16A == i16B;
		i16Cne: bool := i16A != i16B;
		i16Clt: bool := i16A < i16B;
		i16Cle: bool := i16A <= i16B;
		i16Cgt: bool := i16A > i16B;
		i16Cge: bool := i16A >= i16B;
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := +u16B;
		u16Neg: uint16 := -u16B;
		u16Cmt: uint16 := ~u16B;
		u16Add: uint16 := u16A + u16B;
		u16Sub: uint16 := u16A - u16B;
		u16Mul: uint16 := u16A * u16B;
		u16Div: uint16 := u16A / u16B;
		u16Mod: uint16 := u16A % u16B;
		u16And: uint16 := u16A & u16B;
		u16Ior: uint16 := u16A | u16B;
		u16Xor: uint16 := u16A ^ u16B;
		u16Shl: uint16 := (u16A) << shift;
		u16Shr: uint16 := (u16A) >> shift;
		u16Not: bool := !(u16B);
		u16Ceq: bool := u16A == u16B;
		u16Cne: bool := u16A != u16B;
		u16Clt: bool := u16A < u16B;
		u16Cle: bool := u16A <= u16B;
		u16Cgt: bool := u16A > u16B;
		u16Cge: bool := u16A >= u16B;
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := +i32B;
		i32Neg: int32 := -i32B;
		i32Cmt: int32 := ~i32B;
		i32Add: int32 := i32A + i32B;
		i32Sub: int32 := i32A - i32B;
		i32Mul: int32 := i32A * i32B;
		i32Div: int32 := i32A / i32B;
		i32Mod: int32 := i32A % i32B;
		i32And: int32 := i32A & i32B;
		i32Ior: int32 := i32A | i32B;
		i32Xor: int32 := i32A ^ i32B;
		i32Shl: int32 := i32A << shift;
		i32Shr: int32 := i32A >> shift;
		i32Not: bool := !(i32B);
		i32Ceq: bool := i32A == i32B;
		i32Cne: bool := i32A != i32B;
		i32Clt: bool := i32A < i32B;
		i32Cle: bool := i32A <= i32B;
		i32Cgt: bool := i32A > i32B;
		i32Cge: bool := i32A >= i32B;
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := +u32B;
		u32Neg: uint32 := -u32B;
		u32Cmt: uint32 := ~u32B;
		u32Add: uint32 := u32A + u32B;
		u32Sub: uint32 := u32A - u32B;
		u32Mul: uint32 := u32A * u32B;
		u32Div: uint32 := u32A / u32B;
		u32Mod: uint32 := u32A % u32B;
		u32And: uint32 := u32A & u32B;
		u32Ior: uint32 := u32A | u32B;
		u32Xor: uint32 := u32A ^ u32B;
		u32Shl: uint32 := u32A << shift;
		u32Shr: uint32 := u32A >> shift;
		u32Not: bool := !(u32B);
		u32Ceq: bool := u32A == u32B;
		u32Cne: bool := u32A != u32B;
		u32Clt: bool := u32A < u32B;
		u32Cle: bool := u32A <= u32B;
		u32Cgt: bool := u32A > u32B;
		u32Cge: bool := u32A >= u32B;
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := +i64B;
		i64Neg: int64 := -i64B;
		i64Cmt: int64 := ~i64B;
		i64Add: int64 := i64A + i64B;
		i64Sub: int64 := i64A - i64B;
		i64Mul: int64 := i64A * i64B;
		i64Div: int64 := i64A / i64B;
		i64Mod: int64 := i64A % i64B;
		i64And: int64 := i64A & i64B;
		i64Ior: int64 := i64A | i64B;
		i64Xor: int64 := i64A ^ i64B;
		i64Shl: int64 := i64A << shift;
		i64Shr: int64 := i64A >> shift;
		i64Not: bool := !(i64B);
		i64Ceq: bool := i64A == i64B;
		i64Cne: bool := i64A != i64B;
		i64Clt: bool := i64A < i64B;
		i64Cle: bool := i64A <= i64B;
		i64Cgt: bool := i64A > i64B;
		i64Cge: bool := i64A >= i64B;
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := +u64B;
		u64Neg: uint64 := -u64B;
		u64Cmt: uint64 := ~u64B;
		u64Add: uint64 := u64A + u64B;
		u64Sub: uint64 := u64A - u64B;
		u64Mul: uint64 := u64A * u64B;
		u64Div: uint64 := u64A / u64B;
		u64Mod: uint64 := u64A % u64B;
		u64And: uint64 := u64A & u64B;
		u64Ior: uint64 := u64A | u64B;
		u64Xor: uint64 := u64A ^ u64B;
		u64Shl: uint64 := u64A << shift;
		u64Shr: uint64 := u64A >> shift;
		u64Not: bool := !(u64B);
		u64Ceq: bool := u64A == u64B;
		u64Cne: bool := u64A != u64B;
		u64Clt: bool := u64A < u64B;
		u64Cle: bool := u64A <= u64B;
		u64Cgt: bool := u64A > u64B;
		u64Cge: bool := u64A >= u64B;
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := +f32B;
		f32Neg: float32 := -f32B;
		f32Add: float32 := f32A + f32B;
		f32Sub: float32 := f32A - f32B;
		f32Mul: float32 := f32A * f32B;
		f32Div: float32 := f32A / f32B;
		f32Mod: float32 := f32A % f32B;
		f32Not: bool := !(f32B);
		f32Ceq: bool := f32A == f32B;
		f32Cne: bool := f32A != f32B;
		f32Clt: bool := f32A < f32B;
		f32Cle: bool := f32A <= f32B;
		f32Cgt: bool := f32A > f32B;
		f32Cge: bool := f32A >= f32B;
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := +f64B;
		f64Neg: float64 := -f64B;
		f64Add: float64 := f64A + f64B;
		f64Sub: float64 := f64A - f64B;
		f64Mul: float64 := f64A * f64B;
		f64Div: float64 := f64A / f64B;
		f64Mod: float64 := f64A % f64B;
		f64Not: bool := !(f64B);
		f64Ceq: bool := f64A == f64B;
		f64Cne: bool := f64A != f64B;
		f64Clt: bool := f64A < f64B;
		f64Cle: bool := f64A <= f64B;
		f64Cgt: bool := f64A > f64B;
		f64Cge: bool := f64A >= f64B;
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := ptrA == ptrB;
		ptrCne: bool := ptrA != ptrB;
		static if (0 == 0) {
			raise(raise.debug, 1, "0 == 0");
		}
		static if (0 != 0) {
			raise(raise.debug, 2, "0 != 0");
		}
		static if (0 == 0) {
			raise(raise.debug, 3, "0 == 0");
		}
		else {
			raise(raise.debug, 4, "0 != 0");
		}
		static if (0 != 0) {
			raise(raise.debug, 5, "0 != 0");
		}
		else {
			raise(raise.debug, 6, "0 == 0");
		}
		{
			t: int32 := 0;
			if (t == 0) {
				raise(raise.debug, 7, "t == 0", t);
			}
			if (t != 0) {
				raise(raise.debug, 8, "t != 0", t);
			}
			if (t == 0) {
				raise(raise.debug, 9, "t == 0", t);
			}
			else {
				raise(raise.debug, 10, "t != 0", t);
			}
			if (t != 0) {
				raise(raise.debug, 11, "t != 0", t);
			}
			else {
				raise(raise.debug, 12, "t == 0", t);
			}
			if (t == 0) {
				raise(raise.debug, 9, "t == 0", t);
			}
			else if (t == 1) {
				raise(raise.debug, 10, "t == 1", t);
			}
			else if (t == 2) {
				raise(raise.debug, 10, "t == 2", t);
			}
			else if (t == 3) {
				raise(raise.debug, 10, "t == 3", t);
			}
			else if (t == 4) {
				raise(raise.debug, 10, "t == 4", t);
			}
			else if (t == 5) {
				raise(raise.debug, 10, "t == 5", t);
			}
			else {
				raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
			}
		}
		static if ((typename(int64)) == null) {
			error("integer is not declared");
		}
		static if (typename(int64) != typename) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; i < 2; i := i + 1) {
			debug("for (int i = 0; i < 2; i += 1)", i);
		}
		forIdx: int32;
		for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1) {
			debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
		}
		for (i: int32 := 0; i < 7; i := i + 1) {
			if (i < 2) {
				continue;
			}
			debug("for with continue", i);
		}
		for (i: int32 := 0; i < 7; i := i + 1) {
			if (i > 2) {
				break;
			}
			debug("for with break", i);
		}
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := r << 16 & 16711680 | g << 8 & 65280 | b & 255;
		rgb565(r: int32, g: int32, b: int32): int32 := r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31;
		r_comp: int32 := 14 << 3;
		g_comp: int32 := 63 << 2;
		b_comp: int32 := 31 << 3;
		r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp);
		r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp);
		zxtR5: int32 := Bits.zxt32(r5g6b5, 11, 5);
		zxtG6: int32 := Bits.zxt32(r5g6b5, 5, 6);
		zxtB5: int32 := Bits.zxt32(r5g6b5, 0, 5);
		sxtR5: int32 := Bits.sxt32(r5g6b5, 11, 5);
		sxtG6: int32 := Bits.sxt32(r5g6b5, 5, 6);
		sxtB5: int32 := Bits.sxt32(r5g6b5, 0, 5);
		zxtR8: int32 := Bits.zxt32(r8g8b8, 16, 8);
		zxtG8: int32 := Bits.zxt32(r8g8b8, 8, 8);
		zxtB8: int32 := Bits.zxt32(r8g8b8, 0, 8);
		sxtR8: int32 := Bits.sxt32(r8g8b8, 16, 8);
		sxtG8: int32 := Bits.sxt32(r8g8b8, 8, 8);
		sxtB8: int32 := Bits.sxt32(r8g8b8, 0, 8);
		testSin_f64: float64 := Math.sin(pi64 / (2));
		testCos_f64: float64 := Math.cos(pi64 / (2));
		testTan_f64: float64 := Math.tan(pi64 / (4));
		testLog_f64: float64 := Math.log(e64 * e64 * e64);
		testExp_f64: float64 := Math.exp(1.000000);
		testPow_f64: float64 := Math.pow(pi64 * pi64, 0.500000);
		testSqrt_f64: float64 := Math.sqrt(pi64 * pi64);
		testAtan_f64: float64 := Math.atan2(pi64, 1.000000);
		testSin_f32: float32 := Math.sin(pi32 / (2));
		testCos_f32: float32 := Math.cos(pi32 / (2));
		testTan_f32: float32 := Math.tan(pi32 / (4));
		testLog_f32: float32 := Math.log(e32 * e32 * e32);
		testExp_f32: float32 := Math.exp(1.000000);
		testPow_f32: float32 := Math.pow(pi32 * pi32, 0.500000);
		testSqrt_f32: float32 := Math.sqrt(pi32 * pi32);
		testAtan_f32: float32 := Math.atan2(pi32, 1.000000);
		testPopulation_u32: int32 := Bits.countOnes(r5g6b5);
		testSwapBits_u32: uint32 := Bits.swapBits(r5g6b5);
		testBitScanReverse_u32: int32 := Bits.scanReverse(r5g6b5);
		testBitScanForward_u32: int32 := Bits.scanForward(r5g6b5);
		testHighBit_u32: int32 := Bits.keepMsb(r5g6b5);
		testLowBit_u32: int32 := Bits.keepLsb(r5g6b5);
		testZeroExtend_u32: int32 := Bits.zxt32(r5g6b5, 0, 5);
		testSignExtend_u32: int32 := Bits.sxt32(r5g6b5, 0, 5);
		testZeroExtend_u64: int32 := Bits.zxt64(r5g6b5, 0, 5);
		testSignExtend_u64: int32 := Bits.sxt64(r5g6b5, 0, 5);
		testMathFloor_pos_3_0: float64 := Math.floor(3.000000);
		testMathFloor_pos_3_2: float64 := Math.floor(3.200000);
		testMathFloor_pos_3_5: float64 := Math.floor(3.500000);
		testMathFloor_pos_3_7: float64 := Math.floor(3.700000);
		testMathFloor_pos_3_9: float64 := Math.floor(3.900000);
		testMathFloor_neg_3_0: float64 := Math.floor(-3.000000);
		testMathFloor_neg_3_2: float64 := Math.floor(-3.200000);
		testMathFloor_neg_3_5: float64 := Math.floor(-3.500000);
		testMathFloor_neg_3_7: float64 := Math.floor(-3.700000);
		testMathFloor_neg_3_9: float64 := Math.floor(-3.900000);
		testMathRound_pos_3_0: float64 := Math.round(3.000000);
		testMathRound_pos_3_2: float64 := Math.round(3.200000);
		testMathRound_pos_3_5: float64 := Math.round(3.500000);
		testMathRound_pos_3_7: float64 := Math.round(3.700000);
		testMathRound_pos_3_9: float64 := Math.round(3.900000);
		testMathRound_neg_3_0: float64 := Math.round(-3.000000);
		testMathRound_neg_3_2: float64 := Math.round(-3.200000);
		testMathRound_neg_3_5: float64 := Math.round(-3.500000);
		testMathRound_neg_3_7: float64 := Math.round(-3.700000);
		testMathRound_neg_3_9: float64 := Math.round(-3.900000);
		testMathCeil_pos_3_0: float64 := Math.ceil(3.000000);
		testMathCeil_pos_3_2: float64 := Math.ceil(3.200000);
		testMathCeil_pos_3_5: float64 := Math.ceil(3.500000);
		testMathCeil_pos_3_7: float64 := Math.ceil(3.700000);
		testMathCeil_pos_3_9: float64 := Math.ceil(3.900000);
		testMathCeil_neg_3_0: float64 := Math.ceil(-3.000000);
		testMathCeil_neg_3_2: float64 := Math.ceil(-3.200000);
		testMathCeil_neg_3_5: float64 := Math.ceil(-3.500000);
		testMathCeil_neg_3_7: float64 := Math.ceil(-3.700000);
		testMathCeil_neg_3_9: float64 := Math.ceil(-3.900000);
		testMathSign_1F: float64 := Math.sign(0.200000);
		testMathSign_2F: float64 := Math.sign(0.000000);
		testMathSign_3F: float64 := Math.sign(-0.900000);
		testMathSign_1f: float64 := Math.sign(0.200000);
		testMathSign_2f: float64 := Math.sign(0.000000);
		testMathSign_3f: float64 := Math.sign(-0.900000);
		testMathAbs_1F: float64 := Math.abs(0.200000);
		testMathAbs_2F: float64 := Math.abs(0.000000);
		testMathAbs_3F: float64 := Math.abs(-0.900000);
		testMathAbs_1f: float64 := Math.abs(0.200000);
		testMathAbs_2f: float64 := Math.abs(0.000000);
		testMathAbs_3f: float64 := Math.abs(-0.900000);
		testMathMin_1f: float64 := Math.min(1.000000, 2.000000);
		testMathMax_2f: float64 := Math.max(1.000000, 2.000000);
		testMathMin_1F: float64 := Math.min(1.000000, 2.000000);
		testMathMax_2F: float64 := Math.max(1.000000, 2.000000);
		testMathClamp_1f: float64 := Math.clamp(10.000000, 0.000000, 1.000000);
		testMathClamp_1F: float64 := Math.clamp(10.000000, 0.000000, 1.000000);
		testMathMix_1f: float64 := Math.mix(0.000000, 2.000000, 0.500000);
		testMathMix_1F: float64 := Math.mix(0.000000, 2.000000, 0.500000);
		testMathSmooth_1f: float64 := Math.smoothstep(0.000000, 1.000000, 1.000000);
		testMathSmooth_1F: float64 := Math.smoothstep(0.000000, 1.000000, 1.000000);
		testMathMin_nan: float64 := Math.min();
		testMathMin_1: float64 := Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6);
		testMathMax_nan: float64 := Math.max();
		testMathMax_9: float64 := Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6);
		testMathSum_0: float64 := Math.sum();
		testMathSum_1: float64 := Math.sum(1);
		testMathSum_3: float64 := Math.sum(1, 2);
		testMathSum_55: float64 := Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		testMathEval_x: float64 := 10;
		testMathEval_0: float64 := Math.eval(testMathEval_x);
		testMathEval_1: float64 := Math.eval(testMathEval_x, 1.000000);
		testMathEval_2: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000);
		testMathEval_3: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000);
		testMathEval_4: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000);
		testMathEval_5: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000);
		testMathEval_6: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000);
		testMathSin_f64: float64 := Math.sin(Math.pi / (2));
		testMathCos_f64: float64 := Math.cos(Math.pi / (2));
		testMathTan_f64: float64 := Math.tan(Math.pi / (4));
		testMathSinh_f64: float64 := Math.sinh(Math.pi / (2));
		testMathCosh_f64: float64 := Math.cosh(Math.pi / (2));
		testMathAsin_f64: float64 := Math.asin(0.200000);
		testMathAcos_f64: float64 := Math.acos(0.200000);
		testMathAbsMod_f64_0a: float64 := Math.absMod(10.000000, 10.000000);
		testMathAbsMod_f64_0b: float64 := Math.absMod(0.000000, 10.000000);
		testMathAbsMod_f64_0c: float64 := Math.absMod(-10.000000, 10.000000);
		testMathAbsMod_f64_9a: float64 := Math.absMod(19.000000, 10.000000);
		testMathAbsMod_f64_9b: float64 := Math.absMod(9.000000, 10.000000);
		testMathAbsMod_f64_9c: float64 := Math.absMod(-1.000000, 10.000000);
		testMathAbsMod_f64_9d: float64 := Math.absMod(-11.000000, 10.000000);
		testMathAbsMod_f64_8a: float64 := Math.absMod(18.000000, 10.000000);
		testMathAbsMod_f64_8b: float64 := Math.absMod(8.000000, 10.000000);
		testMathAbsMod_f64_8c: float64 := Math.absMod(-2.000000, 10.000000);
		testMathAbsMod_f64_8d: float64 := Math.absMod(-12.000000, 10.000000);
		testMathAbsMod_f32_0a: float32 := Math.absMod(10.000000, 10.000000);
		testMathAbsMod_f32_0b: float32 := Math.absMod(0.000000, 10.000000);
		testMathAbsMod_f32_0c: float32 := Math.absMod(-10.000000, 10.000000);
		testMathAbsMod_f32_9a: float32 := Math.absMod(19.000000, 10.000000);
		testMathAbsMod_f32_9b: float32 := Math.absMod(9.000000, 10.000000);
		testMathAbsMod_f32_9c: float32 := Math.absMod(-1.000000, 10.000000);
		testMathAbsMod_f32_9d: float32 := Math.absMod(-11.000000, 10.000000);
		testMathAbsMod_f32_8a: float32 := Math.absMod(18.000000, 10.000000);
		testMathAbsMod_f32_8b: float32 := Math.absMod(8.000000, 10.000000);
		testMathAbsMod_f32_8c: float32 := Math.absMod(-2.000000, 10.000000);
		testMathAbsMod_f32_8d: float32 := Math.absMod(-12.000000, 10.000000);
		Neg(a: Complex): Complex := Complex(-a.re, -a.im);
		Add(a: Complex, b: Complex): Complex := Complex(a.re + b.re, a.im + b.im);
		Sub(a: Complex, b: Complex): Complex := Complex(a.re - b.re, a.im - b.im);
		Mul(a: Complex, b: Complex): Complex := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
		valA: Complex := {
			valA.re := (9);
			valA.im := (2);
		};
		valB: Complex := {
			valB.re := (2);
			valB.im := (3);
		};
		Neg: Complex := Neg(valA);
		neg: Complex := neg(valA);
		Add: Complex := Add(valA, valB);
		add: Complex := add(valA, valB);
		Sub: Complex := Sub(valA, valB);
		sub: Complex := sub(valA, valB);
		Mul: Complex := Mul(valA, valB);
		mul: Complex := mul(valA, valB);
	}
}
.instructions: (22550 bytes)
	cmplStd/lib/math/Fixed.ci:135: (2309 bytes): static const tbl_log2: uint32[257] := {...}
	cmplStd/lib/math/Fixed.ci:137: (5 bytes): tbl_log2[0] := (0);
	<.main>  : load.z32
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[1] := (6039313);
	<.main+?>: load.c32 6039313
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+4
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[2] := (12055173);
	<.main+?>: load.c32 12055173
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+8
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[3] := (18047761);
	<.main+?>: load.c32 18047761
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+12
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[4] := (24017256);
	<.main+?>: load.c32 24017256
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+16
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[5] := (29963835);
	<.main+?>: load.c32 29963835
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+20
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[6] := (35887674);
	<.main+?>: load.c32 35887674
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+24
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[7] := (41788946);
	<.main+?>: load.c32 41788946
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+28
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[8] := (47667822);
	<.main+?>: load.c32 47667822
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+32
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[9] := (53524472);
	<.main+?>: load.c32 53524472
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+36
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[10] := (59359063);
	<.main+?>: load.c32 59359063
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+40
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[11] := (65171760);
	<.main+?>: load.c32 65171760
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+44
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[12] := (70962727);
	<.main+?>: load.c32 70962727
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+48
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[13] := (76732127);
	<.main+?>: load.c32 76732127
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+52
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[14] := (82480119);
	<.main+?>: load.c32 82480119
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+56
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[15] := (88206861);
	<.main+?>: load.c32 88206861
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+60
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[16] := (93912510);
	<.main+?>: load.c32 93912510
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+64
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[17] := (99597221);
	<.main+?>: load.c32 99597221
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+68
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[18] := (105261147);
	<.main+?>: load.c32 105261147
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+72
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[19] := (110904439);
	<.main+?>: load.c32 110904439
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+76
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[20] := (116527248);
	<.main+?>: load.c32 116527248
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+80
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[21] := (122129720);
	<.main+?>: load.c32 122129720
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+84
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[22] := (127712004);
	<.main+?>: load.c32 127712004
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+88
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[23] := (133274243);
	<.main+?>: load.c32 133274243
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+92
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[24] := (138816582);
	<.main+?>: load.c32 138816582
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+96
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[25] := (144339162);
	<.main+?>: load.c32 144339162
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+100
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[26] := (149842123);
	<.main+?>: load.c32 149842123
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+104
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[27] := (155325605);
	<.main+?>: load.c32 155325605
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+108
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[28] := (160789745);
	<.main+?>: load.c32 160789745
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+112
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[29] := (166234678);
	<.main+?>: load.c32 166234678
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+116
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[30] := (171660540);
	<.main+?>: load.c32 171660540
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+120
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[31] := (177067464);
	<.main+?>: load.c32 177067464
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+124
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[32] := (182455580);
	<.main+?>: load.c32 182455580
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+128
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[33] := (187825021);
	<.main+?>: load.c32 187825021
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+132
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[34] := (193175914);
	<.main+?>: load.c32 193175914
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+136
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[35] := (198508387);
	<.main+?>: load.c32 198508387
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+140
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[36] := (203822568);
	<.main+?>: load.c32 203822568
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+144
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[37] := (209118580);
	<.main+?>: load.c32 209118580
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+148
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[38] := (214396547);
	<.main+?>: load.c32 214396547
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+152
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[39] := (219656593);
	<.main+?>: load.c32 219656593
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+156
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[40] := (224898838);
	<.main+?>: load.c32 224898838
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+160
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[41] := (230123403);
	<.main+?>: load.c32 230123403
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+164
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[42] := (235330406);
	<.main+?>: load.c32 235330406
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+168
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[43] := (240519966);
	<.main+?>: load.c32 240519966
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+172
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[44] := (245692198);
	<.main+?>: load.c32 245692198
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+176
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[45] := (250847217);
	<.main+?>: load.c32 250847217
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+180
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[46] := (255985139);
	<.main+?>: load.c32 255985139
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+184
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[47] := (261106076);
	<.main+?>: load.c32 261106076
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+188
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[48] := (266210140);
	<.main+?>: load.c32 266210140
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+192
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[49] := (271297442);
	<.main+?>: load.c32 271297442
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+196
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[50] := (276368091);
	<.main+?>: load.c32 276368091
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+200
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[51] := (281422197);
	<.main+?>: load.c32 281422197
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+204
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[52] := (286459866);
	<.main+?>: load.c32 286459866
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+208
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[53] := (291481206);
	<.main+?>: load.c32 291481206
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+212
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[54] := (296486322);
	<.main+?>: load.c32 296486322
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+216
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[55] := (301475318);
	<.main+?>: load.c32 301475318
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+220
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[56] := (306448299);
	<.main+?>: load.c32 306448299
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+224
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[57] := (311405365);
	<.main+?>: load.c32 311405365
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+228
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[58] := (316346620);
	<.main+?>: load.c32 316346620
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+232
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[59] := (321272163);
	<.main+?>: load.c32 321272163
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+236
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[60] := (326182094);
	<.main+?>: load.c32 326182094
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+240
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[61] := (331076512);
	<.main+?>: load.c32 331076512
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+244
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[62] := (335955515);
	<.main+?>: load.c32 335955515
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+248
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[63] := (340819198);
	<.main+?>: load.c32 340819198
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+252
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[64] := (345667659);
	<.main+?>: load.c32 345667659
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+256
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[65] := (350500992);
	<.main+?>: load.c32 350500992
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+260
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[66] := (355319292);
	<.main+?>: load.c32 355319292
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+264
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[67] := (360122651);
	<.main+?>: load.c32 360122651
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+268
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[68] := (364911161);
	<.main+?>: load.c32 364911161
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+272
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[69] := (369684916);
	<.main+?>: load.c32 369684916
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+276
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[70] := (374444004);
	<.main+?>: load.c32 374444004
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+280
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[71] := (379188516);
	<.main+?>: load.c32 379188516
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+284
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[72] := (383918541);
	<.main+?>: load.c32 383918541
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+288
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[73] := (388634167);
	<.main+?>: load.c32 388634167
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+292
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[74] := (393335482);
	<.main+?>: load.c32 393335482
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+296
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[75] := (398022572);
	<.main+?>: load.c32 398022572
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+300
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[76] := (402695523);
	<.main+?>: load.c32 402695523
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+304
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[77] := (407354419);
	<.main+?>: load.c32 407354419
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+308
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[78] := (411999346);
	<.main+?>: load.c32 411999346
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+312
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[79] := (416630387);
	<.main+?>: load.c32 416630387
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+316
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[80] := (421247625);
	<.main+?>: load.c32 421247625
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+320
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[81] := (425851141);
	<.main+?>: load.c32 425851141
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+324
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[82] := (430441017);
	<.main+?>: load.c32 430441017
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+328
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[83] := (435017333);
	<.main+?>: load.c32 435017333
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+332
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[84] := (439580170);
	<.main+?>: load.c32 439580170
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+336
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[85] := (444129606);
	<.main+?>: load.c32 444129606
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+340
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[86] := (448665721);
	<.main+?>: load.c32 448665721
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+344
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[87] := (453188591);
	<.main+?>: load.c32 453188591
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+348
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[88] := (457698295);
	<.main+?>: load.c32 457698295
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+352
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[89] := (462194907);
	<.main+?>: load.c32 462194907
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+356
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[90] := (466678505);
	<.main+?>: load.c32 466678505
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+360
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[91] := (471149164);
	<.main+?>: load.c32 471149164
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+364
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[92] := (475606957);
	<.main+?>: load.c32 475606957
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+368
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[93] := (480051958);
	<.main+?>: load.c32 480051958
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+372
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[94] := (484484242);
	<.main+?>: load.c32 484484242
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+376
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[95] := (488903880);
	<.main+?>: load.c32 488903880
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+380
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[96] := (493310944);
	<.main+?>: load.c32 493310944
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+384
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[97] := (497705506);
	<.main+?>: load.c32 497705506
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+388
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[98] := (502087636);
	<.main+?>: load.c32 502087636
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+392
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[99] := (506457405);
	<.main+?>: load.c32 506457405
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+396
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[100] := (510814881);
	<.main+?>: load.c32 510814881
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+400
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[101] := (515160135);
	<.main+?>: load.c32 515160135
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+404
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[102] := (519493235);
	<.main+?>: load.c32 519493235
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+408
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[103] := (523814247);
	<.main+?>: load.c32 523814247
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+412
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[104] := (528123240);
	<.main+?>: load.c32 528123240
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+416
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[105] := (532420281);
	<.main+?>: load.c32 532420281
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+420
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[106] := (536705434);
	<.main+?>: load.c32 536705434
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+424
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[107] := (540978766);
	<.main+?>: load.c32 540978766
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+428
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[108] := (545240343);
	<.main+?>: load.c32 545240343
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+432
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[109] := (549490227);
	<.main+?>: load.c32 549490227
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+436
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[110] := (553728484);
	<.main+?>: load.c32 553728484
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+440
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[111] := (557955177);
	<.main+?>: load.c32 557955177
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+444
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[112] := (562170369);
	<.main+?>: load.c32 562170369
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+448
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[113] := (566374122);
	<.main+?>: load.c32 566374122
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+452
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[114] := (570566498);
	<.main+?>: load.c32 570566498
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+456
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[115] := (574747559);
	<.main+?>: load.c32 574747559
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+460
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[116] := (578917365);
	<.main+?>: load.c32 578917365
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+464
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[117] := (583075977);
	<.main+?>: load.c32 583075977
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+468
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[118] := (587223454);
	<.main+?>: load.c32 587223454
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+472
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[119] := (591359857);
	<.main+?>: load.c32 591359857
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+476
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[120] := (595485245);
	<.main+?>: load.c32 595485245
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+480
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[121] := (599599675);
	<.main+?>: load.c32 599599675
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+484
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[122] := (603703206);
	<.main+?>: load.c32 603703206
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+488
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[123] := (607795895);
	<.main+?>: load.c32 607795895
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+492
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[124] := (611877800);
	<.main+?>: load.c32 611877800
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+496
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[125] := (615948977);
	<.main+?>: load.c32 615948977
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+500
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[126] := (620009483);
	<.main+?>: load.c32 620009483
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+504
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[127] := (624059372);
	<.main+?>: load.c32 624059372
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+508
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[128] := (628098702);
	<.main+?>: load.c32 628098702
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+512
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[129] := (632127526);
	<.main+?>: load.c32 632127526
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+516
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[130] := (636145899);
	<.main+?>: load.c32 636145899
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+520
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[131] := (640153876);
	<.main+?>: load.c32 640153876
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+524
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[132] := (644151509);
	<.main+?>: load.c32 644151509
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+528
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[133] := (648138852);
	<.main+?>: load.c32 648138852
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+532
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[134] := (652115958);
	<.main+?>: load.c32 652115958
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+536
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[135] := (656082880);
	<.main+?>: load.c32 656082880
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+540
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[136] := (660039669);
	<.main+?>: load.c32 660039669
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+544
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[137] := (663986377);
	<.main+?>: load.c32 663986377
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+548
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[138] := (667923055);
	<.main+?>: load.c32 667923055
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+552
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[139] := (671849754);
	<.main+?>: load.c32 671849754
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+556
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[140] := (675766525);
	<.main+?>: load.c32 675766525
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+560
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[141] := (679673417);
	<.main+?>: load.c32 679673417
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+564
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[142] := (683570481);
	<.main+?>: load.c32 683570481
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+568
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[143] := (687457765);
	<.main+?>: load.c32 687457765
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+572
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[144] := (691335319);
	<.main+?>: load.c32 691335319
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+576
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[145] := (695203191);
	<.main+?>: load.c32 695203191
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+580
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[146] := (699061430);
	<.main+?>: load.c32 699061430
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+584
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[147] := (702910083);
	<.main+?>: load.c32 702910083
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+588
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[148] := (706749198);
	<.main+?>: load.c32 706749198
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+592
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[149] := (710578821);
	<.main+?>: load.c32 710578821
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+596
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[150] := (714399001);
	<.main+?>: load.c32 714399001
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+600
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[151] := (718209783);
	<.main+?>: load.c32 718209783
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+604
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[152] := (722011213);
	<.main+?>: load.c32 722011213
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+608
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[153] := (725803337);
	<.main+?>: load.c32 725803337
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+612
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[154] := (729586201);
	<.main+?>: load.c32 729586201
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+616
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[155] := (733359850);
	<.main+?>: load.c32 733359850
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+620
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[156] := (737124328);
	<.main+?>: load.c32 737124328
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+624
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[157] := (740879680);
	<.main+?>: load.c32 740879680
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+628
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[158] := (744625950);
	<.main+?>: load.c32 744625950
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+632
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[159] := (748363182);
	<.main+?>: load.c32 748363182
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+636
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[160] := (752091420);
	<.main+?>: load.c32 752091420
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+640
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[161] := (755810706);
	<.main+?>: load.c32 755810706
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+644
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[162] := (759521084);
	<.main+?>: load.c32 759521084
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+648
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[163] := (763222596);
	<.main+?>: load.c32 763222596
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+652
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[164] := (766915284);
	<.main+?>: load.c32 766915284
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+656
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[165] := (770599191);
	<.main+?>: load.c32 770599191
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+660
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[166] := (774274358);
	<.main+?>: load.c32 774274358
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+664
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[167] := (777940826);
	<.main+?>: load.c32 777940826
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+668
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[168] := (781598636);
	<.main+?>: load.c32 781598636
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+672
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[169] := (785247830);
	<.main+?>: load.c32 785247830
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+676
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[170] := (788888447);
	<.main+?>: load.c32 788888447
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+680
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[171] := (792520529);
	<.main+?>: load.c32 792520529
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+684
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[172] := (796144114);
	<.main+?>: load.c32 796144114
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+688
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[173] := (799759243);
	<.main+?>: load.c32 799759243
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+692
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[174] := (803365955);
	<.main+?>: load.c32 803365955
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+696
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[175] := (806964288);
	<.main+?>: load.c32 806964288
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+700
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[176] := (810554283);
	<.main+?>: load.c32 810554283
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+704
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[177] := (814135977);
	<.main+?>: load.c32 814135977
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+708
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[178] := (817709409);
	<.main+?>: load.c32 817709409
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+712
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[179] := (821274616);
	<.main+?>: load.c32 821274616
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+716
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[180] := (824831638);
	<.main+?>: load.c32 824831638
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+720
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[181] := (828380510);
	<.main+?>: load.c32 828380510
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+724
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[182] := (831921270);
	<.main+?>: load.c32 831921270
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+728
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[183] := (835453956);
	<.main+?>: load.c32 835453956
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+732
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[184] := (838978604);
	<.main+?>: load.c32 838978604
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+736
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[185] := (842495250);
	<.main+?>: load.c32 842495250
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+740
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[186] := (846003931);
	<.main+?>: load.c32 846003931
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+744
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[187] := (849504683);
	<.main+?>: load.c32 849504683
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+748
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[188] := (852997541);
	<.main+?>: load.c32 852997541
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+752
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[189] := (856482541);
	<.main+?>: load.c32 856482541
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+756
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[190] := (859959719);
	<.main+?>: load.c32 859959719
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+760
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[191] := (863429109);
	<.main+?>: load.c32 863429109
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+764
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[192] := (866890746);
	<.main+?>: load.c32 866890746
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+768
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[193] := (870344665);
	<.main+?>: load.c32 870344665
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+772
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[194] := (873790900);
	<.main+?>: load.c32 873790900
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+776
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[195] := (877229485);
	<.main+?>: load.c32 877229485
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+780
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[196] := (880660455);
	<.main+?>: load.c32 880660455
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+784
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[197] := (884083842);
	<.main+?>: load.c32 884083842
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+788
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[198] := (887499680);
	<.main+?>: load.c32 887499680
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+792
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[199] := (890908002);
	<.main+?>: load.c32 890908002
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+796
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[200] := (894308843);
	<.main+?>: load.c32 894308843
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+800
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[201] := (897702233);
	<.main+?>: load.c32 897702233
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+804
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[202] := (901088206);
	<.main+?>: load.c32 901088206
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+808
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[203] := (904466794);
	<.main+?>: load.c32 904466794
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+812
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[204] := (907838029);
	<.main+?>: load.c32 907838029
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+816
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[205] := (911201943);
	<.main+?>: load.c32 911201943
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+820
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[206] := (914558569);
	<.main+?>: load.c32 914558569
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+824
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[207] := (917907937);
	<.main+?>: load.c32 917907937
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+828
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[208] := (921250078);
	<.main+?>: load.c32 921250078
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+832
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[209] := (924585025);
	<.main+?>: load.c32 924585025
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+836
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[210] := (927912807);
	<.main+?>: load.c32 927912807
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+840
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[211] := (931233455);
	<.main+?>: load.c32 931233455
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+844
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[212] := (934547001);
	<.main+?>: load.c32 934547001
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+848
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[213] := (937853474);
	<.main+?>: load.c32 937853474
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+852
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[214] := (941152904);
	<.main+?>: load.c32 941152904
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+856
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[215] := (944445322);
	<.main+?>: load.c32 944445322
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+860
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[216] := (947730757);
	<.main+?>: load.c32 947730757
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+864
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[217] := (951009239);
	<.main+?>: load.c32 951009239
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+868
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[218] := (954280797);
	<.main+?>: load.c32 954280797
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+872
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[219] := (957545460);
	<.main+?>: load.c32 957545460
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+876
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[220] := (960803257);
	<.main+?>: load.c32 960803257
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+880
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[221] := (964054217);
	<.main+?>: load.c32 964054217
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+884
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[222] := (967298369);
	<.main+?>: load.c32 967298369
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+888
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[223] := (970535741);
	<.main+?>: load.c32 970535741
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+892
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[224] := (973766362);
	<.main+?>: load.c32 973766362
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+896
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[225] := (976990259);
	<.main+?>: load.c32 976990259
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+900
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[226] := (980207460);
	<.main+?>: load.c32 980207460
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+904
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[227] := (983417994);
	<.main+?>: load.c32 983417994
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+908
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[228] := (986621888);
	<.main+?>: load.c32 986621888
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+912
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[229] := (989819169);
	<.main+?>: load.c32 989819169
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+916
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[230] := (993009864);
	<.main+?>: load.c32 993009864
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+920
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[231] := (996194001);
	<.main+?>: load.c32 996194001
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+924
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[232] := (999371606);
	<.main+?>: load.c32 999371606
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+928
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[233] := (1002542706);
	<.main+?>: load.c32 1002542706
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+932
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[234] := (1005707329);
	<.main+?>: load.c32 1005707329
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+936
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[235] := (1008865499);
	<.main+?>: load.c32 1008865499
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+940
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[236] := (1012017244);
	<.main+?>: load.c32 1012017244
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+944
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[237] := (1015162589);
	<.main+?>: load.c32 1015162589
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+948
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[238] := (1018301561);
	<.main+?>: load.c32 1018301561
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+952
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[239] := (1021434184);
	<.main+?>: load.c32 1021434184
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+956
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[240] := (1024560486);
	<.main+?>: load.c32 1024560486
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+960
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[241] := (1027680491);
	<.main+?>: load.c32 1027680491
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+964
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[242] := (1030794225);
	<.main+?>: load.c32 1030794225
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+968
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[243] := (1033901713);
	<.main+?>: load.c32 1033901713
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+972
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[244] := (1037002979);
	<.main+?>: load.c32 1037002979
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+976
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[245] := (1040098049);
	<.main+?>: load.c32 1040098049
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+980
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[246] := (1043186947);
	<.main+?>: load.c32 1043186947
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+984
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[247] := (1046269698);
	<.main+?>: load.c32 1046269698
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+988
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[248] := (1049346327);
	<.main+?>: load.c32 1049346327
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+992
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[249] := (1052416857);
	<.main+?>: load.c32 1052416857
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+996
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[250] := (1055481313);
	<.main+?>: load.c32 1055481313
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1000
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[251] := (1058539719);
	<.main+?>: load.c32 1058539719
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1004
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[252] := (1061592098);
	<.main+?>: load.c32 1061592098
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1008
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[253] := (1064638475);
	<.main+?>: load.c32 1064638475
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1012
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[254] := (1067678872);
	<.main+?>: load.c32 1067678872
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1016
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[255] := (1070713314);
	<.main+?>: load.c32 1070713314
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1020
	cmplStd/lib/math/Fixed.ci:169: (9 bytes): tbl_log2[256] := (1073741824);
	<.main+?>: load.c32 1073741824
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1024
	cmplStd/lib/math/Fixed.ci:255: (2313 bytes): static const tbl_pow2: uint32[257] := {...}
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[0] := (1073741824);
	<.main+?>: load.c32 1073741824
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[1] := (1076653033);
	<.main+?>: load.c32 1076653033
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+4
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[2] := (1079572135);
	<.main+?>: load.c32 1079572135
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+8
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[3] := (1082499152);
	<.main+?>: load.c32 1082499152
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+12
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[4] := (1085434105);
	<.main+?>: load.c32 1085434105
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+16
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[5] := (1088377016);
	<.main+?>: load.c32 1088377016
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+20
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[6] := (1091327905);
	<.main+?>: load.c32 1091327905
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+24
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[7] := (1094286795);
	<.main+?>: load.c32 1094286795
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+28
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[8] := (1097253708);
	<.main+?>: load.c32 1097253708
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+32
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[9] := (1100228664);
	<.main+?>: load.c32 1100228664
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+36
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[10] := (1103211687);
	<.main+?>: load.c32 1103211687
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+40
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[11] := (1106202797);
	<.main+?>: load.c32 1106202797
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+44
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[12] := (1109202017);
	<.main+?>: load.c32 1109202017
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+48
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[13] := (1112209369);
	<.main+?>: load.c32 1112209369
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+52
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[14] := (1115224875);
	<.main+?>: load.c32 1115224875
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+56
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[15] := (1118248556);
	<.main+?>: load.c32 1118248556
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+60
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[16] := (1121280435);
	<.main+?>: load.c32 1121280435
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+64
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[17] := (1124320535);
	<.main+?>: load.c32 1124320535
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+68
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[18] := (1127368877);
	<.main+?>: load.c32 1127368877
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+72
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[19] := (1130425484);
	<.main+?>: load.c32 1130425484
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+76
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[20] := (1133490379);
	<.main+?>: load.c32 1133490379
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+80
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[21] := (1136563583);
	<.main+?>: load.c32 1136563583
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+84
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[22] := (1139645119);
	<.main+?>: load.c32 1139645119
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+88
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[23] := (1142735011);
	<.main+?>: load.c32 1142735011
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+92
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[24] := (1145833280);
	<.main+?>: load.c32 1145833280
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+96
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[25] := (1148939949);
	<.main+?>: load.c32 1148939949
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+100
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[26] := (1152055041);
	<.main+?>: load.c32 1152055041
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+104
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[27] := (1155178579);
	<.main+?>: load.c32 1155178579
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+108
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[28] := (1158310586);
	<.main+?>: load.c32 1158310586
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+112
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[29] := (1161451085);
	<.main+?>: load.c32 1161451085
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+116
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[30] := (1164600098);
	<.main+?>: load.c32 1164600098
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+120
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[31] := (1167757649);
	<.main+?>: load.c32 1167757649
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+124
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[32] := (1170923761);
	<.main+?>: load.c32 1170923761
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+128
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[33] := (1174098458);
	<.main+?>: load.c32 1174098458
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+132
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[34] := (1177281762);
	<.main+?>: load.c32 1177281762
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+136
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[35] := (1180473696);
	<.main+?>: load.c32 1180473696
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+140
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[36] := (1183674285);
	<.main+?>: load.c32 1183674285
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+144
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[37] := (1186883552);
	<.main+?>: load.c32 1186883552
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+148
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[38] := (1190101520);
	<.main+?>: load.c32 1190101520
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+152
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[39] := (1193328212);
	<.main+?>: load.c32 1193328212
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+156
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[40] := (1196563653);
	<.main+?>: load.c32 1196563653
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+160
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[41] := (1199807866);
	<.main+?>: load.c32 1199807866
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+164
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[42] := (1203060875);
	<.main+?>: load.c32 1203060875
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+168
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[43] := (1206322704);
	<.main+?>: load.c32 1206322704
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+172
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[44] := (1209593377);
	<.main+?>: load.c32 1209593377
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+176
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[45] := (1212872917);
	<.main+?>: load.c32 1212872917
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+180
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[46] := (1216161349);
	<.main+?>: load.c32 1216161349
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+184
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[47] := (1219458697);
	<.main+?>: load.c32 1219458697
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+188
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[48] := (1222764985);
	<.main+?>: load.c32 1222764985
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+192
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[49] := (1226080238);
	<.main+?>: load.c32 1226080238
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+196
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[50] := (1229404478);
	<.main+?>: load.c32 1229404478
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+200
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[51] := (1232737732);
	<.main+?>: load.c32 1232737732
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+204
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[52] := (1236080023);
	<.main+?>: load.c32 1236080023
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+208
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[53] := (1239431376);
	<.main+?>: load.c32 1239431376
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+212
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[54] := (1242791815);
	<.main+?>: load.c32 1242791815
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+216
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[55] := (1246161366);
	<.main+?>: load.c32 1246161366
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+220
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[56] := (1249540052);
	<.main+?>: load.c32 1249540052
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+224
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[57] := (1252927899);
	<.main+?>: load.c32 1252927899
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+228
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[58] := (1256324931);
	<.main+?>: load.c32 1256324931
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+232
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[59] := (1259731173);
	<.main+?>: load.c32 1259731173
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+236
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[60] := (1263146651);
	<.main+?>: load.c32 1263146651
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+240
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[61] := (1266571389);
	<.main+?>: load.c32 1266571389
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+244
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[62] := (1270005412);
	<.main+?>: load.c32 1270005412
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+248
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[63] := (1273448746);
	<.main+?>: load.c32 1273448746
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+252
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[64] := (1276901416);
	<.main+?>: load.c32 1276901416
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+256
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[65] := (1280363447);
	<.main+?>: load.c32 1280363447
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+260
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[66] := (1283834865);
	<.main+?>: load.c32 1283834865
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+264
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[67] := (1287315694);
	<.main+?>: load.c32 1287315694
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+268
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[68] := (1290805961);
	<.main+?>: load.c32 1290805961
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+272
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[69] := (1294305691);
	<.main+?>: load.c32 1294305691
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+276
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[70] := (1297814910);
	<.main+?>: load.c32 1297814910
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+280
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[71] := (1301333643);
	<.main+?>: load.c32 1301333643
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+284
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[72] := (1304861916);
	<.main+?>: load.c32 1304861916
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+288
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[73] := (1308399756);
	<.main+?>: load.c32 1308399756
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+292
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[74] := (1311947188);
	<.main+?>: load.c32 1311947188
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+296
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[75] := (1315504237);
	<.main+?>: load.c32 1315504237
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+300
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[76] := (1319070931);
	<.main+?>: load.c32 1319070931
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+304
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[77] := (1322647295);
	<.main+?>: load.c32 1322647295
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+308
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[78] := (1326233356);
	<.main+?>: load.c32 1326233356
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+312
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[79] := (1329829139);
	<.main+?>: load.c32 1329829139
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+316
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[80] := (1333434672);
	<.main+?>: load.c32 1333434672
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+320
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[81] := (1337049980);
	<.main+?>: load.c32 1337049980
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+324
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[82] := (1340675090);
	<.main+?>: load.c32 1340675090
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+328
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[83] := (1344310029);
	<.main+?>: load.c32 1344310029
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+332
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[84] := (1347954823);
	<.main+?>: load.c32 1347954823
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+336
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[85] := (1351609500);
	<.main+?>: load.c32 1351609500
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+340
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[86] := (1355274085);
	<.main+?>: load.c32 1355274085
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+344
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[87] := (1358948606);
	<.main+?>: load.c32 1358948606
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+348
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[88] := (1362633089);
	<.main+?>: load.c32 1362633089
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+352
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[89] := (1366327562);
	<.main+?>: load.c32 1366327562
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+356
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[90] := (1370032052);
	<.main+?>: load.c32 1370032052
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+360
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[91] := (1373746586);
	<.main+?>: load.c32 1373746586
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+364
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[92] := (1377471191);
	<.main+?>: load.c32 1377471191
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+368
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[93] := (1381205894);
	<.main+?>: load.c32 1381205894
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+372
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[94] := (1384950723);
	<.main+?>: load.c32 1384950723
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+376
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[95] := (1388705705);
	<.main+?>: load.c32 1388705705
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+380
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[96] := (1392470868);
	<.main+?>: load.c32 1392470868
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+384
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[97] := (1396246240);
	<.main+?>: load.c32 1396246240
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+388
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[98] := (1400031847);
	<.main+?>: load.c32 1400031847
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+392
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[99] := (1403827719);
	<.main+?>: load.c32 1403827719
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+396
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[100] := (1407633882);
	<.main+?>: load.c32 1407633882
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+400
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[101] := (1411450365);
	<.main+?>: load.c32 1411450365
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+404
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[102] := (1415277195);
	<.main+?>: load.c32 1415277195
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+408
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[103] := (1419114400);
	<.main+?>: load.c32 1419114400
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+412
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[104] := (1422962010);
	<.main+?>: load.c32 1422962010
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+416
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[105] := (1426820051);
	<.main+?>: load.c32 1426820051
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+420
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[106] := (1430688553);
	<.main+?>: load.c32 1430688553
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+424
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[107] := (1434567543);
	<.main+?>: load.c32 1434567543
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+428
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[108] := (1438457050);
	<.main+?>: load.c32 1438457050
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+432
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[109] := (1442357103);
	<.main+?>: load.c32 1442357103
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+436
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[110] := (1446267730);
	<.main+?>: load.c32 1446267730
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+440
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[111] := (1450188959);
	<.main+?>: load.c32 1450188959
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+444
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[112] := (1454120821);
	<.main+?>: load.c32 1454120821
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+448
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[113] := (1458063342);
	<.main+?>: load.c32 1458063342
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+452
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[114] := (1462016553);
	<.main+?>: load.c32 1462016553
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+456
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[115] := (1465980482);
	<.main+?>: load.c32 1465980482
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+460
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[116] := (1469955158);
	<.main+?>: load.c32 1469955158
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+464
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[117] := (1473940611);
	<.main+?>: load.c32 1473940611
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+468
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[118] := (1477936869);
	<.main+?>: load.c32 1477936869
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+472
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[119] := (1481943963);
	<.main+?>: load.c32 1481943963
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+476
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[120] := (1485961920);
	<.main+?>: load.c32 1485961920
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+480
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[121] := (1489990772);
	<.main+?>: load.c32 1489990772
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+484
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[122] := (1494030547);
	<.main+?>: load.c32 1494030547
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+488
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[123] := (1498081274);
	<.main+?>: load.c32 1498081274
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+492
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[124] := (1502142985);
	<.main+?>: load.c32 1502142985
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+496
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[125] := (1506215708);
	<.main+?>: load.c32 1506215708
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+500
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[126] := (1510299473);
	<.main+?>: load.c32 1510299473
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+504
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[127] := (1514394310);
	<.main+?>: load.c32 1514394310
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+508
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[128] := (1518500249);
	<.main+?>: load.c32 1518500249
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+512
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[129] := (1522617321);
	<.main+?>: load.c32 1522617321
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+516
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[130] := (1526745556);
	<.main+?>: load.c32 1526745556
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+520
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[131] := (1530884983);
	<.main+?>: load.c32 1530884983
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+524
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[132] := (1535035633);
	<.main+?>: load.c32 1535035633
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+528
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[133] := (1539197537);
	<.main+?>: load.c32 1539197537
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+532
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[134] := (1543370725);
	<.main+?>: load.c32 1543370725
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+536
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[135] := (1547555227);
	<.main+?>: load.c32 1547555227
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+540
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[136] := (1551751075);
	<.main+?>: load.c32 1551751075
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+544
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[137] := (1555958299);
	<.main+?>: load.c32 1555958299
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+548
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[138] := (1560176930);
	<.main+?>: load.c32 1560176930
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+552
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[139] := (1564406999);
	<.main+?>: load.c32 1564406999
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+556
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[140] := (1568648537);
	<.main+?>: load.c32 1568648537
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+560
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[141] := (1572901574);
	<.main+?>: load.c32 1572901574
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+564
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[142] := (1577166143);
	<.main+?>: load.c32 1577166143
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+568
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[143] := (1581442274);
	<.main+?>: load.c32 1581442274
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+572
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[144] := (1585729999);
	<.main+?>: load.c32 1585729999
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+576
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[145] := (1590029349);
	<.main+?>: load.c32 1590029349
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+580
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[146] := (1594340356);
	<.main+?>: load.c32 1594340356
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+584
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[147] := (1598663051);
	<.main+?>: load.c32 1598663051
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+588
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[148] := (1602997467);
	<.main+?>: load.c32 1602997467
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+592
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[149] := (1607343634);
	<.main+?>: load.c32 1607343634
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+596
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[150] := (1611701584);
	<.main+?>: load.c32 1611701584
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+600
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[151] := (1616071351);
	<.main+?>: load.c32 1616071351
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+604
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[152] := (1620452965);
	<.main+?>: load.c32 1620452965
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+608
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[153] := (1624846458);
	<.main+?>: load.c32 1624846458
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+612
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[154] := (1629251864);
	<.main+?>: load.c32 1629251864
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+616
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[155] := (1633669214);
	<.main+?>: load.c32 1633669214
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+620
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[156] := (1638098541);
	<.main+?>: load.c32 1638098541
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+624
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[157] := (1642539876);
	<.main+?>: load.c32 1642539876
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+628
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[158] := (1646993254);
	<.main+?>: load.c32 1646993254
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+632
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[159] := (1651458705);
	<.main+?>: load.c32 1651458705
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+636
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[160] := (1655936264);
	<.main+?>: load.c32 1655936264
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+640
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[161] := (1660425963);
	<.main+?>: load.c32 1660425963
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+644
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[162] := (1664927834);
	<.main+?>: load.c32 1664927834
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+648
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[163] := (1669441912);
	<.main+?>: load.c32 1669441912
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+652
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[164] := (1673968228);
	<.main+?>: load.c32 1673968228
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+656
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[165] := (1678506816);
	<.main+?>: load.c32 1678506816
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+660
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[166] := (1683057710);
	<.main+?>: load.c32 1683057710
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+664
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[167] := (1687620942);
	<.main+?>: load.c32 1687620942
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+668
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[168] := (1692196547);
	<.main+?>: load.c32 1692196547
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+672
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[169] := (1696784557);
	<.main+?>: load.c32 1696784557
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+676
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[170] := (1701385007);
	<.main+?>: load.c32 1701385007
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+680
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[171] := (1705997929);
	<.main+?>: load.c32 1705997929
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+684
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[172] := (1710623359);
	<.main+?>: load.c32 1710623359
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+688
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[173] := (1715261329);
	<.main+?>: load.c32 1715261329
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+692
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[174] := (1719911875);
	<.main+?>: load.c32 1719911875
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+696
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[175] := (1724575029);
	<.main+?>: load.c32 1724575029
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+700
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[176] := (1729250826);
	<.main+?>: load.c32 1729250826
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+704
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[177] := (1733939301);
	<.main+?>: load.c32 1733939301
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+708
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[178] := (1738640487);
	<.main+?>: load.c32 1738640487
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+712
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[179] := (1743354420);
	<.main+?>: load.c32 1743354420
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+716
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[180] := (1748081133);
	<.main+?>: load.c32 1748081133
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+720
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[181] := (1752820662);
	<.main+?>: load.c32 1752820662
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+724
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[182] := (1757573041);
	<.main+?>: load.c32 1757573041
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+728
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[183] := (1762338305);
	<.main+?>: load.c32 1762338305
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+732
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[184] := (1767116488);
	<.main+?>: load.c32 1767116488
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+736
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[185] := (1771907627);
	<.main+?>: load.c32 1771907627
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+740
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[186] := (1776711756);
	<.main+?>: load.c32 1776711756
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+744
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[187] := (1781528911);
	<.main+?>: load.c32 1781528911
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+748
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[188] := (1786359125);
	<.main+?>: load.c32 1786359125
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+752
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[189] := (1791202436);
	<.main+?>: load.c32 1791202436
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+756
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[190] := (1796058879);
	<.main+?>: load.c32 1796058879
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+760
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[191] := (1800928488);
	<.main+?>: load.c32 1800928488
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+764
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[192] := (1805811301);
	<.main+?>: load.c32 1805811301
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+768
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[193] := (1810707352);
	<.main+?>: load.c32 1810707352
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+772
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[194] := (1815616678);
	<.main+?>: load.c32 1815616678
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+776
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[195] := (1820539314);
	<.main+?>: load.c32 1820539314
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+780
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[196] := (1825475297);
	<.main+?>: load.c32 1825475297
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+784
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[197] := (1830424662);
	<.main+?>: load.c32 1830424662
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+788
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[198] := (1835387447);
	<.main+?>: load.c32 1835387447
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+792
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[199] := (1840363687);
	<.main+?>: load.c32 1840363687
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+796
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[200] := (1845353419);
	<.main+?>: load.c32 1845353419
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+800
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[201] := (1850356680);
	<.main+?>: load.c32 1850356680
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+804
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[202] := (1855373506);
	<.main+?>: load.c32 1855373506
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+808
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[203] := (1860403934);
	<.main+?>: load.c32 1860403934
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+812
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[204] := (1865448001);
	<.main+?>: load.c32 1865448001
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+816
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[205] := (1870505743);
	<.main+?>: load.c32 1870505743
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+820
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[206] := (1875577199);
	<.main+?>: load.c32 1875577199
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+824
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[207] := (1880662405);
	<.main+?>: load.c32 1880662405
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+828
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[208] := (1885761398);
	<.main+?>: load.c32 1885761398
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+832
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[209] := (1890874215);
	<.main+?>: load.c32 1890874215
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+836
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[210] := (1896000895);
	<.main+?>: load.c32 1896000895
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+840
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[211] := (1901141475);
	<.main+?>: load.c32 1901141475
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+844
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[212] := (1906295993);
	<.main+?>: load.c32 1906295993
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+848
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[213] := (1911464486);
	<.main+?>: load.c32 1911464486
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+852
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[214] := (1916646992);
	<.main+?>: load.c32 1916646992
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+856
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[215] := (1921843549);
	<.main+?>: load.c32 1921843549
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+860
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[216] := (1927054195);
	<.main+?>: load.c32 1927054195
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+864
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[217] := (1932278969);
	<.main+?>: load.c32 1932278969
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+868
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[218] := (1937517909);
	<.main+?>: load.c32 1937517909
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+872
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[219] := (1942771053);
	<.main+?>: load.c32 1942771053
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+876
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[220] := (1948038440);
	<.main+?>: load.c32 1948038440
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+880
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[221] := (1953320108);
	<.main+?>: load.c32 1953320108
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+884
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[222] := (1958616096);
	<.main+?>: load.c32 1958616096
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+888
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[223] := (1963926443);
	<.main+?>: load.c32 1963926443
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+892
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[224] := (1969251187);
	<.main+?>: load.c32 1969251187
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+896
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[225] := (1974590369);
	<.main+?>: load.c32 1974590369
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+900
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[226] := (1979944027);
	<.main+?>: load.c32 1979944027
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+904
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[227] := (1985312199);
	<.main+?>: load.c32 1985312199
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+908
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[228] := (1990694927);
	<.main+?>: load.c32 1990694927
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+912
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[229] := (1996092248);
	<.main+?>: load.c32 1996092248
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+916
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[230] := (2001504204);
	<.main+?>: load.c32 2001504204
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+920
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[231] := (2006930832);
	<.main+?>: load.c32 2006930832
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+924
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[232] := (2012372173);
	<.main+?>: load.c32 2012372173
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+928
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[233] := (2017828268);
	<.main+?>: load.c32 2017828268
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+932
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[234] := (2023299155);
	<.main+?>: load.c32 2023299155
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+936
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[235] := (2028784876);
	<.main+?>: load.c32 2028784876
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+940
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[236] := (2034285470);
	<.main+?>: load.c32 2034285470
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+944
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[237] := (2039800977);
	<.main+?>: load.c32 2039800977
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+948
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[238] := (2045331439);
	<.main+?>: load.c32 2045331439
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+952
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[239] := (2050876895);
	<.main+?>: load.c32 2050876895
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+956
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[240] := (2056437386);
	<.main+?>: load.c32 2056437386
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+960
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[241] := (2062012953);
	<.main+?>: load.c32 2062012953
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+964
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[242] := (2067603638);
	<.main+?>: load.c32 2067603638
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+968
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[243] := (2073209480);
	<.main+?>: load.c32 2073209480
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+972
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[244] := (2078830521);
	<.main+?>: load.c32 2078830521
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+976
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[245] := (2084466802);
	<.main+?>: load.c32 2084466802
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+980
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[246] := (2090118365);
	<.main+?>: load.c32 2090118365
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+984
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[247] := (2095785251);
	<.main+?>: load.c32 2095785251
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+988
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[248] := (2101467501);
	<.main+?>: load.c32 2101467501
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+992
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[249] := (2107165158);
	<.main+?>: load.c32 2107165158
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+996
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[250] := (2112878262);
	<.main+?>: load.c32 2112878262
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1000
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[251] := (2118606856);
	<.main+?>: load.c32 2118606856
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1004
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[252] := (2124350982);
	<.main+?>: load.c32 2124350982
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1008
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[253] := (2130110682);
	<.main+?>: load.c32 2130110682
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1012
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[254] := (2135885998);
	<.main+?>: load.c32 2135885998
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1016
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[255] := (2141676972);
	<.main+?>: load.c32 2141676972
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1020
	cmplStd/lib/math/Fixed.ci:289: (9 bytes): tbl_pow2[256] := (2147483648);
	<.main+?>: load.c32 -2147483648
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1024
	cmplStd/lib/time/Duration.ci:8: (13 bytes): static const precision: Timeunit := Timeunit.(Millis)
	<.main+?>: load.c64 1000000
	<.main+?>: store.m64 <?> ;Duration.precision
	cmplStd/lib/time/Timestamp.ci:9: (13 bytes): static const precision: Timeunit := Timeunit.(Millis)
	<.main+?>: load.c64 1000000
	<.main+?>: store.m64 <?> ;Timestamp.precision
	cmplStd/lib/time/Datetime.ci:97: (113 bytes): static const DaysToMonth365: int32[13] := {...}
	cmplStd/lib/time/Datetime.ci:97: (5 bytes): DaysToMonth365[0] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[1] := 31;
	<.main+?>: load.c32 31
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+4
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[2] := 59;
	<.main+?>: load.c32 59
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+8
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[3] := 90;
	<.main+?>: load.c32 90
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+12
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[4] := 120;
	<.main+?>: load.c32 120
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+16
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[5] := 151;
	<.main+?>: load.c32 151
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+20
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[6] := 181;
	<.main+?>: load.c32 181
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+24
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[7] := 212;
	<.main+?>: load.c32 212
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+28
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[8] := 243;
	<.main+?>: load.c32 243
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+32
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[9] := 273;
	<.main+?>: load.c32 273
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+36
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[10] := 304;
	<.main+?>: load.c32 304
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+40
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[11] := 334;
	<.main+?>: load.c32 334
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+44
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[12] := 365;
	<.main+?>: load.c32 365
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+48
	cmplStd/lib/time/Datetime.ci:98: (113 bytes): static const DaysToMonth366: int32[13] := {...}
	cmplStd/lib/time/Datetime.ci:98: (5 bytes): DaysToMonth366[0] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[1] := 31;
	<.main+?>: load.c32 31
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+4
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[2] := 60;
	<.main+?>: load.c32 60
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+8
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[3] := 91;
	<.main+?>: load.c32 91
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+12
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[4] := 121;
	<.main+?>: load.c32 121
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+16
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[5] := 152;
	<.main+?>: load.c32 152
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+20
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[6] := 182;
	<.main+?>: load.c32 182
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+24
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[7] := 213;
	<.main+?>: load.c32 213
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+28
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[8] := 244;
	<.main+?>: load.c32 244
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+32
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[9] := 274;
	<.main+?>: load.c32 274
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+36
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[10] := 305;
	<.main+?>: load.c32 305
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+40
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[11] := 335;
	<.main+?>: load.c32 335
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+44
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[12] := 366;
	<.main+?>: load.c32 366
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+48
	cmplStd/lib/time/Datetime.ci:99: (9 bytes): static const DaysTil1970: int32 := 719162
	<.main+?>: load.c32 719162
	<.main+?>: store.m32 <?> ;Datetime.DaysTil1970
	cmplStd/lib/text/Format.ci:108: (14 bytes): static const whiteSpace: char[] := " \t\n\r"
	<.main+?>: load.c32 4
	<.main+?>: load.ref <?> ;" \t\n\r"
	<.main+?>: store.m64 <?> ;append.whiteSpace
	cmplStd/lib/text/Format.ci:109: (14 bytes): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: load.c32 36
	<.main+?>: load.ref <?> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: store.m64 <?> ;append.radixDigits
	cmplStd/lib/text/Format.ci:508: (182 bytes): static const monthsLongEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:508: (14 bytes): monthsLongEn := monthsLongEn.init
	<.main+?>: load.c32 12
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.monthsLongEn
	cmplStd/lib/text/Format.ci:509: (14 bytes): monthsLongEn.init[0] := ("January");
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;"January"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:510: (14 bytes): monthsLongEn.init[1] := ("February");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"February"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:511: (14 bytes): monthsLongEn.init[2] := ("March");
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;"March"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:512: (14 bytes): monthsLongEn.init[3] := ("April");
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;"April"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:513: (14 bytes): monthsLongEn.init[4] := ("May");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"May"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:514: (14 bytes): monthsLongEn.init[5] := ("June");
	<.main+?>: load.c32 4
	<.main+?>: load.ref <?> ;"June"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:515: (14 bytes): monthsLongEn.init[6] := ("July");
	<.main+?>: load.c32 4
	<.main+?>: load.ref <?> ;"July"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:516: (14 bytes): monthsLongEn.init[7] := ("August");
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"August"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:517: (14 bytes): monthsLongEn.init[8] := ("September");
	<.main+?>: load.c32 9
	<.main+?>: load.ref <?> ;"September"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:518: (14 bytes): monthsLongEn.init[9] := ("October");
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;"October"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:519: (14 bytes): monthsLongEn.init[10] := ("November");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"November"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:520: (14 bytes): monthsLongEn.init[11] := ("December");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"December"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:522: (182 bytes): static const monthsShortEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:522: (14 bytes): monthsShortEn := monthsShortEn.init
	<.main+?>: load.c32 12
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.monthsShortEn
	cmplStd/lib/text/Format.ci:523: (14 bytes): monthsShortEn.init[0] := ("Jan");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Jan"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:523: (14 bytes): monthsShortEn.init[1] := ("Feb");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Feb"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:523: (14 bytes): monthsShortEn.init[2] := ("Mar");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Mar"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:523: (14 bytes): monthsShortEn.init[3] := ("Apr");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Apr"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:524: (14 bytes): monthsShortEn.init[4] := ("May");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"May"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:524: (14 bytes): monthsShortEn.init[5] := ("Jun");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Jun"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:524: (14 bytes): monthsShortEn.init[6] := ("Jul");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Jul"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:524: (14 bytes): monthsShortEn.init[7] := ("Aug");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Aug"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:525: (14 bytes): monthsShortEn.init[8] := ("Sep");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Sep"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:525: (14 bytes): monthsShortEn.init[9] := ("Oct");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Oct"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:525: (14 bytes): monthsShortEn.init[10] := ("Nov");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Nov"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:525: (14 bytes): monthsShortEn.init[11] := ("Dec");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Dec"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:527: (112 bytes): static const weeksLongEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:527: (14 bytes): weeksLongEn := weeksLongEn.init
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.weeksLongEn
	cmplStd/lib/text/Format.ci:528: (14 bytes): weeksLongEn.init[0] := ("Monday");
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"Monday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:529: (14 bytes): weeksLongEn.init[1] := ("Tuesday");
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;"Tuesday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:530: (14 bytes): weeksLongEn.init[2] := ("Wednesday");
	<.main+?>: load.c32 9
	<.main+?>: load.ref <?> ;"Wednesday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:531: (14 bytes): weeksLongEn.init[3] := ("Thursday");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"Thursday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:532: (14 bytes): weeksLongEn.init[4] := ("Friday");
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"Friday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:533: (14 bytes): weeksLongEn.init[5] := ("Saturday");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"Saturday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:534: (14 bytes): weeksLongEn.init[6] := ("Sunday");
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"Sunday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:536: (112 bytes): static const weeksShortEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:536: (14 bytes): weeksShortEn := weeksShortEn.init
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.weeksShortEn
	cmplStd/lib/text/Format.ci:537: (14 bytes): weeksShortEn.init[0] := ("Mon");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Mon"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:537: (14 bytes): weeksShortEn.init[1] := ("Tue");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Tue"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:537: (14 bytes): weeksShortEn.init[2] := ("Wed");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Wed"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:538: (14 bytes): weeksShortEn.init[3] := ("Thu");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Thu"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:538: (14 bytes): weeksShortEn.init[4] := ("Fri");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Fri"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:538: (14 bytes): weeksShortEn.init[5] := ("Sat");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Sat"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:539: (14 bytes): weeksShortEn.init[6] := ("Sun");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Sun"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:541: (42 bytes): static const amPmUpperEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:541: (14 bytes): amPmUpperEn := amPmUpperEn.init
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.amPmUpperEn
	cmplStd/lib/text/Format.ci:542: (14 bytes): amPmUpperEn.init[0] := ("AM");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"AM"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:543: (14 bytes): amPmUpperEn.init[1] := ("PM");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"PM"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:545: (42 bytes): static const amPmLowerEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:545: (14 bytes): amPmLowerEn := amPmLowerEn.init
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.amPmLowerEn
	cmplStd/lib/text/Format.ci:546: (14 bytes): amPmLowerEn.init[0] := ("am");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"am"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:547: (14 bytes): amPmLowerEn.init[1] := ("pm");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"pm"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:550: (104 bytes): static const fmtEN: DatetimeFormat := {...}
	cmplStd/lib/text/Format.ci:551: (8 bytes): fmtEN.monthsLong := (monthsLongEn);
	<.main+?>: load.m64 <?> ;format.monthsLongEn
	<.main+?>: store.m64 <?> ;format.fmtEN
	cmplStd/lib/text/Format.ci:552: (8 bytes): fmtEN.monthsShort := (monthsShortEn);
	<.main+?>: load.m64 <?> ;format.monthsShortEn
	<.main+?>: store.m64 <?> ;format.fmtEN+8
	cmplStd/lib/text/Format.ci:553: (8 bytes): fmtEN.weeksLong := (weeksLongEn);
	<.main+?>: load.m64 <?> ;format.weeksLongEn
	<.main+?>: store.m64 <?> ;format.fmtEN+16
	cmplStd/lib/text/Format.ci:554: (8 bytes): fmtEN.weeksShort := (weeksShortEn);
	<.main+?>: load.m64 <?> ;format.weeksShortEn
	<.main+?>: store.m64 <?> ;format.fmtEN+24
	cmplStd/lib/text/Format.ci:555: (8 bytes): fmtEN.amPmUpper := (amPmUpperEn);
	<.main+?>: load.m64 <?> ;format.amPmUpperEn
	<.main+?>: store.m64 <?> ;format.fmtEN+32
	cmplStd/lib/text/Format.ci:556: (8 bytes): fmtEN.amPmLower := (amPmLowerEn);
	<.main+?>: load.m64 <?> ;format.amPmLowerEn
	<.main+?>: store.m64 <?> ;format.fmtEN+40
	:: (14 bytes): fmtEN.dateLong := ("%A %d %B %Y");
	<.main+?>: load.c32 11
	<.main+?>: load.ref <?> ;"%A %d %B %Y"
	<.main+?>: store.m64 <?> ;format.fmtEN+48
	:: (14 bytes): fmtEN.timeLong := ("%r");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"%r"
	<.main+?>: store.m64 <?> ;format.fmtEN+56
	:: (14 bytes): fmtEN.dateShort := ("%x");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"%x"
	<.main+?>: store.m64 <?> ;format.fmtEN+64
	:: (14 bytes): fmtEN.timeShort := ("%I:%M %p");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"%I:%M %p"
	<.main+?>: store.m64 <?> ;format.fmtEN+72
	cmplStd/lib/text/Format.ci:564: (39 bytes): static const format: FormatFlags := {...}
	:: (7 bytes): format.sign := (0);
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format
	<.main+?>: store.i8
	:: (7 bytes): format.padChr := (0);
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format+1
	<.main+?>: store.i8
	:: (5 bytes): format.width := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+4
	:: (9 bytes): format.precision := 10;
	<.main+?>: load.c32 10
	<.main+?>: store.m32 <?> ;append.format+8
	:: (11 bytes): format.trimDecimal := true;
	<.main+?>: load.c32 1
	<.main+?>: load.ref <?> ;append.format+12
	<.main+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:3: (14 bytes): static const lookup: uint8[] := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	<.main+?>: load.c32 64
	<.main+?>: load.ref <?> ;"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	<.main+?>: store.m64 <?> ;Base64Encoder.lookup
	cmplStd/lib/text/encoding/binary/Base64.ci:136: (2300 bytes): static const lookup: int32[256] := {...}
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[0] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[1] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+4
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[2] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+8
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[3] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+12
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[4] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+16
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[5] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+20
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[6] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+24
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[7] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+28
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[8] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+32
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[9] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+36
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[10] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+40
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[11] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+44
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[12] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+48
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[13] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+52
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[14] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+56
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[15] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+60
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[16] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+64
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[17] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+68
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[18] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+72
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[19] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+76
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[20] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+80
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[21] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+84
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[22] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+88
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[23] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+92
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[24] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+96
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[25] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+100
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[26] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+104
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[27] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+108
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[28] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+112
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[29] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+116
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[30] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+120
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[31] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+124
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[32] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+128
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[33] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+132
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[34] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+136
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[35] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+140
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[36] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+144
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[37] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+148
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[38] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+152
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[39] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+156
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[40] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+160
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[41] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+164
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[42] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+168
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[43] := 62;
	<.main+?>: load.c32 62
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+172
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[44] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+176
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[45] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+180
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[46] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+184
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[47] := 63;
	<.main+?>: load.c32 63
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+188
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[48] := 52;
	<.main+?>: load.c32 52
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+192
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[49] := 53;
	<.main+?>: load.c32 53
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+196
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[50] := 54;
	<.main+?>: load.c32 54
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+200
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[51] := 55;
	<.main+?>: load.c32 55
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+204
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[52] := 56;
	<.main+?>: load.c32 56
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+208
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[53] := 57;
	<.main+?>: load.c32 57
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+212
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[54] := 58;
	<.main+?>: load.c32 58
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+216
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[55] := 59;
	<.main+?>: load.c32 59
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+220
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[56] := 60;
	<.main+?>: load.c32 60
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+224
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[57] := 61;
	<.main+?>: load.c32 61
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+228
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[58] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+232
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[59] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+236
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[60] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+240
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[61] := -2;
	<.main+?>: load.c32 -2
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+244
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[62] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+248
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[63] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+252
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[64] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+256
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (5 bytes): lookup[65] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+260
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[66] := 1;
	<.main+?>: load.c32 1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+264
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[67] := 2;
	<.main+?>: load.c32 2
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+268
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[68] := 3;
	<.main+?>: load.c32 3
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+272
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[69] := 4;
	<.main+?>: load.c32 4
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+276
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[70] := 5;
	<.main+?>: load.c32 5
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+280
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[71] := 6;
	<.main+?>: load.c32 6
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+284
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[72] := 7;
	<.main+?>: load.c32 7
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+288
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[73] := 8;
	<.main+?>: load.c32 8
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+292
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[74] := 9;
	<.main+?>: load.c32 9
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+296
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[75] := 10;
	<.main+?>: load.c32 10
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+300
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[76] := 11;
	<.main+?>: load.c32 11
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+304
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[77] := 12;
	<.main+?>: load.c32 12
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+308
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[78] := 13;
	<.main+?>: load.c32 13
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+312
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[79] := 14;
	<.main+?>: load.c32 14
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+316
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[80] := 15;
	<.main+?>: load.c32 15
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+320
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[81] := 16;
	<.main+?>: load.c32 16
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+324
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[82] := 17;
	<.main+?>: load.c32 17
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+328
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[83] := 18;
	<.main+?>: load.c32 18
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+332
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[84] := 19;
	<.main+?>: load.c32 19
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+336
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[85] := 20;
	<.main+?>: load.c32 20
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+340
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[86] := 21;
	<.main+?>: load.c32 21
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+344
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[87] := 22;
	<.main+?>: load.c32 22
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+348
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[88] := 23;
	<.main+?>: load.c32 23
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+352
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[89] := 24;
	<.main+?>: load.c32 24
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+356
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[90] := 25;
	<.main+?>: load.c32 25
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+360
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[91] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+364
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[92] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+368
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[93] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+372
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[94] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+376
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[95] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+380
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[96] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+384
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[97] := 26;
	<.main+?>: load.c32 26
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+388
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[98] := 27;
	<.main+?>: load.c32 27
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+392
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[99] := 28;
	<.main+?>: load.c32 28
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+396
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[100] := 29;
	<.main+?>: load.c32 29
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+400
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[101] := 30;
	<.main+?>: load.c32 30
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+404
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[102] := 31;
	<.main+?>: load.c32 31
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+408
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[103] := 32;
	<.main+?>: load.c32 32
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+412
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[104] := 33;
	<.main+?>: load.c32 33
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+416
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[105] := 34;
	<.main+?>: load.c32 34
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+420
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[106] := 35;
	<.main+?>: load.c32 35
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+424
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[107] := 36;
	<.main+?>: load.c32 36
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+428
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[108] := 37;
	<.main+?>: load.c32 37
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+432
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[109] := 38;
	<.main+?>: load.c32 38
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+436
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[110] := 39;
	<.main+?>: load.c32 39
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+440
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[111] := 40;
	<.main+?>: load.c32 40
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+444
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[112] := 41;
	<.main+?>: load.c32 41
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+448
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[113] := 42;
	<.main+?>: load.c32 42
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+452
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[114] := 43;
	<.main+?>: load.c32 43
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+456
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[115] := 44;
	<.main+?>: load.c32 44
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+460
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[116] := 45;
	<.main+?>: load.c32 45
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+464
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[117] := 46;
	<.main+?>: load.c32 46
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+468
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[118] := 47;
	<.main+?>: load.c32 47
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+472
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[119] := 48;
	<.main+?>: load.c32 48
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+476
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[120] := 49;
	<.main+?>: load.c32 49
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+480
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[121] := 50;
	<.main+?>: load.c32 50
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+484
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[122] := 51;
	<.main+?>: load.c32 51
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+488
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[123] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+492
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[124] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+496
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[125] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+500
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[126] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+504
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[127] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+508
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[128] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+512
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[129] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+516
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[130] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+520
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[131] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+524
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[132] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+528
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[133] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+532
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[134] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+536
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[135] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+540
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[136] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+544
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[137] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+548
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[138] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+552
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[139] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+556
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[140] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+560
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[141] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+564
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[142] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+568
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[143] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+572
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[144] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+576
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[145] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+580
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[146] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+584
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[147] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+588
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[148] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+592
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[149] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+596
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[150] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+600
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[151] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+604
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[152] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+608
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[153] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+612
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[154] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+616
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[155] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+620
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[156] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+624
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[157] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+628
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[158] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+632
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[159] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+636
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[160] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+640
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[161] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+644
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[162] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+648
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[163] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+652
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[164] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+656
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[165] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+660
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[166] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+664
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[167] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+668
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[168] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+672
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[169] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+676
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[170] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+680
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[171] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+684
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[172] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+688
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[173] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+692
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[174] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+696
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[175] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+700
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[176] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+704
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[177] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+708
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[178] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+712
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[179] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+716
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[180] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+720
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[181] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+724
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[182] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+728
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[183] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+732
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[184] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+736
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[185] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+740
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[186] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+744
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[187] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+748
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[188] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+752
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[189] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+756
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[190] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+760
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[191] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+764
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[192] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+768
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[193] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+772
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[194] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+776
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[195] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+780
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[196] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+784
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[197] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+788
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[198] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+792
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[199] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+796
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[200] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+800
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[201] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+804
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[202] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+808
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[203] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+812
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[204] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+816
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[205] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+820
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[206] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+824
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[207] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+828
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[208] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+832
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[209] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+836
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[210] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+840
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[211] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+844
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[212] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+848
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[213] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+852
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[214] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+856
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[215] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+860
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[216] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+864
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[217] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+868
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[218] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+872
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[219] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+876
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[220] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+880
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[221] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+884
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[222] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+888
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[223] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+892
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[224] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+896
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[225] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+900
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[226] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+904
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[227] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+908
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[228] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+912
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[229] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+916
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[230] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+920
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[231] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+924
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[232] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+928
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[233] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+932
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[234] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+936
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[235] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+940
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[236] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+944
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[237] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+948
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[238] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+952
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[239] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+956
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[240] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+960
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[241] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+964
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[242] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+968
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[243] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+972
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[244] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+976
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[245] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+980
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[246] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+984
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[247] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+988
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[248] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+992
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[249] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+996
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[250] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1000
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[251] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1004
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[252] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1008
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[253] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1012
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[254] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1016
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[255] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1020
	cmplGfx/lib/color.lookup.ci:48: (236 bytes): static const rgb2luv: int32[] := {...}
	cmplGfx/lib/color.lookup.ci:48: (14 bytes): rgb2luv := rgb2luv.init
	<.main+?>: load.c32 12
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;colorMap.rgb2luv
	cmplGfx/lib/color.lookup.ci:49: (23 bytes): rgb2luv.init[0] := fxp(0.299000);
	<.main+?>: load.f64 0.299000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:49: (23 bytes): rgb2luv.init[1] := fxp(0.587000);
	<.main+?>: load.f64 0.587000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:49: (23 bytes): rgb2luv.init[2] := fxp(0.114000);
	<.main+?>: load.f64 0.114000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:49: (5 bytes): rgb2luv.init[3] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:50: (23 bytes): rgb2luv.init[4] := fxp(-0.147000);
	<.main+?>: load.f64 -0.147000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:50: (23 bytes): rgb2luv.init[5] := fxp(-0.289000);
	<.main+?>: load.f64 -0.289000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:50: (23 bytes): rgb2luv.init[6] := fxp(0.437000);
	<.main+?>: load.f64 0.437000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:50: (5 bytes): rgb2luv.init[7] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:51: (23 bytes): rgb2luv.init[8] := fxp(0.615000);
	<.main+?>: load.f64 0.615000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:51: (23 bytes): rgb2luv.init[9] := fxp(-0.515000);
	<.main+?>: load.f64 -0.515000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:51: (23 bytes): rgb2luv.init[10] := fxp(-0.100000);
	<.main+?>: load.f64 -0.100000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:51: (5 bytes): rgb2luv.init[11] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:53: (220 bytes): static const luv2rgb: int32[] := {...}
	cmplGfx/lib/color.lookup.ci:53: (14 bytes): luv2rgb := luv2rgb.init
	<.main+?>: load.c32 12
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;colorMap.luv2rgb
	cmplGfx/lib/color.lookup.ci:54: (23 bytes): luv2rgb.init[0] := fxp(1);
	<.main+?>: load.f64 1.000000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:54: (15 bytes): luv2rgb.init[1] := fxp(0.000000);
	<.main+?>: load.z64
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:54: (23 bytes): luv2rgb.init[2] := fxp(1.140000);
	<.main+?>: load.f64 1.140000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:54: (5 bytes): luv2rgb.init[3] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:55: (23 bytes): luv2rgb.init[4] := fxp(1);
	<.main+?>: load.f64 1.000000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:55: (23 bytes): luv2rgb.init[5] := fxp(-0.394000);
	<.main+?>: load.f64 -0.394000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:55: (23 bytes): luv2rgb.init[6] := fxp(-0.581000);
	<.main+?>: load.f64 -0.581000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:55: (5 bytes): luv2rgb.init[7] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:56: (23 bytes): luv2rgb.init[8] := fxp(1);
	<.main+?>: load.f64 1.000000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:56: (23 bytes): luv2rgb.init[9] := fxp(2.028000);
	<.main+?>: load.f64 2.028000
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:56: (15 bytes): luv2rgb.init[10] := fxp(0.000000);
	<.main+?>: load.z64
	<.main+?>: load.c32 1
	<.main+?>: b32.shl 0x10
	<.main+?>: i32.2f64
	<.main+?>: mul.f64
	<.main+?>: f64.2i32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/color.lookup.ci:56: (5 bytes): luv2rgb.init[11] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?>
	cmplGfx/lib/window.ci:84: (8 bytes): static const start: int64 := System.millis()
	<.main+?>: nfc(20) ;System.millis(): int64
	<.main+?>: store.m64 <?> ;Window.show.start
	cmplGfx/lib/window.ci:207: (5 bytes): static ox: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Window.show.onEvent.ox
	cmplGfx/lib/window.ci:208: (5 bytes): static oy: int32 := 0
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Window.show.onEvent.oy
	cmplGfx/lib/window.ci:209: (15 bytes): static const slow: float32 := (1) / 100.000000
	<.main+?>: load.f32 1.000000
	<.main+?>: load.f32 100.000000
	<.main+?>: div.f32
	<.main+?>: store.m32 <?> ;Window.show.onEvent.slow
	cmplGfx/lib/window.ci:210: (15 bytes): static const fast: float32 := (5) / 100.000000
	<.main+?>: load.f32 5.000000
	<.main+?>: load.f32 100.000000
	<.main+?>: div.f32
	<.main+?>: store.m32 <?> ;Window.show.onEvent.fast
	cmplGfx/lib/micro.ui.core.ci:4: (9 bytes): static const dark: argb := argb(1710618)
	<.main+?>: load.c32 1710618
	<.main+?>: store.m32 <?> ;Style.dark
	cmplGfx/lib/micro.ui.core.ci:6: (9 bytes): static const light: argb := argb(14342874)
	<.main+?>: load.c32 14342874
	<.main+?>: store.m32 <?> ;Style.light
	cmplGfx/lib/micro.ui.core.ci:9: (139 bytes): static const blue: argb := argb(33, 149, 246)
	<.main+?>: load.c32 33
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 149
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 246
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: store.m32 <?> ;Style.blue
	cmplGfx/lib/micro.ui.core.ci:11: (139 bytes): static const green: argb := argb(74, 174, 82)
	<.main+?>: load.c32 74
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 174
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 82
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: store.m32 <?> ;Style.green
	cmplGfx/lib/micro.ui.core.ci:13: (139 bytes): static const gray: argb := argb(98, 125, 139)
	<.main+?>: load.c32 98
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 125
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 139
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: store.m32 <?> ;Style.gray
	cmplGfx/lib/micro.ui.core.ci:15: (135 bytes): static const orange: argb := argb(255, 153, 0)
	<.main+?>: load.c32 255
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 153
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: store.m32 <?> ;Style.orange
	cmplGfx/lib/micro.ui.core.ci:17: (139 bytes): static const red: argb := argb(246, 64, 49)
	<.main+?>: load.c32 246
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 64
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 49
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: store.m32 <?> ;Style.red
	cmplGfx/lib/micro.ui.core.ci:19: (139 bytes): static const magenta: argb := argb(156, 36, 181)
	<.main+?>: load.c32 156
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 36
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 181
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: store.m32 <?> ;Style.magenta
	cmplGfx/lib/micro.ui.core.ci:21: (135 bytes): static const cyan: argb := argb(0, 149, 139)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 149
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 139
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: store.m32 <?> ;Style.cyan
	cmplGfx/lib/micro.ui.core.ci:23: (8 bytes): static const theme: argb := dark
	<.main+?>: load.m32 <?> ;Style.dark
	<.main+?>: store.m32 <?> ;Style.theme
	cmplGfx/lib/micro.ui.core.ci:24: (8 bytes): static const accent: argb := gray
	<.main+?>: load.m32 <?> ;Style.gray
	<.main+?>: store.m32 <?> ;Style.accent
	cmplGfx/lib/micro.ui.core.ci:382: (9 bytes): static focus(view: View): void := focus
	<.main+?>: load.ref <?> ;focus(view: View): void
	<.main+?>: store.m32 <?> ;focus(view: View): void
	cmplGfx/lib/micro.ui.core.ci:383: (9 bytes): static invalidate(view: View, layout: bool): void := invalidate
	<.main+?>: load.ref <?> ;invalidate(view: View, layout: bool): void
	<.main+?>: store.m32 <?> ;invalidate(view: View, layout: bool): void
	cmplGfx/lib/micro.ui.ci:21: (32 bytes): static const onOff: char[*][] := {...}
	cmplGfx/lib/micro.ui.ci:21: (14 bytes): onOff := onOff.init
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;Switch.onOff
	cmplGfx/lib/micro.ui.ci:22: (9 bytes): onOff.init[0] := ("off");
	<.main+?>: load.ref <?> ;"off"
	<.main+?>: store.m32 <?>
	cmplGfx/lib/micro.ui.ci:23: (9 bytes): onOff.init[1] := ("on");
	<.main+?>: load.ref <?> ;"on"
	<.main+?>: store.m32 <?>
	cmplGfx/lib/micro.ui.ci:994: (597 bytes): static const style: Style := {...}
	cmplGfx/lib/micro.ui.ci:995: (9 bytes): style.format.precision := 2;
	<.main+?>: load.c32 2
	<.main+?>: store.m32 <?> ;Widget.style+24
	cmplGfx/lib/micro.ui.ci:995: (7 bytes): style.format.trimDecimal := false;
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;Widget.style+28
	<.main+?>: store.i8
	:: (7 bytes): style.format.sign := (0);
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;Widget.style+16
	<.main+?>: store.i8
	:: (7 bytes): style.format.padChr := (0);
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;Widget.style+17
	<.main+?>: store.i8
	:: (5 bytes): style.format.width := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Widget.style+20
	:: (5 bytes): style.align := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Widget.style
	:: (9 bytes): style.padding := 8;
	<.main+?>: load.c32 8
	<.main+?>: store.m32 <?> ;Widget.style+4
	:: (8 bytes): style.font := Window.font;
	<.main+?>: nfc(132) ;Window.font
	<.main+?>: store.m64 <?> ;Widget.style+8
	:: (8 bytes): style.backgroundColor := uint32(theme);
	<.main+?>: load.m32 <?> ;Style.theme
	<.main+?>: store.m32 <?> ;Widget.style+32
	:: (227 bytes): style.hoveredColor := uint32(mix_rgb8(16, theme, accent));
	<.main+?>: load.c32 16
	<.main+?>: load.m32 <?> ;Style.theme
	<.main+?>: load.m32 <?> ;Style.accent
	<.main+?>: dup.x32 sp(1)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: mov.x32 sp(3, 0)
	<.main+?>: inc.sp(-12)
	<.main+?>: store.m32 <?> ;Widget.style+36
	:: (227 bytes): style.focusedColor := uint32(mix_rgb8(64, theme, accent));
	<.main+?>: load.c32 64
	<.main+?>: load.m32 <?> ;Style.theme
	<.main+?>: load.m32 <?> ;Style.accent
	<.main+?>: dup.x32 sp(1)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: mov.x32 sp(3, 0)
	<.main+?>: inc.sp(-12)
	<.main+?>: store.m32 <?> ;Widget.style+40
	:: (8 bytes): style.valueColor := uint32(accent);
	<.main+?>: load.m32 <?> ;Style.accent
	<.main+?>: store.m32 <?> ;Widget.style+44
	:: (70 bytes): style.textColor := uint32(lum(theme) > 127 ? dark : light);
	<.main+?>: load.m32 <?> ;Style.theme
	<.main+?>: load.c32 19595
	<.main+?>: dup.x32 sp(1)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: mul.i32
	<.main+?>: load.c32 38470
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: load.c32 7471
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.and 0xff
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: b32.sar 0x10
	<.main+?>: set.x32 sp(1)
	<.main+?>: load.c32 127
	<.main+?>: cgt.i32
	<.main+?>: jz +12
	<.main+?>: load.m32 <?> ;Style.dark
	<.main+?>: jmp +8
	<.main+?>: load.m32 <?> ;Style.light
	<.main+?>: store.m32 <?> ;Widget.style+48
	cmplGfx/lib/micro.ui.ci:1001: (601 bytes): static const style: Style := {...}
	cmplGfx/lib/micro.ui.ci:1002: (9 bytes): style.align := Style.left;
	<.main+?>: load.c32 2
	<.main+?>: store.m32 <?> ;FxWidget.style
	cmplGfx/lib/micro.ui.ci:1003: (9 bytes): style.format.precision := 2;
	<.main+?>: load.c32 2
	<.main+?>: store.m32 <?> ;FxWidget.style+24
	cmplGfx/lib/micro.ui.ci:1003: (7 bytes): style.format.trimDecimal := false;
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;FxWidget.style+28
	<.main+?>: store.i8
	:: (7 bytes): style.format.sign := (0);
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;FxWidget.style+16
	<.main+?>: store.i8
	:: (7 bytes): style.format.padChr := (0);
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;FxWidget.style+17
	<.main+?>: store.i8
	:: (5 bytes): style.format.width := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;FxWidget.style+20
	:: (9 bytes): style.padding := 8;
	<.main+?>: load.c32 8
	<.main+?>: store.m32 <?> ;FxWidget.style+4
	:: (8 bytes): style.font := Window.font;
	<.main+?>: nfc(132) ;Window.font
	<.main+?>: store.m64 <?> ;FxWidget.style+8
	:: (8 bytes): style.backgroundColor := uint32(theme);
	<.main+?>: load.m32 <?> ;Style.theme
	<.main+?>: store.m32 <?> ;FxWidget.style+32
	:: (227 bytes): style.hoveredColor := uint32(mix_rgb8(16, theme, accent));
	<.main+?>: load.c32 16
	<.main+?>: load.m32 <?> ;Style.theme
	<.main+?>: load.m32 <?> ;Style.accent
	<.main+?>: dup.x32 sp(1)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: mov.x32 sp(3, 0)
	<.main+?>: inc.sp(-12)
	<.main+?>: store.m32 <?> ;FxWidget.style+36
	:: (227 bytes): style.focusedColor := uint32(mix_rgb8(64, theme, accent));
	<.main+?>: load.c32 64
	<.main+?>: load.m32 <?> ;Style.theme
	<.main+?>: load.m32 <?> ;Style.accent
	<.main+?>: dup.x32 sp(1)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: b32.shl 0x08
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: b32.shl 0x08
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: b32.and 0xff
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.i32
	<.main+?>: inc.i32(+1)
	<.main+?>: mul.i32
	<.main+?>: b32.sar 0x08
	<.main+?>: add.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 255
	<.main+?>: cgt.i32
	<.main+?>: jz +13
	<.main+?>: load.c32 255
	<.main+?>: jmp +19
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.i32
	<.main+?>: jz +9
	<.main+?>: load.z32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: or.b32
	<.main+?>: mov.x32 sp(3, 0)
	<.main+?>: inc.sp(-12)
	<.main+?>: store.m32 <?> ;FxWidget.style+40
	:: (8 bytes): style.valueColor := uint32(accent);
	<.main+?>: load.m32 <?> ;Style.accent
	<.main+?>: store.m32 <?> ;FxWidget.style+44
	:: (70 bytes): style.textColor := uint32(lum(theme) > 127 ? dark : light);
	<.main+?>: load.m32 <?> ;Style.theme
	<.main+?>: load.c32 19595
	<.main+?>: dup.x32 sp(1)
	<.main+?>: b32.shr 0x10
	<.main+?>: b32.and 0xff
	<.main+?>: mul.i32
	<.main+?>: load.c32 38470
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shr 0x08
	<.main+?>: b32.and 0xff
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: load.c32 7471
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.and 0xff
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: b32.sar 0x10
	<.main+?>: set.x32 sp(1)
	<.main+?>: load.c32 127
	<.main+?>: cgt.i32
	<.main+?>: jz +12
	<.main+?>: load.m32 <?> ;Style.dark
	<.main+?>: jmp +8
	<.main+?>: load.m32 <?> ;Style.light
	<.main+?>: store.m32 <?> ;FxWidget.style+48
	cmplStd/test/lang/init.reference.ci:7: (13 bytes): static value: int64 := 42
	<.main+?>: load.c64 42
	<.main+?>: store.m64 <?> ;value
	cmplStd/test/lang/init.member.ci:34: (5 bytes): static global: int32
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;RecordMemberTest.global
	cmplStd/test/lang/init.member.ci:37: (9 bytes): static globalInit: int32 := 1
	<.main+?>: load.c32 1
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalInit
	cmplStd/test/lang/init.member.ci:40: (9 bytes): static const globalConstant: int32 := 2
	<.main+?>: load.c32 2
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalConstant
	cmplStd/test/lang/init.member.ci:43: (14 bytes): static globalRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:43: (9 bytes): globalRec.constant := 4;
	<.main+?>: load.c32 4
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalRec+4
	:: (5 bytes): globalRec.member := (0);
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalRec
	cmplStd/test/lang/init.member.ci:46: (18 bytes): static globalRecInit: Inner := {...}
	cmplStd/test/lang/init.member.ci:46: (9 bytes): globalRecInit.member := 4;
	<.main+?>: load.c32 4
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalRecInit
	cmplStd/test/lang/init.member.ci:46: (9 bytes): globalRecInit.constant := 5;
	<.main+?>: load.c32 5
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalRecInit+4
	cmplStd/test/lang/init.member.ci:49: (18 bytes): static const globalConstantRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:49: (9 bytes): globalConstantRec.member := 6;
	<.main+?>: load.c32 6
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalConstantRec
	cmplStd/test/lang/init.member.ci:49: (9 bytes): globalConstantRec.constant := 7;
	<.main+?>: load.c32 7
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalConstantRec+4
	cmplStd/test/lang/init.method.ci:18: (9 bytes): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+?>: load.ref <?> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: store.m32 <?> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	cmplStd/test/lang/emit.ci:3: (1 byte): emitldz32: int32 := emit(load.z32)
	<.main+?>: load.z32
	cmplStd/test/lang/emit.ci:4: (1 byte): emitldz64: int64 := emit(load.z64)
	<.main+?>: load.z64
	cmplStd/test/lang/emit.ci:6: (5 bytes): emitA: int32 := 42
	<.main+?>: load.c32 42
	cmplStd/test/lang/emit.ci:7: (5 bytes): emitB: int32 := 96
	<.main+?>: load.c32 96
	cmplStd/test/lang/emit.ci:10: (5 bytes): emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: add.i32
	cmplStd/test/lang/emit.ci:13: (11 bytes): emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	<.main+?>: load.c32 10
	<.main+?>: load.c32 5
	<.main+?>: div.i32
	cmplStd/test/lang/emit.ci:16: (15 bytes): emitNfcF32: float32 := emit(float32(3.140000), float32(2), div.f32, float32.sin)
	<.main+?>: load.f32 3.140000
	<.main+?>: load.f32 2.000000
	<.main+?>: div.f32
	<.main+?>: nfc(34) ;float32.sin(x: float32): float32
	cmplStd/test/lang/emit.ci:23: (5 bytes): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+?>: load.f32 500.000000
	cmplStd/test/lang/emit.ci:24: (6 bytes): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+?>: load.f32 500.000000
	<.main+?>: i32.2i64
	cmplStd/test/lang/emit.ci:25: (10 bytes): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+?>: load.f64 500.000000
	<.main+?>: i64.2i32
	cmplStd/test/lang/emit.ci:26: (9 bytes): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+?>: load.f64 500.000000
	cmplStd/test/lang/emit.ci:30: (10 bytes): emitSlice: char[] := emit(int32(3), pointer("string"))
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"string"
	cmplStd/test/lang/inlineMacros.ci:10: (5 bytes): i3: int32 := 3
	<.main+?>: load.c32 3
	cmplStd/test/lang/inlineMacros.ci:11: (5 bytes): i6: int32 := 6
	<.main+?>: load.c32 6
	cmplStd/test/lang/inlineMacros.ci:12: (5 bytes): i2: int32 := 2
	<.main+?>: load.c32 2
	cmplStd/test/lang/inlineMacros.ci:13: (5 bytes): i8: int32 := 8
	<.main+?>: load.c32 8
	cmplStd/test/lang/inlineMacros.ci:15: (1 byte): zeroVal: int32 := zero(3, 6)
	<.main+?>: load.z32
	cmplStd/test/lang/inlineMacros.ci:16: (1 byte): zeroVar: int32 := zero(i3, i6)
	<.main+?>: load.z32
	cmplStd/test/lang/inlineMacros.ci:17: (1 byte): zeroXpr: int32 := zero(i3 + 1, i6 + 1)
	<.main+?>: load.z32
	cmplStd/test/lang/inlineMacros.ci:19: (5 bytes): lastVal: int32 := last(3, 6)
	<.main+?>: load.c32 6
	cmplStd/test/lang/inlineMacros.ci:20: (2 bytes): lastVar: int32 := last(i3, i6)
	<.main+?>: dup.x32 sp(6)
	cmplStd/test/lang/inlineMacros.ci:21: (10 bytes): lastXpr: int32 := last(i3 + 1, i6 + 1) - 1
	<.main+?>: dup.x32 sp(7)
	<.main+?>: inc.i32(+1)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:23: (9 bytes): sum2Val: int32 := sum(3, 6)
	<.main+?>: load.c32 3
	<.main+?>: inc.i32(+6)
	cmplStd/test/lang/inlineMacros.ci:24: (5 bytes): sum2Var: int32 := sum(i3, i6)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: add.i32
	cmplStd/test/lang/inlineMacros.ci:25: (17 bytes): sum2Xpr: int32 := sum(i3 + 1, i6 + 1) - 2
	<.main+?>: dup.x32 sp(11)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(11)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: inc.i32(-2)
	cmplStd/test/lang/inlineMacros.ci:27: (24 bytes): any2Val: int32 := any(3, 6)
	<.main+?>: load.c32 3
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 6
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:28: (18 bytes): any2Var: int32 := any(i3, i6)
	<.main+?>: dup.x32 sp(13)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(13)
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:29: (30 bytes): any2Xpr: int32 := any(i3 + 1, i6 + 1) - 1
	<.main+?>: dup.x32 sp(14)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(14)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:31: (34 bytes): min2Val: int32 := min(3, 6)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:32: (28 bytes): min2Var: int32 := min(i3, i6)
	<.main+?>: dup.x32 sp(16)
	<.main+?>: dup.x32 sp(16)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:33: (40 bytes): min2Xpr: int32 := min(i3 + 1, i6 + 1) - 1
	<.main+?>: dup.x32 sp(17)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(17)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:35: (34 bytes): max2Val: int32 := max(3, 6)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:36: (28 bytes): max2Var: int32 := max(i3, i6)
	<.main+?>: dup.x32 sp(19)
	<.main+?>: dup.x32 sp(19)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:37: (40 bytes): max2Xpr: int32 := max(i3 + 1, i6 + 1) - 1
	<.main+?>: dup.x32 sp(20)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(20)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:41: (21 bytes): sumRlVal: int32 := sumLr(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: load.c32 2
	<.main+?>: inc.i32(+8)
	<.main+?>: add.i32
	<.main+?>: add.i32
	cmplStd/test/lang/inlineMacros.ci:42: (17 bytes): sumLrVal: int32 := sumRl(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: inc.i32(+6)
	<.main+?>: inc.i32(+2)
	<.main+?>: inc.i32(+8)
	cmplStd/test/lang/inlineMacros.ci:43: (11 bytes): sumRlVar: int32 := sumLr(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(23)
	<.main+?>: dup.x32 sp(23)
	<.main+?>: dup.x32 sp(23)
	<.main+?>: dup.x32 sp(23)
	<.main+?>: add.i32
	<.main+?>: add.i32
	<.main+?>: add.i32
	cmplStd/test/lang/inlineMacros.ci:44: (11 bytes): sumLrVar: int32 := sumRl(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(24)
	<.main+?>: dup.x32 sp(24)
	<.main+?>: add.i32
	<.main+?>: dup.x32 sp(23)
	<.main+?>: add.i32
	<.main+?>: dup.x32 sp(22)
	<.main+?>: add.i32
	cmplStd/test/lang/inlineMacros.ci:45: (31 bytes): sumRlXpr: int32 := sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: add.i32
	<.main+?>: add.i32
	<.main+?>: inc.i32(-4)
	cmplStd/test/lang/inlineMacros.ci:46: (31 bytes): sumLrXpr: int32 := sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+?>: dup.x32 sp(26)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(26)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: dup.x32 sp(24)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: inc.i32(-4)
	cmplStd/test/lang/inlineMacros.ci:50: (62 bytes): anyRlVal: int32 := anyLr(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +47
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +28
	<.main+?>: load.c32 2
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 8
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:51: (62 bytes): anyLrVal: int32 := anyRl(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 6
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 2
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 8
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:52: (50 bytes): anyRlVar: int32 := anyLr(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(29)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +38
	<.main+?>: dup.x32 sp(29)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +22
	<.main+?>: dup.x32 sp(29)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(29)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:53: (50 bytes): anyLrVar: int32 := anyRl(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(30)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(30)
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(29)
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(28)
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:54: (70 bytes): anyRlXpr: int32 := anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +50
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +30
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:55: (70 bytes): anyLrXpr: int32 := anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(32)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(32)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(30)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:59: (92 bytes): minRlVal: int32 := minLr(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: load.c32 2
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:60: (92 bytes): minLrVal: int32 := minRl(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.c32 2
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:61: (80 bytes): minRlVar: int32 := minLr(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:62: (80 bytes): minLrVar: int32 := minRl(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(36)
	<.main+?>: dup.x32 sp(36)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(34)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:63: (100 bytes): minRlXpr: int32 := minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:64: (100 bytes): minLrXpr: int32 := minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(38)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(38)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(36)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:68: (92 bytes): maxRlVal: int32 := maxLr(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: load.c32 2
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:69: (92 bytes): maxLrVal: int32 := maxRl(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.c32 2
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:70: (80 bytes): maxRlVar: int32 := maxLr(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:71: (80 bytes): maxLrVar: int32 := maxRl(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(40)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:72: (100 bytes): maxRlXpr: int32 := maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:73: (100 bytes): maxLrXpr: int32 := maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(44)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(44)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/overload.inline.ci:9: (5 bytes): overload1: float32 := overload
	<.main+?>: load.f32 1.000000
	cmplStd/test/lang/overload.inline.ci:10: (5 bytes): overload2: float32 := overload()
	<.main+?>: load.f32 2.000000
	cmplStd/test/lang/overload.inline.ci:11: (5 bytes): overload3: float32 := overload(0)
	<.main+?>: load.f32 3.000000
	cmplStd/test/lang/overload.inline.ci:12: (5 bytes): overload4: float32 := overload(0.000000)
	<.main+?>: load.f32 4.000000
	cmplStd/test/lang/overload.inline.ci:13: (5 bytes): overload5: float32 := overload(0, 0)
	<.main+?>: load.f32 5.000000
	cmplStd/test/lang/overload.inline.ci:28: (9 bytes): boilC: Celsius := Celsius(100.000000)
	<.main+?>: load.f64 100.000000
	cmplStd/test/lang/overload.inline.ci:29: (22 bytes): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.f64 1.800000
	<.main+?>: mul.f64
	<.main+?>: load.f64 32.000000
	<.main+?>: add.f64
	cmplStd/test/lang/memory.ci:7: (14 bytes): p1: pointer := malloc(1024)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.c32 1024
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/test/lang/memory.ci:8: (14 bytes): p2: pointer := malloc(80)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.c32 80
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/test/lang/memory.ci:9: (14 bytes): p3: pointer := malloc(160)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.c32 160
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/test/lang/memory.ci:10: (14 bytes): p4: pointer := malloc(820)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.c32 820
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/test/lang/memory.ci:13: (16 bytes): pointer.fill(p1, 0, 1024);
	<.main+?>: dup.x32 sp(3)
	<.main+?>: load.z32
	<.main+?>: load.c32 1024
	<.main+?>: nfc(14) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:14: (17 bytes): pointer.copy(p1, p3, 160);
	<.main+?>: dup.x32 sp(3)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: load.c32 160
	<.main+?>: nfc(15) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:17: (11 bytes): free(p1);
	<.main+?>: dup.x32 sp(3)
	<.main+?>: load.z32
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:18: (11 bytes): free(p2);
	<.main+?>: dup.x32 sp(2)
	<.main+?>: load.z32
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:19: (11 bytes): free(p3);
	<.main+?>: dup.x32 sp(1)
	<.main+?>: load.z32
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:20: (11 bytes): free(p4);
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:23: (9 bytes): val1: int64 := 42
	<.main+?>: load.c64 42
	cmplStd/test/lang/memory.ci:24: (9 bytes): val2: int64 := 96
	<.main+?>: load.c64 96
	cmplStd/test/lang/memory.ci:26: (49 bytes): debug("val1", val1);
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.sp(+12)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/memory.ci"
	<.main+?>: load.c32 26
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"val1"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/memory.ci:27: (49 bytes): debug("val2", val2);
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/memory.ci"
	<.main+?>: load.c32 27
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"val2"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/memory.ci:29: (25 bytes): pointer.move(pointer(val2), pointer(val1), sizeof(int64));
	<.main+?>: load.sp(+0)
	<.main+?>: load.sp(+12)
	<.main+?>: load.ref <?> ;int64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: nfc(16) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:30: (22 bytes): pointer.fill(pointer(val1), 0, sizeof(int64));
	<.main+?>: load.sp(+8)
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;int64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: nfc(14) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:32: (49 bytes): debug("val1", val1);
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.sp(+12)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/memory.ci"
	<.main+?>: load.c32 32
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"val1"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/memory.ci:33: (49 bytes): debug("val2", val2);
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/memory.ci"
	<.main+?>: load.c32 33
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"val2"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/tryExec.ci:39: (14 bytes): tryExecErr0: int32 := tryExec(null, noError)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;noError(ptr: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:40: (14 bytes): tryExecErr1: int32 := tryExec(null, null)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;null
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:41: (14 bytes): tryExecErr2: int32 := tryExec(null, stackOverflow)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;stackOverflow(ptr: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:42: (14 bytes): tryExecErr3: int32 := tryExec(null, divisionByZero)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;divisionByZero(args: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:43: (14 bytes): tryExecErr4: int32 := tryExec(null, invalidInstruction)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;invalidInstruction(args: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:44: (14 bytes): tryExecErr5: int32 := tryExec(null, invalidMemoryAccess)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;invalidMemoryAccess(args: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:45: (14 bytes): tryExecErr6: int32 := tryExec(null, abortExecution)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;abortExecution(args: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/pointer.ci:1: (39 bytes): arr: int32[5] := {...}
	<.main+?>: inc.sp(+20)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[0] := 1;
	<.main+?>: load.c32 1
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[1] := 2;
	<.main+?>: load.c32 2
	<.main+?>: set.x32 sp(2)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[2] := 3;
	<.main+?>: load.c32 3
	<.main+?>: set.x32 sp(3)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[3] := 4;
	<.main+?>: load.c32 4
	<.main+?>: set.x32 sp(4)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[4] := 5;
	<.main+?>: load.c32 5
	<.main+?>: set.x32 sp(5)
	cmplStd/test/lang/pointer.ci:2: (4 bytes): ptr: pointer := arr
	<.main+?>: load.sp(+0)
	cmplStd/test/lang/pointer.ci:3: (4 bytes): a0: int32 := arr[0]
	<.main+?>: load.sp(+4)
	cmplStd/test/lang/pointer.ci:4: (4 bytes): a1: int32 := arr[1]
	<.main+?>: load.sp(+12)
	cmplStd/test/lang/pointer.ci:5: (4 bytes): a2: int32 := arr[2]
	<.main+?>: load.sp(+20)
	cmplStd/test/lang/pointer.ci:6: (4 bytes): a3: int32 := arr[3]
	<.main+?>: load.sp(+28)
	cmplStd/test/lang/pointer.ci:7: (4 bytes): a4: int32 := arr[4]
	<.main+?>: load.sp(+36)
	cmplStd/test/lang/pointer.ci:9: (55 bytes): assert((ptr) == arr);
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: load.sp(+36)
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 9
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:10: (65 bytes): assert(pointer(a0) == inc(ptr, 0 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(6)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 10
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:11: (69 bytes): assert(pointer(a1) == inc(ptr, 1 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 1
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 11
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:12: (69 bytes): assert(pointer(a2) == inc(ptr, 2 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 12
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:13: (69 bytes): assert(pointer(a3) == inc(ptr, 3 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 13
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:14: (69 bytes): assert(pointer(a4) == inc(ptr, 4 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 4
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 14
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/init.reference.ci:8: (5 bytes): valueRef: int64 := value
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:9: (5 bytes): valuePtr: pointer := value
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:10: (10 bytes): valueVar: variant := value
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:12: (3 bytes): fromRef: int64 := valueRef
	<.main+?>: dup.x32 sp(3)
	<.main+?>: load.i64
	cmplStd/test/lang/init.reference.ci:13: (2 bytes): fromPtr: int64 := valuePtr
	<.main+?>: dup.x32 sp(4)
	cmplStd/test/lang/init.reference.ci:14: (2 bytes): fromVar: int64 := valueVar
	<.main+?>: dup.x32 sp(3)
	cmplStd/test/lang/init.reference.ci:16: (5 bytes): nullRef: int64 := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:17: (5 bytes): nullPtr: pointer := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:18: (10 bytes): nullVar: variant := null
	<.main+?>: load.ref <?> ;pointer
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:19: (5 bytes): nullTyp: typename := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:20: (5 bytes): nullFun: function := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:21: (5 bytes): nullObj: object := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:23: (5 bytes): typePtr: pointer := int64
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:24: (10 bytes): typeVar: variant := int64
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:25: (5 bytes): typeTyp: typename := int64
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:27: (4 bytes): local: int64 := value
	<.main+?>: load.m64 <?> ;value
	cmplStd/test/lang/init.reference.ci:28: (2 bytes): copyVal: int64 := local
	<.main+?>: dup.x64 sp(0)
	cmplStd/test/lang/init.reference.ci:29: (2 bytes): copyRef: int64 := valueRef
	<.main+?>: dup.x32 sp(22)
	cmplStd/test/lang/init.reference.ci:30: (2 bytes): copyPtr: pointer := valuePtr
	<.main+?>: dup.x32 sp(22)
	cmplStd/test/lang/init.reference.ci:31: (2 bytes): copyVar: variant := valueVar
	<.main+?>: dup.x64 sp(21)
	cmplStd/test/lang/init.reference.ci:32: (2 bytes): copyTyp: typename := typeTyp
	<.main+?>: dup.x32 sp(8)
	cmplStd/test/lang/init.reference.ci:35: (5 bytes): ptrVoid: pointer := void
	<.main+?>: load.ref <?> ;void
	cmplStd/test/lang/init.reference.ci:36: (5 bytes): ptrBool: pointer := bool
	<.main+?>: load.ref <?> ;bool
	cmplStd/test/lang/init.reference.ci:37: (5 bytes): ptrChar: pointer := char
	<.main+?>: load.ref <?> ;char
	cmplStd/test/lang/init.reference.ci:38: (5 bytes): ptrInt8: pointer := int8
	<.main+?>: load.ref <?> ;int8
	cmplStd/test/lang/init.reference.ci:39: (5 bytes): ptrInt16: pointer := int16
	<.main+?>: load.ref <?> ;int16
	cmplStd/test/lang/init.reference.ci:40: (5 bytes): ptrInt32: pointer := int32
	<.main+?>: load.ref <?> ;int32
	cmplStd/test/lang/init.reference.ci:41: (5 bytes): ptrInt64: pointer := int64
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:42: (5 bytes): ptrUint8: pointer := uint8
	<.main+?>: load.ref <?> ;uint8
	cmplStd/test/lang/init.reference.ci:43: (5 bytes): ptrUint16: pointer := uint16
	<.main+?>: load.ref <?> ;uint16
	cmplStd/test/lang/init.reference.ci:44: (5 bytes): ptrUint32: pointer := uint32
	<.main+?>: load.ref <?> ;uint32
	cmplStd/test/lang/init.reference.ci:45: (5 bytes): ptrUint64: pointer := uint64
	<.main+?>: load.ref <?> ;uint64
	cmplStd/test/lang/init.reference.ci:46: (5 bytes): ptrFloat32: pointer := float32
	<.main+?>: load.ref <?> ;float32
	cmplStd/test/lang/init.reference.ci:47: (5 bytes): ptrFloat64: pointer := float64
	<.main+?>: load.ref <?> ;float64
	cmplStd/test/lang/init.reference.ci:48: (5 bytes): ptrTypename: pointer := typename
	<.main+?>: load.ref <?> ;typename
	cmplStd/test/lang/init.reference.ci:49: (5 bytes): ptrFunction: pointer := function
	<.main+?>: load.ref <?> ;function
	cmplStd/test/lang/init.reference.ci:50: (5 bytes): ptrPointer: pointer := pointer
	<.main+?>: load.ref <?> ;pointer
	cmplStd/test/lang/init.reference.ci:51: (5 bytes): ptrVariant: pointer := variant
	<.main+?>: load.ref <?> ;variant
	cmplStd/test/lang/init.reference.ci:52: (5 bytes): ptrObject: pointer := object
	<.main+?>: load.ref <?> ;object
	cmplStd/test/lang/init.reference.ci:55: (10 bytes): varVoid: variant := void
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;void
	cmplStd/test/lang/init.reference.ci:56: (10 bytes): varBool: variant := bool
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;bool
	cmplStd/test/lang/init.reference.ci:57: (10 bytes): varChar: variant := char
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;char
	cmplStd/test/lang/init.reference.ci:58: (10 bytes): varInt8: variant := int8
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int8
	cmplStd/test/lang/init.reference.ci:59: (10 bytes): varInt16: variant := int16
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int16
	cmplStd/test/lang/init.reference.ci:60: (10 bytes): varInt32: variant := int32
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int32
	cmplStd/test/lang/init.reference.ci:61: (10 bytes): varInt64: variant := int64
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:62: (10 bytes): varUint8: variant := uint8
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;uint8
	cmplStd/test/lang/init.reference.ci:63: (10 bytes): varUint16: variant := uint16
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;uint16
	cmplStd/test/lang/init.reference.ci:64: (10 bytes): varUint32: variant := uint32
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;uint32
	cmplStd/test/lang/init.reference.ci:65: (10 bytes): varUint64: variant := uint64
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;uint64
	cmplStd/test/lang/init.reference.ci:66: (10 bytes): varFloat32: variant := float32
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;float32
	cmplStd/test/lang/init.reference.ci:67: (10 bytes): varFloat64: variant := float64
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;float64
	cmplStd/test/lang/init.reference.ci:68: (10 bytes): varTypename: variant := typename
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;typename
	cmplStd/test/lang/init.reference.ci:69: (10 bytes): varFunction: variant := function
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;function
	cmplStd/test/lang/init.reference.ci:70: (10 bytes): varPointer: variant := pointer
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;pointer
	cmplStd/test/lang/init.reference.ci:71: (10 bytes): varVariant: variant := variant
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;variant
	cmplStd/test/lang/init.reference.ci:72: (10 bytes): varObject: variant := object
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;object
	cmplStd/test/lang/init.reference.ci:75: (5 bytes): typVoid: typename := void
	<.main+?>: load.ref <?> ;void
	cmplStd/test/lang/init.reference.ci:76: (5 bytes): typBool: typename := bool
	<.main+?>: load.ref <?> ;bool
	cmplStd/test/lang/init.reference.ci:77: (5 bytes): typChar: typename := char
	<.main+?>: load.ref <?> ;char
	cmplStd/test/lang/init.reference.ci:78: (5 bytes): typInt8: typename := int8
	<.main+?>: load.ref <?> ;int8
	cmplStd/test/lang/init.reference.ci:79: (5 bytes): typInt16: typename := int16
	<.main+?>: load.ref <?> ;int16
	cmplStd/test/lang/init.reference.ci:80: (5 bytes): typInt32: typename := int32
	<.main+?>: load.ref <?> ;int32
	cmplStd/test/lang/init.reference.ci:81: (5 bytes): typInt64: typename := int64
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:82: (5 bytes): typUint8: typename := uint8
	<.main+?>: load.ref <?> ;uint8
	cmplStd/test/lang/init.reference.ci:83: (5 bytes): typUint16: typename := uint16
	<.main+?>: load.ref <?> ;uint16
	cmplStd/test/lang/init.reference.ci:84: (5 bytes): typUint32: typename := uint32
	<.main+?>: load.ref <?> ;uint32
	cmplStd/test/lang/init.reference.ci:85: (5 bytes): typUint64: typename := uint64
	<.main+?>: load.ref <?> ;uint64
	cmplStd/test/lang/init.reference.ci:86: (5 bytes): typFloat32: typename := float32
	<.main+?>: load.ref <?> ;float32
	cmplStd/test/lang/init.reference.ci:87: (5 bytes): typFloat64: typename := float64
	<.main+?>: load.ref <?> ;float64
	cmplStd/test/lang/init.reference.ci:88: (5 bytes): typTypename: typename := typename
	<.main+?>: load.ref <?> ;typename
	cmplStd/test/lang/init.reference.ci:89: (5 bytes): typFunction: typename := function
	<.main+?>: load.ref <?> ;function
	cmplStd/test/lang/init.reference.ci:90: (5 bytes): typPointer: typename := pointer
	<.main+?>: load.ref <?> ;pointer
	cmplStd/test/lang/init.reference.ci:91: (5 bytes): typVariant: typename := variant
	<.main+?>: load.ref <?> ;variant
	cmplStd/test/lang/init.reference.ci:92: (5 bytes): typObject: typename := object
	<.main+?>: load.ref <?> ;object
	cmplStd/test/lang/init.reference.ci:95: (5 bytes): valueOfPtr: pointer := pointer(value)
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:96: (10 bytes): valueOfVar: variant := variant(value)
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:97: (5 bytes): valueOfTyp: typename := typename(value)
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:99: (5 bytes): typeOfValue: typename := typename(value)
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:105: (7 bytes): copyPtrFloat64: variant := ptrFloat64
	<.main+?>: load.ref <?> ;pointer
	<.main+?>: dup.x32 sp(65)
	cmplStd/test/lang/init.reference.ci:108: (2 bytes): copyVarFloat64: pointer := varFloat64
	<.main+?>: dup.x32 sp(35)
	cmplStd/test/lang/init.variable.ci:3: (1 byte): variable: int32
	<.main+?>: load.z32
	cmplStd/test/lang/init.variable.ci:7: (5 bytes): const constant: int32 := 42
	<.main+?>: load.c32 42
	cmplStd/test/lang/init.variable.ci:24: (18 bytes): valInitImplicit: ComplexVal := {...}
	<.main+?>: inc.sp(+16)
	cmplStd/test/lang/init.variable.ci:24: (11 bytes): valInitImplicit.re := (8);
	<.main+?>: load.f64 8.000000
	<.main+?>: set.x64 sp(2)
	:: (3 bytes): valInitImplicit.im := (0);
	<.main+?>: load.z64
	<.main+?>: set.x64 sp(4)
	cmplStd/test/lang/init.variable.ci:33: (39 bytes): objInitImplicit: ComplexObj := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/init.variable.ci:33: (11 bytes): objInitImplicit := create(ComplexObj);
	<.main+?>: load.ref <?> ;ComplexObj
	<.main+?>: nfc(7) ;object.create(type: typename): pointer
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/init.variable.ci:33: (16 bytes): objInitImplicit.re := (8);
	<.main+?>: load.f64 8.000000
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+4)
	<.main+?>: store.i64
	:: (8 bytes): objInitImplicit.im := (0);
	<.main+?>: load.z64
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+12)
	<.main+?>: store.i64
	cmplStd/test/lang/init.variable.ci:41: (39 bytes): objInitExplicit: object := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/init.variable.ci:41: (11 bytes): objInitExplicit := create(ComplexObj);
	<.main+?>: load.ref <?> ;ComplexObj
	<.main+?>: nfc(7) ;object.create(type: typename): pointer
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/init.variable.ci:41: (16 bytes): objInitExplicit.re := (8);
	<.main+?>: load.f64 8.000000
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+4)
	<.main+?>: store.i64
	:: (8 bytes): objInitExplicit.im := (0);
	<.main+?>: load.z64
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+12)
	<.main+?>: store.i64
	cmplStd/test/lang/function.ci:12: (21 bytes): funAddResult: int32 := funAdd(2, 7)
	<.main+?>: load.z32
	<.main+?>: load.c32 2
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;funAdd(x: int32, y: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/function.ci:15: (5 bytes): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+?>: load.ref <?> ;funAdd(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:18: (18 bytes): funAddRefResult: int32 := funAddRef(2, 8)
	<.main+?>: load.z32
	<.main+?>: load.c32 2
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(3)
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/function.ci:21: (5 bytes): funMul(x: int32, y: int32): int32 := funMul
	<.main+?>: load.ref <?> ;funMul(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:24: (18 bytes): funMulResult: int32 := funMul(2, 6)
	<.main+?>: load.z32
	<.main+?>: load.c32 2
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(3)
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/function.ci:27: (2 bytes): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+?>: dup.x32 sp(1)
	cmplStd/test/lang/function.ci:30: (18 bytes): funMulRefResult: int32 := funMulRef(2, 7)
	<.main+?>: load.z32
	<.main+?>: load.c32 2
	<.main+?>: load.c32 7
	<.main+?>: dup.x32 sp(3)
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/function.ci:46: (16 bytes): fibonacci_13: uint32 := fib(13)
	<.main+?>: load.z32
	<.main+?>: load.c32 13
	<.main+?>: load.ref <?> ;fib(n: uint32): uint32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/reflect.ci:3: (9 bytes): sizeofVoid: int32 := sizeof(void)
	<.main+?>: load.ref <?> ;void
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:4: (9 bytes): sizeofBool: int32 := sizeof(bool)
	<.main+?>: load.ref <?> ;bool
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:5: (9 bytes): sizeofChar: int32 := sizeof(char)
	<.main+?>: load.ref <?> ;char
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:6: (9 bytes): sizeofInt8: int32 := sizeof(int8)
	<.main+?>: load.ref <?> ;int8
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:7: (9 bytes): sizeofInt16: int32 := sizeof(int16)
	<.main+?>: load.ref <?> ;int16
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:8: (9 bytes): sizeofInt32: int32 := sizeof(int32)
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:9: (9 bytes): sizeofInt64: int32 := sizeof(int64)
	<.main+?>: load.ref <?> ;int64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:10: (9 bytes): sizeofUint8: int32 := sizeof(uint8)
	<.main+?>: load.ref <?> ;uint8
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:11: (9 bytes): sizeofUint16: int32 := sizeof(uint16)
	<.main+?>: load.ref <?> ;uint16
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:12: (9 bytes): sizeofUint32: int32 := sizeof(uint32)
	<.main+?>: load.ref <?> ;uint32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:13: (9 bytes): sizeofUint64: int32 := sizeof(uint64)
	<.main+?>: load.ref <?> ;uint64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:14: (9 bytes): sizeofFloat32: int32 := sizeof(float32)
	<.main+?>: load.ref <?> ;float32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:15: (9 bytes): sizeofFloat64: int32 := sizeof(float64)
	<.main+?>: load.ref <?> ;float64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:16: (9 bytes): sizeofPointer: int32 := sizeof(pointer)
	<.main+?>: load.ref <?> ;pointer
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:17: (9 bytes): sizeofVariant: int32 := sizeof(variant)
	<.main+?>: load.ref <?> ;variant
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:18: (9 bytes): sizeofTypename: int32 := sizeof(typename)
	<.main+?>: load.ref <?> ;typename
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:19: (9 bytes): sizeofFunction: int32 := sizeof(function)
	<.main+?>: load.ref <?> ;function
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:20: (9 bytes): sizeofObject: int32 := sizeof(object)
	<.main+?>: load.ref <?> ;object
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:30: (5 bytes): typeofRecord: typename := RecordSizeofExt
	<.main+?>: load.ref <?> ;RecordSizeofExt
	cmplStd/test/lang/reflect.ci:31: (6 bytes): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: nfc(5) ;typename.name(type: typename): .cstr
	cmplStd/test/lang/reflect.ci:32: (7 bytes): offsetOfRecord: int32 := typeofRecord.offset
	<.main+?>: dup.x32 sp(1)
	<.main+?>: inc.i32(+56)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:33: (7 bytes): sizeOfRecord: int32 := typeofRecord.size
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+48)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:34: (6 bytes): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: nfc(3) ;typename.file(type: typename): .cstr
	cmplStd/test/lang/reflect.ci:35: (6 bytes): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: nfc(4) ;typename.line(type: typename): int32
	cmplStd/test/lang/reflect.ci:37: (6 bytes): typeofBase: typename := typename.base(typeofRecord)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: nfc(2) ;typename.base(type: typename): typename
	cmplStd/test/lang/reflect.ci:38: (6 bytes): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: nfc(5) ;typename.name(type: typename): .cstr
	cmplStd/test/lang/reflect.ci:39: (7 bytes): offsetOfBase: int32 := typeofBase.offset
	<.main+?>: dup.x32 sp(1)
	<.main+?>: inc.i32(+56)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:40: (7 bytes): sizeOfBase: int32 := typeofBase.size
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+48)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:41: (6 bytes): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: nfc(3) ;typename.file(type: typename): .cstr
	cmplStd/test/lang/reflect.ci:42: (6 bytes): lineOfBase: int32 := typename.line(typeofBase)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: nfc(4) ;typename.line(type: typename): int32
	cmplStd/test/lang/reflect.ci:44: (6 bytes): typeofBase1: typename := typename.base(typeofBase)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: nfc(2) ;typename.base(type: typename): typename
	cmplStd/test/lang/reflect.ci:45: (7 bytes): offsetOfBase1: int32 := typeofBase1.offset
	<.main+?>: dup.x32 sp(0)
	<.main+?>: inc.i32(+56)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:46: (7 bytes): sizeOfBase1: int32 := typeofBase1.size
	<.main+?>: dup.x32 sp(1)
	<.main+?>: inc.i32(+48)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:48: (6 bytes): typeofBase2: typename := typename.base(typeofBase1)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: nfc(2) ;typename.base(type: typename): typename
	cmplStd/test/lang/reflect.ci:49: (7 bytes): offsetOfBase2: int32 := typeofBase2.offset
	<.main+?>: dup.x32 sp(0)
	<.main+?>: inc.i32(+56)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:50: (7 bytes): sizeOfBase2: int32 := typeofBase2.size
	<.main+?>: dup.x32 sp(1)
	<.main+?>: inc.i32(+48)
	<.main+?>: load.i32
	cmplStd/test/lang/init.member.ci:52: (60 bytes): recordMemberTest: RecordMemberTest := {...}
	<.main+?>: inc.sp(+32)
	cmplStd/test/lang/init.member.ci:53: (7 bytes): recordMemberTest.member := 10;
	<.main+?>: load.c32 10
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/init.member.ci:54: (7 bytes): recordMemberTest.constant := 11;
	<.main+?>: load.c32 11
	<.main+?>: set.x32 sp(2)
	cmplStd/test/lang/init.member.ci:55: (7 bytes): recordMemberTest.memberInit := 12;
	<.main+?>: load.c32 12
	<.main+?>: set.x32 sp(3)
	cmplStd/test/lang/init.member.ci:56: (7 bytes): recordMemberTest.constantInit := 13;
	<.main+?>: load.c32 13
	<.main+?>: set.x32 sp(4)
	cmplStd/test/lang/init.member.ci:59: (7 bytes): recordMemberTest.memberRec.member := 14;
	<.main+?>: load.c32 14
	<.main+?>: set.x32 sp(5)
	cmplStd/test/lang/init.member.ci:60: (7 bytes): recordMemberTest.memberRec.constant := 15;
	<.main+?>: load.c32 15
	<.main+?>: set.x32 sp(6)
	cmplStd/test/lang/init.member.ci:64: (7 bytes): recordMemberTest.constantRec.member := 16;
	<.main+?>: load.c32 16
	<.main+?>: set.x32 sp(7)
	cmplStd/test/lang/init.member.ci:65: (7 bytes): recordMemberTest.constantRec.constant := 17;
	<.main+?>: load.c32 17
	<.main+?>: set.x32 sp(8)
	cmplStd/test/lang/init.method.ci:62: (24 bytes): recordMethodTest: RecordMethodTest := {...}
	<.main+?>: inc.sp(+16)
	cmplStd/test/lang/init.method.ci:64: (7 bytes): recordMethodTest.abstractMethod := globalFunction;
	<.main+?>: load.ref <?> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+?>: set.x32 sp(1)
	:: (6 bytes): recordMethodTest.delegateMethod := forwardMethod;
	<.main+?>: load.m32 <?> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: set.x32 sp(2)
	:: (7 bytes): recordMethodTest.virtualMethod := virtualMethod;
	<.main+?>: load.ref <?> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: set.x32 sp(3)
	cmplStd/test/lang/init.method.ci:78: (17 bytes): RecordMethodTest.staticMethod(recordMethodTest, 1);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 1
	<.main+?>: load.ref <?> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:79: (14 bytes): recordMethodTest.virtualMethod(recordMethodTest, 1);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 1
	<.main+?>: dup.x32 sp(7)
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:97: (17 bytes): staticMethod(recordMethodTest, 2);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:98: (17 bytes): virtualMethod(recordMethodTest, 2);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:101: (17 bytes): RecordMethodTest.staticMethod(recordMethodTest, 3);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:102: (17 bytes): RecordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:103: (14 bytes): recordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 3
	<.main+?>: dup.x32 sp(7)
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/recUnion.ci:26: (22 bytes): black: rgbU8 := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:26: (6 bytes): black.r := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+6)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:26: (6 bytes): black.g := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+5)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:26: (6 bytes): black.b := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:27: (26 bytes): green: rgbU8 := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:27: (6 bytes): green.r := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+6)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:27: (10 bytes): green.g := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+5)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:27: (6 bytes): green.b := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:28: (34 bytes): white: rgbU8 := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:28: (10 bytes): white.r := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+6)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:28: (10 bytes): white.g := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+5)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:28: (10 bytes): white.b := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+4)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:30: (11 bytes): cyan: color := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:30: (7 bytes): cyan.col := (65535);
	<.main+?>: load.c32 65535
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/recUnion.ci:31: (26 bytes): blue: color := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:31: (6 bytes): blue.rgb.r := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+6)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:31: (6 bytes): blue.rgb.g := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+5)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:31: (10 bytes): blue.rgb.b := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+4)
	<.main+?>: store.i8
	cmplStd/test/lang/useOperator.ci:5: (5 bytes): shift: int32 := 2
	<.main+?>: load.c32 2
	cmplStd/test/lang/useOperator.ci:7: (5 bytes): boolA: bool := true
	<.main+?>: load.c32 1
	cmplStd/test/lang/useOperator.ci:8: (5 bytes): boolB: bool := !false
	<.main+?>: load.c32 1
	cmplStd/test/lang/useOperator.ci:17: (11 bytes): boolAnd: bool := boolA & boolB
	<.main+?>: load.sp(+4)
	<.main+?>: load.is8
	<.main+?>: load.sp(+4)
	<.main+?>: load.is8
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:18: (11 bytes): boolIor: bool := boolA | boolB
	<.main+?>: load.sp(+8)
	<.main+?>: load.is8
	<.main+?>: load.sp(+8)
	<.main+?>: load.is8
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:19: (11 bytes): boolXor: bool := boolA ^ boolB
	<.main+?>: load.sp(+12)
	<.main+?>: load.is8
	<.main+?>: load.sp(+12)
	<.main+?>: load.is8
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:22: (6 bytes): boolNot: bool := !boolB
	<.main+?>: load.sp(+12)
	<.main+?>: load.is8
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:23: (11 bytes): boolCeq: bool := boolA == boolB
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:24: (12 bytes): boolCne: bool := boolA != boolB
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:25: (11 bytes): boolClt: bool := boolA < boolB
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:26: (12 bytes): boolCle: bool := boolA <= boolB
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:27: (11 bytes): boolCgt: bool := boolA > boolB
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:28: (12 bytes): boolCge: bool := boolA >= boolB
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:30: (5 bytes): chrA: char := 'a'
	<.main+?>: load.c32 97
	cmplStd/test/lang/useOperator.ci:31: (5 bytes): chrB: char := 'b'
	<.main+?>: load.c32 98
	cmplStd/test/lang/useOperator.ci:32: (5 bytes): chrPls: char := +chrB
	<.main+?>: load.sp(+0)
	<.main+?>: load.is8
	cmplStd/test/lang/useOperator.ci:33: (6 bytes): chrNeg: char := -chrB
	<.main+?>: load.sp(+4)
	<.main+?>: load.is8
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:34: (6 bytes): chrCmt: char := ~chrB
	<.main+?>: load.sp(+8)
	<.main+?>: load.is8
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:35: (11 bytes): chrAdd: char := chrA + chrB
	<.main+?>: load.sp(+16)
	<.main+?>: load.is8
	<.main+?>: load.sp(+16)
	<.main+?>: load.is8
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:36: (11 bytes): chrSub: char := chrA - chrB
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:37: (11 bytes): chrMul: char := chrA * chrB
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: mul.i32
	cmplStd/test/lang/useOperator.ci:38: (11 bytes): chrDiv: char := chrA / chrB
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: div.i32
	cmplStd/test/lang/useOperator.ci:39: (11 bytes): chrMod: char := chrA % chrB
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: mod.i32
	cmplStd/test/lang/useOperator.ci:40: (11 bytes): chrAnd: char := chrA & chrB
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:41: (11 bytes): chrIor: char := chrA | chrB
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:42: (11 bytes): chrXor: char := chrA ^ chrB
	<.main+?>: load.sp(+44)
	<.main+?>: load.is8
	<.main+?>: load.sp(+44)
	<.main+?>: load.is8
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:43: (8 bytes): chrShl: char := (chrA) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.is8
	<.main+?>: dup.x32 sp(26)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:44: (8 bytes): chrShr: char := (chrA) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.is8
	<.main+?>: dup.x32 sp(27)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:45: (7 bytes): chrNot: bool := !(chrB)
	<.main+?>: load.sp(+52)
	<.main+?>: load.is8
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:46: (11 bytes): chrCeq: bool := chrA == chrB
	<.main+?>: load.sp(+60)
	<.main+?>: load.is8
	<.main+?>: load.sp(+60)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:47: (12 bytes): chrCne: bool := chrA != chrB
	<.main+?>: load.sp(+64)
	<.main+?>: load.is8
	<.main+?>: load.sp(+64)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:48: (11 bytes): chrClt: bool := chrA < chrB
	<.main+?>: load.sp(+68)
	<.main+?>: load.is8
	<.main+?>: load.sp(+68)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:49: (12 bytes): chrCle: bool := chrA <= chrB
	<.main+?>: load.sp(+72)
	<.main+?>: load.is8
	<.main+?>: load.sp(+72)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:50: (11 bytes): chrCgt: bool := chrA > chrB
	<.main+?>: load.sp(+76)
	<.main+?>: load.is8
	<.main+?>: load.sp(+76)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:51: (12 bytes): chrCge: bool := chrA >= chrB
	<.main+?>: load.sp(+80)
	<.main+?>: load.is8
	<.main+?>: load.sp(+80)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:53: (5 bytes): i8A: int8 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:54: (5 bytes): i8B: int8 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:55: (5 bytes): i8Pls: int8 := +i8B
	<.main+?>: load.sp(+0)
	<.main+?>: load.is8
	cmplStd/test/lang/useOperator.ci:56: (6 bytes): i8Neg: int8 := -i8B
	<.main+?>: load.sp(+4)
	<.main+?>: load.is8
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:57: (6 bytes): i8Cmt: int8 := ~i8B
	<.main+?>: load.sp(+8)
	<.main+?>: load.is8
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:58: (11 bytes): i8Add: int8 := i8A + i8B
	<.main+?>: load.sp(+16)
	<.main+?>: load.is8
	<.main+?>: load.sp(+16)
	<.main+?>: load.is8
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:59: (11 bytes): i8Sub: int8 := i8A - i8B
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:60: (11 bytes): i8Mul: int8 := i8A * i8B
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: mul.i32
	cmplStd/test/lang/useOperator.ci:61: (11 bytes): i8Div: int8 := i8A / i8B
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: div.i32
	cmplStd/test/lang/useOperator.ci:62: (11 bytes): i8Mod: int8 := i8A % i8B
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: mod.i32
	cmplStd/test/lang/useOperator.ci:63: (11 bytes): i8And: int8 := i8A & i8B
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:64: (11 bytes): i8Ior: int8 := i8A | i8B
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:65: (11 bytes): i8Xor: int8 := i8A ^ i8B
	<.main+?>: load.sp(+44)
	<.main+?>: load.is8
	<.main+?>: load.sp(+44)
	<.main+?>: load.is8
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:66: (8 bytes): i8Shl: int8 := (i8A) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.is8
	<.main+?>: dup.x32 sp(48)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:67: (8 bytes): i8Shr: int8 := (i8A) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.is8
	<.main+?>: dup.x32 sp(49)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:68: (7 bytes): i8Not: bool := !(i8B)
	<.main+?>: load.sp(+52)
	<.main+?>: load.is8
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:69: (11 bytes): i8Ceq: bool := i8A == i8B
	<.main+?>: load.sp(+60)
	<.main+?>: load.is8
	<.main+?>: load.sp(+60)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:70: (12 bytes): i8Cne: bool := i8A != i8B
	<.main+?>: load.sp(+64)
	<.main+?>: load.is8
	<.main+?>: load.sp(+64)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:71: (11 bytes): i8Clt: bool := i8A < i8B
	<.main+?>: load.sp(+68)
	<.main+?>: load.is8
	<.main+?>: load.sp(+68)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:72: (12 bytes): i8Cle: bool := i8A <= i8B
	<.main+?>: load.sp(+72)
	<.main+?>: load.is8
	<.main+?>: load.sp(+72)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:73: (11 bytes): i8Cgt: bool := i8A > i8B
	<.main+?>: load.sp(+76)
	<.main+?>: load.is8
	<.main+?>: load.sp(+76)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:74: (12 bytes): i8Cge: bool := i8A >= i8B
	<.main+?>: load.sp(+80)
	<.main+?>: load.is8
	<.main+?>: load.sp(+80)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:76: (5 bytes): u8A: uint8 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:77: (5 bytes): u8B: uint8 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:78: (5 bytes): u8Pls: uint8 := +u8B
	<.main+?>: load.sp(+0)
	<.main+?>: load.iu8
	cmplStd/test/lang/useOperator.ci:79: (6 bytes): u8Neg: uint8 := -u8B
	<.main+?>: load.sp(+4)
	<.main+?>: load.iu8
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:80: (6 bytes): u8Cmt: uint8 := ~u8B
	<.main+?>: load.sp(+8)
	<.main+?>: load.iu8
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:81: (11 bytes): u8Add: uint8 := u8A + u8B
	<.main+?>: load.sp(+16)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+16)
	<.main+?>: load.iu8
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:82: (11 bytes): u8Sub: uint8 := u8A - u8B
	<.main+?>: load.sp(+20)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+20)
	<.main+?>: load.iu8
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:83: (11 bytes): u8Mul: uint8 := u8A * u8B
	<.main+?>: load.sp(+24)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+24)
	<.main+?>: load.iu8
	<.main+?>: mul.u32
	cmplStd/test/lang/useOperator.ci:84: (11 bytes): u8Div: uint8 := u8A / u8B
	<.main+?>: load.sp(+28)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+28)
	<.main+?>: load.iu8
	<.main+?>: div.u32
	cmplStd/test/lang/useOperator.ci:85: (11 bytes): u8Mod: uint8 := u8A % u8B
	<.main+?>: load.sp(+32)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+32)
	<.main+?>: load.iu8
	<.main+?>: mod.u32
	cmplStd/test/lang/useOperator.ci:86: (11 bytes): u8And: uint8 := u8A & u8B
	<.main+?>: load.sp(+36)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+36)
	<.main+?>: load.iu8
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:87: (11 bytes): u8Ior: uint8 := u8A | u8B
	<.main+?>: load.sp(+40)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+40)
	<.main+?>: load.iu8
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:88: (11 bytes): u8Xor: uint8 := u8A ^ u8B
	<.main+?>: load.sp(+44)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+44)
	<.main+?>: load.iu8
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:89: (8 bytes): u8Shl: uint8 := (u8A) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.iu8
	<.main+?>: dup.x32 sp(70)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:90: (8 bytes): u8Shr: uint8 := (u8A) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.iu8
	<.main+?>: dup.x32 sp(71)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:91: (7 bytes): u8Not: bool := !(u8B)
	<.main+?>: load.sp(+52)
	<.main+?>: load.iu8
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:92: (11 bytes): u8Ceq: bool := u8A == u8B
	<.main+?>: load.sp(+60)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+60)
	<.main+?>: load.iu8
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:93: (12 bytes): u8Cne: bool := u8A != u8B
	<.main+?>: load.sp(+64)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+64)
	<.main+?>: load.iu8
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:94: (11 bytes): u8Clt: bool := u8A < u8B
	<.main+?>: load.sp(+68)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+68)
	<.main+?>: load.iu8
	<.main+?>: clt.u32
	cmplStd/test/lang/useOperator.ci:95: (12 bytes): u8Cle: bool := u8A <= u8B
	<.main+?>: load.sp(+72)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+72)
	<.main+?>: load.iu8
	<.main+?>: cgt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:96: (11 bytes): u8Cgt: bool := u8A > u8B
	<.main+?>: load.sp(+76)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+76)
	<.main+?>: load.iu8
	<.main+?>: cgt.u32
	cmplStd/test/lang/useOperator.ci:97: (12 bytes): u8Cge: bool := u8A >= u8B
	<.main+?>: load.sp(+80)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+80)
	<.main+?>: load.iu8
	<.main+?>: clt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:99: (5 bytes): i16A: int16 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:100: (5 bytes): i16B: int16 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:101: (5 bytes): i16Pls: int16 := +i16B
	<.main+?>: load.sp(+0)
	<.main+?>: load.is16
	cmplStd/test/lang/useOperator.ci:102: (6 bytes): i16Neg: int16 := -i16B
	<.main+?>: load.sp(+4)
	<.main+?>: load.is16
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:103: (6 bytes): i16Cmt: int16 := ~i16B
	<.main+?>: load.sp(+8)
	<.main+?>: load.is16
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:104: (11 bytes): i16Add: int16 := i16A + i16B
	<.main+?>: load.sp(+16)
	<.main+?>: load.is16
	<.main+?>: load.sp(+16)
	<.main+?>: load.is16
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:105: (11 bytes): i16Sub: int16 := i16A - i16B
	<.main+?>: load.sp(+20)
	<.main+?>: load.is16
	<.main+?>: load.sp(+20)
	<.main+?>: load.is16
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:106: (11 bytes): i16Mul: int16 := i16A * i16B
	<.main+?>: load.sp(+24)
	<.main+?>: load.is16
	<.main+?>: load.sp(+24)
	<.main+?>: load.is16
	<.main+?>: mul.i32
	cmplStd/test/lang/useOperator.ci:107: (11 bytes): i16Div: int16 := i16A / i16B
	<.main+?>: load.sp(+28)
	<.main+?>: load.is16
	<.main+?>: load.sp(+28)
	<.main+?>: load.is16
	<.main+?>: div.i32
	cmplStd/test/lang/useOperator.ci:108: (11 bytes): i16Mod: int16 := i16A % i16B
	<.main+?>: load.sp(+32)
	<.main+?>: load.is16
	<.main+?>: load.sp(+32)
	<.main+?>: load.is16
	<.main+?>: mod.i32
	cmplStd/test/lang/useOperator.ci:109: (11 bytes): i16And: int16 := i16A & i16B
	<.main+?>: load.sp(+36)
	<.main+?>: load.is16
	<.main+?>: load.sp(+36)
	<.main+?>: load.is16
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:110: (11 bytes): i16Ior: int16 := i16A | i16B
	<.main+?>: load.sp(+40)
	<.main+?>: load.is16
	<.main+?>: load.sp(+40)
	<.main+?>: load.is16
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:111: (11 bytes): i16Xor: int16 := i16A ^ i16B
	<.main+?>: load.sp(+44)
	<.main+?>: load.is16
	<.main+?>: load.sp(+44)
	<.main+?>: load.is16
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:112: (8 bytes): i16Shl: int16 := (i16A) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.is16
	<.main+?>: dup.x32 sp(92)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:113: (8 bytes): i16Shr: int16 := (i16A) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.is16
	<.main+?>: dup.x32 sp(93)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:114: (7 bytes): i16Not: bool := !(i16B)
	<.main+?>: load.sp(+52)
	<.main+?>: load.is16
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:115: (11 bytes): i16Ceq: bool := i16A == i16B
	<.main+?>: load.sp(+60)
	<.main+?>: load.is16
	<.main+?>: load.sp(+60)
	<.main+?>: load.is16
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:116: (12 bytes): i16Cne: bool := i16A != i16B
	<.main+?>: load.sp(+64)
	<.main+?>: load.is16
	<.main+?>: load.sp(+64)
	<.main+?>: load.is16
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:117: (11 bytes): i16Clt: bool := i16A < i16B
	<.main+?>: load.sp(+68)
	<.main+?>: load.is16
	<.main+?>: load.sp(+68)
	<.main+?>: load.is16
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:118: (12 bytes): i16Cle: bool := i16A <= i16B
	<.main+?>: load.sp(+72)
	<.main+?>: load.is16
	<.main+?>: load.sp(+72)
	<.main+?>: load.is16
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:119: (11 bytes): i16Cgt: bool := i16A > i16B
	<.main+?>: load.sp(+76)
	<.main+?>: load.is16
	<.main+?>: load.sp(+76)
	<.main+?>: load.is16
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:120: (12 bytes): i16Cge: bool := i16A >= i16B
	<.main+?>: load.sp(+80)
	<.main+?>: load.is16
	<.main+?>: load.sp(+80)
	<.main+?>: load.is16
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:122: (5 bytes): u16A: uint16 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:123: (5 bytes): u16B: uint16 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:124: (5 bytes): u16Pls: uint16 := +u16B
	<.main+?>: load.sp(+0)
	<.main+?>: load.iu16
	cmplStd/test/lang/useOperator.ci:125: (6 bytes): u16Neg: uint16 := -u16B
	<.main+?>: load.sp(+4)
	<.main+?>: load.iu16
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:126: (6 bytes): u16Cmt: uint16 := ~u16B
	<.main+?>: load.sp(+8)
	<.main+?>: load.iu16
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:127: (11 bytes): u16Add: uint16 := u16A + u16B
	<.main+?>: load.sp(+16)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+16)
	<.main+?>: load.iu16
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:128: (11 bytes): u16Sub: uint16 := u16A - u16B
	<.main+?>: load.sp(+20)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+20)
	<.main+?>: load.iu16
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:129: (11 bytes): u16Mul: uint16 := u16A * u16B
	<.main+?>: load.sp(+24)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+24)
	<.main+?>: load.iu16
	<.main+?>: mul.u32
	cmplStd/test/lang/useOperator.ci:130: (11 bytes): u16Div: uint16 := u16A / u16B
	<.main+?>: load.sp(+28)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+28)
	<.main+?>: load.iu16
	<.main+?>: div.u32
	cmplStd/test/lang/useOperator.ci:131: (11 bytes): u16Mod: uint16 := u16A % u16B
	<.main+?>: load.sp(+32)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+32)
	<.main+?>: load.iu16
	<.main+?>: mod.u32
	cmplStd/test/lang/useOperator.ci:132: (11 bytes): u16And: uint16 := u16A & u16B
	<.main+?>: load.sp(+36)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+36)
	<.main+?>: load.iu16
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:133: (11 bytes): u16Ior: uint16 := u16A | u16B
	<.main+?>: load.sp(+40)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+40)
	<.main+?>: load.iu16
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:134: (11 bytes): u16Xor: uint16 := u16A ^ u16B
	<.main+?>: load.sp(+44)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+44)
	<.main+?>: load.iu16
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:135: (8 bytes): u16Shl: uint16 := (u16A) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.iu16
	<.main+?>: dup.x32 sp(114)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:136: (8 bytes): u16Shr: uint16 := (u16A) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.iu16
	<.main+?>: dup.x32 sp(115)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:137: (7 bytes): u16Not: bool := !(u16B)
	<.main+?>: load.sp(+52)
	<.main+?>: load.iu16
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:138: (11 bytes): u16Ceq: bool := u16A == u16B
	<.main+?>: load.sp(+60)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+60)
	<.main+?>: load.iu16
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:139: (12 bytes): u16Cne: bool := u16A != u16B
	<.main+?>: load.sp(+64)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+64)
	<.main+?>: load.iu16
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:140: (11 bytes): u16Clt: bool := u16A < u16B
	<.main+?>: load.sp(+68)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+68)
	<.main+?>: load.iu16
	<.main+?>: clt.u32
	cmplStd/test/lang/useOperator.ci:141: (12 bytes): u16Cle: bool := u16A <= u16B
	<.main+?>: load.sp(+72)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+72)
	<.main+?>: load.iu16
	<.main+?>: cgt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:142: (11 bytes): u16Cgt: bool := u16A > u16B
	<.main+?>: load.sp(+76)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+76)
	<.main+?>: load.iu16
	<.main+?>: cgt.u32
	cmplStd/test/lang/useOperator.ci:143: (12 bytes): u16Cge: bool := u16A >= u16B
	<.main+?>: load.sp(+80)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+80)
	<.main+?>: load.iu16
	<.main+?>: clt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:145: (5 bytes): i32A: int32 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:146: (5 bytes): i32B: int32 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:147: (2 bytes): i32Pls: int32 := +i32B
	<.main+?>: dup.x32 sp(0)
	cmplStd/test/lang/useOperator.ci:148: (3 bytes): i32Neg: int32 := -i32B
	<.main+?>: dup.x32 sp(1)
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:149: (3 bytes): i32Cmt: int32 := ~i32B
	<.main+?>: dup.x32 sp(2)
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:150: (5 bytes): i32Add: int32 := i32A + i32B
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:151: (5 bytes): i32Sub: int32 := i32A - i32B
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:152: (5 bytes): i32Mul: int32 := i32A * i32B
	<.main+?>: dup.x32 sp(6)
	<.main+?>: dup.x32 sp(6)
	<.main+?>: mul.i32
	cmplStd/test/lang/useOperator.ci:153: (5 bytes): i32Div: int32 := i32A / i32B
	<.main+?>: dup.x32 sp(7)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: div.i32
	cmplStd/test/lang/useOperator.ci:154: (5 bytes): i32Mod: int32 := i32A % i32B
	<.main+?>: dup.x32 sp(8)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: mod.i32
	cmplStd/test/lang/useOperator.ci:155: (5 bytes): i32And: int32 := i32A & i32B
	<.main+?>: dup.x32 sp(9)
	<.main+?>: dup.x32 sp(9)
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:156: (5 bytes): i32Ior: int32 := i32A | i32B
	<.main+?>: dup.x32 sp(10)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:157: (5 bytes): i32Xor: int32 := i32A ^ i32B
	<.main+?>: dup.x32 sp(11)
	<.main+?>: dup.x32 sp(11)
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:158: (5 bytes): i32Shl: int32 := i32A << shift
	<.main+?>: dup.x32 sp(12)
	<.main+?>: dup.x32 sp(136)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:159: (5 bytes): i32Shr: int32 := i32A >> shift
	<.main+?>: dup.x32 sp(13)
	<.main+?>: dup.x32 sp(137)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:160: (4 bytes): i32Not: bool := !(i32B)
	<.main+?>: dup.x32 sp(13)
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:161: (5 bytes): i32Ceq: bool := i32A == i32B
	<.main+?>: dup.x32 sp(15)
	<.main+?>: dup.x32 sp(15)
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:162: (6 bytes): i32Cne: bool := i32A != i32B
	<.main+?>: dup.x32 sp(16)
	<.main+?>: dup.x32 sp(16)
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:163: (5 bytes): i32Clt: bool := i32A < i32B
	<.main+?>: dup.x32 sp(17)
	<.main+?>: dup.x32 sp(17)
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:164: (6 bytes): i32Cle: bool := i32A <= i32B
	<.main+?>: dup.x32 sp(18)
	<.main+?>: dup.x32 sp(18)
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:165: (5 bytes): i32Cgt: bool := i32A > i32B
	<.main+?>: dup.x32 sp(19)
	<.main+?>: dup.x32 sp(19)
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:166: (6 bytes): i32Cge: bool := i32A >= i32B
	<.main+?>: dup.x32 sp(20)
	<.main+?>: dup.x32 sp(20)
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:168: (5 bytes): u32A: uint32 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:169: (5 bytes): u32B: uint32 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:170: (2 bytes): u32Pls: uint32 := +u32B
	<.main+?>: dup.x32 sp(0)
	cmplStd/test/lang/useOperator.ci:171: (3 bytes): u32Neg: uint32 := -u32B
	<.main+?>: dup.x32 sp(1)
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:172: (3 bytes): u32Cmt: uint32 := ~u32B
	<.main+?>: dup.x32 sp(2)
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:173: (5 bytes): u32Add: uint32 := u32A + u32B
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:174: (5 bytes): u32Sub: uint32 := u32A - u32B
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:175: (5 bytes): u32Mul: uint32 := u32A * u32B
	<.main+?>: dup.x32 sp(6)
	<.main+?>: dup.x32 sp(6)
	<.main+?>: mul.u32
	cmplStd/test/lang/useOperator.ci:176: (5 bytes): u32Div: uint32 := u32A / u32B
	<.main+?>: dup.x32 sp(7)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: div.u32
	cmplStd/test/lang/useOperator.ci:177: (5 bytes): u32Mod: uint32 := u32A % u32B
	<.main+?>: dup.x32 sp(8)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: mod.u32
	cmplStd/test/lang/useOperator.ci:178: (5 bytes): u32And: uint32 := u32A & u32B
	<.main+?>: dup.x32 sp(9)
	<.main+?>: dup.x32 sp(9)
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:179: (5 bytes): u32Ior: uint32 := u32A | u32B
	<.main+?>: dup.x32 sp(10)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:180: (5 bytes): u32Xor: uint32 := u32A ^ u32B
	<.main+?>: dup.x32 sp(11)
	<.main+?>: dup.x32 sp(11)
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:181: (5 bytes): u32Shl: uint32 := u32A << shift
	<.main+?>: dup.x32 sp(12)
	<.main+?>: dup.x32 sp(158)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:182: (5 bytes): u32Shr: uint32 := u32A >> shift
	<.main+?>: dup.x32 sp(13)
	<.main+?>: dup.x32 sp(159)
	<.main+?>: shr.b32
	cmplStd/test/lang/useOperator.ci:183: (4 bytes): u32Not: bool := !(u32B)
	<.main+?>: dup.x32 sp(13)
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:184: (5 bytes): u32Ceq: bool := u32A == u32B
	<.main+?>: dup.x32 sp(15)
	<.main+?>: dup.x32 sp(15)
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:185: (6 bytes): u32Cne: bool := u32A != u32B
	<.main+?>: dup.x32 sp(16)
	<.main+?>: dup.x32 sp(16)
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:186: (5 bytes): u32Clt: bool := u32A < u32B
	<.main+?>: dup.x32 sp(17)
	<.main+?>: dup.x32 sp(17)
	<.main+?>: clt.u32
	cmplStd/test/lang/useOperator.ci:187: (6 bytes): u32Cle: bool := u32A <= u32B
	<.main+?>: dup.x32 sp(18)
	<.main+?>: dup.x32 sp(18)
	<.main+?>: cgt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:188: (5 bytes): u32Cgt: bool := u32A > u32B
	<.main+?>: dup.x32 sp(19)
	<.main+?>: dup.x32 sp(19)
	<.main+?>: cgt.u32
	cmplStd/test/lang/useOperator.ci:189: (6 bytes): u32Cge: bool := u32A >= u32B
	<.main+?>: dup.x32 sp(20)
	<.main+?>: dup.x32 sp(20)
	<.main+?>: clt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:191: (9 bytes): i64A: int64 := a
	<.main+?>: load.c64 96
	cmplStd/test/lang/useOperator.ci:192: (9 bytes): i64B: int64 := b
	<.main+?>: load.c64 42
	cmplStd/test/lang/useOperator.ci:193: (2 bytes): i64Pls: int64 := +i64B
	<.main+?>: dup.x64 sp(0)
	cmplStd/test/lang/useOperator.ci:194: (3 bytes): i64Neg: int64 := -i64B
	<.main+?>: dup.x64 sp(2)
	<.main+?>: neg.i64
	cmplStd/test/lang/useOperator.ci:195: (3 bytes): i64Cmt: int64 := ~i64B
	<.main+?>: dup.x64 sp(4)
	<.main+?>: cmt.b64
	cmplStd/test/lang/useOperator.ci:196: (5 bytes): i64Add: int64 := i64A + i64B
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: add.i64
	cmplStd/test/lang/useOperator.ci:197: (5 bytes): i64Sub: int64 := i64A - i64B
	<.main+?>: dup.x64 sp(10)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: sub.i64
	cmplStd/test/lang/useOperator.ci:198: (5 bytes): i64Mul: int64 := i64A * i64B
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(12)
	<.main+?>: mul.i64
	cmplStd/test/lang/useOperator.ci:199: (5 bytes): i64Div: int64 := i64A / i64B
	<.main+?>: dup.x64 sp(14)
	<.main+?>: dup.x64 sp(14)
	<.main+?>: div.i64
	cmplStd/test/lang/useOperator.ci:200: (5 bytes): i64Mod: int64 := i64A % i64B
	<.main+?>: dup.x64 sp(16)
	<.main+?>: dup.x64 sp(16)
	<.main+?>: mod.i64
	cmplStd/test/lang/useOperator.ci:201: (5 bytes): i64And: int64 := i64A & i64B
	<.main+?>: dup.x64 sp(18)
	<.main+?>: dup.x64 sp(18)
	<.main+?>: and.b64
	cmplStd/test/lang/useOperator.ci:202: (5 bytes): i64Ior: int64 := i64A | i64B
	<.main+?>: dup.x64 sp(20)
	<.main+?>: dup.x64 sp(20)
	<.main+?>: or.b64
	cmplStd/test/lang/useOperator.ci:203: (5 bytes): i64Xor: int64 := i64A ^ i64B
	<.main+?>: dup.x64 sp(22)
	<.main+?>: dup.x64 sp(22)
	<.main+?>: xor.b64
	cmplStd/test/lang/useOperator.ci:204: (5 bytes): i64Shl: int64 := i64A << shift
	<.main+?>: dup.x64 sp(24)
	<.main+?>: dup.x32 sp(194)
	<.main+?>: shl.b64
	cmplStd/test/lang/useOperator.ci:205: (5 bytes): i64Shr: int64 := i64A >> shift
	<.main+?>: dup.x64 sp(26)
	<.main+?>: dup.x32 sp(196)
	<.main+?>: sar.b64
	cmplStd/test/lang/useOperator.ci:206: (4 bytes): i64Not: bool := !(i64B)
	<.main+?>: dup.x64 sp(26)
	<.main+?>: i64.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:207: (5 bytes): i64Ceq: bool := i64A == i64B
	<.main+?>: dup.x64 sp(29)
	<.main+?>: dup.x64 sp(29)
	<.main+?>: ceq.i64
	cmplStd/test/lang/useOperator.ci:208: (6 bytes): i64Cne: bool := i64A != i64B
	<.main+?>: dup.x64 sp(30)
	<.main+?>: dup.x64 sp(30)
	<.main+?>: ceq.i64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:209: (5 bytes): i64Clt: bool := i64A < i64B
	<.main+?>: dup.x64 sp(31)
	<.main+?>: dup.x64 sp(31)
	<.main+?>: clt.i64
	cmplStd/test/lang/useOperator.ci:210: (6 bytes): i64Cle: bool := i64A <= i64B
	<.main+?>: dup.x64 sp(32)
	<.main+?>: dup.x64 sp(32)
	<.main+?>: cgt.i64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:211: (5 bytes): i64Cgt: bool := i64A > i64B
	<.main+?>: dup.x64 sp(33)
	<.main+?>: dup.x64 sp(33)
	<.main+?>: cgt.i64
	cmplStd/test/lang/useOperator.ci:212: (6 bytes): i64Cge: bool := i64A >= i64B
	<.main+?>: dup.x64 sp(34)
	<.main+?>: dup.x64 sp(34)
	<.main+?>: clt.i64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:214: (9 bytes): u64A: uint64 := a
	<.main+?>: load.c64 96
	cmplStd/test/lang/useOperator.ci:215: (9 bytes): u64B: uint64 := b
	<.main+?>: load.c64 42
	cmplStd/test/lang/useOperator.ci:216: (2 bytes): u64Pls: uint64 := +u64B
	<.main+?>: dup.x64 sp(0)
	cmplStd/test/lang/useOperator.ci:217: (3 bytes): u64Neg: uint64 := -u64B
	<.main+?>: dup.x64 sp(2)
	<.main+?>: neg.i64
	cmplStd/test/lang/useOperator.ci:218: (3 bytes): u64Cmt: uint64 := ~u64B
	<.main+?>: dup.x64 sp(4)
	<.main+?>: cmt.b64
	cmplStd/test/lang/useOperator.ci:219: (5 bytes): u64Add: uint64 := u64A + u64B
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: add.i64
	cmplStd/test/lang/useOperator.ci:220: (5 bytes): u64Sub: uint64 := u64A - u64B
	<.main+?>: dup.x64 sp(10)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: sub.i64
	cmplStd/test/lang/useOperator.ci:221: (5 bytes): u64Mul: uint64 := u64A * u64B
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(12)
	<.main+?>: mul.u64
	cmplStd/test/lang/useOperator.ci:222: (5 bytes): u64Div: uint64 := u64A / u64B
	<.main+?>: dup.x64 sp(14)
	<.main+?>: dup.x64 sp(14)
	<.main+?>: div.u64
	cmplStd/test/lang/useOperator.ci:223: (5 bytes): u64Mod: uint64 := u64A % u64B
	<.main+?>: dup.x64 sp(16)
	<.main+?>: dup.x64 sp(16)
	<.main+?>: mod.u64
	cmplStd/test/lang/useOperator.ci:224: (5 bytes): u64And: uint64 := u64A & u64B
	<.main+?>: dup.x64 sp(18)
	<.main+?>: dup.x64 sp(18)
	<.main+?>: and.b64
	cmplStd/test/lang/useOperator.ci:225: (5 bytes): u64Ior: uint64 := u64A | u64B
	<.main+?>: dup.x64 sp(20)
	<.main+?>: dup.x64 sp(20)
	<.main+?>: or.b64
	cmplStd/test/lang/useOperator.ci:226: (5 bytes): u64Xor: uint64 := u64A ^ u64B
	<.main+?>: dup.x64 sp(22)
	<.main+?>: dup.x64 sp(22)
	<.main+?>: xor.b64
	cmplStd/test/lang/useOperator.ci:227: (5 bytes): u64Shl: uint64 := u64A << shift
	<.main+?>: dup.x64 sp(24)
	<.main+?>: dup.x32 sp(231)
	<.main+?>: shl.b64
	cmplStd/test/lang/useOperator.ci:228: (5 bytes): u64Shr: uint64 := u64A >> shift
	<.main+?>: dup.x64 sp(26)
	<.main+?>: dup.x32 sp(233)
	<.main+?>: shr.b64
	cmplStd/test/lang/useOperator.ci:229: (4 bytes): u64Not: bool := !(u64B)
	<.main+?>: dup.x64 sp(26)
	<.main+?>: i64.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:230: (5 bytes): u64Ceq: bool := u64A == u64B
	<.main+?>: dup.x64 sp(29)
	<.main+?>: dup.x64 sp(29)
	<.main+?>: ceq.i64
	cmplStd/test/lang/useOperator.ci:231: (6 bytes): u64Cne: bool := u64A != u64B
	<.main+?>: dup.x64 sp(30)
	<.main+?>: dup.x64 sp(30)
	<.main+?>: ceq.i64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:232: (5 bytes): u64Clt: bool := u64A < u64B
	<.main+?>: dup.x64 sp(31)
	<.main+?>: dup.x64 sp(31)
	<.main+?>: clt.u64
	cmplStd/test/lang/useOperator.ci:233: (6 bytes): u64Cle: bool := u64A <= u64B
	<.main+?>: dup.x64 sp(32)
	<.main+?>: dup.x64 sp(32)
	<.main+?>: cgt.u64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:234: (5 bytes): u64Cgt: bool := u64A > u64B
	<.main+?>: dup.x64 sp(33)
	<.main+?>: dup.x64 sp(33)
	<.main+?>: cgt.u64
	cmplStd/test/lang/useOperator.ci:235: (6 bytes): u64Cge: bool := u64A >= u64B
	<.main+?>: dup.x64 sp(34)
	<.main+?>: dup.x64 sp(34)
	<.main+?>: clt.u64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:237: (5 bytes): f32A: float32 := a
	<.main+?>: load.f32 96.300003
	cmplStd/test/lang/useOperator.ci:238: (5 bytes): f32B: float32 := b
	<.main+?>: load.f32 42.139999
	cmplStd/test/lang/useOperator.ci:239: (2 bytes): f32Pls: float32 := +f32B
	<.main+?>: dup.x32 sp(0)
	cmplStd/test/lang/useOperator.ci:240: (3 bytes): f32Neg: float32 := -f32B
	<.main+?>: dup.x32 sp(1)
	<.main+?>: neg.f32
	cmplStd/test/lang/useOperator.ci:242: (5 bytes): f32Add: float32 := f32A + f32B
	<.main+?>: dup.x32 sp(3)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: add.f32
	cmplStd/test/lang/useOperator.ci:243: (5 bytes): f32Sub: float32 := f32A - f32B
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: sub.f32
	cmplStd/test/lang/useOperator.ci:244: (5 bytes): f32Mul: float32 := f32A * f32B
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: mul.f32
	cmplStd/test/lang/useOperator.ci:245: (5 bytes): f32Div: float32 := f32A / f32B
	<.main+?>: dup.x32 sp(6)
	<.main+?>: dup.x32 sp(6)
	<.main+?>: div.f32
	cmplStd/test/lang/useOperator.ci:246: (5 bytes): f32Mod: float32 := f32A % f32B
	<.main+?>: dup.x32 sp(7)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: mod.f32
	cmplStd/test/lang/useOperator.ci:252: (4 bytes): f32Not: bool := !(f32B)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: f32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:253: (5 bytes): f32Ceq: bool := f32A == f32B
	<.main+?>: dup.x32 sp(9)
	<.main+?>: dup.x32 sp(9)
	<.main+?>: ceq.f32
	cmplStd/test/lang/useOperator.ci:254: (6 bytes): f32Cne: bool := f32A != f32B
	<.main+?>: dup.x32 sp(10)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: ceq.f32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:255: (5 bytes): f32Clt: bool := f32A < f32B
	<.main+?>: dup.x32 sp(11)
	<.main+?>: dup.x32 sp(11)
	<.main+?>: clt.f32
	cmplStd/test/lang/useOperator.ci:256: (6 bytes): f32Cle: bool := f32A <= f32B
	<.main+?>: dup.x32 sp(12)
	<.main+?>: dup.x32 sp(12)
	<.main+?>: cgt.f32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:257: (5 bytes): f32Cgt: bool := f32A > f32B
	<.main+?>: dup.x32 sp(13)
	<.main+?>: dup.x32 sp(13)
	<.main+?>: cgt.f32
	cmplStd/test/lang/useOperator.ci:258: (6 bytes): f32Cge: bool := f32A >= f32B
	<.main+?>: dup.x32 sp(14)
	<.main+?>: dup.x32 sp(14)
	<.main+?>: clt.f32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:260: (9 bytes): f64A: float64 := a
	<.main+?>: load.f64 96.300000
	cmplStd/test/lang/useOperator.ci:261: (9 bytes): f64B: float64 := b
	<.main+?>: load.f64 42.140000
	cmplStd/test/lang/useOperator.ci:262: (2 bytes): f64Pls: float64 := +f64B
	<.main+?>: dup.x64 sp(0)
	cmplStd/test/lang/useOperator.ci:263: (3 bytes): f64Neg: float64 := -f64B
	<.main+?>: dup.x64 sp(2)
	<.main+?>: neg.f64
	cmplStd/test/lang/useOperator.ci:265: (5 bytes): f64Add: float64 := f64A + f64B
	<.main+?>: dup.x64 sp(6)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: add.f64
	cmplStd/test/lang/useOperator.ci:266: (5 bytes): f64Sub: float64 := f64A - f64B
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: sub.f64
	cmplStd/test/lang/useOperator.ci:267: (5 bytes): f64Mul: float64 := f64A * f64B
	<.main+?>: dup.x64 sp(10)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: mul.f64
	cmplStd/test/lang/useOperator.ci:268: (5 bytes): f64Div: float64 := f64A / f64B
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(12)
	<.main+?>: div.f64
	cmplStd/test/lang/useOperator.ci:269: (5 bytes): f64Mod: float64 := f64A % f64B
	<.main+?>: dup.x64 sp(14)
	<.main+?>: dup.x64 sp(14)
	<.main+?>: mod.f64
	cmplStd/test/lang/useOperator.ci:275: (4 bytes): f64Not: bool := !(f64B)
	<.main+?>: dup.x64 sp(14)
	<.main+?>: f64.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:276: (5 bytes): f64Ceq: bool := f64A == f64B
	<.main+?>: dup.x64 sp(17)
	<.main+?>: dup.x64 sp(17)
	<.main+?>: ceq.f64
	cmplStd/test/lang/useOperator.ci:277: (6 bytes): f64Cne: bool := f64A != f64B
	<.main+?>: dup.x64 sp(18)
	<.main+?>: dup.x64 sp(18)
	<.main+?>: ceq.f64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:278: (5 bytes): f64Clt: bool := f64A < f64B
	<.main+?>: dup.x64 sp(19)
	<.main+?>: dup.x64 sp(19)
	<.main+?>: clt.f64
	cmplStd/test/lang/useOperator.ci:279: (6 bytes): f64Cle: bool := f64A <= f64B
	<.main+?>: dup.x64 sp(20)
	<.main+?>: dup.x64 sp(20)
	<.main+?>: cgt.f64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:280: (5 bytes): f64Cgt: bool := f64A > f64B
	<.main+?>: dup.x64 sp(21)
	<.main+?>: dup.x64 sp(21)
	<.main+?>: cgt.f64
	cmplStd/test/lang/useOperator.ci:281: (6 bytes): f64Cge: bool := f64A >= f64B
	<.main+?>: dup.x64 sp(22)
	<.main+?>: dup.x64 sp(22)
	<.main+?>: clt.f64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:283: (5 bytes): ptrA: pointer := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/useOperator.ci:284: (4 bytes): ptrB: pointer := pointer(shift)
	<.main+?>: load.sp(+1128)
	cmplStd/test/lang/useOperator.ci:299: (5 bytes): ptrCeq: bool := ptrA == ptrB
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:300: (6 bytes): ptrCne: bool := ptrA != ptrB
	<.main+?>: dup.x32 sp(2)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/stmt.if.ci:4: (40 bytes): raise(raise.debug, 1, "0 == 0");
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 4
	<.main+?>: load.c32 14
	<.main+?>: load.c32 1
	<.main+?>: load.ref <?> ;"0 == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/stmt.if.ci:12: (40 bytes): raise(raise.debug, 3, "0 == 0");
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 12
	<.main+?>: load.c32 14
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"0 == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/stmt.if.ci:22: (40 bytes): raise(raise.debug, 6, "0 == 0");
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 22
	<.main+?>: load.c32 14
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"0 == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/stmt.if.ci:26: (1 byte): t: int32 := 0
	<.main+?>: load.z32
	cmplStd/test/lang/stmt.if.ci:28: (61 bytes): if (t == 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jz +57
	cmplStd/test/lang/stmt.if.ci:29: (53 bytes): raise(raise.debug, 7, "t == 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 29
	<.main+?>: load.c32 14
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;"t == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:32: (61 bytes): if (t != 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jnz +57
	cmplStd/test/lang/stmt.if.ci:33: (53 bytes): raise(raise.debug, 8, "t != 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 33
	<.main+?>: load.c32 14
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"t != 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:36: (118 bytes): if (t == 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:37: (53 bytes): raise(raise.debug, 9, "t == 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 37
	<.main+?>: load.c32 14
	<.main+?>: load.c32 9
	<.main+?>: load.ref <?> ;"t == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.if.ci:40: (53 bytes): raise(raise.debug, 10, "t != 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 40
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t != 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:43: (118 bytes): if (t != 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jnz +61
	cmplStd/test/lang/stmt.if.ci:44: (53 bytes): raise(raise.debug, 11, "t != 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 44
	<.main+?>: load.c32 14
	<.main+?>: load.c32 11
	<.main+?>: load.ref <?> ;"t != 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.if.ci:47: (53 bytes): raise(raise.debug, 12, "t == 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 47
	<.main+?>: load.c32 14
	<.main+?>: load.c32 12
	<.main+?>: load.ref <?> ;"t == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:50: (463 bytes): if (t == 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:51: (53 bytes): raise(raise.debug, 9, "t == 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 51
	<.main+?>: load.c32 14
	<.main+?>: load.c32 9
	<.main+?>: load.ref <?> ;"t == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +402
	cmplStd/test/lang/stmt.if.ci:53: (398 bytes): if (t == 1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 1
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:54: (53 bytes): raise(raise.debug, 10, "t == 1", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 54
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 1"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +333
	cmplStd/test/lang/stmt.if.ci:56: (329 bytes): if (t == 2)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:57: (53 bytes): raise(raise.debug, 10, "t == 2", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 57
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 2"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +264
	cmplStd/test/lang/stmt.if.ci:59: (260 bytes): if (t == 3)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 3
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:60: (53 bytes): raise(raise.debug, 10, "t == 3", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 60
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 3"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +195
	cmplStd/test/lang/stmt.if.ci:62: (191 bytes): if (t == 4)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 4
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:63: (53 bytes): raise(raise.debug, 10, "t == 4", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 63
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 4"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +126
	cmplStd/test/lang/stmt.if.ci:65: (122 bytes): if (t == 5)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 5
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:66: (53 bytes): raise(raise.debug, 10, "t == 5", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 66
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 5"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.if.ci:69: (53 bytes): raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 69
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:3: (48 bytes): for ( ; ; )
	<.main+?>: jmp +44
	cmplStd/test/lang/stmt.for.ci:4: (36 bytes): debug("for ( ; ; )");
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 4
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for ( ; ; )"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/stmt.for.ci:5: (4 bytes): break;
	<.main+?>: jmp +8
	:: (4 bytes)
	<.main+?>: jmp -40
	cmplStd/test/lang/stmt.for.ci:8: (74 bytes): for (i: int32 := 0; i < 2; i := i + 1)
	<.main+?>: load.z32
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.for.ci:9: (49 bytes): debug("for (int i = 0; i < 2; i += 1)", i);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 9
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for (int i = 0; i < 2; i += 1)"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:8: (4 bytes): i := i + 1
	<.main+?>: inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:8: (12 bytes): i < 2
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: clt.i32
	<.main+?>: jnz -61
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:12: (1 byte): forIdx: int32
	<.main+?>: load.z32
	cmplStd/test/lang/stmt.for.ci:13: (72 bytes): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	<.main+?>: load.z32
	<.main+?>: set.x32 sp(1)
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.for.ci:14: (49 bytes): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 14
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:13: (4 bytes): forIdx := forIdx + 1
	<.main+?>: inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:13: (12 bytes): forIdx < 2
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: clt.i32
	<.main+?>: jnz -61
	cmplStd/test/lang/stmt.for.ci:17: (90 bytes): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+?>: load.z32
	<.main+?>: jmp +73
	cmplStd/test/lang/stmt.for.ci:18: (16 bytes): if (i < 2)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: clt.i32
	<.main+?>: jz +8
	cmplStd/test/lang/stmt.for.ci:19: (4 bytes): continue;
	<.main+?>: jmp +53
	cmplStd/test/lang/stmt.for.ci:21: (49 bytes): debug("for with continue", i);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 21
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for with continue"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:17: (4 bytes): i := i + 1
	<.main+?>: inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:17: (12 bytes): i < 7
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 7
	<.main+?>: clt.i32
	<.main+?>: jnz -77
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:24: (90 bytes): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+?>: load.z32
	<.main+?>: jmp +73
	cmplStd/test/lang/stmt.for.ci:25: (16 bytes): if (i > 2)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: cgt.i32
	<.main+?>: jz +8
	cmplStd/test/lang/stmt.for.ci:26: (4 bytes): break;
	<.main+?>: jmp +69
	cmplStd/test/lang/stmt.for.ci:28: (49 bytes): debug("for with break", i);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 28
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for with break"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:24: (4 bytes): i := i + 1
	<.main+?>: inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:24: (12 bytes): i < 7
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 7
	<.main+?>: clt.i32
	<.main+?>: jnz -77
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:3: (9 bytes): pi64: float64 := 3.141593
	<.main+?>: load.f64 3.141593
	cmplStd/test/math/test.Bits.ci:4: (9 bytes): e64: float64 := 2.718282
	<.main+?>: load.f64 2.718282
	cmplStd/test/math/test.Bits.ci:6: (3 bytes): pi32: float32 := pi64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: f64.2f32
	cmplStd/test/math/test.Bits.ci:7: (3 bytes): e32: float32 := e64
	<.main+?>: dup.x64 sp(1)
	<.main+?>: f64.2f32
	cmplStd/test/math/test.Bits.ci:14: (7 bytes): r_comp: int32 := 14 << 3
	<.main+?>: load.c32 14
	<.main+?>: b32.shl 0x03
	cmplStd/test/math/test.Bits.ci:15: (7 bytes): g_comp: int32 := 63 << 2
	<.main+?>: load.c32 63
	<.main+?>: b32.shl 0x02
	cmplStd/test/math/test.Bits.ci:16: (7 bytes): b_comp: int32 := 31 << 3
	<.main+?>: load.c32 31
	<.main+?>: b32.shl 0x03
	cmplStd/test/math/test.Bits.ci:18: (28 bytes): r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 63488
	<.main+?>: and.b32
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shl 0x03
	<.main+?>: load.c32 2016
	<.main+?>: and.b32
	<.main+?>: or.b32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: b32.sar 0x03
	<.main+?>: b32.and 0x1f
	<.main+?>: or.b32
	cmplStd/test/math/test.Bits.ci:19: (26 bytes): r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: b32.shl 0x10
	<.main+?>: load.c32 16711680
	<.main+?>: and.b32
	<.main+?>: dup.x32 sp(3)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 65280
	<.main+?>: and.b32
	<.main+?>: or.b32
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.and 0xff
	<.main+?>: or.b32
	cmplStd/test/math/test.Bits.ci:21: (23 bytes): zxtR5: int32 := Bits.zxt32(r5g6b5, 11, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(2)
	<.main+?>: load.c32 11
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:22: (23 bytes): zxtG6: int32 := Bits.zxt32(r5g6b5, 5, 6)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(3)
	<.main+?>: load.c32 5
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:23: (19 bytes): zxtB5: int32 := Bits.zxt32(r5g6b5, 0, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(4)
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:25: (23 bytes): sxtR5: int32 := Bits.sxt32(r5g6b5, 11, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(5)
	<.main+?>: load.c32 11
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:26: (23 bytes): sxtG6: int32 := Bits.sxt32(r5g6b5, 5, 6)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(6)
	<.main+?>: load.c32 5
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:27: (19 bytes): sxtB5: int32 := Bits.sxt32(r5g6b5, 0, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(7)
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:29: (23 bytes): zxtR8: int32 := Bits.zxt32(r8g8b8, 16, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(7)
	<.main+?>: load.c32 16
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:30: (23 bytes): zxtG8: int32 := Bits.zxt32(r8g8b8, 8, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 8
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:31: (19 bytes): zxtB8: int32 := Bits.zxt32(r8g8b8, 0, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(9)
	<.main+?>: load.z32
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:33: (23 bytes): sxtR8: int32 := Bits.sxt32(r8g8b8, 16, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(10)
	<.main+?>: load.c32 16
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:34: (23 bytes): sxtG8: int32 := Bits.sxt32(r8g8b8, 8, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(11)
	<.main+?>: load.c32 8
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:35: (19 bytes): sxtB8: int32 := Bits.sxt32(r8g8b8, 0, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(12)
	<.main+?>: load.z32
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:37: (23 bytes): testSin_f64: float64 := Math.sin(pi64 / (2))
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(23)
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.sin(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:38: (23 bytes): testCos_f64: float64 := Math.cos(pi64 / (2))
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(25)
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.cos(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:39: (23 bytes): testTan_f64: float64 := Math.tan(pi64 / (4))
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(27)
	<.main+?>: load.f64 4.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.tan(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:40: (19 bytes): testLog_f64: float64 := Math.log(e64 * e64 * e64)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(27)
	<.main+?>: dup.x64 sp(29)
	<.main+?>: mul.f64
	<.main+?>: dup.x64 sp(29)
	<.main+?>: mul.f64
	<.main+?>: load.ref <?> ;Math.log(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:41: (20 bytes): testExp_f64: float64 := Math.exp(1.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 1.000000
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:42: (25 bytes): testPow_f64: float64 := Math.pow(pi64 * pi64, 0.500000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(33)
	<.main+?>: dup.x64 sp(35)
	<.main+?>: mul.f64
	<.main+?>: load.f64 0.500000
	<.main+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Bits.ci:43: (16 bytes): testSqrt_f64: float64 := Math.sqrt(pi64 * pi64)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(35)
	<.main+?>: dup.x64 sp(37)
	<.main+?>: mul.f64
	<.main+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:44: (22 bytes): testAtan_f64: float64 := Math.atan2(pi64, 1.000000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(37)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Bits.ci:46: (19 bytes): testSin_f32: float32 := Math.sin(pi32 / (2))
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(35)
	<.main+?>: load.f32 2.000000
	<.main+?>: div.f32
	<.main+?>: load.ref <?> ;Math.sin(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:47: (19 bytes): testCos_f32: float32 := Math.cos(pi32 / (2))
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(36)
	<.main+?>: load.f32 2.000000
	<.main+?>: div.f32
	<.main+?>: load.ref <?> ;Math.cos(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:48: (19 bytes): testTan_f32: float32 := Math.tan(pi32 / (4))
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(37)
	<.main+?>: load.f32 4.000000
	<.main+?>: div.f32
	<.main+?>: load.ref <?> ;Math.tan(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:49: (19 bytes): testLog_f32: float32 := Math.log(e32 * e32 * e32)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(37)
	<.main+?>: dup.x32 sp(38)
	<.main+?>: mul.f32
	<.main+?>: dup.x32 sp(38)
	<.main+?>: mul.f32
	<.main+?>: load.ref <?> ;Math.log(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:50: (16 bytes): testExp_f32: float32 := Math.exp(1.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 1.000000
	<.main+?>: load.ref <?> ;Math.exp(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:51: (21 bytes): testPow_f32: float32 := Math.pow(pi32 * pi32, 0.500000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(40)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: mul.f32
	<.main+?>: load.f32 0.500000
	<.main+?>: load.ref <?> ;Math.pow(x: float32, y: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:52: (16 bytes): testSqrt_f32: float32 := Math.sqrt(pi32 * pi32)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: mul.f32
	<.main+?>: load.ref <?> ;Math.sqrt(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:53: (18 bytes): testAtan_f32: float32 := Math.atan2(pi32, 1.000000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(42)
	<.main+?>: load.f32 1.000000
	<.main+?>: load.ref <?> ;Math.atan2(y: float32, x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:55: (13 bytes): testPopulation_u32: int32 := Bits.countOnes(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(38)
	<.main+?>: load.ref <?> ;Bits.countOnes(x: uint32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:56: (13 bytes): testSwapBits_u32: uint32 := Bits.swapBits(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(39)
	<.main+?>: load.ref <?> ;Bits.swapBits(x: uint32): uint32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:57: (13 bytes): testBitScanReverse_u32: int32 := Bits.scanReverse(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(40)
	<.main+?>: load.ref <?> ;Bits.scanReverse(x: uint32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:58: (13 bytes): testBitScanForward_u32: int32 := Bits.scanForward(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(41)
	<.main+?>: load.ref <?> ;Bits.scanForward(x: uint32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:59: (13 bytes): testHighBit_u32: int32 := Bits.keepMsb(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(42)
	<.main+?>: load.ref <?> ;Bits.keepMsb(x: uint32): uint32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:60: (10 bytes): testLowBit_u32: int32 := Bits.keepLsb(r5g6b5)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: neg.i32
	<.main+?>: and.b32
	<.main+?>: set.x32 sp(1)
	cmplStd/test/math/test.Bits.ci:62: (19 bytes): testZeroExtend_u32: int32 := Bits.zxt32(r5g6b5, 0, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(44)
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:63: (19 bytes): testSignExtend_u32: int32 := Bits.sxt32(r5g6b5, 0, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(45)
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:65: (21 bytes): testZeroExtend_u64: int32 := Bits.zxt64(r5g6b5, 0, 5)
	<.main+?>: load.z64
	<.main+?>: dup.x32 sp(47)
	<.main+?>: i32.2i64
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.zxt64(value: int64, offs: int32, count: int32): int64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: i64.2i32
	cmplStd/test/math/test.Bits.ci:66: (21 bytes): testSignExtend_u64: int32 := Bits.sxt64(r5g6b5, 0, 5)
	<.main+?>: load.z64
	<.main+?>: dup.x32 sp(48)
	<.main+?>: i32.2i64
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.sxt64(value: int64, offs: int32, count: int32): int64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: i64.2i32
	cmplStd/test/math/test.Math.ci:3: (20 bytes): testMathFloor_pos_3_0: float64 := Math.floor(3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.000000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:4: (20 bytes): testMathFloor_pos_3_2: float64 := Math.floor(3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.200000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:5: (20 bytes): testMathFloor_pos_3_5: float64 := Math.floor(3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.500000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:6: (20 bytes): testMathFloor_pos_3_7: float64 := Math.floor(3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.700000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:7: (20 bytes): testMathFloor_pos_3_9: float64 := Math.floor(3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.900000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:8: (20 bytes): testMathFloor_neg_3_0: float64 := Math.floor(-3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.000000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:9: (20 bytes): testMathFloor_neg_3_2: float64 := Math.floor(-3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.200000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:10: (20 bytes): testMathFloor_neg_3_5: float64 := Math.floor(-3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.500000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:11: (20 bytes): testMathFloor_neg_3_7: float64 := Math.floor(-3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.700000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:12: (20 bytes): testMathFloor_neg_3_9: float64 := Math.floor(-3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.900000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:14: (30 bytes): testMathRound_pos_3_0: float64 := Math.round(3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.000000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:15: (30 bytes): testMathRound_pos_3_2: float64 := Math.round(3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.200000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:16: (30 bytes): testMathRound_pos_3_5: float64 := Math.round(3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.500000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:17: (30 bytes): testMathRound_pos_3_7: float64 := Math.round(3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.700000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:18: (30 bytes): testMathRound_pos_3_9: float64 := Math.round(3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.900000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:19: (30 bytes): testMathRound_neg_3_0: float64 := Math.round(-3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.000000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:20: (30 bytes): testMathRound_neg_3_2: float64 := Math.round(-3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.200000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:21: (30 bytes): testMathRound_neg_3_5: float64 := Math.round(-3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.500000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:22: (30 bytes): testMathRound_neg_3_7: float64 := Math.round(-3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.700000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:23: (30 bytes): testMathRound_neg_3_9: float64 := Math.round(-3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.900000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:25: (21 bytes): testMathCeil_pos_3_0: float64 := Math.ceil(3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.000000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:26: (21 bytes): testMathCeil_pos_3_2: float64 := Math.ceil(3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.200000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:27: (21 bytes): testMathCeil_pos_3_5: float64 := Math.ceil(3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.500000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:28: (21 bytes): testMathCeil_pos_3_7: float64 := Math.ceil(3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.700000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:29: (21 bytes): testMathCeil_pos_3_9: float64 := Math.ceil(3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.900000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:30: (21 bytes): testMathCeil_neg_3_0: float64 := Math.ceil(-3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.000000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:31: (21 bytes): testMathCeil_neg_3_2: float64 := Math.ceil(-3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.200000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:32: (21 bytes): testMathCeil_neg_3_5: float64 := Math.ceil(-3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.500000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:33: (21 bytes): testMathCeil_neg_3_7: float64 := Math.ceil(-3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.700000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:34: (21 bytes): testMathCeil_neg_3_9: float64 := Math.ceil(-3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.900000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:36: (26 bytes): testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+?>: load.f64 0.200000
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: cgt.f64
	<.main+?>: dup.x64 sp(1)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: sub.i32
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:37: (18 bytes): testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: cgt.f64
	<.main+?>: dup.x64 sp(1)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: sub.i32
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:38: (26 bytes): testMathSign_3F: float64 := Math.sign(-0.900000)
	<.main+?>: load.f64 -0.900000
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: cgt.f64
	<.main+?>: dup.x64 sp(1)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: sub.i32
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:39: (17 bytes): testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+?>: load.f32 0.200000
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: cgt.f32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: sub.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:40: (13 bytes): testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: cgt.f32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: sub.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:41: (17 bytes): testMathSign_3f: float64 := Math.sign(-0.900000)
	<.main+?>: load.f32 -0.900000
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: cgt.f32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: sub.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:43: (28 bytes): testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+?>: load.f64 0.200000
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: jz +11
	<.main+?>: dup.x64 sp(0)
	<.main+?>: neg.f64
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:44: (20 bytes): testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: jz +11
	<.main+?>: dup.x64 sp(0)
	<.main+?>: neg.f64
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:45: (28 bytes): testMathAbs_3F: float64 := Math.abs(-0.900000)
	<.main+?>: load.f64 -0.900000
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: jz +11
	<.main+?>: dup.x64 sp(0)
	<.main+?>: neg.f64
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:46: (25 bytes): testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+?>: load.f32 0.200000
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: jz +11
	<.main+?>: dup.x32 sp(0)
	<.main+?>: neg.f32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:47: (21 bytes): testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: jz +11
	<.main+?>: dup.x32 sp(0)
	<.main+?>: neg.f32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:48: (25 bytes): testMathAbs_3f: float64 := Math.abs(-0.900000)
	<.main+?>: load.f32 -0.900000
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: jz +11
	<.main+?>: dup.x32 sp(0)
	<.main+?>: neg.f32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:50: (35 bytes): testMathMin_1f: float64 := Math.min(1.000000, 2.000000)
	<.main+?>: load.f32 1.000000
	<.main+?>: load.f32 2.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:51: (35 bytes): testMathMax_2f: float64 := Math.max(1.000000, 2.000000)
	<.main+?>: load.f32 1.000000
	<.main+?>: load.f32 2.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:52: (42 bytes): testMathMin_1F: float64 := Math.min(1.000000, 2.000000)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: clt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:53: (42 bytes): testMathMax_2F: float64 := Math.max(1.000000, 2.000000)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: cgt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:55: (60 bytes): testMathClamp_1f: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+?>: load.f32 10.000000
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.f32 1.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:56: (67 bytes): testMathClamp_1F: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+?>: load.f64 10.000000
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: cgt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: clt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:58: (21 bytes): testMathMix_1f: float64 := Math.mix(0.000000, 2.000000, 0.500000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.f32 0.500000
	<.main+?>: load.f32 2.000000
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.f32
	<.main+?>: mul.f32
	<.main+?>: add.f32
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:59: (28 bytes): testMathMix_1F: float64 := Math.mix(0.000000, 2.000000, 0.500000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.f64 0.500000
	<.main+?>: load.f64 2.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: sub.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:61: (97 bytes): testMathSmooth_1f: float64 := Math.smoothstep(0.000000, 1.000000, 1.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 1.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: sub.f32
	<.main+?>: load.f32 1.000000
	<.main+?>: dup.x32 sp(2)
	<.main+?>: sub.f32
	<.main+?>: div.f32
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.f32 1.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: mul.f32
	<.main+?>: load.f32 3.000000
	<.main+?>: load.f32 2.000000
	<.main+?>: dup.x32 sp(3)
	<.main+?>: mul.f32
	<.main+?>: sub.f32
	<.main+?>: mul.f32
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:62: (116 bytes): testMathSmooth_1F: float64 := Math.smoothstep(0.000000, 1.000000, 1.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: sub.f64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(4)
	<.main+?>: sub.f64
	<.main+?>: div.f64
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: cgt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: clt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	<.main+?>: dup.x64 sp(0)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: load.f64 3.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: mul.f64
	<.main+?>: sub.f64
	<.main+?>: mul.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:64: (21 bytes): testMathMin_nan: float64 := Math.min()
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.min(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(4, 2)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:65: (106 bytes): testMathMin_1: float64 := Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+?>: load.f64 6.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 9.000000
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 8.000000
	<.main+?>: load.f64 5.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 6.000000
	<.main+?>: load.c32 9
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.min(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(22, 2)
	<.main+?>: inc.sp(-88)
	cmplStd/test/math/test.Math.ci:66: (21 bytes): testMathMax_nan: float64 := Math.max()
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.max(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(4, 2)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:67: (106 bytes): testMathMax_9: float64 := Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+?>: load.f64 6.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 9.000000
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 8.000000
	<.main+?>: load.f64 5.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 6.000000
	<.main+?>: load.c32 9
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.max(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(22, 2)
	<.main+?>: inc.sp(-88)
	cmplStd/test/math/test.Math.ci:69: (21 bytes): testMathSum_0: float64 := Math.sum()
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(4, 2)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:70: (34 bytes): testMathSum_1: float64 := Math.sum(1)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(6, 2)
	<.main+?>: inc.sp(-24)
	cmplStd/test/math/test.Math.ci:71: (43 bytes): testMathSum_3: float64 := Math.sum(1, 2)
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 1.000000
	<.main+?>: load.c32 2
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(8, 2)
	<.main+?>: inc.sp(-32)
	cmplStd/test/math/test.Math.ci:72: (115 bytes): testMathSum_55: float64 := Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
	<.main+?>: load.f64 10.000000
	<.main+?>: load.f64 9.000000
	<.main+?>: load.f64 8.000000
	<.main+?>: load.f64 7.000000
	<.main+?>: load.f64 6.000000
	<.main+?>: load.f64 5.000000
	<.main+?>: load.f64 4.000000
	<.main+?>: load.f64 3.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 1.000000
	<.main+?>: load.c32 10
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(24, 2)
	<.main+?>: inc.sp(-96)
	cmplStd/test/math/test.Math.ci:74: (9 bytes): testMathEval_x: float64 := 10
	<.main+?>: load.f64 10.000000
	cmplStd/test/math/test.Math.ci:75: (23 bytes): testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(4)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.ref <?> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(6, 4)
	<.main+?>: inc.sp(-24)
	cmplStd/test/math/test.Math.ci:76: (9 bytes): testMathEval_1: float64 := Math.eval(testMathEval_x, 1.000000)
	<.main+?>: load.f64 1.000000
	cmplStd/test/math/test.Math.ci:77: (22 bytes): testMathEval_2: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	cmplStd/test/math/test.Math.ci:78: (39 bytes): testMathEval_3: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:79: (56 bytes): testMathEval_4: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:80: (73 bytes): testMathEval_5: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:81: (90 bytes): testMathEval_6: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+?>: dup.x64 sp(12)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:83: (30 bytes): testMathSin_f64: float64 := Math.sin(Math.pi / (2))
	<.main+?>: load.z64
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.sin(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:84: (30 bytes): testMathCos_f64: float64 := Math.cos(Math.pi / (2))
	<.main+?>: load.z64
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.cos(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:85: (30 bytes): testMathTan_f64: float64 := Math.tan(Math.pi / (4))
	<.main+?>: load.z64
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 4.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.tan(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:86: (72 bytes): testMathSinh_f64: float64 := Math.sinh(Math.pi / (2))
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: ceq.f64
	<.main+?>: jz +9
	<.main+?>: load.z64
	<.main+?>: jmp +42
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(4)
	<.main+?>: neg.f64
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: sub.f64
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:87: (80 bytes): testMathCosh_f64: float64 := Math.cosh(Math.pi / (2))
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: ceq.f64
	<.main+?>: jz +17
	<.main+?>: load.f64 1.000000
	<.main+?>: jmp +42
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(4)
	<.main+?>: neg.f64
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: add.f64
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:89: (60 bytes): testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+?>: load.f64 0.200000
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.z64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(8)
	<.main+?>: add.f64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(10)
	<.main+?>: sub.f64
	<.main+?>: mul.f64
	<.main+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:90: (59 bytes): testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+?>: load.f64 0.200000
	<.main+?>: load.z128
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: add.f64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(8)
	<.main+?>: sub.f64
	<.main+?>: mul.f64
	<.main+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:93: (29 bytes): testMathAbsMod_f64_0a: float64 := Math.absMod(10.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 10.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:94: (20 bytes): testMathAbsMod_f64_0b: float64 := Math.absMod(0.000000, 10.000000)
	<.main+?>: load.z128
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:95: (29 bytes): testMathAbsMod_f64_0c: float64 := Math.absMod(-10.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -10.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:97: (29 bytes): testMathAbsMod_f64_9a: float64 := Math.absMod(19.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 19.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:98: (29 bytes): testMathAbsMod_f64_9b: float64 := Math.absMod(9.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 9.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:99: (29 bytes): testMathAbsMod_f64_9c: float64 := Math.absMod(-1.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -1.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:100: (29 bytes): testMathAbsMod_f64_9d: float64 := Math.absMod(-11.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -11.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:102: (29 bytes): testMathAbsMod_f64_8a: float64 := Math.absMod(18.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 18.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:103: (29 bytes): testMathAbsMod_f64_8b: float64 := Math.absMod(8.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 8.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:104: (29 bytes): testMathAbsMod_f64_8c: float64 := Math.absMod(-2.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -2.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:105: (29 bytes): testMathAbsMod_f64_8d: float64 := Math.absMod(-12.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -12.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:107: (21 bytes): testMathAbsMod_f32_0a: float32 := Math.absMod(10.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 10.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:108: (17 bytes): testMathAbsMod_f32_0b: float32 := Math.absMod(0.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.z32
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:109: (21 bytes): testMathAbsMod_f32_0c: float32 := Math.absMod(-10.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -10.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:111: (21 bytes): testMathAbsMod_f32_9a: float32 := Math.absMod(19.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 19.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:112: (21 bytes): testMathAbsMod_f32_9b: float32 := Math.absMod(9.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 9.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:113: (21 bytes): testMathAbsMod_f32_9c: float32 := Math.absMod(-1.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -1.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:114: (21 bytes): testMathAbsMod_f32_9d: float32 := Math.absMod(-11.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -11.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:116: (21 bytes): testMathAbsMod_f32_8a: float32 := Math.absMod(18.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 18.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:117: (21 bytes): testMathAbsMod_f32_8b: float32 := Math.absMod(8.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 8.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:118: (21 bytes): testMathAbsMod_f32_8c: float32 := Math.absMod(-2.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -2.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:119: (21 bytes): testMathAbsMod_f32_8d: float32 := Math.absMod(-12.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -12.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Complex.ci:8: (26 bytes): valA: Complex := {...}
	<.main+?>: inc.sp(+16)
	cmplStd/test/math/test.Complex.ci:8: (11 bytes): valA.re := (9);
	<.main+?>: load.f64 9.000000
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Complex.ci:8: (11 bytes): valA.im := (2);
	<.main+?>: load.f64 2.000000
	<.main+?>: set.x64 sp(4)
	cmplStd/test/math/test.Complex.ci:9: (26 bytes): valB: Complex := {...}
	<.main+?>: inc.sp(+16)
	cmplStd/test/math/test.Complex.ci:9: (11 bytes): valB.re := (2);
	<.main+?>: load.f64 2.000000
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Complex.ci:9: (11 bytes): valB.im := (3);
	<.main+?>: load.f64 3.000000
	<.main+?>: set.x64 sp(4)
	cmplStd/test/math/test.Complex.ci:11: (24 bytes): Neg: Complex := Neg(valA)
	<.main+?>: dup.x128 sp(4)
	<.main+?>: inc.sp(+16)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: neg.f64
	<.main+?>: dup.x64 sp(8)
	<.main+?>: neg.f64
	<.main+?>: load.ref <?> ;Complex(real: float64, imaginary: float64): Complex
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: set.x128 sp(4)
	cmplStd/test/math/test.Complex.ci:12: (3 bytes): neg: Complex := neg(valA)
	<.main+?>: dup.x128 sp(8)
	<.main+?>: neg.v2d
	cmplStd/test/math/test.Complex.ci:14: (35 bytes): Add: Complex := Add(valA, valB)
	<.main+?>: dup.x128 sp(12)
	<.main+?>: dup.x128 sp(12)
	<.main+?>: inc.sp(+16)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: add.f64
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Complex(real: float64, imaginary: float64): Complex
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: mov.x128 sp(8, 0)
	<.main+?>: inc.sp(-32)
	cmplStd/test/math/test.Complex.ci:15: (5 bytes): add: Complex := add(valA, valB)
	<.main+?>: dup.x128 sp(16)
	<.main+?>: dup.x128 sp(16)
	<.main+?>: add.v2d
	cmplStd/test/math/test.Complex.ci:17: (35 bytes): Sub: Complex := Sub(valA, valB)
	<.main+?>: dup.x128 sp(20)
	<.main+?>: dup.x128 sp(20)
	<.main+?>: inc.sp(+16)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: sub.f64
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: sub.f64
	<.main+?>: load.ref <?> ;Complex(real: float64, imaginary: float64): Complex
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: mov.x128 sp(8, 0)
	<.main+?>: inc.sp(-32)
	cmplStd/test/math/test.Complex.ci:18: (5 bytes): sub: Complex := sub(valA, valB)
	<.main+?>: dup.x128 sp(24)
	<.main+?>: dup.x128 sp(24)
	<.main+?>: sub.v2d
	cmplStd/test/math/test.Complex.ci:20: (47 bytes): Mul: Complex := Mul(valA, valB)
	<.main+?>: dup.x128 sp(28)
	<.main+?>: dup.x128 sp(28)
	<.main+?>: inc.sp(+16)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: mul.f64
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: mul.f64
	<.main+?>: sub.f64
	<.main+?>: dup.x64 sp(10)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: mul.f64
	<.main+?>: dup.x64 sp(14)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Complex(real: float64, imaginary: float64): Complex
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: mov.x128 sp(8, 0)
	<.main+?>: inc.sp(-32)
	cmplStd/test/math/test.Complex.ci:21: (27 bytes): mul: Complex := mul(valA, valB)
	<.main+?>: dup.x128 sp(32)
	<.main+?>: dup.x128 sp(32)
	<.main+?>: dup.x128 sp(4)
	<.main+?>: dup.x128 sp(4)
	<.main+?>: swz.p4x zwxy(4e)
	<.main+?>: mul.v2d
	<.main+?>: add.f64
	<.main+?>: dup.x128 sp(6)
	<.main+?>: dup.x128 sp(6)
	<.main+?>: mul.v2d
	<.main+?>: swz.p4x zwxy(4e)
	<.main+?>: sub.f64
	<.main+?>: mov.x128 sp(8, 0)
	<.main+?>: inc.sp(-32)
	<.main+?>: nfc(0) ;halt(): void
}

---------- Execute: byte-code
cmplStd/test/lang/memory.ci:26: debug: val1: int64(42)
cmplStd/test/lang/memory.ci:27: debug: val2: int64(96)
cmplStd/test/lang/memory.ci:32: debug: val1: int64(0)
cmplStd/test/lang/memory.ci:33: debug: val2: int64(42)
cmplStd/test/lang/tryExec.ci:27: fatal: fatal error: NotEquals({
	message: char[*]("assertion failed"),
	expected: int32(97),
	returned: int32(77)
})
	native.code:: abortExecution(args: null)
	cmplStd/test/lang/tryExec.ci:45: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(1)
	cmplStd/test/lang/init.method.ci:78: staticMethod(this: <?>, x: 1)
	native.code:: .main
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(1)
	cmplStd/test/lang/init.method.ci:79: virtualMethod(this: <?>, x: 1)
	native.code:: .main
cmplStd/test/lang/init.method.ci:85: debug: extension.staticMethod
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(2)
	cmplStd/test/lang/init.method.ci:87: staticMethod(this: <?>, x: 2)
	cmplStd/test/lang/init.method.ci:97: staticMethod(this: <?>, x: 2)
	native.code:: .main
cmplStd/test/lang/init.method.ci:91: debug: extension.virtualMethod
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(2)
	cmplStd/test/lang/init.method.ci:93: virtualMethod(this: <?>, x: 2)
	cmplStd/test/lang/init.method.ci:98: virtualMethod(this: <?>, x: 2)
	native.code:: .main
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(3)
	cmplStd/test/lang/init.method.ci:101: staticMethod(this: <?>, x: 3)
	native.code:: .main
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:102: virtualMethod(this: <?>, x: 3)
	native.code:: .main
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:103: virtualMethod(this: <?>, x: 3)
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:4: debug: 0 == 0
	... 1 more
cmplStd/test/lang/stmt.if.ci:12: debug: 0 == 0
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:22: debug: 0 == 0
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:29: debug: t == 0: int32(0)
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:37: debug: t == 0: int32(0)
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:47: debug: t == 0: int32(0)
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:51: debug: t == 0: int32(0)
	native.code:: .main
cmplStd/test/lang/stmt.for.ci:4: debug: for ( ; ; )
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(2)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(3)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(4)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(5)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(6)
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(0)
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(1)
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(2)

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit.swz: typename(<emit.swz>)
emit: typename(<emit>)
System.Platform: typename(<System.Platform>)
System: typename(<System>)
cmplStd/lib/lang/Debug.ci:32: NotEquals: typename(<NotEquals>)
cmplStd/lib/lang/Debug.ci:44: NotEquals: function(<NotEquals>)
cmplStd/lib/lang/Debug.ci:59: assertEq: function(<assertEq>)
cmplStd/lib/math/Bits.ci:40: Bits.zxt32: function(<Bits.zxt32>)
cmplStd/lib/math/Bits.ci:50: Bits.sxt32: function(<Bits.sxt32>)
cmplStd/lib/math/Bits.ci:60: Bits.zxt64: function(<Bits.zxt64>)
cmplStd/lib/math/Bits.ci:70: Bits.sxt64: function(<Bits.sxt64>)
cmplStd/lib/math/Bits.ci:80: Bits.swapBytes: function(<Bits.swapBytes>)
cmplStd/lib/math/Bits.ci:88: Bits.swapBytes: function(<Bits.swapBytes>)
cmplStd/lib/math/Bits.ci:95: Bits.swapBytes: function(<Bits.swapBytes>)
cmplStd/lib/math/Bits.ci:110: Bits.scanReverse: function(<Bits.scanReverse>)
cmplStd/lib/math/Bits.ci:150: Bits.scanReverse: function(<Bits.scanReverse>)
cmplStd/lib/math/Bits.ci:186: Bits.scanReverse: function(<Bits.scanReverse>)
cmplStd/lib/math/Bits.ci:214: Bits.scanReverse: function(<Bits.scanReverse>)
cmplStd/lib/math/Bits.ci:239: Bits.scanForward: function(<Bits.scanForward>)
cmplStd/lib/math/Bits.ci:280: Bits.scanForward: function(<Bits.scanForward>)
cmplStd/lib/math/Bits.ci:317: Bits.scanForward: function(<Bits.scanForward>)
cmplStd/lib/math/Bits.ci:345: Bits.scanForward: function(<Bits.scanForward>)
cmplStd/lib/math/Bits.ci:370: Bits.keepMsb: function(<Bits.keepMsb>)
cmplStd/lib/math/Bits.ci:389: Bits.keepMsb: function(<Bits.keepMsb>)
cmplStd/lib/math/Bits.ci:433: Bits.countOnes: function(<Bits.countOnes>)
cmplStd/lib/math/Bits.ci:452: Bits.countOnes: function(<Bits.countOnes>)
cmplStd/lib/math/Bits.ci:471: Bits.swapBits: function(<Bits.swapBits>)
cmplStd/lib/math/Bits.ci:489: Bits.swapBits: function(<Bits.swapBits>)
cmplStd/lib/math/Bits.ci:506: Bits.swapBits: function(<Bits.swapBits>)
cmplStd/lib/math/Bits.ci:517: Bits.swapBits: function(<Bits.swapBits>)
cmplStd/lib/math/Bits.ci:528: Bits.clamp: function(<Bits.clamp>)
cmplStd/lib/math/Bits.ci:537: Bits.clamp: function(<Bits.clamp>)
cmplStd/lib/math/Bits.ci:2: Bits: typename(<Bits>)
cmplStd/lib/math/Math.ci:23: Math.isNan: function(<Math.isNan>)
cmplStd/lib/math/Math.ci:29: Math.isInf: function(<Math.isInf>)
cmplStd/lib/math/Math.ci:34: Math.isFinite: function(<Math.isFinite>)
cmplStd/lib/math/Math.ci:40: Math.isInf: function(<Math.isInf>)
cmplStd/lib/math/Math.ci:52: Math.floor: function(<Math.floor>)
cmplStd/lib/math/Math.ci:61: Math.floor: function(<Math.floor>)
cmplStd/lib/math/Math.ci:102: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math/Math.ci:110: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math/Math.ci:209: Math.min: function(<Math.min>)
cmplStd/lib/math/Math.ci:223: Math.max: function(<Math.max>)
cmplStd/lib/math/Math.ci:237: Math.sum: function(<Math.sum>)
cmplStd/lib/math/Math.ci:246: Math.mean: function(<Math.mean>)
cmplStd/lib/math/Math.ci:269: Math.eval: function(<Math.eval>)
cmplStd/lib/math/Math.ci:278: Math.modf: function(<Math.modf>)
cmplStd/lib/math/Math.ci:293: Math.copysign: function(<Math.copysign>)
cmplStd/lib/math/Math.ci:309: Math.frexp: function(<Math.frexp>)
cmplStd/lib/math/Math.ci:350: Math.ldexp: function(<Math.ldexp>)
cmplStd/lib/math/Math.ci:397: Math.log: function(<Math.log>)
cmplStd/lib/math/Math.ci:444: Math.log: function(<Math.log>)
cmplStd/lib/math/Math.ci:465: Math.exp: function(<Math.exp>)
cmplStd/lib/math/Math.ci:521: Math.exp: function(<Math.exp>)
cmplStd/lib/math/Math.ci:532: Math.sqrt: function(<Math.sqrt>)
cmplStd/lib/math/Math.ci:596: Math.sqrt: function(<Math.sqrt>)
cmplStd/lib/math/Math.ci:607: Math.pow: function(<Math.pow>)
cmplStd/lib/math/Math.ci:687: Math.pow: function(<Math.pow>)
cmplStd/lib/math/Math.ci:698: Math.sincos: function(<Math.sincos>)
cmplStd/lib/math/Math.ci:746: Math.tancot: function(<Math.tancot>)
cmplStd/lib/math/Math.ci:820: Math.atan: function(<Math.atan>)
cmplStd/lib/math/Math.ci:865: Math.atan2: function(<Math.atan2>)
cmplStd/lib/math/Math.ci:889: Math.atan2: function(<Math.atan2>)
cmplStd/lib/math/Math.ci:900: Math.sin: function(<Math.sin>)
cmplStd/lib/math/Math.ci:910: Math.sin: function(<Math.sin>)
cmplStd/lib/math/Math.ci:930: Math.cos: function(<Math.cos>)
cmplStd/lib/math/Math.ci:943: Math.cos: function(<Math.cos>)
cmplStd/lib/math/Math.ci:963: Math.tan: function(<Math.tan>)
cmplStd/lib/math/Math.ci:985: Math.tan: function(<Math.tan>)
cmplStd/lib/math/Math.ci:1002: Math.cot: function(<Math.cot>)
cmplStd/lib/math/Math.ci:2: Math: typename(<Math>)
cmplStd/lib/math/Fixed.ci:35: Fixed.as: function(<Fixed.as>)
cmplStd/lib/math/Fixed.ci:38: Fixed.neg: function(<Fixed.neg>)
cmplStd/lib/math/Fixed.ci:41: Fixed.add: function(<Fixed.add>)
cmplStd/lib/math/Fixed.ci:44: Fixed.sub: function(<Fixed.sub>)
cmplStd/lib/math/Fixed.ci:47: Fixed.mul: function(<Fixed.mul>)
cmplStd/lib/math/Fixed.ci:48: Fixed.mul: function(<Fixed.mul>)
cmplStd/lib/math/Fixed.ci:49: Fixed.mul_28: function(<Fixed.mul_28>)
cmplStd/lib/math/Fixed.ci:52: Fixed.div: function(<Fixed.div>)
cmplStd/lib/math/Fixed.ci:61: Fixed.div: function(<Fixed.div>)
cmplStd/lib/math/Fixed.ci:64: Fixed.mod: function(<Fixed.mod>)
cmplStd/lib/math/Fixed.ci:67: Fixed.inv: function(<Fixed.inv>)
cmplStd/lib/math/Fixed.ci:80: Fixed.fract: function(<Fixed.fract>)
cmplStd/lib/math/Fixed.ci:88: Fixed.floor: function(<Fixed.floor>)
cmplStd/lib/math/Fixed.ci:93: Fixed.ceil: function(<Fixed.ceil>)
cmplStd/lib/math/Fixed.ci:98: Fixed.round: function(<Fixed.round>)
cmplStd/lib/math/Fixed.ci:103: Fixed.isFinite: function(<Fixed.isFinite>)
cmplStd/lib/math/Fixed.ci:116: Fixed.isNan: function(<Fixed.isNan>)
cmplStd/lib/math/Fixed.ci:121: Fixed.compare: function(<Fixed.compare>)
cmplStd/lib/math/Fixed.ci:134: Fixed.log2: function(<Fixed.log2>)
cmplStd/lib/math/Fixed.ci:198: Fixed.log: function(<Fixed.log>)
cmplStd/lib/math/Fixed.ci:215: Fixed.log10: function(<Fixed.log10>)
cmplStd/lib/math/Fixed.ci:231: Fixed.log: function(<Fixed.log>)
cmplStd/lib/math/Fixed.ci:254: Fixed.pow2: function(<Fixed.pow2>)
cmplStd/lib/math/Fixed.ci:322: Fixed.exp: function(<Fixed.exp>)
cmplStd/lib/math/Fixed.ci:334: Fixed.exp10: function(<Fixed.exp10>)
cmplStd/lib/math/Fixed.ci:346: Fixed.sqrt: function(<Fixed.sqrt>)
cmplStd/lib/math/Fixed.ci:382: Fixed.pow: function(<Fixed.pow>)
cmplStd/lib/math/Fixed.ci:451: Fixed.sin: function(<Fixed.sin>)
cmplStd/lib/math/Fixed.ci:490: Fixed.sinh: function(<Fixed.sinh>)
cmplStd/lib/math/Fixed.ci:530: Fixed.cos: function(<Fixed.cos>)
cmplStd/lib/math/Fixed.ci:605: Fixed.tan: function(<Fixed.tan>)
cmplStd/lib/math/Fixed.ci:714: Fixed.degrees: function(<Fixed.degrees>)
cmplStd/lib/math/Fixed.ci:719: Fixed.radians: function(<Fixed.radians>)
cmplStd/lib/math/Fixed.ci:2: Fixed: typename(<Fixed>)
cmplStd/lib/math/Fixed.ci:732: Fixed: function(<Fixed>)
cmplStd/lib/math/Fixed.ci:750: float64: function(<float64>)
cmplStd/lib/math/Complex.ci:2: Complex: typename(<Complex>)
cmplStd/lib/math/Complex.ci:12: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:19: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:54: div: function(<div>)
cmplStd/lib/math/Complex.ci:84: inv: function(<inv>)
cmplStd/lib/math/Complex.ci:102: pow: function(<pow>)
cmplStd/lib/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
cmplStd/lib/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:87: transpose: function(<transpose>)
cmplStd/lib/math/Matrix4f.ci:97: mul: function(<mul>)
cmplStd/lib/math/Matrix4f.ci:109: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:158: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:191: translation: function(<translation>)
cmplStd/lib/math/Matrix4f.ci:201: scale: function(<scale>)
cmplStd/lib/math/Matrix4f.ci:213: inverse: function(<inverse>)
cmplStd/lib/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
cmplStd/lib/math/Vector2d.ci:14: vec2d: function(<vec2d>)
cmplStd/lib/time/Timeunit.ci:2: Timeunit: typename(<Timeunit>)
cmplStd/lib/time/Timeunit.ci:14: convert: function(<convert>)
cmplStd/lib/time/Timeunit.ci:24: convert: function(<convert>)
cmplStd/lib/time/Duration.ci:8: Duration.precision: Timeunit(1000000)
cmplStd/lib/time/Duration.ci:11: Duration.value: function(<Duration.value>)
cmplStd/lib/time/Duration.ci:16: Duration.add: function(<Duration.add>)
cmplStd/lib/time/Duration.ci:5: Duration: typename(<Duration>)
cmplStd/lib/time/Duration.ci:22: Duration: function(<Duration>)
cmplStd/lib/time/Timestamp.ci:9: Timestamp.precision: Timeunit(1000000)
cmplStd/lib/time/Timestamp.ci:12: Timestamp.value: function(<Timestamp.value>)
cmplStd/lib/time/Timestamp.ci:17: Timestamp.diff: function(<Timestamp.diff>)
cmplStd/lib/time/Timestamp.ci:22: Timestamp.diff: function(<Timestamp.diff>)
cmplStd/lib/time/Timestamp.ci:27: Timestamp.compare: function(<Timestamp.compare>)
cmplStd/lib/time/Timestamp.ci:32: Timestamp.equal: function(<Timestamp.equal>)
cmplStd/lib/time/Timestamp.ci:37: Timestamp.equal: function(<Timestamp.equal>)
cmplStd/lib/time/Timestamp.ci:42: Timestamp.add: function(<Timestamp.add>)
cmplStd/lib/time/Timestamp.ci:55: Timestamp.floor: function(<Timestamp.floor>)
cmplStd/lib/time/Timestamp.ci:73: Timestamp.ceil: function(<Timestamp.ceil>)
cmplStd/lib/time/Timestamp.ci:94: Timestamp.distribute: function(<Timestamp.distribute>)
cmplStd/lib/time/Timestamp.ci:109: Timestamp.distribute: function(<Timestamp.distribute>)
cmplStd/lib/time/Timestamp.ci:114: Timestamp.now: function(<Timestamp.now>)
cmplStd/lib/time/Timestamp.ci:5: Timestamp: typename(<Timestamp>)
cmplStd/lib/time/Timestamp.ci:120: Timestamp: function(<Timestamp>)
cmplStd/lib/time/Timezone.ci:6: Timezone.offset: function(<Timezone.offset>)
cmplStd/lib/time/Timezone.ci:11: Timezone.utc: function(<Timezone.utc>)
cmplStd/lib/time/Timezone.ci:22: Timezone.lookup: function(<Timezone.lookup>)
cmplStd/lib/time/Timezone.ci:24: Timezone.local: function(<Timezone.local>)
cmplStd/lib/time/Timezone.ci:2: Timezone: typename(<Timezone>)
cmplStd/lib/time/Datetime.ci:2: Month: typename(<Month>)
cmplStd/lib/time/Datetime.ci:22: Weekday: typename(<Weekday>)
cmplStd/lib/time/Datetime.ci:37: Calendar: typename(<Calendar>)
cmplStd/lib/time/Datetime.ci:97: Datetime.DaysToMonth365: int32[13]([13] {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365})
cmplStd/lib/time/Datetime.ci:98: Datetime.DaysToMonth366: int32[13]([13] {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366})
cmplStd/lib/time/Datetime.ci:99: Datetime.DaysTil1970: int32(719162)
cmplStd/lib/time/Datetime.ci:102: Datetime.isLeapYear: function(<Datetime.isLeapYear>)
cmplStd/lib/time/Datetime.ci:116: Datetime.add: function(<Datetime.add>)
cmplStd/lib/time/Datetime.ci:57: Datetime: typename(<Datetime>)
cmplStd/lib/time/Datetime.ci:149: Timestamp: function(<Timestamp>)
cmplStd/lib/time/Datetime.ci:179: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:273: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:291: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:296: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:301: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:306: Datetime: function(<Datetime>)
cmplStd/lib/text/cstr.ci:4: length: function(<length>)
cmplStd/lib/text/cstr.ci:15: indexOf: function(<indexOf>)
cmplStd/lib/text/cstr.ci:25: lastIndexOf: function(<lastIndexOf>)
cmplStd/lib/text/cstr.ci:36: startsWith: function(<startsWith>)
cmplStd/lib/text/cstr.ci:46: endsWith: function(<endsWith>)
cmplStd/lib/text/cstr.ci:61: compare: function(<compare>)
cmplStd/lib/text/cstr.ci:73: ignCaseCmp: function(<ignCaseCmp>)
cmplStd/lib/text/cstr.ci:88: caseCmp: function(<caseCmp>)
cmplStd/lib/text/cstr.ci:117: float64: function(<float64>)
cmplStd/lib/text/Format.ci:19: FormatFlags.read: function(<FormatFlags.read>)
cmplStd/lib/text/Format.ci:73: FormatFlags.defPad: function(<FormatFlags.defPad>)
cmplStd/lib/text/Format.ci:2: FormatFlags: typename(<FormatFlags>)
cmplStd/lib/text/Format.ci:87: append: function(<append>)
cmplStd/lib/text/Format.ci:107: append: function(<append>)
cmplStd/lib/text/Format.ci:170: append: function(<append>)
cmplStd/lib/text/Format.ci:184: append: function(<append>)
cmplStd/lib/text/Format.ci:313: DatetimeFormat.format: function(<DatetimeFormat.format>)
cmplStd/lib/text/Format.ci:501: DatetimeFormat.format: function(<DatetimeFormat.format>)
cmplStd/lib/text/Format.ci:298: DatetimeFormat: typename(<DatetimeFormat>)
cmplStd/lib/text/Format.ci:507: format: function(<format>)
cmplStd/lib/text/Format.ci:563: append: function(<append>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/ByteStream.ci:2: Closeable: typename(<Closeable>)
cmplStd/lib/text/stream/ByteStream.ci:26: ByteReader.read: function(<ByteReader.read>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/ByteStream.ci:17: ByteReader: typename(<ByteReader>)
cmplStd/lib/text/stream/ByteStream.ci:56: ByteWriter.write: function(<ByteWriter.write>)
cmplStd/lib/text/stream/ByteStream.ci:76: ByteWriter.copy: function(<ByteWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/ByteStream.ci:44: ByteWriter: typename(<ByteWriter>)
cmplStd/lib/text/stream/ByteStream.ci:104: CopyReader.read: function(<CopyReader.read>)
cmplStd/lib/text/stream/ByteStream.ci:113: CopyReader.close: function(<CopyReader.close>)
cmplStd/lib/text/stream/ByteStream.ci:26: ByteReader.read: function(<ByteReader.read>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/ByteStream.ci:99: CopyReader: typename(<CopyReader>)
cmplStd/lib/text/stream/ByteStream.ci:126: ByteBuffer.read: function(<ByteBuffer.read>)
cmplStd/lib/text/stream/ByteStream.ci:140: ByteBuffer.read: function(<ByteBuffer.read>)
cmplStd/lib/text/stream/ByteStream.ci:149: ByteBuffer.write: function(<ByteBuffer.write>)
cmplStd/lib/text/stream/ByteStream.ci:175: ByteBuffer.flush: function(<ByteBuffer.flush>)
cmplStd/lib/text/stream/ByteStream.ci:179: ByteBuffer.close: function(<ByteBuffer.close>)
cmplStd/lib/text/stream/ByteStream.ci:120: ByteBuffer: typename(<ByteBuffer>)
cmplStd/lib/text/stream/TextStream.ci:19: TextReader.close: function(<TextReader.close>)
cmplStd/lib/text/stream/TextStream.ci:25: TextReader.decode: function(<TextReader.decode>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/TextStream.ci:7: TextReader: typename(<TextReader>)
cmplStd/lib/text/stream/TextStream.ci:50: TextWriter.Writeable: typename(<TextWriter.Writeable>)
cmplStd/lib/text/stream/TextStream.ci:67: TextWriter.flush: function(<TextWriter.flush>)
cmplStd/lib/text/stream/TextStream.ci:72: TextWriter.close: function(<TextWriter.close>)
cmplStd/lib/text/stream/TextStream.ci:78: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:84: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:90: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:98: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:105: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:112: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:119: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:126: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:133: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:140: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:146: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:151: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:168: TextWriter.copy: function(<TextWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/TextStream.ci:48: TextWriter: typename(<TextWriter>)
cmplStd/lib/text/encoding/binary/Base64.ci:3: Base64Encoder.lookup: uint8[]([64] {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, ...})
cmplStd/lib/text/encoding/binary/Base64.ci:16: Base64Encoder.flushBuffer: function(<Base64Encoder.flushBuffer>)
cmplStd/lib/text/encoding/binary/Base64.ci:41: Base64Encoder.write: function(<Base64Encoder.write>)
cmplStd/lib/text/encoding/binary/Base64.ci:124: Base64Encoder.flush: function(<Base64Encoder.flush>)
cmplStd/lib/text/encoding/binary/Base64.ci:129: Base64Encoder.close: function(<Base64Encoder.close>)
cmplStd/lib/text/stream/ByteStream.ci:56: ByteWriter.write: function(<ByteWriter.write>)
cmplStd/lib/text/stream/ByteStream.ci:76: ByteWriter.copy: function(<ByteWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/binary/Base64.ci:2: Base64Encoder: typename(<Base64Encoder>)
cmplStd/lib/text/encoding/binary/Base64.ci:136: Base64Decoder.lookup: int32[256]([256] {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, ...})
cmplStd/lib/text/encoding/binary/Base64.ci:162: Base64Decoder.read: function(<Base64Decoder.read>)
cmplStd/lib/text/encoding/binary/Base64.ci:190: Base64Decoder.close: function(<Base64Decoder.close>)
cmplStd/lib/text/stream/ByteStream.ci:26: ByteReader.read: function(<ByteReader.read>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/binary/Base64.ci:135: Base64Decoder: typename(<Base64Decoder>)
cmplStd/lib/text/encoding/Ascii.ci:4: AsciiReader.decode: function(<AsciiReader.decode>)
cmplStd/lib/text/stream/TextStream.ci:19: TextReader.close: function(<TextReader.close>)
cmplStd/lib/text/stream/TextStream.ci:25: TextReader.decode: function(<TextReader.decode>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/Ascii.ci:2: AsciiReader: typename(<AsciiReader>)
cmplStd/lib/text/encoding/Ascii.ci:21: AsciiWriter.encode: function(<AsciiWriter.encode>)
cmplStd/lib/text/stream/TextStream.ci:50: TextWriter.Writeable: typename(<TextWriter.Writeable>)
cmplStd/lib/text/stream/TextStream.ci:67: TextWriter.flush: function(<TextWriter.flush>)
cmplStd/lib/text/stream/TextStream.ci:72: TextWriter.close: function(<TextWriter.close>)
cmplStd/lib/text/stream/TextStream.ci:78: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:84: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:90: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:98: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:105: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:112: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:119: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:126: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:133: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:140: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:146: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:151: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:168: TextWriter.copy: function(<TextWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/Ascii.ci:19: AsciiWriter: typename(<AsciiWriter>)
cmplStd/lib/text/encoding/Utf8.ci:4: Utf8Reader.decode: function(<Utf8Reader.decode>)
cmplStd/lib/text/stream/TextStream.ci:19: TextReader.close: function(<TextReader.close>)
cmplStd/lib/text/stream/TextStream.ci:25: TextReader.decode: function(<TextReader.decode>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/Utf8.ci:2: Utf8Reader: typename(<Utf8Reader>)
cmplStd/lib/text/encoding/Utf8.ci:53: Utf8Writer.encode: function(<Utf8Writer.encode>)
cmplStd/lib/text/stream/TextStream.ci:50: TextWriter.Writeable: typename(<TextWriter.Writeable>)
cmplStd/lib/text/stream/TextStream.ci:67: TextWriter.flush: function(<TextWriter.flush>)
cmplStd/lib/text/stream/TextStream.ci:72: TextWriter.close: function(<TextWriter.close>)
cmplStd/lib/text/stream/TextStream.ci:78: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:84: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:90: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:98: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:105: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:112: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:119: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:126: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:133: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:140: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:146: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:151: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:168: TextWriter.copy: function(<TextWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/Utf8.ci:51: Utf8Writer: typename(<Utf8Writer>)
cmplStd/lib/math/Easing.ci:6: Easing.linear: function(<Easing.linear>)
cmplStd/lib/math/Easing.ci:11: Easing.quad: function(<Easing.quad>)
cmplStd/lib/math/Easing.ci:16: Easing.cubic: function(<Easing.cubic>)
cmplStd/lib/math/Easing.ci:21: Easing.quart: function(<Easing.quart>)
cmplStd/lib/math/Easing.ci:26: Easing.quint: function(<Easing.quint>)
cmplStd/lib/math/Easing.ci:31: Easing.expo: function(<Easing.expo>)
cmplStd/lib/math/Easing.ci:36: Easing.sine: function(<Easing.sine>)
cmplStd/lib/math/Easing.ci:41: Easing.circle: function(<Easing.circle>)
cmplStd/lib/math/Easing.ci:46: Easing.elastic: function(<Easing.elastic>)
cmplStd/lib/math/Easing.ci:53: Easing.back: function(<Easing.back>)
cmplStd/lib/math/Easing.ci:59: Easing.bounce: function(<Easing.bounce>)
cmplStd/lib/math/Easing.ci:4: Easing: typename(<Easing>)
cmplStd/lib/math/Easing.ci:84: in: function(<in>)
cmplStd/lib/math/Easing.ci:92: out: function(<out>)
cmplStd/lib/math/Easing.ci:100: inOut: function(<inOut>)
cmplStd/lib/math/Easing.ci:109: outIn: function(<outIn>)
cmplStd/lib/math/Polynomial.ci:14: Polynomial.write: function(<Polynomial.write>)
cmplStd/lib/math/Polynomial.ci:54: Polynomial.destroy: function(<Polynomial.destroy>)
cmplStd/lib/math/Polynomial.ci:59: Polynomial.create: function(<Polynomial.create>)
cmplStd/lib/math/Polynomial.ci:79: Polynomial.degree: function(<Polynomial.degree>)
cmplStd/lib/math/Polynomial.ci:89: Polynomial.get: function(<Polynomial.get>)
cmplStd/lib/math/Polynomial.ci:98: Polynomial.set: function(<Polynomial.set>)
cmplStd/lib/math/Polynomial.ci:105: Polynomial.neg: function(<Polynomial.neg>)
cmplStd/lib/math/Polynomial.ci:114: Polynomial.add: function(<Polynomial.add>)
cmplStd/lib/math/Polynomial.ci:123: Polynomial.sub: function(<Polynomial.sub>)
cmplStd/lib/math/Polynomial.ci:132: Polynomial.mul: function(<Polynomial.mul>)
cmplStd/lib/math/Polynomial.ci:145: Polynomial.evaluate: function(<Polynomial.evaluate>)
cmplStd/lib/math/Polynomial.ci:154: Polynomial.derivative: function(<Polynomial.derivative>)
cmplStd/lib/math/Polynomial.ci:163: Polynomial.integral: function(<Polynomial.integral>)
cmplStd/lib/math/Polynomial.ci:4: Polynomial: typename(<Polynomial>)
cmplStd/lib/math/Polynomial.ci:177: Polynomial: function(<Polynomial>)
File: typename(<File>)
cmplFile/lib.ci:2: read: function(<read>)
cmplFile/lib.ci:11: write: function(<write>)
cmplFile/lib/FileStream.ci:5: FileReader.read: function(<FileReader.read>)
cmplFile/lib/FileStream.ci:9: FileReader.close: function(<FileReader.close>)
cmplStd/lib/text/stream/ByteStream.ci:26: ByteReader.read: function(<ByteReader.read>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplFile/lib/FileStream.ci:2: FileReader: typename(<FileReader>)
cmplFile/lib/FileStream.ci:19: FileWriter.write: function(<FileWriter.write>)
cmplFile/lib/FileStream.ci:24: FileWriter.flush: function(<FileWriter.flush>)
cmplFile/lib/FileStream.ci:28: FileWriter.close: function(<FileWriter.close>)
cmplStd/lib/text/stream/ByteStream.ci:56: ByteWriter.write: function(<ByteWriter.write>)
cmplStd/lib/text/stream/ByteStream.ci:76: ByteWriter.copy: function(<ByteWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplFile/lib/FileStream.ci:15: FileWriter: typename(<FileWriter>)
cmplFile/lib/FileStream.ci:38: BufferedFileWriter.flushBuffer: function(<BufferedFileWriter.flushBuffer>)
cmplFile/lib/FileStream.ci:44: BufferedFileWriter.write: function(<BufferedFileWriter.write>)
cmplFile/lib/FileStream.ci:64: BufferedFileWriter.flush: function(<BufferedFileWriter.flush>)
cmplFile/lib/FileStream.ci:69: BufferedFileWriter.close: function(<BufferedFileWriter.close>)
cmplFile/lib/FileStream.ci:19: FileWriter.write: function(<FileWriter.write>)
cmplFile/lib/FileStream.ci:24: FileWriter.flush: function(<FileWriter.flush>)
cmplFile/lib/FileStream.ci:28: FileWriter.close: function(<FileWriter.close>)
cmplStd/lib/text/stream/ByteStream.ci:56: ByteWriter.write: function(<ByteWriter.write>)
cmplStd/lib/text/stream/ByteStream.ci:76: ByteWriter.copy: function(<ByteWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplFile/lib/FileStream.ci:34: BufferedFileWriter: typename(<BufferedFileWriter>)
cmplFile/lib/FileStream.ci:76: FileReader: function(<FileReader>)
cmplFile/lib/FileStream.ci:83: FileWriter: function(<FileWriter>)
cmplFile/lib/FileStream.ci:90: BufferedFileWriter: function(<BufferedFileWriter>)
Rect: typename(<Rect>)
Image: typename(<Image>)
Mesh: typename(<Mesh>)
lights: typename(<lights>)
Window: typename(<Window>)
cmplGfx/lib/rect.ci:2: empty: function(<empty>)
cmplGfx/lib/rect.ci:8: contains: function(<contains>)
cmplGfx/lib/rect.ci:15: width: function(<width>)
cmplGfx/lib/rect.ci:22: height: function(<height>)
cmplGfx/lib/rect.ci:27: setSize: function(<setSize>)
cmplGfx/lib/rect.ci:33: positionX: function(<positionX>)
cmplGfx/lib/rect.ci:38: positionY: function(<positionY>)
cmplGfx/lib/rect.ci:44: position: function(<position>)
cmplGfx/lib/rect.ci:50: adjust: function(<adjust>)
cmplGfx/lib/rect.ci:58: padded: function(<padded>)
cmplGfx/lib/rect.ci:68: translateX: function(<translateX>)
cmplGfx/lib/rect.ci:73: translateY: function(<translateY>)
cmplGfx/lib/color.ci:2: argb: typename(<argb>)
cmplGfx/lib/color.ci:80: hue: function(<hue>)
cmplGfx/lib/color.ci:128: lerpLut: function(<lerpLut>)
cmplGfx/lib/color.ci:143: alphaLut: function(<alphaLut>)
cmplGfx/lib/color.hsl.ci:3: rgb2hsl: function(<rgb2hsl>)
cmplGfx/lib/color.hsl.ci:61: hsl2rgb: function(<hsl2rgb>)
cmplGfx/lib/image.ci:5: Image: function(<Image>)
cmplGfx/lib/image.ci:31: clip: function(<clip>)
cmplGfx/lib/image.draw.rect.ci:2: fillRect: function(<fillRect>)
cmplGfx/lib/image.draw.rect.ci:31: drawRect: function(<drawRect>)
cmplGfx/lib/image.draw.rect.ci:65: fillRect: function(<fillRect>)
cmplGfx/lib/image.draw.rect.ci:73: drawRect: function(<drawRect>)
cmplGfx/lib/image.draw.rrect.ci:2: fillRRect: function(<fillRRect>)
cmplGfx/lib/image.draw.rrect.ci:61: drawRRect: function(<drawRRect>)
cmplGfx/lib/image.draw.rrect.ci:131: fillRRect: function(<fillRRect>)
cmplGfx/lib/image.draw.oval.ci:8: fillOval: function(<fillOval>)
cmplGfx/lib/image.draw.oval.ci:16: drawOval: function(<drawOval>)
cmplGfx/lib/image.draw.line.ci:2: drawLineIncl: function(<drawLineIncl>)
cmplGfx/lib/image.draw.line.ci:79: drawLine: function(<drawLine>)
cmplGfx/lib/image.draw.line.ci:85: drawBezier: function(<drawBezier>)
cmplGfx/lib/image.draw.line.ci:105: drawBezier: function(<drawBezier>)
cmplGfx/lib/image.draw.ci:14: fill: function(<fill>)
cmplGfx/lib/image.draw.ci:20: drawText: function(<drawText>)
cmplGfx/lib/image.blend.ci:2: blend: function(<blend>)
cmplGfx/lib/image.blend.ci:53: blend: function(<blend>)
cmplGfx/lib/image.blend.ci:67: blend: function(<blend>)
cmplGfx/lib/image.blend.ci:84: blendAlpha: function(<blendAlpha>)
cmplGfx/lib/image.blend.ci:101: blendDstAlpha: function(<blendDstAlpha>)
cmplGfx/lib/image.blend.ci:119: copy: function(<copy>)
cmplGfx/lib/image.blend.ci:124: Image: function(<Image>)
cmplGfx/lib/image.blend.ci:131: tile: function(<tile>)
cmplGfx/lib/image.blend.ci:159: eval: function(<eval>)
cmplGfx/lib/image.transform.ci:2: transform: function(<transform>)
cmplGfx/lib/image.transform.ci:67: Image: function(<Image>)
cmplGfx/lib/image.transform.ci:136: Image: function(<Image>)
cmplGfx/lib/image.blur.ci:2: blur: function(<blur>)
cmplGfx/lib/color.lookup.ci:2: colorMap: function(<colorMap>)
cmplGfx/lib/color.matrix.ci:2: colorMat: function(<colorMat>)
cmplGfx/lib/mesh.ci:2: Mesh: function(<Mesh>)
cmplGfx/lib/camera.ci:13: Camera.projection: function(<Camera.projection>)
cmplGfx/lib/camera.ci:40: Camera.lookAt: function(<Camera.lookAt>)
cmplGfx/lib/camera.ci:52: Camera.matrix: function(<Camera.matrix>)
cmplGfx/lib/camera.ci:62: Camera.matrix: function(<Camera.matrix>)
cmplGfx/lib/camera.ci:67: Camera.move: function(<Camera.move>)
cmplGfx/lib/camera.ci:72: Camera.rotate: function(<Camera.rotate>)
cmplGfx/lib/camera.ci:2: Camera: typename(<Camera>)
cmplGfx/lib/window.ci:9: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:20: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:66: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:73: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:78: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:83: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:160: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:165: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:2: Window: typename(<Window>)
cmplGfx/lib/micro.ui.core.ci:4: Style.dark: argb({
	v: uint32(1710618)
})
cmplGfx/lib/micro.ui.core.ci:6: Style.light: argb({
	v: uint32(14342874)
})
cmplGfx/lib/micro.ui.core.ci:9: Style.blue: argb({
	v: uint32(2201078)
})
cmplGfx/lib/micro.ui.core.ci:11: Style.green: argb({
	v: uint32(4894290)
})
cmplGfx/lib/micro.ui.core.ci:13: Style.gray: argb({
	v: uint32(6454667)
})
cmplGfx/lib/micro.ui.core.ci:15: Style.orange: argb({
	v: uint32(16750848)
})
cmplGfx/lib/micro.ui.core.ci:17: Style.red: argb({
	v: uint32(16138289)
})
cmplGfx/lib/micro.ui.core.ci:19: Style.magenta: argb({
	v: uint32(10233013)
})
cmplGfx/lib/micro.ui.core.ci:21: Style.cyan: argb({
	v: uint32(38283)
})
cmplGfx/lib/micro.ui.core.ci:23: Style.theme: argb({
	v: uint32(1710618)
})
cmplGfx/lib/micro.ui.core.ci:24: Style.accent: argb({
	v: uint32(6454667)
})
cmplGfx/lib/micro.ui.core.ci:80: Style.align: function(<Style.align>)
cmplGfx/lib/micro.ui.core.ci:113: Style.measure: function(<Style.measure>)
cmplGfx/lib/micro.ui.core.ci:119: Style.align: function(<Style.align>)
cmplGfx/lib/micro.ui.core.ci:134: Style.align: function(<Style.align>)
cmplGfx/lib/micro.ui.core.ci:139: Style.setColor: function(<Style.setColor>)
cmplGfx/lib/micro.ui.core.ci:2: Style: typename(<Style>)
cmplGfx/lib/micro.ui.core.ci:151: KeyEvent: typename(<KeyEvent>)
cmplGfx/lib/micro.ui.core.ci:189: TouchEvent.test: function(<TouchEvent.test>)
cmplGfx/lib/micro.ui.core.ci:200: TouchEvent.isMotion: function(<TouchEvent.isMotion>)
cmplGfx/lib/micro.ui.core.ci:205: TouchEvent.isPress: function(<TouchEvent.isPress>)
cmplGfx/lib/micro.ui.core.ci:210: TouchEvent.isLongPress: function(<TouchEvent.isLongPress>)
cmplGfx/lib/micro.ui.core.ci:215: TouchEvent.isPress: function(<TouchEvent.isPress>)
cmplGfx/lib/micro.ui.core.ci:166: TouchEvent: typename(<TouchEvent>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:227: View: typename(<View>)
cmplGfx/lib/micro.ui.core.ci:382: focus: function(<focus>)
cmplGfx/lib/micro.ui.core.ci:383: invalidate: function(<invalidate>)
cmplGfx/lib/micro.ui.core.ci:390: Layout.Item: typename(<Layout.Item>)
cmplGfx/lib/micro.ui.core.ci:429: Layout.clearState: function(<Layout.clearState>)
cmplGfx/lib/micro.ui.core.ci:459: Layout.getPressed: function(<Layout.getPressed>)
cmplGfx/lib/micro.ui.core.ci:474: Layout.getFocused: function(<Layout.getFocused>)
cmplGfx/lib/micro.ui.core.ci:489: Layout.setFocused: function(<Layout.setFocused>)
cmplGfx/lib/micro.ui.core.ci:513: Layout.capacity: function(<Layout.capacity>)
cmplGfx/lib/micro.ui.core.ci:529: Layout.addItems: function(<Layout.addItems>)
cmplGfx/lib/micro.ui.core.ci:567: Layout.size: function(<Layout.size>)
cmplGfx/lib/micro.ui.core.ci:572: Layout.getView: function(<Layout.getView>)
cmplGfx/lib/micro.ui.core.ci:578: Layout.setAlignment: function(<Layout.setAlignment>)
cmplGfx/lib/micro.ui.core.ci:584: Layout.padding: function(<Layout.padding>)
cmplGfx/lib/micro.ui.core.ci:593: Layout.onClick: function(<Layout.onClick>)
cmplGfx/lib/micro.ui.core.ci:598: Layout.onReset: function(<Layout.onReset>)
cmplGfx/lib/micro.ui.core.ci:609: Layout.onCreate: function(<Layout.onCreate>)
cmplGfx/lib/micro.ui.core.ci:618: Layout.onDestroy: function(<Layout.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:628: Layout.onKeyEvent: function(<Layout.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:643: Layout.onTouchEvent: function(<Layout.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:749: Layout.onMeasure: function(<Layout.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:803: Layout.onLayout: function(<Layout.onLayout>)
cmplGfx/lib/micro.ui.core.ci:1029: Layout.onDraw: function(<Layout.onDraw>)
cmplGfx/lib/micro.ui.core.ci:1055: Layout.Custom: function(<Layout.Custom>)
cmplGfx/lib/micro.ui.core.ci:1066: Layout.Row: function(<Layout.Row>)
cmplGfx/lib/micro.ui.core.ci:1071: Layout.Column: function(<Layout.Column>)
cmplGfx/lib/micro.ui.core.ci:1076: Layout.Stack: function(<Layout.Stack>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:389: Layout: typename(<Layout>)
cmplGfx/lib/micro.ui.core.ci:1092: Widget.focusNext: function(<Widget.focusNext>)
cmplGfx/lib/micro.ui.core.ci:1150: Widget.addItems: function(<Widget.addItems>)
cmplGfx/lib/micro.ui.core.ci:1156: Widget.addItems: function(<Widget.addItems>)
cmplGfx/lib/micro.ui.core.ci:1162: Widget.focus: function(<Widget.focus>)
cmplGfx/lib/micro.ui.core.ci:1168: Widget.padding: function(<Widget.padding>)
cmplGfx/lib/micro.ui.core.ci:1174: Widget.padding: function(<Widget.padding>)
cmplGfx/lib/micro.ui.core.ci:1180: Widget.padding: function(<Widget.padding>)
cmplGfx/lib/micro.ui.core.ci:1185: Widget.onCreate: function(<Widget.onCreate>)
cmplGfx/lib/micro.ui.core.ci:1195: Widget.onKeyEvent: function(<Widget.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:1218: Widget.onMeasure: function(<Widget.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:1224: Widget.onDraw: function(<Widget.onDraw>)
cmplGfx/lib/micro.ui.core.ci:390: Layout.Item: typename(<Layout.Item>)
cmplGfx/lib/micro.ui.core.ci:429: Layout.clearState: function(<Layout.clearState>)
cmplGfx/lib/micro.ui.core.ci:459: Layout.getPressed: function(<Layout.getPressed>)
cmplGfx/lib/micro.ui.core.ci:474: Layout.getFocused: function(<Layout.getFocused>)
cmplGfx/lib/micro.ui.core.ci:489: Layout.setFocused: function(<Layout.setFocused>)
cmplGfx/lib/micro.ui.core.ci:513: Layout.capacity: function(<Layout.capacity>)
cmplGfx/lib/micro.ui.core.ci:529: Layout.addItems: function(<Layout.addItems>)
cmplGfx/lib/micro.ui.core.ci:567: Layout.size: function(<Layout.size>)
cmplGfx/lib/micro.ui.core.ci:572: Layout.getView: function(<Layout.getView>)
cmplGfx/lib/micro.ui.core.ci:578: Layout.setAlignment: function(<Layout.setAlignment>)
cmplGfx/lib/micro.ui.core.ci:584: Layout.padding: function(<Layout.padding>)
cmplGfx/lib/micro.ui.core.ci:593: Layout.onClick: function(<Layout.onClick>)
cmplGfx/lib/micro.ui.core.ci:598: Layout.onReset: function(<Layout.onReset>)
cmplGfx/lib/micro.ui.core.ci:609: Layout.onCreate: function(<Layout.onCreate>)
cmplGfx/lib/micro.ui.core.ci:618: Layout.onDestroy: function(<Layout.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:628: Layout.onKeyEvent: function(<Layout.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:643: Layout.onTouchEvent: function(<Layout.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:749: Layout.onMeasure: function(<Layout.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:803: Layout.onLayout: function(<Layout.onLayout>)
cmplGfx/lib/micro.ui.core.ci:1029: Layout.onDraw: function(<Layout.onDraw>)
cmplGfx/lib/micro.ui.core.ci:1055: Layout.Custom: function(<Layout.Custom>)
cmplGfx/lib/micro.ui.core.ci:1066: Layout.Row: function(<Layout.Row>)
cmplGfx/lib/micro.ui.core.ci:1071: Layout.Column: function(<Layout.Column>)
cmplGfx/lib/micro.ui.core.ci:1076: Layout.Stack: function(<Layout.Stack>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:1084: Widget: typename(<Widget>)
cmplGfx/lib/micro.ui.core.ci:1231: getWidget: function(<getWidget>)
cmplGfx/lib/micro.ui.core.ci:1243: focus: function(<focus>)
cmplGfx/lib/micro.ui.core.ci:1283: invalidate: function(<invalidate>)
cmplGfx/lib/micro.ui.core.ci:1295: isFocused: function(<isFocused>)
cmplGfx/lib/micro.ui.core.ci:1300: isPressed: function(<isPressed>)
cmplGfx/lib/micro.ui.core.ci:1305: isDirty: function(<isDirty>)
cmplGfx/lib/micro.ui.ci:8: Button.onMeasure: function(<Button.onMeasure>)
cmplGfx/lib/micro.ui.ci:14: Button.onDraw: function(<Button.onDraw>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.ci:4: Button: typename(<Button>)
cmplGfx/lib/micro.ui.ci:21: Switch.onOff: char[*][]([2] {
	"off",
	"on"
})
cmplGfx/lib/micro.ui.ci:39: Switch.checked: function(<Switch.checked>)
cmplGfx/lib/micro.ui.ci:44: Switch.onUpdate: function(<Switch.onUpdate>)
cmplGfx/lib/micro.ui.ci:65: Switch.onReset: function(<Switch.onReset>)
cmplGfx/lib/micro.ui.ci:69: Switch.onClick: function(<Switch.onClick>)
cmplGfx/lib/micro.ui.ci:87: Switch.onCreate: function(<Switch.onCreate>)
cmplGfx/lib/micro.ui.ci:96: Switch.onKeyEvent: function(<Switch.onKeyEvent>)
cmplGfx/lib/micro.ui.ci:111: Switch.onTouchEvent: function(<Switch.onTouchEvent>)
cmplGfx/lib/micro.ui.ci:122: Switch.onMeasure: function(<Switch.onMeasure>)
cmplGfx/lib/micro.ui.ci:141: Switch.onDraw: function(<Switch.onDraw>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.ci:20: Switch: typename(<Switch>)
cmplGfx/lib/micro.ui.ci:199: Slider.onUpdate: function(<Slider.onUpdate>)
cmplGfx/lib/micro.ui.ci:217: Slider.onReset: function(<Slider.onReset>)
cmplGfx/lib/micro.ui.ci:221: Slider.onCreate: function(<Slider.onCreate>)
cmplGfx/lib/micro.ui.ci:230: Slider.onKeyEvent: function(<Slider.onKeyEvent>)
cmplGfx/lib/micro.ui.ci:246: Slider.onTouchEvent: function(<Slider.onTouchEvent>)
cmplGfx/lib/micro.ui.ci:282: Slider.onMeasure: function(<Slider.onMeasure>)
cmplGfx/lib/micro.ui.ci:298: Slider.onDrawSlider: function(<Slider.onDrawSlider>)
cmplGfx/lib/micro.ui.ci:316: Slider.onDraw: function(<Slider.onDraw>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.ci:180: Slider: typename(<Slider>)
cmplGfx/lib/micro.ui.ci:341: Histogram.update: function(<Histogram.update>)
cmplGfx/lib/micro.ui.ci:348: Histogram.onUpdate: function(<Histogram.onUpdate>)
cmplGfx/lib/micro.ui.ci:353: Histogram.onReset: function(<Histogram.onReset>)
cmplGfx/lib/micro.ui.ci:361: Histogram.onCreate: function(<Histogram.onCreate>)
cmplGfx/lib/micro.ui.ci:366: Histogram.onTouchEvent: function(<Histogram.onTouchEvent>)
cmplGfx/lib/micro.ui.ci:406: Histogram.onMeasure: function(<Histogram.onMeasure>)
cmplGfx/lib/micro.ui.ci:416: Histogram.onDraw: function(<Histogram.onDraw>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.ci:331: Histogram: typename(<Histogram>)
cmplGfx/lib/micro.ui.ci:498: DebugView.startTimer: function(<DebugView.startTimer>)
cmplGfx/lib/micro.ui.ci:512: DebugView.update: function(<DebugView.update>)
cmplGfx/lib/micro.ui.ci:533: DebugView.onClick: function(<DebugView.onClick>)
cmplGfx/lib/micro.ui.ci:537: DebugView.onReset: function(<DebugView.onReset>)
cmplGfx/lib/micro.ui.ci:552: DebugView.onCreate: function(<DebugView.onCreate>)
cmplGfx/lib/micro.ui.ci:557: DebugView.onMeasure: function(<DebugView.onMeasure>)
cmplGfx/lib/micro.ui.ci:567: DebugView.onDraw: function(<DebugView.onDraw>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.ci:485: DebugView: typename(<DebugView>)
cmplGfx/lib/micro.ui.ci:604: Panel.visible: function(<Panel.visible>)
cmplGfx/lib/micro.ui.ci:614: Panel.onMeasure: function(<Panel.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:390: Layout.Item: typename(<Layout.Item>)
cmplGfx/lib/micro.ui.core.ci:429: Layout.clearState: function(<Layout.clearState>)
cmplGfx/lib/micro.ui.core.ci:459: Layout.getPressed: function(<Layout.getPressed>)
cmplGfx/lib/micro.ui.core.ci:474: Layout.getFocused: function(<Layout.getFocused>)
cmplGfx/lib/micro.ui.core.ci:489: Layout.setFocused: function(<Layout.setFocused>)
cmplGfx/lib/micro.ui.core.ci:513: Layout.capacity: function(<Layout.capacity>)
cmplGfx/lib/micro.ui.core.ci:529: Layout.addItems: function(<Layout.addItems>)
cmplGfx/lib/micro.ui.core.ci:567: Layout.size: function(<Layout.size>)
cmplGfx/lib/micro.ui.core.ci:572: Layout.getView: function(<Layout.getView>)
cmplGfx/lib/micro.ui.core.ci:578: Layout.setAlignment: function(<Layout.setAlignment>)
cmplGfx/lib/micro.ui.core.ci:584: Layout.padding: function(<Layout.padding>)
cmplGfx/lib/micro.ui.core.ci:593: Layout.onClick: function(<Layout.onClick>)
cmplGfx/lib/micro.ui.core.ci:598: Layout.onReset: function(<Layout.onReset>)
cmplGfx/lib/micro.ui.core.ci:609: Layout.onCreate: function(<Layout.onCreate>)
cmplGfx/lib/micro.ui.core.ci:618: Layout.onDestroy: function(<Layout.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:628: Layout.onKeyEvent: function(<Layout.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:643: Layout.onTouchEvent: function(<Layout.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:749: Layout.onMeasure: function(<Layout.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:803: Layout.onLayout: function(<Layout.onLayout>)
cmplGfx/lib/micro.ui.core.ci:1029: Layout.onDraw: function(<Layout.onDraw>)
cmplGfx/lib/micro.ui.core.ci:1055: Layout.Custom: function(<Layout.Custom>)
cmplGfx/lib/micro.ui.core.ci:1066: Layout.Row: function(<Layout.Row>)
cmplGfx/lib/micro.ui.core.ci:1071: Layout.Column: function(<Layout.Column>)
cmplGfx/lib/micro.ui.core.ci:1076: Layout.Stack: function(<Layout.Stack>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.ci:599: Panel: typename(<Panel>)
cmplGfx/lib/micro.ui.ci:634: TabPage.onCreate: function(<TabPage.onCreate>)
cmplGfx/lib/micro.ui.ci:641: TabPage.onMeasurePage: function(<TabPage.onMeasurePage>)
cmplGfx/lib/micro.ui.ci:651: TabPage.onDrawPage: function(<TabPage.onDrawPage>)
cmplGfx/lib/micro.ui.ci:657: TabPage.onDrawBar: function(<TabPage.onDrawBar>)
cmplGfx/lib/micro.ui.ci:663: TabPage.onDrawTab: function(<TabPage.onDrawTab>)
cmplGfx/lib/micro.ui.ci:675: TabPage.onDrawSeparator: function(<TabPage.onDrawSeparator>)
cmplGfx/lib/micro.ui.ci:677: TabPage.onClickTab: function(<TabPage.onClickTab>)
cmplGfx/lib/micro.ui.ci:691: TabPage.addItems: function(<TabPage.addItems>)
cmplGfx/lib/micro.ui.core.ci:390: Layout.Item: typename(<Layout.Item>)
cmplGfx/lib/micro.ui.core.ci:429: Layout.clearState: function(<Layout.clearState>)
cmplGfx/lib/micro.ui.core.ci:459: Layout.getPressed: function(<Layout.getPressed>)
cmplGfx/lib/micro.ui.core.ci:474: Layout.getFocused: function(<Layout.getFocused>)
cmplGfx/lib/micro.ui.core.ci:489: Layout.setFocused: function(<Layout.setFocused>)
cmplGfx/lib/micro.ui.core.ci:513: Layout.capacity: function(<Layout.capacity>)
cmplGfx/lib/micro.ui.core.ci:529: Layout.addItems: function(<Layout.addItems>)
cmplGfx/lib/micro.ui.core.ci:567: Layout.size: function(<Layout.size>)
cmplGfx/lib/micro.ui.core.ci:572: Layout.getView: function(<Layout.getView>)
cmplGfx/lib/micro.ui.core.ci:578: Layout.setAlignment: function(<Layout.setAlignment>)
cmplGfx/lib/micro.ui.core.ci:584: Layout.padding: function(<Layout.padding>)
cmplGfx/lib/micro.ui.core.ci:593: Layout.onClick: function(<Layout.onClick>)
cmplGfx/lib/micro.ui.core.ci:598: Layout.onReset: function(<Layout.onReset>)
cmplGfx/lib/micro.ui.core.ci:609: Layout.onCreate: function(<Layout.onCreate>)
cmplGfx/lib/micro.ui.core.ci:618: Layout.onDestroy: function(<Layout.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:628: Layout.onKeyEvent: function(<Layout.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:643: Layout.onTouchEvent: function(<Layout.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:749: Layout.onMeasure: function(<Layout.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:803: Layout.onLayout: function(<Layout.onLayout>)
cmplGfx/lib/micro.ui.core.ci:1029: Layout.onDraw: function(<Layout.onDraw>)
cmplGfx/lib/micro.ui.core.ci:1055: Layout.Custom: function(<Layout.Custom>)
cmplGfx/lib/micro.ui.core.ci:1066: Layout.Row: function(<Layout.Row>)
cmplGfx/lib/micro.ui.core.ci:1071: Layout.Column: function(<Layout.Column>)
cmplGfx/lib/micro.ui.core.ci:1076: Layout.Stack: function(<Layout.Stack>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.ci:629: TabPage: typename(<TabPage>)
cmplGfx/lib/micro.ui.ci:756: Select.selectedData: function(<Select.selectedData>)
cmplGfx/lib/micro.ui.ci:763: Select.expand: function(<Select.expand>)
cmplGfx/lib/micro.ui.ci:777: Select.onItemClick: function(<Select.onItemClick>)
cmplGfx/lib/micro.ui.ci:785: Select.setSelectedIndex: function(<Select.setSelectedIndex>)
cmplGfx/lib/micro.ui.ci:801: Select.addItems: function(<Select.addItems>)
cmplGfx/lib/micro.ui.ci:836: Select.addItem: function(<Select.addItem>)
cmplGfx/lib/micro.ui.ci:853: Select.addItem: function(<Select.addItem>)
cmplGfx/lib/micro.ui.core.ci:390: Layout.Item: typename(<Layout.Item>)
cmplGfx/lib/micro.ui.core.ci:429: Layout.clearState: function(<Layout.clearState>)
cmplGfx/lib/micro.ui.core.ci:459: Layout.getPressed: function(<Layout.getPressed>)
cmplGfx/lib/micro.ui.core.ci:474: Layout.getFocused: function(<Layout.getFocused>)
cmplGfx/lib/micro.ui.core.ci:489: Layout.setFocused: function(<Layout.setFocused>)
cmplGfx/lib/micro.ui.core.ci:513: Layout.capacity: function(<Layout.capacity>)
cmplGfx/lib/micro.ui.core.ci:529: Layout.addItems: function(<Layout.addItems>)
cmplGfx/lib/micro.ui.core.ci:567: Layout.size: function(<Layout.size>)
cmplGfx/lib/micro.ui.core.ci:572: Layout.getView: function(<Layout.getView>)
cmplGfx/lib/micro.ui.core.ci:578: Layout.setAlignment: function(<Layout.setAlignment>)
cmplGfx/lib/micro.ui.core.ci:584: Layout.padding: function(<Layout.padding>)
cmplGfx/lib/micro.ui.core.ci:593: Layout.onClick: function(<Layout.onClick>)
cmplGfx/lib/micro.ui.core.ci:598: Layout.onReset: function(<Layout.onReset>)
cmplGfx/lib/micro.ui.core.ci:609: Layout.onCreate: function(<Layout.onCreate>)
cmplGfx/lib/micro.ui.core.ci:618: Layout.onDestroy: function(<Layout.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:628: Layout.onKeyEvent: function(<Layout.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:643: Layout.onTouchEvent: function(<Layout.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:749: Layout.onMeasure: function(<Layout.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:803: Layout.onLayout: function(<Layout.onLayout>)
cmplGfx/lib/micro.ui.core.ci:1029: Layout.onDraw: function(<Layout.onDraw>)
cmplGfx/lib/micro.ui.core.ci:1055: Layout.Custom: function(<Layout.Custom>)
cmplGfx/lib/micro.ui.core.ci:1066: Layout.Row: function(<Layout.Row>)
cmplGfx/lib/micro.ui.core.ci:1071: Layout.Column: function(<Layout.Column>)
cmplGfx/lib/micro.ui.core.ci:1076: Layout.Stack: function(<Layout.Stack>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.ci:746: Select: typename(<Select>)
cmplGfx/lib/micro.ui.ci:870: FxWidget.onTouchEvent: function(<FxWidget.onTouchEvent>)
cmplGfx/lib/micro.ui.ci:895: FxWidget.onKeyEvent: function(<FxWidget.onKeyEvent>)
cmplGfx/lib/micro.ui.ci:949: FxWidget.onMeasure: function(<FxWidget.onMeasure>)
cmplGfx/lib/micro.ui.ci:967: FxWidget.onDraw: function(<FxWidget.onDraw>)
cmplGfx/lib/micro.ui.ci:979: FxWidget.onProcess: function(<FxWidget.onProcess>)
cmplGfx/lib/micro.ui.core.ci:1092: Widget.focusNext: function(<Widget.focusNext>)
cmplGfx/lib/micro.ui.core.ci:1150: Widget.addItems: function(<Widget.addItems>)
cmplGfx/lib/micro.ui.core.ci:1156: Widget.addItems: function(<Widget.addItems>)
cmplGfx/lib/micro.ui.core.ci:1162: Widget.focus: function(<Widget.focus>)
cmplGfx/lib/micro.ui.core.ci:1168: Widget.padding: function(<Widget.padding>)
cmplGfx/lib/micro.ui.core.ci:1174: Widget.padding: function(<Widget.padding>)
cmplGfx/lib/micro.ui.core.ci:1180: Widget.padding: function(<Widget.padding>)
cmplGfx/lib/micro.ui.core.ci:1185: Widget.onCreate: function(<Widget.onCreate>)
cmplGfx/lib/micro.ui.core.ci:1195: Widget.onKeyEvent: function(<Widget.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:1218: Widget.onMeasure: function(<Widget.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:1224: Widget.onDraw: function(<Widget.onDraw>)
cmplGfx/lib/micro.ui.core.ci:390: Layout.Item: typename(<Layout.Item>)
cmplGfx/lib/micro.ui.core.ci:429: Layout.clearState: function(<Layout.clearState>)
cmplGfx/lib/micro.ui.core.ci:459: Layout.getPressed: function(<Layout.getPressed>)
cmplGfx/lib/micro.ui.core.ci:474: Layout.getFocused: function(<Layout.getFocused>)
cmplGfx/lib/micro.ui.core.ci:489: Layout.setFocused: function(<Layout.setFocused>)
cmplGfx/lib/micro.ui.core.ci:513: Layout.capacity: function(<Layout.capacity>)
cmplGfx/lib/micro.ui.core.ci:529: Layout.addItems: function(<Layout.addItems>)
cmplGfx/lib/micro.ui.core.ci:567: Layout.size: function(<Layout.size>)
cmplGfx/lib/micro.ui.core.ci:572: Layout.getView: function(<Layout.getView>)
cmplGfx/lib/micro.ui.core.ci:578: Layout.setAlignment: function(<Layout.setAlignment>)
cmplGfx/lib/micro.ui.core.ci:584: Layout.padding: function(<Layout.padding>)
cmplGfx/lib/micro.ui.core.ci:593: Layout.onClick: function(<Layout.onClick>)
cmplGfx/lib/micro.ui.core.ci:598: Layout.onReset: function(<Layout.onReset>)
cmplGfx/lib/micro.ui.core.ci:609: Layout.onCreate: function(<Layout.onCreate>)
cmplGfx/lib/micro.ui.core.ci:618: Layout.onDestroy: function(<Layout.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:628: Layout.onKeyEvent: function(<Layout.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:643: Layout.onTouchEvent: function(<Layout.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:749: Layout.onMeasure: function(<Layout.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:803: Layout.onLayout: function(<Layout.onLayout>)
cmplGfx/lib/micro.ui.core.ci:1029: Layout.onDraw: function(<Layout.onDraw>)
cmplGfx/lib/micro.ui.core.ci:1055: Layout.Custom: function(<Layout.Custom>)
cmplGfx/lib/micro.ui.core.ci:1066: Layout.Row: function(<Layout.Row>)
cmplGfx/lib/micro.ui.core.ci:1071: Layout.Column: function(<Layout.Column>)
cmplGfx/lib/micro.ui.core.ci:1076: Layout.Stack: function(<Layout.Stack>)
cmplGfx/lib/micro.ui.core.ci:250: View.parent: function(<View.parent>)
cmplGfx/lib/micro.ui.core.ci:255: View.onClick: function(<View.onClick>)
cmplGfx/lib/micro.ui.core.ci:260: View.onReset: function(<View.onReset>)
cmplGfx/lib/micro.ui.core.ci:265: View.onCreate: function(<View.onCreate>)
cmplGfx/lib/micro.ui.core.ci:275: View.onDestroy: function(<View.onDestroy>)
cmplGfx/lib/micro.ui.core.ci:278: View.onKeyEvent: function(<View.onKeyEvent>)
cmplGfx/lib/micro.ui.core.ci:298: View.onTouchEvent: function(<View.onTouchEvent>)
cmplGfx/lib/micro.ui.core.ci:331: View.onMeasure: function(<View.onMeasure>)
cmplGfx/lib/micro.ui.core.ci:347: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.core.ci:363: View.onDraw: function(<View.onDraw>)
cmplGfx/lib/micro.ui.ci:859: FxWidget: typename(<FxWidget>)
cmplGfx/lib/micro.ui.ci:983: Widget: function(<Widget>)
cmplGfx/lib/micro.ui.ci:993: Widget: function(<Widget>)
cmplGfx/lib/micro.ui.ci:1000: FxWidget: function(<FxWidget>)
cmplGfx/lib/micro.ui.ci:1024: FxWidget: function(<FxWidget>)
cmplGfx/lib/micro.ui.ci:1029: hasFocused: function(<hasFocused>)
cmplGfx/lib/micro.ui.ci:1052: hasPressed: function(<hasPressed>)
cmplGfx/lib/micro.ui.ci:1078: Window.show: function(<Window.show>)
cmplGfx/lib/micro.ui.ci:1347: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:9: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:20: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:66: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:73: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:78: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:83: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:160: Window.show: function(<Window.show>)
cmplGfx/lib/window.ci:165: Window.show: function(<Window.show>)
cmplGfx/lib/micro.ui.ci:1076: Window: typename(<Window>)
cmplStd/test/lang/emit.ci:3: emitldz32: int32(0)
cmplStd/test/lang/emit.ci:4: emitldz64: int64(0)
cmplStd/test/lang/emit.ci:6: emitA: int32(42)
cmplStd/test/lang/emit.ci:7: emitB: int32(96)
cmplStd/test/lang/emit.ci:10: emitAddI32: int32(138)
cmplStd/test/lang/emit.ci:13: emitDivI32: int32(2)
cmplStd/test/lang/emit.ci:16: emitNfcF32: float32(1.000000)
cmplStd/test/lang/emit.ci:23: emitFloatAsInt1: int32(1140457472)
cmplStd/test/lang/emit.ci:24: emitFloatAsInt2: int64(1140457472)
cmplStd/test/lang/emit.ci:25: emitFloatAsInt3: int32(0)
cmplStd/test/lang/emit.ci:26: emitFloatAsInt4: int64(4647503709213818880)
cmplStd/test/lang/emit.ci:30: emitSlice: char[]([3] {'s', 't', 'r'})
cmplStd/test/lang/inlineMacros.ci:10: i3: int32(3)
cmplStd/test/lang/inlineMacros.ci:11: i6: int32(6)
cmplStd/test/lang/inlineMacros.ci:12: i2: int32(2)
cmplStd/test/lang/inlineMacros.ci:13: i8: int32(8)
cmplStd/test/lang/inlineMacros.ci:15: zeroVal: int32(0)
cmplStd/test/lang/inlineMacros.ci:16: zeroVar: int32(0)
cmplStd/test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
cmplStd/test/lang/inlineMacros.ci:19: lastVal: int32(6)
cmplStd/test/lang/inlineMacros.ci:20: lastVar: int32(6)
cmplStd/test/lang/inlineMacros.ci:21: lastXpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:23: sum2Val: int32(9)
cmplStd/test/lang/inlineMacros.ci:24: sum2Var: int32(9)
cmplStd/test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
cmplStd/test/lang/inlineMacros.ci:27: any2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:28: any2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:31: min2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:32: min2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:35: max2Val: int32(6)
cmplStd/test/lang/inlineMacros.ci:36: max2Var: int32(6)
cmplStd/test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:59: minRlVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:60: minLrVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:61: minRlVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:62: minLrVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
cmplStd/test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
cmplStd/test/lang/overload.inline.ci:9: overload1: float32(1.000000)
cmplStd/test/lang/overload.inline.ci:10: overload2: float32(2.000000)
cmplStd/test/lang/overload.inline.ci:11: overload3: float32(3.000000)
cmplStd/test/lang/overload.inline.ci:12: overload4: float32(4.000000)
cmplStd/test/lang/overload.inline.ci:13: overload5: float32(5.000000)
cmplStd/test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
cmplStd/test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
cmplStd/test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
cmplStd/test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
cmplStd/test/lang/memory.ci:7: p1: pointer(<?>)
cmplStd/test/lang/memory.ci:8: p2: pointer(<?>)
cmplStd/test/lang/memory.ci:9: p3: pointer(<?>)
cmplStd/test/lang/memory.ci:10: p4: pointer(<?>)
cmplStd/test/lang/memory.ci:23: val1: int64(0)
cmplStd/test/lang/memory.ci:24: val2: int64(42)
cmplStd/test/lang/tryExec.ci:3: noError: function(<noError>)
cmplStd/test/lang/tryExec.ci:6: stackOverflow: function(<stackOverflow>)
cmplStd/test/lang/tryExec.ci:12: divisionByZero: function(<divisionByZero>)
cmplStd/test/lang/tryExec.ci:16: abortExecution: function(<abortExecution>)
cmplStd/test/lang/tryExec.ci:30: invalidMemoryAccess: function(<invalidMemoryAccess>)
cmplStd/test/lang/tryExec.ci:35: invalidInstruction: function(<invalidInstruction>)
cmplStd/test/lang/tryExec.ci:39: tryExecErr0: int32(0)
cmplStd/test/lang/tryExec.ci:40: tryExecErr1: int32(1)
cmplStd/test/lang/tryExec.ci:41: tryExecErr2: int32(2)
cmplStd/test/lang/tryExec.ci:42: tryExecErr3: int32(3)
cmplStd/test/lang/tryExec.ci:43: tryExecErr4: int32(4)
cmplStd/test/lang/tryExec.ci:44: tryExecErr5: int32(5)
cmplStd/test/lang/tryExec.ci:45: tryExecErr6: int32(6)
cmplStd/test/lang/pointer.ci:1: arr: int32[5]([5] {1, 2, 3, 4, 5})
cmplStd/test/lang/pointer.ci:2: ptr: pointer(<?>)
cmplStd/test/lang/pointer.ci:3: a0: int32(1)
cmplStd/test/lang/pointer.ci:4: a1: int32(2)
cmplStd/test/lang/pointer.ci:5: a2: int32(3)
cmplStd/test/lang/pointer.ci:6: a3: int32(4)
cmplStd/test/lang/pointer.ci:7: a4: int32(5)
cmplStd/test/lang/init.reference.ci:7: value: int64(42)
cmplStd/test/lang/init.reference.ci:8: valueRef: int64(42)
cmplStd/test/lang/init.reference.ci:9: valuePtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:10: valueVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:12: fromRef: int64(42)
cmplStd/test/lang/init.reference.ci:13: fromPtr: int64(42)
cmplStd/test/lang/init.reference.ci:14: fromVar: int64(42)
cmplStd/test/lang/init.reference.ci:16: nullRef: int64(null)
cmplStd/test/lang/init.reference.ci:17: nullPtr: pointer(null)
cmplStd/test/lang/init.reference.ci:18: nullVar: variant(null)
cmplStd/test/lang/init.reference.ci:19: nullTyp: typename(null)
cmplStd/test/lang/init.reference.ci:20: nullFun: function(null)
cmplStd/test/lang/init.reference.ci:21: nullObj: object(null)
cmplStd/test/lang/init.reference.ci:23: typePtr: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:24: typeVar: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:25: typeTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:27: local: int64(42)
cmplStd/test/lang/init.reference.ci:28: copyVal: int64(42)
cmplStd/test/lang/init.reference.ci:29: copyRef: int64(42)
cmplStd/test/lang/init.reference.ci:30: copyPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:31: copyVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:32: copyTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:35: ptrVoid: pointer(<void>)
cmplStd/test/lang/init.reference.ci:36: ptrBool: pointer(<bool>)
cmplStd/test/lang/init.reference.ci:37: ptrChar: pointer(<char>)
cmplStd/test/lang/init.reference.ci:38: ptrInt8: pointer(<int8>)
cmplStd/test/lang/init.reference.ci:39: ptrInt16: pointer(<int16>)
cmplStd/test/lang/init.reference.ci:40: ptrInt32: pointer(<int32>)
cmplStd/test/lang/init.reference.ci:41: ptrInt64: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:42: ptrUint8: pointer(<uint8>)
cmplStd/test/lang/init.reference.ci:43: ptrUint16: pointer(<uint16>)
cmplStd/test/lang/init.reference.ci:44: ptrUint32: pointer(<uint32>)
cmplStd/test/lang/init.reference.ci:45: ptrUint64: pointer(<uint64>)
cmplStd/test/lang/init.reference.ci:46: ptrFloat32: pointer(<float32>)
cmplStd/test/lang/init.reference.ci:47: ptrFloat64: pointer(<float64>)
cmplStd/test/lang/init.reference.ci:48: ptrTypename: pointer(<typename>)
cmplStd/test/lang/init.reference.ci:49: ptrFunction: pointer(<function>)
cmplStd/test/lang/init.reference.ci:50: ptrPointer: pointer(<pointer>)
cmplStd/test/lang/init.reference.ci:51: ptrVariant: pointer(<variant>)
cmplStd/test/lang/init.reference.ci:52: ptrObject: pointer(<object>)
cmplStd/test/lang/init.reference.ci:55: varVoid: variant(typename: <void>)
cmplStd/test/lang/init.reference.ci:56: varBool: variant(typename: <bool>)
cmplStd/test/lang/init.reference.ci:57: varChar: variant(typename: <char>)
cmplStd/test/lang/init.reference.ci:58: varInt8: variant(typename: <int8>)
cmplStd/test/lang/init.reference.ci:59: varInt16: variant(typename: <int16>)
cmplStd/test/lang/init.reference.ci:60: varInt32: variant(typename: <int32>)
cmplStd/test/lang/init.reference.ci:61: varInt64: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:62: varUint8: variant(typename: <uint8>)
cmplStd/test/lang/init.reference.ci:63: varUint16: variant(typename: <uint16>)
cmplStd/test/lang/init.reference.ci:64: varUint32: variant(typename: <uint32>)
cmplStd/test/lang/init.reference.ci:65: varUint64: variant(typename: <uint64>)
cmplStd/test/lang/init.reference.ci:66: varFloat32: variant(typename: <float32>)
cmplStd/test/lang/init.reference.ci:67: varFloat64: variant(typename: <float64>)
cmplStd/test/lang/init.reference.ci:68: varTypename: variant(typename: <typename>)
cmplStd/test/lang/init.reference.ci:69: varFunction: variant(typename: <function>)
cmplStd/test/lang/init.reference.ci:70: varPointer: variant(typename: <pointer>)
cmplStd/test/lang/init.reference.ci:71: varVariant: variant(typename: <variant>)
cmplStd/test/lang/init.reference.ci:72: varObject: variant(typename: <object>)
cmplStd/test/lang/init.reference.ci:75: typVoid: typename(<void>)
cmplStd/test/lang/init.reference.ci:76: typBool: typename(<bool>)
cmplStd/test/lang/init.reference.ci:77: typChar: typename(<char>)
cmplStd/test/lang/init.reference.ci:78: typInt8: typename(<int8>)
cmplStd/test/lang/init.reference.ci:79: typInt16: typename(<int16>)
cmplStd/test/lang/init.reference.ci:80: typInt32: typename(<int32>)
cmplStd/test/lang/init.reference.ci:81: typInt64: typename(<int64>)
cmplStd/test/lang/init.reference.ci:82: typUint8: typename(<uint8>)
cmplStd/test/lang/init.reference.ci:83: typUint16: typename(<uint16>)
cmplStd/test/lang/init.reference.ci:84: typUint32: typename(<uint32>)
cmplStd/test/lang/init.reference.ci:85: typUint64: typename(<uint64>)
cmplStd/test/lang/init.reference.ci:86: typFloat32: typename(<float32>)
cmplStd/test/lang/init.reference.ci:87: typFloat64: typename(<float64>)
cmplStd/test/lang/init.reference.ci:88: typTypename: typename(<typename>)
cmplStd/test/lang/init.reference.ci:89: typFunction: typename(<function>)
cmplStd/test/lang/init.reference.ci:90: typPointer: typename(<pointer>)
cmplStd/test/lang/init.reference.ci:91: typVariant: typename(<variant>)
cmplStd/test/lang/init.reference.ci:92: typObject: typename(<object>)
cmplStd/test/lang/init.reference.ci:95: valueOfPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:96: valueOfVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:97: valueOfTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:99: typeOfValue: typename(<int64>)
cmplStd/test/lang/init.reference.ci:105: copyPtrFloat64: variant(pointer: <float64>)
cmplStd/test/lang/init.reference.ci:108: copyVarFloat64: pointer(<float64>)
cmplStd/test/lang/init.variable.ci:3: variable: int32(0)
cmplStd/test/lang/init.variable.ci:7: constant: int32(42)
cmplStd/test/lang/init.variable.ci:9: ComplexVal: typename(<ComplexVal>)
cmplStd/test/lang/init.variable.ci:13: ComplexObj: typename(<ComplexObj>)
cmplStd/test/lang/init.variable.ci:24: valInitImplicit: ComplexVal({
	re: float64(8.000000),
	im: float64(0.000000)
})
cmplStd/test/lang/init.variable.ci:33: objInitImplicit: ComplexObj({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/init.variable.ci:41: objInitExplicit: object({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/function.ci:4: empty: function(<empty>)
cmplStd/test/lang/function.ci:7: funAdd: function(<funAdd>)
cmplStd/test/lang/function.ci:12: funAddResult: int32(9)
cmplStd/test/lang/function.ci:15: funAddRef: function(<funAdd>)
cmplStd/test/lang/function.ci:18: funAddRefResult: int32(10)
cmplStd/test/lang/function.ci:21: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:24: funMulResult: int32(12)
cmplStd/test/lang/function.ci:27: funMulRef: function(<funMul>)
cmplStd/test/lang/function.ci:30: funMulRefResult: int32(14)
cmplStd/test/lang/function.ci:33: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:38: fib: function(<fib>)
cmplStd/test/lang/function.ci:46: fibonacci_13: uint32(233)
cmplStd/test/lang/reflect.ci:3: sizeofVoid: int32(0)
cmplStd/test/lang/reflect.ci:4: sizeofBool: int32(1)
cmplStd/test/lang/reflect.ci:5: sizeofChar: int32(1)
cmplStd/test/lang/reflect.ci:6: sizeofInt8: int32(1)
cmplStd/test/lang/reflect.ci:7: sizeofInt16: int32(2)
cmplStd/test/lang/reflect.ci:8: sizeofInt32: int32(4)
cmplStd/test/lang/reflect.ci:9: sizeofInt64: int32(8)
cmplStd/test/lang/reflect.ci:10: sizeofUint8: int32(1)
cmplStd/test/lang/reflect.ci:11: sizeofUint16: int32(2)
cmplStd/test/lang/reflect.ci:12: sizeofUint32: int32(4)
cmplStd/test/lang/reflect.ci:13: sizeofUint64: int32(8)
cmplStd/test/lang/reflect.ci:14: sizeofFloat32: int32(4)
cmplStd/test/lang/reflect.ci:15: sizeofFloat64: int32(8)
cmplStd/test/lang/reflect.ci:16: sizeofPointer: int32(4)
cmplStd/test/lang/reflect.ci:17: sizeofVariant: int32(8)
cmplStd/test/lang/reflect.ci:18: sizeofTypename: int32(4)
cmplStd/test/lang/reflect.ci:19: sizeofFunction: int32(4)
cmplStd/test/lang/reflect.ci:20: sizeofObject: int32(4)
cmplStd/test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
cmplStd/test/lang/reflect.ci:32: offsetOfRecord: int32(1039072)
cmplStd/test/lang/reflect.ci:33: sizeOfRecord: int32(16)
cmplStd/test/lang/reflect.ci:34: fileOfRecord: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:35: lineOfRecord: int32(26)
cmplStd/test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
cmplStd/test/lang/reflect.ci:39: offsetOfBase: int32(1038752)
cmplStd/test/lang/reflect.ci:40: sizeOfBase: int32(12)
cmplStd/test/lang/reflect.ci:41: fileOfBase: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:42: lineOfBase: int32(22)
cmplStd/test/lang/reflect.ci:44: typeofBase1: typename(<object>)
cmplStd/test/lang/reflect.ci:45: offsetOfBase1: int32(2880)
cmplStd/test/lang/reflect.ci:46: sizeOfBase1: int32(4)
cmplStd/test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
cmplStd/test/lang/reflect.ci:49: offsetOfBase2: int32(8)
cmplStd/test/lang/reflect.ci:50: sizeOfBase2: int32(160)
cmplStd/test/lang/init.member.ci:4: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
cmplStd/test/lang/init.member.ci:34: RecordMemberTest.global: int32(0)
cmplStd/test/lang/init.member.ci:37: RecordMemberTest.globalInit: int32(1)
cmplStd/test/lang/init.member.ci:40: RecordMemberTest.globalConstant: int32(2)
cmplStd/test/lang/init.member.ci:43: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(4)
})
cmplStd/test/lang/init.member.ci:46: RecordMemberTest.globalRecInit: Inner({
	member: int32(4),
	constant: int32(5)
})
cmplStd/test/lang/init.member.ci:49: RecordMemberTest.globalConstantRec: Inner({
	member: int32(6),
	constant: int32(7)
})
cmplStd/test/lang/init.member.ci:2: RecordMemberTest: typename(<RecordMemberTest>)
cmplStd/test/lang/init.member.ci:52: recordMemberTest: RecordMemberTest({
	member: int32(10),
	constant: int32(11),
	memberInit: int32(12),
	constantInit: int32(13),
	memberRec: Inner({
		member: int32(14),
		constant: int32(15)
	}),
	constantRec: Inner({
		member: int32(16),
		constant: int32(17)
	})
})
cmplStd/test/lang/init.method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
cmplStd/test/lang/init.method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
cmplStd/test/lang/init.method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
cmplStd/test/lang/init.method.ci:57: globalFunction: function(<globalFunction>)
cmplStd/test/lang/init.method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<globalFunction>),
	delegateMethod: function(<RecordMethodTest.forwardMethod>),
	virtualMethod: function(<RecordMethodTest.virtualMethod>)
})
cmplStd/test/lang/init.method.ci:84: staticMethod: function(<staticMethod>)
cmplStd/test/lang/init.method.ci:90: virtualMethod: function(<virtualMethod>)
cmplStd/test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
cmplStd/test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
cmplStd/test/lang/recUnion.ci:16: color: typename(<color>)
cmplStd/test/lang/recUnion.ci:22: Color: typename(<Color>)
cmplStd/test/lang/recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
cmplStd/test/lang/recUnion.ci:30: cyan: color({
	col: uint32(65535)
})
cmplStd/test/lang/recUnion.ci:31: blue: color({
	col: uint32(255)
})
cmplStd/test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
cmplStd/test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
cmplStd/test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
cmplStd/test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
cmplStd/test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
cmplStd/test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
cmplStd/test/lang/useOperator.ci:5: shift: int32(2)
cmplStd/test/lang/useOperator.ci:7: boolA: bool(1)
cmplStd/test/lang/useOperator.ci:8: boolB: bool(1)
cmplStd/test/lang/useOperator.ci:17: boolAnd: bool(1)
cmplStd/test/lang/useOperator.ci:18: boolIor: bool(1)
cmplStd/test/lang/useOperator.ci:19: boolXor: bool(0)
cmplStd/test/lang/useOperator.ci:22: boolNot: bool(0)
cmplStd/test/lang/useOperator.ci:23: boolCeq: bool(1)
cmplStd/test/lang/useOperator.ci:24: boolCne: bool(0)
cmplStd/test/lang/useOperator.ci:25: boolClt: bool(0)
cmplStd/test/lang/useOperator.ci:26: boolCle: bool(1)
cmplStd/test/lang/useOperator.ci:27: boolCgt: bool(0)
cmplStd/test/lang/useOperator.ci:28: boolCge: bool(1)
cmplStd/test/lang/useOperator.ci:30: chrA: char('a')
cmplStd/test/lang/useOperator.ci:31: chrB: char('b')
cmplStd/test/lang/useOperator.ci:32: chrPls: char('b')
cmplStd/test/lang/useOperator.ci:33: chrNeg: char('')
cmplStd/test/lang/useOperator.ci:34: chrCmt: char('')
cmplStd/test/lang/useOperator.ci:35: chrAdd: char('')
cmplStd/test/lang/useOperator.ci:36: chrSub: char('')
cmplStd/test/lang/useOperator.ci:37: chrMul: char('\"')
cmplStd/test/lang/useOperator.ci:38: chrDiv: char('')
cmplStd/test/lang/useOperator.ci:39: chrMod: char('a')
cmplStd/test/lang/useOperator.ci:40: chrAnd: char('`')
cmplStd/test/lang/useOperator.ci:41: chrIor: char('c')
cmplStd/test/lang/useOperator.ci:42: chrXor: char('')
cmplStd/test/lang/useOperator.ci:43: chrShl: char('')
cmplStd/test/lang/useOperator.ci:44: chrShr: char('')
cmplStd/test/lang/useOperator.ci:45: chrNot: bool(0)
cmplStd/test/lang/useOperator.ci:46: chrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:47: chrCne: bool(1)
cmplStd/test/lang/useOperator.ci:48: chrClt: bool(1)
cmplStd/test/lang/useOperator.ci:49: chrCle: bool(1)
cmplStd/test/lang/useOperator.ci:50: chrCgt: bool(0)
cmplStd/test/lang/useOperator.ci:51: chrCge: bool(0)
cmplStd/test/lang/useOperator.ci:53: i8A: int8(96)
cmplStd/test/lang/useOperator.ci:54: i8B: int8(42)
cmplStd/test/lang/useOperator.ci:55: i8Pls: int8(42)
cmplStd/test/lang/useOperator.ci:56: i8Neg: int8(-42)
cmplStd/test/lang/useOperator.ci:57: i8Cmt: int8(-43)
cmplStd/test/lang/useOperator.ci:58: i8Add: int8(-118)
cmplStd/test/lang/useOperator.ci:59: i8Sub: int8(54)
cmplStd/test/lang/useOperator.ci:60: i8Mul: int8(-64)
cmplStd/test/lang/useOperator.ci:61: i8Div: int8(2)
cmplStd/test/lang/useOperator.ci:62: i8Mod: int8(12)
cmplStd/test/lang/useOperator.ci:63: i8And: int8(32)
cmplStd/test/lang/useOperator.ci:64: i8Ior: int8(106)
cmplStd/test/lang/useOperator.ci:65: i8Xor: int8(74)
cmplStd/test/lang/useOperator.ci:66: i8Shl: int8(-128)
cmplStd/test/lang/useOperator.ci:67: i8Shr: int8(24)
cmplStd/test/lang/useOperator.ci:68: i8Not: bool(0)
cmplStd/test/lang/useOperator.ci:69: i8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:70: i8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:71: i8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:72: i8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:73: i8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:74: i8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:76: u8A: uint8(96)
cmplStd/test/lang/useOperator.ci:77: u8B: uint8(42)
cmplStd/test/lang/useOperator.ci:78: u8Pls: uint8(42)
cmplStd/test/lang/useOperator.ci:79: u8Neg: uint8(214)
cmplStd/test/lang/useOperator.ci:80: u8Cmt: uint8(213)
cmplStd/test/lang/useOperator.ci:81: u8Add: uint8(138)
cmplStd/test/lang/useOperator.ci:82: u8Sub: uint8(54)
cmplStd/test/lang/useOperator.ci:83: u8Mul: uint8(192)
cmplStd/test/lang/useOperator.ci:84: u8Div: uint8(2)
cmplStd/test/lang/useOperator.ci:85: u8Mod: uint8(12)
cmplStd/test/lang/useOperator.ci:86: u8And: uint8(32)
cmplStd/test/lang/useOperator.ci:87: u8Ior: uint8(106)
cmplStd/test/lang/useOperator.ci:88: u8Xor: uint8(74)
cmplStd/test/lang/useOperator.ci:89: u8Shl: uint8(128)
cmplStd/test/lang/useOperator.ci:90: u8Shr: uint8(24)
cmplStd/test/lang/useOperator.ci:91: u8Not: bool(0)
cmplStd/test/lang/useOperator.ci:92: u8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:93: u8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:94: u8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:95: u8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:96: u8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:97: u8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:99: i16A: int16(96)
cmplStd/test/lang/useOperator.ci:100: i16B: int16(42)
cmplStd/test/lang/useOperator.ci:101: i16Pls: int16(42)
cmplStd/test/lang/useOperator.ci:102: i16Neg: int16(-42)
cmplStd/test/lang/useOperator.ci:103: i16Cmt: int16(-43)
cmplStd/test/lang/useOperator.ci:104: i16Add: int16(138)
cmplStd/test/lang/useOperator.ci:105: i16Sub: int16(54)
cmplStd/test/lang/useOperator.ci:106: i16Mul: int16(4032)
cmplStd/test/lang/useOperator.ci:107: i16Div: int16(2)
cmplStd/test/lang/useOperator.ci:108: i16Mod: int16(12)
cmplStd/test/lang/useOperator.ci:109: i16And: int16(32)
cmplStd/test/lang/useOperator.ci:110: i16Ior: int16(106)
cmplStd/test/lang/useOperator.ci:111: i16Xor: int16(74)
cmplStd/test/lang/useOperator.ci:112: i16Shl: int16(384)
cmplStd/test/lang/useOperator.ci:113: i16Shr: int16(24)
cmplStd/test/lang/useOperator.ci:114: i16Not: bool(0)
cmplStd/test/lang/useOperator.ci:115: i16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:116: i16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:117: i16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:118: i16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:119: i16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:120: i16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:122: u16A: uint16(96)
cmplStd/test/lang/useOperator.ci:123: u16B: uint16(42)
cmplStd/test/lang/useOperator.ci:124: u16Pls: uint16(42)
cmplStd/test/lang/useOperator.ci:125: u16Neg: uint16(65494)
cmplStd/test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
cmplStd/test/lang/useOperator.ci:127: u16Add: uint16(138)
cmplStd/test/lang/useOperator.ci:128: u16Sub: uint16(54)
cmplStd/test/lang/useOperator.ci:129: u16Mul: uint16(4032)
cmplStd/test/lang/useOperator.ci:130: u16Div: uint16(2)
cmplStd/test/lang/useOperator.ci:131: u16Mod: uint16(12)
cmplStd/test/lang/useOperator.ci:132: u16And: uint16(32)
cmplStd/test/lang/useOperator.ci:133: u16Ior: uint16(106)
cmplStd/test/lang/useOperator.ci:134: u16Xor: uint16(74)
cmplStd/test/lang/useOperator.ci:135: u16Shl: uint16(384)
cmplStd/test/lang/useOperator.ci:136: u16Shr: uint16(24)
cmplStd/test/lang/useOperator.ci:137: u16Not: bool(0)
cmplStd/test/lang/useOperator.ci:138: u16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:139: u16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:140: u16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:141: u16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:142: u16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:143: u16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:145: i32A: int32(96)
cmplStd/test/lang/useOperator.ci:146: i32B: int32(42)
cmplStd/test/lang/useOperator.ci:147: i32Pls: int32(42)
cmplStd/test/lang/useOperator.ci:148: i32Neg: int32(-42)
cmplStd/test/lang/useOperator.ci:149: i32Cmt: int32(-43)
cmplStd/test/lang/useOperator.ci:150: i32Add: int32(138)
cmplStd/test/lang/useOperator.ci:151: i32Sub: int32(54)
cmplStd/test/lang/useOperator.ci:152: i32Mul: int32(4032)
cmplStd/test/lang/useOperator.ci:153: i32Div: int32(2)
cmplStd/test/lang/useOperator.ci:154: i32Mod: int32(12)
cmplStd/test/lang/useOperator.ci:155: i32And: int32(32)
cmplStd/test/lang/useOperator.ci:156: i32Ior: int32(106)
cmplStd/test/lang/useOperator.ci:157: i32Xor: int32(74)
cmplStd/test/lang/useOperator.ci:158: i32Shl: int32(384)
cmplStd/test/lang/useOperator.ci:159: i32Shr: int32(24)
cmplStd/test/lang/useOperator.ci:160: i32Not: bool(0)
cmplStd/test/lang/useOperator.ci:161: i32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:162: i32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:163: i32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:164: i32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:165: i32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:166: i32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:168: u32A: uint32(96)
cmplStd/test/lang/useOperator.ci:169: u32B: uint32(42)
cmplStd/test/lang/useOperator.ci:170: u32Pls: uint32(42)
cmplStd/test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
cmplStd/test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
cmplStd/test/lang/useOperator.ci:173: u32Add: uint32(138)
cmplStd/test/lang/useOperator.ci:174: u32Sub: uint32(54)
cmplStd/test/lang/useOperator.ci:175: u32Mul: uint32(4032)
cmplStd/test/lang/useOperator.ci:176: u32Div: uint32(2)
cmplStd/test/lang/useOperator.ci:177: u32Mod: uint32(12)
cmplStd/test/lang/useOperator.ci:178: u32And: uint32(32)
cmplStd/test/lang/useOperator.ci:179: u32Ior: uint32(106)
cmplStd/test/lang/useOperator.ci:180: u32Xor: uint32(74)
cmplStd/test/lang/useOperator.ci:181: u32Shl: uint32(384)
cmplStd/test/lang/useOperator.ci:182: u32Shr: uint32(24)
cmplStd/test/lang/useOperator.ci:183: u32Not: bool(0)
cmplStd/test/lang/useOperator.ci:184: u32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:185: u32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:186: u32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:187: u32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:188: u32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:189: u32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:191: i64A: int64(96)
cmplStd/test/lang/useOperator.ci:192: i64B: int64(42)
cmplStd/test/lang/useOperator.ci:193: i64Pls: int64(42)
cmplStd/test/lang/useOperator.ci:194: i64Neg: int64(-42)
cmplStd/test/lang/useOperator.ci:195: i64Cmt: int64(-43)
cmplStd/test/lang/useOperator.ci:196: i64Add: int64(138)
cmplStd/test/lang/useOperator.ci:197: i64Sub: int64(54)
cmplStd/test/lang/useOperator.ci:198: i64Mul: int64(4032)
cmplStd/test/lang/useOperator.ci:199: i64Div: int64(2)
cmplStd/test/lang/useOperator.ci:200: i64Mod: int64(12)
cmplStd/test/lang/useOperator.ci:201: i64And: int64(32)
cmplStd/test/lang/useOperator.ci:202: i64Ior: int64(106)
cmplStd/test/lang/useOperator.ci:203: i64Xor: int64(74)
cmplStd/test/lang/useOperator.ci:204: i64Shl: int64(384)
cmplStd/test/lang/useOperator.ci:205: i64Shr: int64(24)
cmplStd/test/lang/useOperator.ci:206: i64Not: bool(0)
cmplStd/test/lang/useOperator.ci:207: i64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:208: i64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:209: i64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:210: i64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:211: i64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:212: i64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:214: u64A: uint64(96)
cmplStd/test/lang/useOperator.ci:215: u64B: uint64(42)
cmplStd/test/lang/useOperator.ci:216: u64Pls: uint64(42)
cmplStd/test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
cmplStd/test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
cmplStd/test/lang/useOperator.ci:219: u64Add: uint64(138)
cmplStd/test/lang/useOperator.ci:220: u64Sub: uint64(54)
cmplStd/test/lang/useOperator.ci:221: u64Mul: uint64(4032)
cmplStd/test/lang/useOperator.ci:222: u64Div: uint64(2)
cmplStd/test/lang/useOperator.ci:223: u64Mod: uint64(12)
cmplStd/test/lang/useOperator.ci:224: u64And: uint64(32)
cmplStd/test/lang/useOperator.ci:225: u64Ior: uint64(106)
cmplStd/test/lang/useOperator.ci:226: u64Xor: uint64(74)
cmplStd/test/lang/useOperator.ci:227: u64Shl: uint64(384)
cmplStd/test/lang/useOperator.ci:228: u64Shr: uint64(24)
cmplStd/test/lang/useOperator.ci:229: u64Not: bool(0)
cmplStd/test/lang/useOperator.ci:230: u64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:231: u64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:232: u64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:233: u64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:234: u64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:235: u64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:237: f32A: float32(96.300003)
cmplStd/test/lang/useOperator.ci:238: f32B: float32(42.139999)
cmplStd/test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
cmplStd/test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
cmplStd/test/lang/useOperator.ci:242: f32Add: float32(138.440002)
cmplStd/test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
cmplStd/test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
cmplStd/test/lang/useOperator.ci:245: f32Div: float32(2.285240)
cmplStd/test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
cmplStd/test/lang/useOperator.ci:252: f32Not: bool(0)
cmplStd/test/lang/useOperator.ci:253: f32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:254: f32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:255: f32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:256: f32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:257: f32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:258: f32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:260: f64A: float64(96.300000)
cmplStd/test/lang/useOperator.ci:261: f64B: float64(42.140000)
cmplStd/test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
cmplStd/test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
cmplStd/test/lang/useOperator.ci:265: f64Add: float64(138.440000)
cmplStd/test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
cmplStd/test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
cmplStd/test/lang/useOperator.ci:268: f64Div: float64(2.285240)
cmplStd/test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
cmplStd/test/lang/useOperator.ci:275: f64Not: bool(0)
cmplStd/test/lang/useOperator.ci:276: f64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:277: f64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:278: f64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:279: f64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:280: f64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:281: f64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:283: ptrA: pointer(null)
cmplStd/test/lang/useOperator.ci:284: ptrB: pointer(<?>)
cmplStd/test/lang/useOperator.ci:299: ptrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:300: ptrCne: bool(1)
cmplStd/test/lang/stmt.if.ci:26: t: int32(0)
cmplStd/test/lang/stmt.for.ci:12: forIdx: int32(2)
cmplStd/test/math/test.Bits.ci:3: pi64: float64(3.141593)
cmplStd/test/math/test.Bits.ci:4: e64: float64(2.718282)
cmplStd/test/math/test.Bits.ci:6: pi32: float32(3.141593)
cmplStd/test/math/test.Bits.ci:7: e32: float32(2.718282)
cmplStd/test/math/test.Bits.ci:14: r_comp: int32(112)
cmplStd/test/math/test.Bits.ci:15: g_comp: int32(252)
cmplStd/test/math/test.Bits.ci:16: b_comp: int32(248)
cmplStd/test/math/test.Bits.ci:18: r5g6b5: int32(30719)
cmplStd/test/math/test.Bits.ci:19: r8g8b8: int32(7404792)
cmplStd/test/math/test.Bits.ci:21: zxtR5: int32(14)
cmplStd/test/math/test.Bits.ci:22: zxtG6: int32(63)
cmplStd/test/math/test.Bits.ci:23: zxtB5: int32(31)
cmplStd/test/math/test.Bits.ci:25: sxtR5: int32(14)
cmplStd/test/math/test.Bits.ci:26: sxtG6: int32(-1)
cmplStd/test/math/test.Bits.ci:27: sxtB5: int32(-1)
cmplStd/test/math/test.Bits.ci:29: zxtR8: int32(112)
cmplStd/test/math/test.Bits.ci:30: zxtG8: int32(252)
cmplStd/test/math/test.Bits.ci:31: zxtB8: int32(248)
cmplStd/test/math/test.Bits.ci:33: sxtR8: int32(112)
cmplStd/test/math/test.Bits.ci:34: sxtG8: int32(-4)
cmplStd/test/math/test.Bits.ci:35: sxtB8: int32(-8)
cmplStd/test/math/test.Bits.ci:37: testSin_f64: float64(1.000000)
cmplStd/test/math/test.Bits.ci:38: testCos_f64: float64(0.000000)
cmplStd/test/math/test.Bits.ci:39: testTan_f64: float64(1.000000)
cmplStd/test/math/test.Bits.ci:40: testLog_f64: float64(3.000000)
cmplStd/test/math/test.Bits.ci:41: testExp_f64: float64(2.718282)
cmplStd/test/math/test.Bits.ci:42: testPow_f64: float64(3.141593)
cmplStd/test/math/test.Bits.ci:43: testSqrt_f64: float64(3.141593)
cmplStd/test/math/test.Bits.ci:44: testAtan_f64: float64(1.262627)
cmplStd/test/math/test.Bits.ci:46: testSin_f32: float32(1.000000)
cmplStd/test/math/test.Bits.ci:47: testCos_f32: float32(-0.000000)
cmplStd/test/math/test.Bits.ci:48: testTan_f32: float32(1.000000)
cmplStd/test/math/test.Bits.ci:49: testLog_f32: float32(3.000000)
cmplStd/test/math/test.Bits.ci:50: testExp_f32: float32(2.718282)
cmplStd/test/math/test.Bits.ci:51: testPow_f32: float32(3.141593)
cmplStd/test/math/test.Bits.ci:52: testSqrt_f32: float32(3.141593)
cmplStd/test/math/test.Bits.ci:53: testAtan_f32: float32(1.262627)
cmplStd/test/math/test.Bits.ci:55: testPopulation_u32: int32(14)
cmplStd/test/math/test.Bits.ci:56: testSwapBits_u32: uint32(4293787648)
cmplStd/test/math/test.Bits.ci:57: testBitScanReverse_u32: int32(14)
cmplStd/test/math/test.Bits.ci:58: testBitScanForward_u32: int32(0)
cmplStd/test/math/test.Bits.ci:59: testHighBit_u32: int32(16384)
cmplStd/test/math/test.Bits.ci:60: testLowBit_u32: int32(1)
cmplStd/test/math/test.Bits.ci:62: testZeroExtend_u32: int32(31)
cmplStd/test/math/test.Bits.ci:63: testSignExtend_u32: int32(-1)
cmplStd/test/math/test.Bits.ci:65: testZeroExtend_u64: int32(31)
cmplStd/test/math/test.Bits.ci:66: testSignExtend_u64: int32(-1)
cmplStd/test/math/test.Math.ci:3: testMathFloor_pos_3_0: float64(3.000000)
cmplStd/test/math/test.Math.ci:4: testMathFloor_pos_3_2: float64(3.000000)
cmplStd/test/math/test.Math.ci:5: testMathFloor_pos_3_5: float64(3.000000)
cmplStd/test/math/test.Math.ci:6: testMathFloor_pos_3_7: float64(3.000000)
cmplStd/test/math/test.Math.ci:7: testMathFloor_pos_3_9: float64(3.000000)
cmplStd/test/math/test.Math.ci:8: testMathFloor_neg_3_0: float64(-3.000000)
cmplStd/test/math/test.Math.ci:9: testMathFloor_neg_3_2: float64(-4.000000)
cmplStd/test/math/test.Math.ci:10: testMathFloor_neg_3_5: float64(-4.000000)
cmplStd/test/math/test.Math.ci:11: testMathFloor_neg_3_7: float64(-4.000000)
cmplStd/test/math/test.Math.ci:12: testMathFloor_neg_3_9: float64(-4.000000)
cmplStd/test/math/test.Math.ci:14: testMathRound_pos_3_0: float64(3.000000)
cmplStd/test/math/test.Math.ci:15: testMathRound_pos_3_2: float64(3.000000)
cmplStd/test/math/test.Math.ci:16: testMathRound_pos_3_5: float64(4.000000)
cmplStd/test/math/test.Math.ci:17: testMathRound_pos_3_7: float64(4.000000)
cmplStd/test/math/test.Math.ci:18: testMathRound_pos_3_9: float64(4.000000)
cmplStd/test/math/test.Math.ci:19: testMathRound_neg_3_0: float64(-3.000000)
cmplStd/test/math/test.Math.ci:20: testMathRound_neg_3_2: float64(-3.000000)
cmplStd/test/math/test.Math.ci:21: testMathRound_neg_3_5: float64(-3.000000)
cmplStd/test/math/test.Math.ci:22: testMathRound_neg_3_7: float64(-4.000000)
cmplStd/test/math/test.Math.ci:23: testMathRound_neg_3_9: float64(-4.000000)
cmplStd/test/math/test.Math.ci:25: testMathCeil_pos_3_0: float64(3.000000)
cmplStd/test/math/test.Math.ci:26: testMathCeil_pos_3_2: float64(4.000000)
cmplStd/test/math/test.Math.ci:27: testMathCeil_pos_3_5: float64(4.000000)
cmplStd/test/math/test.Math.ci:28: testMathCeil_pos_3_7: float64(4.000000)
cmplStd/test/math/test.Math.ci:29: testMathCeil_pos_3_9: float64(4.000000)
cmplStd/test/math/test.Math.ci:30: testMathCeil_neg_3_0: float64(-3.000000)
cmplStd/test/math/test.Math.ci:31: testMathCeil_neg_3_2: float64(-3.000000)
cmplStd/test/math/test.Math.ci:32: testMathCeil_neg_3_5: float64(-3.000000)
cmplStd/test/math/test.Math.ci:33: testMathCeil_neg_3_7: float64(-3.000000)
cmplStd/test/math/test.Math.ci:34: testMathCeil_neg_3_9: float64(-3.000000)
cmplStd/test/math/test.Math.ci:36: testMathSign_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:37: testMathSign_2F: float64(0.000000)
cmplStd/test/math/test.Math.ci:38: testMathSign_3F: float64(-1.000000)
cmplStd/test/math/test.Math.ci:39: testMathSign_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:40: testMathSign_2f: float64(0.000000)
cmplStd/test/math/test.Math.ci:41: testMathSign_3f: float64(-1.000000)
cmplStd/test/math/test.Math.ci:43: testMathAbs_1F: float64(0.200000)
cmplStd/test/math/test.Math.ci:44: testMathAbs_2F: float64(0.000000)
cmplStd/test/math/test.Math.ci:45: testMathAbs_3F: float64(0.900000)
cmplStd/test/math/test.Math.ci:46: testMathAbs_1f: float64(0.200000)
cmplStd/test/math/test.Math.ci:47: testMathAbs_2f: float64(0.000000)
cmplStd/test/math/test.Math.ci:48: testMathAbs_3f: float64(0.900000)
cmplStd/test/math/test.Math.ci:50: testMathMin_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:51: testMathMax_2f: float64(2.000000)
cmplStd/test/math/test.Math.ci:52: testMathMin_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:53: testMathMax_2F: float64(2.000000)
cmplStd/test/math/test.Math.ci:55: testMathClamp_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:56: testMathClamp_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:58: testMathMix_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:59: testMathMix_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:61: testMathSmooth_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:62: testMathSmooth_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:64: testMathMin_nan: float64(-nan)
cmplStd/test/math/test.Math.ci:65: testMathMin_1: float64(1.000000)
cmplStd/test/math/test.Math.ci:66: testMathMax_nan: float64(-nan)
cmplStd/test/math/test.Math.ci:67: testMathMax_9: float64(9.000000)
cmplStd/test/math/test.Math.ci:69: testMathSum_0: float64(0.000000)
cmplStd/test/math/test.Math.ci:70: testMathSum_1: float64(1.000000)
cmplStd/test/math/test.Math.ci:71: testMathSum_3: float64(3.000000)
cmplStd/test/math/test.Math.ci:72: testMathSum_55: float64(55.000000)
cmplStd/test/math/test.Math.ci:74: testMathEval_x: float64(10.000000)
cmplStd/test/math/test.Math.ci:75: testMathEval_0: float64(0.000000)
cmplStd/test/math/test.Math.ci:76: testMathEval_1: float64(1.000000)
cmplStd/test/math/test.Math.ci:77: testMathEval_2: float64(11.000000)
cmplStd/test/math/test.Math.ci:78: testMathEval_3: float64(111.000000)
cmplStd/test/math/test.Math.ci:79: testMathEval_4: float64(1111.000000)
cmplStd/test/math/test.Math.ci:80: testMathEval_5: float64(11111.000000)
cmplStd/test/math/test.Math.ci:81: testMathEval_6: float64(111111.000000)
cmplStd/test/math/test.Math.ci:83: testMathSin_f64: float64(1.000000)
cmplStd/test/math/test.Math.ci:84: testMathCos_f64: float64(0.000000)
cmplStd/test/math/test.Math.ci:85: testMathTan_f64: float64(1.000000)
cmplStd/test/math/test.Math.ci:86: testMathSinh_f64: float64(2.301299)
cmplStd/test/math/test.Math.ci:87: testMathCosh_f64: float64(2.509178)
cmplStd/test/math/test.Math.ci:89: testMathAsin_f64: float64(0.201358)
cmplStd/test/math/test.Math.ci:90: testMathAcos_f64: float64(1.369438)
cmplStd/test/math/test.Math.ci:93: testMathAbsMod_f64_0a: float64(0.000000)
cmplStd/test/math/test.Math.ci:94: testMathAbsMod_f64_0b: float64(0.000000)
cmplStd/test/math/test.Math.ci:95: testMathAbsMod_f64_0c: float64(-0.000000)
cmplStd/test/math/test.Math.ci:97: testMathAbsMod_f64_9a: float64(9.000000)
cmplStd/test/math/test.Math.ci:98: testMathAbsMod_f64_9b: float64(9.000000)
cmplStd/test/math/test.Math.ci:99: testMathAbsMod_f64_9c: float64(9.000000)
cmplStd/test/math/test.Math.ci:100: testMathAbsMod_f64_9d: float64(9.000000)
cmplStd/test/math/test.Math.ci:102: testMathAbsMod_f64_8a: float64(8.000000)
cmplStd/test/math/test.Math.ci:103: testMathAbsMod_f64_8b: float64(8.000000)
cmplStd/test/math/test.Math.ci:104: testMathAbsMod_f64_8c: float64(8.000000)
cmplStd/test/math/test.Math.ci:105: testMathAbsMod_f64_8d: float64(8.000000)
cmplStd/test/math/test.Math.ci:107: testMathAbsMod_f32_0a: float32(0.000000)
cmplStd/test/math/test.Math.ci:108: testMathAbsMod_f32_0b: float32(0.000000)
cmplStd/test/math/test.Math.ci:109: testMathAbsMod_f32_0c: float32(-0.000000)
cmplStd/test/math/test.Math.ci:111: testMathAbsMod_f32_9a: float32(9.000000)
cmplStd/test/math/test.Math.ci:112: testMathAbsMod_f32_9b: float32(9.000000)
cmplStd/test/math/test.Math.ci:113: testMathAbsMod_f32_9c: float32(9.000000)
cmplStd/test/math/test.Math.ci:114: testMathAbsMod_f32_9d: float32(9.000000)
cmplStd/test/math/test.Math.ci:116: testMathAbsMod_f32_8a: float32(8.000000)
cmplStd/test/math/test.Math.ci:117: testMathAbsMod_f32_8b: float32(8.000000)
cmplStd/test/math/test.Math.ci:118: testMathAbsMod_f32_8c: float32(8.000000)
cmplStd/test/math/test.Math.ci:119: testMathAbsMod_f32_8d: float32(8.000000)
cmplStd/test/math/test.Complex.ci:8: valA: Complex({
	re: float64(9.000000),
	im: float64(2.000000)
})
cmplStd/test/math/test.Complex.ci:9: valB: Complex({
	re: float64(2.000000),
	im: float64(3.000000)
})
cmplStd/test/math/test.Complex.ci:11: Neg: Complex({
	re: float64(-9.000000),
	im: float64(-2.000000)
})
cmplStd/test/math/test.Complex.ci:12: neg: Complex({
	re: float64(-9.000000),
	im: float64(-2.000000)
})
cmplStd/test/math/test.Complex.ci:14: Add: Complex({
	re: float64(11.000000),
	im: float64(5.000000)
})
cmplStd/test/math/test.Complex.ci:15: add: Complex({
	re: float64(11.000000),
	im: float64(5.000000)
})
cmplStd/test/math/test.Complex.ci:17: Sub: Complex({
	re: float64(7.000000),
	im: float64(-1.000000)
})
cmplStd/test/math/test.Complex.ci:18: sub: Complex({
	re: float64(7.000000),
	im: float64(-1.000000)
})
cmplStd/test/math/test.Complex.ci:20: Mul: Complex({
	re: float64(12.000000),
	im: float64(31.000000)
})
cmplStd/test/math/test.Complex.ci:21: mul: Complex({
	re: float64(12.000000),
	im: float64(31.000000)
})

---------- Memory usage:
memory[all] @000000; size: 134217448(128.0 Mb)
memory[used] @000000; size: 1240052(1.2 Mb)
memory[heap] @12ebf4; size: 99422994(94.8 Mb)
memory[stack] @3ffff4c; size: 33554362(32.0 Mb)

---------- Used memory:
memory[meta] @000000; size: 1138288(1.1 Mb)
memory[code] @000000; size: 95931(93.7 Kb)
memory[data] @000000; size: 4072(4.0 Kb)

---------- Heap memory:
memory[used] @12ec08; size: 32(32.0 bytes)
memory[used] @12ec38; size: 32(32.0 bytes)
memory[free] @12ec68; size: 99422848(94.8 Mb)

---------- Exitcode: 0, time: 0.000 ms
