
---------- Compile: `/cmplStd/lib.ci`
warn: variable `args` hides previous declaration
debug: inline file: `cmplStd/lib.ci`
cmplStd/lib.ci:18: debug: inline file: `cmplStd/lib/lang/Debug.ci`
cmplStd/lib/lang/Debug.ci:48: warn: adding implicit cast variant[](null: pointer)
cmplStd/lib/lang/Debug.ci:63: warn: adding implicit cast variant(message: char[*])
cmplStd/lib/lang/Debug.ci:65: warn: adding implicit cast variant(expected: int32)
cmplStd/lib/lang/Debug.ci:66: warn: adding implicit cast variant(returned: int32)
cmplStd/lib/lang/Debug.ci:67: warn: adding implicit cast variant[](extras: variant[1])
cmplStd/lib.ci:21: debug: inline file: `cmplStd/lib/lang/Pointer.ci`
cmplStd/lib/lang/Pointer.ci:7: warn: variable `inc(ptr: pointer, val: int32): pointer` hides previous declaration
cmplStd/lib/lang/Pointer.ci:3: warn: previously defined here as `inc(ptr: pointer, val: int32): pointer`
cmplStd/lib.ci:24: debug: inline file: `cmplStd/lib/math/Bits.ci`
cmplStd/lib/math/Bits.ci:37: warn: adding implicit cast uint64(lo: uint32)
cmplStd/lib/math/Bits.ci:41: warn: adding implicit cast pointer(typename(uint32.zxt): typename)
cmplStd/lib/math/Bits.ci:41: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:51: warn: adding implicit cast pointer(typename(uint32.sxt): typename)
cmplStd/lib/math/Bits.ci:51: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:61: warn: adding implicit cast pointer(typename(uint64.zxt): typename)
cmplStd/lib/math/Bits.ci:61: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:71: warn: adding implicit cast pointer(typename(uint64.sxt): typename)
cmplStd/lib/math/Bits.ci:71: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:81: warn: adding implicit cast uint64(4294967295: int64)
cmplStd/lib/math/Bits.ci:81: warn: adding implicit cast uint64(-4294967296: int64)
cmplStd/lib/math/Bits.ci:82: warn: adding implicit cast uint64(281470681808895: int64)
cmplStd/lib/math/Bits.ci:82: warn: adding implicit cast uint64(-281470681808896: int64)
cmplStd/lib/math/Bits.ci:83: warn: adding implicit cast uint64(71777214294589695: int64)
cmplStd/lib/math/Bits.ci:83: warn: adding implicit cast uint64(-71777214294589696: int64)
cmplStd/lib/math/Bits.ci:89: warn: adding implicit cast uint32(65535: int32)
cmplStd/lib/math/Bits.ci:89: warn: adding implicit cast int64(x: uint32)
cmplStd/lib/math/Bits.ci:89: warn: adding implicit cast int64((x & (65535)) << 16: uint32)
cmplStd/lib/math/Bits.ci:89: warn: adding implicit cast uint32(((x & (65535)) << 16) | ((x) & 4294901760) >> 16: int64)
cmplStd/lib/math/Bits.ci:90: warn: adding implicit cast uint32(16711935: int32)
cmplStd/lib/math/Bits.ci:90: warn: adding implicit cast int64(x: uint32)
cmplStd/lib/math/Bits.ci:90: warn: adding implicit cast int64((x & (16711935)) << 8: uint32)
cmplStd/lib/math/Bits.ci:90: warn: adding implicit cast uint32(((x & (16711935)) << 8) | ((x) & 4278255360) >> 8: int64)
cmplStd/lib/math/Bits.ci:96: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:96: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:111: warn: adding implicit cast pointer(typename(uint64.bsr): typename)
cmplStd/lib/math/Bits.ci:111: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:113: verbose: reference `bsr` is not defined
cmplStd/lib/math/Bits.ci:113: verbose: reference `bsr` is not defined
cmplStd/lib/math/Bits.ci:113: verbose: can not type check expression: `.result := uint64.bsr(x)`
cmplStd/lib/math/Bits.ci:115: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:120: warn: adding implicit cast uint64(-4294967296: int64)
cmplStd/lib/math/Bits.ci:124: warn: adding implicit cast uint64(4294901760: int64)
cmplStd/lib/math/Bits.ci:128: warn: adding implicit cast uint64(65280: int32)
cmplStd/lib/math/Bits.ci:132: warn: adding implicit cast uint64(240: int32)
cmplStd/lib/math/Bits.ci:136: warn: adding implicit cast uint64(12: int32)
cmplStd/lib/math/Bits.ci:140: warn: adding implicit cast uint64(2: int32)
cmplStd/lib/math/Bits.ci:151: warn: adding implicit cast pointer(typename(uint32.bsr): typename)
cmplStd/lib/math/Bits.ci:151: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:155: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:160: warn: adding implicit cast int64(x: uint32)
cmplStd/lib/math/Bits.ci:164: warn: adding implicit cast uint32(65280: int32)
cmplStd/lib/math/Bits.ci:168: warn: adding implicit cast uint32(240: int32)
cmplStd/lib/math/Bits.ci:172: warn: adding implicit cast uint32(12: int32)
cmplStd/lib/math/Bits.ci:176: warn: adding implicit cast uint32(2: int32)
cmplStd/lib/math/Bits.ci:187: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:192: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:194: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:194: warn: adding implicit cast uint16((x) >> 8: int32)
cmplStd/lib/math/Bits.ci:196: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:198: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:198: warn: adding implicit cast uint16((x) >> 4: int32)
cmplStd/lib/math/Bits.ci:200: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:202: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:202: warn: adding implicit cast uint16((x) >> 2: int32)
cmplStd/lib/math/Bits.ci:204: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:215: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:220: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:222: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:222: warn: adding implicit cast uint8((x) >> 4: int32)
cmplStd/lib/math/Bits.ci:224: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:226: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:226: warn: adding implicit cast uint8((x) >> 2: int32)
cmplStd/lib/math/Bits.ci:228: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:240: warn: adding implicit cast pointer(typename(uint64.bsf): typename)
cmplStd/lib/math/Bits.ci:240: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:242: verbose: reference `bsf` is not defined
cmplStd/lib/math/Bits.ci:242: verbose: reference `bsf` is not defined
cmplStd/lib/math/Bits.ci:242: verbose: can not type check expression: `.result := uint64.bsf(x)`
cmplStd/lib/math/Bits.ci:245: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:250: warn: adding implicit cast uint64(4294967295: int64)
cmplStd/lib/math/Bits.ci:250: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:254: warn: adding implicit cast uint64(65535: int32)
cmplStd/lib/math/Bits.ci:254: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:258: warn: adding implicit cast uint64(255: int32)
cmplStd/lib/math/Bits.ci:258: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:262: warn: adding implicit cast uint64(15: int32)
cmplStd/lib/math/Bits.ci:262: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:266: warn: adding implicit cast uint64(3: int32)
cmplStd/lib/math/Bits.ci:266: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:270: warn: adding implicit cast uint64(1: int32)
cmplStd/lib/math/Bits.ci:270: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Bits.ci:281: warn: adding implicit cast pointer(typename(uint32.bsf): typename)
cmplStd/lib/math/Bits.ci:281: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:286: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:291: warn: adding implicit cast uint32(65535: int32)
cmplStd/lib/math/Bits.ci:291: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:295: warn: adding implicit cast uint32(255: int32)
cmplStd/lib/math/Bits.ci:295: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:299: warn: adding implicit cast uint32(15: int32)
cmplStd/lib/math/Bits.ci:299: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:303: warn: adding implicit cast uint32(3: int32)
cmplStd/lib/math/Bits.ci:303: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:307: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Bits.ci:307: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Bits.ci:318: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:323: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:325: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:325: warn: adding implicit cast uint16((x) >> 8: int32)
cmplStd/lib/math/Bits.ci:327: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:329: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:329: warn: adding implicit cast uint16((x) >> 4: int32)
cmplStd/lib/math/Bits.ci:331: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:333: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:333: warn: adding implicit cast uint16((x) >> 2: int32)
cmplStd/lib/math/Bits.ci:335: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:346: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:351: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:353: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:353: warn: adding implicit cast uint8((x) >> 4: int32)
cmplStd/lib/math/Bits.ci:355: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:357: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:357: warn: adding implicit cast uint8((x) >> 2: int32)
cmplStd/lib/math/Bits.ci:359: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:371: warn: adding implicit cast pointer(typename(uint64.hib): typename)
cmplStd/lib/math/Bits.ci:371: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:373: verbose: reference `hib` is not defined
cmplStd/lib/math/Bits.ci:373: verbose: reference `hib` is not defined
cmplStd/lib/math/Bits.ci:373: verbose: can not type check expression: `.result := uint64.hib(x)`
cmplStd/lib/math/Bits.ci:390: warn: adding implicit cast pointer(typename(uint32.hib): typename)
cmplStd/lib/math/Bits.ci:390: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:434: warn: adding implicit cast pointer(typename(uint64.pop): typename)
cmplStd/lib/math/Bits.ci:434: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:436: verbose: reference `pop` is not defined
cmplStd/lib/math/Bits.ci:436: verbose: reference `pop` is not defined
cmplStd/lib/math/Bits.ci:436: verbose: can not type check expression: `.result := uint64.pop(x)`
cmplStd/lib/math/Bits.ci:439: warn: adding implicit cast uint64(6148914691236517205: int64)
cmplStd/lib/math/Bits.ci:440: warn: adding implicit cast uint64(3689348814741910323: int64)
cmplStd/lib/math/Bits.ci:440: warn: adding implicit cast uint64(3689348814741910323: int64)
cmplStd/lib/math/Bits.ci:441: warn: adding implicit cast uint64(1085102592571150095: int64)
cmplStd/lib/math/Bits.ci:445: warn: adding implicit cast uint64(63: int32)
cmplStd/lib/math/Bits.ci:453: warn: adding implicit cast pointer(typename(uint32.pop): typename)
cmplStd/lib/math/Bits.ci:453: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:458: warn: adding implicit cast uint32(1431655765: int32)
cmplStd/lib/math/Bits.ci:459: warn: adding implicit cast uint32(858993459: int32)
cmplStd/lib/math/Bits.ci:459: warn: adding implicit cast uint32(858993459: int32)
cmplStd/lib/math/Bits.ci:460: warn: adding implicit cast uint32(252645135: int32)
cmplStd/lib/math/Bits.ci:463: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/math/Bits.ci:472: warn: adding implicit cast pointer(typename(uint64.swap): typename)
cmplStd/lib/math/Bits.ci:472: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:474: verbose: reference `swap` is not defined
cmplStd/lib/math/Bits.ci:474: verbose: reference `swap` is not defined
cmplStd/lib/math/Bits.ci:474: verbose: can not type check expression: `.result := uint64.swap(x)`
cmplStd/lib/math/Bits.ci:477: warn: adding implicit cast uint64(6148914691236517205: int64)
cmplStd/lib/math/Bits.ci:477: warn: adding implicit cast uint64(6148914691236517205: int64)
cmplStd/lib/math/Bits.ci:478: warn: adding implicit cast uint64(3689348814741910323: int64)
cmplStd/lib/math/Bits.ci:478: warn: adding implicit cast uint64(3689348814741910323: int64)
cmplStd/lib/math/Bits.ci:479: warn: adding implicit cast uint64(1085102592571150095: int64)
cmplStd/lib/math/Bits.ci:479: warn: adding implicit cast uint64(1085102592571150095: int64)
cmplStd/lib/math/Bits.ci:480: warn: adding implicit cast uint64(71777214294589695: int64)
cmplStd/lib/math/Bits.ci:480: warn: adding implicit cast uint64(71777214294589695: int64)
cmplStd/lib/math/Bits.ci:481: warn: adding implicit cast uint64(281470681808895: int64)
cmplStd/lib/math/Bits.ci:481: warn: adding implicit cast uint64(281470681808895: int64)
cmplStd/lib/math/Bits.ci:490: warn: adding implicit cast pointer(typename(uint32.swap): typename)
cmplStd/lib/math/Bits.ci:490: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Bits.ci:495: warn: adding implicit cast uint32(1431655765: int32)
cmplStd/lib/math/Bits.ci:495: warn: adding implicit cast uint32(1431655765: int32)
cmplStd/lib/math/Bits.ci:496: warn: adding implicit cast uint32(858993459: int32)
cmplStd/lib/math/Bits.ci:496: warn: adding implicit cast uint32(858993459: int32)
cmplStd/lib/math/Bits.ci:497: warn: adding implicit cast uint32(252645135: int32)
cmplStd/lib/math/Bits.ci:497: warn: adding implicit cast uint32(252645135: int32)
cmplStd/lib/math/Bits.ci:498: warn: adding implicit cast uint32(16711935: int32)
cmplStd/lib/math/Bits.ci:498: warn: adding implicit cast uint32(16711935: int32)
cmplStd/lib/math/Bits.ci:507: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:507: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:507: warn: adding implicit cast uint16((((x) >> 1) & 21845) | (((x) & 21845) << 1): int32)
cmplStd/lib/math/Bits.ci:508: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:508: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:508: warn: adding implicit cast uint16((((x) >> 2) & 13107) | (((x) & 13107) << 2): int32)
cmplStd/lib/math/Bits.ci:509: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:509: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:509: warn: adding implicit cast uint16((((x) >> 4) & 3855) | (((x) & 3855) << 4): int32)
cmplStd/lib/math/Bits.ci:510: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:510: warn: adding implicit cast int32(x: uint16)
cmplStd/lib/math/Bits.ci:518: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:518: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:518: warn: adding implicit cast uint8((((x) >> 1) & 85) | (((x) & 85) << 1): int32)
cmplStd/lib/math/Bits.ci:519: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:519: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:519: warn: adding implicit cast uint8((((x) >> 2) & 51) | (((x) & 51) << 2): int32)
cmplStd/lib/math/Bits.ci:520: warn: adding implicit cast int32(x: uint8)
cmplStd/lib/math/Bits.ci:520: warn: adding implicit cast int32(x: uint8)
cmplStd/lib.ci:25: debug: inline file: `cmplStd/lib/math/Math.ci`
cmplStd/lib/math/Math.ci:17: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:18: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:29: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:29: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:34: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:47: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:47: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:53: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:54: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:55: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:62: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Math.ci:63: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:64: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Math.ci:86: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Math.ci:86: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Math.ci:89: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Math.ci:92: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Math.ci:95: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:95: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:98: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:98: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:103: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:111: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:121: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Math.ci:130: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Math.ci:133: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:197: warn: adding implicit cast float32(2: int32)
cmplStd/lib/math/Math.ci:197: warn: adding implicit cast float32(3: int32)
cmplStd/lib/math/Math.ci:202: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:202: warn: adding implicit cast float64(3: int32)
cmplStd/lib/math/Math.ci:210: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Math.ci:214: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Math.ci:224: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Math.ci:228: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Math.ci:239: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Math.ci:247: warn: adding implicit cast float64(Bits.signed(values.length): int32)
cmplStd/lib/math/Math.ci:271: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Math.ci:279: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:280: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:285: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:288: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:317: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:328: warn: adding implicit cast float64(1 << 52: int32)
cmplStd/lib/math/Math.ci:337: warn: adding implicit cast uint64(bias: int32)
cmplStd/lib/math/Math.ci:358: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:362: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:369: warn: adding implicit cast float64(1 << 52: int32)
cmplStd/lib/math/Math.ci:374: warn: adding implicit cast uint64(int32(x >> shift): int32)
cmplStd/lib/math/Math.ci:374: warn: adding implicit cast uint64(bias: int32)
cmplStd/lib/math/Math.ci:374: warn: adding implicit cast uint64(exp: int32)
cmplStd/lib/math/Math.ci:374: warn: adding implicit cast int32((exp) + ((int32(x >> shift)) & mask) - (bias): uint64)
cmplStd/lib/math/Math.ci:388: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:398: warn: adding implicit cast pointer(typename(float64.log): typename)
cmplStd/lib/math/Math.ci:398: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:418: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:419: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:428: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:432: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:436: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:436: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:440: warn: adding implicit cast float64(exp: int32)
cmplStd/lib/math/Math.ci:445: warn: adding implicit cast pointer(typename(float32.log): typename)
cmplStd/lib/math/Math.ci:445: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:466: warn: adding implicit cast pointer(typename(float64.exp): typename)
cmplStd/lib/math/Math.ci:466: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:517: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:517: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:522: warn: adding implicit cast pointer(typename(float32.exp): typename)
cmplStd/lib/math/Math.ci:522: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:533: warn: adding implicit cast pointer(typename(float64.sqrt): typename)
cmplStd/lib/math/Math.ci:533: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:544: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:547: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:559: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Math.ci:577: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Math.ci:588: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/math/Math.ci:589: warn: adding implicit cast uint64(1: int32)
cmplStd/lib/math/Math.ci:597: warn: adding implicit cast pointer(typename(float32.sqrt): typename)
cmplStd/lib/math/Math.ci:597: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:608: warn: adding implicit cast pointer(typename(float64.pow): typename)
cmplStd/lib/math/Math.ci:608: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:613: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:618: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:627: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:627: warn: adding implicit cast bool(flip: int32)
cmplStd/lib/math/Math.ci:633: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:634: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:638: warn: adding implicit cast float64(2147483647: int32)
cmplStd/lib/math/Math.ci:639: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:640: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:640: warn: adding implicit cast bool(flip: int32)
cmplStd/lib/math/Math.ci:647: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:663: warn: adding implicit cast int64(1: int32)
cmplStd/lib/math/Math.ci:668: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Math.ci:688: warn: adding implicit cast pointer(typename(float32.pow): typename)
cmplStd/lib/math/Math.ci:688: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:711: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:717: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:718: warn: adding implicit cast float64(32764: int32)
cmplStd/lib/math/Math.ci:721: warn: adding implicit cast float64(quad: int32)
cmplStd/lib/math/Math.ci:725: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math/Math.ci:725: warn: adding implicit cast int32(e - (4) * f: float64)
cmplStd/lib/math/Math.ci:728: warn: adding implicit cast float64(k: int32)
cmplStd/lib/math/Math.ci:733: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:767: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:769: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/math/Math.ci:778: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math/Math.ci:807: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/math/Math.ci:811: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:852: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:852: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:854: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math/Math.ci:854: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:854: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:857: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:866: warn: adding implicit cast pointer(typename(float64.atan2): typename)
cmplStd/lib/math/Math.ci:866: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:872: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:873: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:875: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:879: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:880: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:890: warn: adding implicit cast pointer(typename(float32.atan2): typename)
cmplStd/lib/math/Math.ci:890: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:901: warn: adding implicit cast pointer(typename(float64.sin): typename)
cmplStd/lib/math/Math.ci:901: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:911: warn: adding implicit cast pointer(typename(float32.sin): typename)
cmplStd/lib/math/Math.ci:911: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:920: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:920: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:920: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:923: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:923: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:926: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:931: warn: adding implicit cast pointer(typename(float64.cos): typename)
cmplStd/lib/math/Math.ci:931: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:936: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:944: warn: adding implicit cast pointer(typename(float32.cos): typename)
cmplStd/lib/math/Math.ci:944: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:953: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:953: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:953: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:956: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:956: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:959: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:964: warn: adding implicit cast pointer(typename(float64.tan): typename)
cmplStd/lib/math/Math.ci:964: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:969: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:976: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:986: warn: adding implicit cast pointer(typename(float32.tan): typename)
cmplStd/lib/math/Math.ci:986: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:995: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:995: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:995: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:995: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:998: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:998: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:998: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/math/Math.ci:998: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1003: warn: adding implicit cast pointer(typename(float64.cot): typename)
cmplStd/lib/math/Math.ci:1003: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/math/Math.ci:1005: verbose: reference `cot` is not defined
cmplStd/lib/math/Math.ci:1005: verbose: reference `cot` is not defined
cmplStd/lib/math/Math.ci:1005: verbose: can not type check expression: `.result := float64.cot(x)`
cmplStd/lib/math/Math.ci:1008: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1015: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1018: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Math.ci:1018: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1018: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1021: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1021: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1021: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/math/Math.ci:1021: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1025: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1028: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1031: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1031: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1034: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1038: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1041: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1044: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1044: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1047: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Math.ci:1051: warn: adding implicit cast float64(180: int32)
cmplStd/lib/math/Math.ci:1054: warn: adding implicit cast float64(180: int32)
cmplStd/lib.ci:26: debug: inline file: `cmplStd/lib/math/Fixed.ci`
cmplStd/lib/math/Fixed.ci:9: warn: adding implicit cast int32(2147483648: int64)
cmplStd/lib/math/Fixed.ci:33: verbose: reference `precision_must_be_at_most_26_bits` is not defined
cmplStd/lib/math/Fixed.ci:33: verbose: can not type check expression: `precision_must_be_at_most_26_bits`
cmplStd/lib/math/Fixed.ci:33: verbose: unexpected token `}`, matching `;`
cmplStd/lib/math/Fixed.ci:47: warn: adding implicit cast int64(b.value: int32)
cmplStd/lib/math/Fixed.ci:47: warn: adding implicit cast int32((int64(a.value) * (b.value)) >> precision: int64)
cmplStd/lib/math/Fixed.ci:49: warn: adding implicit cast int64(b: int32)
cmplStd/lib/math/Fixed.ci:49: warn: adding implicit cast int32(int64(a.value) * (b) >> 28: int64)
cmplStd/lib/math/Fixed.ci:59: warn: adding implicit cast int64(b.value: int32)
cmplStd/lib/math/Fixed.ci:59: warn: adding implicit cast int32((int64(a.value) << precision) / (b.value): int64)
cmplStd/lib/math/Fixed.ci:71: warn: adding implicit cast int64(x.value: int32)
cmplStd/lib/math/Fixed.ci:73: warn: adding implicit cast int64(0: int32)
cmplStd/lib/math/Fixed.ci:75: warn: adding implicit cast int32(value: int64)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(6039313: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(12055173: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(18047761: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(24017256: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(29963835: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(35887674: int32)
cmplStd/lib/math/Fixed.ci:137: warn: adding implicit cast uint32(41788946: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(47667822: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(53524472: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(59359063: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(65171760: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(70962727: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(76732127: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(82480119: int32)
cmplStd/lib/math/Fixed.ci:138: warn: adding implicit cast uint32(88206861: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(93912510: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(99597221: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(105261147: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(110904439: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(116527248: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(122129720: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(127712004: int32)
cmplStd/lib/math/Fixed.ci:139: warn: adding implicit cast uint32(133274243: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(138816582: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(144339162: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(149842123: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(155325605: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(160789745: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(166234678: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(171660540: int32)
cmplStd/lib/math/Fixed.ci:140: warn: adding implicit cast uint32(177067464: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(182455580: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(187825021: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(193175914: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(198508387: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(203822568: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(209118580: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(214396547: int32)
cmplStd/lib/math/Fixed.ci:141: warn: adding implicit cast uint32(219656593: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(224898838: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(230123403: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(235330406: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(240519966: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(245692198: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(250847217: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(255985139: int32)
cmplStd/lib/math/Fixed.ci:142: warn: adding implicit cast uint32(261106076: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(266210140: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(271297442: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(276368091: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(281422197: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(286459866: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(291481206: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(296486322: int32)
cmplStd/lib/math/Fixed.ci:143: warn: adding implicit cast uint32(301475318: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(306448299: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(311405365: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(316346620: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(321272163: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(326182094: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(331076512: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(335955515: int32)
cmplStd/lib/math/Fixed.ci:144: warn: adding implicit cast uint32(340819198: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(345667659: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(350500992: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(355319292: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(360122651: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(364911161: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(369684916: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(374444004: int32)
cmplStd/lib/math/Fixed.ci:145: warn: adding implicit cast uint32(379188516: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(383918541: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(388634167: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(393335482: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(398022572: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(402695523: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(407354419: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(411999346: int32)
cmplStd/lib/math/Fixed.ci:146: warn: adding implicit cast uint32(416630387: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(421247625: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(425851141: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(430441017: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(435017333: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(439580170: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(444129606: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(448665721: int32)
cmplStd/lib/math/Fixed.ci:147: warn: adding implicit cast uint32(453188591: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(457698295: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(462194907: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(466678505: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(471149164: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(475606957: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(480051958: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(484484242: int32)
cmplStd/lib/math/Fixed.ci:148: warn: adding implicit cast uint32(488903880: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(493310944: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(497705506: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(502087636: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(506457405: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(510814881: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(515160135: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(519493235: int32)
cmplStd/lib/math/Fixed.ci:149: warn: adding implicit cast uint32(523814247: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(528123240: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(532420281: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(536705434: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(540978766: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(545240343: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(549490227: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(553728484: int32)
cmplStd/lib/math/Fixed.ci:150: warn: adding implicit cast uint32(557955177: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(562170369: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(566374122: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(570566498: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(574747559: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(578917365: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(583075977: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(587223454: int32)
cmplStd/lib/math/Fixed.ci:151: warn: adding implicit cast uint32(591359857: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(595485245: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(599599675: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(603703206: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(607795895: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(611877800: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(615948977: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(620009483: int32)
cmplStd/lib/math/Fixed.ci:152: warn: adding implicit cast uint32(624059372: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(628098702: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(632127526: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(636145899: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(640153876: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(644151509: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(648138852: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(652115958: int32)
cmplStd/lib/math/Fixed.ci:153: warn: adding implicit cast uint32(656082880: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(660039669: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(663986377: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(667923055: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(671849754: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(675766525: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(679673417: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(683570481: int32)
cmplStd/lib/math/Fixed.ci:154: warn: adding implicit cast uint32(687457765: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(691335319: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(695203191: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(699061430: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(702910083: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(706749198: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(710578821: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(714399001: int32)
cmplStd/lib/math/Fixed.ci:155: warn: adding implicit cast uint32(718209783: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(722011213: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(725803337: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(729586201: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(733359850: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(737124328: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(740879680: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(744625950: int32)
cmplStd/lib/math/Fixed.ci:156: warn: adding implicit cast uint32(748363182: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(752091420: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(755810706: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(759521084: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(763222596: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(766915284: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(770599191: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(774274358: int32)
cmplStd/lib/math/Fixed.ci:157: warn: adding implicit cast uint32(777940826: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(781598636: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(785247830: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(788888447: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(792520529: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(796144114: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(799759243: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(803365955: int32)
cmplStd/lib/math/Fixed.ci:158: warn: adding implicit cast uint32(806964288: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(810554283: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(814135977: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(817709409: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(821274616: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(824831638: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(828380510: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(831921270: int32)
cmplStd/lib/math/Fixed.ci:159: warn: adding implicit cast uint32(835453956: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(838978604: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(842495250: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(846003931: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(849504683: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(852997541: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(856482541: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(859959719: int32)
cmplStd/lib/math/Fixed.ci:160: warn: adding implicit cast uint32(863429109: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(866890746: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(870344665: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(873790900: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(877229485: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(880660455: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(884083842: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(887499680: int32)
cmplStd/lib/math/Fixed.ci:161: warn: adding implicit cast uint32(890908002: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(894308843: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(897702233: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(901088206: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(904466794: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(907838029: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(911201943: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(914558569: int32)
cmplStd/lib/math/Fixed.ci:162: warn: adding implicit cast uint32(917907937: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(921250078: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(924585025: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(927912807: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(931233455: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(934547001: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(937853474: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(941152904: int32)
cmplStd/lib/math/Fixed.ci:163: warn: adding implicit cast uint32(944445322: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(947730757: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(951009239: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(954280797: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(957545460: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(960803257: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(964054217: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(967298369: int32)
cmplStd/lib/math/Fixed.ci:164: warn: adding implicit cast uint32(970535741: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(973766362: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(976990259: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(980207460: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(983417994: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(986621888: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(989819169: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(993009864: int32)
cmplStd/lib/math/Fixed.ci:165: warn: adding implicit cast uint32(996194001: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(999371606: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1002542706: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1005707329: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1008865499: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1012017244: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1015162589: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1018301561: int32)
cmplStd/lib/math/Fixed.ci:166: warn: adding implicit cast uint32(1021434184: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1024560486: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1027680491: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1030794225: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1033901713: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1037002979: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1040098049: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1043186947: int32)
cmplStd/lib/math/Fixed.ci:167: warn: adding implicit cast uint32(1046269698: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1049346327: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1052416857: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1055481313: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1058539719: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1061592098: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1064638475: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1067678872: int32)
cmplStd/lib/math/Fixed.ci:168: warn: adding implicit cast uint32(1070713314: int32)
cmplStd/lib/math/Fixed.ci:169: warn: adding implicit cast uint32(1073741824: int32)
cmplStd/lib/math/Fixed.ci:184: verbose: reference `error_not_implemented_yet` is not defined
cmplStd/lib/math/Fixed.ci:184: verbose: can not type check expression: `error_not_implemented_yet`
cmplStd/lib/math/Fixed.ci:192: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:192: warn: adding implicit cast uint32(value: int32)
cmplStd/lib/math/Fixed.ci:192: warn: adding implicit cast int32(mix * (tbl_log2[idx + (1)] - (value)) >> 8: uint32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1073741824: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1076653033: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1079572135: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1082499152: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1085434105: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1088377016: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1091327905: int32)
cmplStd/lib/math/Fixed.ci:257: warn: adding implicit cast uint32(1094286795: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1097253708: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1100228664: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1103211687: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1106202797: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1109202017: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1112209369: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1115224875: int32)
cmplStd/lib/math/Fixed.ci:258: warn: adding implicit cast uint32(1118248556: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1121280435: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1124320535: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1127368877: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1130425484: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1133490379: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1136563583: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1139645119: int32)
cmplStd/lib/math/Fixed.ci:259: warn: adding implicit cast uint32(1142735011: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1145833280: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1148939949: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1152055041: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1155178579: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1158310586: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1161451085: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1164600098: int32)
cmplStd/lib/math/Fixed.ci:260: warn: adding implicit cast uint32(1167757649: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1170923761: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1174098458: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1177281762: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1180473696: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1183674285: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1186883552: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1190101520: int32)
cmplStd/lib/math/Fixed.ci:261: warn: adding implicit cast uint32(1193328212: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1196563653: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1199807866: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1203060875: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1206322704: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1209593377: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1212872917: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1216161349: int32)
cmplStd/lib/math/Fixed.ci:262: warn: adding implicit cast uint32(1219458697: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1222764985: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1226080238: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1229404478: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1232737732: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1236080023: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1239431376: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1242791815: int32)
cmplStd/lib/math/Fixed.ci:263: warn: adding implicit cast uint32(1246161366: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1249540052: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1252927899: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1256324931: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1259731173: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1263146651: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1266571389: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1270005412: int32)
cmplStd/lib/math/Fixed.ci:264: warn: adding implicit cast uint32(1273448746: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1276901416: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1280363447: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1283834865: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1287315694: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1290805961: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1294305691: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1297814910: int32)
cmplStd/lib/math/Fixed.ci:265: warn: adding implicit cast uint32(1301333643: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1304861916: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1308399756: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1311947188: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1315504237: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1319070931: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1322647295: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1326233356: int32)
cmplStd/lib/math/Fixed.ci:266: warn: adding implicit cast uint32(1329829139: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1333434672: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1337049980: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1340675090: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1344310029: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1347954823: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1351609500: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1355274085: int32)
cmplStd/lib/math/Fixed.ci:267: warn: adding implicit cast uint32(1358948606: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1362633089: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1366327562: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1370032052: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1373746586: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1377471191: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1381205894: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1384950723: int32)
cmplStd/lib/math/Fixed.ci:268: warn: adding implicit cast uint32(1388705705: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1392470868: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1396246240: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1400031847: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1403827719: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1407633882: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1411450365: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1415277195: int32)
cmplStd/lib/math/Fixed.ci:269: warn: adding implicit cast uint32(1419114400: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1422962010: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1426820051: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1430688553: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1434567543: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1438457050: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1442357103: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1446267730: int32)
cmplStd/lib/math/Fixed.ci:270: warn: adding implicit cast uint32(1450188959: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1454120821: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1458063342: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1462016553: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1465980482: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1469955158: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1473940611: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1477936869: int32)
cmplStd/lib/math/Fixed.ci:271: warn: adding implicit cast uint32(1481943963: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1485961920: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1489990772: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1494030547: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1498081274: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1502142985: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1506215708: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1510299473: int32)
cmplStd/lib/math/Fixed.ci:272: warn: adding implicit cast uint32(1514394310: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1518500249: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1522617321: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1526745556: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1530884983: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1535035633: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1539197537: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1543370725: int32)
cmplStd/lib/math/Fixed.ci:273: warn: adding implicit cast uint32(1547555227: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1551751075: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1555958299: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1560176930: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1564406999: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1568648537: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1572901574: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1577166143: int32)
cmplStd/lib/math/Fixed.ci:274: warn: adding implicit cast uint32(1581442274: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1585729999: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1590029349: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1594340356: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1598663051: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1602997467: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1607343634: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1611701584: int32)
cmplStd/lib/math/Fixed.ci:275: warn: adding implicit cast uint32(1616071351: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1620452965: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1624846458: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1629251864: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1633669214: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1638098541: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1642539876: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1646993254: int32)
cmplStd/lib/math/Fixed.ci:276: warn: adding implicit cast uint32(1651458705: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1655936264: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1660425963: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1664927834: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1669441912: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1673968228: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1678506816: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1683057710: int32)
cmplStd/lib/math/Fixed.ci:277: warn: adding implicit cast uint32(1687620942: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1692196547: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1696784557: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1701385007: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1705997929: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1710623359: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1715261329: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1719911875: int32)
cmplStd/lib/math/Fixed.ci:278: warn: adding implicit cast uint32(1724575029: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1729250826: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1733939301: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1738640487: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1743354420: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1748081133: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1752820662: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1757573041: int32)
cmplStd/lib/math/Fixed.ci:279: warn: adding implicit cast uint32(1762338305: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1767116488: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1771907627: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1776711756: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1781528911: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1786359125: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1791202436: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1796058879: int32)
cmplStd/lib/math/Fixed.ci:280: warn: adding implicit cast uint32(1800928488: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1805811301: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1810707352: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1815616678: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1820539314: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1825475297: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1830424662: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1835387447: int32)
cmplStd/lib/math/Fixed.ci:281: warn: adding implicit cast uint32(1840363687: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1845353419: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1850356680: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1855373506: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1860403934: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1865448001: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1870505743: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1875577199: int32)
cmplStd/lib/math/Fixed.ci:282: warn: adding implicit cast uint32(1880662405: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1885761398: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1890874215: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1896000895: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1901141475: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1906295993: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1911464486: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1916646992: int32)
cmplStd/lib/math/Fixed.ci:283: warn: adding implicit cast uint32(1921843549: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1927054195: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1932278969: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1937517909: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1942771053: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1948038440: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1953320108: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1958616096: int32)
cmplStd/lib/math/Fixed.ci:284: warn: adding implicit cast uint32(1963926443: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1969251187: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1974590369: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1979944027: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1985312199: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1990694927: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(1996092248: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(2001504204: int32)
cmplStd/lib/math/Fixed.ci:285: warn: adding implicit cast uint32(2006930832: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2012372173: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2017828268: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2023299155: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2028784876: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2034285470: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2039800977: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2045331439: int32)
cmplStd/lib/math/Fixed.ci:286: warn: adding implicit cast uint32(2050876895: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2056437386: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2062012953: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2067603638: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2073209480: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2078830521: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2084466802: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2090118365: int32)
cmplStd/lib/math/Fixed.ci:287: warn: adding implicit cast uint32(2095785251: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2101467501: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2107165158: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2112878262: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2118606856: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2124350982: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2130110682: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2135885998: int32)
cmplStd/lib/math/Fixed.ci:288: warn: adding implicit cast uint32(2141676972: int32)
cmplStd/lib/math/Fixed.ci:289: warn: adding implicit cast uint32(2147483648: int64)
cmplStd/lib/math/Fixed.ci:307: verbose: reference `error_not_implemented_yet` is not defined
cmplStd/lib/math/Fixed.ci:307: verbose: can not type check expression: `error_not_implemented_yet`
cmplStd/lib/math/Fixed.ci:314: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:368: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/math/Fixed.ci:368: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:372: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:375: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Fixed.ci:432: warn: adding implicit cast int64(res: int32)
cmplStd/lib/math/Fixed.ci:432: warn: adding implicit cast int32((res) * sqr >> precision: int64)
cmplStd/lib/math/Fixed.ci:444: warn: adding implicit cast int64(a1: int32)
cmplStd/lib/math/Fixed.ci:458: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:458: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Fixed.ci:459: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:459: warn: adding implicit cast float64(6: int32)
cmplStd/lib/math/Fixed.ci:460: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:460: warn: adding implicit cast float64(120: int32)
cmplStd/lib/math/Fixed.ci:461: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:461: warn: adding implicit cast float64(5040: int32)
cmplStd/lib/math/Fixed.ci:462: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:462: warn: adding implicit cast float64(362880: int32)
cmplStd/lib/math/Fixed.ci:463: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:463: warn: adding implicit cast float64(39916800: int32)
warn: adding implicit cast int32(1048576.000000: float64)
warn: adding implicit cast int32(-174762.666667: float64)
warn: adding implicit cast int32(8738.133333: float64)
warn: adding implicit cast int32(-208.050794: float64)
warn: adding implicit cast int32(2.889594: float64)
warn: adding implicit cast int32(-0.026269: float64)
cmplStd/lib/math/Fixed.ci:484: warn: adding implicit cast int64(x.value: int32)
cmplStd/lib/math/Fixed.ci:536: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:536: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Fixed.ci:537: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:537: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Fixed.ci:538: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:538: warn: adding implicit cast float64(24: int32)
cmplStd/lib/math/Fixed.ci:539: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:539: warn: adding implicit cast float64(720: int32)
cmplStd/lib/math/Fixed.ci:540: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:540: warn: adding implicit cast float64(40320: int32)
cmplStd/lib/math/Fixed.ci:541: warn: adding implicit cast float64(one: int32)
cmplStd/lib/math/Fixed.ci:541: warn: adding implicit cast float64(3628800: int32)
warn: adding implicit cast int32(1048576.000000: float64)
warn: adding implicit cast int32(-524288.000000: float64)
warn: adding implicit cast int32(43690.666667: float64)
warn: adding implicit cast int32(-1456.355556: float64)
warn: adding implicit cast int32(26.006349: float64)
warn: adding implicit cast int32(-0.288959: float64)
cmplStd/lib/math/Fixed.ci:562: warn: adding implicit cast int64(x.value: int32)
cmplStd/lib/math/Fixed.ci:715: warn: adding implicit cast int64(radians.value: int32)
cmplStd/lib/math/Fixed.ci:2: warn: padding `Fixed` with 4 bytes: (4 -> 8)
cmplStd/lib/math/Fixed.ci:733: warn: adding implicit cast float64((1 << Fixed.precision): int32)
cmplStd/lib/math/Fixed.ci:738: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Fixed.ci:741: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Fixed.ci:761: warn: adding implicit cast float64(value.value: int32)
cmplStd/lib.ci:27: debug: inline file: `cmplStd/lib/math/Complex.ci`
cmplStd/lib/math/Complex.ci:12: debug: using default field initializer: Complex.im := 0
cmplStd/lib/math/Complex.ci:8: warn: adding implicit cast float64(0: int32)
cmplStd/lib.ci:28: debug: inline file: `cmplStd/lib/math/Vector4f.ci`
cmplStd/lib.ci:29: debug: inline file: `cmplStd/lib/math/Matrix4f.ci`
cmplStd/lib/math/Matrix4f.ci:111: warn: adding implicit cast float64(len: float32)
cmplStd/lib/math/Matrix4f.ci:135: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:167: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:174: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:179: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:184: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:193: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:193: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:193: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:194: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:194: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:194: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:195: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:195: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:195: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:196: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:202: warn: adding implicit cast float32(1: int32)
cmplStd/lib/math/Matrix4f.ci:202: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:202: warn: adding implicit cast float64((val < (0) ? -val : val): float32)
cmplStd/lib/math/Matrix4f.ci:202: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:204: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:205: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:205: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:205: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:206: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:206: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:206: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(0: int32)
cmplStd/lib/math/Matrix4f.ci:207: warn: adding implicit cast float32(1: int32)
cmplStd/lib.ci:30: debug: inline file: `cmplStd/lib/math/Vector2d.ci`
cmplStd/lib.ci:39: debug: inline file: `cmplStd/lib/time/Timeunit.ci`
cmplStd/lib/time/Timeunit.ci:4: warn: adding implicit cast Timeunit(1: int32)
cmplStd/lib/time/Timeunit.ci:5: warn: adding implicit cast int64(1000: int32)
warn: adding implicit cast Timeunit(1000: int64)
cmplStd/lib/time/Timeunit.ci:6: warn: adding implicit cast int64(1000: int32)
warn: adding implicit cast Timeunit(1000000: int64)
cmplStd/lib/time/Timeunit.ci:7: warn: adding implicit cast int64(1000: int32)
warn: adding implicit cast Timeunit(1000000000: int64)
cmplStd/lib/time/Timeunit.ci:8: warn: adding implicit cast int64(60: int32)
warn: adding implicit cast Timeunit(60000000000: int64)
cmplStd/lib/time/Timeunit.ci:9: warn: adding implicit cast int64(60: int32)
warn: adding implicit cast Timeunit(3600000000000: int64)
cmplStd/lib/time/Timeunit.ci:10: warn: adding implicit cast int64(24: int32)
warn: adding implicit cast Timeunit(86400000000000: int64)
cmplStd/lib/time/Timeunit.ci:27: warn: adding implicit cast float64((from / to): int64)
cmplStd/lib/time/Timeunit.ci:30: warn: adding implicit cast float64((to / from): int64)
cmplStd/lib.ci:40: debug: inline file: `cmplStd/lib/time/Duration.ci`
cmplStd/lib/time/Duration.ci:8: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib.ci:41: debug: inline file: `cmplStd/lib/time/Timestamp.ci`
cmplStd/lib/time/Timestamp.ci:9: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib/time/Timestamp.ci:56: warn: adding implicit cast int64(Timestamp.precision: Timeunit)
cmplStd/lib/time/Timestamp.ci:74: warn: adding implicit cast int64(Timestamp.precision: Timeunit)
cmplStd/lib/time/Timestamp.ci:80: warn: adding implicit cast int64(0: int32)
cmplStd/lib/time/Timestamp.ci:96: warn: adding implicit cast int64(0: int32)
cmplStd/lib/time/Timestamp.ci:115: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib.ci:42: debug: inline file: `cmplStd/lib/time/Timezone.ci`
cmplStd/lib/time/Timezone.ci:14: warn: adding implicit cast int64(0: int32)
cmplStd/lib/time/Timezone.ci:18: warn: adding implicit cast char[]("UTC": .cstr)
cmplStd/lib/time/Timezone.ci:29: warn: adding implicit cast Timeunit(Hours: int64)
cmplStd/lib/time/Timezone.ci:33: warn: adding implicit cast char[]("GMT+3": .cstr)
cmplStd/lib/time/Timezone.ci:2: warn: padding `Timezone` with 4 bytes: (12 -> 16)
cmplStd/lib.ci:43: debug: inline file: `cmplStd/lib/time/Datetime.ci`
cmplStd/lib/time/Datetime.ci:3: warn: adding implicit cast Month(1: int32)
warn: adding implicit cast Month(2: int64)
warn: adding implicit cast Month(3: int64)
warn: adding implicit cast Month(4: int64)
warn: adding implicit cast Month(5: int64)
warn: adding implicit cast Month(6: int64)
warn: adding implicit cast Month(7: int64)
warn: adding implicit cast Month(8: int64)
warn: adding implicit cast Month(9: int64)
warn: adding implicit cast Month(10: int64)
warn: adding implicit cast Month(11: int64)
warn: adding implicit cast Month(12: int64)
cmplStd/lib/time/Datetime.ci:17: warn: adding implicit cast Month(January: uint8)
cmplStd/lib/time/Datetime.ci:17: warn: adding implicit cast int32(Month.(January): Month)
cmplStd/lib/time/Datetime.ci:19: warn: adding implicit cast Month(January: uint8)
cmplStd/lib/time/Datetime.ci:19: warn: adding implicit cast uint8(Month.(January): Month)
cmplStd/lib/time/Datetime.ci:23: warn: adding implicit cast Weekday(1: int32)
warn: adding implicit cast Weekday(2: int64)
warn: adding implicit cast Weekday(3: int64)
warn: adding implicit cast Weekday(4: int64)
warn: adding implicit cast Weekday(5: int64)
warn: adding implicit cast Weekday(6: int64)
warn: adding implicit cast Weekday(7: int64)
cmplStd/lib/time/Datetime.ci:32: warn: adding implicit cast Weekday(Monday: uint8)
cmplStd/lib/time/Datetime.ci:32: warn: adding implicit cast int32(Weekday.(Monday): Weekday)
cmplStd/lib/time/Datetime.ci:34: warn: adding implicit cast Weekday(Monday: uint8)
cmplStd/lib/time/Datetime.ci:34: warn: adding implicit cast uint8(Weekday.(Monday): Weekday)
warn: adding implicit cast Calendar(0: int64)
cmplStd/lib/time/Datetime.ci:76: warn: padding `Datetime.millis` with 1 bytes: (9 -> 10)
cmplStd/lib/time/Datetime.ci:79: warn: padding `Datetime.timezone` with 4 bytes: (12 -> 16)
cmplStd/lib/time/Datetime.ci:89: warn: padding `Datetime.dayOfYear` with 1 bytes: (33 -> 34)
cmplStd/lib/time/Datetime.ci:57: warn: padding `Datetime` with 2 bytes: (38 -> 40)
cmplStd/lib/time/Datetime.ci:157: warn: adding implicit cast Month(January: uint8)
cmplStd/lib/time/Datetime.ci:157: warn: adding implicit cast int32(Month.(January): Month)
cmplStd/lib/time/Datetime.ci:157: warn: adding implicit cast Month(December: uint8)
cmplStd/lib/time/Datetime.ci:157: warn: adding implicit cast int32(Month.(December): Month)
cmplStd/lib/time/Datetime.ci:159: warn: adding implicit cast Month(January: uint8)
cmplStd/lib/time/Datetime.ci:159: warn: adding implicit cast Month(December: uint8)
cmplStd/lib/time/Datetime.ci:162: warn: adding implicit cast int32[13](Datetime.DaysToMonth366: int32[13])
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(24: int32)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(value.hour: uint8)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(60: int32)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(value.minute: uint8)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(60: int32)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(value.second: uint8)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(1000: int32)
cmplStd/lib/time/Datetime.ci:174: warn: adding implicit cast int64(value.millis: uint16)
cmplStd/lib/time/Datetime.ci:175: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib/time/Datetime.ci:180: warn: adding implicit cast Calendar(Gregorian: uint8)
cmplStd/lib/time/Datetime.ci:180: warn: adding implicit cast uint8(Calendar.(Gregorian): Calendar)
cmplStd/lib/time/Datetime.ci:198: warn: adding implicit cast Timeunit(Days: int64)
cmplStd/lib/time/Datetime.ci:198: warn: adding implicit cast int64(Datetime.DaysTil1970: int32)
cmplStd/lib/time/Datetime.ci:239: warn: adding implicit cast int32[13](Datetime.DaysToMonth366: int32[13])
cmplStd/lib/time/Datetime.ci:253: warn: adding implicit cast Timeunit(Hours: int64)
cmplStd/lib/time/Datetime.ci:253: warn: adding implicit cast int64(24: int32)
cmplStd/lib/time/Datetime.ci:254: warn: adding implicit cast Timeunit(Minutes: int64)
cmplStd/lib/time/Datetime.ci:254: warn: adding implicit cast int64(60: int32)
cmplStd/lib/time/Datetime.ci:255: warn: adding implicit cast Timeunit(Seconds: int64)
cmplStd/lib/time/Datetime.ci:255: warn: adding implicit cast int64(60: int32)
cmplStd/lib/time/Datetime.ci:256: warn: adding implicit cast Timeunit(Millis: int64)
cmplStd/lib/time/Datetime.ci:256: warn: adding implicit cast int64(1000: int32)
cmplStd/lib/time/Datetime.ci:264: warn: adding implicit cast Weekday(Thursday: uint8)
cmplStd/lib/time/Datetime.ci:265: warn: adding implicit cast int32[13](DaysToMonth: int32[*])
cmplStd/lib/time/Datetime.ci:250: warn: adding implicit cast uint8(n - DaysToMonth[m - 1] + 1: int32)
cmplStd/lib/time/Datetime.ci:253: warn: adding implicit cast uint8(Timestamp.value(timestamp, Timeunit.(Hours)) % (24): int64)
cmplStd/lib/time/Datetime.ci:254: warn: adding implicit cast uint8(Timestamp.value(timestamp, Timeunit.(Minutes)) % (60): int64)
cmplStd/lib/time/Datetime.ci:255: warn: adding implicit cast uint8(Timestamp.value(timestamp, Timeunit.(Seconds)) % (60): int64)
cmplStd/lib/time/Datetime.ci:256: warn: adding implicit cast uint16(Timestamp.value(timestamp, Timeunit.(Millis)) % (1000): int64)
cmplStd/lib/time/Datetime.ci:262: warn: adding implicit cast uint16(n + 1: int32)
cmplStd/lib/time/Datetime.ci:264: warn: adding implicit cast uint8((n - dayOfWeek + indexOf(Weekday.(Thursday))) / 7 + 1: int32)
cmplStd/lib/time/Datetime.ci:270: warn: adding implicit cast Calendar(Gregorian: uint8)
cmplStd/lib/time/Datetime.ci:285: warn: adding implicit cast Weekday(Monday: uint8)
cmplStd/lib/time/Datetime.ci:277: warn: adding implicit cast uint8(day: int32)
cmplStd/lib/time/Datetime.ci:278: warn: adding implicit cast uint8(hour: int32)
cmplStd/lib/time/Datetime.ci:279: warn: adding implicit cast uint8(minute: int32)
cmplStd/lib/time/Datetime.ci:280: warn: adding implicit cast uint8(second: int32)
cmplStd/lib/time/Datetime.ci:281: warn: adding implicit cast uint16(millis: int32)
cmplStd/lib/time/Datetime.ci:283: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/time/Datetime.ci:284: warn: adding implicit cast uint16(0: int32)
cmplStd/lib.ci:47: debug: inline file: `cmplStd/lib/text/cstr.ci`
cmplStd/lib/text/cstr.ci:5: warn: adding implicit cast pointer(str: char[*])
cmplStd/lib/text/cstr.ci:37: warn: adding implicit cast int32(with[i]: char)
cmplStd/lib/text/cstr.ci:65: warn: adding implicit cast int32(str[i]: char)
cmplStd/lib/text/cstr.ci:119: warn: adding implicit cast pointer(typename(float64.parse): typename)
cmplStd/lib/text/cstr.ci:119: warn: adding implicit cast bool(preferNativeCalls: int64)
cmplStd/lib/text/cstr.ci:122: warn: adding implicit cast int32(value.length: uint32)
cmplStd/lib/text/cstr.ci:122: warn: adding implicit cast int32(value[len]: char)
cmplStd/lib/text/cstr.ci:132: warn: adding implicit cast int32(value.length: uint32)
cmplStd/lib/text/cstr.ci:132: warn: adding implicit cast int32(value[i]: char)
cmplStd/lib/text/cstr.ci:135: warn: adding implicit cast float64(10: int32)
cmplStd/lib/text/cstr.ci:135: warn: adding implicit cast float64((chr - '0'): char)
cmplStd/lib/text/cstr.ci:136: warn: adding implicit cast float64(10: int32)
cmplStd/lib/text/cstr.ci:139: warn: adding implicit cast float64(0: int32)
cmplStd/lib/text/cstr.ci:143: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/cstr.ci:146: warn: adding implicit cast float64(-1: int32)
cmplStd/lib/text/cstr.ci:149: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/cstr.ci:157: warn: adding implicit cast float64(0: int32)
cmplStd/lib/text/cstr.ci:158: warn: adding implicit cast uint32(0: int32)
cmplStd/lib.ci:48: debug: inline file: `cmplStd/lib/text/Format.ci`
cmplStd/lib/text/Format.ci:21: warn: adding implicit cast int32('%': char)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.precision := 10
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.width := 0
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/Format.ci:7: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/Format.ci:4: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:26: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:28: warn: adding implicit cast int32('%': char)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.precision := 10
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.width := 0
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/Format.ci:7: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/Format.ci:4: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:33: warn: adding implicit cast int32('-': char)
cmplStd/lib/text/Format.ci:33: warn: adding implicit cast int32('+': char)
cmplStd/lib/text/Format.ci:36: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:40: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:43: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:47: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:47: warn: adding implicit cast int32('9': char)
cmplStd/lib/text/Format.ci:49: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:50: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:54: warn: adding implicit cast int32('.': char)
cmplStd/lib/text/Format.ci:56: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:57: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:57: warn: adding implicit cast int32('9': char)
cmplStd/lib/text/Format.ci:59: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:60: warn: adding implicit cast int32(format[pos]: char)
cmplStd/lib/text/Format.ci:65: warn: adding implicit cast char(sgnChr: int32)
cmplStd/lib/text/Format.ci:67: warn: adding implicit cast char(padChr: int32)
cmplStd/lib/text/Format.ci:19: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:73: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:10: warn: padding `FormatFlags.width` with 2 bytes: (2 -> 4)
cmplStd/lib/text/Format.ci:2: warn: padding `FormatFlags` with 3 bytes: (13 -> 16)
cmplStd/lib/text/Format.ci:88: warn: adding implicit cast pointer(value: char[*])
cmplStd/lib/text/Format.ci:92: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:99: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:100: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:100: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:102: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:115: warn: adding implicit cast int32(radixDigits.length: uint32)
cmplStd/lib/text/Format.ci:118: warn: adding implicit cast uint64(0: int32)
cmplStd/lib/text/Format.ci:118: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/text/Format.ci:119: warn: adding implicit cast uint64(radix: int32)
cmplStd/lib/text/Format.ci:133: warn: adding implicit cast int32(format.sign: char)
cmplStd/lib/text/Format.ci:138: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:143: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:150: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:157: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:162: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:163: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:163: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:165: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:171: warn: adding implicit cast int64(0: int32)
cmplStd/lib/text/Format.ci:172: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:186: warn: adding implicit cast float64(0: int32)
cmplStd/lib/text/Format.ci:185: debug: using default field initializer: FormatFlags.precision := 10
cmplStd/lib/text/Format.ci:185: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib/text/Format.ci:192: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:193: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:193: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:206: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:207: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:207: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:211: warn: adding implicit cast float64(2: int32)
cmplStd/lib/text/Format.ci:213: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/Format.ci:214: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/Format.ci:215: warn: adding implicit cast float64(1: int32)
cmplStd/lib/text/Format.ci:219: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:220: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:220: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:225: warn: adding implicit cast float64(10: int32)
cmplStd/lib/text/Format.ci:226: warn: adding implicit cast int32('0': char)
cmplStd/lib/text/Format.ci:226: warn: adding implicit cast char(('0') + int32(value): int32)
cmplStd/lib/text/Format.ci:229: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:230: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:230: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:234: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:243: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:246: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:321: warn: adding implicit cast int32(format.length: uint32)
cmplStd/lib/text/Format.ci:322: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:323: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:323: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:324: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:418: warn: adding implicit cast int32(value.millis: uint16)
cmplStd/lib/text/Format.ci:422: warn: adding implicit cast int32(value.hour: uint8)
cmplStd/lib/text/Format.ci:426: warn: adding implicit cast int32(value.hour: uint8)
cmplStd/lib/text/Format.ci:436: warn: adding implicit cast Timeunit(Seconds: int64)
cmplStd/lib/text/Format.ci:487: warn: adding implicit cast int32(output.length: uint32)
cmplStd/lib/text/Format.ci:488: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/text/Format.ci:488: warn: adding implicit cast int32(output.length - (1): uint32)
cmplStd/lib/text/Format.ci:490: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:509: warn: adding implicit cast char[]("January": .cstr)
cmplStd/lib/text/Format.ci:510: warn: adding implicit cast char[]("February": .cstr)
cmplStd/lib/text/Format.ci:511: warn: adding implicit cast char[]("March": .cstr)
cmplStd/lib/text/Format.ci:512: warn: adding implicit cast char[]("April": .cstr)
cmplStd/lib/text/Format.ci:513: warn: adding implicit cast char[]("May": .cstr)
cmplStd/lib/text/Format.ci:514: warn: adding implicit cast char[]("June": .cstr)
cmplStd/lib/text/Format.ci:515: warn: adding implicit cast char[]("July": .cstr)
cmplStd/lib/text/Format.ci:516: warn: adding implicit cast char[]("August": .cstr)
cmplStd/lib/text/Format.ci:517: warn: adding implicit cast char[]("September": .cstr)
cmplStd/lib/text/Format.ci:518: warn: adding implicit cast char[]("October": .cstr)
cmplStd/lib/text/Format.ci:519: warn: adding implicit cast char[]("November": .cstr)
cmplStd/lib/text/Format.ci:520: warn: adding implicit cast char[]("December": .cstr)
cmplStd/lib/text/Format.ci:523: warn: adding implicit cast char[]("Jan": .cstr)
cmplStd/lib/text/Format.ci:523: warn: adding implicit cast char[]("Feb": .cstr)
cmplStd/lib/text/Format.ci:523: warn: adding implicit cast char[]("Mar": .cstr)
cmplStd/lib/text/Format.ci:523: warn: adding implicit cast char[]("Apr": .cstr)
cmplStd/lib/text/Format.ci:524: warn: adding implicit cast char[]("May": .cstr)
cmplStd/lib/text/Format.ci:524: warn: adding implicit cast char[]("Jun": .cstr)
cmplStd/lib/text/Format.ci:524: warn: adding implicit cast char[]("Jul": .cstr)
cmplStd/lib/text/Format.ci:524: warn: adding implicit cast char[]("Aug": .cstr)
cmplStd/lib/text/Format.ci:525: warn: adding implicit cast char[]("Sep": .cstr)
cmplStd/lib/text/Format.ci:525: warn: adding implicit cast char[]("Oct": .cstr)
cmplStd/lib/text/Format.ci:525: warn: adding implicit cast char[]("Nov": .cstr)
cmplStd/lib/text/Format.ci:525: warn: adding implicit cast char[]("Dec": .cstr)
cmplStd/lib/text/Format.ci:528: warn: adding implicit cast char[]("Monday": .cstr)
cmplStd/lib/text/Format.ci:529: warn: adding implicit cast char[]("Tuesday": .cstr)
cmplStd/lib/text/Format.ci:530: warn: adding implicit cast char[]("Wednesday": .cstr)
cmplStd/lib/text/Format.ci:531: warn: adding implicit cast char[]("Thursday": .cstr)
cmplStd/lib/text/Format.ci:532: warn: adding implicit cast char[]("Friday": .cstr)
cmplStd/lib/text/Format.ci:533: warn: adding implicit cast char[]("Saturday": .cstr)
cmplStd/lib/text/Format.ci:534: warn: adding implicit cast char[]("Sunday": .cstr)
cmplStd/lib/text/Format.ci:537: warn: adding implicit cast char[]("Mon": .cstr)
cmplStd/lib/text/Format.ci:537: warn: adding implicit cast char[]("Tue": .cstr)
cmplStd/lib/text/Format.ci:537: warn: adding implicit cast char[]("Wed": .cstr)
cmplStd/lib/text/Format.ci:538: warn: adding implicit cast char[]("Thu": .cstr)
cmplStd/lib/text/Format.ci:538: warn: adding implicit cast char[]("Fri": .cstr)
cmplStd/lib/text/Format.ci:538: warn: adding implicit cast char[]("Sat": .cstr)
cmplStd/lib/text/Format.ci:539: warn: adding implicit cast char[]("Sun": .cstr)
cmplStd/lib/text/Format.ci:542: warn: adding implicit cast char[]("AM": .cstr)
cmplStd/lib/text/Format.ci:543: warn: adding implicit cast char[]("PM": .cstr)
cmplStd/lib/text/Format.ci:546: warn: adding implicit cast char[]("am": .cstr)
cmplStd/lib/text/Format.ci:547: warn: adding implicit cast char[]("pm": .cstr)
cmplStd/lib/text/Format.ci:551: warn: adding implicit cast char[][](monthsLongEn: char[][])
cmplStd/lib/text/Format.ci:552: warn: adding implicit cast char[][](monthsShortEn: char[][])
cmplStd/lib/text/Format.ci:553: warn: adding implicit cast char[][](weeksLongEn: char[][])
cmplStd/lib/text/Format.ci:554: warn: adding implicit cast char[][](weeksShortEn: char[][])
cmplStd/lib/text/Format.ci:555: warn: adding implicit cast char[][](amPmUpperEn: char[][])
cmplStd/lib/text/Format.ci:556: warn: adding implicit cast char[][](amPmLowerEn: char[][])
cmplStd/lib/text/Format.ci:550: debug: using default field initializer: DatetimeFormat.dateLong := "%A %d %B %Y"
cmplStd/lib/text/Format.ci:308: warn: adding implicit cast char[]("%A %d %B %Y": .cstr)
cmplStd/lib/text/Format.ci:550: debug: using default field initializer: DatetimeFormat.timeLong := "%r"
cmplStd/lib/text/Format.ci:309: warn: adding implicit cast char[]("%r": .cstr)
cmplStd/lib/text/Format.ci:550: debug: using default field initializer: DatetimeFormat.dateShort := "%x"
cmplStd/lib/text/Format.ci:310: warn: adding implicit cast char[]("%x": .cstr)
cmplStd/lib/text/Format.ci:550: debug: using default field initializer: DatetimeFormat.timeShort := "%I:%M %p"
cmplStd/lib/text/Format.ci:311: warn: adding implicit cast char[]("%I:%M %p": .cstr)
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.sign := 0
cmplStd/lib/text/Format.ci:4: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.padChr := 0
cmplStd/lib/text/Format.ci:7: warn: adding implicit cast char(0: int32)
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.width := 0
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.precision := 10
cmplStd/lib/text/Format.ci:564: debug: using default field initializer: FormatFlags.trimDecimal := true
cmplStd/lib.ci:49: debug: inline file: `cmplStd/lib/text/stream/ByteStream.ci`
cmplStd/lib/text/stream/ByteStream.ci:8: warn: adding implicit cast pointer(this.close: function)
cmplStd/lib/text/stream/ByteStream.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/text/stream/ByteStream.ci:104: warn: Overriding virtual function: ByteReader.read(this: ByteReader, bytes: uint8[]): int32
cmplStd/lib/text/stream/ByteStream.ci:113: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib/text/stream/ByteStream.ci:126: warn: Creating virtual method for: ByteBuffer.read(this: ByteBuffer, bytes: uint8[]): int32
cmplStd/lib/text/stream/ByteStream.ci:130: warn: adding implicit cast int32(bytes.length: uint32)
cmplStd/lib/text/stream/ByteStream.ci:140: warn: Creating virtual method for: ByteBuffer.read(this: ByteBuffer): int32
cmplStd/lib/text/stream/ByteStream.ci:149: warn: Creating virtual method for: ByteBuffer.write(this: ByteBuffer, bytes: uint8[]): void
cmplStd/lib/text/stream/ByteStream.ci:150: warn: adding implicit cast int32(bytes.length: uint32)
cmplStd/lib/text/stream/ByteStream.ci:165: warn: adding implicit cast uint8[*](new: uint8[*])
cmplStd/lib/text/stream/ByteStream.ci:169: warn: adding implicit cast int32(bytes.length: uint32)
cmplStd/lib/text/stream/ByteStream.ci:175: warn: Creating virtual method for: ByteBuffer.flush(this: ByteBuffer): void
cmplStd/lib/text/stream/ByteStream.ci:179: warn: Creating virtual method for: ByteBuffer.close(this: ByteBuffer): void
cmplStd/lib/text/stream/ByteStream.ci:183: warn: adding implicit cast uint8[*](null: pointer)
cmplStd/lib/text/stream/ByteStream.ci:120: warn: padding `ByteBuffer` with 4 bytes: (36 -> 40)
cmplStd/lib.ci:50: debug: inline file: `cmplStd/lib/text/stream/TextStream.ci`
cmplStd/lib/text/stream/TextStream.ci:19: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib/text/stream/TextStream.ci:26: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/text/stream/TextStream.ci:30: warn: adding implicit cast uint32(16777215: int32)
cmplStd/lib/text/stream/TextStream.ci:67: warn: Creating virtual method for: TextWriter.flush(this: TextWriter): void
cmplStd/lib/text/stream/TextStream.ci:72: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib.ci:51: debug: inline file: `cmplStd/lib/text/encoding/binary/Base64.ci`
cmplStd/lib/text/encoding/binary/Base64.ci:41: warn: Overriding virtual function: ByteWriter.write(this: ByteWriter, bytes: uint8[]): void
cmplStd/lib/text/encoding/binary/Base64.ci:42: warn: adding implicit cast int32(length: uint32)
cmplStd/lib/text/encoding/binary/Base64.ci:50: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:50: warn: adding implicit cast uint32(0: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:51: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:52: warn: adding implicit cast uint32(2: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:55: warn: adding implicit cast int32(data[i]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:63: warn: adding implicit cast int32(data[i]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:64: warn: adding implicit cast int32(data[i + 1]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:72: warn: adding implicit cast int32(data[i]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:80: warn: adding implicit cast uint32(2: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:81: warn: adding implicit cast int32(buffer.length: uint32)
cmplStd/lib/text/encoding/binary/Base64.ci:86: warn: adding implicit cast int32(data[i + 0]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:87: warn: adding implicit cast int32(data[i + 1]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:88: warn: adding implicit cast int32(data[i + 2]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:97: warn: adding implicit cast uint32(i: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:98: warn: adding implicit cast int32(buffer.length: uint32)
cmplStd/lib/text/encoding/binary/Base64.ci:103: warn: adding implicit cast int32(data[i + 0]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:104: warn: adding implicit cast int32(data[i + 1]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:108: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:113: warn: adding implicit cast int32(data[i]: uint8)
cmplStd/lib/text/encoding/binary/Base64.ci:116: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:117: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:124: warn: Overriding virtual function: ByteWriter.flush(this: ByteWriter): void
cmplStd/lib/text/encoding/binary/Base64.ci:129: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib/text/encoding/binary/Base64.ci:162: warn: Overriding virtual function: ByteReader.read(this: ByteReader, bytes: uint8[]): int32
cmplStd/lib/text/encoding/binary/Base64.ci:165: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/text/encoding/binary/Base64.ci:169: warn: adding implicit cast int32(data.length: uint32)
cmplStd/lib/text/encoding/binary/Base64.ci:173: warn: adding implicit cast uint8('=': char)
cmplStd/lib/text/encoding/binary/Base64.ci:190: warn: Overriding virtual function: Closeable.close(this: Closeable): void
cmplStd/lib.ci:52: debug: inline file: `cmplStd/lib/text/encoding/Ascii.ci`
cmplStd/lib/text/encoding/Ascii.ci:4: warn: Overriding virtual function: TextReader.decode(this: TextReader, chars: uint32[]): int32
cmplStd/lib/text/encoding/Ascii.ci:6: warn: adding implicit cast int32(chars.length: uint32)
cmplStd/lib/text/encoding/Ascii.ci:12: warn: adding implicit cast uint32(value[0]: uint8)
cmplStd/lib/text/encoding/Ascii.ci:21: warn: Overriding virtual function: TextWriter.encode(this: TextWriter, chars: uint32[]): void
cmplStd/lib/text/encoding/Ascii.ci:23: warn: adding implicit cast int32(chars.length: uint32)
cmplStd/lib/text/encoding/Ascii.ci:24: warn: adding implicit cast uint8(chars[i]: uint32)
cmplStd/lib.ci:53: debug: inline file: `cmplStd/lib/text/encoding/Utf8.ci`
cmplStd/lib/text/encoding/Utf8.ci:4: warn: Overriding virtual function: TextReader.decode(this: TextReader, chars: uint32[]): int32
cmplStd/lib/text/encoding/Utf8.ci:5: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/text/encoding/Utf8.ci:6: warn: adding implicit cast uint8(0: int32)
cmplStd/lib/text/encoding/Utf8.ci:8: warn: adding implicit cast int32(chars.length: uint32)
cmplStd/lib/text/encoding/Utf8.ci:14: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:15: warn: adding implicit cast uint32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:17: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:22: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:23: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:23: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:23: warn: adding implicit cast uint32(((buff[0]) & 31) << 6 | ((ext[0]) & 63): int32)
cmplStd/lib/text/encoding/Utf8.ci:25: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:30: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:31: warn: adding implicit cast int32(ext[1]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:32: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:32: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:32: warn: adding implicit cast int32(ext[1]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:32: warn: adding implicit cast uint32(((buff[0]) & 15) << 12 | ((ext[0]) & 63) << 6 | ((ext[1]) & 63): int32)
cmplStd/lib/text/encoding/Utf8.ci:34: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:39: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:40: warn: adding implicit cast int32(ext[1]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:41: warn: adding implicit cast int32(ext[2]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast int32(buff[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast int32(ext[0]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast int32(ext[1]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast int32(ext[2]: uint8)
cmplStd/lib/text/encoding/Utf8.ci:42: warn: adding implicit cast uint32(((buff[0]) & 7) << 18 | ((ext[0]) & 63) << 12 | ((ext[1]) & 63) << 6 | ((ext[2]) & 63): int32)
cmplStd/lib/text/encoding/Utf8.ci:53: warn: Overriding virtual function: TextWriter.encode(this: TextWriter, chars: uint32[]): void
cmplStd/lib/text/encoding/Utf8.ci:55: warn: adding implicit cast int32(chars.length: uint32)
cmplStd/lib/text/encoding/Utf8.ci:58: warn: adding implicit cast uint32(128: int32)
cmplStd/lib/text/encoding/Utf8.ci:59: warn: adding implicit cast uint8(cp: uint32)
cmplStd/lib/text/encoding/Utf8.ci:62: warn: adding implicit cast uint32(2048: int32)
cmplStd/lib/text/encoding/Utf8.ci:64: warn: adding implicit cast int32((cp >> 6): uint32)
cmplStd/lib/text/encoding/Utf8.ci:65: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:65: warn: adding implicit cast int32((cp & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:64: warn: adding implicit cast uint8(192 | ((cp >> 6)): int32)
cmplStd/lib/text/encoding/Utf8.ci:65: warn: adding implicit cast uint8(128 | ((cp & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:69: warn: adding implicit cast uint32(65536: int32)
cmplStd/lib/text/encoding/Utf8.ci:71: warn: adding implicit cast int32((cp >> 12): uint32)
cmplStd/lib/text/encoding/Utf8.ci:72: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:72: warn: adding implicit cast int32(((cp >> 6) & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:73: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:73: warn: adding implicit cast int32((cp & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:71: warn: adding implicit cast uint8(224 | ((cp >> 12)): int32)
cmplStd/lib/text/encoding/Utf8.ci:72: warn: adding implicit cast uint8(128 | (((cp >> 6) & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:73: warn: adding implicit cast uint8(128 | ((cp & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:79: warn: adding implicit cast int32((cp >> 18): uint32)
cmplStd/lib/text/encoding/Utf8.ci:80: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:80: warn: adding implicit cast int32(((cp >> 12) & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:81: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:81: warn: adding implicit cast int32(((cp >> 6) & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:82: warn: adding implicit cast uint32(63: int32)
cmplStd/lib/text/encoding/Utf8.ci:82: warn: adding implicit cast int32((cp & (63)): uint32)
cmplStd/lib/text/encoding/Utf8.ci:79: warn: adding implicit cast uint8(240 | ((cp >> 18)): int32)
cmplStd/lib/text/encoding/Utf8.ci:80: warn: adding implicit cast uint8(128 | (((cp >> 12) & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:81: warn: adding implicit cast uint8(128 | (((cp >> 6) & (63))): int32)
cmplStd/lib/text/encoding/Utf8.ci:82: warn: adding implicit cast uint8(128 | ((cp & (63))): int32)
cmplStd/lib.ci:63: debug: inline file: `cmplStd/lib/math/Easing.ci`
cmplStd/lib/math/Easing.ci:32: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:32: warn: adding implicit cast float64(10: int32)
cmplStd/lib/math/Easing.ci:32: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Easing.ci:32: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Easing.ci:37: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Easing.ci:37: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:42: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:42: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:47: warn: statement should be a block statement {return .result := t;}
cmplStd/lib/math/Easing.ci:55: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:61: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:64: warn: adding implicit cast float64(4: int32)
cmplStd/lib/math/Easing.ci:67: warn: adding implicit cast float64(8: int32)
cmplStd/lib/math/Easing.ci:68: warn: adding implicit cast float64(6: int32)
cmplStd/lib/math/Easing.ci:69: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:71: warn: adding implicit cast float64(10: int32)
cmplStd/lib/math/Easing.ci:72: warn: adding implicit cast float32(9: int32)
cmplStd/lib/math/Easing.ci:72: warn: adding implicit cast float64(((9) / 11.000000): float32)
cmplStd/lib/math/Easing.ci:73: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:75: warn: adding implicit cast float64(21: int32)
cmplStd/lib/math/Easing.ci:76: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:79: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:79: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:85: warn: adding implicit cast pointer(ease: function)
cmplStd/lib/math/Easing.ci:93: warn: adding implicit cast pointer(ease: function)
cmplStd/lib/math/Easing.ci:96: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:101: warn: adding implicit cast pointer(ease: function)
cmplStd/lib/math/Easing.ci:104: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Easing.ci:105: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:105: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:110: warn: adding implicit cast pointer(ease: function)
cmplStd/lib/math/Easing.ci:113: warn: adding implicit cast float64(2: int32)
cmplStd/lib/math/Easing.ci:114: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Easing.ci:114: warn: adding implicit cast float64(1: int32)
cmplStd/lib.ci:65: debug: inline file: `cmplStd/lib/math/Polynomial.ci`
cmplStd/lib/math/Polynomial.ci:9: warn: adding implicit cast float64(0: int32)
cmplStd/lib/math/Polynomial.ci:10: warn: adding implicit cast float64(1: int32)
cmplStd/lib/math/Polynomial.ci:14: warn: Overriding virtual function: TextWriter.Writeable.write(this: Writeable, writer: TextWriter): void
cmplStd/lib/math/Polynomial.ci:54: warn: Creating virtual method for: Polynomial.destroy(this: Polynomial): void
cmplStd/lib/math/Polynomial.ci:61: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Polynomial.ci:65: warn: adding implicit cast float64[*](coefficients: float64[*])
cmplStd/lib/math/Polynomial.ci:63: debug: using default field initializer: Polynomial.destroy(this: Polynomial): void := destroy
cmplStd/lib/math/Polynomial.ci:63: debug: using default type initializer: TextWriter.Writeable.write(this: Writeable, writer: TextWriter): void := write
cmplStd/lib/math/Polynomial.ci:69: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Polynomial.ci:157: warn: adding implicit cast float64((i + 1): int32)
cmplStd/lib/math/Polynomial.ci:167: warn: adding implicit cast float64(i: int32)
cmplStd/lib/math/Polynomial.ci:178: warn: adding implicit cast uint32(1: int32)
cmplStd/lib/math/Polynomial.ci:179: warn: adding implicit cast int32(values.length: uint32)
cmplStd/lib/math/Polynomial.ci:180: warn: adding implicit cast uint32(i: int32)
cmplStd/lib/math/Polynomial.ci:180: warn: adding implicit cast uint32(1: int32)

---------- Compile: `cmplStd/test/test.ci`
cmplStd/test/test.ci:9: debug: inline file: `cmplStd/test/lang/emit.ci`
cmplStd/test/test.ci:10: debug: inline file: `cmplStd/test/lang/inlineMacros.ci`
cmplStd/test/lang/inlineMacros.ci:6: warn: adding implicit cast bool(a: int32)
cmplStd/test/test.ci:11: debug: inline file: `cmplStd/test/lang/overload.inline.ci`
cmplStd/test/lang/overload.inline.ci:25: warn: adding implicit cast float64(32: int32)
cmplStd/test/lang/overload.inline.ci:26: warn: adding implicit cast float64(32: int32)
cmplStd/test/test.ci:14: debug: inline file: `cmplStd/test/lang/memory.ci`
cmplStd/test/test.ci:15: debug: inline file: `cmplStd/test/lang/tryExec.ci`
cmplStd/test/lang/tryExec.ci:17: warn: variable `abortExecution.NotEquals` hides previous declaration
cmplStd/lib/lang/Debug.ci:32: warn: previously defined here as `NotEquals`
cmplStd/test/lang/tryExec.ci:17: warn: padding `abortExecution.NotEquals` with 4 bytes: (12 -> 16)
cmplStd/test/lang/tryExec.ci:23: warn: adding implicit cast char[*]("assertion failed": .cstr)
cmplStd/test/test.ci:16: debug: inline file: `cmplStd/test/lang/pointer.ci`
cmplStd/test/lang/pointer.ci:9: warn: adding implicit cast int32[5](ptr: pointer)
cmplStd/test/test.ci:20: debug: inline file: `cmplStd/test/lang/init.reference.ci`
cmplStd/test/lang/init.reference.ci:3: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:21: debug: inline file: `cmplStd/test/lang/init.variable.ci`
cmplStd/test/lang/init.variable.ci:24: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:24: debug: using default field initializer: ComplexVal.im := 0
cmplStd/test/lang/init.variable.ci:11: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:33: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:33: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/lang/init.variable.ci:41: warn: adding implicit cast float64(8: int32)
cmplStd/test/lang/init.variable.ci:41: debug: using default field initializer: ComplexObj.im := 0
cmplStd/test/lang/init.variable.ci:15: warn: adding implicit cast float64(0: int32)
cmplStd/test/test.ci:24: debug: inline file: `cmplStd/test/lang/function.ci`
cmplStd/test/lang/function.ci:33: warn: Overwriting forward function: funMul(x: int32, y: int32): int32
cmplStd/test/lang/function.ci:39: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(1: int32)
cmplStd/test/lang/function.ci:42: warn: adding implicit cast uint32(2: int32)
cmplStd/test/test.ci:25: debug: inline file: `cmplStd/test/lang/reflect.ci`
cmplStd/test/test.ci:29: debug: inline file: `cmplStd/test/lang/init.member.ci`
cmplStd/test/lang/init.member.ci:81: warn: ignoring nested comment
cmplStd/test/lang/init.member.ci:43: debug: using default type initializer: RecordMemberTest.Inner.member := 0
warn: adding implicit cast int32(0: int64)
cmplStd/test/test.ci:30: debug: inline file: `cmplStd/test/lang/init.method.ci`
cmplStd/test/lang/init.method.ci:40: warn: Creating virtual method for: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:47: warn: Overwriting forward function: RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
cmplStd/test/lang/init.method.ci:4: warn: padding `RecordMethodTest` with 4 bytes: (12 -> 16)
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod
cmplStd/test/lang/init.method.ci:62: debug: using default field initializer: RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod
cmplStd/test/lang/init.method.ci:86: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/lang/init.method.ci:92: warn: adding implicit cast pointer(this: RecordMethodTest)
cmplStd/test/test.ci:33: debug: inline file: `cmplStd/test/lang/recUnion.ci`
cmplStd/test/lang/recUnion.ci:2: warn: padding `rgbF32` with 4 bytes: (12 -> 16)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:26: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:27: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:28: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:30: warn: adding implicit cast uint32(65535: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(0: int32)
cmplStd/test/lang/recUnion.ci:31: warn: adding implicit cast uint8(255: int32)
cmplStd/test/lang/recUnion.ci:31: warn: partial union initialization with `blue.rgb`
cmplStd/test/test.ci:34: debug: inline file: `cmplStd/test/lang/recPacking.ci`
cmplStd/test/lang/recPacking.ci:24: warn: padding `record_pack2.a` with 1 bytes: (1 -> 2)
cmplStd/test/lang/recPacking.ci:26: warn: padding `record_pack2.b` with 1 bytes: (11 -> 12)
cmplStd/test/lang/recPacking.ci:28: warn: padding `record_pack2.c` with 1 bytes: (17 -> 18)
cmplStd/test/lang/recPacking.ci:34: warn: padding `record_pack4.a` with 3 bytes: (1 -> 4)
cmplStd/test/lang/recPacking.ci:36: warn: padding `record_pack4.b` with 3 bytes: (13 -> 16)
cmplStd/test/lang/recPacking.ci:38: warn: padding `record_pack4.c` with 1 bytes: (21 -> 22)
cmplStd/test/lang/recPacking.ci:44: warn: padding `record_pack8.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:46: warn: padding `record_pack8.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:48: warn: padding `record_pack8.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:42: warn: padding `record_pack8` with 4 bytes: (28 -> 32)
cmplStd/test/lang/recPacking.ci:54: warn: padding `record_packDef.a` with 7 bytes: (1 -> 8)
cmplStd/test/lang/recPacking.ci:56: warn: padding `record_packDef.b` with 3 bytes: (17 -> 20)
cmplStd/test/lang/recPacking.ci:58: warn: padding `record_packDef.c` with 1 bytes: (25 -> 26)
cmplStd/test/lang/recPacking.ci:52: warn: padding `record_packDef` with 4 bytes: (28 -> 32)
cmplStd/test/test.ci:41: debug: inline file: `cmplStd/test/lang/useOperator.ci`
cmplStd/test/lang/useOperator.ci:43: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:44: warn: adding implicit cast int32(chrA: char)
cmplStd/test/lang/useOperator.ci:45: warn: adding implicit cast bool(chrB: char)
cmplStd/test/lang/useOperator.ci:66: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:67: warn: adding implicit cast int32(i8A: int8)
cmplStd/test/lang/useOperator.ci:68: warn: adding implicit cast bool(i8B: int8)
cmplStd/test/lang/useOperator.ci:89: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:90: warn: adding implicit cast int32(u8A: uint8)
cmplStd/test/lang/useOperator.ci:91: warn: adding implicit cast bool(u8B: uint8)
cmplStd/test/lang/useOperator.ci:112: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:113: warn: adding implicit cast int32(i16A: int16)
cmplStd/test/lang/useOperator.ci:114: warn: adding implicit cast bool(i16B: int16)
cmplStd/test/lang/useOperator.ci:135: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:136: warn: adding implicit cast int32(u16A: uint16)
cmplStd/test/lang/useOperator.ci:137: warn: adding implicit cast bool(u16B: uint16)
cmplStd/test/lang/useOperator.ci:160: warn: adding implicit cast bool(i32B: int32)
cmplStd/test/lang/useOperator.ci:183: warn: adding implicit cast bool(u32B: uint32)
cmplStd/test/lang/useOperator.ci:206: warn: adding implicit cast bool(i64B: int64)
cmplStd/test/lang/useOperator.ci:229: warn: adding implicit cast bool(u64B: uint64)
cmplStd/test/lang/useOperator.ci:252: warn: adding implicit cast bool(f32B: float32)
cmplStd/test/lang/useOperator.ci:275: warn: adding implicit cast bool(f64B: float64)
cmplStd/test/test.ci:45: debug: inline file: `cmplStd/test/lang/stmt.if.ci`
cmplStd/test/lang/stmt.if.ci:73: warn: adding implicit cast pointer(typename(int64): typename)
cmplStd/test/test.ci:46: debug: inline file: `cmplStd/test/lang/stmt.for.ci`
cmplStd/test/test.ci:50: debug: inline file: `cmplStd/test/math/test.Bits.ci`
cmplStd/test/math/test.Bits.ci:37: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Bits.ci:38: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Bits.ci:39: warn: adding implicit cast float64(4: int32)
cmplStd/test/math/test.Bits.ci:46: warn: adding implicit cast float32(2: int32)
cmplStd/test/math/test.Bits.ci:47: warn: adding implicit cast float32(2: int32)
cmplStd/test/math/test.Bits.ci:48: warn: adding implicit cast float32(4: int32)
cmplStd/test/test.ci:52: debug: inline file: `cmplStd/test/math/test.Math.ci`
cmplStd/test/math/test.Math.ci:83: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Math.ci:84: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Math.ci:85: warn: adding implicit cast float64(4: int32)
cmplStd/test/math/test.Math.ci:86: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Math.ci:87: warn: adding implicit cast float64(2: int32)
cmplStd/test/test.ci:53: debug: inline file: `cmplStd/test/math/test.Complex.ci`
cmplStd/test/math/test.Complex.ci:8: warn: adding implicit cast float64(9: int32)
cmplStd/test/math/test.Complex.ci:8: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Complex.ci:9: warn: adding implicit cast float64(2: int32)
cmplStd/test/math/test.Complex.ci:9: warn: adding implicit cast float64(3: int32)

---------- Generate: byte-code
cmplStd/lib/math/Math.ci:425: warn: using default type initializer: Math.log.exp := 0
cmplStd/lib/math/Math.ci:622: warn: using default type initializer: Math.pow.ye := 0
cmplStd/lib/math/Math.ci:657: warn: using default type initializer: Math.pow.ex := 0
cmplStd/lib/math/Math.ci:716: warn: using default type initializer: Math.sincos.y := 0
cmplStd/lib/math/Math.ci:719: warn: using default type initializer: e := 0
cmplStd/lib/math/Math.ci:723: warn: using default type initializer: f := 0
cmplStd/lib/math/Fixed.ci:55: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:57: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:94: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:94: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:94: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:99: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:99: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:206: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:211: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:223: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:227: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:233: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:237: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:241: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:297: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:303: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:318: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:330: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:330: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:342: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:342: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:355: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:357: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:378: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:386: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:394: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:399: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:409: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:411: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:437: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:437: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:437: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:440: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:440: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:440: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:486: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:486: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:496: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:503: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:564: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:610: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:610: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:610: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:715: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:720: warn: uninitialized variable `.result`
cmplStd/lib/math/Fixed.ci:733: warn: uninitialized variable `.result`
cmplStd/lib/math/Matrix4f.ci:98: warn: uninitialized variable `.result`
cmplStd/lib/time/Timestamp.ci:23: warn: uninitialized variable `.result`
cmplStd/lib/time/Timestamp.ci:110: warn: uninitialized variable `.result`
cmplStd/lib/time/Timezone.ci:7: warn: using default type initializer: Timezone.offset.isDaylightSaving := 0
cmplStd/lib/time/Timezone.ci:8: warn: uninitialized variable `.result`
cmplStd/lib/time/Timezone.ci:29: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/time/Datetime.ci:153: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:175: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/time/Datetime.ci:196: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:197: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:292: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:292: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:297: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:302: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:307: warn: uninitialized variable `.result`
cmplStd/lib/time/Datetime.ci:307: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/text/Format.ci:334: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:359: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:359: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:363: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:363: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:371: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, ' ')
cmplStd/lib/text/Format.ci:371: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:385: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:385: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:389: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:389: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:393: debug: adding temporary variable format := FormatFlags.defPad(flags, 3, '0')
cmplStd/lib/text/Format.ci:393: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:397: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, ' ')
cmplStd/lib/text/Format.ci:397: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:401: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, ' ')
cmplStd/lib/text/Format.ci:401: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:405: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:405: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:409: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:409: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:418: debug: adding temporary variable format := FormatFlags.defPad(flags, 9, '0')
cmplStd/lib/text/Format.ci:418: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:436: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:440: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:440: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:459: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:459: warn: uninitialized variable `.result`
cmplStd/lib/text/Format.ci:471: debug: adding temporary variable format := FormatFlags.defPad(flags, 2, '0')
cmplStd/lib/text/Format.ci:471: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:86: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:92: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:94: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:101: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:108: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:115: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:122: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:129: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:136: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:147: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:151: warn: uninitialized variable `.result`
cmplStd/lib/text/stream/TextStream.ci:151: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/math/Polynomial.ci:26: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:30: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:35: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:39: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:43: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:45: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:46: warn: uninitialized variable `.result`
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:27: warn: no code will be generated for statement: 0
cmplStd/lib/math/Polynomial.ci:106: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:115: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:124: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:135: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:155: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:164: warn: uninitialized variable `.result`
cmplStd/lib/math/Polynomial.ci:178: warn: uninitialized variable `.result`
cmplStd/test/lang/init.member.ci:34: warn: using default type initializer: RecordMemberTest.global := 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/lib/lang/Debug.ci:29: warn: no code will be generated for statement: 0
cmplStd/test/lang/init.variable.ci:3: warn: using default type initializer: variable := 0
cmplStd/test/lang/useOperator.ci:76: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/useOperator.ci:77: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/useOperator.ci:122: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/useOperator.ci:123: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/useOperator.ci:168: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/useOperator.ci:169: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/useOperator.ci:214: warn: using signed cast for unsigned value: `96.300000`
cmplStd/test/lang/useOperator.ci:215: warn: using signed cast for unsigned value: `42.140000`
cmplStd/test/lang/stmt.for.ci:12: warn: using default type initializer: forIdx := 0
cmplStd/test/math/test.Complex.ci:3: warn: uninitialized variable `.result`
cmplStd/test/math/test.Complex.ci:4: warn: uninitialized variable `.result`
cmplStd/test/math/test.Complex.ci:5: warn: uninitialized variable `.result`
cmplStd/test/math/test.Complex.ci:6: warn: uninitialized variable `.result`

---------- Symbols:
typename: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 160
.name: 'typename'
.print: '<%T>'
.field size: int32 (size: 4, cast: const variable)
.field offset: int32 (size: 4, cast: const variable)
.field base: function (size: 0, cast: static const inline)
.field file: function (size: 0, cast: static const inline)
.field line: function (size: 0, cast: static const inline)
.field name: function (size: 0, cast: static const inline)
.field size: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:77: referenced as `typename`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:48: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:44: referenced as `typename`
	cmplStd/test/lang/reflect.ci:42: referenced as `typename`
	cmplStd/test/lang/reflect.ci:41: referenced as `typename`
	cmplStd/test/lang/reflect.ci:38: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:37: referenced as `typename`
	cmplStd/test/lang/reflect.ci:35: referenced as `typename`
	cmplStd/test/lang/reflect.ci:34: referenced as `typename`
	cmplStd/test/lang/reflect.ci:31: referenced as `typename`
	cmplStd/test/lang/reflect.ci:30: referenced as `typename`
	cmplStd/test/lang/reflect.ci:18: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:99: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:97: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:92: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:91: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:90: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:89: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:88: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:87: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:86: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:85: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:84: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:83: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:82: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:81: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:80: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:79: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:78: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:77: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:76: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:75: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:68: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:48: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:32: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:25: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:19: referenced as `typename`
	cmplStd/test/lang/init.reference.ci:3: referenced as `typename`
	cmplStd/lib/text/cstr.ci:119: referenced as `typename`
	cmplStd/lib/math/Math.ci:1003: referenced as `typename`
	cmplStd/lib/math/Math.ci:986: referenced as `typename`
	cmplStd/lib/math/Math.ci:964: referenced as `typename`
	cmplStd/lib/math/Math.ci:944: referenced as `typename`
	cmplStd/lib/math/Math.ci:931: referenced as `typename`
	cmplStd/lib/math/Math.ci:911: referenced as `typename`
	cmplStd/lib/math/Math.ci:901: referenced as `typename`
	cmplStd/lib/math/Math.ci:890: referenced as `typename`
	cmplStd/lib/math/Math.ci:866: referenced as `typename`
	cmplStd/lib/math/Math.ci:688: referenced as `typename`
	cmplStd/lib/math/Math.ci:608: referenced as `typename`
	cmplStd/lib/math/Math.ci:597: referenced as `typename`
	cmplStd/lib/math/Math.ci:533: referenced as `typename`
	cmplStd/lib/math/Math.ci:522: referenced as `typename`
	cmplStd/lib/math/Math.ci:466: referenced as `typename`
	cmplStd/lib/math/Math.ci:445: referenced as `typename`
	cmplStd/lib/math/Math.ci:398: referenced as `typename`
	cmplStd/lib/math/Bits.ci:490: referenced as `typename`
	cmplStd/lib/math/Bits.ci:472: referenced as `typename`
	cmplStd/lib/math/Bits.ci:453: referenced as `typename`
	cmplStd/lib/math/Bits.ci:434: referenced as `typename`
	cmplStd/lib/math/Bits.ci:390: referenced as `typename`
	cmplStd/lib/math/Bits.ci:371: referenced as `typename`
	cmplStd/lib/math/Bits.ci:281: referenced as `typename`
	cmplStd/lib/math/Bits.ci:240: referenced as `typename`
	cmplStd/lib/math/Bits.ci:151: referenced as `typename`
	cmplStd/lib/math/Bits.ci:111: referenced as `typename`
	cmplStd/lib/math/Bits.ci:71: referenced as `typename`
	cmplStd/lib/math/Bits.ci:61: referenced as `typename`
	cmplStd/lib/math/Bits.ci:51: referenced as `typename`
	cmplStd/lib/math/Bits.ci:41: referenced as `typename`
	cmplStd/lib.ci:16: referenced as `typename`
	cmplStd/lib.ci:14: referenced as `typename`
	cmplStd/lib.ci:14: referenced as `typename`
	internal usages: 12
}
typename.size: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'size'
.owner: typename
.doc: '@builtin'
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `size`
	cmplStd/test/lang/reflect.ci:46: referenced as `size`
	cmplStd/test/lang/reflect.ci:40: referenced as `size`
	cmplStd/test/lang/reflect.ci:33: referenced as `size`
}
typename.offset: int32 {
.kind: const variable
.base: `int32`
.size: 4
.name: 'offset'
.print: '@%06x'
.owner: typename
.doc: '@builtin'
.usages:
	cmplStd/test/lang/reflect.ci:49: referenced as `offset`
	cmplStd/test/lang/reflect.ci:45: referenced as `offset`
	cmplStd/test/lang/reflect.ci:39: referenced as `offset`
	cmplStd/test/lang/reflect.ci:32: referenced as `offset`
}
typename.base(type: typename): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'base'
.owner: typename
.param .result: typename (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(2)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `base`
	cmplStd/test/lang/reflect.ci:44: referenced as `base`
	cmplStd/test/lang/reflect.ci:37: referenced as `base`
}
typename.file(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'file'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(3)
.usages:
	cmplStd/test/lang/reflect.ci:41: referenced as `file`
	cmplStd/test/lang/reflect.ci:34: referenced as `file`
}
typename.line(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'line'
.owner: typename
.param .result: int32 (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(4)
.usages:
	cmplStd/test/lang/reflect.ci:42: referenced as `line`
	cmplStd/test/lang/reflect.ci:35: referenced as `line`
}
typename.name(type: typename): .cstr: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'name'
.owner: typename
.param .result: .cstr (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(5)
.usages:
	cmplStd/test/lang/reflect.ci:38: referenced as `name`
	cmplStd/test/lang/reflect.ci:31: referenced as `name`
}
typename.size(type: typename): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'size'
.owner: typename
.param .result: int32 (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(6)
.usages:
	cmplStd/lib.ci:14: referenced as `size`
}
void: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'void'
.doc: '@builtin'
.usages:
	cmplStd/test/lang/init.method.ci:90: referenced as `void`
	cmplStd/test/lang/init.method.ci:84: referenced as `void`
	cmplStd/test/lang/init.method.ci:57: referenced as `void`
	cmplStd/test/lang/init.method.ci:47: referenced as `void`
	cmplStd/test/lang/init.method.ci:40: referenced as `void`
	cmplStd/test/lang/init.method.ci:32: referenced as `void`
	cmplStd/test/lang/init.method.ci:25: referenced as `void`
	cmplStd/test/lang/init.method.ci:18: referenced as `void`
	cmplStd/test/lang/init.method.ci:10: referenced as `void`
	cmplStd/test/lang/reflect.ci:3: referenced as `void`
	cmplStd/test/lang/function.ci:4: referenced as `void`
	cmplStd/test/lang/init.reference.ci:75: referenced as `void`
	cmplStd/test/lang/init.reference.ci:55: referenced as `void`
	cmplStd/test/lang/init.reference.ci:35: referenced as `void`
	cmplStd/test/lang/tryExec.ci:35: referenced as `void`
	cmplStd/test/lang/tryExec.ci:30: referenced as `void`
	cmplStd/test/lang/tryExec.ci:16: referenced as `void`
	cmplStd/test/lang/tryExec.ci:12: referenced as `void`
	cmplStd/test/lang/tryExec.ci:6: referenced as `void`
	cmplStd/test/lang/tryExec.ci:3: referenced as `void`
	cmplStd/lib/math/Polynomial.ci:54: referenced as `void`
	cmplStd/lib/math/Polynomial.ci:14: referenced as `void`
	cmplStd/lib/text/encoding/Utf8.ci:53: referenced as `void`
	cmplStd/lib/text/encoding/Ascii.ci:21: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:190: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:129: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:124: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:41: referenced as `void`
	cmplStd/lib/text/encoding/binary/Base64.ci:16: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:72: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:67: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:64: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:52: referenced as `void`
	cmplStd/lib/text/stream/TextStream.ci:19: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:179: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:175: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:149: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:113: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:56: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:53: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:48: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:7: referenced as `void`
	cmplStd/lib/text/stream/ByteStream.ci:5: referenced as `void`
	cmplStd/lib/lang/Debug.ci:59: referenced as `void`
	cmplStd/lib/lang/Debug.ci:55: referenced as `void`
	cmplStd/lib/lang/Debug.ci:55: referenced as `void`
	cmplStd/lib/lang/Debug.ci:29: referenced as `void`
	cmplStd/lib/lang/Debug.ci:29: referenced as `void`
	cmplStd/lib/lang/Debug.ci:27: referenced as `void`
	cmplStd/lib/lang/Debug.ci:27: referenced as `void`
	internal usages: 7
}
bool: typename {
.kind: static const typename(bool)
.base: `typename`
.size: 1
.name: 'bool'
.print: '%d'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:299: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:281: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:280: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:279: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:278: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:277: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:276: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:275: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:258: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:257: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:256: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:255: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:254: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:253: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:252: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:235: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:234: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:233: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:232: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:231: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:230: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:229: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:212: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:211: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:210: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:209: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:208: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:207: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:206: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:189: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:188: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:187: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:186: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:185: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:184: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:183: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:166: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:165: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:164: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:163: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:162: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:161: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:160: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:143: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:142: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:141: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:140: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:139: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:138: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:137: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:120: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:119: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:118: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:117: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:116: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:115: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:114: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:97: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:96: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:95: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:94: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:93: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:92: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:91: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:74: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:73: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:72: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:71: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:70: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:69: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:68: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:51: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:50: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:49: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:48: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:47: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:46: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:45: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:28: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:27: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:26: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:25: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:24: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:23: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:22: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:19: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:18: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:17: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:8: referenced as `bool`
	cmplStd/test/lang/useOperator.ci:7: referenced as `bool`
	cmplStd/test/lang/reflect.ci:4: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:76: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:56: referenced as `bool`
	cmplStd/test/lang/init.reference.ci:36: referenced as `bool`
	cmplStd/lib/math/Polynomial.ci:15: referenced as `bool`
	cmplStd/lib/text/stream/TextStream.ci:90: referenced as `bool`
	cmplStd/lib/text/Format.ci:16: referenced as `bool`
	cmplStd/lib/text/cstr.ci:46: referenced as `bool`
	cmplStd/lib/text/cstr.ci:36: referenced as `bool`
	cmplStd/lib/time/Datetime.ci:102: referenced as `bool`
	cmplStd/lib/time/Datetime.ci:95: referenced as `bool`
	cmplStd/lib/time/Timezone.ci:27: referenced as `bool`
	cmplStd/lib/time/Timezone.ci:12: referenced as `bool`
	cmplStd/lib/time/Timezone.ci:7: referenced as `bool`
	cmplStd/lib/time/Timezone.ci:4: referenced as `bool`
	cmplStd/lib/time/Timestamp.ci:37: referenced as `bool`
	cmplStd/lib/time/Timestamp.ci:32: referenced as `bool`
	cmplStd/lib/math/Fixed.ci:116: referenced as `bool`
	cmplStd/lib/math/Fixed.ci:103: referenced as `bool`
	cmplStd/lib/math/Math.ci:40: referenced as `bool`
	cmplStd/lib/math/Math.ci:34: referenced as `bool`
	cmplStd/lib/math/Math.ci:29: referenced as `bool`
	cmplStd/lib/math/Math.ci:23: referenced as `bool`
	cmplStd/lib/lang/Debug.ci:55: referenced as `bool`
	cmplStd/lib/lang/Debug.ci:29: referenced as `bool`
	cmplStd/lib/lang/Debug.ci:27: referenced as `bool`
	cmplStd/lib.ci:4: referenced as `bool`
}
char: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'char'
.print: '%c'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:44: referenced as `char`
	cmplStd/test/lang/useOperator.ci:43: referenced as `char`
	cmplStd/test/lang/useOperator.ci:42: referenced as `char`
	cmplStd/test/lang/useOperator.ci:41: referenced as `char`
	cmplStd/test/lang/useOperator.ci:40: referenced as `char`
	cmplStd/test/lang/useOperator.ci:39: referenced as `char`
	cmplStd/test/lang/useOperator.ci:38: referenced as `char`
	cmplStd/test/lang/useOperator.ci:37: referenced as `char`
	cmplStd/test/lang/useOperator.ci:36: referenced as `char`
	cmplStd/test/lang/useOperator.ci:35: referenced as `char`
	cmplStd/test/lang/useOperator.ci:34: referenced as `char`
	cmplStd/test/lang/useOperator.ci:33: referenced as `char`
	cmplStd/test/lang/useOperator.ci:32: referenced as `char`
	cmplStd/test/lang/useOperator.ci:31: referenced as `char`
	cmplStd/test/lang/useOperator.ci:30: referenced as `char`
	cmplStd/test/lang/reflect.ci:41: referenced as `char`
	cmplStd/test/lang/reflect.ci:38: referenced as `char`
	cmplStd/test/lang/reflect.ci:34: referenced as `char`
	cmplStd/test/lang/reflect.ci:31: referenced as `char`
	cmplStd/test/lang/reflect.ci:5: referenced as `char`
	cmplStd/test/lang/init.reference.ci:77: referenced as `char`
	cmplStd/test/lang/init.reference.ci:57: referenced as `char`
	cmplStd/test/lang/init.reference.ci:37: referenced as `char`
	cmplStd/test/lang/tryExec.ci:18: referenced as `char`
	cmplStd/test/lang/emit.ci:30: referenced as `char`
	cmplStd/lib/text/encoding/binary/Base64.ci:163: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:134: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:127: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:120: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:113: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:106: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:99: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:85: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:84: referenced as `char`
	cmplStd/lib/text/stream/TextStream.ci:78: referenced as `char`
	cmplStd/lib/text/Format.ci:563: referenced as `char`
	cmplStd/lib/text/Format.ci:545: referenced as `char`
	cmplStd/lib/text/Format.ci:541: referenced as `char`
	cmplStd/lib/text/Format.ci:536: referenced as `char`
	cmplStd/lib/text/Format.ci:527: referenced as `char`
	cmplStd/lib/text/Format.ci:522: referenced as `char`
	cmplStd/lib/text/Format.ci:508: referenced as `char`
	cmplStd/lib/text/Format.ci:507: referenced as `char`
	cmplStd/lib/text/Format.ci:507: referenced as `char`
	cmplStd/lib/text/Format.ci:501: referenced as `char`
	cmplStd/lib/text/Format.ci:501: referenced as `char`
	cmplStd/lib/text/Format.ci:320: referenced as `char`
	cmplStd/lib/text/Format.ci:313: referenced as `char`
	cmplStd/lib/text/Format.ci:313: referenced as `char`
	cmplStd/lib/text/Format.ci:311: referenced as `char`
	cmplStd/lib/text/Format.ci:310: referenced as `char`
	cmplStd/lib/text/Format.ci:309: referenced as `char`
	cmplStd/lib/text/Format.ci:308: referenced as `char`
	cmplStd/lib/text/Format.ci:307: referenced as `char`
	cmplStd/lib/text/Format.ci:306: referenced as `char`
	cmplStd/lib/text/Format.ci:305: referenced as `char`
	cmplStd/lib/text/Format.ci:304: referenced as `char`
	cmplStd/lib/text/Format.ci:303: referenced as `char`
	cmplStd/lib/text/Format.ci:302: referenced as `char`
	cmplStd/lib/text/Format.ci:279: referenced as `char`
	cmplStd/lib/text/Format.ci:276: referenced as `char`
	cmplStd/lib/text/Format.ci:273: referenced as `char`
	cmplStd/lib/text/Format.ci:270: referenced as `char`
	cmplStd/lib/text/Format.ci:267: referenced as `char`
	cmplStd/lib/text/Format.ci:264: referenced as `char`
	cmplStd/lib/text/Format.ci:261: referenced as `char`
	cmplStd/lib/text/Format.ci:258: referenced as `char`
	cmplStd/lib/text/Format.ci:255: referenced as `char`
	cmplStd/lib/text/Format.ci:184: referenced as `char`
	cmplStd/lib/text/Format.ci:170: referenced as `char`
	cmplStd/lib/text/Format.ci:127: referenced as `char`
	cmplStd/lib/text/Format.ci:112: referenced as `char`
	cmplStd/lib/text/Format.ci:109: referenced as `char`
	cmplStd/lib/text/Format.ci:108: referenced as `char`
	cmplStd/lib/text/Format.ci:107: referenced as `char`
	cmplStd/lib/text/Format.ci:87: referenced as `char`
	cmplStd/lib/text/Format.ci:87: referenced as `char`
	cmplStd/lib/text/Format.ci:73: referenced as `char`
	cmplStd/lib/text/Format.ci:19: referenced as `char`
	cmplStd/lib/text/Format.ci:7: referenced as `char`
	cmplStd/lib/text/Format.ci:4: referenced as `char`
	cmplStd/lib/text/cstr.ci:133: referenced as `char`
	cmplStd/lib/text/cstr.ci:117: referenced as `char`
	cmplStd/lib/text/cstr.ci:105: referenced as `char`
	cmplStd/lib/text/cstr.ci:105: referenced as `char`
	cmplStd/lib/text/cstr.ci:102: referenced as `char`
	cmplStd/lib/text/cstr.ci:102: referenced as `char`
	cmplStd/lib/text/cstr.ci:100: referenced as `char`
	cmplStd/lib/text/cstr.ci:100: referenced as `char`
	cmplStd/lib/text/cstr.ci:98: referenced as `char`
	cmplStd/lib/text/cstr.ci:98: referenced as `char`
	cmplStd/lib/text/cstr.ci:96: referenced as `char`
	cmplStd/lib/text/cstr.ci:96: referenced as `char`
	cmplStd/lib/text/cstr.ci:88: referenced as `char`
	cmplStd/lib/text/cstr.ci:88: referenced as `char`
	cmplStd/lib/text/cstr.ci:74: referenced as `char`
	cmplStd/lib/text/cstr.ci:74: referenced as `char`
	cmplStd/lib/text/cstr.ci:73: referenced as `char`
	cmplStd/lib/text/cstr.ci:73: referenced as `char`
	cmplStd/lib/text/cstr.ci:61: referenced as `char`
	cmplStd/lib/text/cstr.ci:61: referenced as `char`
	cmplStd/lib/text/cstr.ci:61: referenced as `char`
	cmplStd/lib/text/cstr.ci:61: referenced as `char`
	cmplStd/lib/text/cstr.ci:46: referenced as `char`
	cmplStd/lib/text/cstr.ci:46: referenced as `char`
	cmplStd/lib/text/cstr.ci:46: referenced as `char`
	cmplStd/lib/text/cstr.ci:46: referenced as `char`
	cmplStd/lib/text/cstr.ci:36: referenced as `char`
	cmplStd/lib/text/cstr.ci:36: referenced as `char`
	cmplStd/lib/text/cstr.ci:36: referenced as `char`
	cmplStd/lib/text/cstr.ci:36: referenced as `char`
	cmplStd/lib/text/cstr.ci:25: referenced as `char`
	cmplStd/lib/text/cstr.ci:25: referenced as `char`
	cmplStd/lib/text/cstr.ci:15: referenced as `char`
	cmplStd/lib/text/cstr.ci:15: referenced as `char`
	cmplStd/lib/text/cstr.ci:4: referenced as `char`
	cmplStd/lib/time/Timezone.ci:22: referenced as `char`
	cmplStd/lib/time/Timezone.ci:3: referenced as `char`
	cmplStd/lib/lang/Debug.ci:59: referenced as `char`
	cmplStd/lib/lang/Debug.ci:55: referenced as `char`
	cmplStd/lib/lang/Debug.ci:53: referenced as `char`
	cmplStd/lib/lang/Debug.ci:27: referenced as `char`
	cmplStd/lib/lang/Debug.ci:22: referenced as `char`
	cmplStd/lib/lang/Debug.ci:19: referenced as `char`
	cmplStd/lib/lang/Debug.ci:16: referenced as `char`
	cmplStd/lib/lang/Debug.ci:13: referenced as `char`
	cmplStd/lib/lang/Debug.ci:10: referenced as `char`
	cmplStd/lib/lang/Debug.ci:7: referenced as `char`
	cmplStd/lib/lang/Debug.ci:4: referenced as `char`
	internal usages: 4
}
int8: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 1
.name: 'int8'
.print: '%d'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:67: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:66: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:65: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:64: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:63: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:62: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:61: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:60: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:59: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:58: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:57: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:56: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:55: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:54: referenced as `int8`
	cmplStd/test/lang/useOperator.ci:53: referenced as `int8`
	cmplStd/test/lang/reflect.ci:6: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:78: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:58: referenced as `int8`
	cmplStd/test/lang/init.reference.ci:38: referenced as `int8`
	cmplStd/lib/text/Format.ci:276: referenced as `int8`
	cmplStd/lib/math/Bits.ci:524: referenced as `int8`
	cmplStd/lib/math/Bits.ci:429: referenced as `int8`
	cmplStd/lib/math/Bits.ci:366: referenced as `int8`
	cmplStd/lib/math/Bits.ci:235: referenced as `int8`
	cmplStd/lib/math/Bits.ci:16: referenced as `int8`
	cmplStd/lib/math/Bits.ci:4: referenced as `int8`
}
int16: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 2
.name: 'int16'
.print: '%d'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:113: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:112: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:111: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:110: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:109: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:108: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:107: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:106: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:105: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:104: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:103: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:102: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:101: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:100: referenced as `int16`
	cmplStd/test/lang/useOperator.ci:99: referenced as `int16`
	cmplStd/test/lang/reflect.ci:7: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:79: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:59: referenced as `int16`
	cmplStd/test/lang/init.reference.ci:39: referenced as `int16`
	cmplStd/lib/text/Format.ci:273: referenced as `int16`
	cmplStd/lib/math/Bits.ci:514: referenced as `int16`
	cmplStd/lib/math/Bits.ci:423: referenced as `int16`
	cmplStd/lib/math/Bits.ci:342: referenced as `int16`
	cmplStd/lib/math/Bits.ci:211: referenced as `int16`
	cmplStd/lib/math/Bits.ci:106: referenced as `int16`
	cmplStd/lib/math/Bits.ci:106: referenced as `int16`
	cmplStd/lib/math/Bits.ci:19: referenced as `int16`
	cmplStd/lib/math/Bits.ci:7: referenced as `int16`
}
int32: typename {
.kind: static const typename(i32)
.base: `typename`
.size: 4
.name: 'int32'
.print: '%d'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/math/test.Bits.ci:66: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:65: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:63: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:62: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:60: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:59: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:58: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:57: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:55: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:35: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:34: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:33: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:31: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:30: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:29: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:27: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:26: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:25: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:23: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:22: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:21: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:19: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:18: referenced as `int32`
	cmplStd/test/math/test.Bits.ci:16: referenced as `int`
	cmplStd/test/math/test.Bits.ci:15: referenced as `int`
	cmplStd/test/math/test.Bits.ci:14: referenced as `int`
	cmplStd/test/math/test.Bits.ci:12: referenced as `int`
	cmplStd/test/math/test.Bits.ci:12: referenced as `int`
	cmplStd/test/math/test.Bits.ci:12: referenced as `int`
	cmplStd/test/math/test.Bits.ci:10: referenced as `int`
	cmplStd/test/math/test.Bits.ci:10: referenced as `int`
	cmplStd/test/math/test.Bits.ci:10: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:24: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:17: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:12: referenced as `int`
	cmplStd/test/lang/stmt.for.ci:8: referenced as `int`
	cmplStd/test/lang/stmt.if.ci:26: referenced as `int`
	cmplStd/test/lang/useOperator.ci:159: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:158: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:157: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:156: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:155: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:154: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:153: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:152: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:151: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:150: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:149: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:148: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:147: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:146: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:145: referenced as `int32`
	cmplStd/test/lang/useOperator.ci:5: referenced as `int32`
	cmplStd/test/lang/init.method.ci:90: referenced as `int`
	cmplStd/test/lang/init.method.ci:84: referenced as `int`
	cmplStd/test/lang/init.method.ci:57: referenced as `int`
	cmplStd/test/lang/init.method.ci:47: referenced as `int`
	cmplStd/test/lang/init.method.ci:40: referenced as `int`
	cmplStd/test/lang/init.method.ci:32: referenced as `int`
	cmplStd/test/lang/init.method.ci:25: referenced as `int`
	cmplStd/test/lang/init.method.ci:18: referenced as `int`
	cmplStd/test/lang/init.method.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:40: referenced as `int`
	cmplStd/test/lang/init.member.ci:37: referenced as `int`
	cmplStd/test/lang/init.member.ci:34: referenced as `int`
	cmplStd/test/lang/init.member.ci:19: referenced as `int`
	cmplStd/test/lang/init.member.ci:16: referenced as `int`
	cmplStd/test/lang/init.member.ci:13: referenced as `int`
	cmplStd/test/lang/init.member.ci:10: referenced as `int`
	cmplStd/test/lang/init.member.ci:6: referenced as `int`
	cmplStd/test/lang/init.member.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:50: referenced as `int`
	cmplStd/test/lang/reflect.ci:49: referenced as `int`
	cmplStd/test/lang/reflect.ci:46: referenced as `int`
	cmplStd/test/lang/reflect.ci:45: referenced as `int`
	cmplStd/test/lang/reflect.ci:42: referenced as `int`
	cmplStd/test/lang/reflect.ci:40: referenced as `int`
	cmplStd/test/lang/reflect.ci:39: referenced as `int`
	cmplStd/test/lang/reflect.ci:35: referenced as `int`
	cmplStd/test/lang/reflect.ci:33: referenced as `int`
	cmplStd/test/lang/reflect.ci:32: referenced as `int`
	cmplStd/test/lang/reflect.ci:27: referenced as `int32`
	cmplStd/test/lang/reflect.ci:20: referenced as `int`
	cmplStd/test/lang/reflect.ci:19: referenced as `int`
	cmplStd/test/lang/reflect.ci:18: referenced as `int`
	cmplStd/test/lang/reflect.ci:17: referenced as `int`
	cmplStd/test/lang/reflect.ci:16: referenced as `int`
	cmplStd/test/lang/reflect.ci:15: referenced as `int`
	cmplStd/test/lang/reflect.ci:14: referenced as `int`
	cmplStd/test/lang/reflect.ci:13: referenced as `int`
	cmplStd/test/lang/reflect.ci:12: referenced as `int`
	cmplStd/test/lang/reflect.ci:11: referenced as `int`
	cmplStd/test/lang/reflect.ci:10: referenced as `int`
	cmplStd/test/lang/reflect.ci:9: referenced as `int`
	cmplStd/test/lang/reflect.ci:8: referenced as `int32`
	cmplStd/test/lang/reflect.ci:8: referenced as `int`
	cmplStd/test/lang/reflect.ci:7: referenced as `int`
	cmplStd/test/lang/reflect.ci:6: referenced as `int`
	cmplStd/test/lang/reflect.ci:5: referenced as `int`
	cmplStd/test/lang/reflect.ci:4: referenced as `int`
	cmplStd/test/lang/reflect.ci:3: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:33: referenced as `int`
	cmplStd/test/lang/function.ci:30: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:27: referenced as `int`
	cmplStd/test/lang/function.ci:24: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:21: referenced as `int`
	cmplStd/test/lang/function.ci:18: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:15: referenced as `int`
	cmplStd/test/lang/function.ci:12: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/function.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:7: referenced as `int`
	cmplStd/test/lang/init.variable.ci:3: referenced as `int`
	cmplStd/test/lang/init.reference.ci:80: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:60: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:40: referenced as `int32`
	cmplStd/test/lang/init.reference.ci:4: referenced as `int32`
	cmplStd/test/lang/pointer.ci:14: referenced as `int32`
	cmplStd/test/lang/pointer.ci:13: referenced as `int32`
	cmplStd/test/lang/pointer.ci:12: referenced as `int32`
	cmplStd/test/lang/pointer.ci:11: referenced as `int32`
	cmplStd/test/lang/pointer.ci:10: referenced as `int32`
	cmplStd/test/lang/pointer.ci:7: referenced as `int32`
	cmplStd/test/lang/pointer.ci:6: referenced as `int32`
	cmplStd/test/lang/pointer.ci:5: referenced as `int32`
	cmplStd/test/lang/pointer.ci:4: referenced as `int32`
	cmplStd/test/lang/pointer.ci:3: referenced as `int32`
	cmplStd/test/lang/pointer.ci:1: referenced as `int32`
	cmplStd/test/lang/tryExec.ci:45: referenced as `int`
	cmplStd/test/lang/tryExec.ci:44: referenced as `int`
	cmplStd/test/lang/tryExec.ci:43: referenced as `int`
	cmplStd/test/lang/tryExec.ci:42: referenced as `int`
	cmplStd/test/lang/tryExec.ci:41: referenced as `int`
	cmplStd/test/lang/tryExec.ci:40: referenced as `int`
	cmplStd/test/lang/tryExec.ci:39: referenced as `int`
	cmplStd/test/lang/tryExec.ci:32: referenced as `int`
	cmplStd/test/lang/tryExec.ci:31: referenced as `int32`
	cmplStd/test/lang/tryExec.ci:20: referenced as `int`
	cmplStd/test/lang/tryExec.ci:19: referenced as `int`
	cmplStd/test/lang/tryExec.ci:13: referenced as `int`
	cmplStd/test/lang/memory.ci:4: referenced as `int`
	cmplStd/test/lang/memory.ci:3: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:7: referenced as `int`
	cmplStd/test/lang/overload.inline.ci:5: referenced as `int32`
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:13: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:12: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:11: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:10: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:8: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:7: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:6: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:5: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:4: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/inlineMacros.ci:3: referenced as `int`
	cmplStd/test/lang/emit.ci:30: referenced as `int`
	cmplStd/test/lang/emit.ci:25: referenced as `int32`
	cmplStd/test/lang/emit.ci:23: referenced as `int32`
	cmplStd/test/lang/emit.ci:19: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:13: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:10: referenced as `int32`
	cmplStd/test/lang/emit.ci:7: referenced as `int32`
	cmplStd/test/lang/emit.ci:6: referenced as `int32`
	cmplStd/test/lang/emit.ci:3: referenced as `int32`
	cmplStd/lib/math/Polynomial.ci:179: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:166: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:156: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:147: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:137: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:136: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:134: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:133: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:125: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:116: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:107: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:98: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:89: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:80: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:79: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:72: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:69: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:60: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:59: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:16: referenced as `int`
	cmplStd/lib/math/Polynomial.ci:6: referenced as `int`
	cmplStd/lib/text/encoding/Utf8.ci:55: referenced as `int`
	cmplStd/lib/text/encoding/Utf8.ci:8: referenced as `int`
	cmplStd/lib/text/encoding/Utf8.ci:4: referenced as `int`
	cmplStd/lib/text/encoding/Ascii.ci:23: referenced as `int`
	cmplStd/lib/text/encoding/Ascii.ci:6: referenced as `int`
	cmplStd/lib/text/encoding/Ascii.ci:4: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:169: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:162: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:160: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:159: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:136: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:113: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:103: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:97: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:86: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:80: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:71: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:62: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:54: referenced as `int32`
	cmplStd/lib/text/encoding/binary/Base64.ci:47: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:46: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:32: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:20: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:18: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:14: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:13: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:10: referenced as `int`
	cmplStd/lib/text/encoding/binary/Base64.ci:9: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:172: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:170: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:168: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:135: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:128: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:121: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:114: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:107: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:100: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:98: referenced as `int32`
	cmplStd/lib/text/stream/TextStream.ci:25: referenced as `int`
	cmplStd/lib/text/stream/TextStream.ci:16: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:169: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:161: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:150: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:144: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:140: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:130: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:126: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:123: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:122: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:121: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:105: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:104: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:80: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:78: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:76: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:26: referenced as `int`
	cmplStd/lib/text/stream/ByteStream.ci:23: referenced as `int`
	cmplStd/lib/text/Format.ci:563: referenced as `int`
	cmplStd/lib/text/Format.ci:563: referenced as `int`
	cmplStd/lib/text/Format.ci:563: referenced as `int`
	cmplStd/lib/text/Format.ci:507: referenced as `int`
	cmplStd/lib/text/Format.ci:501: referenced as `int`
	cmplStd/lib/text/Format.ci:426: referenced as `int`
	cmplStd/lib/text/Format.ci:422: referenced as `int`
	cmplStd/lib/text/Format.ci:321: referenced as `int`
	cmplStd/lib/text/Format.ci:314: referenced as `int`
	cmplStd/lib/text/Format.ci:313: referenced as `int`
	cmplStd/lib/text/Format.ci:313: referenced as `int`
	cmplStd/lib/text/Format.ci:279: referenced as `int`
	cmplStd/lib/text/Format.ci:276: referenced as `int`
	cmplStd/lib/text/Format.ci:273: referenced as `int`
	cmplStd/lib/text/Format.ci:270: referenced as `int32`
	cmplStd/lib/text/Format.ci:270: referenced as `int`
	cmplStd/lib/text/Format.ci:267: referenced as `int`
	cmplStd/lib/text/Format.ci:264: referenced as `int`
	cmplStd/lib/text/Format.ci:261: referenced as `int`
	cmplStd/lib/text/Format.ci:258: referenced as `int`
	cmplStd/lib/text/Format.ci:255: referenced as `int`
	cmplStd/lib/text/Format.ci:239: referenced as `int`
	cmplStd/lib/text/Format.ci:226: referenced as `int`
	cmplStd/lib/text/Format.ci:203: referenced as `int`
	cmplStd/lib/text/Format.ci:196: referenced as `int`
	cmplStd/lib/text/Format.ci:191: referenced as `int`
	cmplStd/lib/text/Format.ci:184: referenced as `int`
	cmplStd/lib/text/Format.ci:184: referenced as `int`
	cmplStd/lib/text/Format.ci:170: referenced as `int`
	cmplStd/lib/text/Format.ci:170: referenced as `int`
	cmplStd/lib/text/Format.ci:170: referenced as `int`
	cmplStd/lib/text/Format.ci:156: referenced as `int`
	cmplStd/lib/text/Format.ci:125: referenced as `int`
	cmplStd/lib/text/Format.ci:111: referenced as `int`
	cmplStd/lib/text/Format.ci:107: referenced as `int`
	cmplStd/lib/text/Format.ci:107: referenced as `int`
	cmplStd/lib/text/Format.ci:107: referenced as `int`
	cmplStd/lib/text/Format.ci:91: referenced as `int`
	cmplStd/lib/text/Format.ci:87: referenced as `int`
	cmplStd/lib/text/Format.ci:87: referenced as `int`
	cmplStd/lib/text/Format.ci:73: referenced as `int`
	cmplStd/lib/text/Format.ci:53: referenced as `int`
	cmplStd/lib/text/Format.ci:46: referenced as `int`
	cmplStd/lib/text/Format.ci:39: referenced as `int`
	cmplStd/lib/text/Format.ci:32: referenced as `int`
	cmplStd/lib/text/Format.ci:20: referenced as `int`
	cmplStd/lib/text/Format.ci:19: referenced as `int`
	cmplStd/lib/text/Format.ci:13: referenced as `int`
	cmplStd/lib/text/Format.ci:10: referenced as `int`
	cmplStd/lib/text/cstr.ci:132: referenced as `int`
	cmplStd/lib/text/cstr.ci:121: referenced as `int`
	cmplStd/lib/text/cstr.ci:93: referenced as `int`
	cmplStd/lib/text/cstr.ci:93: referenced as `int`
	cmplStd/lib/text/cstr.ci:88: referenced as `int`
	cmplStd/lib/text/cstr.ci:73: referenced as `int`
	cmplStd/lib/text/cstr.ci:63: referenced as `int`
	cmplStd/lib/text/cstr.ci:62: referenced as `int`
	cmplStd/lib/text/cstr.ci:61: referenced as `int`
	cmplStd/lib/text/cstr.ci:61: referenced as `int`
	cmplStd/lib/text/cstr.ci:52: referenced as `int`
	cmplStd/lib/text/cstr.ci:48: referenced as `int`
	cmplStd/lib/text/cstr.ci:47: referenced as `int`
	cmplStd/lib/text/cstr.ci:46: referenced as `int`
	cmplStd/lib/text/cstr.ci:37: referenced as `int`
	cmplStd/lib/text/cstr.ci:36: referenced as `int`
	cmplStd/lib/text/cstr.ci:27: referenced as `int`
	cmplStd/lib/text/cstr.ci:26: referenced as `int`
	cmplStd/lib/text/cstr.ci:25: referenced as `int`
	cmplStd/lib/text/cstr.ci:16: referenced as `int`
	cmplStd/lib/text/cstr.ci:15: referenced as `int`
	cmplStd/lib/text/cstr.ci:8: referenced as `int`
	cmplStd/lib/text/cstr.ci:4: referenced as `int`
	cmplStd/lib/time/Datetime.ci:306: referenced as `int`
	cmplStd/lib/time/Datetime.ci:306: referenced as `int`
	cmplStd/lib/time/Datetime.ci:306: referenced as `int`
	cmplStd/lib/time/Datetime.ci:301: referenced as `int`
	cmplStd/lib/time/Datetime.ci:301: referenced as `int`
	cmplStd/lib/time/Datetime.ci:301: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:296: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:291: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:273: referenced as `int`
	cmplStd/lib/time/Datetime.ci:239: referenced as `int`
	cmplStd/lib/time/Datetime.ci:238: referenced as `int`
	cmplStd/lib/time/Datetime.ci:231: referenced as `int`
	cmplStd/lib/time/Datetime.ci:224: referenced as `int`
	cmplStd/lib/time/Datetime.ci:219: referenced as `int`
	cmplStd/lib/time/Datetime.ci:209: referenced as `int`
	cmplStd/lib/time/Datetime.ci:204: referenced as `int`
	cmplStd/lib/time/Datetime.ci:201: referenced as `int`
	cmplStd/lib/time/Datetime.ci:198: referenced as `int`
	cmplStd/lib/time/Datetime.ci:181: referenced as `int`
	cmplStd/lib/time/Datetime.ci:172: referenced as `int`
	cmplStd/lib/time/Datetime.ci:166: referenced as `int`
	cmplStd/lib/time/Datetime.ci:165: referenced as `int`
	cmplStd/lib/time/Datetime.ci:164: referenced as `int`
	cmplStd/lib/time/Datetime.ci:162: referenced as `int`
	cmplStd/lib/time/Datetime.ci:159: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:159: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:156: referenced as `int`
	cmplStd/lib/time/Datetime.ci:150: referenced as `int`
	cmplStd/lib/time/Datetime.ci:119: referenced as `int`
	cmplStd/lib/time/Datetime.ci:117: referenced as `int`
	cmplStd/lib/time/Datetime.ci:116: referenced as `int`
	cmplStd/lib/time/Datetime.ci:116: referenced as `int`
	cmplStd/lib/time/Datetime.ci:116: referenced as `int`
	cmplStd/lib/time/Datetime.ci:102: referenced as `int`
	cmplStd/lib/time/Datetime.ci:99: referenced as `int`
	cmplStd/lib/time/Datetime.ci:98: referenced as `int`
	cmplStd/lib/time/Datetime.ci:97: referenced as `int`
	cmplStd/lib/time/Datetime.ci:61: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:34: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:32: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:32: referenced as `int`
	cmplStd/lib/time/Datetime.ci:19: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:17: referenced as `int32`
	cmplStd/lib/time/Datetime.ci:17: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `int`
	cmplStd/lib/time/Timestamp.ci:27: referenced as `int`
	cmplStd/lib/math/Fixed.ci:725: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:563: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:562: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:555: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:535: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:485: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:484: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:472: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:457: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:448: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:447: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:446: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:445: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:445: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:445: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:445: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:428: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:426: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:317: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:186: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:183: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:122: referenced as `int`
	cmplStd/lib/math/Fixed.ci:122: referenced as `int`
	cmplStd/lib/math/Fixed.ci:121: referenced as `int`
	cmplStd/lib/math/Fixed.ci:61: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:49: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:48: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:35: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:5: referenced as `int32`
	cmplStd/lib/math/Fixed.ci:3: referenced as `int32`
	cmplStd/lib/math/Math.ci:786: referenced as `int`
	cmplStd/lib/math/Math.ci:746: referenced as `int`
	cmplStd/lib/math/Math.ci:727: referenced as `int`
	cmplStd/lib/math/Math.ci:698: referenced as `int`
	cmplStd/lib/math/Math.ci:659: referenced as `int`
	cmplStd/lib/math/Math.ci:657: referenced as `int`
	cmplStd/lib/math/Math.ci:617: referenced as `int`
	cmplStd/lib/math/Math.ci:557: referenced as `int`
	cmplStd/lib/math/Math.ci:557: referenced as `int`
	cmplStd/lib/math/Math.ci:425: referenced as `int`
	cmplStd/lib/math/Math.ci:374: referenced as `int`
	cmplStd/lib/math/Math.ci:350: referenced as `int`
	cmplStd/lib/math/Math.ci:335: referenced as `int`
	cmplStd/lib/math/Math.ci:309: referenced as `int`
	cmplStd/lib/math/Math.ci:271: referenced as `int`
	cmplStd/lib/math/Math.ci:239: referenced as `int`
	cmplStd/lib/math/Math.ci:228: referenced as `int`
	cmplStd/lib/math/Math.ci:214: referenced as `int`
	cmplStd/lib/math/Math.ci:174: referenced as `int32`
	cmplStd/lib/math/Math.ci:174: referenced as `int32`
	cmplStd/lib/math/Math.ci:174: referenced as `int32`
	cmplStd/lib/math/Math.ci:155: referenced as `int32`
	cmplStd/lib/math/Math.ci:155: referenced as `int32`
	cmplStd/lib/math/Math.ci:137: referenced as `int32`
	cmplStd/lib/math/Math.ci:137: referenced as `int32`
	cmplStd/lib/math/Math.ci:118: referenced as `int32`
	cmplStd/lib/math/Math.ci:98: referenced as `int`
	cmplStd/lib/math/Math.ci:98: referenced as `int`
	cmplStd/lib/math/Math.ci:95: referenced as `int`
	cmplStd/lib/math/Math.ci:95: referenced as `int`
	cmplStd/lib/math/Math.ci:92: referenced as `int`
	cmplStd/lib/math/Math.ci:89: referenced as `int`
	cmplStd/lib/math/Math.ci:86: referenced as `int`
	cmplStd/lib/math/Math.ci:86: referenced as `int`
	cmplStd/lib/math/Math.ci:83: referenced as `int`
	cmplStd/lib/math/Math.ci:83: referenced as `int`
	cmplStd/lib/math/Math.ci:83: referenced as `int32`
	cmplStd/lib/math/Math.ci:40: referenced as `int`
	cmplStd/lib/math/Bits.ci:537: referenced as `int32`
	cmplStd/lib/math/Bits.ci:537: referenced as `int32`
	cmplStd/lib/math/Bits.ci:537: referenced as `int32`
	cmplStd/lib/math/Bits.ci:537: referenced as `int32`
	cmplStd/lib/math/Bits.ci:528: referenced as `int32`
	cmplStd/lib/math/Bits.ci:528: referenced as `int32`
	cmplStd/lib/math/Bits.ci:528: referenced as `int32`
	cmplStd/lib/math/Bits.ci:503: referenced as `int32`
	cmplStd/lib/math/Bits.ci:467: referenced as `int32`
	cmplStd/lib/math/Bits.ci:452: referenced as `int`
	cmplStd/lib/math/Bits.ci:433: referenced as `int`
	cmplStd/lib/math/Bits.ci:417: referenced as `int32`
	cmplStd/lib/math/Bits.ci:404: referenced as `int32`
	cmplStd/lib/math/Bits.ci:350: referenced as `int`
	cmplStd/lib/math/Bits.ci:345: referenced as `int`
	cmplStd/lib/math/Bits.ci:322: referenced as `int`
	cmplStd/lib/math/Bits.ci:317: referenced as `int`
	cmplStd/lib/math/Bits.ci:314: referenced as `int32`
	cmplStd/lib/math/Bits.ci:290: referenced as `int`
	cmplStd/lib/math/Bits.ci:280: referenced as `int`
	cmplStd/lib/math/Bits.ci:249: referenced as `int`
	cmplStd/lib/math/Bits.ci:239: referenced as `int`
	cmplStd/lib/math/Bits.ci:219: referenced as `int`
	cmplStd/lib/math/Bits.ci:214: referenced as `int`
	cmplStd/lib/math/Bits.ci:191: referenced as `int`
	cmplStd/lib/math/Bits.ci:186: referenced as `int`
	cmplStd/lib/math/Bits.ci:183: referenced as `int32`
	cmplStd/lib/math/Bits.ci:159: referenced as `int`
	cmplStd/lib/math/Bits.ci:150: referenced as `int`
	cmplStd/lib/math/Bits.ci:119: referenced as `int`
	cmplStd/lib/math/Bits.ci:110: referenced as `int`
	cmplStd/lib/math/Bits.ci:103: referenced as `int32`
	cmplStd/lib/math/Bits.ci:103: referenced as `int32`
	cmplStd/lib/math/Bits.ci:70: referenced as `int32`
	cmplStd/lib/math/Bits.ci:70: referenced as `int32`
	cmplStd/lib/math/Bits.ci:60: referenced as `int32`
	cmplStd/lib/math/Bits.ci:60: referenced as `int32`
	cmplStd/lib/math/Bits.ci:56: referenced as `int32`
	cmplStd/lib/math/Bits.ci:50: referenced as `int32`
	cmplStd/lib/math/Bits.ci:50: referenced as `int32`
	cmplStd/lib/math/Bits.ci:50: referenced as `int32`
	cmplStd/lib/math/Bits.ci:50: referenced as `int32`
	cmplStd/lib/math/Bits.ci:40: referenced as `int32`
	cmplStd/lib/math/Bits.ci:40: referenced as `int32`
	cmplStd/lib/math/Bits.ci:40: referenced as `int32`
	cmplStd/lib/math/Bits.ci:40: referenced as `int32`
	cmplStd/lib/math/Bits.ci:22: referenced as `int32`
	cmplStd/lib/math/Bits.ci:10: referenced as `int32`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:5: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `int`
	cmplStd/lib/lang/Pointer.ci:1: referenced as `int32`
	cmplStd/lib/lang/Pointer.ci:1: referenced as `int`
	cmplStd/lib/lang/Debug.ci:72: referenced as `int`
	cmplStd/lib/lang/Debug.ci:72: referenced as `int`
	cmplStd/lib/lang/Debug.ci:59: referenced as `int`
	cmplStd/lib/lang/Debug.ci:59: referenced as `int`
	internal usages: 46
}
int64: typename {
.kind: static const typename(i64)
.base: `typename`
.size: 8
.name: 'int64'
.print: '%D'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:77: referenced as `integer`
	cmplStd/test/lang/stmt.if.ci:73: referenced as `integer`
	cmplStd/test/lang/useOperator.ci:205: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:204: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:203: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:202: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:201: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:200: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:199: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:198: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:197: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:196: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:195: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:194: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:193: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:192: referenced as `int64`
	cmplStd/test/lang/useOperator.ci:191: referenced as `int64`
	cmplStd/test/lang/reflect.ci:23: referenced as `int64`
	cmplStd/test/lang/reflect.ci:9: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:81: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:61: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:41: referenced as `int64`
	cmplStd/test/lang/init.reference.ci:29: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:28: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:27: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:25: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:24: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:16: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:14: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:13: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:12: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:8: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:7: referenced as `integer`
	cmplStd/test/lang/init.reference.ci:3: referenced as `integer`
	cmplStd/test/lang/memory.ci:30: referenced as `int64`
	cmplStd/test/lang/memory.ci:29: referenced as `int64`
	cmplStd/test/lang/memory.ci:24: referenced as `int64`
	cmplStd/test/lang/memory.ci:23: referenced as `int64`
	cmplStd/test/lang/emit.ci:26: referenced as `int64`
	cmplStd/test/lang/emit.ci:24: referenced as `int64`
	cmplStd/test/lang/emit.ci:21: referenced as `int64`
	cmplStd/test/lang/emit.ci:4: referenced as `int64`
	cmplStd/test/test.ci:5: referenced as `int64`
	cmplStd/lib/text/stream/TextStream.ci:105: referenced as `int64`
	cmplStd/lib/text/Format.ci:276: referenced as `int64`
	cmplStd/lib/text/Format.ci:273: referenced as `int64`
	cmplStd/lib/text/Format.ci:270: referenced as `int64`
	cmplStd/lib/text/Format.ci:267: referenced as `int64`
	cmplStd/lib/text/Format.ci:267: referenced as `int64`
	cmplStd/lib/text/Format.ci:215: referenced as `int64`
	cmplStd/lib/text/Format.ci:200: referenced as `int64`
	cmplStd/lib/text/Format.ci:170: referenced as `int64`
	cmplStd/lib/time/Datetime.ci:174: referenced as `int64`
	cmplStd/lib/time/Datetime.ci:173: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:120: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:79: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:78: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:60: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:42: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:17: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:12: referenced as `int64`
	cmplStd/lib/time/Timestamp.ci:6: referenced as `int64`
	cmplStd/lib/time/Duration.ci:22: referenced as `int64`
	cmplStd/lib/time/Duration.ci:11: referenced as `int64`
	cmplStd/lib/time/Duration.ci:6: referenced as `int64`
	cmplStd/lib/time/Timeunit.ci:14: referenced as `int64`
	cmplStd/lib/time/Timeunit.ci:14: referenced as `int64`
	cmplStd/lib/time/Timeunit.ci:2: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:715: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:562: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:484: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:444: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:427: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:71: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:71: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:59: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:49: referenced as `int64`
	cmplStd/lib/math/Fixed.ci:47: referenced as `int64`
	cmplStd/lib/math/Math.ci:660: referenced as `int64`
	cmplStd/lib/math/Math.ci:177: referenced as `int64`
	cmplStd/lib/math/Math.ci:177: referenced as `int64`
	cmplStd/lib/math/Math.ci:177: referenced as `int64`
	cmplStd/lib/math/Math.ci:158: referenced as `int64`
	cmplStd/lib/math/Math.ci:158: referenced as `int64`
	cmplStd/lib/math/Math.ci:140: referenced as `int64`
	cmplStd/lib/math/Math.ci:140: referenced as `int64`
	cmplStd/lib/math/Math.ci:121: referenced as `int64`
	cmplStd/lib/math/Math.ci:86: referenced as `int64`
	cmplStd/lib/math/Bits.ci:486: referenced as `int64`
	cmplStd/lib/math/Bits.ci:449: referenced as `int64`
	cmplStd/lib/math/Bits.ci:411: referenced as `int64`
	cmplStd/lib/math/Bits.ci:386: referenced as `int64`
	cmplStd/lib/math/Bits.ci:277: referenced as `int64`
	cmplStd/lib/math/Bits.ci:147: referenced as `int64`
	cmplStd/lib/math/Bits.ci:100: referenced as `int64`
	cmplStd/lib/math/Bits.ci:100: referenced as `int64`
	cmplStd/lib/math/Bits.ci:76: referenced as `int64`
	cmplStd/lib/math/Bits.ci:70: referenced as `int64`
	cmplStd/lib/math/Bits.ci:70: referenced as `int64`
	cmplStd/lib/math/Bits.ci:60: referenced as `int64`
	cmplStd/lib/math/Bits.ci:60: referenced as `int64`
	cmplStd/lib/math/Bits.ci:25: referenced as `int64`
	cmplStd/lib/math/Bits.ci:13: referenced as `int64`
	cmplStd/lib/lang/Pointer.ci:5: referenced as `int64`
	internal usages: 6
}
uint8: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 1
.name: 'uint8'
.print: '%u'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:90: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:89: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:88: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:87: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:86: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:85: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:84: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:83: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:82: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:81: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:80: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:79: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:78: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:77: referenced as `uint8`
	cmplStd/test/lang/useOperator.ci:76: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:57: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:55: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:53: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:47: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:45: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:43: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:37: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:35: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:33: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:27: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:25: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:23: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:17: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:15: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:13: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:7: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:5: referenced as `uint8`
	cmplStd/test/lang/recPacking.ci:3: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:12: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:11: referenced as `uint8`
	cmplStd/test/lang/recUnion.ci:10: referenced as `uint8`
	cmplStd/test/lang/reflect.ci:10: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:82: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:62: referenced as `uint8`
	cmplStd/test/lang/init.reference.ci:42: referenced as `uint8`
	cmplStd/test/lang/tryExec.ci:8: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:78: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:70: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:63: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:59: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:6: referenced as `byte`
	cmplStd/lib/text/encoding/Utf8.ci:5: referenced as `byte`
	cmplStd/lib/text/encoding/Ascii.ci:24: referenced as `byte`
	cmplStd/lib/text/encoding/Ascii.ci:7: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:182: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:165: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:162: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:45: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:41: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:33: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:8: referenced as `byte`
	cmplStd/lib/text/encoding/binary/Base64.ci:3: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:149: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:126: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:104: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:77: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:57: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:56: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:48: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:27: referenced as `byte`
	cmplStd/lib/text/stream/ByteStream.ci:23: referenced as `byte`
	cmplStd/lib/text/Format.ci:264: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:86: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:74: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:72: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:70: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:65: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:37: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:22: referenced as `uint8`
	cmplStd/lib/time/Datetime.ci:2: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:524: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:517: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:517: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:429: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:426: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:426: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:366: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:345: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:235: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:214: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:16: referenced as `uint8`
	cmplStd/lib/math/Bits.ci:4: referenced as `uint8`
	cmplStd/lib.ci:9: referenced as `uint8`
	internal usages: 1
}
uint16: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 2
.name: 'uint16'
.print: '%u'
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:136: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:135: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:134: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:133: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:132: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:131: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:130: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:129: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:128: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:127: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:126: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:125: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:124: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:123: referenced as `uint16`
	cmplStd/test/lang/useOperator.ci:122: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:58: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:48: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:38: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:28: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:18: referenced as `uint16`
	cmplStd/test/lang/recPacking.ci:8: referenced as `uint16`
	cmplStd/test/lang/reflect.ci:11: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:83: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:63: referenced as `uint16`
	cmplStd/test/lang/init.reference.ci:43: referenced as `uint16`
	cmplStd/lib/text/Format.ci:261: referenced as `uint16`
	cmplStd/lib/time/Datetime.ci:89: referenced as `uint16`
	cmplStd/lib/time/Datetime.ci:76: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:514: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:506: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:506: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:423: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:420: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:420: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:342: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:317: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:211: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:186: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:106: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:95: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:95: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:19: referenced as `uint16`
	cmplStd/lib/math/Bits.ci:7: referenced as `uint16`
}
uint32: typename {
.kind: static const typename(u32)
.base: `typename`
.size: 4
.name: 'uint32'
.print: '%u'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.field pop: function (size: 0, cast: static const inline)
.field swap: function (size: 0, cast: static const inline)
.field bsr: function (size: 0, cast: static const inline)
.field bsf: function (size: 0, cast: static const inline)
.field hib: function (size: 0, cast: static const inline)
.field lob: function (size: 0, cast: static const inline)
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/math/test.Bits.ci:56: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:182: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:181: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:180: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:179: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:178: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:177: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:176: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:175: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:174: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:173: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:172: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:171: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:170: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:169: referenced as `uint32`
	cmplStd/test/lang/useOperator.ci:168: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:56: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:46: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:36: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:26: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:16: referenced as `uint32`
	cmplStd/test/lang/recPacking.ci:6: referenced as `uint32`
	cmplStd/test/lang/recUnion.ci:17: referenced as `uint32`
	cmplStd/test/lang/reflect.ci:12: referenced as `uint32`
	cmplStd/test/lang/function.ci:46: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/function.ci:38: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:84: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:64: referenced as `uint32`
	cmplStd/test/lang/init.reference.ci:44: referenced as `uint32`
	cmplStd/lib/text/encoding/Utf8.ci:56: referenced as `unicode`
	cmplStd/lib/text/encoding/Utf8.ci:53: referenced as `unicode`
	cmplStd/lib/text/encoding/Utf8.ci:4: referenced as `unicode`
	cmplStd/lib/text/encoding/Ascii.ci:21: referenced as `unicode`
	cmplStd/lib/text/encoding/Ascii.ci:4: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:169: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:112: referenced as `uint32`
	cmplStd/lib/text/stream/TextStream.ci:64: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:26: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:16: referenced as `unicode`
	cmplStd/lib/text/stream/TextStream.ci:3: referenced as `uint32`
	cmplStd/lib/text/Format.ci:258: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:372: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:368: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:367: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:366: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:365: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:310: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:308: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:306: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:255: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:188: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:185: referenced as `uint32`
	cmplStd/lib/math/Fixed.ci:135: referenced as `uint32`
	cmplStd/lib/math/Math.ci:180: referenced as `uint32`
	cmplStd/lib/math/Math.ci:180: referenced as `uint32`
	cmplStd/lib/math/Math.ci:180: referenced as `uint32`
	cmplStd/lib/math/Math.ci:161: referenced as `uint32`
	cmplStd/lib/math/Math.ci:161: referenced as `uint32`
	cmplStd/lib/math/Math.ci:143: referenced as `uint32`
	cmplStd/lib/math/Math.ci:143: referenced as `uint32`
	cmplStd/lib/math/Math.ci:124: referenced as `uint32`
	cmplStd/lib/math/Math.ci:89: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:503: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:492: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:490: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:489: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:489: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:467: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:455: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:453: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:452: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:417: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:414: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:414: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:404: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:392: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:390: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:389: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:389: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:314: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:283: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:281: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:280: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:183: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:153: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:151: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:150: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:103: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:88: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:88: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:53: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:51: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:46: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:43: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:41: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:37: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:37: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:33: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:33: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:28: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:22: referenced as `uint32`
	cmplStd/lib/math/Bits.ci:10: referenced as `uint32`
}
uint32.zxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(24)
.usages:
	cmplStd/lib/math/Bits.ci:43: referenced as `zxt`
	cmplStd/lib/math/Bits.ci:41: referenced as `zxt`
}
uint32.sxt(value: int32, offs: int32, count: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(25)
.usages:
	cmplStd/lib/math/Bits.ci:53: referenced as `sxt`
	cmplStd/lib/math/Bits.ci:51: referenced as `sxt`
}
uint32.pop(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pop'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(26)
.usages:
	cmplStd/lib/math/Bits.ci:455: referenced as `pop`
	cmplStd/lib/math/Bits.ci:453: referenced as `pop`
}
uint32.swap(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'swap'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(27)
.usages:
	cmplStd/lib/math/Bits.ci:492: referenced as `swap`
	cmplStd/lib/math/Bits.ci:490: referenced as `swap`
}
uint32.bsr(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsr'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(28)
.usages:
	cmplStd/lib/math/Bits.ci:153: referenced as `bsr`
	cmplStd/lib/math/Bits.ci:151: referenced as `bsr`
}
uint32.bsf(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'bsf'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(29)
.usages:
	cmplStd/lib/math/Bits.ci:283: referenced as `bsf`
	cmplStd/lib/math/Bits.ci:281: referenced as `bsf`
}
uint32.hib(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'hib'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(30)
.usages:
	cmplStd/lib/math/Bits.ci:392: referenced as `hib`
	cmplStd/lib/math/Bits.ci:390: referenced as `hib`
}
uint32.lob(value: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'lob'
.owner: uint32
.param .result: int32 (size: 4, cast: inline)
.param value: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(31)
.usages:
}
uint64: typename {
.kind: static const typename(u64)
.base: `typename`
.size: 8
.name: 'uint64'
.print: '%U'
.field zxt: function (size: 0, cast: static const inline)
.field sxt: function (size: 0, cast: static const inline)
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:228: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:227: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:226: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:225: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:224: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:223: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:222: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:221: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:220: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:219: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:218: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:217: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:216: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:215: referenced as `uint64`
	cmplStd/test/lang/useOperator.ci:214: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:54: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:44: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:34: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:24: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:14: referenced as `uint64`
	cmplStd/test/lang/recPacking.ci:4: referenced as `uint64`
	cmplStd/test/lang/reflect.ci:13: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:85: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:65: referenced as `uint64`
	cmplStd/test/lang/init.reference.ci:45: referenced as `uint64`
	cmplStd/lib/text/stream/TextStream.ci:119: referenced as `uint64`
	cmplStd/lib/text/Format.ci:264: referenced as `uint64`
	cmplStd/lib/text/Format.ci:261: referenced as `uint64`
	cmplStd/lib/text/Format.ci:258: referenced as `uint64`
	cmplStd/lib/text/Format.ci:255: referenced as `uint64`
	cmplStd/lib/text/Format.ci:255: referenced as `uint64`
	cmplStd/lib/text/Format.ci:215: referenced as `uint64`
	cmplStd/lib/text/Format.ci:200: referenced as `uint64`
	cmplStd/lib/text/Format.ci:180: referenced as `uint64`
	cmplStd/lib/text/Format.ci:178: referenced as `uint64`
	cmplStd/lib/text/Format.ci:107: referenced as `uint64`
	cmplStd/lib/time/Timestamp.ci:94: referenced as `uint64`
	cmplStd/lib/math/Math.ci:591: referenced as `uint64`
	cmplStd/lib/math/Math.ci:578: referenced as `uint64`
	cmplStd/lib/math/Math.ci:576: referenced as `uint64`
	cmplStd/lib/math/Math.ci:575: referenced as `uint64`
	cmplStd/lib/math/Math.ci:574: referenced as `uint64`
	cmplStd/lib/math/Math.ci:555: referenced as `uint64`
	cmplStd/lib/math/Math.ci:391: referenced as `uint64`
	cmplStd/lib/math/Math.ci:373: referenced as `uint64`
	cmplStd/lib/math/Math.ci:334: referenced as `uint64`
	cmplStd/lib/math/Math.ci:295: referenced as `uint64`
	cmplStd/lib/math/Math.ci:294: referenced as `uint64`
	cmplStd/lib/math/Math.ci:183: referenced as `uint64`
	cmplStd/lib/math/Math.ci:183: referenced as `uint64`
	cmplStd/lib/math/Math.ci:183: referenced as `uint64`
	cmplStd/lib/math/Math.ci:164: referenced as `uint64`
	cmplStd/lib/math/Math.ci:164: referenced as `uint64`
	cmplStd/lib/math/Math.ci:146: referenced as `uint64`
	cmplStd/lib/math/Math.ci:146: referenced as `uint64`
	cmplStd/lib/math/Math.ci:127: referenced as `uint64`
	cmplStd/lib/math/Math.ci:92: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:486: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:474: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:472: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:471: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:471: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:449: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:436: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:434: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:433: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:411: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:408: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:408: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:386: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:373: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:371: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:370: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:370: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:277: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:242: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:240: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:239: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:147: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:113: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:111: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:110: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:100: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:80: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:80: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:73: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:71: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:66: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:63: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:61: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:37: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:37: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:35: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:35: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:30: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:25: referenced as `uint64`
	cmplStd/lib/math/Bits.ci:13: referenced as `uint64`
}
uint64.zxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'zxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(32)
.usages:
	cmplStd/lib/math/Bits.ci:63: referenced as `zxt`
	cmplStd/lib/math/Bits.ci:61: referenced as `zxt`
}
uint64.sxt(value: int64, offs: int32, count: int32): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sxt'
.owner: uint64
.param .result: int64 (size: 8, cast: inline)
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(33)
.usages:
	cmplStd/lib/math/Bits.ci:73: referenced as `sxt`
	cmplStd/lib/math/Bits.ci:71: referenced as `sxt`
}
float32: typename {
.kind: static const typename(f32)
.base: `typename`
.size: 4
.name: 'float32'
.print: '%f'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/math/test.Math.ci:119: referenced as `float32`
	cmplStd/test/math/test.Math.ci:118: referenced as `float32`
	cmplStd/test/math/test.Math.ci:117: referenced as `float32`
	cmplStd/test/math/test.Math.ci:116: referenced as `float32`
	cmplStd/test/math/test.Math.ci:114: referenced as `float32`
	cmplStd/test/math/test.Math.ci:113: referenced as `float32`
	cmplStd/test/math/test.Math.ci:112: referenced as `float32`
	cmplStd/test/math/test.Math.ci:111: referenced as `float32`
	cmplStd/test/math/test.Math.ci:109: referenced as `float32`
	cmplStd/test/math/test.Math.ci:108: referenced as `float32`
	cmplStd/test/math/test.Math.ci:107: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:53: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:52: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:51: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:50: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:49: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:48: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:47: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:46: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:7: referenced as `float32`
	cmplStd/test/math/test.Bits.ci:6: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:246: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:245: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:244: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:243: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:242: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:240: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:239: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:238: referenced as `float32`
	cmplStd/test/lang/useOperator.ci:237: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:5: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:4: referenced as `float32`
	cmplStd/test/lang/recUnion.ci:3: referenced as `float32`
	cmplStd/test/lang/reflect.ci:14: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:86: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:66: referenced as `float32`
	cmplStd/test/lang/init.reference.ci:46: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:13: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:12: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:11: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:10: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:9: referenced as `float32`
	cmplStd/test/lang/overload.inline.ci:6: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:19: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/test/lang/emit.ci:16: referenced as `float32`
	cmplStd/lib/text/stream/TextStream.ci:126: referenced as `float32`
	cmplStd/lib/text/Format.ci:279: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:247: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:245: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:244: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:243: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:242: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:241: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:240: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:239: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:238: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:237: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:236: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:235: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:234: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:232: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:231: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:230: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:229: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:227: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:226: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:225: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:224: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:222: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:221: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:220: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:219: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:217: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:216: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:215: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:214: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:202: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:201: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:191: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:167: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:164: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:162: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:161: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:159: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:158: referenced as `float`
	cmplStd/lib/math/Matrix4f.ci:135: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:134: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:130: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:129: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:128: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:127: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:126: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:121: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:120: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:110: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:109: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:65: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:64: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:63: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:57: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:55: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:53: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:51: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:48: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:46: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:44: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:42: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:39: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:37: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:33: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:30: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:28: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:24: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Matrix4f.ci:4: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:114: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:14: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:11: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:9: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:7: referenced as `float32`
	cmplStd/lib/math/Vector4f.ci:5: referenced as `float32`
	cmplStd/lib/math/Math.ci:991: referenced as `float32`
	cmplStd/lib/math/Math.ci:988: referenced as `float32`
	cmplStd/lib/math/Math.ci:986: referenced as `float32`
	cmplStd/lib/math/Math.ci:985: referenced as `float32`
	cmplStd/lib/math/Math.ci:985: referenced as `float32`
	cmplStd/lib/math/Math.ci:949: referenced as `float32`
	cmplStd/lib/math/Math.ci:946: referenced as `float32`
	cmplStd/lib/math/Math.ci:944: referenced as `float32`
	cmplStd/lib/math/Math.ci:943: referenced as `float32`
	cmplStd/lib/math/Math.ci:943: referenced as `float32`
	cmplStd/lib/math/Math.ci:916: referenced as `float32`
	cmplStd/lib/math/Math.ci:913: referenced as `float32`
	cmplStd/lib/math/Math.ci:911: referenced as `float32`
	cmplStd/lib/math/Math.ci:910: referenced as `float32`
	cmplStd/lib/math/Math.ci:910: referenced as `float32`
	cmplStd/lib/math/Math.ci:895: referenced as `float32`
	cmplStd/lib/math/Math.ci:892: referenced as `float32`
	cmplStd/lib/math/Math.ci:890: referenced as `float32`
	cmplStd/lib/math/Math.ci:889: referenced as `float32`
	cmplStd/lib/math/Math.ci:889: referenced as `float32`
	cmplStd/lib/math/Math.ci:889: referenced as `float32`
	cmplStd/lib/math/Math.ci:693: referenced as `float32`
	cmplStd/lib/math/Math.ci:690: referenced as `float32`
	cmplStd/lib/math/Math.ci:688: referenced as `float32`
	cmplStd/lib/math/Math.ci:687: referenced as `float32`
	cmplStd/lib/math/Math.ci:687: referenced as `float32`
	cmplStd/lib/math/Math.ci:687: referenced as `float32`
	cmplStd/lib/math/Math.ci:602: referenced as `float32`
	cmplStd/lib/math/Math.ci:599: referenced as `float32`
	cmplStd/lib/math/Math.ci:597: referenced as `float32`
	cmplStd/lib/math/Math.ci:596: referenced as `float32`
	cmplStd/lib/math/Math.ci:596: referenced as `float32`
	cmplStd/lib/math/Math.ci:527: referenced as `float32`
	cmplStd/lib/math/Math.ci:524: referenced as `float32`
	cmplStd/lib/math/Math.ci:522: referenced as `float32`
	cmplStd/lib/math/Math.ci:521: referenced as `float32`
	cmplStd/lib/math/Math.ci:521: referenced as `float32`
	cmplStd/lib/math/Math.ci:450: referenced as `float32`
	cmplStd/lib/math/Math.ci:447: referenced as `float32`
	cmplStd/lib/math/Math.ci:445: referenced as `float32`
	cmplStd/lib/math/Math.ci:444: referenced as `float32`
	cmplStd/lib/math/Math.ci:444: referenced as `float32`
	cmplStd/lib/math/Math.ci:200: referenced as `float32`
	cmplStd/lib/math/Math.ci:200: referenced as `float32`
	cmplStd/lib/math/Math.ci:200: referenced as `float32`
	cmplStd/lib/math/Math.ci:197: referenced as `float32`
	cmplStd/lib/math/Math.ci:192: referenced as `float32`
	cmplStd/lib/math/Math.ci:192: referenced as `float32`
	cmplStd/lib/math/Math.ci:192: referenced as `float32`
	cmplStd/lib/math/Math.ci:186: referenced as `float32`
	cmplStd/lib/math/Math.ci:186: referenced as `float32`
	cmplStd/lib/math/Math.ci:186: referenced as `float32`
	cmplStd/lib/math/Math.ci:167: referenced as `float32`
	cmplStd/lib/math/Math.ci:167: referenced as `float32`
	cmplStd/lib/math/Math.ci:149: referenced as `float32`
	cmplStd/lib/math/Math.ci:149: referenced as `float32`
	cmplStd/lib/math/Math.ci:130: referenced as `float32`
	cmplStd/lib/math/Math.ci:102: referenced as `float32`
	cmplStd/lib/math/Math.ci:102: referenced as `float32`
	cmplStd/lib/math/Math.ci:102: referenced as `float32`
	cmplStd/lib/math/Math.ci:95: referenced as `float32`
	cmplStd/lib/math/Math.ci:79: referenced as `float32`
	cmplStd/lib/math/Math.ci:73: referenced as `float32`
	cmplStd/lib/math/Math.ci:62: referenced as `float32`
	cmplStd/lib/math/Math.ci:61: referenced as `float32`
	cmplStd/lib/math/Math.ci:61: referenced as `float32`
	cmplStd/lib/math/Bits.ci:33: referenced as `float32`
	cmplStd/lib/math/Bits.ci:28: referenced as `float32`
	cmplStd/lib/math/Bits.ci:28: referenced as `float32`
	cmplStd/lib.ci:10: referenced as `float32`
	internal usages: 18
}
float32.sin(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(34)
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `sin`
	cmplStd/lib/math/Math.ci:913: referenced as `sin`
	cmplStd/lib/math/Math.ci:911: referenced as `sin`
}
float32.cos(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(35)
.usages:
	cmplStd/lib/math/Math.ci:946: referenced as `cos`
	cmplStd/lib/math/Math.ci:944: referenced as `cos`
}
float32.tan(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(36)
.usages:
	cmplStd/lib/math/Math.ci:988: referenced as `tan`
	cmplStd/lib/math/Math.ci:986: referenced as `tan`
}
float32.log(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(37)
.usages:
	cmplStd/lib/math/Math.ci:447: referenced as `log`
	cmplStd/lib/math/Math.ci:445: referenced as `log`
}
float32.exp(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(38)
.usages:
	cmplStd/lib/math/Math.ci:524: referenced as `exp`
	cmplStd/lib/math/Math.ci:522: referenced as `exp`
}
float32.pow(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(39)
.usages:
	cmplStd/lib/math/Math.ci:690: referenced as `pow`
	cmplStd/lib/math/Math.ci:688: referenced as `pow`
}
float32.sqrt(x: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(40)
.usages:
	cmplStd/lib/math/Math.ci:599: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:597: referenced as `sqrt`
}
float32.atan2(x: float32, y: float32): float32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float32
.param .result: float32 (size: 4, cast: inline)
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.doc: '@builtin'
.value: nfc(41)
.usages:
	cmplStd/lib/math/Math.ci:892: referenced as `atan2`
	cmplStd/lib/math/Math.ci:890: referenced as `atan2`
}
float64: typename {
.kind: static const typename(f64)
.base: `typename`
.size: 8
.name: 'float64'
.print: '%F'
.field sin: function (size: 0, cast: static const inline)
.field cos: function (size: 0, cast: static const inline)
.field tan: function (size: 0, cast: static const inline)
.field log: function (size: 0, cast: static const inline)
.field exp: function (size: 0, cast: static const inline)
.field pow: function (size: 0, cast: static const inline)
.field sqrt: function (size: 0, cast: static const inline)
.field atan2: function (size: 0, cast: static const inline)
.field ldexp: function (size: 0, cast: static const inline)
.field frexp: function (size: 0, cast: static const inline)
.field parse: function (size: 0, cast: static const inline)
.field print: function (size: 0, cast: static const inline)
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/test/math/test.Math.ci:105: referenced as `float64`
	cmplStd/test/math/test.Math.ci:104: referenced as `float64`
	cmplStd/test/math/test.Math.ci:103: referenced as `float64`
	cmplStd/test/math/test.Math.ci:102: referenced as `float64`
	cmplStd/test/math/test.Math.ci:100: referenced as `float64`
	cmplStd/test/math/test.Math.ci:99: referenced as `float64`
	cmplStd/test/math/test.Math.ci:98: referenced as `float64`
	cmplStd/test/math/test.Math.ci:97: referenced as `float64`
	cmplStd/test/math/test.Math.ci:95: referenced as `float64`
	cmplStd/test/math/test.Math.ci:94: referenced as `float64`
	cmplStd/test/math/test.Math.ci:93: referenced as `float64`
	cmplStd/test/math/test.Math.ci:90: referenced as `float64`
	cmplStd/test/math/test.Math.ci:89: referenced as `float64`
	cmplStd/test/math/test.Math.ci:87: referenced as `float64`
	cmplStd/test/math/test.Math.ci:86: referenced as `float64`
	cmplStd/test/math/test.Math.ci:85: referenced as `float64`
	cmplStd/test/math/test.Math.ci:84: referenced as `float64`
	cmplStd/test/math/test.Math.ci:83: referenced as `float64`
	cmplStd/test/math/test.Math.ci:81: referenced as `float64`
	cmplStd/test/math/test.Math.ci:80: referenced as `float64`
	cmplStd/test/math/test.Math.ci:79: referenced as `float64`
	cmplStd/test/math/test.Math.ci:78: referenced as `float64`
	cmplStd/test/math/test.Math.ci:77: referenced as `float64`
	cmplStd/test/math/test.Math.ci:76: referenced as `float64`
	cmplStd/test/math/test.Math.ci:75: referenced as `float64`
	cmplStd/test/math/test.Math.ci:74: referenced as `float64`
	cmplStd/test/math/test.Math.ci:72: referenced as `float64`
	cmplStd/test/math/test.Math.ci:71: referenced as `float64`
	cmplStd/test/math/test.Math.ci:70: referenced as `float64`
	cmplStd/test/math/test.Math.ci:69: referenced as `float64`
	cmplStd/test/math/test.Math.ci:67: referenced as `float64`
	cmplStd/test/math/test.Math.ci:66: referenced as `float64`
	cmplStd/test/math/test.Math.ci:65: referenced as `float64`
	cmplStd/test/math/test.Math.ci:64: referenced as `float64`
	cmplStd/test/math/test.Math.ci:62: referenced as `float64`
	cmplStd/test/math/test.Math.ci:61: referenced as `float64`
	cmplStd/test/math/test.Math.ci:59: referenced as `float64`
	cmplStd/test/math/test.Math.ci:58: referenced as `float64`
	cmplStd/test/math/test.Math.ci:56: referenced as `float64`
	cmplStd/test/math/test.Math.ci:55: referenced as `float64`
	cmplStd/test/math/test.Math.ci:53: referenced as `float64`
	cmplStd/test/math/test.Math.ci:52: referenced as `float64`
	cmplStd/test/math/test.Math.ci:51: referenced as `float64`
	cmplStd/test/math/test.Math.ci:50: referenced as `float64`
	cmplStd/test/math/test.Math.ci:48: referenced as `float64`
	cmplStd/test/math/test.Math.ci:47: referenced as `float64`
	cmplStd/test/math/test.Math.ci:46: referenced as `float64`
	cmplStd/test/math/test.Math.ci:45: referenced as `float64`
	cmplStd/test/math/test.Math.ci:44: referenced as `float64`
	cmplStd/test/math/test.Math.ci:43: referenced as `float64`
	cmplStd/test/math/test.Math.ci:41: referenced as `float64`
	cmplStd/test/math/test.Math.ci:40: referenced as `float64`
	cmplStd/test/math/test.Math.ci:39: referenced as `float64`
	cmplStd/test/math/test.Math.ci:38: referenced as `float64`
	cmplStd/test/math/test.Math.ci:37: referenced as `float64`
	cmplStd/test/math/test.Math.ci:36: referenced as `float64`
	cmplStd/test/math/test.Math.ci:34: referenced as `float64`
	cmplStd/test/math/test.Math.ci:33: referenced as `float64`
	cmplStd/test/math/test.Math.ci:32: referenced as `float64`
	cmplStd/test/math/test.Math.ci:31: referenced as `float64`
	cmplStd/test/math/test.Math.ci:30: referenced as `float64`
	cmplStd/test/math/test.Math.ci:29: referenced as `float64`
	cmplStd/test/math/test.Math.ci:28: referenced as `float64`
	cmplStd/test/math/test.Math.ci:27: referenced as `float64`
	cmplStd/test/math/test.Math.ci:26: referenced as `float64`
	cmplStd/test/math/test.Math.ci:25: referenced as `float64`
	cmplStd/test/math/test.Math.ci:23: referenced as `float64`
	cmplStd/test/math/test.Math.ci:22: referenced as `float64`
	cmplStd/test/math/test.Math.ci:21: referenced as `float64`
	cmplStd/test/math/test.Math.ci:20: referenced as `float64`
	cmplStd/test/math/test.Math.ci:19: referenced as `float64`
	cmplStd/test/math/test.Math.ci:18: referenced as `float64`
	cmplStd/test/math/test.Math.ci:17: referenced as `float64`
	cmplStd/test/math/test.Math.ci:16: referenced as `float64`
	cmplStd/test/math/test.Math.ci:15: referenced as `float64`
	cmplStd/test/math/test.Math.ci:14: referenced as `float64`
	cmplStd/test/math/test.Math.ci:12: referenced as `float64`
	cmplStd/test/math/test.Math.ci:11: referenced as `float64`
	cmplStd/test/math/test.Math.ci:10: referenced as `float64`
	cmplStd/test/math/test.Math.ci:9: referenced as `float64`
	cmplStd/test/math/test.Math.ci:8: referenced as `float64`
	cmplStd/test/math/test.Math.ci:7: referenced as `float64`
	cmplStd/test/math/test.Math.ci:6: referenced as `float64`
	cmplStd/test/math/test.Math.ci:5: referenced as `float64`
	cmplStd/test/math/test.Math.ci:4: referenced as `float64`
	cmplStd/test/math/test.Math.ci:3: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:44: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:43: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:42: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:41: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:40: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:39: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:38: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:37: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:4: referenced as `float64`
	cmplStd/test/math/test.Bits.ci:3: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:269: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:268: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:267: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:266: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:265: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:263: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:262: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:261: referenced as `float64`
	cmplStd/test/lang/useOperator.ci:260: referenced as `float64`
	cmplStd/test/lang/reflect.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:15: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:14: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:11: referenced as `float64`
	cmplStd/test/lang/init.variable.ci:10: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:87: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:67: referenced as `float64`
	cmplStd/test/lang/init.reference.ci:47: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:16: referenced as `float64`
	cmplStd/test/lang/overload.inline.ci:15: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/test/lang/emit.ci:21: referenced as `float64`
	cmplStd/lib/math/Polynomial.ci:177: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:163: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:146: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:145: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:145: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:98: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:98: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:89: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:59: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:21: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:8: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:5: referenced as `scalar`
	cmplStd/lib/math/Polynomial.ci:1: referenced as `float64`
	cmplStd/lib/math/Easing.ci:109: referenced as `float64`
	cmplStd/lib/math/Easing.ci:109: referenced as `float64`
	cmplStd/lib/math/Easing.ci:109: referenced as `float64`
	cmplStd/lib/math/Easing.ci:109: referenced as `float64`
	cmplStd/lib/math/Easing.ci:100: referenced as `float64`
	cmplStd/lib/math/Easing.ci:100: referenced as `float64`
	cmplStd/lib/math/Easing.ci:100: referenced as `float64`
	cmplStd/lib/math/Easing.ci:100: referenced as `float64`
	cmplStd/lib/math/Easing.ci:92: referenced as `float64`
	cmplStd/lib/math/Easing.ci:92: referenced as `float64`
	cmplStd/lib/math/Easing.ci:92: referenced as `float64`
	cmplStd/lib/math/Easing.ci:92: referenced as `float64`
	cmplStd/lib/math/Easing.ci:84: referenced as `float64`
	cmplStd/lib/math/Easing.ci:84: referenced as `float64`
	cmplStd/lib/math/Easing.ci:84: referenced as `float64`
	cmplStd/lib/math/Easing.ci:84: referenced as `float64`
	cmplStd/lib/math/Easing.ci:60: referenced as `float64`
	cmplStd/lib/math/Easing.ci:60: referenced as `float64`
	cmplStd/lib/math/Easing.ci:60: referenced as `float64`
	cmplStd/lib/math/Easing.ci:60: referenced as `float64`
	cmplStd/lib/math/Easing.ci:59: referenced as `float64`
	cmplStd/lib/math/Easing.ci:59: referenced as `float64`
	cmplStd/lib/math/Easing.ci:53: referenced as `float64`
	cmplStd/lib/math/Easing.ci:53: referenced as `float64`
	cmplStd/lib/math/Easing.ci:46: referenced as `float64`
	cmplStd/lib/math/Easing.ci:46: referenced as `float64`
	cmplStd/lib/math/Easing.ci:41: referenced as `float64`
	cmplStd/lib/math/Easing.ci:41: referenced as `float64`
	cmplStd/lib/math/Easing.ci:36: referenced as `float64`
	cmplStd/lib/math/Easing.ci:36: referenced as `float64`
	cmplStd/lib/math/Easing.ci:31: referenced as `float64`
	cmplStd/lib/math/Easing.ci:31: referenced as `float64`
	cmplStd/lib/math/Easing.ci:26: referenced as `float64`
	cmplStd/lib/math/Easing.ci:26: referenced as `float64`
	cmplStd/lib/math/Easing.ci:21: referenced as `float64`
	cmplStd/lib/math/Easing.ci:21: referenced as `float64`
	cmplStd/lib/math/Easing.ci:16: referenced as `float64`
	cmplStd/lib/math/Easing.ci:16: referenced as `float64`
	cmplStd/lib/math/Easing.ci:11: referenced as `float64`
	cmplStd/lib/math/Easing.ci:11: referenced as `float64`
	cmplStd/lib/math/Easing.ci:6: referenced as `float64`
	cmplStd/lib/math/Easing.ci:6: referenced as `float64`
	cmplStd/lib/text/stream/TextStream.ci:133: referenced as `float64`
	cmplStd/lib/text/Format.ci:279: referenced as `float64`
	cmplStd/lib/text/Format.ci:211: referenced as `float64`
	cmplStd/lib/text/Format.ci:197: referenced as `float64`
	cmplStd/lib/text/Format.ci:184: referenced as `float64`
	cmplStd/lib/text/cstr.ci:130: referenced as `float64`
	cmplStd/lib/text/cstr.ci:129: referenced as `float64`
	cmplStd/lib/text/cstr.ci:121: referenced as `float64`
	cmplStd/lib/text/cstr.ci:119: referenced as `float64`
	cmplStd/lib/text/cstr.ci:118: referenced as `float64`
	cmplStd/lib/text/cstr.ci:117: referenced as `float64`
	cmplStd/lib/time/Timeunit.ci:24: referenced as `float64`
	cmplStd/lib/time/Timeunit.ci:24: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:10: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:7: referenced as `float64`
	cmplStd/lib/math/Vector2d.ci:5: referenced as `float64`
	cmplStd/lib/math/Complex.ci:113: referenced as `float64`
	cmplStd/lib/math/Complex.ci:106: referenced as `float64`
	cmplStd/lib/math/Complex.ci:105: referenced as `float64`
	cmplStd/lib/math/Complex.ci:104: referenced as `float64`
	cmplStd/lib/math/Complex.ci:103: referenced as `float64`
	cmplStd/lib/math/Complex.ci:85: referenced as `float64`
	cmplStd/lib/math/Complex.ci:76: referenced as `float64`
	cmplStd/lib/math/Complex.ci:74: referenced as `float64`
	cmplStd/lib/math/Complex.ci:67: referenced as `float64`
	cmplStd/lib/math/Complex.ci:66: referenced as `float64`
	cmplStd/lib/math/Complex.ci:60: referenced as `float64`
	cmplStd/lib/math/Complex.ci:59: referenced as `float64`
	cmplStd/lib/math/Complex.ci:51: referenced as `float64`
	cmplStd/lib/math/Complex.ci:49: referenced as `float64`
	cmplStd/lib/math/Complex.ci:41: referenced as `float64`
	cmplStd/lib/math/Complex.ci:39: referenced as `float64`
	cmplStd/lib/math/Complex.ci:34: referenced as `float64`
	cmplStd/lib/math/Complex.ci:32: referenced as `float64`
	cmplStd/lib/math/Complex.ci:19: referenced as `float64`
	cmplStd/lib/math/Complex.ci:19: referenced as `float64`
	cmplStd/lib/math/Complex.ci:12: referenced as `float64`
	cmplStd/lib/math/Complex.ci:8: referenced as `float64`
	cmplStd/lib/math/Complex.ci:5: referenced as `float64`
	cmplStd/lib/math/Fixed.ci:761: referenced as `float64`
	cmplStd/lib/math/Fixed.ci:750: referenced as `float64`
	cmplStd/lib/math/Fixed.ci:732: referenced as `float64`
	cmplStd/lib/math/Math.ci:1054: referenced as `float64`
	cmplStd/lib/math/Math.ci:1054: referenced as `float64`
	cmplStd/lib/math/Math.ci:1051: referenced as `float64`
	cmplStd/lib/math/Math.ci:1051: referenced as `float64`
	cmplStd/lib/math/Math.ci:1047: referenced as `float64`
	cmplStd/lib/math/Math.ci:1044: referenced as `float64`
	cmplStd/lib/math/Math.ci:1041: referenced as `float64`
	cmplStd/lib/math/Math.ci:1038: referenced as `float64`
	cmplStd/lib/math/Math.ci:1034: referenced as `float64`
	cmplStd/lib/math/Math.ci:1031: referenced as `float64`
	cmplStd/lib/math/Math.ci:1028: referenced as `float64`
	cmplStd/lib/math/Math.ci:1025: referenced as `float64`
	cmplStd/lib/math/Math.ci:1021: referenced as `float64`
	cmplStd/lib/math/Math.ci:1018: referenced as `float64`
	cmplStd/lib/math/Math.ci:1015: referenced as `float64`
	cmplStd/lib/math/Math.ci:1005: referenced as `float64`
	cmplStd/lib/math/Math.ci:1003: referenced as `float64`
	cmplStd/lib/math/Math.ci:1002: referenced as `float64`
	cmplStd/lib/math/Math.ci:1002: referenced as `float64`
	cmplStd/lib/math/Math.ci:998: referenced as `float64`
	cmplStd/lib/math/Math.ci:995: referenced as `float64`
	cmplStd/lib/math/Math.ci:991: referenced as `float64`
	cmplStd/lib/math/Math.ci:966: referenced as `float64`
	cmplStd/lib/math/Math.ci:964: referenced as `float64`
	cmplStd/lib/math/Math.ci:963: referenced as `float64`
	cmplStd/lib/math/Math.ci:963: referenced as `float64`
	cmplStd/lib/math/Math.ci:959: referenced as `float64`
	cmplStd/lib/math/Math.ci:956: referenced as `float64`
	cmplStd/lib/math/Math.ci:953: referenced as `float64`
	cmplStd/lib/math/Math.ci:949: referenced as `float64`
	cmplStd/lib/math/Math.ci:933: referenced as `float64`
	cmplStd/lib/math/Math.ci:931: referenced as `float64`
	cmplStd/lib/math/Math.ci:930: referenced as `float64`
	cmplStd/lib/math/Math.ci:930: referenced as `float64`
	cmplStd/lib/math/Math.ci:926: referenced as `float64`
	cmplStd/lib/math/Math.ci:923: referenced as `float64`
	cmplStd/lib/math/Math.ci:920: referenced as `float64`
	cmplStd/lib/math/Math.ci:916: referenced as `float64`
	cmplStd/lib/math/Math.ci:903: referenced as `float64`
	cmplStd/lib/math/Math.ci:901: referenced as `float64`
	cmplStd/lib/math/Math.ci:900: referenced as `float64`
	cmplStd/lib/math/Math.ci:900: referenced as `float64`
	cmplStd/lib/math/Math.ci:895: referenced as `float64`
	cmplStd/lib/math/Math.ci:895: referenced as `float64`
	cmplStd/lib/math/Math.ci:868: referenced as `float64`
	cmplStd/lib/math/Math.ci:866: referenced as `float64`
	cmplStd/lib/math/Math.ci:865: referenced as `float64`
	cmplStd/lib/math/Math.ci:865: referenced as `float64`
	cmplStd/lib/math/Math.ci:865: referenced as `float64`
	cmplStd/lib/math/Math.ci:847: referenced as `float64`
	cmplStd/lib/math/Math.ci:847: referenced as `float64`
	cmplStd/lib/math/Math.ci:842: referenced as `float64`
	cmplStd/lib/math/Math.ci:841: referenced as `float64`
	cmplStd/lib/math/Math.ci:840: referenced as `float64`
	cmplStd/lib/math/Math.ci:839: referenced as `float64`
	cmplStd/lib/math/Math.ci:839: referenced as `float64`
	cmplStd/lib/math/Math.ci:821: referenced as `float64`
	cmplStd/lib/math/Math.ci:820: referenced as `float64`
	cmplStd/lib/math/Math.ci:820: referenced as `float64`
	cmplStd/lib/math/Math.ci:796: referenced as `float64`
	cmplStd/lib/math/Math.ci:781: referenced as `float64`
	cmplStd/lib/math/Math.ci:778: referenced as `float64`
	cmplStd/lib/math/Math.ci:766: referenced as `float64`
	cmplStd/lib/math/Math.ci:747: referenced as `float64`
	cmplStd/lib/math/Math.ci:746: referenced as `float64`
	cmplStd/lib/math/Math.ci:746: referenced as `float64`
	cmplStd/lib/math/Math.ci:741: referenced as `float64`
	cmplStd/lib/math/Math.ci:740: referenced as `float64`
	cmplStd/lib/math/Math.ci:739: referenced as `float64`
	cmplStd/lib/math/Math.ci:723: referenced as `float64`
	cmplStd/lib/math/Math.ci:719: referenced as `float64`
	cmplStd/lib/math/Math.ci:716: referenced as `float64`
	cmplStd/lib/math/Math.ci:699: referenced as `float64`
	cmplStd/lib/math/Math.ci:698: referenced as `float64`
	cmplStd/lib/math/Math.ci:698: referenced as `float64`
	cmplStd/lib/math/Math.ci:693: referenced as `float64`
	cmplStd/lib/math/Math.ci:693: referenced as `float64`
	cmplStd/lib/math/Math.ci:624: referenced as `float64`
	cmplStd/lib/math/Math.ci:623: referenced as `float64`
	cmplStd/lib/math/Math.ci:622: referenced as `float64`
	cmplStd/lib/math/Math.ci:610: referenced as `float64`
	cmplStd/lib/math/Math.ci:608: referenced as `float64`
	cmplStd/lib/math/Math.ci:607: referenced as `float64`
	cmplStd/lib/math/Math.ci:607: referenced as `float64`
	cmplStd/lib/math/Math.ci:607: referenced as `float64`
	cmplStd/lib/math/Math.ci:602: referenced as `float64`
	cmplStd/lib/math/Math.ci:535: referenced as `float64`
	cmplStd/lib/math/Math.ci:533: referenced as `float64`
	cmplStd/lib/math/Math.ci:532: referenced as `float64`
	cmplStd/lib/math/Math.ci:532: referenced as `float64`
	cmplStd/lib/math/Math.ci:527: referenced as `float64`
	cmplStd/lib/math/Math.ci:514: referenced as `float64`
	cmplStd/lib/math/Math.ci:513: referenced as `float64`
	cmplStd/lib/math/Math.ci:512: referenced as `float64`
	cmplStd/lib/math/Math.ci:505: referenced as `float64`
	cmplStd/lib/math/Math.ci:471: referenced as `float64`
	cmplStd/lib/math/Math.ci:468: referenced as `float64`
	cmplStd/lib/math/Math.ci:466: referenced as `float64`
	cmplStd/lib/math/Math.ci:465: referenced as `float64`
	cmplStd/lib/math/Math.ci:465: referenced as `float64`
	cmplStd/lib/math/Math.ci:460: referenced as `float64`
	cmplStd/lib/math/Math.ci:460: referenced as `float64`
	cmplStd/lib/math/Math.ci:457: referenced as `float64`
	cmplStd/lib/math/Math.ci:454: referenced as `float64`
	cmplStd/lib/math/Math.ci:450: referenced as `float64`
	cmplStd/lib/math/Math.ci:439: referenced as `float64`
	cmplStd/lib/math/Math.ci:438: referenced as `float64`
	cmplStd/lib/math/Math.ci:437: referenced as `float64`
	cmplStd/lib/math/Math.ci:436: referenced as `float64`
	cmplStd/lib/math/Math.ci:403: referenced as `float64`
	cmplStd/lib/math/Math.ci:400: referenced as `float64`
	cmplStd/lib/math/Math.ci:398: referenced as `float64`
	cmplStd/lib/math/Math.ci:397: referenced as `float64`
	cmplStd/lib/math/Math.ci:397: referenced as `float64`
	cmplStd/lib/math/Math.ci:388: referenced as `float64`
	cmplStd/lib/math/Math.ci:384: referenced as `float64`
	cmplStd/lib/math/Math.ci:350: referenced as `float64`
	cmplStd/lib/math/Math.ci:350: referenced as `float64`
	cmplStd/lib/math/Math.ci:309: referenced as `float64`
	cmplStd/lib/math/Math.ci:309: referenced as `float64`
	cmplStd/lib/math/Math.ci:293: referenced as `float64`
	cmplStd/lib/math/Math.ci:293: referenced as `float64`
	cmplStd/lib/math/Math.ci:293: referenced as `float64`
	cmplStd/lib/math/Math.ci:288: referenced as `float64`
	cmplStd/lib/math/Math.ci:281: referenced as `float64`
	cmplStd/lib/math/Math.ci:278: referenced as `float64`
	cmplStd/lib/math/Math.ci:278: referenced as `float64`
	cmplStd/lib/math/Math.ci:278: referenced as `float64`
	cmplStd/lib/math/Math.ci:270: referenced as `float64`
	cmplStd/lib/math/Math.ci:269: referenced as `float64`
	cmplStd/lib/math/Math.ci:269: referenced as `float64`
	cmplStd/lib/math/Math.ci:269: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:266: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:263: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:260: referenced as `float64`
	cmplStd/lib/math/Math.ci:257: referenced as `float64`
	cmplStd/lib/math/Math.ci:257: referenced as `float64`
	cmplStd/lib/math/Math.ci:257: referenced as `float64`
	cmplStd/lib/math/Math.ci:257: referenced as `float64`
	cmplStd/lib/math/Math.ci:254: referenced as `float64`
	cmplStd/lib/math/Math.ci:254: referenced as `float64`
	cmplStd/lib/math/Math.ci:254: referenced as `float64`
	cmplStd/lib/math/Math.ci:251: referenced as `float64`
	cmplStd/lib/math/Math.ci:251: referenced as `float64`
	cmplStd/lib/math/Math.ci:246: referenced as `float64`
	cmplStd/lib/math/Math.ci:246: referenced as `float64`
	cmplStd/lib/math/Math.ci:238: referenced as `float64`
	cmplStd/lib/math/Math.ci:237: referenced as `float64`
	cmplStd/lib/math/Math.ci:237: referenced as `float64`
	cmplStd/lib/math/Math.ci:227: referenced as `float64`
	cmplStd/lib/math/Math.ci:223: referenced as `float64`
	cmplStd/lib/math/Math.ci:223: referenced as `float64`
	cmplStd/lib/math/Math.ci:213: referenced as `float64`
	cmplStd/lib/math/Math.ci:209: referenced as `float64`
	cmplStd/lib/math/Math.ci:209: referenced as `float64`
	cmplStd/lib/math/Math.ci:205: referenced as `float64`
	cmplStd/lib/math/Math.ci:205: referenced as `float64`
	cmplStd/lib/math/Math.ci:205: referenced as `float64`
	cmplStd/lib/math/Math.ci:202: referenced as `float64`
	cmplStd/lib/math/Math.ci:195: referenced as `float64`
	cmplStd/lib/math/Math.ci:195: referenced as `float64`
	cmplStd/lib/math/Math.ci:195: referenced as `float64`
	cmplStd/lib/math/Math.ci:189: referenced as `float64`
	cmplStd/lib/math/Math.ci:189: referenced as `float64`
	cmplStd/lib/math/Math.ci:189: referenced as `float64`
	cmplStd/lib/math/Math.ci:170: referenced as `float64`
	cmplStd/lib/math/Math.ci:170: referenced as `float64`
	cmplStd/lib/math/Math.ci:152: referenced as `float64`
	cmplStd/lib/math/Math.ci:152: referenced as `float64`
	cmplStd/lib/math/Math.ci:133: referenced as `float64`
	cmplStd/lib/math/Math.ci:110: referenced as `float64`
	cmplStd/lib/math/Math.ci:110: referenced as `float64`
	cmplStd/lib/math/Math.ci:110: referenced as `float64`
	cmplStd/lib/math/Math.ci:98: referenced as `float64`
	cmplStd/lib/math/Math.ci:76: referenced as `float64`
	cmplStd/lib/math/Math.ci:70: referenced as `float64`
	cmplStd/lib/math/Math.ci:53: referenced as `float64`
	cmplStd/lib/math/Math.ci:52: referenced as `float64`
	cmplStd/lib/math/Math.ci:52: referenced as `float64`
	cmplStd/lib/math/Math.ci:40: referenced as `float64`
	cmplStd/lib/math/Math.ci:34: referenced as `float64`
	cmplStd/lib/math/Math.ci:29: referenced as `float64`
	cmplStd/lib/math/Math.ci:23: referenced as `float64`
	cmplStd/lib/math/Math.ci:5: referenced as `float64`
	cmplStd/lib/math/Bits.ci:37: referenced as `float64`
	cmplStd/lib/math/Bits.ci:35: referenced as `float64`
	cmplStd/lib/math/Bits.ci:30: referenced as `float64`
	cmplStd/lib/math/Bits.ci:30: referenced as `float64`
	cmplStd/lib.ci:11: referenced as `float64`
	internal usages: 24
}
float64.sin(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sin'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(42)
.usages:
	cmplStd/lib/math/Math.ci:903: referenced as `sin`
	cmplStd/lib/math/Math.ci:901: referenced as `sin`
}
float64.cos(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'cos'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(43)
.usages:
	cmplStd/lib/math/Math.ci:933: referenced as `cos`
	cmplStd/lib/math/Math.ci:931: referenced as `cos`
}
float64.tan(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tan'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(44)
.usages:
	cmplStd/lib/math/Math.ci:966: referenced as `tan`
	cmplStd/lib/math/Math.ci:964: referenced as `tan`
}
float64.log(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'log'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(45)
.usages:
	cmplStd/lib/math/Math.ci:400: referenced as `log`
	cmplStd/lib/math/Math.ci:398: referenced as `log`
}
float64.exp(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(46)
.usages:
	cmplStd/lib/math/Math.ci:468: referenced as `exp`
	cmplStd/lib/math/Math.ci:466: referenced as `exp`
}
float64.pow(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'pow'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(47)
.usages:
	cmplStd/lib/math/Math.ci:610: referenced as `pow`
	cmplStd/lib/math/Math.ci:608: referenced as `pow`
}
float64.sqrt(x: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sqrt'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(48)
.usages:
	cmplStd/lib/math/Math.ci:535: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:533: referenced as `sqrt`
}
float64.atan2(x: float64, y: float64): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'atan2'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: '@builtin'
.value: nfc(49)
.usages:
	cmplStd/lib/math/Math.ci:868: referenced as `atan2`
	cmplStd/lib/math/Math.ci:866: referenced as `atan2`
}
float64.ldexp(x: float64, exp: int32): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'ldexp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param exp: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(50)
.usages:
}
float64.frexp(x: float64, exp: int32): float64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'frexp'
.owner: float64
.param .result: float64 (size: 8, cast: inline)
.param x: float64 (size: 8, cast: variable(f64))
.param exp: int32 (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(51)
.usages:
}
float64.parse(value: char[], out: float64): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'parse'
.owner: float64
.param .result: int32 (size: 4, cast: inline)
.param value: char[] (size: 8, cast: const variable(arr))
.param out: float64 (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(52)
.usages:
	cmplStd/lib/text/cstr.ci:121: referenced as `parse`
	cmplStd/lib/text/cstr.ci:119: referenced as `parse`
}
float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'print'
.owner: float64
.field flagMinus: int64 (size: 0, cast: static const i64)
.field flagPlus: int64 (size: 0, cast: static const i64)
.field flagSpace: int64 (size: 0, cast: static const i64)
.field flagHash: int64 (size: 0, cast: static const i64)
.field flagZero: int64 (size: 0, cast: static const i64)
.param .result: int32 (size: 4, cast: inline)
.param out: char[] (size: 8, cast: variable(arr))
.param value: float64 (size: 8, cast: variable(f64))
.param flags: int32 (size: 4, cast: variable(i32))
.param width: int32 (size: 4, cast: variable(i32))
.param precision: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(53)
.usages:
}
float64.print.flagMinus: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagMinus'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 1
}
float64.print.flagPlus: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagPlus'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 2
}
float64.print.flagSpace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagSpace'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 4
}
float64.print.flagHash: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagHash'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 8
}
float64.print.flagZero: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'flagZero'
.owner: float64.print(out: char[], value: float64, flags: int32, width: int32, precision: int32): int32
.doc: '@builtin'
.value: 16
}
pointer: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'pointer'
.field alloc: function (size: 0, cast: static const inline)
.field fill: function (size: 0, cast: static const inline)
.field copy: function (size: 0, cast: static const inline)
.field move: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:284: referenced as `pointer`
	cmplStd/test/lang/useOperator.ci:283: referenced as `pointer`
	cmplStd/test/lang/reflect.ci:16: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:108: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:95: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:90: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:70: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:52: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:51: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:50: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:49: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:48: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:47: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:46: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:45: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:44: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:43: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:42: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:41: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:40: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:39: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:38: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:37: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:36: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:35: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:30: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:23: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:17: referenced as `pointer`
	cmplStd/test/lang/init.reference.ci:9: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:14: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:13: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:12: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:11: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:10: referenced as `pointer`
	cmplStd/test/lang/pointer.ci:2: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:35: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:30: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:16: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:12: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:6: referenced as `pointer`
	cmplStd/test/lang/tryExec.ci:3: referenced as `pointer`
	cmplStd/test/lang/memory.ci:30: referenced as `pointer`
	cmplStd/test/lang/memory.ci:30: referenced as `pointer`
	cmplStd/test/lang/memory.ci:29: referenced as `pointer`
	cmplStd/test/lang/memory.ci:29: referenced as `pointer`
	cmplStd/test/lang/memory.ci:29: referenced as `pointer`
	cmplStd/test/lang/memory.ci:14: referenced as `pointer`
	cmplStd/test/lang/memory.ci:13: referenced as `pointer`
	cmplStd/test/lang/memory.ci:10: referenced as `pointer`
	cmplStd/test/lang/memory.ci:9: referenced as `pointer`
	cmplStd/test/lang/memory.ci:8: referenced as `pointer`
	cmplStd/test/lang/memory.ci:7: referenced as `pointer`
	cmplStd/test/lang/memory.ci:5: referenced as `pointer`
	cmplStd/test/lang/memory.ci:5: referenced as `pointer`
	cmplStd/test/lang/memory.ci:4: referenced as `pointer`
	cmplStd/test/lang/memory.ci:3: referenced as `pointer`
	cmplStd/test/lang/memory.ci:3: referenced as `pointer`
	cmplStd/test/lang/emit.ci:30: referenced as `pointer`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `pointer`
	cmplStd/lib/math/Polynomial.ci:55: referenced as `pointer`
	cmplStd/lib/text/stream/ByteStream.ci:181: referenced as `pointer`
	cmplStd/lib/text/stream/ByteStream.ci:164: referenced as `pointer`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `pointer`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `pointer`
	cmplStd/lib/text/Format.ci:316: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `pointer`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `pointer`
	internal usages: 15
}
pointer.alloc(ptr: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'alloc'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param ptr: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(13)
.usages:
	cmplStd/test/lang/memory.ci:5: referenced as `alloc`
	cmplStd/test/lang/memory.ci:4: referenced as `alloc`
	cmplStd/test/lang/memory.ci:3: referenced as `alloc`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `alloc`
	cmplStd/lib/math/Polynomial.ci:55: referenced as `alloc`
	cmplStd/lib/text/stream/ByteStream.ci:181: referenced as `alloc`
	cmplStd/lib/text/stream/ByteStream.ci:164: referenced as `alloc`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `alloc`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `alloc`
}
pointer.fill(dst: pointer, value: uint8, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'fill'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param value: uint8 (size: 4, cast: variable(u32))
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(14)
.usages:
	cmplStd/test/lang/memory.ci:30: referenced as `fill`
	cmplStd/test/lang/memory.ci:13: referenced as `fill`
}
pointer.copy(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'copy'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(15)
.usages:
	cmplStd/test/lang/memory.ci:14: referenced as `copy`
}
pointer.move(dst: pointer, src: pointer, size: int32): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'move'
.owner: pointer
.param .result: pointer (size: 4, cast: inline)
.param dst: pointer (size: 4, cast: variable(ref))
.param src: pointer (size: 4, cast: variable(ref))
.param size: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(16)
.usages:
	cmplStd/test/lang/memory.ci:29: referenced as `move`
}
variant: typename {
.kind: static const typename(var)
.base: `typename`
.size: 8
.name: 'variant'
.field as: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/reflect.ci:17: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:105: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:96: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:91: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:72: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:71: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:70: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:69: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:68: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:67: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:66: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:65: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:64: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:63: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:62: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:61: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:60: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:59: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:58: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:57: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:56: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:55: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:51: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:31: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:24: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:18: referenced as `variant`
	cmplStd/test/lang/init.reference.ci:10: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:63: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:44: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:44: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:40: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:37: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:34: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:29: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:27: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:22: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:19: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:16: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:13: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:10: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:7: referenced as `variant`
	cmplStd/lib/lang/Debug.ci:4: referenced as `variant`
	internal usages: 2
}
variant.as(var: variant, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'as'
.owner: variant
.param .result: pointer (size: 4, cast: inline)
.param var: variant (size: 8, cast: variable(var))
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(1)
.usages:
}
function: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'function'
.doc: '@builtin'
.usages:
	cmplStd/test/lang/reflect.ci:19: referenced as `function`
	cmplStd/test/lang/init.reference.ci:89: referenced as `function`
	cmplStd/test/lang/init.reference.ci:69: referenced as `function`
	cmplStd/test/lang/init.reference.ci:49: referenced as `function`
	cmplStd/test/lang/init.reference.ci:20: referenced as `function`
	cmplStd/lib.ci:16: referenced as `function`
}
object: typename {
.kind: static const typename(ref)
.base: `typename`
.size: 4
.name: 'object'
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/recUnion.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:22: referenced as `object`
	cmplStd/test/lang/reflect.ci:20: referenced as `object`
	cmplStd/test/lang/init.variable.ci:41: referenced as `object`
	cmplStd/test/lang/init.variable.ci:13: referenced as `object`
	cmplStd/test/lang/init.reference.ci:92: referenced as `object`
	cmplStd/test/lang/init.reference.ci:72: referenced as `object`
	cmplStd/test/lang/init.reference.ci:52: referenced as `object`
	cmplStd/test/lang/init.reference.ci:21: referenced as `object`
	cmplStd/lib/text/stream/TextStream.ci:50: referenced as `object`
	cmplStd/lib/text/stream/ByteStream.ci:2: referenced as `object`
	internal usages: 3
}
object..type: typename {
.kind: const variable(ref)
.base: `typename`
.size: 4
.name: '.type'
.owner: object
}
object.create(type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'create'
.owner: object
.param .result: pointer (size: 4, cast: inline)
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(7)
.usages:
}
object.destroy(this: object): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'destroy'
.owner: object
.param .result: void (size: 0, cast: inline)
.param this: object (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(8)
.usages:
}
object.as(this: object, type: typename): pointer: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'as'
.owner: object
.param .result: pointer (size: 4, cast: inline)
.param this: object (size: 4, cast: variable(ref))
.param type: typename (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(9)
.usages:
}
object.type(this: object): typename: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'type'
.owner: object
.param .result: typename (size: 4, cast: inline)
.param this: object (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(10)
.usages:
}
null: pointer {
.kind: static const inline
.base: `pointer`
.size: 0
.name: 'null'
.doc: '@builtin'
.value: {pointer @0}
.usages:
	cmplStd/test/lang/stmt.if.ci:73: referenced as `null`
	cmplStd/test/lang/useOperator.ci:283: referenced as `null`
	cmplStd/test/lang/init.method.ci:92: referenced as `null`
	cmplStd/test/lang/init.method.ci:86: referenced as `null`
	cmplStd/test/lang/init.reference.ci:21: referenced as `null`
	cmplStd/test/lang/init.reference.ci:20: referenced as `null`
	cmplStd/test/lang/init.reference.ci:19: referenced as `null`
	cmplStd/test/lang/init.reference.ci:18: referenced as `null`
	cmplStd/test/lang/init.reference.ci:17: referenced as `null`
	cmplStd/test/lang/init.reference.ci:16: referenced as `null`
	cmplStd/test/lang/init.reference.ci:3: referenced as `null`
	cmplStd/test/lang/tryExec.ci:45: referenced as `null`
	cmplStd/test/lang/tryExec.ci:44: referenced as `null`
	cmplStd/test/lang/tryExec.ci:43: referenced as `null`
	cmplStd/test/lang/tryExec.ci:42: referenced as `null`
	cmplStd/test/lang/tryExec.ci:41: referenced as `null`
	cmplStd/test/lang/tryExec.ci:40: referenced as `null`
	cmplStd/test/lang/tryExec.ci:40: referenced as `null`
	cmplStd/test/lang/tryExec.ci:39: referenced as `null`
	cmplStd/test/lang/tryExec.ci:31: referenced as `null`
	cmplStd/test/lang/memory.ci:4: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:178: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:164: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:155: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:135: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:106: referenced as `null`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `null`
	cmplStd/lib/math/Easing.ci:110: referenced as `null`
	cmplStd/lib/math/Easing.ci:101: referenced as `null`
	cmplStd/lib/math/Easing.ci:93: referenced as `null`
	cmplStd/lib/math/Easing.ci:85: referenced as `null`
	cmplStd/lib/text/stream/ByteStream.ci:183: referenced as `null`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `null`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `null`
	cmplStd/lib/text/stream/ByteStream.ci:8: referenced as `null`
	cmplStd/lib/text/Format.ci:316: referenced as `null`
	cmplStd/lib/text/Format.ci:88: referenced as `null`
	cmplStd/lib/text/cstr.ci:119: referenced as `null`
	cmplStd/lib/text/cstr.ci:5: referenced as `null`
	cmplStd/lib/math/Math.ci:1003: referenced as `null`
	cmplStd/lib/math/Math.ci:986: referenced as `null`
	cmplStd/lib/math/Math.ci:964: referenced as `null`
	cmplStd/lib/math/Math.ci:944: referenced as `null`
	cmplStd/lib/math/Math.ci:931: referenced as `null`
	cmplStd/lib/math/Math.ci:911: referenced as `null`
	cmplStd/lib/math/Math.ci:901: referenced as `null`
	cmplStd/lib/math/Math.ci:890: referenced as `null`
	cmplStd/lib/math/Math.ci:866: referenced as `null`
	cmplStd/lib/math/Math.ci:688: referenced as `null`
	cmplStd/lib/math/Math.ci:608: referenced as `null`
	cmplStd/lib/math/Math.ci:597: referenced as `null`
	cmplStd/lib/math/Math.ci:533: referenced as `null`
	cmplStd/lib/math/Math.ci:522: referenced as `null`
	cmplStd/lib/math/Math.ci:466: referenced as `null`
	cmplStd/lib/math/Math.ci:445: referenced as `null`
	cmplStd/lib/math/Math.ci:398: referenced as `null`
	cmplStd/lib/math/Bits.ci:490: referenced as `null`
	cmplStd/lib/math/Bits.ci:472: referenced as `null`
	cmplStd/lib/math/Bits.ci:453: referenced as `null`
	cmplStd/lib/math/Bits.ci:434: referenced as `null`
	cmplStd/lib/math/Bits.ci:390: referenced as `null`
	cmplStd/lib/math/Bits.ci:371: referenced as `null`
	cmplStd/lib/math/Bits.ci:281: referenced as `null`
	cmplStd/lib/math/Bits.ci:240: referenced as `null`
	cmplStd/lib/math/Bits.ci:151: referenced as `null`
	cmplStd/lib/math/Bits.ci:111: referenced as `null`
	cmplStd/lib/math/Bits.ci:71: referenced as `null`
	cmplStd/lib/math/Bits.ci:61: referenced as `null`
	cmplStd/lib/math/Bits.ci:51: referenced as `null`
	cmplStd/lib/math/Bits.ci:41: referenced as `null`
	cmplStd/lib/lang/Debug.ci:72: referenced as `null`
	cmplStd/lib/lang/Debug.ci:48: referenced as `null`
}
int: typename {
.kind: static const inline
.base: `typename`
.size: 0
.name: 'int'
.value: int32
}
.cstr: char {
.kind: static const typename(arr)
.base: `char`
.size: 4
.name: '.cstr'
.print: '%s'
}
emit: function {
.kind: static const typename(void)
.base: `function`
.size: 0
.name: 'emit'
.field nop: void (size: 0, cast: static const inline)
.field not: bool (size: 0, cast: static const inline)
.field set: void (size: 0, cast: static const inline)
.field ret: void (size: 0, cast: static const inline)
.field call: void (size: 0, cast: static const inline)
.field p4x: typename (size: 16, cast: static const typename(val))
.field dup: typename (size: 0, cast: static const typename(void))
.field load: typename (size: 0, cast: static const typename(void))
.field store: typename (size: 0, cast: static const typename(void))
.field cmt: typename (size: 0, cast: static const typename(void))
.field and: typename (size: 0, cast: static const typename(void))
.field or: typename (size: 0, cast: static const typename(void))
.field xor: typename (size: 0, cast: static const typename(void))
.field shl: typename (size: 0, cast: static const typename(void))
.field shr: typename (size: 0, cast: static const typename(void))
.field neg: typename (size: 0, cast: static const typename(void))
.field add: typename (size: 0, cast: static const typename(void))
.field sub: typename (size: 0, cast: static const typename(void))
.field mul: typename (size: 0, cast: static const typename(void))
.field div: typename (size: 0, cast: static const typename(void))
.field mod: typename (size: 0, cast: static const typename(void))
.field ceq: typename (size: 0, cast: static const typename(void))
.field clt: typename (size: 0, cast: static const typename(void))
.field cgt: typename (size: 0, cast: static const typename(void))
.field min: typename (size: 0, cast: static const typename(void))
.field max: typename (size: 0, cast: static const typename(void))
.field swz: typename (size: 0, cast: static const typename(void))
.doc: '@builtin'
.usages:
	cmplStd/test/lang/tryExec.ci:36: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `emit`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:30: referenced as `emit`
	cmplStd/test/lang/emit.ci:21: referenced as `emit`
	cmplStd/test/lang/emit.ci:19: referenced as `emit`
	cmplStd/test/lang/emit.ci:16: referenced as `emit`
	cmplStd/test/lang/emit.ci:13: referenced as `emit`
	cmplStd/test/lang/emit.ci:10: referenced as `emit`
	cmplStd/test/lang/emit.ci:4: referenced as `emit`
	cmplStd/test/lang/emit.ci:3: referenced as `emit`
	cmplStd/lib/time/Datetime.ci:32: referenced as `emit`
	cmplStd/lib/time/Datetime.ci:17: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `emit`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:103: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `emit`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `emit`
	cmplStd/lib/math/Complex.ci:44: referenced as `emit`
	cmplStd/lib/math/Complex.ci:37: referenced as `emit`
	cmplStd/lib/math/Complex.ci:30: referenced as `emit`
	cmplStd/lib/math/Complex.ci:27: referenced as `emit`
	cmplStd/lib/math/Bits.ci:37: referenced as `emit`
	cmplStd/lib/math/Bits.ci:35: referenced as `emit`
	cmplStd/lib/math/Bits.ci:33: referenced as `emit`
	cmplStd/lib/math/Bits.ci:30: referenced as `emit`
	cmplStd/lib/math/Bits.ci:28: referenced as `emit`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `emit`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `emit`
}
emit.nop: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'nop'
.owner: emit
.doc: '@builtin'
.value: nop
}
emit.not: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'not'
.owner: emit
.doc: '@builtin'
.value: not.b32
}
emit.set: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'set'
.owner: emit
.doc: '@builtin'
.value: set.x32 sp(1)
}
emit.ret: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'ret'
.owner: emit
.doc: '@builtin'
.value: ret
.usages:
	cmplStd/test/lang/tryExec.ci:36: referenced as `ret`
}
emit.call: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'call'
.owner: emit
.doc: '@builtin'
.value: call
}
emit.p4x: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'p4x'
.owner: emit
.field dp3: float32 (size: 0, cast: static const inline)
.field dp4: float32 (size: 0, cast: static const inline)
.field dph: float32 (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector4f.ci:131: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `p4x`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `p4x`
}
emit.p4x.dp3: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp3'
.owner: emit.p4x
.doc: '@builtin'
.value: dp3.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:123: referenced as `dp3`
}
emit.p4x.dp4: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dp4'
.owner: emit.p4x
.doc: '@builtin'
.value: dp4.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:131: referenced as `dp4`
}
emit.p4x.dph: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'dph'
.owner: emit.p4x
.doc: '@builtin'
.value: dph.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:127: referenced as `dph`
}
emit.dup: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'dup'
.owner: emit
.field x1: int32 (size: 0, cast: static const inline)
.field x2: int64 (size: 0, cast: static const inline)
.field x4: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.dup.x1: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x1'
.owner: emit.dup
.doc: '@builtin'
.value: dup.x32 sp(0)
}
emit.dup.x2: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'x2'
.owner: emit.dup
.doc: '@builtin'
.value: dup.x64 sp(0)
}
emit.dup.x4: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'x4'
.owner: emit.dup
.doc: '@builtin'
.value: dup.x128 sp(0)
}
emit.load: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'load'
.owner: emit
.field z32: int32 (size: 0, cast: static const inline)
.field z64: int64 (size: 0, cast: static const inline)
.field z128: emit.p4x (size: 0, cast: static const inline)
.field i8: int32 (size: 0, cast: static const inline)
.field u8: int32 (size: 0, cast: static const inline)
.field i16: int32 (size: 0, cast: static const inline)
.field u16: int32 (size: 0, cast: static const inline)
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field i128: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/tryExec.ci:36: referenced as `load`
	cmplStd/test/lang/emit.ci:4: referenced as `load`
	cmplStd/test/lang/emit.ci:3: referenced as `load`
}
emit.load.z32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'z32'
.owner: emit.load
.doc: '@builtin'
.value: load.z32
.usages:
	cmplStd/test/lang/tryExec.ci:36: referenced as `z32`
	cmplStd/test/lang/emit.ci:3: referenced as `z32`
}
emit.load.z64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'z64'
.owner: emit.load
.doc: '@builtin'
.value: load.z64
.usages:
	cmplStd/test/lang/emit.ci:4: referenced as `z64`
}
emit.load.z128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'z128'
.owner: emit.load
.doc: '@builtin'
.value: load.z128
}
emit.load.i8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i8'
.owner: emit.load
.doc: '@builtin'
.value: load.is8
}
emit.load.u8: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'u8'
.owner: emit.load
.doc: '@builtin'
.value: load.iu8
}
emit.load.i16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i16'
.owner: emit.load
.doc: '@builtin'
.value: load.is16
}
emit.load.u16: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'u16'
.owner: emit.load
.doc: '@builtin'
.value: load.iu16
}
emit.load.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.load
.doc: '@builtin'
.value: load.i32
}
emit.load.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.load
.doc: '@builtin'
.value: load.i64
}
emit.load.i128: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'i128'
.owner: emit.load
.doc: '@builtin'
.value: load.i128
}
emit.store: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'store'
.owner: emit
.field i8: void (size: 0, cast: static const inline)
.field i16: void (size: 0, cast: static const inline)
.field i32: void (size: 0, cast: static const inline)
.field i64: void (size: 0, cast: static const inline)
.field i128: void (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.store.i8: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i8'
.owner: emit.store
.doc: '@builtin'
.value: store.i8
}
emit.store.i16: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i16'
.owner: emit.store
.doc: '@builtin'
.value: store.i16
}
emit.store.i32: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i32'
.owner: emit.store
.doc: '@builtin'
.value: store.i32
}
emit.store.i64: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i64'
.owner: emit.store
.doc: '@builtin'
.value: store.i64
}
emit.store.i128: void {
.kind: static const inline
.base: `void`
.size: 0
.name: 'i128'
.owner: emit.store
.doc: '@builtin'
.value: store.i128
}
emit.cmt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cmt'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.cmt.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.cmt
.doc: '@builtin'
.value: cmt.b32
}
emit.cmt.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.cmt
.doc: '@builtin'
.value: cmt.b64
}
emit.and: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'and'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.and.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.and
.doc: '@builtin'
.value: and.b32
}
emit.and.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.and
.doc: '@builtin'
.value: and.b64
}
emit.or: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'or'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.or.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.or
.doc: '@builtin'
.value: or.b32
}
emit.or.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.or
.doc: '@builtin'
.value: or.b64
}
emit.xor: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'xor'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.xor.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.xor
.doc: '@builtin'
.value: xor.b32
}
emit.xor.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.xor
.doc: '@builtin'
.value: xor.b64
}
emit.shl: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shl'
.owner: emit
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.shl.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shl
.doc: '@builtin'
.value: shl.b32
}
emit.shl.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shl
.doc: '@builtin'
.value: shl.b64
}
emit.shr: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'shr'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.shr.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.shr
.doc: '@builtin'
.value: sar.b32
}
emit.shr.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.shr
.doc: '@builtin'
.value: sar.b64
}
emit.shr.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.shr
.doc: '@builtin'
.value: shr.b32
}
emit.shr.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.shr
.doc: '@builtin'
.value: shr.b64
}
emit.neg: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'neg'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Complex.ci:27: referenced as `neg`
}
emit.neg.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.neg
.doc: '@builtin'
.value: neg.i32
}
emit.neg.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.neg
.doc: '@builtin'
.value: neg.i64
}
emit.neg.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.neg
.doc: '@builtin'
.value: neg.f32
}
emit.neg.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.neg
.doc: '@builtin'
.value: neg.f64
}
emit.neg.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.neg
.doc: '@builtin'
.value: neg.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:69: referenced as `p4f`
}
emit.neg.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.neg
.doc: '@builtin'
.value: neg.v2d
.usages:
	cmplStd/lib/math/Complex.ci:27: referenced as `p2d`
}
emit.add: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'add'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `add`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `add`
	cmplStd/lib/math/Complex.ci:45: referenced as `add`
	cmplStd/lib/math/Complex.ci:30: referenced as `add`
	cmplStd/lib/lang/Pointer.ci:7: referenced as `add`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `add`
}
emit.add.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.add
.doc: '@builtin'
.value: add.i32
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `i32`
	cmplStd/lib/lang/Pointer.ci:3: referenced as `i32`
}
emit.add.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.add
.doc: '@builtin'
.value: add.i64
.usages:
	cmplStd/lib/lang/Pointer.ci:7: referenced as `i64`
}
emit.add.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.add
.doc: '@builtin'
.value: add.f32
}
emit.add.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.add
.doc: '@builtin'
.value: add.f64
.usages:
	cmplStd/lib/math/Complex.ci:45: referenced as `f64`
}
emit.add.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.add
.doc: '@builtin'
.value: add.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:71: referenced as `p4f`
}
emit.add.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.add
.doc: '@builtin'
.value: add.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:22: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:30: referenced as `p2d`
}
emit.sub: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'sub'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `sub`
	cmplStd/lib/math/Complex.ci:46: referenced as `sub`
	cmplStd/lib/math/Complex.ci:37: referenced as `sub`
}
emit.sub.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.sub
.doc: '@builtin'
.value: sub.i32
}
emit.sub.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.sub
.doc: '@builtin'
.value: sub.i64
}
emit.sub.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.sub
.doc: '@builtin'
.value: sub.f32
}
emit.sub.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.sub
.doc: '@builtin'
.value: sub.f64
.usages:
	cmplStd/lib/math/Complex.ci:46: referenced as `f64`
}
emit.sub.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.sub
.doc: '@builtin'
.value: sub.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:73: referenced as `p4f`
}
emit.sub.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.sub
.doc: '@builtin'
.value: sub.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:25: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:37: referenced as `p2d`
}
emit.mul: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mul'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `mul`
	cmplStd/lib/math/Complex.ci:46: referenced as `mul`
	cmplStd/lib/math/Complex.ci:45: referenced as `mul`
}
emit.mul.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mul
.doc: '@builtin'
.value: mul.i32
}
emit.mul.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mul
.doc: '@builtin'
.value: mul.i64
}
emit.mul.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mul
.doc: '@builtin'
.value: mul.u32
}
emit.mul.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.mul
.doc: '@builtin'
.value: mul.u64
}
emit.mul.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mul
.doc: '@builtin'
.value: mul.f32
}
emit.mul.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mul
.doc: '@builtin'
.value: mul.f64
}
emit.mul.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.mul
.doc: '@builtin'
.value: mul.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:75: referenced as `p4f`
}
emit.mul.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.mul
.doc: '@builtin'
.value: mul.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:28: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:46: referenced as `p2d`
	cmplStd/lib/math/Complex.ci:45: referenced as `p2d`
}
emit.div: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'div'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `div`
	cmplStd/test/lang/emit.ci:13: referenced as `div`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `div`
}
emit.div.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.div
.doc: '@builtin'
.value: div.i32
.usages:
	cmplStd/test/lang/emit.ci:13: referenced as `i32`
}
emit.div.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.div
.doc: '@builtin'
.value: div.i64
}
emit.div.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.div
.doc: '@builtin'
.value: div.u32
}
emit.div.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.div
.doc: '@builtin'
.value: div.u64
}
emit.div.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.div
.doc: '@builtin'
.value: div.f32
.usages:
	cmplStd/test/lang/emit.ci:16: referenced as `f32`
}
emit.div.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.div
.doc: '@builtin'
.value: div.f64
}
emit.div.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.div
.doc: '@builtin'
.value: div.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:77: referenced as `p4f`
}
emit.div.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.div
.doc: '@builtin'
.value: div.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:31: referenced as `p2d`
}
emit.mod: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'mod'
.owner: emit
.field i32: int32 (size: 0, cast: static const inline)
.field i64: int64 (size: 0, cast: static const inline)
.field u32: uint32 (size: 0, cast: static const inline)
.field u64: uint64 (size: 0, cast: static const inline)
.field f32: float32 (size: 0, cast: static const inline)
.field f64: float64 (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.mod.i32: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'i32'
.owner: emit.mod
.doc: '@builtin'
.value: mod.i32
}
emit.mod.i64: int64 {
.kind: static const inline
.base: `int64`
.size: 0
.name: 'i64'
.owner: emit.mod
.doc: '@builtin'
.value: mod.i64
}
emit.mod.u32: uint32 {
.kind: static const inline
.base: `uint32`
.size: 0
.name: 'u32'
.owner: emit.mod
.doc: '@builtin'
.value: mod.u32
}
emit.mod.u64: uint64 {
.kind: static const inline
.base: `uint64`
.size: 0
.name: 'u64'
.owner: emit.mod
.doc: '@builtin'
.value: mod.u64
}
emit.mod.f32: float32 {
.kind: static const inline
.base: `float32`
.size: 0
.name: 'f32'
.owner: emit.mod
.doc: '@builtin'
.value: mod.f32
}
emit.mod.f64: float64 {
.kind: static const inline
.base: `float64`
.size: 0
.name: 'f64'
.owner: emit.mod
.doc: '@builtin'
.value: mod.f64
}
emit.ceq: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'ceq'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.field p4f: bool (size: 0, cast: static const inline)
.field p2d: bool (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `ceq`
}
emit.ceq.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.i32
}
emit.ceq.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.i64
}
emit.ceq.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.f32
}
emit.ceq.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.f64
}
emit.ceq.p4f: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p4f'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.v4f
}
emit.ceq.p2d: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'p2d'
.owner: emit.ceq
.doc: '@builtin'
.value: ceq.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:40: referenced as `p2d`
}
emit.clt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'clt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.clt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.clt
.doc: '@builtin'
.value: clt.i32
}
emit.clt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.clt
.doc: '@builtin'
.value: clt.i64
}
emit.clt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.clt
.doc: '@builtin'
.value: clt.u32
}
emit.clt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.clt
.doc: '@builtin'
.value: clt.u64
}
emit.clt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.clt
.doc: '@builtin'
.value: clt.f32
}
emit.clt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.clt
.doc: '@builtin'
.value: clt.f64
}
emit.cgt: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'cgt'
.owner: emit
.field i32: bool (size: 0, cast: static const inline)
.field i64: bool (size: 0, cast: static const inline)
.field u32: bool (size: 0, cast: static const inline)
.field u64: bool (size: 0, cast: static const inline)
.field f32: bool (size: 0, cast: static const inline)
.field f64: bool (size: 0, cast: static const inline)
.doc: '@builtin'
}
emit.cgt.i32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i32'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.i32
}
emit.cgt.i64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'i64'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.i64
}
emit.cgt.u32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u32'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.u32
}
emit.cgt.u64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'u64'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.u64
}
emit.cgt.f32: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f32'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.f32
}
emit.cgt.f64: bool {
.kind: static const inline
.base: `bool`
.size: 0
.name: 'f64'
.owner: emit.cgt
.doc: '@builtin'
.value: cgt.f64
}
emit.min: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'min'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector4f.ci:103: referenced as `min`
}
emit.min.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.min
.doc: '@builtin'
.value: min.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:103: referenced as `p4f`
}
emit.min.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.min
.doc: '@builtin'
.value: min.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `p2d`
}
emit.max: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'max'
.owner: emit
.field p4f: emit.p4x (size: 0, cast: static const inline)
.field p2d: emit.p4x (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Vector4f.ci:105: referenced as `max`
}
emit.max.p4f: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p4f'
.owner: emit.max
.doc: '@builtin'
.value: max.v4f
.usages:
	cmplStd/lib/math/Vector4f.ci:105: referenced as `p4f`
}
emit.max.p2d: emit.p4x {
.kind: static const inline
.base: `emit.p4x`
.size: 0
.name: 'p2d'
.owner: emit.max
.doc: '@builtin'
.value: max.v2d
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `p2d`
}
emit.swz: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'swz'
.owner: emit
.field x2: int32 (size: 0, cast: static const inline)
.doc: '@builtin'
.usages:
	cmplStd/lib/math/Complex.ci:46: referenced as `swz`
	cmplStd/lib/math/Complex.ci:45: referenced as `swz`
}
emit.swz.x2: int32 {
.kind: static const inline
.base: `int32`
.size: 0
.name: 'x2'
.owner: emit.swz
.doc: '@builtin'
.value: swz.p4x zwxy(4e)
.usages:
	cmplStd/lib/math/Complex.ci:46: referenced as `x2`
	cmplStd/lib/math/Complex.ci:45: referenced as `x2`
}
halt(): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'halt'
.param .result: void (size: 0, cast: inline)
.doc: '@builtin'
.value: nfc(0)
.usages:
}
preferNativeCalls: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'preferNativeCalls'
.doc: '@builtin'
.value: 1
.usages:
	cmplStd/lib/text/cstr.ci:119: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:1003: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:986: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:964: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:944: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:931: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:911: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:901: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:890: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:866: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:688: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:608: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:597: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:533: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:522: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:466: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:445: referenced as `preferNativeCalls`
	cmplStd/lib/math/Math.ci:398: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:490: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:472: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:453: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:434: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:390: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:371: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:281: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:240: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:151: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:111: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:71: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:61: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:51: referenced as `preferNativeCalls`
	cmplStd/lib/math/Bits.ci:41: referenced as `preferNativeCalls`
}
raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'raise'
.field abort: int64 (size: 0, cast: static const i64)
.field error: int64 (size: 0, cast: static const i64)
.field warn: int64 (size: 0, cast: static const i64)
.field info: int64 (size: 0, cast: static const i64)
.field debug: int64 (size: 0, cast: static const i64)
.field verbose: int64 (size: 0, cast: static const i64)
.field noTrace: int64 (size: 0, cast: static const i64)
.field defTrace: int64 (size: 0, cast: static const i64)
.param .result: void (size: 0, cast: inline)
.param file: char[*] (size: 4, cast: const variable(ref))
.param line: int32 (size: 4, cast: variable(i32))
.param level: int32 (size: 4, cast: variable(i32))
.param trace: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: const variable(ref))
.param details: variant[] (size: 8, cast: const variable(arr))
.doc: 'Report messages or raise errors.'
.value: nfc(11)
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:69: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:69: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:69: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:69: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:53: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:53: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:53: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:29: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:29: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:29: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:27: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:27: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:27: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:24: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:24: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:24: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:22: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:22: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:22: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:19: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:19: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:19: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:16: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:16: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:16: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:13: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:13: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:13: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:10: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:10: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:10: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:7: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:7: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:7: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:4: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:4: referenced as `raise`
	cmplStd/lib/lang/Debug.ci:4: referenced as `raise`
	cmplStd/lib.ci:16: referenced as `raise`
}
raise.abort: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'abort'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: -2
.usages:
	cmplStd/lib/lang/Debug.ci:69: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:53: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:29: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:27: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:24: referenced as `abort`
	cmplStd/lib/lang/Debug.ci:22: referenced as `abort`
}
raise.error: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'error'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: -1
.usages:
	cmplStd/lib/lang/Debug.ci:19: referenced as `error`
}
raise.warn: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'warn'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 1
.usages:
	cmplStd/lib/lang/Debug.ci:16: referenced as `warn`
}
raise.info: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'info'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 13
.usages:
	cmplStd/lib/lang/Debug.ci:13: referenced as `info`
}
raise.debug: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'debug'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 14
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:22: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:19: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:15: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:12: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:8: referenced as `debug`
	cmplStd/test/lang/stmt.if.ci:4: referenced as `debug`
	cmplStd/lib/lang/Debug.ci:10: referenced as `debug`
	cmplStd/lib/lang/Debug.ci:7: referenced as `debug`
}
raise.verbose: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'verbose'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 15
.usages:
	cmplStd/lib/lang/Debug.ci:4: referenced as `verbose`
}
raise.noTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'noTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 0
.usages:
	cmplStd/lib/lang/Debug.ci:16: referenced as `noTrace`
	cmplStd/lib/lang/Debug.ci:13: referenced as `noTrace`
	cmplStd/lib/lang/Debug.ci:7: referenced as `noTrace`
	cmplStd/lib/lang/Debug.ci:4: referenced as `noTrace`
}
raise.defTrace: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'defTrace'
.owner: raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
.doc: '@builtin'
.value: 128
.usages:
	cmplStd/lib/lang/Debug.ci:69: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:53: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:29: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:27: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:24: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:22: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:19: referenced as `defTrace`
	cmplStd/lib/lang/Debug.ci:10: referenced as `defTrace`
}
tryExec(args: pointer, action(args: pointer): void): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'tryExec'
.param .result: int32 (size: 4, cast: inline)
.param args: pointer (size: 4, cast: variable(ref))
.param action: function (size: 4, cast: variable(ref))
.doc: '@builtin'
.value: nfc(12)
.usages:
	cmplStd/test/lang/tryExec.ci:45: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:44: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:43: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:42: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:41: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:40: referenced as `tryExec`
	cmplStd/test/lang/tryExec.ci:39: referenced as `tryExec`
}
System: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'System'
.field exit: function (size: 0, cast: static const inline)
.field srand: function (size: 0, cast: static const inline)
.field time: function (size: 0, cast: static const inline)
.field millis: function (size: 0, cast: static const inline)
.field sleep: function (size: 0, cast: static const inline)
.field rand: function (size: 0, cast: static const inline)
.field clock: function (size: 0, cast: static const inline)
.field Platform: typename (size: 0, cast: static const typename(void))
.doc: '@builtin'
.usages:
	cmplStd/lib/time/Timestamp.ci:115: referenced as `System`
}
System.exit(code: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'exit'
.owner: System
.param .result: void (size: 0, cast: inline)
.param code: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(17)
.usages:
}
System.srand(seed: int32): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'srand'
.owner: System
.param .result: void (size: 0, cast: inline)
.param seed: int32 (size: 4, cast: variable(i32))
.doc: '@builtin'
.value: nfc(18)
.usages:
}
System.time(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'time'
.owner: System
.param .result: int32 (size: 4, cast: inline)
.doc: '@builtin'
.value: nfc(19)
.usages:
}
System.millis(): int64: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'millis'
.owner: System
.param .result: int64 (size: 8, cast: inline)
.doc: '@builtin'
.value: nfc(20)
.usages:
	cmplStd/lib/time/Timestamp.ci:115: referenced as `millis`
}
System.sleep(millis: int64): void: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'sleep'
.owner: System
.param .result: void (size: 0, cast: inline)
.param millis: int64 (size: 8, cast: variable(i64))
.doc: '@builtin'
.value: nfc(21)
.usages:
}
System.rand(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'rand'
.owner: System
.field max: int64 (size: 0, cast: static const i64)
.param .result: int32 (size: 4, cast: inline)
.doc: '@builtin'
.value: nfc(22)
.usages:
}
System.rand.max: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'max'
.owner: System.rand(): int32
.doc: '@builtin'
.value: 2147483647
}
System.clock(): int32: function {
.kind: static const inline
.base: `function`
.size: 0
.name: 'clock'
.owner: System
.field perSec: int64 (size: 0, cast: static const i64)
.param .result: int32 (size: 4, cast: inline)
.doc: '@builtin'
.value: nfc(23)
.usages:
}
System.clock.perSec: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'perSec'
.owner: System.clock(): int32
.doc: '@builtin'
.value: 1000000
}
System.Platform: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Platform'
.owner: System
.field WebAssembly: int64 (size: 0, cast: static const i64)
.field Windows: int64 (size: 0, cast: static const i64)
.field MacOS: int64 (size: 0, cast: static const i64)
.field Linux: int64 (size: 0, cast: static const i64)
.field Unix: int64 (size: 0, cast: static const i64)
.doc: '@builtin'
}
System.Platform.WebAssembly: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'WebAssembly'
.owner: System.Platform
.doc: '@builtin'
.value: 0
}
System.Platform.Windows: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Windows'
.owner: System.Platform
.doc: '@builtin'
.value: 0
}
System.Platform.MacOS: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'MacOS'
.owner: System.Platform
.doc: '@builtin'
.value: 0
}
System.Platform.Linux: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Linux'
.owner: System.Platform
.doc: '@builtin'
.value: 64
}
System.Platform.Unix: int64 {
.kind: static const i64
.base: `int64`
.size: 0
.name: 'Unix'
.owner: System.Platform
.doc: '@builtin'
.value: 64
}
true: bool {
.kind: static const val
.base: `bool`
.size: 0
.name: 'true'
.file: 'cmplStd/lib.ci:5'
.doc: 'true'
.value: 1
.usages:
	cmplStd/test/lang/useOperator.ci:7: referenced as `true`
	cmplStd/lib/math/Polynomial.ci:15: referenced as `true`
	cmplStd/lib/text/Format.ci:16: referenced as `true`
	cmplStd/lib/text/cstr.ci:57: referenced as `true`
	cmplStd/lib/text/cstr.ci:42: referenced as `true`
	cmplStd/lib/time/Datetime.ci:112: referenced as `true`
	cmplStd/lib/time/Datetime.ci:107: referenced as `true`
	cmplStd/lib/math/Fixed.ci:113: referenced as `true`
	cmplStd/lib/math/Math.ci:45: referenced as `true`
}
false: bool {
.kind: static const val
.base: `bool`
.size: 0
.name: 'false'
.file: 'cmplStd/lib.ci:6'
.doc: 'false'
.value: 0
.usages:
	cmplStd/test/lang/useOperator.ci:8: referenced as `false`
	cmplStd/lib/math/Polynomial.ci:49: referenced as `false`
	cmplStd/lib/text/cstr.ci:54: referenced as `false`
	cmplStd/lib/text/cstr.ci:50: referenced as `false`
	cmplStd/lib/text/cstr.ci:39: referenced as `false`
	cmplStd/lib/time/Datetime.ci:110: referenced as `false`
	cmplStd/lib/time/Datetime.ci:104: referenced as `false`
	cmplStd/lib/time/Timezone.ci:28: referenced as `false`
	cmplStd/lib/time/Timezone.ci:13: referenced as `false`
	cmplStd/lib/math/Fixed.ci:111: referenced as `false`
	cmplStd/lib/math/Fixed.ci:108: referenced as `false`
	cmplStd/lib/math/Fixed.ci:105: referenced as `false`
	cmplStd/lib/math/Math.ci:42: referenced as `false`
}
byte: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'byte'
.file: 'cmplStd/lib.ci:9'
.value: uint8
.usages:
}
float: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'float'
.file: 'cmplStd/lib.ci:10'
.value: float32
.usages:
}
double: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'double'
.file: 'cmplStd/lib.ci:11'
.value: float64
.usages:
}
sizeof(type: typename): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sizeof'
.file: 'cmplStd/lib.ci:14'
.param .result: int32 (size: 4, cast: i32)
.param type: typename (size: 4, cast: ref)
.doc: 'Returns the size of the given type'
.value: typename.size(type)
.usages:
	cmplStd/test/lang/reflect.ci:20: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:19: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:18: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:17: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:16: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:15: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:14: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:13: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:12: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:11: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:10: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:9: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:8: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:7: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:6: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:5: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:4: referenced as `sizeof`
	cmplStd/test/lang/reflect.ci:3: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:14: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:13: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:12: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:11: referenced as `sizeof`
	cmplStd/test/lang/pointer.ci:10: referenced as `sizeof`
	cmplStd/test/lang/memory.ci:30: referenced as `sizeof`
	cmplStd/test/lang/memory.ci:29: referenced as `sizeof`
	cmplStd/lib/math/Polynomial.ci:62: referenced as `sizeof`
}
verbose(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'verbose'
.file: 'cmplStd/lib/lang/Debug.ci:4'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message at `verbose` logging level'
.value: raise(raise.verbose, raise.noTrace, message, ...details)
.usages:
}
debug(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'debug'
.file: 'cmplStd/lib/lang/Debug.ci:7'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message at `debug` logging level'
.value: raise(raise.debug, raise.noTrace, message, ...details)
.usages:
	cmplStd/test/lang/stmt.for.ci:28: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:21: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:14: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:9: referenced as `debug`
	cmplStd/test/lang/stmt.for.ci:4: referenced as `debug`
	cmplStd/test/lang/init.method.ci:91: referenced as `debug`
	cmplStd/test/lang/init.method.ci:85: referenced as `debug`
	cmplStd/test/lang/memory.ci:33: referenced as `debug`
	cmplStd/test/lang/memory.ci:32: referenced as `debug`
	cmplStd/test/lang/memory.ci:27: referenced as `debug`
	cmplStd/test/lang/memory.ci:26: referenced as `debug`
}
trace(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'trace'
.file: 'cmplStd/lib/lang/Debug.ci:10'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message with stacktrace at `debug` logging level'
.value: raise(raise.debug, raise.defTrace, message, ...details)
.usages:
	cmplStd/test/lang/init.method.ci:58: referenced as `trace`
	cmplStd/test/lang/init.method.ci:48: referenced as `trace`
	cmplStd/test/lang/init.method.ci:41: referenced as `trace`
	cmplStd/test/lang/init.method.ci:11: referenced as `trace`
	cmplStd/lib/time/Datetime.ci:168: referenced as `trace`
	cmplStd/lib/time/Datetime.ci:158: referenced as `trace`
	cmplStd/lib/time/Datetime.ci:152: referenced as `trace`
	cmplStd/lib/time/Timestamp.ci:75: referenced as `trace`
	cmplStd/lib/time/Timestamp.ci:57: referenced as `trace`
	cmplStd/lib/math/Matrix4f.ci:112: referenced as `trace`
}
info(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'info'
.file: 'cmplStd/lib/lang/Debug.ci:13'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message at `info` logging level'
.value: raise(raise.info, raise.noTrace, message, ...details)
.usages:
}
warn(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'warn'
.file: 'cmplStd/lib/lang/Debug.ci:16'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message at `warn` logging level'
.value: raise(raise.warn, raise.noTrace, message, ...details)
.usages:
	cmplStd/lib/time/Timezone.ci:25: referenced as `warn`
}
error(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'error'
.file: 'cmplStd/lib/lang/Debug.ci:19'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message with stacktrace at `error` logging level'
.value: raise(raise.error, raise.defTrace, message, ...details)
.usages:
	cmplStd/test/lang/stmt.if.ci:78: referenced as `error`
	cmplStd/test/lang/stmt.if.ci:74: referenced as `error`
	cmplStd/lib/text/encoding/Utf8.ci:36: referenced as `error`
	cmplStd/lib/text/encoding/Utf8.ci:27: referenced as `error`
	cmplStd/lib/text/encoding/Utf8.ci:19: referenced as `error`
}
abort(message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'cmplStd/lib/lang/Debug.ci:22'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, message, ...details)
.usages:
	cmplStd/test/lang/tryExec.ci:27: referenced as `abort`
	cmplStd/lib/text/Format.ci:483: referenced as `abort`
	cmplStd/lib/time/Timezone.ci:22: referenced as `abort`
	cmplStd/lib/time/Timestamp.ci:95: referenced as `abort`
}
abort(): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'cmplStd/lib/lang/Debug.ci:24'
.param .result: void (size: 0, cast: void)
.doc: 'report message with stacktrace at `abort` logging level and abort execution'
.value: raise(raise.abort, raise.defTrace, "execution aborted!")
.usages:
}
assert(condition: bool, message: char[*], details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'cmplStd/lib/lang/Debug.ci:27'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: const ref)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : raise(raise.abort, raise.defTrace, message, ...details))
.usages:
	cmplStd/lib/math/Polynomial.ci:100: referenced as `assert`
	cmplStd/lib/math/Polynomial.ci:99: referenced as `assert`
	cmplStd/lib/math/Polynomial.ci:90: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:41: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:40: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:39: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:31: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:30: referenced as `assert`
	cmplStd/lib/text/encoding/Utf8.ci:22: referenced as `assert`
	cmplStd/lib/text/encoding/binary/Base64.ci:191: referenced as `assert`
	cmplStd/lib/text/Format.ci:115: referenced as `assert`
	cmplStd/lib/text/Format.ci:114: referenced as `assert`
}
assert(condition: bool, details: variant[]): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'cmplStd/lib/lang/Debug.ci:29'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param details: variant[] (size: 8, cast: const arr)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : raise(raise.abort, raise.defTrace, "assertion failed!", ...details))
.usages:
	cmplStd/test/lang/pointer.ci:14: referenced as `assert`
	cmplStd/test/lang/pointer.ci:13: referenced as `assert`
	cmplStd/test/lang/pointer.ci:12: referenced as `assert`
	cmplStd/test/lang/pointer.ci:11: referenced as `assert`
	cmplStd/test/lang/pointer.ci:10: referenced as `assert`
	cmplStd/test/lang/pointer.ci:9: referenced as `assert`
	cmplStd/lib/math/Polynomial.ci:61: referenced as `assert`
	cmplStd/lib/text/encoding/binary/Base64.ci:42: referenced as `assert`
	cmplStd/lib/text/Format.ci:157: referenced as `assert`
	cmplStd/lib/text/Format.ci:150: referenced as `assert`
	cmplStd/lib/text/Format.ci:143: referenced as `assert`
	cmplStd/lib/text/Format.ci:138: referenced as `assert`
	cmplStd/lib/time/Datetime.ci:180: referenced as `assert`
	cmplStd/lib/time/Datetime.ci:129: referenced as `assert`
}
NotEquals: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'NotEquals'
.file: 'cmplStd/lib/lang/Debug.ci:32'
.field expected: variant (size: 8, cast: const variable(var))
.field returned: variant (size: 8, cast: const variable(var))
.field extras: variant[] (size: 8, cast: const variable(arr))
.doc: 'Record used for debugging purposes, containing expected, returned and an array of extra values'
.usages:
	cmplStd/lib/lang/Debug.ci:64: referenced as `NotEquals`
	cmplStd/lib/lang/Debug.ci:55: referenced as `NotEquals`
	cmplStd/lib/lang/Debug.ci:53: referenced as `NotEquals`
	cmplStd/lib/lang/Debug.ci:44: referenced as `NotEquals`
}
NotEquals.expected: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'expected'
.file: 'cmplStd/lib/lang/Debug.ci:34'
.owner: NotEquals
.doc: 'Value of the expected result'
.usages:
	cmplStd/lib/lang/Debug.ci:65: referenced as `expected`
	cmplStd/lib/lang/Debug.ci:46: referenced as `expected`
}
NotEquals.returned: variant {
.kind: const variable(var)
.base: `variant`
.size: 8
.name: 'returned'
.file: 'cmplStd/lib/lang/Debug.ci:37'
.owner: NotEquals
.doc: 'Value of the actual result'
.usages:
	cmplStd/lib/lang/Debug.ci:66: referenced as `returned`
	cmplStd/lib/lang/Debug.ci:47: referenced as `returned`
}
NotEquals.extras: variant[] {
.kind: const variable(arr)
.base: `variant[]`
.size: 8
.name: 'extras'
.file: 'cmplStd/lib/lang/Debug.ci:40'
.owner: NotEquals
.doc: 'Extra argument to identify what happened'
.usages:
	cmplStd/lib/lang/Debug.ci:67: referenced as `extras`
	cmplStd/lib/lang/Debug.ci:48: referenced as `extras`
}
NotEquals(expected: variant, returned: variant): NotEquals: function {
.kind: static function
.base: `function`
.size: 15
.name: 'NotEquals'
.file: 'cmplStd/lib/lang/Debug.ci:44'
.param .result: NotEquals (size: 24, cast: variable(val))
.param expected: variant (size: 8, cast: const variable(var))
.param returned: variant (size: 8, cast: const variable(var))
.doc: 'Create a not equals record for inspection from expected and returned'
.value: {
	return .result := {
			.result.expected := expected;
			.result.returned := returned;
			.result.extras := (null);
		};
}
.instructions: (15 bytes)
	cmplStd/lib/lang/Debug.ci:45: (15 bytes): return .result := {...};
	cmplStd/lib/lang/Debug.ci:46: (3 bytes): .result.expected := expected;
	<NotEquals>  : mov.x64 sp(5, 3)
	cmplStd/lib/lang/Debug.ci:47: (3 bytes): .result.returned := returned;
	<NotEquals+?>: mov.x64 sp(7, 1)
	cmplStd/lib/lang/Debug.ci:48: (8 bytes): .result.extras := (null);
	<NotEquals+?>: load.z32
	<NotEquals+?>: load.ref <?> ;null
	<NotEquals+?>: set.x64 sp(11)
	<NotEquals+?>: ret
.usages:
}
abort(message: char[*], detail: NotEquals): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abort'
.file: 'cmplStd/lib/lang/Debug.ci:53'
.param .result: void (size: 0, cast: void)
.param message: char[*] (size: 4, cast: const ref)
.param detail: NotEquals (size: 4, cast: const ref)
.doc: 'abort execution displaying the expected and returned values'
.value: raise(raise.abort, raise.defTrace, message, detail)
.usages:
	cmplStd/lib/lang/Debug.ci:55: referenced as `abort`
}
assert(condition: bool, message: char[*], detail: NotEquals): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assert'
.file: 'cmplStd/lib/lang/Debug.ci:55'
.param .result: void (size: 0, cast: void)
.param condition: bool (size: 4, cast: bool)
.param message: char[*] (size: 4, cast: const ref)
.param detail: NotEquals (size: 4, cast: const ref)
.doc: 'report message and abort the execution if the assertion condition fails (is false)'
.value: void(condition ? void(0) : abort(message, detail))
.usages:
}
assertEq(expected: int32, returned: int32, message: char[*]): void: function {
.kind: static function
.base: `function`
.size: 118
.name: 'assertEq'
.file: 'cmplStd/lib/lang/Debug.ci:59'
.param .result: void (size: 0, cast: variable(void))
.param expected: int32 (size: 4, cast: variable(i32))
.param returned: int32 (size: 4, cast: variable(i32))
.param message: char[*] (size: 4, cast: const variable(ref))
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: {
	if (returned == expected) {
		return;
	}
	extras: variant[1] := {
		extras[0] := (message);
	};
	detail: NotEquals := {
		detail.expected := (expected);
		detail.returned := (returned);
		detail.extras := (extras);
	};
	raise(raise.abort, raise.defTrace, "assertion failed", detail);
}
.instructions: (118 bytes)
	cmplStd/lib/lang/Debug.ci:60: (10 bytes): if (returned == expected)
	<assertEq>  : dup.x32 sp(2)
	<assertEq+?>: dup.x32 sp(4)
	<assertEq+?>: ceq.i32
	<assertEq+?>: jz +5
	cmplStd/lib/lang/Debug.ci:61: (1 byte): return;
	<assertEq+?>: ret
	cmplStd/lib/lang/Debug.ci:63: (13 bytes): extras: variant[1] := {...}
	<assertEq+?>: inc.sp(+8)
	cmplStd/lib/lang/Debug.ci:63: (9 bytes): extras[0] := (message);
	<assertEq+?>: load.ref <?>
	<assertEq+?>: dup.x32 sp(4)
	<assertEq+?>: set.x64 sp(2)
	cmplStd/lib/lang/Debug.ci:64: (37 bytes): detail: NotEquals := {...}
	<assertEq+?>: inc.sp(+24)
	cmplStd/lib/lang/Debug.ci:65: (11 bytes): detail.expected := (expected);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+48)
	<assertEq+?>: set.x64 sp(2)
	cmplStd/lib/lang/Debug.ci:66: (11 bytes): detail.returned := (returned);
	<assertEq+?>: load.ref <?> ;int32
	<assertEq+?>: load.sp(+44)
	<assertEq+?>: set.x64 sp(4)
	cmplStd/lib/lang/Debug.ci:67: (11 bytes): detail.extras := (extras);
	<assertEq+?>: load.c32 1
	<assertEq+?>: load.sp(+28)
	<assertEq+?>: set.x64 sp(6)
	cmplStd/lib/lang/Debug.ci:69: (53 bytes): raise(raise.abort, raise.defTrace, "assertion failed", detail);
	<assertEq+?>: load.ref <?> ;NotEquals
	<assertEq+?>: load.sp(+4)
	<assertEq+?>: load.c32 1
	<assertEq+?>: load.sp(+4)
	<assertEq+?>: load.ref <?> ;"cmplStd/lib/lang/Debug.ci"
	<assertEq+?>: load.c32 69
	<assertEq+?>: load.c32 -2
	<assertEq+?>: load.c32 128
	<assertEq+?>: load.ref <?> ;"assertion failed"
	<assertEq+?>: dup.x64 sp(5)
	<assertEq+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<assertEq+?>: inc.sp(-16)
	<assertEq+?>: inc.sp(-32)
	<assertEq+?>: ret
.usages:
	cmplStd/lib/lang/Debug.ci:72: referenced as `assertEq`
}
assertEq(expected: int32, returned: int32): void: function {
.kind: inline
.base: `function`
.size: 0
.name: 'assertEq'
.file: 'cmplStd/lib/lang/Debug.ci:72'
.param .result: void (size: 0, cast: void)
.param expected: int32 (size: 4, cast: i32)
.param returned: int32 (size: 4, cast: i32)
.doc: 'abort execution if the returned value is not equal to the expected value'
.value: assertEq(expected, returned, null)
.usages:
}
inc(ptr: pointer, val: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'inc'
.file: 'cmplStd/lib/lang/Pointer.ci:3'
.param .result: pointer (size: 4, cast: ref)
.param ptr: pointer (size: 4, cast: ref)
.param val: int32 (size: 4, cast: i32)
.doc: 'Returns the pointer incremented with the given value'
.value: pointer(emit(pointer(ptr), int32(val), add.i32))
.usages:
	cmplStd/test/lang/pointer.ci:14: referenced as `inc`
	cmplStd/test/lang/pointer.ci:13: referenced as `inc`
	cmplStd/test/lang/pointer.ci:12: referenced as `inc`
	cmplStd/test/lang/pointer.ci:11: referenced as `inc`
	cmplStd/test/lang/pointer.ci:10: referenced as `inc`
	cmplStd/lib/text/encoding/binary/Base64.ci:33: referenced as `inc`
}
Bits: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Bits'
.file: 'cmplStd/lib/math/Bits.ci:2'
.field signed: function (size: 0, cast: static inline)
.field signed: function (size: 0, cast: static inline)
.field signed: function (size: 0, cast: static inline)
.field signed: function (size: 0, cast: static inline)
.field unsigned: function (size: 0, cast: static inline)
.field unsigned: function (size: 0, cast: static inline)
.field unsigned: function (size: 0, cast: static inline)
.field unsigned: function (size: 0, cast: static inline)
.field fromFloat32: function (size: 0, cast: static inline)
.field fromFloat64: function (size: 0, cast: static inline)
.field asFloat32: function (size: 0, cast: static inline)
.field asFloat64: function (size: 0, cast: static inline)
.field asFloat64: function (size: 0, cast: static inline)
.field zxt32: function (size: 39, cast: static function)
.field sxt32: function (size: 39, cast: static function)
.field zxt64: function (size: 39, cast: static function)
.field sxt64: function (size: 39, cast: static function)
.field swapBytes: function (size: 121, cast: static function)
.field swapBytes: function (size: 68, cast: static function)
.field swapBytes: function (size: 29, cast: static function)
.field swapBytes: function (size: 0, cast: static inline)
.field swapBytes: function (size: 0, cast: static inline)
.field swapBytes: function (size: 0, cast: static inline)
.field scanReverse: function (size: 196, cast: static function)
.field scanReverse: function (size: 0, cast: static inline)
.field scanReverse: function (size: 139, cast: static function)
.field scanReverse: function (size: 0, cast: static inline)
.field scanReverse: function (size: 135, cast: static function)
.field scanReverse: function (size: 0, cast: static inline)
.field scanReverse: function (size: 104, cast: static function)
.field scanReverse: function (size: 0, cast: static inline)
.field scanForward: function (size: 202, cast: static function)
.field scanForward: function (size: 0, cast: static inline)
.field scanForward: function (size: 123, cast: static function)
.field scanForward: function (size: 0, cast: static inline)
.field scanForward: function (size: 127, cast: static function)
.field scanForward: function (size: 0, cast: static inline)
.field scanForward: function (size: 98, cast: static function)
.field scanForward: function (size: 0, cast: static inline)
.field keepMsb: function (size: 92, cast: static function)
.field keepMsb: function (size: 0, cast: static inline)
.field keepMsb: function (size: 64, cast: static function)
.field keepMsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field keepLsb: function (size: 0, cast: static inline)
.field countOnes: function (size: 134, cast: static function)
.field countOnes: function (size: 0, cast: static inline)
.field countOnes: function (size: 85, cast: static function)
.field countOnes: function (size: 0, cast: static inline)
.field swapBits: function (size: 215, cast: static function)
.field swapBits: function (size: 0, cast: static inline)
.field swapBits: function (size: 113, cast: static function)
.field swapBits: function (size: 0, cast: static inline)
.field swapBits: function (size: 117, cast: static function)
.field swapBits: function (size: 0, cast: static inline)
.field swapBits: function (size: 85, cast: static function)
.field swapBits: function (size: 0, cast: static inline)
.field clamp: function (size: 37, cast: static function)
.field clamp: function (size: 27, cast: static function)
.doc: 'Utility functions manipulating binary representations'
.usages:
	cmplStd/test/math/test.Bits.ci:66: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:65: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:63: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:62: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:60: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:59: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:58: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:57: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:56: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:55: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:35: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:34: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:33: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:31: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:30: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:29: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:27: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:26: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:25: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:23: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:22: referenced as `Bits`
	cmplStd/test/math/test.Bits.ci:21: referenced as `Bits`
	cmplStd/lib/math/Fixed.ci:183: referenced as `Bits`
	cmplStd/lib/math/Math.ci:592: referenced as `Bits`
	cmplStd/lib/math/Math.ci:555: referenced as `Bits`
	cmplStd/lib/math/Math.ci:392: referenced as `Bits`
	cmplStd/lib/math/Math.ci:373: referenced as `Bits`
	cmplStd/lib/math/Math.ci:338: referenced as `Bits`
	cmplStd/lib/math/Math.ci:334: referenced as `Bits`
	cmplStd/lib/math/Math.ci:296: referenced as `Bits`
	cmplStd/lib/math/Math.ci:295: referenced as `Bits`
	cmplStd/lib/math/Math.ci:294: referenced as `Bits`
	cmplStd/lib/math/Math.ci:247: referenced as `Bits`
}
Bits.signed(value: uint8): int8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/lib/math/Bits.ci:4'
.owner: Bits
.param .result: int8 (size: 1, cast: i32)
.param value: uint8 (size: 4, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int8(value)
.usages:
}
Bits.signed(value: uint16): int16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/lib/math/Bits.ci:7'
.owner: Bits
.param .result: int16 (size: 2, cast: i32)
.param value: uint16 (size: 4, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int16(value)
.usages:
}
Bits.signed(value: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/lib/math/Bits.ci:10'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param value: uint32 (size: 4, cast: u32)
.doc: 'convert unsigned to signed integer'
.value: int32(value)
.usages:
	cmplStd/lib/math/Math.ci:247: referenced as `signed`
}
Bits.signed(value: uint64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'signed'
.file: 'cmplStd/lib/math/Bits.ci:13'
.owner: Bits
.param .result: int64 (size: 8, cast: i64)
.param value: uint64 (size: 8, cast: u64)
.doc: 'convert unsigned to signed integer'
.value: int64(value)
.usages:
}
Bits.unsigned(value: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/lib/math/Bits.ci:16'
.owner: Bits
.param .result: uint8 (size: 1, cast: u32)
.param value: int8 (size: 4, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint8(value)
.usages:
}
Bits.unsigned(value: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/lib/math/Bits.ci:19'
.owner: Bits
.param .result: uint16 (size: 2, cast: u32)
.param value: int16 (size: 4, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint16(value)
.usages:
}
Bits.unsigned(value: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/lib/math/Bits.ci:22'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param value: int32 (size: 4, cast: i32)
.doc: 'convert signed to unsigned integer'
.value: uint32(value)
.usages:
}
Bits.unsigned(value: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'unsigned'
.file: 'cmplStd/lib/math/Bits.ci:25'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param value: int64 (size: 8, cast: i64)
.doc: 'convert signed to unsigned integer'
.value: uint64(value)
.usages:
}
Bits.fromFloat32(value: float32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'fromFloat32'
.file: 'cmplStd/lib/math/Bits.ci:28'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param value: float32 (size: 4, cast: f32)
.doc: 'return the 32 bit floating point value as an integer'
.value: uint32(emit(float32(value)))
.usages:
}
Bits.fromFloat64(value: float64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'fromFloat64'
.file: 'cmplStd/lib/math/Bits.ci:30'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param value: float64 (size: 8, cast: f64)
.doc: 'return the 64 bit floating point value as an integer'
.value: uint64(emit(float64(value)))
.usages:
	cmplStd/lib/math/Math.ci:555: referenced as `fromFloat64`
	cmplStd/lib/math/Math.ci:373: referenced as `fromFloat64`
	cmplStd/lib/math/Math.ci:334: referenced as `fromFloat64`
	cmplStd/lib/math/Math.ci:295: referenced as `fromFloat64`
	cmplStd/lib/math/Math.ci:294: referenced as `fromFloat64`
}
Bits.asFloat32(value: uint32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asFloat32'
.file: 'cmplStd/lib/math/Bits.ci:33'
.owner: Bits
.param .result: float32 (size: 4, cast: f32)
.param value: uint32 (size: 4, cast: u32)
.doc: 'return the 32 bit integer as a floating point value'
.value: float32(emit(uint32(value)))
.usages:
}
Bits.asFloat64(value: uint64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asFloat64'
.file: 'cmplStd/lib/math/Bits.ci:35'
.owner: Bits
.param .result: float64 (size: 8, cast: f64)
.param value: uint64 (size: 8, cast: u64)
.doc: 'return the 64 bit integer as a floating point value'
.value: float64(emit(uint64(value)))
.usages:
	cmplStd/lib/math/Math.ci:592: referenced as `asFloat64`
	cmplStd/lib/math/Math.ci:392: referenced as `asFloat64`
	cmplStd/lib/math/Math.ci:338: referenced as `asFloat64`
	cmplStd/lib/math/Math.ci:296: referenced as `asFloat64`
}
Bits.asFloat64(hi: uint32, lo: uint32): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asFloat64'
.file: 'cmplStd/lib/math/Bits.ci:37'
.owner: Bits
.param .result: float64 (size: 8, cast: f64)
.param hi: uint32 (size: 4, cast: u32)
.param lo: uint32 (size: 4, cast: u32)
.doc: 'return the two 32 bit integers merged as a floating point value'
.value: float64(emit(uint64(uint64(hi) << 32 | (lo))))
.usages:
}
Bits.zxt32(value: int32, offs: int32, count: int32): int32: function {
.kind: static function
.base: `function`
.size: 39
.name: 'zxt32'
.file: 'cmplStd/lib/math/Bits.ci:40'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.zxt)) != null) {
		return .result := uint32.zxt(value, offs, count);
	}
	return .result := uint32(value << (32 - (offs + count))) >> (32 - count);
}
.instructions: (39 bytes)
	cmplStd/lib/math/Bits.ci:43: (13 bytes): return .result := uint32.zxt(value, offs, count);
	<zxt32>  : dup.x32 sp(3)
	<zxt32+?>: dup.x32 sp(3)
	<zxt32+?>: dup.x32 sp(3)
	<zxt32+?>: nfc(24) ;uint32.zxt(value: int32, offs: int32, count: int32): int32
	<zxt32+?>: set.x32 sp(5)
	<zxt32+?>: ret
	cmplStd/lib/math/Bits.ci:46: (26 bytes): return .result := uint32(value << (32 - (offs + count))) >> (32 - count);
	<zxt32+?>: dup.x32 sp(3)
	<zxt32+?>: load.c32 32
	<zxt32+?>: dup.x32 sp(4)
	<zxt32+?>: dup.x32 sp(4)
	<zxt32+?>: add.i32
	<zxt32+?>: sub.i32
	<zxt32+?>: shl.b32
	<zxt32+?>: load.c32 32
	<zxt32+?>: dup.x32 sp(3)
	<zxt32+?>: sub.i32
	<zxt32+?>: shr.b32
	<zxt32+?>: set.x32 sp(5)
	<zxt32+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:62: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:31: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:30: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:29: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:23: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:22: referenced as `zxt32`
	cmplStd/test/math/test.Bits.ci:21: referenced as `zxt32`
}
Bits.sxt32(value: int32, offs: int32, count: int32): int32: function {
.kind: static function
.base: `function`
.size: 39
.name: 'sxt32'
.file: 'cmplStd/lib/math/Bits.ci:50'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.sxt)) != null) {
		return .result := uint32.sxt(value, offs, count);
	}
	return .result := int32(value << (32 - (offs + count))) >> (32 - count);
}
.instructions: (39 bytes)
	cmplStd/lib/math/Bits.ci:53: (13 bytes): return .result := uint32.sxt(value, offs, count);
	<sxt32>  : dup.x32 sp(3)
	<sxt32+?>: dup.x32 sp(3)
	<sxt32+?>: dup.x32 sp(3)
	<sxt32+?>: nfc(25) ;uint32.sxt(value: int32, offs: int32, count: int32): int32
	<sxt32+?>: set.x32 sp(5)
	<sxt32+?>: ret
	cmplStd/lib/math/Bits.ci:56: (26 bytes): return .result := int32(value << (32 - (offs + count))) >> (32 - count);
	<sxt32+?>: dup.x32 sp(3)
	<sxt32+?>: load.c32 32
	<sxt32+?>: dup.x32 sp(4)
	<sxt32+?>: dup.x32 sp(4)
	<sxt32+?>: add.i32
	<sxt32+?>: sub.i32
	<sxt32+?>: shl.b32
	<sxt32+?>: load.c32 32
	<sxt32+?>: dup.x32 sp(3)
	<sxt32+?>: sub.i32
	<sxt32+?>: sar.b32
	<sxt32+?>: set.x32 sp(5)
	<sxt32+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:63: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:35: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:34: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:33: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:27: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:26: referenced as `sxt32`
	cmplStd/test/math/test.Bits.ci:25: referenced as `sxt32`
}
Bits.zxt64(value: int64, offs: int32, count: int32): int64: function {
.kind: static function
.base: `function`
.size: 39
.name: 'zxt64'
.file: 'cmplStd/lib/math/Bits.ci:60'
.owner: Bits
.param .result: int64 (size: 8, cast: variable(i64))
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.zxt)) != null) {
		return .result := uint64.zxt(value, offs, count);
	}
	return .result := uint64(value << (64 - (offs + count))) >> (64 - count);
}
.instructions: (39 bytes)
	cmplStd/lib/math/Bits.ci:63: (13 bytes): return .result := uint64.zxt(value, offs, count);
	<zxt64>  : dup.x64 sp(3)
	<zxt64+?>: dup.x32 sp(4)
	<zxt64+?>: dup.x32 sp(4)
	<zxt64+?>: nfc(32) ;uint64.zxt(value: int64, offs: int32, count: int32): int64
	<zxt64+?>: set.x64 sp(7)
	<zxt64+?>: ret
	cmplStd/lib/math/Bits.ci:66: (26 bytes): return .result := uint64(value << (64 - (offs + count))) >> (64 - count);
	<zxt64+?>: dup.x64 sp(3)
	<zxt64+?>: load.c32 64
	<zxt64+?>: dup.x32 sp(5)
	<zxt64+?>: dup.x32 sp(5)
	<zxt64+?>: add.i32
	<zxt64+?>: sub.i32
	<zxt64+?>: shl.b64
	<zxt64+?>: load.c32 64
	<zxt64+?>: dup.x32 sp(4)
	<zxt64+?>: sub.i32
	<zxt64+?>: shr.b64
	<zxt64+?>: set.x64 sp(7)
	<zxt64+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:65: referenced as `zxt64`
}
Bits.sxt64(value: int64, offs: int32, count: int32): int64: function {
.kind: static function
.base: `function`
.size: 39
.name: 'sxt64'
.file: 'cmplStd/lib/math/Bits.ci:70'
.owner: Bits
.param .result: int64 (size: 8, cast: variable(i64))
.param value: int64 (size: 8, cast: variable(i64))
.param offs: int32 (size: 4, cast: variable(i32))
.param count: int32 (size: 4, cast: variable(i32))
.doc: '@public'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.sxt)) != null) {
		return .result := uint64.sxt(value, offs, count);
	}
	return .result := int64(value << (64 - (offs + count))) >> (64 - count);
}
.instructions: (39 bytes)
	cmplStd/lib/math/Bits.ci:73: (13 bytes): return .result := uint64.sxt(value, offs, count);
	<sxt64>  : dup.x64 sp(3)
	<sxt64+?>: dup.x32 sp(4)
	<sxt64+?>: dup.x32 sp(4)
	<sxt64+?>: nfc(33) ;uint64.sxt(value: int64, offs: int32, count: int32): int64
	<sxt64+?>: set.x64 sp(7)
	<sxt64+?>: ret
	cmplStd/lib/math/Bits.ci:76: (26 bytes): return .result := int64(value << (64 - (offs + count))) >> (64 - count);
	<sxt64+?>: dup.x64 sp(3)
	<sxt64+?>: load.c32 64
	<sxt64+?>: dup.x32 sp(5)
	<sxt64+?>: dup.x32 sp(5)
	<sxt64+?>: add.i32
	<sxt64+?>: sub.i32
	<sxt64+?>: shl.b64
	<sxt64+?>: load.c32 64
	<sxt64+?>: dup.x32 sp(4)
	<sxt64+?>: sub.i32
	<sxt64+?>: sar.b64
	<sxt64+?>: set.x64 sp(7)
	<sxt64+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:66: referenced as `sxt64`
}
Bits.swapBytes(x: uint64): uint64: function {
.kind: static function
.base: `function`
.size: 121
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:80'
.owner: Bits
.param .result: uint64 (size: 8, cast: variable(u64))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'convert a 64 bit value between Little endian and Big endian'
.value: {
	x := (x & (4294967295)) << 32 | (x & (-4294967296)) >> 32;
	x := (x & (281470681808895)) << 16 | (x & (-281470681808896)) >> 16;
	x := (x & (71777214294589695)) << 8 | (x & (-71777214294589696)) >> 8;
	return .result := x;
}
.instructions: (121 bytes)
	cmplStd/lib/math/Bits.ci:81: (39 bytes): x := (x & (4294967295)) << 32 | (x & (-4294967296)) >> 32;
	<swapBytes>  : dup.x64 sp(1)
	<swapBytes+?>: load.c64 4294967295
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 32
	<swapBytes+?>: shl.b64
	<swapBytes+?>: dup.x64 sp(3)
	<swapBytes+?>: load.c64 -4294967296
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 32
	<swapBytes+?>: shr.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:82: (39 bytes): x := (x & (281470681808895)) << 16 | (x & (-281470681808896)) >> 16;
	<swapBytes+?>: dup.x64 sp(1)
	<swapBytes+?>: load.c64 281470681808895
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 16
	<swapBytes+?>: shl.b64
	<swapBytes+?>: dup.x64 sp(3)
	<swapBytes+?>: load.c64 -281470681808896
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 16
	<swapBytes+?>: shr.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:83: (39 bytes): x := (x & (71777214294589695)) << 8 | (x & (-71777214294589696)) >> 8;
	<swapBytes+?>: dup.x64 sp(1)
	<swapBytes+?>: load.c64 71777214294589695
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 8
	<swapBytes+?>: shl.b64
	<swapBytes+?>: dup.x64 sp(3)
	<swapBytes+?>: load.c64 -71777214294589696
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 8
	<swapBytes+?>: shr.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:84: (4 bytes): return .result := x;
	<swapBytes+?>: mov.x64 sp(3, 1)
	<swapBytes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:100: referenced as `swapBytes`
}
Bits.swapBytes(x: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 68
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:88'
.owner: Bits
.param .result: uint32 (size: 4, cast: variable(u32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'convert a 32 bit value between Little endian and Big endian'
.value: {
	x := (((x & (65535)) << 16) | ((x) & 4294901760) >> 16);
	x := (((x & (16711935)) << 8) | ((x) & 4278255360) >> 8);
	return .result := x;
}
.instructions: (68 bytes)
	cmplStd/lib/math/Bits.ci:89: (30 bytes): x := (((x & (65535)) << 16) | ((x) & 4294901760) >> 16);
	<swapBytes>  : dup.x32 sp(1)
	<swapBytes+?>: b32.and 0xffff
	<swapBytes+?>: b32.shl 0x10
	<swapBytes+?>: u32.2i64
	<swapBytes+?>: dup.x32 sp(3)
	<swapBytes+?>: u32.2i64
	<swapBytes+?>: load.c64 4294901760
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 16
	<swapBytes+?>: sar.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: i64.2i32
	<swapBytes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:90: (34 bytes): x := (((x & (16711935)) << 8) | ((x) & 4278255360) >> 8);
	<swapBytes+?>: dup.x32 sp(1)
	<swapBytes+?>: load.c32 16711935
	<swapBytes+?>: and.b32
	<swapBytes+?>: b32.shl 0x08
	<swapBytes+?>: u32.2i64
	<swapBytes+?>: dup.x32 sp(3)
	<swapBytes+?>: u32.2i64
	<swapBytes+?>: load.c64 4278255360
	<swapBytes+?>: and.b64
	<swapBytes+?>: load.c32 8
	<swapBytes+?>: sar.b64
	<swapBytes+?>: or.b64
	<swapBytes+?>: i64.2i32
	<swapBytes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:91: (4 bytes): return .result := x;
	<swapBytes+?>: mov.x32 sp(2, 1)
	<swapBytes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:103: referenced as `swapBytes`
}
Bits.swapBytes(x: uint16): uint16: function {
.kind: static function
.base: `function`
.size: 29
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:95'
.owner: Bits
.param .result: uint16 (size: 4, cast: variable(u32))
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'convert a 16 bit value between Little endian and Big endian'
.value: {
	return .result := ((x) & 255) << 8 | ((x) & 65280) >> 8;
}
.instructions: (29 bytes)
	cmplStd/lib/math/Bits.ci:96: (29 bytes): return .result := ((x) & 255) << 8 | ((x) & 65280) >> 8;
	<swapBytes>  : load.sp(+4)
	<swapBytes+?>: load.iu16
	<swapBytes+?>: b32.and 0xff
	<swapBytes+?>: b32.shl 0x08
	<swapBytes+?>: load.sp(+8)
	<swapBytes+?>: load.iu16
	<swapBytes+?>: load.c32 65280
	<swapBytes+?>: and.b32
	<swapBytes+?>: b32.sar 0x08
	<swapBytes+?>: or.b32
	<swapBytes+?>: load.sp(+12)
	<swapBytes+?>: store.i16
	<swapBytes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:106: referenced as `swapBytes`
}
Bits.swapBytes(x: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:100'
.owner: Bits
.param .result: int64 (size: 8, cast: i64)
.param x: int64 (size: 8, cast: i64)
.doc: 'convert a 64 bit value between Little endian and Big endian'
.value: int64(swapBytes(uint64(x)))
.usages:
}
Bits.swapBytes(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:103'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.doc: 'convert a 32 bit value between Little endian and Big endian'
.value: int32(swapBytes(uint32(x)))
.usages:
}
Bits.swapBytes(x: int16): int16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBytes'
.file: 'cmplStd/lib/math/Bits.ci:106'
.owner: Bits
.param .result: int16 (size: 2, cast: i32)
.param x: int16 (size: 4, cast: i32)
.doc: 'convert a 16 bit value between Little endian and Big endian'
.value: int16(swapBytes(uint16(x)))
.usages:
}
Bits.scanReverse(x: uint64): int32: function {
.kind: static function
.base: `function`
.size: 196
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:110'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'find the index of the most significant(highest) bit'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.bsr)) != null) {
		return .result := uint64.bsr(x);
	}
	if (x == (0)) {
		return .result := -1;
	}
	result: int32 := 0;
	if (x & (-4294967296)) {
		result := result + 32;
		x := x >> 32;
	}
	if (x & (4294901760)) {
		result := result + 16;
		x := x >> 16;
	}
	if (x & (65280)) {
		result := result + 8;
		x := x >> 8;
	}
	if (x & (240)) {
		result := result + 4;
		x := x >> 4;
	}
	if (x & (12)) {
		result := result + 2;
		x := x >> 2;
	}
	if (x & (2)) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (196 bytes)
	cmplStd/lib/math/Bits.ci:115: (16 bytes): if (x == (0))
	<scanReverse>  : dup.x64 sp(1)
	<scanReverse+?>: load.z64
	<scanReverse+?>: ceq.i64
	<scanReverse+?>: jz +12
	cmplStd/lib/math/Bits.ci:116: (8 bytes): return .result := -1;
	<scanReverse+?>: load.c32 -1
	<scanReverse+?>: set.x32 sp(4)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:119: (1 byte): result: int32 := 0
	<scanReverse+?>: load.z32
	cmplStd/lib/math/Bits.ci:120: (31 bytes): if (x & (-4294967296))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 -4294967296
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:121: (4 bytes): result := result + 32;
	<scanReverse+?>: inc.i32(+32)
	cmplStd/lib/math/Bits.ci:122: (10 bytes): x := x >> 32;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 32
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:124: (31 bytes): if (x & (4294901760))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 4294901760
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:125: (4 bytes): result := result + 16;
	<scanReverse+?>: inc.i32(+16)
	cmplStd/lib/math/Bits.ci:126: (10 bytes): x := x >> 16;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 16
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:128: (31 bytes): if (x & (65280))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 65280
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:129: (4 bytes): result := result + 8;
	<scanReverse+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:130: (10 bytes): x := x >> 8;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 8
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:132: (31 bytes): if (x & (240))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 240
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:133: (4 bytes): result := result + 4;
	<scanReverse+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:134: (10 bytes): x := x >> 4;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 4
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:136: (31 bytes): if (x & (12))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 12
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +18
	cmplStd/lib/math/Bits.ci:137: (4 bytes): result := result + 2;
	<scanReverse+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:138: (10 bytes): x := x >> 2;
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c32 2
	<scanReverse+?>: shr.b64
	<scanReverse+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:140: (21 bytes): if (x & (2))
	<scanReverse+?>: dup.x64 sp(2)
	<scanReverse+?>: load.c64 2
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +8
	cmplStd/lib/math/Bits.ci:141: (4 bytes): result := result + 1;
	<scanReverse+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:143: (3 bytes): return .result := result;
	<scanReverse+?>: set.x32 sp(4)
	<scanReverse+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:147: referenced as `scanReverse`
}
Bits.scanReverse(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:147'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int64 (size: 8, cast: i64)
.doc: 'find the index of the most significant(highest) bit'
.value: scanReverse(uint64(x))
.usages:
}
Bits.scanReverse(x: uint32): int32: function {
.kind: static function
.base: `function`
.size: 139
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:150'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'find the index of the most significant(highest) bit'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.bsr)) != null) {
		return .result := uint32.bsr(x);
	}
	if (x == (0)) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x) & 4294901760) {
		result := result + 16;
		x := x >> 16;
	}
	if (x & (65280)) {
		result := result + 8;
		x := x >> 8;
	}
	if (x & (240)) {
		result := result + 4;
		x := x >> 4;
	}
	if (x & (12)) {
		result := result + 2;
		x := x >> 2;
	}
	if (x & (2)) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (139 bytes)
	cmplStd/lib/math/Bits.ci:153: (9 bytes): return .result := uint32.bsr(x);
	<scanReverse>  : dup.x32 sp(1)
	<scanReverse+?>: nfc(28) ;uint32.bsr(value: int32): int32
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:155: (16 bytes): if (x == (0))
	<scanReverse+?>: dup.x32 sp(1)
	<scanReverse+?>: load.z32
	<scanReverse+?>: ceq.i32
	<scanReverse+?>: jz +12
	cmplStd/lib/math/Bits.ci:156: (8 bytes): return .result := -1;
	<scanReverse+?>: load.c32 -1
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:159: (1 byte): result: int32 := 0
	<scanReverse+?>: load.z32
	cmplStd/lib/math/Bits.ci:160: (28 bytes): if ((x) & 4294901760)
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: u32.2i64
	<scanReverse+?>: load.c64 4294901760
	<scanReverse+?>: and.b64
	<scanReverse+?>: i64.2bool
	<scanReverse+?>: jz +14
	cmplStd/lib/math/Bits.ci:161: (4 bytes): result := result + 16;
	<scanReverse+?>: inc.i32(+16)
	cmplStd/lib/math/Bits.ci:162: (6 bytes): x := x >> 16;
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: b32.shr 0x10
	<scanReverse+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:164: (22 bytes): if (x & (65280))
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: load.c32 65280
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +14
	cmplStd/lib/math/Bits.ci:165: (4 bytes): result := result + 8;
	<scanReverse+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:166: (6 bytes): x := x >> 8;
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: b32.shr 0x08
	<scanReverse+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:168: (22 bytes): if (x & (240))
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: load.c32 240
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +14
	cmplStd/lib/math/Bits.ci:169: (4 bytes): result := result + 4;
	<scanReverse+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:170: (6 bytes): x := x >> 4;
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: b32.shr 0x04
	<scanReverse+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:172: (22 bytes): if (x & (12))
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: load.c32 12
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +14
	cmplStd/lib/math/Bits.ci:173: (4 bytes): result := result + 2;
	<scanReverse+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:174: (6 bytes): x := x >> 2;
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: b32.shr 0x02
	<scanReverse+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:176: (16 bytes): if (x & (2))
	<scanReverse+?>: dup.x32 sp(2)
	<scanReverse+?>: load.c32 2
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +8
	cmplStd/lib/math/Bits.ci:177: (4 bytes): result := result + 1;
	<scanReverse+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:179: (3 bytes): return .result := result;
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:183: referenced as `scanReverse`
}
Bits.scanReverse(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:183'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.doc: 'find the index of the most significant(highest) bit'
.value: scanReverse(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:57: referenced as `scanReverse`
	cmplStd/lib/math/Fixed.ci:183: referenced as `scanReverse`
}
Bits.scanReverse(x: uint16): int32: function {
.kind: static function
.base: `function`
.size: 135
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:186'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'find the index of the most significant(highest) bit'
.value: {
	if ((x) == 0) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x) & 65280) {
		result := result + 8;
		x := ((x) >> 8);
	}
	if ((x) & 240) {
		result := result + 4;
		x := ((x) >> 4);
	}
	if ((x) & 12) {
		result := result + 2;
		x := ((x) >> 2);
	}
	if ((x) & 2) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (135 bytes)
	cmplStd/lib/math/Bits.ci:187: (19 bytes): if ((x) == 0)
	<scanReverse>  : load.sp(+4)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.z32
	<scanReverse+?>: ceq.i32
	<scanReverse+?>: jz +12
	cmplStd/lib/math/Bits.ci:188: (8 bytes): return .result := -1;
	<scanReverse+?>: load.c32 -1
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:191: (1 byte): result: int32 := 0
	<scanReverse+?>: load.z32
	cmplStd/lib/math/Bits.ci:192: (31 bytes): if ((x) & 65280)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.c32 65280
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:193: (4 bytes): result := result + 8;
	<scanReverse+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:194: (12 bytes): x := ((x) >> 8);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: b32.sar 0x08
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i16
	cmplStd/lib/math/Bits.ci:196: (31 bytes): if ((x) & 240)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.c32 240
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:197: (4 bytes): result := result + 4;
	<scanReverse+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:198: (12 bytes): x := ((x) >> 4);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: b32.sar 0x04
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i16
	cmplStd/lib/math/Bits.ci:200: (31 bytes): if ((x) & 12)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.c32 12
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:201: (4 bytes): result := result + 2;
	<scanReverse+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:202: (12 bytes): x := ((x) >> 2);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: b32.sar 0x02
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i16
	cmplStd/lib/math/Bits.ci:204: (19 bytes): if ((x) & 2)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu16
	<scanReverse+?>: load.c32 2
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +8
	cmplStd/lib/math/Bits.ci:205: (4 bytes): result := result + 1;
	<scanReverse+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:207: (3 bytes): return .result := result;
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:211: referenced as `scanReverse`
}
Bits.scanReverse(x: int16): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:211'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int16 (size: 4, cast: i32)
.doc: 'find the index of the most significant(highest) bit'
.value: scanReverse(uint16(x))
.usages:
}
Bits.scanReverse(x: uint8): int32: function {
.kind: static function
.base: `function`
.size: 104
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:214'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint8 (size: 4, cast: variable(u32))
.doc: 'find the index of the most significant(highest) bit'
.value: {
	if ((x) == 0) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x) & 240) {
		result := result + 4;
		x := ((x) >> 4);
	}
	if ((x) & 12) {
		result := result + 2;
		x := ((x) >> 2);
	}
	if ((x) & 2) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (104 bytes)
	cmplStd/lib/math/Bits.ci:215: (19 bytes): if ((x) == 0)
	<scanReverse>  : load.sp(+4)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: load.z32
	<scanReverse+?>: ceq.i32
	<scanReverse+?>: jz +12
	cmplStd/lib/math/Bits.ci:216: (8 bytes): return .result := -1;
	<scanReverse+?>: load.c32 -1
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
	cmplStd/lib/math/Bits.ci:219: (1 byte): result: int32 := 0
	<scanReverse+?>: load.z32
	cmplStd/lib/math/Bits.ci:220: (31 bytes): if ((x) & 240)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: load.c32 240
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:221: (4 bytes): result := result + 4;
	<scanReverse+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:222: (12 bytes): x := ((x) >> 4);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: b32.sar 0x04
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i8
	cmplStd/lib/math/Bits.ci:224: (31 bytes): if ((x) & 12)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: load.c32 12
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +20
	cmplStd/lib/math/Bits.ci:225: (4 bytes): result := result + 2;
	<scanReverse+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:226: (12 bytes): x := ((x) >> 2);
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: b32.sar 0x02
	<scanReverse+?>: load.sp(+12)
	<scanReverse+?>: store.i8
	cmplStd/lib/math/Bits.ci:228: (19 bytes): if ((x) & 2)
	<scanReverse+?>: load.sp(+8)
	<scanReverse+?>: load.iu8
	<scanReverse+?>: load.c32 2
	<scanReverse+?>: and.b32
	<scanReverse+?>: jz +8
	cmplStd/lib/math/Bits.ci:229: (4 bytes): result := result + 1;
	<scanReverse+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:231: (3 bytes): return .result := result;
	<scanReverse+?>: set.x32 sp(3)
	<scanReverse+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:235: referenced as `scanReverse`
}
Bits.scanReverse(x: int8): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanReverse'
.file: 'cmplStd/lib/math/Bits.ci:235'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int8 (size: 4, cast: i32)
.doc: 'find the index of the most significant(highest) bit'
.value: scanReverse(uint8(x))
.usages:
}
Bits.scanForward(x: uint64): int32: function {
.kind: static function
.base: `function`
.size: 202
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:239'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'find the index of the least significant(lowest) bit'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.bsf)) != null) {
		return .result := uint64.bsf(x);
	}
	if (x == (0)) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x & (4294967295)) == (0)) {
		result := result + 32;
		x := x >> 32;
	}
	if ((x & (65535)) == (0)) {
		result := result + 16;
		x := x >> 16;
	}
	if ((x & (255)) == (0)) {
		result := result + 8;
		x := x >> 8;
	}
	if ((x & (15)) == (0)) {
		result := result + 4;
		x := x >> 4;
	}
	if ((x & (3)) == (0)) {
		result := result + 2;
		x := x >> 2;
	}
	if ((x & (1)) == (0)) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (202 bytes)
	cmplStd/lib/math/Bits.ci:245: (16 bytes): if (x == (0))
	<scanForward>  : dup.x64 sp(1)
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +12
	cmplStd/lib/math/Bits.ci:246: (8 bytes): return .result := -1;
	<scanForward+?>: load.c32 -1
	<scanForward+?>: set.x32 sp(4)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:249: (1 byte): result: int32 := 0
	<scanForward+?>: load.z32
	cmplStd/lib/math/Bits.ci:250: (32 bytes): if ((x & (4294967295)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 4294967295
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:251: (4 bytes): result := result + 32;
	<scanForward+?>: inc.i32(+32)
	cmplStd/lib/math/Bits.ci:252: (10 bytes): x := x >> 32;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 32
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:254: (32 bytes): if ((x & (65535)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 65535
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:255: (4 bytes): result := result + 16;
	<scanForward+?>: inc.i32(+16)
	cmplStd/lib/math/Bits.ci:256: (10 bytes): x := x >> 16;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 16
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:258: (32 bytes): if ((x & (255)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 255
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:259: (4 bytes): result := result + 8;
	<scanForward+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:260: (10 bytes): x := x >> 8;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 8
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:262: (32 bytes): if ((x & (15)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 15
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:263: (4 bytes): result := result + 4;
	<scanForward+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:264: (10 bytes): x := x >> 4;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 4
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:266: (32 bytes): if ((x & (3)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 3
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +18
	cmplStd/lib/math/Bits.ci:267: (4 bytes): result := result + 2;
	<scanForward+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:268: (10 bytes): x := x >> 2;
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c32 2
	<scanForward+?>: shr.b64
	<scanForward+?>: set.x64 sp(4)
	cmplStd/lib/math/Bits.ci:270: (22 bytes): if ((x & (1)) == (0))
	<scanForward+?>: dup.x64 sp(2)
	<scanForward+?>: load.c64 1
	<scanForward+?>: and.b64
	<scanForward+?>: load.z64
	<scanForward+?>: ceq.i64
	<scanForward+?>: jz +8
	cmplStd/lib/math/Bits.ci:271: (4 bytes): result := result + 1;
	<scanForward+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:273: (3 bytes): return .result := result;
	<scanForward+?>: set.x32 sp(4)
	<scanForward+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:277: referenced as `scanForward`
}
Bits.scanForward(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:277'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int64 (size: 8, cast: i64)
.doc: 'find the index of the least significant(lowest) bit'
.value: scanForward(uint64(x))
.usages:
}
Bits.scanForward(x: uint32): int32: function {
.kind: static function
.base: `function`
.size: 123
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:280'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'find the index of the least significant(lowest) bit'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.bsf)) != null) {
		return .result := uint32.bsf(x);
	}
	if (x == (0)) {
		return .result := -1;
	}
	result: int32 := 0;
	if ((x & (65535)) == (0)) {
		result := result + 16;
		x := x >> 16;
	}
	if ((x & (255)) == (0)) {
		result := result + 8;
		x := x >> 8;
	}
	if ((x & (15)) == (0)) {
		result := result + 4;
		x := x >> 4;
	}
	if ((x & (3)) == (0)) {
		result := result + 2;
		x := x >> 2;
	}
	if ((x & (1)) == (0)) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (123 bytes)
	cmplStd/lib/math/Bits.ci:283: (9 bytes): return .result := uint32.bsf(x);
	<scanForward>  : dup.x32 sp(1)
	<scanForward+?>: nfc(29) ;uint32.bsf(value: int32): int32
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:286: (16 bytes): if (x == (0))
	<scanForward+?>: dup.x32 sp(1)
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +12
	cmplStd/lib/math/Bits.ci:287: (8 bytes): return .result := -1;
	<scanForward+?>: load.c32 -1
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:290: (1 byte): result: int32 := 0
	<scanForward+?>: load.z32
	cmplStd/lib/math/Bits.ci:291: (20 bytes): if ((x & (65535)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0xffff
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +14
	cmplStd/lib/math/Bits.ci:292: (4 bytes): result := result + 16;
	<scanForward+?>: inc.i32(+16)
	cmplStd/lib/math/Bits.ci:293: (6 bytes): x := x >> 16;
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.shr 0x10
	<scanForward+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:295: (20 bytes): if ((x & (255)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0xff
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +14
	cmplStd/lib/math/Bits.ci:296: (4 bytes): result := result + 8;
	<scanForward+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:297: (6 bytes): x := x >> 8;
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.shr 0x08
	<scanForward+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:299: (20 bytes): if ((x & (15)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0x0f
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +14
	cmplStd/lib/math/Bits.ci:300: (4 bytes): result := result + 4;
	<scanForward+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:301: (6 bytes): x := x >> 4;
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.shr 0x04
	<scanForward+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:303: (20 bytes): if ((x & (3)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0x03
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +14
	cmplStd/lib/math/Bits.ci:304: (4 bytes): result := result + 2;
	<scanForward+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:305: (6 bytes): x := x >> 2;
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.shr 0x02
	<scanForward+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:307: (14 bytes): if ((x & (1)) == (0))
	<scanForward+?>: dup.x32 sp(2)
	<scanForward+?>: b32.and 0x01
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +8
	cmplStd/lib/math/Bits.ci:308: (4 bytes): result := result + 1;
	<scanForward+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:310: (3 bytes): return .result := result;
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:314: referenced as `scanForward`
}
Bits.scanForward(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:314'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.doc: 'find the index of the least significant(lowest) bit'
.value: scanForward(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:58: referenced as `scanForward`
}
Bits.scanForward(x: uint16): int32: function {
.kind: static function
.base: `function`
.size: 127
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:317'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'find the index of the least significant(lowest) bit'
.value: {
	if ((x) == 0) {
		return .result := -1;
	}
	result: int32 := 0;
	if (((x) & 255) == 0) {
		result := result + 8;
		x := ((x) >> 8);
	}
	if (((x) & 15) == 0) {
		result := result + 4;
		x := ((x) >> 4);
	}
	if (((x) & 3) == 0) {
		result := result + 2;
		x := ((x) >> 2);
	}
	if (((x) & 1) == 0) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (127 bytes)
	cmplStd/lib/math/Bits.ci:318: (19 bytes): if ((x) == 0)
	<scanForward>  : load.sp(+4)
	<scanForward+?>: load.iu16
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +12
	cmplStd/lib/math/Bits.ci:319: (8 bytes): return .result := -1;
	<scanForward+?>: load.c32 -1
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:322: (1 byte): result: int32 := 0
	<scanForward+?>: load.z32
	cmplStd/lib/math/Bits.ci:323: (29 bytes): if (((x) & 255) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.and 0xff
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:324: (4 bytes): result := result + 8;
	<scanForward+?>: inc.i32(+8)
	cmplStd/lib/math/Bits.ci:325: (12 bytes): x := ((x) >> 8);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.sar 0x08
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i16
	cmplStd/lib/math/Bits.ci:327: (29 bytes): if (((x) & 15) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.and 0x0f
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:328: (4 bytes): result := result + 4;
	<scanForward+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:329: (12 bytes): x := ((x) >> 4);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.sar 0x04
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i16
	cmplStd/lib/math/Bits.ci:331: (29 bytes): if (((x) & 3) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.and 0x03
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:332: (4 bytes): result := result + 2;
	<scanForward+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:333: (12 bytes): x := ((x) >> 2);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.sar 0x02
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i16
	cmplStd/lib/math/Bits.ci:335: (17 bytes): if (((x) & 1) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu16
	<scanForward+?>: b32.and 0x01
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +8
	cmplStd/lib/math/Bits.ci:336: (4 bytes): result := result + 1;
	<scanForward+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:338: (3 bytes): return .result := result;
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:342: referenced as `scanForward`
}
Bits.scanForward(x: int16): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:342'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int16 (size: 4, cast: i32)
.doc: 'find the index of the least significant(lowest) bit'
.value: scanForward(uint16(x))
.usages:
}
Bits.scanForward(x: uint8): int32: function {
.kind: static function
.base: `function`
.size: 98
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:345'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint8 (size: 4, cast: variable(u32))
.doc: 'find the index of the least significant(lowest) bit'
.value: {
	if ((x) == 0) {
		return .result := -1;
	}
	result: int32 := 0;
	if (((x) & 15) == 0) {
		result := result + 4;
		x := ((x) >> 4);
	}
	if (((x) & 3) == 0) {
		result := result + 2;
		x := ((x) >> 2);
	}
	if (((x) & 1) == 0) {
		result := result + 1;
	}
	return .result := result;
}
.instructions: (98 bytes)
	cmplStd/lib/math/Bits.ci:346: (19 bytes): if ((x) == 0)
	<scanForward>  : load.sp(+4)
	<scanForward+?>: load.iu8
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +12
	cmplStd/lib/math/Bits.ci:347: (8 bytes): return .result := -1;
	<scanForward+?>: load.c32 -1
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
	cmplStd/lib/math/Bits.ci:350: (1 byte): result: int32 := 0
	<scanForward+?>: load.z32
	cmplStd/lib/math/Bits.ci:351: (29 bytes): if (((x) & 15) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.and 0x0f
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:352: (4 bytes): result := result + 4;
	<scanForward+?>: inc.i32(+4)
	cmplStd/lib/math/Bits.ci:353: (12 bytes): x := ((x) >> 4);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.sar 0x04
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i8
	cmplStd/lib/math/Bits.ci:355: (29 bytes): if (((x) & 3) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.and 0x03
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +20
	cmplStd/lib/math/Bits.ci:356: (4 bytes): result := result + 2;
	<scanForward+?>: inc.i32(+2)
	cmplStd/lib/math/Bits.ci:357: (12 bytes): x := ((x) >> 2);
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.sar 0x02
	<scanForward+?>: load.sp(+12)
	<scanForward+?>: store.i8
	cmplStd/lib/math/Bits.ci:359: (17 bytes): if (((x) & 1) == 0)
	<scanForward+?>: load.sp(+8)
	<scanForward+?>: load.iu8
	<scanForward+?>: b32.and 0x01
	<scanForward+?>: load.z32
	<scanForward+?>: ceq.i32
	<scanForward+?>: jz +8
	cmplStd/lib/math/Bits.ci:360: (4 bytes): result := result + 1;
	<scanForward+?>: inc.i32(+1)
	cmplStd/lib/math/Bits.ci:362: (3 bytes): return .result := result;
	<scanForward+?>: set.x32 sp(3)
	<scanForward+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:366: referenced as `scanForward`
}
Bits.scanForward(x: int8): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'scanForward'
.file: 'cmplStd/lib/math/Bits.ci:366'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int8 (size: 4, cast: i32)
.doc: 'find the index of the least significant(lowest) bit'
.value: scanForward(uint8(x))
.usages:
}
Bits.keepMsb(x: uint64): uint64: function {
.kind: static function
.base: `function`
.size: 92
.name: 'keepMsb'
.file: 'cmplStd/lib/math/Bits.ci:370'
.owner: Bits
.param .result: uint64 (size: 8, cast: variable(u64))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'keep the highest bit set'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.hib)) != null) {
		return .result := uint64.hib(x);
	}
	x := x | x >> 1;
	x := x | x >> 2;
	x := x | x >> 4;
	x := x | x >> 8;
	x := x | x >> 16;
	x := x | x >> 32;
	return .result := x - (x >> 1);
}
.instructions: (92 bytes)
	cmplStd/lib/math/Bits.ci:376: (13 bytes): x := x | x >> 1;
	<keepMsb>  : dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 1
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:377: (13 bytes): x := x | x >> 2;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 2
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:378: (13 bytes): x := x | x >> 4;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 4
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:379: (13 bytes): x := x | x >> 8;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 8
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:380: (13 bytes): x := x | x >> 16;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 16
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:381: (13 bytes): x := x | x >> 32;
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 32
	<keepMsb+?>: shr.b64
	<keepMsb+?>: or.b64
	<keepMsb+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:382: (14 bytes): return .result := x - (x >> 1);
	<keepMsb+?>: dup.x64 sp(1)
	<keepMsb+?>: dup.x64 sp(3)
	<keepMsb+?>: load.c32 1
	<keepMsb+?>: shr.b64
	<keepMsb+?>: sub.i64
	<keepMsb+?>: set.x64 sp(5)
	<keepMsb+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:386: referenced as `keepMsb`
}
Bits.keepMsb(x: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepMsb'
.file: 'cmplStd/lib/math/Bits.ci:386'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param x: int64 (size: 8, cast: i64)
.doc: 'keep the highest bit set'
.value: keepMsb(uint64(x))
.usages:
}
Bits.keepMsb(x: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 64
.name: 'keepMsb'
.file: 'cmplStd/lib/math/Bits.ci:389'
.owner: Bits
.param .result: uint32 (size: 4, cast: variable(u32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'keep the highest bit set'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.hib)) != null) {
		return .result := uint32.hib(x);
	}
	x := x | x >> 1;
	x := x | x >> 2;
	x := x | x >> 4;
	x := x | x >> 8;
	x := x | x >> 16;
	return .result := x - (x >> 1);
}
.instructions: (64 bytes)
	cmplStd/lib/math/Bits.ci:392: (9 bytes): return .result := uint32.hib(x);
	<keepMsb>  : dup.x32 sp(1)
	<keepMsb+?>: nfc(30) ;uint32.hib(value: int32): int32
	<keepMsb+?>: set.x32 sp(3)
	<keepMsb+?>: ret
	cmplStd/lib/math/Bits.ci:395: (9 bytes): x := x | x >> 1;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x01
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:396: (9 bytes): x := x | x >> 2;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x02
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:397: (9 bytes): x := x | x >> 4;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x04
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:398: (9 bytes): x := x | x >> 8;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x08
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:399: (9 bytes): x := x | x >> 16;
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x10
	<keepMsb+?>: or.b32
	<keepMsb+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:400: (10 bytes): return .result := x - (x >> 1);
	<keepMsb+?>: dup.x32 sp(1)
	<keepMsb+?>: dup.x32 sp(2)
	<keepMsb+?>: b32.shr 0x01
	<keepMsb+?>: sub.i32
	<keepMsb+?>: set.x32 sp(3)
	<keepMsb+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:404: referenced as `keepMsb`
}
Bits.keepMsb(x: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepMsb'
.file: 'cmplStd/lib/math/Bits.ci:404'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param x: int32 (size: 4, cast: i32)
.doc: 'keep the highest bit set'
.value: keepMsb(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:59: referenced as `keepMsb`
}
Bits.keepLsb(x: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:408'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'keep the lowest bit set'
.value: uint64(x & -x)
.usages:
	cmplStd/lib/math/Bits.ci:411: referenced as `keepLsb`
}
Bits.keepLsb(x: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:411'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param x: int64 (size: 8, cast: i64)
.doc: 'keep the lowest bit set'
.value: keepLsb(uint64(x))
.usages:
}
Bits.keepLsb(x: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:414'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'keep the lowest bit set'
.value: uint32(x & -x)
.usages:
	cmplStd/lib/math/Bits.ci:417: referenced as `keepLsb`
}
Bits.keepLsb(x: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:417'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param x: int32 (size: 4, cast: i32)
.doc: 'keep the lowest bit set'
.value: keepLsb(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:60: referenced as `keepLsb`
}
Bits.keepLsb(x: uint16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:420'
.owner: Bits
.param .result: uint16 (size: 2, cast: u32)
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'keep the lowest bit set'
.value: uint16(x & -x)
.usages:
	cmplStd/lib/math/Bits.ci:423: referenced as `keepLsb`
}
Bits.keepLsb(x: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:423'
.owner: Bits
.param .result: uint16 (size: 2, cast: u32)
.param x: int16 (size: 4, cast: i32)
.doc: 'keep the lowest bit set'
.value: keepLsb(uint16(x))
.usages:
}
Bits.keepLsb(x: uint8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:426'
.owner: Bits
.param .result: uint8 (size: 1, cast: u32)
.param x: uint8 (size: 4, cast: variable(u32))
.doc: 'keep the lowest bit set'
.value: uint8(x & -x)
.usages:
	cmplStd/lib/math/Bits.ci:429: referenced as `keepLsb`
}
Bits.keepLsb(x: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'keepLsb'
.file: 'cmplStd/lib/math/Bits.ci:429'
.owner: Bits
.param .result: uint8 (size: 1, cast: u32)
.param x: int8 (size: 4, cast: i32)
.doc: 'keep the lowest bit set'
.value: keepLsb(uint8(x))
.usages:
}
Bits.countOnes(x: uint64): int32: function {
.kind: static function
.base: `function`
.size: 134
.name: 'countOnes'
.file: 'cmplStd/lib/math/Bits.ci:433'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'count bits set to one'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.pop)) != null) {
		return .result := uint64.pop(x);
	}
	x := x - ((x >> 1) & (6148914691236517205));
	x := (x & (3689348814741910323)) + ((x >> 2) & (3689348814741910323));
	x := (x + (x >> 4)) & (1085102592571150095);
	x := x + (x >> 8);
	x := x + (x >> 16);
	x := x + (x >> 32);
	return .result := x & (63);
}
.instructions: (134 bytes)
	cmplStd/lib/math/Bits.ci:439: (23 bytes): x := x - ((x >> 1) & (6148914691236517205));
	<countOnes>  : dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 1
	<countOnes+?>: shr.b64
	<countOnes+?>: load.c64 6148914691236517205
	<countOnes+?>: and.b64
	<countOnes+?>: sub.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:440: (33 bytes): x := (x & (3689348814741910323)) + ((x >> 2) & (3689348814741910323));
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: load.c64 3689348814741910323
	<countOnes+?>: and.b64
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 2
	<countOnes+?>: shr.b64
	<countOnes+?>: load.c64 3689348814741910323
	<countOnes+?>: and.b64
	<countOnes+?>: add.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:441: (23 bytes): x := (x + (x >> 4)) & (1085102592571150095);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 4
	<countOnes+?>: shr.b64
	<countOnes+?>: add.i64
	<countOnes+?>: load.c64 1085102592571150095
	<countOnes+?>: and.b64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:442: (13 bytes): x := x + (x >> 8);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 8
	<countOnes+?>: shr.b64
	<countOnes+?>: add.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:443: (13 bytes): x := x + (x >> 16);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 16
	<countOnes+?>: shr.b64
	<countOnes+?>: add.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:444: (13 bytes): x := x + (x >> 32);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: dup.x64 sp(3)
	<countOnes+?>: load.c32 32
	<countOnes+?>: shr.b64
	<countOnes+?>: add.i64
	<countOnes+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:445: (16 bytes): return .result := x & (63);
	<countOnes+?>: dup.x64 sp(1)
	<countOnes+?>: load.c64 63
	<countOnes+?>: and.b64
	<countOnes+?>: i64.2i32
	<countOnes+?>: set.x32 sp(4)
	<countOnes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:449: referenced as `countOnes`
}
Bits.countOnes(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'countOnes'
.file: 'cmplStd/lib/math/Bits.ci:449'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int64 (size: 8, cast: i64)
.doc: 'count bits set to one'
.value: countOnes(uint64(x))
.usages:
}
Bits.countOnes(x: uint32): int32: function {
.kind: static function
.base: `function`
.size: 85
.name: 'countOnes'
.file: 'cmplStd/lib/math/Bits.ci:452'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'count bits set to one'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.pop)) != null) {
		return .result := uint32.pop(x);
	}
	x := x - ((x >> 1) & (1431655765));
	x := (x & (858993459)) + ((x >> 2) & (858993459));
	x := (x + (x >> 4)) & (252645135);
	x := x + (x >> 8);
	x := x + (x >> 16);
	return .result := x & (63);
}
.instructions: (85 bytes)
	cmplStd/lib/math/Bits.ci:455: (9 bytes): return .result := uint32.pop(x);
	<countOnes>  : dup.x32 sp(1)
	<countOnes+?>: nfc(26) ;uint32.pop(value: int32): int32
	<countOnes+?>: set.x32 sp(3)
	<countOnes+?>: ret
	cmplStd/lib/math/Bits.ci:458: (15 bytes): x := x - ((x >> 1) & (1431655765));
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x01
	<countOnes+?>: load.c32 1431655765
	<countOnes+?>: and.b32
	<countOnes+?>: sub.i32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:459: (21 bytes): x := (x & (858993459)) + ((x >> 2) & (858993459));
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: load.c32 858993459
	<countOnes+?>: and.b32
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x02
	<countOnes+?>: load.c32 858993459
	<countOnes+?>: and.b32
	<countOnes+?>: add.i32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:460: (15 bytes): x := (x + (x >> 4)) & (252645135);
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x04
	<countOnes+?>: add.i32
	<countOnes+?>: load.c32 252645135
	<countOnes+?>: and.b32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:461: (9 bytes): x := x + (x >> 8);
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x08
	<countOnes+?>: add.i32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:462: (9 bytes): x := x + (x >> 16);
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: dup.x32 sp(2)
	<countOnes+?>: b32.shr 0x10
	<countOnes+?>: add.i32
	<countOnes+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:463: (7 bytes): return .result := x & (63);
	<countOnes+?>: dup.x32 sp(1)
	<countOnes+?>: b32.and 0x3f
	<countOnes+?>: set.x32 sp(3)
	<countOnes+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:467: referenced as `countOnes`
}
Bits.countOnes(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'countOnes'
.file: 'cmplStd/lib/math/Bits.ci:467'
.owner: Bits
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.doc: 'count bits set to one'
.value: countOnes(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:55: referenced as `countOnes`
}
Bits.swapBits(x: uint64): uint64: function {
.kind: static function
.base: `function`
.size: 215
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:471'
.owner: Bits
.param .result: uint64 (size: 8, cast: variable(u64))
.param x: uint64 (size: 8, cast: variable(u64))
.doc: 'reverse all the bits'
.value: {
	static if ((preferNativeCalls) && (typename(uint64.swap)) != null) {
		return .result := uint64.swap(x);
	}
	x := ((x >> 1) & (6148914691236517205)) | ((x & (6148914691236517205)) << 1);
	x := ((x >> 2) & (3689348814741910323)) | ((x & (3689348814741910323)) << 2);
	x := ((x >> 4) & (1085102592571150095)) | ((x & (1085102592571150095)) << 4);
	x := ((x >> 8) & (71777214294589695)) | ((x & (71777214294589695)) << 8);
	x := ((x >> 16) & (281470681808895)) | ((x & (281470681808895)) << 16);
	return .result := (x >> 32) | (x << 32);
}
.instructions: (215 bytes)
	cmplStd/lib/math/Bits.ci:477: (39 bytes): x := ((x >> 1) & (6148914691236517205)) | ((x & (6148914691236517205)) << 1);
	<swapBits>  : dup.x64 sp(1)
	<swapBits+?>: load.c32 1
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 6148914691236517205
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 6148914691236517205
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 1
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:478: (39 bytes): x := ((x >> 2) & (3689348814741910323)) | ((x & (3689348814741910323)) << 2);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 2
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 3689348814741910323
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 3689348814741910323
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 2
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:479: (39 bytes): x := ((x >> 4) & (1085102592571150095)) | ((x & (1085102592571150095)) << 4);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 4
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 1085102592571150095
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 1085102592571150095
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 4
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:480: (39 bytes): x := ((x >> 8) & (71777214294589695)) | ((x & (71777214294589695)) << 8);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 8
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 71777214294589695
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 71777214294589695
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 8
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:481: (39 bytes): x := ((x >> 16) & (281470681808895)) | ((x & (281470681808895)) << 16);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 16
	<swapBits+?>: shr.b64
	<swapBits+?>: load.c64 281470681808895
	<swapBits+?>: and.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c64 281470681808895
	<swapBits+?>: and.b64
	<swapBits+?>: load.c32 16
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(3)
	cmplStd/lib/math/Bits.ci:482: (20 bytes): return .result := (x >> 32) | (x << 32);
	<swapBits+?>: dup.x64 sp(1)
	<swapBits+?>: load.c32 32
	<swapBits+?>: shr.b64
	<swapBits+?>: dup.x64 sp(3)
	<swapBits+?>: load.c32 32
	<swapBits+?>: shl.b64
	<swapBits+?>: or.b64
	<swapBits+?>: set.x64 sp(5)
	<swapBits+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:486: referenced as `swapBits`
}
Bits.swapBits(x: int64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:486'
.owner: Bits
.param .result: uint64 (size: 8, cast: u64)
.param x: int64 (size: 8, cast: i64)
.doc: 'reverse all the bits'
.value: swapBits(uint64(x))
.usages:
}
Bits.swapBits(x: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 113
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:489'
.owner: Bits
.param .result: uint32 (size: 4, cast: variable(u32))
.param x: uint32 (size: 4, cast: variable(u32))
.doc: 'reverse all the bits'
.value: {
	static if ((preferNativeCalls) && (typename(uint32.swap)) != null) {
		return .result := uint32.swap(x);
	}
	x := ((x >> 1) & (1431655765)) | ((x & (1431655765)) << 1);
	x := ((x >> 2) & (858993459)) | ((x & (858993459)) << 2);
	x := ((x >> 4) & (252645135)) | ((x & (252645135)) << 4);
	x := ((x >> 8) & (16711935)) | ((x & (16711935)) << 8);
	return .result := (x >> 16) | (x << 16);
}
.instructions: (113 bytes)
	cmplStd/lib/math/Bits.ci:492: (9 bytes): return .result := uint32.swap(x);
	<swapBits>  : dup.x32 sp(1)
	<swapBits+?>: nfc(27) ;uint32.swap(value: int32): int32
	<swapBits+?>: set.x32 sp(3)
	<swapBits+?>: ret
	cmplStd/lib/math/Bits.ci:495: (23 bytes): x := ((x >> 1) & (1431655765)) | ((x & (1431655765)) << 1);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x01
	<swapBits+?>: load.c32 1431655765
	<swapBits+?>: and.b32
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: load.c32 1431655765
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x01
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:496: (23 bytes): x := ((x >> 2) & (858993459)) | ((x & (858993459)) << 2);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x02
	<swapBits+?>: load.c32 858993459
	<swapBits+?>: and.b32
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: load.c32 858993459
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x02
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:497: (23 bytes): x := ((x >> 4) & (252645135)) | ((x & (252645135)) << 4);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x04
	<swapBits+?>: load.c32 252645135
	<swapBits+?>: and.b32
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: load.c32 252645135
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x04
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:498: (23 bytes): x := ((x >> 8) & (16711935)) | ((x & (16711935)) << 8);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x08
	<swapBits+?>: load.c32 16711935
	<swapBits+?>: and.b32
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: load.c32 16711935
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x08
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(2)
	cmplStd/lib/math/Bits.ci:499: (12 bytes): return .result := (x >> 16) | (x << 16);
	<swapBits+?>: dup.x32 sp(1)
	<swapBits+?>: b32.shr 0x10
	<swapBits+?>: dup.x32 sp(2)
	<swapBits+?>: b32.shl 0x10
	<swapBits+?>: or.b32
	<swapBits+?>: set.x32 sp(3)
	<swapBits+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:503: referenced as `swapBits`
}
Bits.swapBits(x: int32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:503'
.owner: Bits
.param .result: uint32 (size: 4, cast: u32)
.param x: int32 (size: 4, cast: i32)
.doc: 'reverse all the bits'
.value: swapBits(uint32(x))
.usages:
	cmplStd/test/math/test.Bits.ci:56: referenced as `swapBits`
}
Bits.swapBits(x: uint16): uint16: function {
.kind: static function
.base: `function`
.size: 117
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:506'
.owner: Bits
.param .result: uint16 (size: 4, cast: variable(u32))
.param x: uint16 (size: 4, cast: variable(u32))
.doc: 'reverse all the bits'
.value: {
	x := ((((x) >> 1) & 21845) | (((x) & 21845) << 1));
	x := ((((x) >> 2) & 13107) | (((x) & 13107) << 2));
	x := ((((x) >> 4) & 3855) | (((x) & 3855) << 4));
	return .result := ((x) >> 8) | ((x) << 8);
}
.instructions: (117 bytes)
	cmplStd/lib/math/Bits.ci:507: (32 bytes): x := ((((x) >> 1) & 21845) | (((x) & 21845) << 1));
	<swapBits>  : load.sp(+4)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.sar 0x01
	<swapBits+?>: load.c32 21845
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu16
	<swapBits+?>: load.c32 21845
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x01
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i16
	cmplStd/lib/math/Bits.ci:508: (32 bytes): x := ((((x) >> 2) & 13107) | (((x) & 13107) << 2));
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.sar 0x02
	<swapBits+?>: load.c32 13107
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu16
	<swapBits+?>: load.c32 13107
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x02
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i16
	cmplStd/lib/math/Bits.ci:509: (32 bytes): x := ((((x) >> 4) & 3855) | (((x) & 3855) << 4));
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.sar 0x04
	<swapBits+?>: load.c32 3855
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu16
	<swapBits+?>: load.c32 3855
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x04
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i16
	cmplStd/lib/math/Bits.ci:510: (21 bytes): return .result := ((x) >> 8) | ((x) << 8);
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.sar 0x08
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu16
	<swapBits+?>: b32.shl 0x08
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+12)
	<swapBits+?>: store.i16
	<swapBits+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:514: referenced as `swapBits`
}
Bits.swapBits(x: int16): uint16: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:514'
.owner: Bits
.param .result: uint16 (size: 2, cast: u32)
.param x: int16 (size: 4, cast: i32)
.doc: 'reverse all the bits'
.value: swapBits(uint16(x))
.usages:
}
Bits.swapBits(x: uint8): uint8: function {
.kind: static function
.base: `function`
.size: 85
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:517'
.owner: Bits
.param .result: uint8 (size: 4, cast: variable(u32))
.param x: uint8 (size: 4, cast: variable(u32))
.doc: 'reverse all the bits'
.value: {
	x := ((((x) >> 1) & 85) | (((x) & 85) << 1));
	x := ((((x) >> 2) & 51) | (((x) & 51) << 2));
	return .result := ((x) >> 4) | ((x) << 4);
}
.instructions: (85 bytes)
	cmplStd/lib/math/Bits.ci:518: (32 bytes): x := ((((x) >> 1) & 85) | (((x) & 85) << 1));
	<swapBits>  : load.sp(+4)
	<swapBits+?>: load.iu8
	<swapBits+?>: b32.sar 0x01
	<swapBits+?>: load.c32 85
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu8
	<swapBits+?>: load.c32 85
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x01
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i8
	cmplStd/lib/math/Bits.ci:519: (32 bytes): x := ((((x) >> 2) & 51) | (((x) & 51) << 2));
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu8
	<swapBits+?>: b32.sar 0x02
	<swapBits+?>: load.c32 51
	<swapBits+?>: and.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu8
	<swapBits+?>: load.c32 51
	<swapBits+?>: and.b32
	<swapBits+?>: b32.shl 0x02
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: store.i8
	cmplStd/lib/math/Bits.ci:520: (21 bytes): return .result := ((x) >> 4) | ((x) << 4);
	<swapBits+?>: load.sp(+4)
	<swapBits+?>: load.iu8
	<swapBits+?>: b32.sar 0x04
	<swapBits+?>: load.sp(+8)
	<swapBits+?>: load.iu8
	<swapBits+?>: b32.shl 0x04
	<swapBits+?>: or.b32
	<swapBits+?>: load.sp(+12)
	<swapBits+?>: store.i8
	<swapBits+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:524: referenced as `swapBits`
}
Bits.swapBits(x: int8): uint8: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'swapBits'
.file: 'cmplStd/lib/math/Bits.ci:524'
.owner: Bits
.param .result: uint8 (size: 1, cast: u32)
.param x: int8 (size: 4, cast: i32)
.doc: 'reverse all the bits'
.value: swapBits(uint8(x))
.usages:
}
Bits.clamp(value: int32, max: int32): int32: function {
.kind: static function
.base: `function`
.size: 37
.name: 'clamp'
.file: 'cmplStd/lib/math/Bits.ci:528'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param max: int32 (size: 4, cast: variable(i32))
.doc: 'branch-less clamp'
.value: {
	value := value & ~(value >> 31);
	value := value - max;
	value := value & (value >> 31);
	value := value + max;
	return .result := value;
}
.instructions: (37 bytes)
	cmplStd/lib/math/Bits.ci:529: (10 bytes): value := value & ~(value >> 31);
	<clamp>  : dup.x32 sp(2)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: b32.sar 0x1f
	<clamp+?>: cmt.b32
	<clamp+?>: and.b32
	<clamp+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:530: (7 bytes): value := value - max;
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: sub.i32
	<clamp+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:531: (9 bytes): value := value & (value >> 31);
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: b32.sar 0x1f
	<clamp+?>: and.b32
	<clamp+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:532: (7 bytes): value := value + max;
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: dup.x32 sp(2)
	<clamp+?>: add.i32
	<clamp+?>: set.x32 sp(3)
	cmplStd/lib/math/Bits.ci:533: (4 bytes): return .result := value;
	<clamp+?>: mov.x32 sp(3, 2)
	<clamp+?>: ret
.usages:
	cmplStd/lib/math/Bits.ci:538: referenced as `clamp`
}
Bits.clamp(value: int32, min: int32, max: int32): int32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'clamp'
.file: 'cmplStd/lib/math/Bits.ci:537'
.owner: Bits
.param .result: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.param min: int32 (size: 4, cast: variable(i32))
.param max: int32 (size: 4, cast: variable(i32))
.doc: 'branch-less clamp'
.value: {
	return .result := clamp(value - min, max - min) + min;
}
.instructions: (27 bytes)
	cmplStd/lib/math/Bits.ci:538: (27 bytes): return .result := clamp(value - min, max - min) + min;
	<clamp>  : load.z32
	<clamp+?>: dup.x32 sp(4)
	<clamp+?>: dup.x32 sp(4)
	<clamp+?>: sub.i32
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: dup.x32 sp(5)
	<clamp+?>: sub.i32
	<clamp+?>: load.ref <?> ;Bits.clamp(value: int32, max: int32): int32
	<clamp+?>: call
	<clamp+?>: inc.sp(-8)
	<clamp+?>: dup.x32 sp(3)
	<clamp+?>: add.i32
	<clamp+?>: set.x32 sp(5)
	<clamp+?>: ret
.usages:
}
Math: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Math'
.file: 'cmplStd/lib/math/Math.ci:2'
.field pi: float64 (size: 0, cast: static const val)
.field e: float64 (size: 0, cast: static const val)
.field ln2: float64 (size: 0, cast: static const val)
.field log2E: float64 (size: 0, cast: static const val)
.field ln10: float64 (size: 0, cast: static const val)
.field log10E: float64 (size: 0, cast: static const val)
.field phi: float64 (size: 0, cast: static const val)
.field sqrt2: float64 (size: 0, cast: static const val)
.field sqrtE: float64 (size: 0, cast: static const val)
.field sqrtPi: float64 (size: 0, cast: static const val)
.field sqrtPhi: float64 (size: 0, cast: static const val)
.field nan: float64 (size: 0, cast: static const val)
.field inf: float64 (size: 0, cast: static const val)
.field smallestNormal: float64 (size: 0, cast: static const val)
.field isNan: function (size: 12, cast: static function)
.field isInf: function (size: 36, cast: static function)
.field isFinite: function (size: 13, cast: static function)
.field isInf: function (size: 69, cast: static function)
.field floor: function (size: 42, cast: static function)
.field floor: function (size: 34, cast: static function)
.field ceil: function (size: 0, cast: static inline)
.field ceil: function (size: 0, cast: static inline)
.field round: function (size: 0, cast: static inline)
.field round: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field sign: function (size: 0, cast: static inline)
.field absMod: function (size: 27, cast: static function)
.field absMod: function (size: 27, cast: static function)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field abs: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field min: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field max: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field clamp: function (size: 0, cast: static inline)
.field mix: function (size: 0, cast: static inline)
.field mix: function (size: 0, cast: static inline)
.field smoothstep: function (size: 0, cast: static inline)
.field smoothstep: function (size: 0, cast: static inline)
.field smoothstep: function (size: 0, cast: static inline)
.field smoothstep: function (size: 0, cast: static inline)
.field min: function (size: 79, cast: static function)
.field max: function (size: 79, cast: static function)
.field sum: function (size: 40, cast: static function)
.field mean: function (size: 20, cast: static function)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 0, cast: static inline)
.field eval: function (size: 47, cast: static function)
.field modf: function (size: 92, cast: static function)
.field copysign: function (size: 49, cast: static function)
.field frexp: function (size: 236, cast: static function)
.field ldexp: function (size: 336, cast: static function)
.field log: function (size: 298, cast: static function)
.field log: function (size: 27, cast: static function)
.field log2: function (size: 0, cast: static inline)
.field log10: function (size: 0, cast: static inline)
.field log: function (size: 0, cast: static inline)
.field exp: function (size: 297, cast: static function)
.field exp: function (size: 27, cast: static function)
.field sqrt: function (size: 448, cast: static function)
.field sqrt: function (size: 27, cast: static function)
.field pow: function (size: 590, cast: static function)
.field pow: function (size: 32, cast: static function)
.field sincos: function (size: 357, cast: static function)
.field tancot: function (size: 447, cast: static function)
.field atan: function (size: 42, cast: static function)
.field atan2: function (size: 143, cast: static function)
.field atan2: function (size: 32, cast: static function)
.field sin: function (size: 26, cast: static function)
.field sin: function (size: 27, cast: static function)
.field sinh: function (size: 0, cast: static inline)
.field asin: function (size: 0, cast: static inline)
.field asinh: function (size: 0, cast: static inline)
.field cos: function (size: 43, cast: static function)
.field cos: function (size: 27, cast: static function)
.field cosh: function (size: 0, cast: static inline)
.field acos: function (size: 0, cast: static inline)
.field acosh: function (size: 0, cast: static inline)
.field tan: function (size: 82, cast: static function)
.field tan: function (size: 27, cast: static function)
.field tanh: function (size: 0, cast: static inline)
.field atanh: function (size: 0, cast: static inline)
.field cot: function (size: 41, cast: static function)
.field coth: function (size: 0, cast: static inline)
.field acot: function (size: 0, cast: static inline)
.field acoth: function (size: 0, cast: static inline)
.field sec: function (size: 0, cast: static inline)
.field sech: function (size: 0, cast: static inline)
.field asec: function (size: 0, cast: static inline)
.field asech: function (size: 0, cast: static inline)
.field csc: function (size: 0, cast: static inline)
.field csch: function (size: 0, cast: static inline)
.field acsc: function (size: 0, cast: static inline)
.field acsch: function (size: 0, cast: static inline)
.field radians: function (size: 0, cast: static inline)
.field degrees: function (size: 0, cast: static inline)
.doc: 'Mathematical utility functions and constants'
.usages:
	cmplStd/test/math/test.Math.ci:119: referenced as `Math`
	cmplStd/test/math/test.Math.ci:118: referenced as `Math`
	cmplStd/test/math/test.Math.ci:117: referenced as `Math`
	cmplStd/test/math/test.Math.ci:116: referenced as `Math`
	cmplStd/test/math/test.Math.ci:114: referenced as `Math`
	cmplStd/test/math/test.Math.ci:113: referenced as `Math`
	cmplStd/test/math/test.Math.ci:112: referenced as `Math`
	cmplStd/test/math/test.Math.ci:111: referenced as `Math`
	cmplStd/test/math/test.Math.ci:109: referenced as `Math`
	cmplStd/test/math/test.Math.ci:108: referenced as `Math`
	cmplStd/test/math/test.Math.ci:107: referenced as `Math`
	cmplStd/test/math/test.Math.ci:105: referenced as `Math`
	cmplStd/test/math/test.Math.ci:104: referenced as `Math`
	cmplStd/test/math/test.Math.ci:103: referenced as `Math`
	cmplStd/test/math/test.Math.ci:102: referenced as `Math`
	cmplStd/test/math/test.Math.ci:100: referenced as `Math`
	cmplStd/test/math/test.Math.ci:99: referenced as `Math`
	cmplStd/test/math/test.Math.ci:98: referenced as `Math`
	cmplStd/test/math/test.Math.ci:97: referenced as `Math`
	cmplStd/test/math/test.Math.ci:95: referenced as `Math`
	cmplStd/test/math/test.Math.ci:94: referenced as `Math`
	cmplStd/test/math/test.Math.ci:93: referenced as `Math`
	cmplStd/test/math/test.Math.ci:90: referenced as `Math`
	cmplStd/test/math/test.Math.ci:89: referenced as `Math`
	cmplStd/test/math/test.Math.ci:87: referenced as `Math`
	cmplStd/test/math/test.Math.ci:87: referenced as `Math`
	cmplStd/test/math/test.Math.ci:86: referenced as `Math`
	cmplStd/test/math/test.Math.ci:86: referenced as `Math`
	cmplStd/test/math/test.Math.ci:85: referenced as `Math`
	cmplStd/test/math/test.Math.ci:85: referenced as `Math`
	cmplStd/test/math/test.Math.ci:84: referenced as `Math`
	cmplStd/test/math/test.Math.ci:84: referenced as `Math`
	cmplStd/test/math/test.Math.ci:83: referenced as `Math`
	cmplStd/test/math/test.Math.ci:83: referenced as `Math`
	cmplStd/test/math/test.Math.ci:81: referenced as `Math`
	cmplStd/test/math/test.Math.ci:80: referenced as `Math`
	cmplStd/test/math/test.Math.ci:79: referenced as `Math`
	cmplStd/test/math/test.Math.ci:78: referenced as `Math`
	cmplStd/test/math/test.Math.ci:77: referenced as `Math`
	cmplStd/test/math/test.Math.ci:76: referenced as `Math`
	cmplStd/test/math/test.Math.ci:75: referenced as `Math`
	cmplStd/test/math/test.Math.ci:72: referenced as `Math`
	cmplStd/test/math/test.Math.ci:71: referenced as `Math`
	cmplStd/test/math/test.Math.ci:70: referenced as `Math`
	cmplStd/test/math/test.Math.ci:69: referenced as `Math`
	cmplStd/test/math/test.Math.ci:67: referenced as `Math`
	cmplStd/test/math/test.Math.ci:66: referenced as `Math`
	cmplStd/test/math/test.Math.ci:65: referenced as `Math`
	cmplStd/test/math/test.Math.ci:64: referenced as `Math`
	cmplStd/test/math/test.Math.ci:62: referenced as `Math`
	cmplStd/test/math/test.Math.ci:61: referenced as `Math`
	cmplStd/test/math/test.Math.ci:59: referenced as `Math`
	cmplStd/test/math/test.Math.ci:58: referenced as `Math`
	cmplStd/test/math/test.Math.ci:56: referenced as `Math`
	cmplStd/test/math/test.Math.ci:55: referenced as `Math`
	cmplStd/test/math/test.Math.ci:53: referenced as `Math`
	cmplStd/test/math/test.Math.ci:52: referenced as `Math`
	cmplStd/test/math/test.Math.ci:51: referenced as `Math`
	cmplStd/test/math/test.Math.ci:50: referenced as `Math`
	cmplStd/test/math/test.Math.ci:48: referenced as `Math`
	cmplStd/test/math/test.Math.ci:47: referenced as `Math`
	cmplStd/test/math/test.Math.ci:46: referenced as `Math`
	cmplStd/test/math/test.Math.ci:45: referenced as `Math`
	cmplStd/test/math/test.Math.ci:44: referenced as `Math`
	cmplStd/test/math/test.Math.ci:43: referenced as `Math`
	cmplStd/test/math/test.Math.ci:41: referenced as `Math`
	cmplStd/test/math/test.Math.ci:40: referenced as `Math`
	cmplStd/test/math/test.Math.ci:39: referenced as `Math`
	cmplStd/test/math/test.Math.ci:38: referenced as `Math`
	cmplStd/test/math/test.Math.ci:37: referenced as `Math`
	cmplStd/test/math/test.Math.ci:36: referenced as `Math`
	cmplStd/test/math/test.Math.ci:34: referenced as `Math`
	cmplStd/test/math/test.Math.ci:33: referenced as `Math`
	cmplStd/test/math/test.Math.ci:32: referenced as `Math`
	cmplStd/test/math/test.Math.ci:31: referenced as `Math`
	cmplStd/test/math/test.Math.ci:30: referenced as `Math`
	cmplStd/test/math/test.Math.ci:29: referenced as `Math`
	cmplStd/test/math/test.Math.ci:28: referenced as `Math`
	cmplStd/test/math/test.Math.ci:27: referenced as `Math`
	cmplStd/test/math/test.Math.ci:26: referenced as `Math`
	cmplStd/test/math/test.Math.ci:25: referenced as `Math`
	cmplStd/test/math/test.Math.ci:23: referenced as `Math`
	cmplStd/test/math/test.Math.ci:22: referenced as `Math`
	cmplStd/test/math/test.Math.ci:21: referenced as `Math`
	cmplStd/test/math/test.Math.ci:20: referenced as `Math`
	cmplStd/test/math/test.Math.ci:19: referenced as `Math`
	cmplStd/test/math/test.Math.ci:18: referenced as `Math`
	cmplStd/test/math/test.Math.ci:17: referenced as `Math`
	cmplStd/test/math/test.Math.ci:16: referenced as `Math`
	cmplStd/test/math/test.Math.ci:15: referenced as `Math`
	cmplStd/test/math/test.Math.ci:14: referenced as `Math`
	cmplStd/test/math/test.Math.ci:12: referenced as `Math`
	cmplStd/test/math/test.Math.ci:11: referenced as `Math`
	cmplStd/test/math/test.Math.ci:10: referenced as `Math`
	cmplStd/test/math/test.Math.ci:9: referenced as `Math`
	cmplStd/test/math/test.Math.ci:8: referenced as `Math`
	cmplStd/test/math/test.Math.ci:7: referenced as `Math`
	cmplStd/test/math/test.Math.ci:6: referenced as `Math`
	cmplStd/test/math/test.Math.ci:5: referenced as `Math`
	cmplStd/test/math/test.Math.ci:4: referenced as `Math`
	cmplStd/test/math/test.Math.ci:3: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:53: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:52: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:51: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:50: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:49: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:48: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:47: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:46: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:44: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:43: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:42: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:41: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:40: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:39: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:38: referenced as `Math`
	cmplStd/test/math/test.Bits.ci:37: referenced as `Math`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `Math`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `Math`
	cmplStd/lib/math/Polynomial.ci:60: referenced as `Math`
	cmplStd/lib/math/Easing.ci:49: referenced as `Math`
	cmplStd/lib/math/Easing.ci:49: referenced as `Math`
	cmplStd/lib/math/Easing.ci:49: referenced as `Math`
	cmplStd/lib/math/Easing.ci:42: referenced as `Math`
	cmplStd/lib/math/Easing.ci:37: referenced as `Math`
	cmplStd/lib/math/Easing.ci:37: referenced as `Math`
	cmplStd/lib/math/Easing.ci:32: referenced as `Math`
	cmplStd/lib/text/encoding/binary/Base64.ci:32: referenced as `Math`
	cmplStd/lib/text/Format.ci:225: referenced as `Math`
	cmplStd/lib/text/Format.ci:218: referenced as `Math`
	cmplStd/lib/text/Format.ci:211: referenced as `Math`
	cmplStd/lib/text/Format.ci:205: referenced as `Math`
	cmplStd/lib/text/Format.ci:197: referenced as `Math`
	cmplStd/lib/text/Format.ci:197: referenced as `Math`
	cmplStd/lib/text/cstr.ci:153: referenced as `Math`
	cmplStd/lib/text/cstr.ci:141: referenced as `Math`
	cmplStd/lib/text/cstr.ci:126: referenced as `Math`
	cmplStd/lib/time/Datetime.ci:169: referenced as `Math`
	cmplStd/lib/time/Datetime.ci:159: referenced as `Math`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `Math`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `Math`
	cmplStd/lib/math/Matrix4f.ci:134: referenced as `Math`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:137: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:118: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:117: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:115: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `Math`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `Math`
	cmplStd/lib/math/Complex.ci:142: referenced as `Math`
	cmplStd/lib/math/Complex.ci:142: referenced as `Math`
	cmplStd/lib/math/Complex.ci:118: referenced as `Math`
	cmplStd/lib/math/Complex.ci:118: referenced as `Math`
	cmplStd/lib/math/Complex.ci:118: referenced as `Math`
	cmplStd/lib/math/Complex.ci:118: referenced as `Math`
	cmplStd/lib/math/Complex.ci:116: referenced as `Math`
	cmplStd/lib/math/Complex.ci:116: referenced as `Math`
	cmplStd/lib/math/Complex.ci:116: referenced as `Math`
	cmplStd/lib/math/Complex.ci:116: referenced as `Math`
	cmplStd/lib/math/Complex.ci:109: referenced as `Math`
	cmplStd/lib/math/Complex.ci:108: referenced as `Math`
	cmplStd/lib/math/Complex.ci:106: referenced as `Math`
	cmplStd/lib/math/Complex.ci:106: referenced as `Math`
	cmplStd/lib/math/Complex.ci:105: referenced as `Math`
	cmplStd/lib/math/Complex.ci:99: referenced as `Math`
	cmplStd/lib/math/Complex.ci:96: referenced as `Math`
	cmplStd/lib/math/Complex.ci:96: referenced as `Math`
	cmplStd/lib/math/Complex.ci:96: referenced as `Math`
	cmplStd/lib/math/Complex.ci:96: referenced as `Math`
	cmplStd/lib/math/Complex.ci:81: referenced as `Math`
	cmplStd/lib/math/Complex.ci:79: referenced as `Math`
	cmplStd/lib/math/Complex.ci:58: referenced as `Math`
	cmplStd/lib/math/Complex.ci:58: referenced as `Math`
	cmplStd/lib/math/Fixed.ci:758: referenced as `Math`
	cmplStd/lib/math/Fixed.ci:755: referenced as `Math`
	cmplStd/lib/math/Fixed.ci:752: referenced as `Math`
}
Math.pi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'pi'
.file: 'cmplStd/lib/math/Math.ci:6'
.owner: Math
.doc: 'pi'
.value: 3.141593
.usages:
	cmplStd/test/math/test.Math.ci:87: referenced as `pi`
	cmplStd/test/math/test.Math.ci:86: referenced as `pi`
	cmplStd/test/math/test.Math.ci:85: referenced as `pi`
	cmplStd/test/math/test.Math.ci:84: referenced as `pi`
	cmplStd/test/math/test.Math.ci:83: referenced as `pi`
	cmplStd/lib/math/Easing.ci:49: referenced as `pi`
	cmplStd/lib/math/Easing.ci:37: referenced as `pi`
	cmplStd/lib/math/Math.ci:1054: referenced as `pi`
	cmplStd/lib/math/Math.ci:1051: referenced as `pi`
	cmplStd/lib/math/Math.ci:1018: referenced as `pi`
	cmplStd/lib/math/Math.ci:883: referenced as `pi`
	cmplStd/lib/math/Math.ci:881: referenced as `pi`
	cmplStd/lib/math/Math.ci:875: referenced as `pi`
	cmplStd/lib/math/Math.ci:873: referenced as `pi`
	cmplStd/lib/math/Math.ci:854: referenced as `pi`
	cmplStd/lib/math/Math.ci:852: referenced as `pi`
	cmplStd/lib/math/Math.ci:778: referenced as `pi`
	cmplStd/lib/math/Math.ci:717: referenced as `pi`
}
Math.e: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'e'
.file: 'cmplStd/lib/math/Math.ci:7'
.owner: Math
.doc: 'e'
.value: 2.718282
.usages:
}
Math.ln2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'ln2'
.file: 'cmplStd/lib/math/Math.ci:8'
.owner: Math
.doc: 'ln2'
.value: 0.693147
.usages:
	cmplStd/lib/math/Math.ci:454: referenced as `ln2`
	cmplStd/lib/math/Math.ci:9: referenced as `ln2`
}
Math.log2E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'log2E'
.file: 'cmplStd/lib/math/Math.ci:9'
.owner: Math
.doc: 'log2E'
.value: 1.442695
.usages:
}
Math.ln10: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'ln10'
.file: 'cmplStd/lib/math/Math.ci:10'
.owner: Math
.doc: 'ln10'
.value: 2.302585
.usages:
	cmplStd/lib/math/Math.ci:457: referenced as `ln10`
	cmplStd/lib/math/Math.ci:11: referenced as `ln10`
}
Math.log10E: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'log10E'
.file: 'cmplStd/lib/math/Math.ci:11'
.owner: Math
.doc: 'log10E'
.value: 0.434294
.usages:
}
Math.phi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'phi'
.file: 'cmplStd/lib/math/Math.ci:12'
.owner: Math
.doc: 'phi'
.value: 1.618034
.usages:
}
Math.sqrt2: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrt2'
.file: 'cmplStd/lib/math/Math.ci:13'
.owner: Math
.doc: 'sqrt2'
.value: 1.414214
.usages:
}
Math.sqrtE: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrtE'
.file: 'cmplStd/lib/math/Math.ci:14'
.owner: Math
.doc: 'sqrtE'
.value: 1.648721
.usages:
}
Math.sqrtPi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrtPi'
.file: 'cmplStd/lib/math/Math.ci:15'
.owner: Math
.doc: 'sqrtPi'
.value: 1.772454
.usages:
}
Math.sqrtPhi: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'sqrtPhi'
.file: 'cmplStd/lib/math/Math.ci:16'
.owner: Math
.doc: 'sqrtPhi'
.value: 1.272020
.usages:
}
Math.nan: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'nan'
.file: 'cmplStd/lib/math/Math.ci:17'
.owner: Math
.doc: 'nan'
.value: -nan
.usages:
	cmplStd/lib/text/cstr.ci:153: referenced as `nan`
	cmplStd/lib/text/cstr.ci:141: referenced as `nan`
	cmplStd/lib/text/cstr.ci:126: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:752: referenced as `nan`
	cmplStd/lib/math/Math.ci:978: referenced as `nan`
	cmplStd/lib/math/Math.ci:643: referenced as `nan`
	cmplStd/lib/math/Math.ci:630: referenced as `nan`
	cmplStd/lib/math/Math.ci:548: referenced as `nan`
	cmplStd/lib/math/Math.ci:422: referenced as `nan`
	cmplStd/lib/math/Math.ci:225: referenced as `nan`
	cmplStd/lib/math/Math.ci:211: referenced as `nan`
}
Math.inf: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'inf'
.file: 'cmplStd/lib/math/Math.ci:18'
.owner: Math
.doc: 'inf'
.value: inf
.usages:
	cmplStd/lib/math/Fixed.ci:758: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:755: referenced as `inf`
	cmplStd/lib/math/Math.ci:1047: referenced as `inf`
	cmplStd/lib/math/Math.ci:1044: referenced as `inf`
	cmplStd/lib/math/Math.ci:1034: referenced as `inf`
	cmplStd/lib/math/Math.ci:1031: referenced as `inf`
	cmplStd/lib/math/Math.ci:1021: referenced as `inf`
	cmplStd/lib/math/Math.ci:1021: referenced as `inf`
	cmplStd/lib/math/Math.ci:1009: referenced as `inf`
	cmplStd/lib/math/Math.ci:998: referenced as `inf`
	cmplStd/lib/math/Math.ci:998: referenced as `inf`
	cmplStd/lib/math/Math.ci:493: referenced as `inf`
	cmplStd/lib/math/Math.ci:420: referenced as `inf`
	cmplStd/lib/math/Math.ci:382: referenced as `inf`
}
Math.smallestNormal: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'smallestNormal'
.file: 'cmplStd/lib/math/Math.ci:19'
.owner: Math
.doc: 'smallestNormal'
.value: 0.000000
.usages:
	cmplStd/lib/math/Math.ci:367: referenced as `smallestNormal`
	cmplStd/lib/math/Math.ci:326: referenced as `smallestNormal`
}
Math.isNan(x: float64): bool: function {
.kind: static function
.base: `function`
.size: 12
.name: 'isNan'
.file: 'cmplStd/lib/math/Math.ci:23'
.owner: Math
.param .result: bool (size: 4, cast: variable(bool))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Determines whether the given floating point value is not-a-number'
.value: {
	return .result := x != x;
}
.instructions: (12 bytes)
	cmplStd/lib/math/Math.ci:23: (12 bytes): return .result := x != x;
	<isNan>  : dup.x64 sp(1)
	<isNan+?>: dup.x64 sp(3)
	<isNan+?>: ceq.f64
	<isNan+?>: not.b32
	<isNan+?>: load.sp(+16)
	<isNan+?>: store.i8
	<isNan+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:544: referenced as `isNan`
	cmplStd/lib/math/Math.ci:489: referenced as `isNan`
	cmplStd/lib/math/Math.ci:321: referenced as `isNan`
}
Math.isInf(x: float64): bool: function {
.kind: static function
.base: `function`
.size: 36
.name: 'isInf'
.file: 'cmplStd/lib/math/Math.ci:29'
.owner: Math
.param .result: bool (size: 4, cast: variable(bool))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Determines whether the given floating point value is infinity'
.value: {
	return .result := x != (0) && x == (2) * x;
}
.instructions: (36 bytes)
	cmplStd/lib/math/Math.ci:29: (36 bytes): return .result := x != (0) && x == (2) * x;
	<isInf>  : dup.x64 sp(1)
	<isInf+?>: load.z64
	<isInf+?>: ceq.f64
	<isInf+?>: not.b32
	<isInf+?>: dup.x32 sp(0)
	<isInf+?>: jz +23
	<isInf+?>: inc.sp(-4)
	<isInf+?>: dup.x64 sp(1)
	<isInf+?>: load.f64 2.000000
	<isInf+?>: dup.x64 sp(5)
	<isInf+?>: mul.f64
	<isInf+?>: ceq.f64
	<isInf+?>: load.sp(+16)
	<isInf+?>: store.i8
	<isInf+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:321: referenced as `isInf`
}
Math.isFinite(x: float64): bool: function {
.kind: static function
.base: `function`
.size: 13
.name: 'isFinite'
.file: 'cmplStd/lib/math/Math.ci:34'
.owner: Math
.param .result: bool (size: 4, cast: variable(bool))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Determines whether the given floating point value is finite: `!isNan(x) && !isInf(x)`'
.value: {
	return .result := x - x == (0);
}
.instructions: (13 bytes)
	cmplStd/lib/math/Math.ci:34: (13 bytes): return .result := x - x == (0);
	<isFinite>  : dup.x64 sp(1)
	<isFinite+?>: dup.x64 sp(3)
	<isFinite+?>: sub.f64
	<isFinite+?>: load.z64
	<isFinite+?>: ceq.f64
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:41: referenced as `isFinite`
}
Math.isInf(x: float64, sign: int32): bool: function {
.kind: static function
.base: `function`
.size: 69
.name: 'isInf'
.file: 'cmplStd/lib/math/Math.ci:40'
.owner: Math
.param .result: bool (size: 4, cast: variable(bool))
.param x: float64 (size: 8, cast: variable(f64))
.param sign: int32 (size: 4, cast: variable(i32))
.doc: 'Determines whether the given floating point value is finite: `!isNan(x) && !isInf(x)`'
.value: {
	if (isFinite(x)) {
		return .result := false;
	}
	if (sign == 0) {
		return .result := true;
	}
	return .result := sign < 0 ? x < (0) : x > (0);
}
.instructions: (69 bytes)
	cmplStd/lib/math/Math.ci:41: (24 bytes): if (isFinite(x))
	<isInf>  : load.z32
	<isInf+?>: dup.x64 sp(3)
	<isInf+?>: load.ref <?> ;Math.isFinite(x: float64): bool
	<isInf+?>: call
	<isInf+?>: inc.sp(-8)
	<isInf+?>: jz +11
	cmplStd/lib/math/Math.ci:42: (7 bytes): return .result := false;
	<isInf+?>: load.z32
	<isInf+?>: load.sp(+20)
	<isInf+?>: store.i8
	<isInf+?>: ret
	cmplStd/lib/math/Math.ci:44: (19 bytes): if (sign == 0)
	<isInf+?>: dup.x32 sp(1)
	<isInf+?>: load.z32
	<isInf+?>: ceq.i32
	<isInf+?>: jz +15
	cmplStd/lib/math/Math.ci:45: (11 bytes): return .result := true;
	<isInf+?>: load.c32 1
	<isInf+?>: load.sp(+20)
	<isInf+?>: store.i8
	<isInf+?>: ret
	cmplStd/lib/math/Math.ci:47: (26 bytes): return .result := sign < 0 ? x < (0) : x > (0);
	<isInf+?>: dup.x32 sp(1)
	<isInf+?>: load.z32
	<isInf+?>: clt.i32
	<isInf+?>: jz +12
	<isInf+?>: dup.x64 sp(2)
	<isInf+?>: load.z64
	<isInf+?>: clt.f64
	<isInf+?>: jmp +8
	<isInf+?>: dup.x64 sp(2)
	<isInf+?>: load.z64
	<isInf+?>: cgt.f64
	<isInf+?>: load.sp(+20)
	<isInf+?>: store.i8
	<isInf+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:544: referenced as `isInf`
}
Math.floor(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 42
.name: 'floor'
.file: 'cmplStd/lib/math/Math.ci:52'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	mod: float64 := x % (1);
	if (mod < (0)) {
		mod := mod + (1);
	}
	return .result := x - mod;
}
.instructions: (42 bytes)
	cmplStd/lib/math/Math.ci:53: (12 bytes): mod: float64 := x % (1)
	<floor>  : dup.x64 sp(1)
	<floor+?>: load.f64 1.000000
	<floor+?>: mod.f64
	cmplStd/lib/math/Math.ci:54: (18 bytes): if (mod < (0))
	<floor+?>: dup.x64 sp(0)
	<floor+?>: load.z64
	<floor+?>: clt.f64
	<floor+?>: jz +14
	cmplStd/lib/math/Math.ci:55: (10 bytes): mod := mod + (1);
	<floor+?>: load.f64 1.000000
	<floor+?>: add.f64
	cmplStd/lib/math/Math.ci:57: (12 bytes): return .result := x - mod;
	<floor+?>: dup.x64 sp(3)
	<floor+?>: dup.x64 sp(2)
	<floor+?>: sub.f64
	<floor+?>: set.x64 sp(7)
	<floor+?>: inc.sp(-8)
	<floor+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:12: referenced as `floor`
	cmplStd/test/math/test.Math.ci:11: referenced as `floor`
	cmplStd/test/math/test.Math.ci:10: referenced as `floor`
	cmplStd/test/math/test.Math.ci:9: referenced as `floor`
	cmplStd/test/math/test.Math.ci:8: referenced as `floor`
	cmplStd/test/math/test.Math.ci:7: referenced as `floor`
	cmplStd/test/math/test.Math.ci:6: referenced as `floor`
	cmplStd/test/math/test.Math.ci:5: referenced as `floor`
	cmplStd/test/math/test.Math.ci:4: referenced as `floor`
	cmplStd/test/math/test.Math.ci:3: referenced as `floor`
	cmplStd/lib/math/Math.ci:782: referenced as `floor`
	cmplStd/lib/math/Math.ci:778: referenced as `floor`
	cmplStd/lib/math/Math.ci:505: referenced as `floor`
	cmplStd/lib/math/Math.ci:76: referenced as `floor`
	cmplStd/lib/math/Math.ci:70: referenced as `floor`
}
Math.floor(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 34
.name: 'floor'
.file: 'cmplStd/lib/math/Math.ci:61'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Computes the largest integer value not greater than the input'
.value: {
	mod: float32 := x % (1);
	if (mod < (0)) {
		mod := mod + (1);
	}
	return .result := x - mod;
}
.instructions: (34 bytes)
	cmplStd/lib/math/Math.ci:62: (8 bytes): mod: float32 := x % (1)
	<floor>  : dup.x32 sp(1)
	<floor+?>: load.f32 1.000000
	<floor+?>: mod.f32
	cmplStd/lib/math/Math.ci:63: (14 bytes): if (mod < (0))
	<floor+?>: dup.x32 sp(0)
	<floor+?>: load.z32
	<floor+?>: clt.f32
	<floor+?>: jz +10
	cmplStd/lib/math/Math.ci:64: (6 bytes): mod := mod + (1);
	<floor+?>: load.f32 1.000000
	<floor+?>: add.f32
	cmplStd/lib/math/Math.ci:66: (12 bytes): return .result := x - mod;
	<floor+?>: dup.x32 sp(2)
	<floor+?>: dup.x32 sp(1)
	<floor+?>: sub.f32
	<floor+?>: set.x32 sp(4)
	<floor+?>: inc.sp(-4)
	<floor+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:79: referenced as `floor`
	cmplStd/lib/math/Math.ci:73: referenced as `floor`
}
Math.ceil(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'cmplStd/lib/math/Math.ci:70'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the smallest integer not less than the input'
.value: -floor(-x)
.usages:
	cmplStd/test/math/test.Math.ci:34: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:33: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:32: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:31: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:30: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:29: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:28: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:27: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:26: referenced as `ceil`
	cmplStd/test/math/test.Math.ci:25: referenced as `ceil`
}
Math.ceil(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'ceil'
.file: 'cmplStd/lib/math/Math.ci:73'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param x: float32 (size: 4, cast: f32)
.doc: 'Computes the smallest integer not less than the input'
.value: -floor(-x)
.usages:
}
Math.round(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'cmplStd/lib/math/Math.ci:76'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Computes the nearest integer to the input'
.value: floor(x + 0.500000)
.usages:
	cmplStd/test/math/test.Math.ci:23: referenced as `round`
	cmplStd/test/math/test.Math.ci:22: referenced as `round`
	cmplStd/test/math/test.Math.ci:21: referenced as `round`
	cmplStd/test/math/test.Math.ci:20: referenced as `round`
	cmplStd/test/math/test.Math.ci:19: referenced as `round`
	cmplStd/test/math/test.Math.ci:18: referenced as `round`
	cmplStd/test/math/test.Math.ci:17: referenced as `round`
	cmplStd/test/math/test.Math.ci:16: referenced as `round`
	cmplStd/test/math/test.Math.ci:15: referenced as `round`
	cmplStd/test/math/test.Math.ci:14: referenced as `round`
}
Math.round(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'round'
.file: 'cmplStd/lib/math/Math.ci:79'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param x: float32 (size: 4, cast: f32)
.doc: 'Computes the nearest integer to the input'
.value: floor(x + 0.500000)
.usages:
}
Math.sign(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:83'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > 0) - int32(x < 0)
.usages:
}
Math.sign(x: int64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:86'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
}
Math.sign(x: uint32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:89'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: uint32 (size: 4, cast: u32)
.doc: 'Returns the signum of the input (`0` if zero, `1` if positive)'
.value: int32(x > (0))
.usages:
}
Math.sign(x: uint64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:92'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: uint64 (size: 8, cast: u64)
.doc: 'Returns the signum of the input (`0` if zero, `1` if positive)'
.value: int32(x > (0))
.usages:
}
Math.sign(x: float32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:95'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
	cmplStd/test/math/test.Math.ci:41: referenced as `sign`
	cmplStd/test/math/test.Math.ci:40: referenced as `sign`
	cmplStd/test/math/test.Math.ci:39: referenced as `sign`
}
Math.sign(x: float64): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sign'
.file: 'cmplStd/lib/math/Math.ci:98'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the signum of the input (`0` if zero, `-1` if negative, `1` if positive)'
.value: int32(x > (0)) - int32(x < (0))
.usages:
	cmplStd/test/math/test.Math.ci:38: referenced as `sign`
	cmplStd/test/math/test.Math.ci:37: referenced as `sign`
	cmplStd/test/math/test.Math.ci:36: referenced as `sign`
}
Math.absMod(val: float32, mod: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'cmplStd/lib/math/Math.ci:102'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param val: float32 (size: 4, cast: variable(f32))
.param mod: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:103: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x32 sp(2)
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: mod.f32
	<absMod+?>: dup.x32 sp(0)
	<absMod+?>: set.x32 sp(4)
	<absMod+?>: load.z32
	<absMod+?>: clt.f32
	<absMod+?>: jz +12
	cmplStd/lib/math/Math.ci:104: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: dup.x32 sp(2)
	<absMod+?>: add.f32
	<absMod+?>: set.x32 sp(4)
	<absMod+?>: ret
	cmplStd/lib/math/Math.ci:106: (4 bytes): return .result := val;
	<absMod+?>: mov.x32 sp(3, 2)
	<absMod+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:119: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:118: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:117: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:116: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:114: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:113: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:112: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:111: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:109: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:108: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:107: referenced as `absMod`
}
Math.absMod(val: float64, mod: float64): float64: function {
.kind: static function
.base: `function`
.size: 27
.name: 'absMod'
.file: 'cmplStd/lib/math/Math.ci:110'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param val: float64 (size: 8, cast: variable(f64))
.param mod: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the positive modulus of the input'
.value: {
	if ((val := val % mod) < (0)) {
		return .result := val + mod;
	}
	return .result := val;
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:111: (23 bytes): if ((val := val % mod) < (0))
	<absMod>  : dup.x64 sp(3)
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: mod.f64
	<absMod+?>: dup.x64 sp(0)
	<absMod+?>: set.x64 sp(7)
	<absMod+?>: load.z64
	<absMod+?>: clt.f64
	<absMod+?>: jz +12
	cmplStd/lib/math/Math.ci:112: (8 bytes): return .result := val + mod;
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: dup.x64 sp(3)
	<absMod+?>: add.f64
	<absMod+?>: set.x64 sp(7)
	<absMod+?>: ret
	cmplStd/lib/math/Math.ci:114: (4 bytes): return .result := val;
	<absMod+?>: mov.x64 sp(5, 3)
	<absMod+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:105: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:104: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:103: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:102: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:100: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:99: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:98: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:97: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:95: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:94: referenced as `absMod`
	cmplStd/test/math/test.Math.ci:93: referenced as `absMod`
}
Math.abs(x: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:118'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the absolute value of the input'
.value: x < 0 ? -x : x
.usages:
}
Math.abs(x: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:121'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param x: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the absolute value of the input'
.value: x < (0) ? -x : x
.usages:
}
Math.abs(x: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:124'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param x: uint32 (size: 4, cast: u32)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:127'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param x: uint64 (size: 8, cast: u64)
.doc: 'Returns the absolute value of the input'
.value: x
.usages:
}
Math.abs(x: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:130'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the absolute value of the input'
.value: x < (0) ? -x : x
.usages:
	cmplStd/test/math/test.Math.ci:48: referenced as `abs`
	cmplStd/test/math/test.Math.ci:47: referenced as `abs`
	cmplStd/test/math/test.Math.ci:46: referenced as `abs`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `abs`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `abs`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `abs`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `abs`
}
Math.abs(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Math.ci:133'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the absolute value of the input'
.value: x < (0) ? -x : x
.usages:
	cmplStd/test/math/test.Math.ci:45: referenced as `abs`
	cmplStd/test/math/test.Math.ci:44: referenced as `abs`
	cmplStd/test/math/test.Math.ci:43: referenced as `abs`
	cmplStd/lib/text/Format.ci:197: referenced as `abs`
	cmplStd/lib/math/Complex.ci:58: referenced as `abs`
	cmplStd/lib/math/Complex.ci:58: referenced as `abs`
	cmplStd/lib/math/Math.ci:367: referenced as `abs`
	cmplStd/lib/math/Math.ci:326: referenced as `abs`
}
Math.min(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:137'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:32: referenced as `min`
	cmplStd/lib/math/Math.ci:174: referenced as `min`
}
Math.min(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:140'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param a: int64 (size: 8, cast: variable(i64))
.param b: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:177: referenced as `min`
}
Math.min(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:143'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param a: uint32 (size: 4, cast: variable(u32))
.param b: uint32 (size: 4, cast: variable(u32))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:180: referenced as `min`
}
Math.min(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:146'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param a: uint64 (size: 8, cast: variable(u64))
.param b: uint64 (size: 8, cast: variable(u64))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:183: referenced as `min`
}
Math.min(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:149'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/test/math/test.Math.ci:50: referenced as `min`
	cmplStd/lib/math/Math.ci:186: referenced as `min`
}
Math.min(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:152'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the smaller value from the input values'
.value: a < b ? a : b
.usages:
	cmplStd/test/math/test.Math.ci:52: referenced as `min`
	cmplStd/lib/math/Math.ci:189: referenced as `min`
}
Math.max(a: int32, b: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:155'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/lib/math/Polynomial.ci:124: referenced as `max`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `max`
	cmplStd/lib/math/Polynomial.ci:60: referenced as `max`
	cmplStd/lib/text/Format.ci:218: referenced as `max`
	cmplStd/lib/text/Format.ci:205: referenced as `max`
	cmplStd/lib/math/Math.ci:174: referenced as `max`
}
Math.max(a: int64, b: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:158'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param a: int64 (size: 8, cast: variable(i64))
.param b: int64 (size: 8, cast: variable(i64))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:177: referenced as `max`
}
Math.max(a: uint32, b: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:161'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param a: uint32 (size: 4, cast: variable(u32))
.param b: uint32 (size: 4, cast: variable(u32))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:180: referenced as `max`
}
Math.max(a: uint64, b: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:164'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param a: uint64 (size: 8, cast: variable(u64))
.param b: uint64 (size: 8, cast: variable(u64))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/lib/math/Math.ci:183: referenced as `max`
}
Math.max(a: float32, b: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:167'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/test/math/test.Math.ci:51: referenced as `max`
	cmplStd/lib/math/Math.ci:186: referenced as `max`
}
Math.max(a: float64, b: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:170'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the greater value from the input values'
.value: a > b ? a : b
.usages:
	cmplStd/test/math/test.Math.ci:53: referenced as `max`
	cmplStd/lib/math/Math.ci:189: referenced as `max`
}
Math.clamp(value: int32, min: int32, max: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:174'
.owner: Math
.param .result: int32 (size: 4, cast: i32)
.param value: int32 (size: 4, cast: i32)
.param min: int32 (size: 4, cast: i32)
.param max: int32 (size: 4, cast: i32)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
	cmplStd/lib/time/Datetime.ci:169: referenced as `clamp`
	cmplStd/lib/time/Datetime.ci:159: referenced as `clamp`
}
Math.clamp(value: int64, min: int64, max: int64): int64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:177'
.owner: Math
.param .result: int64 (size: 8, cast: i64)
.param value: int64 (size: 8, cast: i64)
.param min: int64 (size: 8, cast: i64)
.param max: int64 (size: 8, cast: i64)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
}
Math.clamp(value: uint32, min: uint32, max: uint32): uint32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:180'
.owner: Math
.param .result: uint32 (size: 4, cast: u32)
.param value: uint32 (size: 4, cast: u32)
.param min: uint32 (size: 4, cast: u32)
.param max: uint32 (size: 4, cast: u32)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
}
Math.clamp(value: uint64, min: uint64, max: uint64): uint64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:183'
.owner: Math
.param .result: uint64 (size: 8, cast: u64)
.param value: uint64 (size: 8, cast: u64)
.param min: uint64 (size: 8, cast: u64)
.param max: uint64 (size: 8, cast: u64)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
}
Math.clamp(value: float32, min: float32, max: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:186'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param value: float32 (size: 4, cast: f32)
.param min: float32 (size: 4, cast: f32)
.param max: float32 (size: 4, cast: f32)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
	cmplStd/test/math/test.Math.ci:55: referenced as `clamp`
	cmplStd/lib/math/Math.ci:200: referenced as `clamp`
}
Math.clamp(value: float64, min: float64, max: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Math.ci:189'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param value: float64 (size: 8, cast: f64)
.param min: float64 (size: 8, cast: f64)
.param max: float64 (size: 8, cast: f64)
.doc: 'Returns the `value` clamped between `min` and `max`'
.value: min(max(value, min), max)
.usages:
	cmplStd/test/math/test.Math.ci:56: referenced as `clamp`
	cmplStd/lib/math/Math.ci:205: referenced as `clamp`
}
Math.mix(a: float32, b: float32, t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'mix'
.file: 'cmplStd/lib/math/Math.ci:192'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param a: float32 (size: 4, cast: variable(f32))
.param b: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
	cmplStd/test/math/test.Math.ci:58: referenced as `mix`
	cmplStd/lib/math/Vector4f.ci:118: referenced as `mix`
	cmplStd/lib/math/Vector4f.ci:117: referenced as `mix`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `mix`
	cmplStd/lib/math/Vector4f.ci:115: referenced as `mix`
}
Math.mix(a: float64, b: float64, t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'mix'
.file: 'cmplStd/lib/math/Math.ci:195'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param a: float64 (size: 8, cast: variable(f64))
.param b: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.doc: 'Returns the linear interpolation between `a` and `b` by `t`'
.value: a + t * (b - a)
.usages:
	cmplStd/test/math/test.Math.ci:59: referenced as `mix`
}
Math.smoothstep(t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smoothstep'
.file: 'cmplStd/lib/math/Math.ci:197'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: variable(f32))
.value: t * t * ((3) - (2) * t)
.usages:
	cmplStd/lib/math/Math.ci:200: referenced as `smoothstep`
}
Math.smoothstep(min: float32, max: float32, t: float32): float32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smoothstep'
.file: 'cmplStd/lib/math/Math.ci:200'
.owner: Math
.param .result: float32 (size: 4, cast: f32)
.param min: float32 (size: 4, cast: variable(f32))
.param max: float32 (size: 4, cast: f32)
.param t: float32 (size: 4, cast: f32)
.doc: 'Returns the Hermite interpolation between two values'
.value: smoothstep(clamp((t - min) / (max - min), 0.000000, 1.000000))
.usages:
	cmplStd/test/math/test.Math.ci:61: referenced as `smoothstep`
}
Math.smoothstep(t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smoothstep'
.file: 'cmplStd/lib/math/Math.ci:202'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: variable(f64))
.value: t * t * ((3) - (2) * t)
.usages:
	cmplStd/lib/math/Math.ci:205: referenced as `smoothstep`
}
Math.smoothstep(min: float64, max: float64, t: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'smoothstep'
.file: 'cmplStd/lib/math/Math.ci:205'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param min: float64 (size: 8, cast: variable(f64))
.param max: float64 (size: 8, cast: f64)
.param t: float64 (size: 8, cast: f64)
.doc: 'Returns the Hermite interpolation between two values'
.value: smoothstep(clamp((t - min) / (max - min), 0.000000, 1.000000))
.usages:
	cmplStd/test/math/test.Math.ci:62: referenced as `smoothstep`
}
Math.min(values: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.name: 'min'
.file: 'cmplStd/lib/math/Math.ci:209'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the smaller value from the input values'
.value: {
	if (values.length == (0)) {
		return .result := nan;
	}
	result: float64 := values[0];
	for (i: int32 := 1; i < (values.length); i := i + 1) {
		if (result > values[i]) {
			result := values[i];
		}
	}
	return .result := result;
}
.instructions: (79 bytes)
	cmplStd/lib/math/Math.ci:210: (20 bytes): if (values.length == (0))
	<min>  : dup.x32 sp(2)
	<min+?>: load.z32
	<min+?>: ceq.i32
	<min+?>: jz +16
	cmplStd/lib/math/Math.ci:211: (12 bytes): return .result := nan;
	<min+?>: load.f64 -nan
	<min+?>: set.x64 sp(5)
	<min+?>: ret
	cmplStd/lib/math/Math.ci:213: (3 bytes): result: float64 := values[0]
	<min+?>: dup.x32 sp(1)
	<min+?>: load.i64
	cmplStd/lib/math/Math.ci:214: (53 bytes): for (i: int32 := 1; i < (values.length); i := i + 1)
	<min+?>: load.c32 1
	<min+?>: jmp +35
	cmplStd/lib/math/Math.ci:215: (27 bytes): if (result > values[i])
	<min+?>: dup.x64 sp(1)
	<min+?>: dup.x32 sp(6)
	<min+?>: dup.x32 sp(3)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: cgt.f64
	<min+?>: jz +15
	cmplStd/lib/math/Math.ci:216: (11 bytes): result := values[i];
	<min+?>: dup.x32 sp(4)
	<min+?>: dup.x32 sp(1)
	<min+?>: mad.u32 8
	<min+?>: load.i64
	<min+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:214: (4 bytes): i := i + 1
	<min+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:214: (9 bytes): i < (values.length)
	<min+?>: dup.x32 sp(0)
	<min+?>: dup.x32 sp(6)
	<min+?>: clt.i32
	<min+?>: jnz -36
	<min+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:219: (3 bytes): return .result := result;
	<min+?>: set.x64 sp(5)
	<min+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:65: referenced as `min`
	cmplStd/test/math/test.Math.ci:64: referenced as `min`
}
Math.max(values: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 79
.name: 'max'
.file: 'cmplStd/lib/math/Math.ci:223'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the greater value from the input values'
.value: {
	if (values.length == (0)) {
		return .result := nan;
	}
	result: float64 := values[0];
	for (i: int32 := 1; i < (values.length); i := i + 1) {
		if (result < values[i]) {
			result := values[i];
		}
	}
	return .result := result;
}
.instructions: (79 bytes)
	cmplStd/lib/math/Math.ci:224: (20 bytes): if (values.length == (0))
	<max>  : dup.x32 sp(2)
	<max+?>: load.z32
	<max+?>: ceq.i32
	<max+?>: jz +16
	cmplStd/lib/math/Math.ci:225: (12 bytes): return .result := nan;
	<max+?>: load.f64 -nan
	<max+?>: set.x64 sp(5)
	<max+?>: ret
	cmplStd/lib/math/Math.ci:227: (3 bytes): result: float64 := values[0]
	<max+?>: dup.x32 sp(1)
	<max+?>: load.i64
	cmplStd/lib/math/Math.ci:228: (53 bytes): for (i: int32 := 1; i < (values.length); i := i + 1)
	<max+?>: load.c32 1
	<max+?>: jmp +35
	cmplStd/lib/math/Math.ci:229: (27 bytes): if (result < values[i])
	<max+?>: dup.x64 sp(1)
	<max+?>: dup.x32 sp(6)
	<max+?>: dup.x32 sp(3)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: clt.f64
	<max+?>: jz +15
	cmplStd/lib/math/Math.ci:230: (11 bytes): result := values[i];
	<max+?>: dup.x32 sp(4)
	<max+?>: dup.x32 sp(1)
	<max+?>: mad.u32 8
	<max+?>: load.i64
	<max+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:228: (4 bytes): i := i + 1
	<max+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:228: (9 bytes): i < (values.length)
	<max+?>: dup.x32 sp(0)
	<max+?>: dup.x32 sp(6)
	<max+?>: clt.i32
	<max+?>: jnz -36
	<max+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:233: (3 bytes): return .result := result;
	<max+?>: set.x64 sp(5)
	<max+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:67: referenced as `max`
	cmplStd/test/math/test.Math.ci:66: referenced as `max`
}
Math.sum(values: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 40
.name: 'sum'
.file: 'cmplStd/lib/math/Math.ci:237'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the sum of the input values'
.value: {
	result: float64 := 0;
	for (i: int32 := 0; i < (values.length); i := i + 1) {
		result := result + values[i];
	}
	return .result := result;
}
.instructions: (40 bytes)
	cmplStd/lib/math/Math.ci:238: (1 byte): result: float64 := 0
	<sum>  : load.z128
	cmplStd/lib/math/Math.ci:239: (36 bytes): for (i: int32 := 0; i < (values.length); i := i + 1)
	<sum+?>: i64.2i32
	<sum+?>: jmp +22
	cmplStd/lib/math/Math.ci:240: (14 bytes): result := result + values[i];
	<sum+?>: dup.x64 sp(1)
	<sum+?>: dup.x32 sp(6)
	<sum+?>: dup.x32 sp(3)
	<sum+?>: mad.u32 8
	<sum+?>: load.i64
	<sum+?>: add.f64
	<sum+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:239: (4 bytes): i := i + 1
	<sum+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:239: (9 bytes): i < (values.length)
	<sum+?>: dup.x32 sp(0)
	<sum+?>: dup.x32 sp(6)
	<sum+?>: clt.i32
	<sum+?>: jnz -23
	<sum+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:242: (3 bytes): return .result := result;
	<sum+?>: set.x64 sp(5)
	<sum+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:72: referenced as `sum`
	cmplStd/test/math/test.Math.ci:71: referenced as `sum`
	cmplStd/test/math/test.Math.ci:70: referenced as `sum`
	cmplStd/test/math/test.Math.ci:69: referenced as `sum`
	cmplStd/lib/math/Math.ci:247: referenced as `sum`
}
Math.mean(values: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 20
.name: 'mean'
.file: 'cmplStd/lib/math/Math.ci:246'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Returns the mean of the input values'
.value: {
	return .result := sum(...values) / (Bits.signed(values.length));
}
.instructions: (20 bytes)
	cmplStd/lib/math/Math.ci:247: (20 bytes): return .result := sum(...values) / (Bits.signed(values.length));
	<mean>  : load.z64
	<mean+?>: dup.x64 sp(3)
	<mean+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<mean+?>: call
	<mean+?>: inc.sp(-8)
	<mean+?>: dup.x32 sp(4)
	<mean+?>: i32.2f64
	<mean+?>: div.f64
	<mean+?>: set.x64 sp(5)
	<mean+?>: ret
.usages:
}
Math.eval(x: float64, a0: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:251'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0
.usages:
	cmplStd/test/math/test.Math.ci:76: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:254'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * a1
.usages:
	cmplStd/test/math/test.Math.ci:77: referenced as `eval`
	cmplStd/lib/math/Math.ci:257: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:257'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * eval(x, a1, a2)
.usages:
	cmplStd/test/math/test.Math.ci:78: referenced as `eval`
	cmplStd/lib/math/Math.ci:798: referenced as `eval`
	cmplStd/lib/math/Math.ci:513: referenced as `eval`
	cmplStd/lib/math/Math.ci:439: referenced as `eval`
	cmplStd/lib/math/Math.ci:260: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:260'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * eval(x, a1, a2, a3)
.usages:
	cmplStd/test/math/test.Math.ci:79: referenced as `eval`
	cmplStd/lib/math/Math.ci:741: referenced as `eval`
	cmplStd/lib/math/Math.ci:514: referenced as `eval`
	cmplStd/lib/math/Math.ci:438: referenced as `eval`
	cmplStd/lib/math/Math.ci:263: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64, a4: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:263'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.param a4: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * eval(x, a1, a2, a3, a4)
.usages:
	cmplStd/test/math/test.Math.ci:80: referenced as `eval`
	cmplStd/lib/math/Math.ci:842: referenced as `eval`
	cmplStd/lib/math/Math.ci:841: referenced as `eval`
	cmplStd/lib/math/Math.ci:798: referenced as `eval`
	cmplStd/lib/math/Math.ci:740: referenced as `eval`
	cmplStd/lib/math/Math.ci:266: referenced as `eval`
}
Math.eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64, a4: float64, a5: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:266'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.param a0: float64 (size: 8, cast: f64)
.param a1: float64 (size: 8, cast: f64)
.param a2: float64 (size: 8, cast: f64)
.param a3: float64 (size: 8, cast: f64)
.param a4: float64 (size: 8, cast: f64)
.param a5: float64 (size: 8, cast: f64)
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: a0 + x * eval(x, a1, a2, a3, a4, a5)
.usages:
	cmplStd/test/math/test.Math.ci:81: referenced as `eval`
}
Math.eval(x: float64, polynomial: float64[]): float64: function {
.kind: static function
.base: `function`
.size: 47
.name: 'eval'
.file: 'cmplStd/lib/math/Math.ci:269'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param polynomial: float64[] (size: 8, cast: variable(arr))
.doc: 'Return the polynomial evaluated at x using Horner's algorithm'
.value: {
	result: float64 := 0;
	for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
		result := result * x + polynomial[i];
	}
	return .result := result;
}
.instructions: (47 bytes)
	cmplStd/lib/math/Math.ci:270: (1 byte): result: float64 := 0
	<eval>  : load.z64
	cmplStd/lib/math/Math.ci:271: (43 bytes): for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1)
	<eval+?>: dup.x32 sp(4)
	<eval+?>: inc.i32(-1)
	<eval+?>: jmp +25
	cmplStd/lib/math/Math.ci:272: (17 bytes): result := result * x + polynomial[i];
	<eval+?>: dup.x64 sp(1)
	<eval+?>: dup.x64 sp(8)
	<eval+?>: mul.f64
	<eval+?>: dup.x32 sp(6)
	<eval+?>: dup.x32 sp(3)
	<eval+?>: mad.u32 8
	<eval+?>: load.i64
	<eval+?>: add.f64
	<eval+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:271: (4 bytes): i := i - 1
	<eval+?>: inc.i32(-1)
	cmplStd/lib/math/Math.ci:271: (8 bytes): i >= 0
	<eval+?>: dup.x32 sp(0)
	<eval+?>: load.z32
	<eval+?>: clt.i32
	<eval+?>: jz -25
	<eval+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:274: (3 bytes): return .result := result;
	<eval+?>: set.x64 sp(7)
	<eval+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:75: referenced as `eval`
}
Math.modf(x: float64, intPart: float64): float64: function {
.kind: static function
.base: `function`
.size: 92
.name: 'modf'
.file: 'cmplStd/lib/math/Math.ci:278'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param intPart: float64 (size: 4, cast: variable(ref))
.doc: 'Decompose a value into integer and fractional parts'
.value: {
	if (x < (1)) {
		if (x < (0)) {
			result: float64 := modf(-x, &intPart);
			intPart := -intPart;
			return .result := -result;
		}
		intPart := (0);
		return .result := x;
	}
	result: float64 := x % (1);
	intPart := x - result;
	return .result := result;
}
.instructions: (92 bytes)
	cmplStd/lib/math/Math.ci:279: (69 bytes): if (x < (1))
	<modf>  : dup.x64 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: clt.f64
	<modf+?>: jz +57
	cmplStd/lib/math/Math.ci:280: (45 bytes): if (x < (0))
	<modf+?>: dup.x64 sp(2)
	<modf+?>: load.z64
	<modf+?>: clt.f64
	<modf+?>: jz +41
	cmplStd/lib/math/Math.ci:281: (16 bytes): result: float64 := modf(-x, &intPart)
	<modf+?>: load.z64
	<modf+?>: dup.x64 sp(4)
	<modf+?>: neg.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<modf+?>: call
	<modf+?>: inc.sp(-12)
	cmplStd/lib/math/Math.ci:282: (7 bytes): intPart := -intPart;
	<modf+?>: dup.x32 sp(3)
	<modf+?>: load.i64
	<modf+?>: neg.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: store.i64
	cmplStd/lib/math/Math.ci:283: (10 bytes): return .result := -result;
	<modf+?>: dup.x64 sp(0)
	<modf+?>: neg.f64
	<modf+?>: set.x64 sp(8)
	<modf+?>: inc.sp(-8)
	<modf+?>: ret
	<modf+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:285: (4 bytes): intPart := (0);
	<modf+?>: load.z64
	<modf+?>: dup.x32 sp(3)
	<modf+?>: store.i64
	cmplStd/lib/math/Math.ci:286: (4 bytes): return .result := x;
	<modf+?>: mov.x64 sp(4, 2)
	<modf+?>: ret
	cmplStd/lib/math/Math.ci:288: (12 bytes): result: float64 := x % (1)
	<modf+?>: dup.x64 sp(2)
	<modf+?>: load.f64 1.000000
	<modf+?>: mod.f64
	cmplStd/lib/math/Math.ci:289: (8 bytes): intPart := x - result;
	<modf+?>: dup.x64 sp(4)
	<modf+?>: dup.x64 sp(2)
	<modf+?>: sub.f64
	<modf+?>: dup.x32 sp(5)
	<modf+?>: store.i64
	cmplStd/lib/math/Math.ci:290: (3 bytes): return .result := result;
	<modf+?>: set.x64 sp(6)
	<modf+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:225: referenced as `modf`
	cmplStd/lib/text/Format.ci:197: referenced as `modf`
	cmplStd/lib/math/Math.ci:724: referenced as `modf`
	cmplStd/lib/math/Math.ci:720: referenced as `modf`
	cmplStd/lib/math/Math.ci:624: referenced as `modf`
	cmplStd/lib/math/Math.ci:281: referenced as `modf`
}
Math.copysign(x: float64, y: float64): float64: function {
.kind: static function
.base: `function`
.size: 49
.name: 'copysign'
.file: 'cmplStd/lib/math/Math.ci:293'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.value: {
	sign: uint64 := Bits.fromFloat64(y) & (1 << 63);
	val: uint64 := Bits.fromFloat64(x) & ~(1 << 63);
	return .result := Bits.asFloat64(sign | val);
}
.instructions: (49 bytes)
	cmplStd/lib/math/Math.ci:294: (18 bytes): sign: uint64 := Bits.fromFloat64(y) & (1 << 63)
	<copysign>  : dup.x64 sp(1)
	<copysign+?>: load.c64 1
	<copysign+?>: load.c32 63
	<copysign+?>: shl.b64
	<copysign+?>: and.b64
	cmplStd/lib/math/Math.ci:295: (19 bytes): val: uint64 := Bits.fromFloat64(x) & ~(1 << 63)
	<copysign+?>: dup.x64 sp(5)
	<copysign+?>: load.c64 1
	<copysign+?>: load.c32 63
	<copysign+?>: shl.b64
	<copysign+?>: cmt.b64
	<copysign+?>: and.b64
	cmplStd/lib/math/Math.ci:296: (12 bytes): return .result := Bits.asFloat64(sign | val);
	<copysign+?>: dup.x64 sp(2)
	<copysign+?>: dup.x64 sp(2)
	<copysign+?>: or.b64
	<copysign+?>: set.x64 sp(11)
	<copysign+?>: inc.sp(-16)
	<copysign+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:382: referenced as `copysign`
	cmplStd/lib/math/Math.ci:378: referenced as `copysign`
}
Math.frexp(f: float64, exp: int32): float64: function {
.kind: static function
.base: `function`
.size: 236
.name: 'frexp'
.file: 'cmplStd/lib/math/Math.ci:309'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param f: float64 (size: 8, cast: variable(f64))
.param exp: int32 (size: 4, cast: variable(ref))
.value: {
	mask: typename := 2047;
	shift: typename := 64 - 11 - 1;
	bias: typename := 1023;
	signMask: typename := 1 << 63;
	fracMask: typename := 1 << shift - 1;
	if (f == (0)) {
		exp := 0;
		return .result := f;
	}
	if (isInf(f) || isNan(f)) {
		exp := 0;
		return .result := f;
	}
	if (abs(f) < smallestNormal) {
		f := f * (1 << 52);
		exp := exp - 52;
	}
	else {
		exp := 0;
	}
	x: uint64 := Bits.fromFloat64(f);
	exp := exp + int32((x >> shift) & mask) - bias + 1;
	x := x & ~(mask << shift);
	x := x | (-1 + (bias)) << shift;
	return .result := Bits.asFloat64(x);
}
.instructions: (236 bytes)
	cmplStd/lib/math/Math.ci:317: (16 bytes): if (f == (0))
	<frexp>  : dup.x64 sp(2)
	<frexp+?>: load.z64
	<frexp+?>: ceq.f64
	<frexp+?>: jz +12
	cmplStd/lib/math/Math.ci:318: (4 bytes): exp := 0;
	<frexp+?>: load.z32
	<frexp+?>: dup.x32 sp(2)
	<frexp+?>: store.i32
	cmplStd/lib/math/Math.ci:319: (4 bytes): return .result := f;
	<frexp+?>: mov.x64 sp(4, 2)
	<frexp+?>: ret
	cmplStd/lib/math/Math.ci:321: (48 bytes): if (isInf(f) || isNan(f))
	<frexp+?>: load.z32
	<frexp+?>: dup.x64 sp(3)
	<frexp+?>: load.ref <?> ;Math.isInf(x: float64): bool
	<frexp+?>: call
	<frexp+?>: inc.sp(-8)
	<frexp+?>: dup.x32 sp(0)
	<frexp+?>: jnz +21
	<frexp+?>: inc.sp(-4)
	<frexp+?>: load.z32
	<frexp+?>: dup.x64 sp(3)
	<frexp+?>: load.ref <?> ;Math.isNan(x: float64): bool
	<frexp+?>: call
	<frexp+?>: inc.sp(-8)
	<frexp+?>: jz +12
	cmplStd/lib/math/Math.ci:322: (4 bytes): exp := 0;
	<frexp+?>: load.z32
	<frexp+?>: dup.x32 sp(2)
	<frexp+?>: store.i32
	cmplStd/lib/math/Math.ci:323: (4 bytes): return .result := f;
	<frexp+?>: mov.x64 sp(4, 2)
	<frexp+?>: ret
	cmplStd/lib/math/Math.ci:326: (66 bytes): if (abs(f) < smallestNormal)
	<frexp+?>: dup.x64 sp(2)
	<frexp+?>: dup.x64 sp(0)
	<frexp+?>: load.z64
	<frexp+?>: clt.f64
	<frexp+?>: jz +11
	<frexp+?>: dup.x64 sp(0)
	<frexp+?>: neg.f64
	<frexp+?>: jmp +6
	<frexp+?>: dup.x64 sp(0)
	<frexp+?>: set.x64 sp(2)
	<frexp+?>: load.f64 0.000000
	<frexp+?>: clt.f64
	<frexp+?>: jz +31
	cmplStd/lib/math/Math.ci:328: (13 bytes): f := f * (1 << 52);
	<frexp+?>: dup.x64 sp(2)
	<frexp+?>: load.c32 1
	<frexp+?>: b32.shl 0x34
	<frexp+?>: i32.2f64
	<frexp+?>: mul.f64
	<frexp+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:329: (10 bytes): exp := exp - 52;
	<frexp+?>: dup.x32 sp(1)
	<frexp+?>: load.i32
	<frexp+?>: inc.i32(-52)
	<frexp+?>: dup.x32 sp(2)
	<frexp+?>: store.i32
	<frexp+?>: jmp +8
	cmplStd/lib/math/Math.ci:331: (4 bytes): exp := 0;
	<frexp+?>: load.z32
	<frexp+?>: dup.x32 sp(2)
	<frexp+?>: store.i32
	cmplStd/lib/math/Math.ci:334: (2 bytes): x: uint64 := Bits.fromFloat64(f)
	<frexp+?>: dup.x64 sp(2)
	cmplStd/lib/math/Math.ci:335: (42 bytes): exp := exp + int32((x >> shift) & mask) - bias + 1;
	<frexp+?>: dup.x32 sp(3)
	<frexp+?>: load.i32
	<frexp+?>: dup.x64 sp(1)
	<frexp+?>: load.c32 64
	<frexp+?>: inc.i32(-11)
	<frexp+?>: inc.i32(-1)
	<frexp+?>: shr.b64
	<frexp+?>: load.c64 2047
	<frexp+?>: and.b64
	<frexp+?>: i64.2i32
	<frexp+?>: inc.i32(-1023)
	<frexp+?>: inc.i32(+1)
	<frexp+?>: add.i32
	<frexp+?>: dup.x32 sp(4)
	<frexp+?>: store.i32
	cmplStd/lib/math/Math.ci:336: (25 bytes): x := x & ~(mask << shift);
	<frexp+?>: load.c64 2047
	<frexp+?>: load.c32 64
	<frexp+?>: inc.i32(-11)
	<frexp+?>: inc.i32(-1)
	<frexp+?>: shl.b64
	<frexp+?>: cmt.b64
	<frexp+?>: and.b64
	cmplStd/lib/math/Math.ci:337: (34 bytes): x := x | (-1 + (bias)) << shift;
	<frexp+?>: load.c64 -1
	<frexp+?>: load.c64 1023
	<frexp+?>: add.i64
	<frexp+?>: load.c32 64
	<frexp+?>: inc.i32(-11)
	<frexp+?>: inc.i32(-1)
	<frexp+?>: shl.b64
	<frexp+?>: or.b64
	cmplStd/lib/math/Math.ci:338: (3 bytes): return .result := Bits.asFloat64(x);
	<frexp+?>: set.x64 sp(6)
	<frexp+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:658: referenced as `frexp`
	cmplStd/lib/math/Math.ci:426: referenced as `frexp`
}
Math.ldexp(f: float64, exp: int32): float64: function {
.kind: static function
.base: `function`
.size: 336
.name: 'ldexp'
.file: 'cmplStd/lib/math/Math.ci:350'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param f: float64 (size: 8, cast: variable(f64))
.param exp: int32 (size: 4, cast: variable(i32))
.value: {
	mask: typename := 2047;
	shift: typename := 64 - 11 - 1;
	bias: typename := 1023;
	signMask: typename := 1 << 63;
	fracMask: typename := 1 << shift - 1;
	if (f == (0)) {
		return .result := f;
	}
	if (f != f || f - f != (0)) {
		return .result := f;
	}
	if (abs(f) < smallestNormal) {
		f := f * (1 << 52);
		exp := exp - 52;
	}
	x: uint64 := Bits.fromFloat64(f);
	exp := ((exp) + ((int32(x >> shift)) & mask) - (bias));
	if (exp < -1075) {
		return .result := copysign(0.000000, f);
	}
	if (exp > 1023) {
		return .result := copysign(inf, f);
	}
	m: float64 := 1;
	if (exp < -1022) {
		exp := exp + 53;
		m := (1) / float64(1 << 53);
	}
	x := x & ~(mask << shift);
	x := x | uint64(exp + bias) << shift;
	return .result := m * Bits.asFloat64(x);
}
.instructions: (336 bytes)
	cmplStd/lib/math/Math.ci:358: (12 bytes): if (f == (0))
	<ldexp>  : dup.x64 sp(2)
	<ldexp+?>: load.z64
	<ldexp+?>: ceq.f64
	<ldexp+?>: jz +8
	cmplStd/lib/math/Math.ci:360: (4 bytes): return .result := f;
	<ldexp+?>: mov.x64 sp(4, 2)
	<ldexp+?>: ret
	cmplStd/lib/math/Math.ci:362: (32 bytes): if (f != f || f - f != (0))
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: dup.x64 sp(4)
	<ldexp+?>: ceq.f64
	<ldexp+?>: not.b32
	<ldexp+?>: dup.x32 sp(0)
	<ldexp+?>: jnz +16
	<ldexp+?>: inc.sp(-4)
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: dup.x64 sp(4)
	<ldexp+?>: sub.f64
	<ldexp+?>: load.z64
	<ldexp+?>: ceq.f64
	<ldexp+?>: not.b32
	<ldexp+?>: jz +8
	cmplStd/lib/math/Math.ci:364: (4 bytes): return .result := f;
	<ldexp+?>: mov.x64 sp(4, 2)
	<ldexp+?>: ret
	cmplStd/lib/math/Math.ci:367: (56 bytes): if (abs(f) < smallestNormal)
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: dup.x64 sp(0)
	<ldexp+?>: load.z64
	<ldexp+?>: clt.f64
	<ldexp+?>: jz +11
	<ldexp+?>: dup.x64 sp(0)
	<ldexp+?>: neg.f64
	<ldexp+?>: jmp +6
	<ldexp+?>: dup.x64 sp(0)
	<ldexp+?>: set.x64 sp(2)
	<ldexp+?>: load.f64 0.000000
	<ldexp+?>: clt.f64
	<ldexp+?>: jz +25
	cmplStd/lib/math/Math.ci:369: (13 bytes): f := f * (1 << 52);
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: load.c32 1
	<ldexp+?>: b32.shl 0x34
	<ldexp+?>: i32.2f64
	<ldexp+?>: mul.f64
	<ldexp+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:370: (8 bytes): exp := exp - 52;
	<ldexp+?>: dup.x32 sp(1)
	<ldexp+?>: inc.i32(-52)
	<ldexp+?>: set.x32 sp(2)
	cmplStd/lib/math/Math.ci:373: (2 bytes): x: uint64 := Bits.fromFloat64(f)
	<ldexp+?>: dup.x64 sp(2)
	cmplStd/lib/math/Math.ci:374: (45 bytes): exp := ((exp) + ((int32(x >> shift)) & mask) - (bias));
	<ldexp+?>: dup.x32 sp(3)
	<ldexp+?>: i32.2i64
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: load.c32 64
	<ldexp+?>: inc.i32(-11)
	<ldexp+?>: inc.i32(-1)
	<ldexp+?>: shr.b64
	<ldexp+?>: i64.2i32
	<ldexp+?>: i32.2i64
	<ldexp+?>: load.c64 2047
	<ldexp+?>: and.b64
	<ldexp+?>: load.c64 1023
	<ldexp+?>: sub.i64
	<ldexp+?>: add.i64
	<ldexp+?>: i64.2i32
	<ldexp+?>: set.x32 sp(4)
	cmplStd/lib/math/Math.ci:376: (32 bytes): if (exp < -1075)
	<ldexp+?>: dup.x32 sp(3)
	<ldexp+?>: load.c32 -1075
	<ldexp+?>: clt.i32
	<ldexp+?>: jz +24
	cmplStd/lib/math/Math.ci:378: (20 bytes): return .result := copysign(0.000000, f);
	<ldexp+?>: load.z128
	<ldexp+?>: dup.x64 sp(8)
	<ldexp+?>: load.ref <?> ;Math.copysign(x: float64, y: float64): float64
	<ldexp+?>: call
	<ldexp+?>: inc.sp(-16)
	<ldexp+?>: set.x64 sp(8)
	<ldexp+?>: inc.sp(-8)
	<ldexp+?>: ret
	cmplStd/lib/math/Math.ci:380: (41 bytes): if (exp > 1023)
	<ldexp+?>: dup.x32 sp(3)
	<ldexp+?>: load.c32 1023
	<ldexp+?>: cgt.i32
	<ldexp+?>: jz +33
	cmplStd/lib/math/Math.ci:382: (29 bytes): return .result := copysign(inf, f);
	<ldexp+?>: load.z64
	<ldexp+?>: load.f64 inf
	<ldexp+?>: dup.x64 sp(8)
	<ldexp+?>: load.ref <?> ;Math.copysign(x: float64, y: float64): float64
	<ldexp+?>: call
	<ldexp+?>: inc.sp(-16)
	<ldexp+?>: set.x64 sp(8)
	<ldexp+?>: inc.sp(-8)
	<ldexp+?>: ret
	cmplStd/lib/math/Math.ci:384: (9 bytes): m: float64 := 1
	<ldexp+?>: load.f64 1.000000
	cmplStd/lib/math/Math.ci:385: (40 bytes): if (exp < -1022)
	<ldexp+?>: dup.x32 sp(5)
	<ldexp+?>: load.c32 -1022
	<ldexp+?>: clt.i32
	<ldexp+?>: jz +32
	cmplStd/lib/math/Math.ci:387: (8 bytes): exp := exp + 53;
	<ldexp+?>: dup.x32 sp(5)
	<ldexp+?>: inc.i32(+53)
	<ldexp+?>: set.x32 sp(6)
	cmplStd/lib/math/Math.ci:388: (20 bytes): m := (1) / float64(1 << 53);
	<ldexp+?>: load.f64 1.000000
	<ldexp+?>: load.c32 1
	<ldexp+?>: b32.shl 0x35
	<ldexp+?>: i32.2f64
	<ldexp+?>: div.f64
	<ldexp+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:390: (29 bytes): x := x & ~(mask << shift);
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: load.c64 2047
	<ldexp+?>: load.c32 64
	<ldexp+?>: inc.i32(-11)
	<ldexp+?>: inc.i32(-1)
	<ldexp+?>: shl.b64
	<ldexp+?>: cmt.b64
	<ldexp+?>: and.b64
	<ldexp+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:391: (26 bytes): x := x | uint64(exp + bias) << shift;
	<ldexp+?>: dup.x64 sp(2)
	<ldexp+?>: dup.x32 sp(7)
	<ldexp+?>: inc.i32(+1023)
	<ldexp+?>: i32.2i64
	<ldexp+?>: load.c32 64
	<ldexp+?>: inc.i32(-11)
	<ldexp+?>: inc.i32(-1)
	<ldexp+?>: shl.b64
	<ldexp+?>: or.b64
	<ldexp+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:392: (12 bytes): return .result := m * Bits.asFloat64(x);
	<ldexp+?>: dup.x64 sp(0)
	<ldexp+?>: dup.x64 sp(4)
	<ldexp+?>: mul.f64
	<ldexp+?>: set.x64 sp(10)
	<ldexp+?>: inc.sp(-16)
	<ldexp+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:783: referenced as `ldexp`
	cmplStd/lib/math/Math.ci:781: referenced as `ldexp`
	cmplStd/lib/math/Math.ci:683: referenced as `ldexp`
	cmplStd/lib/math/Math.ci:517: referenced as `ldexp`
}
Math.log(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 298
.name: 'log'
.file: 'cmplStd/lib/math/Math.ci:397'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the natural logarithm of the argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.log)) != null) {
		return .result := float64.log(x);
	}
	if (x <= (0)) {
		if (x == (0)) {
			return .result := -inf;
		}
		return .result := nan;
	}
	exp: int32;
	x := frexp(x, &exp);
	for ( ; x < 0.500000; ) {
		x := x * (2);
		exp := exp - 1;
	}
	if (x < sqrto2) {
		x := x * (2);
		exp := exp - 1;
	}
	z: float64 := (x - (1)) / (x + (1));
	zsq: float64 := z * z;
	p: float64 := eval(zsq, p0, p1, p2, p3);
	q: float64 := eval(zsq, q0, q1, q2 + zsq);
	return .result := p / q * z + (exp) * log2;
}
.instructions: (298 bytes)
	cmplStd/lib/math/Math.ci:400: (9 bytes): return .result := float64.log(x);
	<log>  : dup.x64 sp(1)
	<log+?>: nfc(45) ;float64.log(x: float64): float64
	<log+?>: set.x64 sp(5)
	<log+?>: ret
	cmplStd/lib/math/Math.ci:418: (40 bytes): if (x <= (0))
	<log+?>: dup.x64 sp(1)
	<log+?>: load.z64
	<log+?>: cgt.f64
	<log+?>: jnz +36
	cmplStd/lib/math/Math.ci:419: (20 bytes): if (x == (0))
	<log+?>: dup.x64 sp(1)
	<log+?>: load.z64
	<log+?>: ceq.f64
	<log+?>: jz +16
	cmplStd/lib/math/Math.ci:420: (12 bytes): return .result := -inf;
	<log+?>: load.f64 -inf
	<log+?>: set.x64 sp(5)
	<log+?>: ret
	cmplStd/lib/math/Math.ci:422: (12 bytes): return .result := nan;
	<log+?>: load.f64 -nan
	<log+?>: set.x64 sp(5)
	<log+?>: ret
	cmplStd/lib/math/Math.ci:425: (1 byte): exp: int32
	<log+?>: load.z32
	cmplStd/lib/math/Math.ci:426: (19 bytes): x := frexp(x, &exp);
	<log+?>: load.z64
	<log+?>: dup.x64 sp(4)
	<log+?>: load.sp(+16)
	<log+?>: load.ref <?> ;Math.frexp(f: float64, exp: int32): float64
	<log+?>: call
	<log+?>: inc.sp(-12)
	<log+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:427: (38 bytes): for ( ; x < 0.500000; )
	<log+?>: jmp +22
	cmplStd/lib/math/Math.ci:428: (14 bytes): x := x * (2);
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 2.000000
	<log+?>: mul.f64
	<log+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:429: (4 bytes): exp := exp - 1;
	<log+?>: inc.i32(-1)
	cmplStd/lib/math/Math.ci:427: (16 bytes): x < 0.500000
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 0.500000
	<log+?>: clt.f64
	<log+?>: jnz -30
	cmplStd/lib/math/Math.ci:431: (34 bytes): if (x < sqrto2)
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 0.707107
	<log+?>: clt.f64
	<log+?>: jz +22
	cmplStd/lib/math/Math.ci:432: (14 bytes): x := x * (2);
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 2.000000
	<log+?>: mul.f64
	<log+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:433: (4 bytes): exp := exp - 1;
	<log+?>: inc.i32(-1)
	cmplStd/lib/math/Math.ci:436: (25 bytes): z: float64 := (x - (1)) / (x + (1))
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 1.000000
	<log+?>: sub.f64
	<log+?>: dup.x64 sp(4)
	<log+?>: load.f64 1.000000
	<log+?>: add.f64
	<log+?>: div.f64
	cmplStd/lib/math/Math.ci:437: (5 bytes): zsq: float64 := z * z
	<log+?>: dup.x64 sp(0)
	<log+?>: dup.x64 sp(2)
	<log+?>: mul.f64
	cmplStd/lib/math/Math.ci:438: (56 bytes): p: float64 := eval(zsq, p0, p1, p2, p3)
	<log+?>: dup.x64 sp(0)
	<log+?>: load.f64 -24.013918
	<log+?>: dup.x64 sp(2)
	<log+?>: dup.x64 sp(4)
	<log+?>: load.f64 30.957293
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 -9.637691
	<log+?>: dup.x64 sp(6)
	<log+?>: load.f64 0.421087
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: set.x64 sp(2)
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:439: (42 bytes): q: float64 := eval(zsq, q0, q1, q2 + zsq)
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 -12.006959
	<log+?>: dup.x64 sp(2)
	<log+?>: load.f64 19.480966
	<log+?>: dup.x64 sp(6)
	<log+?>: load.f64 -8.911109
	<log+?>: dup.x64 sp(14)
	<log+?>: add.f64
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:440: (29 bytes): return .result := p / q * z + (exp) * log2;
	<log+?>: dup.x64 sp(2)
	<log+?>: dup.x64 sp(2)
	<log+?>: div.f64
	<log+?>: dup.x64 sp(8)
	<log+?>: mul.f64
	<log+?>: dup.x32 sp(10)
	<log+?>: i32.2f64
	<log+?>: load.f64 0.693147
	<log+?>: mul.f64
	<log+?>: add.f64
	<log+?>: set.x64 sp(14)
	<log+?>: inc.sp(-36)
	<log+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:40: referenced as `log`
	cmplStd/lib/math/Complex.ci:105: referenced as `log`
	cmplStd/lib/math/Complex.ci:99: referenced as `log`
	cmplStd/lib/math/Math.ci:1047: referenced as `log`
	cmplStd/lib/math/Math.ci:1047: referenced as `log`
	cmplStd/lib/math/Math.ci:1034: referenced as `log`
	cmplStd/lib/math/Math.ci:1021: referenced as `log`
	cmplStd/lib/math/Math.ci:998: referenced as `log`
	cmplStd/lib/math/Math.ci:959: referenced as `log`
	cmplStd/lib/math/Math.ci:926: referenced as `log`
	cmplStd/lib/math/Math.ci:654: referenced as `log`
	cmplStd/lib/math/Math.ci:636: referenced as `log`
	cmplStd/lib/math/Math.ci:460: referenced as `log`
	cmplStd/lib/math/Math.ci:460: referenced as `log`
	cmplStd/lib/math/Math.ci:457: referenced as `log`
	cmplStd/lib/math/Math.ci:454: referenced as `log`
	cmplStd/lib/math/Math.ci:450: referenced as `log`
}
Math.log(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'log'
.file: 'cmplStd/lib/math/Math.ci:444'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the natural logarithm of the argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.log)) != null) {
		return .result := float32.log(x);
	}
	return .result := float32(log(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:447: (9 bytes): return .result := float32.log(x);
	<log>  : dup.x32 sp(1)
	<log+?>: nfc(37) ;float32.log(x: float32): float32
	<log+?>: set.x32 sp(3)
	<log+?>: ret
	cmplStd/lib/math/Math.ci:450: (18 bytes): return .result := float32(log(float64(x)));
	<log+?>: load.z64
	<log+?>: dup.x32 sp(3)
	<log+?>: f32.2f64
	<log+?>: load.ref <?> ;Math.log(x: float64): float64
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: f64.2f32
	<log+?>: set.x32 sp(3)
	<log+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:49: referenced as `log`
}
Math.log2(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'log2'
.file: 'cmplStd/lib/math/Math.ci:454'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the base 2 logarithm of the argument `x`.'
.value: log(x) / ln2
.usages:
}
Math.log10(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'log10'
.file: 'cmplStd/lib/math/Math.ci:457'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the base 10 logarithm of the argument `x`.'
.value: log(x) / ln10
.usages:
}
Math.log(x: float64, base: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'log'
.file: 'cmplStd/lib/math/Math.ci:460'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.param base: float64 (size: 8, cast: f64)
.doc: 'Returns the logarithm of the specified `base` of the argument `x`.'
.value: log(x) / log(base)
.usages:
}
Math.exp(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 297
.name: 'exp'
.file: 'cmplStd/lib/math/Math.ci:465'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the base-e exponential: $ e^x $.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.exp)) != null) {
		return .result := float64.exp(x);
	}
	if (isNan(x)) {
		return .result := x;
	}
	if (x > MAXLOG) {
		return .result := inf;
	}
	if (x < MINLOG) {
		return .result := 0;
	}
	px: float64 := floor(LOG2E * x + 0.500000);
	x := x - px * c1;
	x := x - px * c2;
	xx: float64 := x * x;
	p: float64 := x * eval(xx, p2, p1, p0);
	q: float64 := eval(xx, q3, q2, q1, q0);
	return .result := ldexp((1) + (2) * p / (q - p), px);
}
.instructions: (297 bytes)
	cmplStd/lib/math/Math.ci:468: (9 bytes): return .result := float64.exp(x);
	<exp>  : dup.x64 sp(1)
	<exp+?>: nfc(46) ;float64.exp(x: float64): float64
	<exp+?>: set.x64 sp(5)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:489: (21 bytes): if (isNan(x))
	<exp+?>: load.z32
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.ref <?> ;Math.isNan(x: float64): bool
	<exp+?>: call
	<exp+?>: inc.sp(-8)
	<exp+?>: jz +8
	cmplStd/lib/math/Math.ci:490: (4 bytes): return .result := x;
	<exp+?>: mov.x64 sp(3, 1)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:492: (28 bytes): if (x > MAXLOG)
	<exp+?>: dup.x64 sp(1)
	<exp+?>: load.f64 708.396419
	<exp+?>: cgt.f64
	<exp+?>: jz +16
	cmplStd/lib/math/Math.ci:493: (12 bytes): return .result := inf;
	<exp+?>: load.f64 inf
	<exp+?>: set.x64 sp(5)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:496: (20 bytes): if (x < MINLOG)
	<exp+?>: dup.x64 sp(1)
	<exp+?>: load.f64 -708.396419
	<exp+?>: clt.f64
	<exp+?>: jz +8
	cmplStd/lib/math/Math.ci:497: (4 bytes): return .result := 0;
	<exp+?>: load.z64
	<exp+?>: set.x64 sp(5)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:505: (33 bytes): px: float64 := floor(LOG2E * x + 0.500000)
	<exp+?>: load.z64
	<exp+?>: load.f64 1.442695
	<exp+?>: dup.x64 sp(5)
	<exp+?>: mul.f64
	<exp+?>: load.f64 0.500000
	<exp+?>: add.f64
	<exp+?>: load.ref <?> ;Math.floor(x: float64): float64
	<exp+?>: call
	<exp+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:506: (17 bytes): x := x - px * c1;
	<exp+?>: dup.x64 sp(3)
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 0.693146
	<exp+?>: mul.f64
	<exp+?>: sub.f64
	<exp+?>: set.x64 sp(5)
	cmplStd/lib/math/Math.ci:507: (17 bytes): x := x - px * c2;
	<exp+?>: dup.x64 sp(3)
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 0.000001
	<exp+?>: mul.f64
	<exp+?>: sub.f64
	<exp+?>: set.x64 sp(5)
	cmplStd/lib/math/Math.ci:512: (5 bytes): xx: float64 := x * x
	<exp+?>: dup.x64 sp(3)
	<exp+?>: dup.x64 sp(5)
	<exp+?>: mul.f64
	cmplStd/lib/math/Math.ci:513: (42 bytes): p: float64 := x * eval(xx, p2, p1, p0)
	<exp+?>: dup.x64 sp(5)
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 1.000000
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 0.030299
	<exp+?>: dup.x64 sp(6)
	<exp+?>: load.f64 0.000126
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: set.x64 sp(2)
	<exp+?>: mul.f64
	cmplStd/lib/math/Math.ci:514: (56 bytes): q: float64 := eval(xx, q3, q2, q1, q0)
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 2.000000
	<exp+?>: dup.x64 sp(2)
	<exp+?>: dup.x64 sp(4)
	<exp+?>: load.f64 0.227266
	<exp+?>: dup.x64 sp(2)
	<exp+?>: load.f64 0.002524
	<exp+?>: dup.x64 sp(6)
	<exp+?>: load.f64 0.000003
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: set.x64 sp(2)
	<exp+?>: mul.f64
	<exp+?>: add.f64
	<exp+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:517: (49 bytes): return .result := ldexp((1) + (2) * p / (q - p), px);
	<exp+?>: load.z64
	<exp+?>: load.f64 1.000000
	<exp+?>: load.f64 2.000000
	<exp+?>: dup.x64 sp(8)
	<exp+?>: mul.f64
	<exp+?>: dup.x64 sp(6)
	<exp+?>: dup.x64 sp(10)
	<exp+?>: sub.f64
	<exp+?>: div.f64
	<exp+?>: add.f64
	<exp+?>: dup.x64 sp(10)
	<exp+?>: f64.2i32
	<exp+?>: load.ref <?> ;Math.ldexp(f: float64, exp: int32): float64
	<exp+?>: call
	<exp+?>: inc.sp(-12)
	<exp+?>: set.x64 sp(13)
	<exp+?>: inc.sp(-32)
	<exp+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:41: referenced as `exp`
	cmplStd/lib/math/Complex.ci:106: referenced as `exp`
	cmplStd/lib/math/Complex.ci:96: referenced as `exp`
	cmplStd/lib/math/Complex.ci:96: referenced as `exp`
	cmplStd/lib/math/Math.ci:995: referenced as `exp`
	cmplStd/lib/math/Math.ci:953: referenced as `exp`
	cmplStd/lib/math/Math.ci:953: referenced as `exp`
	cmplStd/lib/math/Math.ci:920: referenced as `exp`
	cmplStd/lib/math/Math.ci:920: referenced as `exp`
	cmplStd/lib/math/Math.ci:654: referenced as `exp`
	cmplStd/lib/math/Math.ci:636: referenced as `exp`
	cmplStd/lib/math/Math.ci:527: referenced as `exp`
}
Math.exp(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'exp'
.file: 'cmplStd/lib/math/Math.ci:521'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the base-e exponential: $ e^x $.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.exp)) != null) {
		return .result := float32.exp(x);
	}
	return .result := float32(exp(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:524: (9 bytes): return .result := float32.exp(x);
	<exp>  : dup.x32 sp(1)
	<exp+?>: nfc(38) ;float32.exp(x: float32): float32
	<exp+?>: set.x32 sp(3)
	<exp+?>: ret
	cmplStd/lib/math/Math.ci:527: (18 bytes): return .result := float32(exp(float64(x)));
	<exp+?>: load.z64
	<exp+?>: dup.x32 sp(3)
	<exp+?>: f32.2f64
	<exp+?>: load.ref <?> ;Math.exp(x: float64): float64
	<exp+?>: call
	<exp+?>: inc.sp(-8)
	<exp+?>: f64.2f32
	<exp+?>: set.x32 sp(3)
	<exp+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:50: referenced as `exp`
}
Math.sqrt(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 448
.name: 'sqrt'
.file: 'cmplStd/lib/math/Math.ci:532'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the square root of the parameter `x`: $\sqrt{x}$.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.sqrt)) != null) {
		return .result := float64.sqrt(x);
	}
	if (x == (0) || isNan(x) || isInf(x, 1)) {
		return .result := x;
	}
	if (x < (0)) {
		return .result := nan;
	}
	mask: typename := 2047;
	shift: typename := 64 - 11 - 1;
	bias: typename := 1023;
	ix: uint64 := Bits.fromFloat64(x);
	exp: int32 := int32((ix >> shift) & mask);
	if (exp == 0) {
		for ( ; (ix & (1 << shift)) == (0); ) {
			ix := ix << 1;
			exp := exp - 1;
		}
		exp := exp + 1;
	}
	exp := exp - bias;
	ix := ix & ~(mask << shift);
	ix := ix | 1 << shift;
	if ((exp & 1) == 1) {
		ix := ix << 1;
	}
	exp := exp >> 1;
	ix := ix << 1;
	s: uint64 := 0;
	q: uint64 := 0;
	r: uint64 := 1 << (shift + 1);
	for ( ; r != (0); ) {
		t: uint64 := s + r;
		if (t <= ix) {
			s := t + r;
			ix := ix - t;
			q := q + r;
		}
		ix := ix << 1;
		r := r >> 1;
	}
	if (ix != (0)) {
		q := q + (q & (1));
	}
	ix := (q >> 1) + (uint64(exp - 1 + bias) << shift);
	return .result := Bits.asFloat64(ix);
}
.instructions: (448 bytes)
	cmplStd/lib/math/Math.ci:535: (9 bytes): return .result := float64.sqrt(x);
	<sqrt>  : dup.x64 sp(1)
	<sqrt+?>: nfc(48) ;float64.sqrt(x: float64): float64
	<sqrt+?>: set.x64 sp(5)
	<sqrt+?>: ret
	cmplStd/lib/math/Math.ci:544: (63 bytes): if (x == (0) || isNan(x) || isInf(x, 1))
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.z64
	<sqrt+?>: ceq.f64
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: jnz +21
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: load.z32
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: load.ref <?> ;Math.isNan(x: float64): bool
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-8)
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: jnz +26
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: load.z32
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: load.c32 1
	<sqrt+?>: load.ref <?> ;Math.isInf(x: float64, sign: int32): bool
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-12)
	<sqrt+?>: jz +8
	cmplStd/lib/math/Math.ci:545: (4 bytes): return .result := x;
	<sqrt+?>: mov.x64 sp(3, 1)
	<sqrt+?>: ret
	cmplStd/lib/math/Math.ci:547: (20 bytes): if (x < (0))
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.z64
	<sqrt+?>: clt.f64
	<sqrt+?>: jz +16
	cmplStd/lib/math/Math.ci:548: (12 bytes): return .result := nan;
	<sqrt+?>: load.f64 -nan
	<sqrt+?>: set.x64 sp(5)
	<sqrt+?>: ret
	cmplStd/lib/math/Math.ci:555: (2 bytes): ix: uint64 := Bits.fromFloat64(x)
	<sqrt+?>: dup.x64 sp(1)
	cmplStd/lib/math/Math.ci:557: (27 bytes): exp: int32 := int32((ix >> shift) & mask)
	<sqrt+?>: dup.x64 sp(0)
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shr.b64
	<sqrt+?>: load.c64 2047
	<sqrt+?>: and.b64
	<sqrt+?>: i64.2i32
	cmplStd/lib/math/Math.ci:558: (62 bytes): if (exp == 0)
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: load.z32
	<sqrt+?>: ceq.i32
	<sqrt+?>: jz +58
	cmplStd/lib/math/Math.ci:559: (50 bytes): for ( ; (ix & (1 << shift)) == (0); )
	<sqrt+?>: jmp +18
	cmplStd/lib/math/Math.ci:560: (10 bytes): ix := ix << 1;
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shl.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:561: (4 bytes): exp := exp - 1;
	<sqrt+?>: inc.i32(-1)
	cmplStd/lib/math/Math.ci:559: (32 bytes): (ix & (1 << shift)) == (0)
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c64 1
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shl.b64
	<sqrt+?>: and.b64
	<sqrt+?>: load.z64
	<sqrt+?>: ceq.i64
	<sqrt+?>: jnz -42
	cmplStd/lib/math/Math.ci:563: (4 bytes): exp := exp + 1;
	<sqrt+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:565: (4 bytes): exp := exp - bias;
	<sqrt+?>: inc.i32(-1023)
	cmplStd/lib/math/Math.ci:566: (29 bytes): ix := ix & ~(mask << shift);
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c64 2047
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shl.b64
	<sqrt+?>: cmt.b64
	<sqrt+?>: and.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:567: (28 bytes): ix := ix | 1 << shift;
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c64 1
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shl.b64
	<sqrt+?>: or.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:568: (24 bytes): if ((exp & 1) == 1)
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: b32.and 0x01
	<sqrt+?>: load.c32 1
	<sqrt+?>: ceq.i32
	<sqrt+?>: jz +14
	cmplStd/lib/math/Math.ci:569: (10 bytes): ix := ix << 1;
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shl.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:571: (2 bytes): exp := exp >> 1;
	<sqrt+?>: b32.sar 0x01
	cmplStd/lib/math/Math.ci:573: (10 bytes): ix := ix << 1;
	<sqrt+?>: dup.x64 sp(1)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shl.b64
	<sqrt+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:574: (1 byte): s: uint64 := 0
	<sqrt+?>: load.z128
	cmplStd/lib/math/Math.ci:576: (27 bytes): r: uint64 := 1 << (shift + 1)
	<sqrt+?>: load.c64 1
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: inc.i32(+1)
	<sqrt+?>: shl.b64
	cmplStd/lib/math/Math.ci:577: (71 bytes): for ( ; r != (0); )
	<sqrt+?>: jmp +63
	cmplStd/lib/math/Math.ci:578: (5 bytes): t: uint64 := s + r
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: add.i64
	cmplStd/lib/math/Math.ci:579: (30 bytes): if (t <= ix)
	<sqrt+?>: dup.x64 sp(0)
	<sqrt+?>: dup.x64 sp(11)
	<sqrt+?>: cgt.u64
	<sqrt+?>: jnz +25
	cmplStd/lib/math/Math.ci:580: (7 bytes): s := t + r;
	<sqrt+?>: dup.x64 sp(0)
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: add.i64
	<sqrt+?>: set.x64 sp(8)
	cmplStd/lib/math/Math.ci:581: (7 bytes): ix := ix - t;
	<sqrt+?>: dup.x64 sp(9)
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: sub.i64
	<sqrt+?>: set.x64 sp(11)
	cmplStd/lib/math/Math.ci:582: (7 bytes): q := q + r;
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: add.i64
	<sqrt+?>: set.x64 sp(6)
	cmplStd/lib/math/Math.ci:584: (10 bytes): ix := ix << 1;
	<sqrt+?>: dup.x64 sp(9)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shl.b64
	<sqrt+?>: set.x64 sp(11)
	cmplStd/lib/math/Math.ci:585: (10 bytes): r := r >> 1;
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shr.b64
	<sqrt+?>: set.x64 sp(4)
	<sqrt+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:577: (8 bytes): r != (0)
	<sqrt+?>: dup.x64 sp(0)
	<sqrt+?>: load.z64
	<sqrt+?>: ceq.i64
	<sqrt+?>: jz -63
	cmplStd/lib/math/Math.ci:588: (25 bytes): if (ix != (0))
	<sqrt+?>: dup.x64 sp(7)
	<sqrt+?>: load.z64
	<sqrt+?>: ceq.i64
	<sqrt+?>: jnz +21
	cmplStd/lib/math/Math.ci:589: (17 bytes): q := q + (q & (1));
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: dup.x64 sp(4)
	<sqrt+?>: load.c64 1
	<sqrt+?>: and.b64
	<sqrt+?>: add.i64
	<sqrt+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:591: (36 bytes): ix := (q >> 1) + (uint64(exp - 1 + bias) << shift);
	<sqrt+?>: dup.x64 sp(2)
	<sqrt+?>: load.c32 1
	<sqrt+?>: shr.b64
	<sqrt+?>: dup.x32 sp(8)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: inc.i32(+1023)
	<sqrt+?>: i32.2i64
	<sqrt+?>: load.c32 64
	<sqrt+?>: inc.i32(-11)
	<sqrt+?>: inc.i32(-1)
	<sqrt+?>: shl.b64
	<sqrt+?>: add.i64
	<sqrt+?>: set.x64 sp(9)
	cmplStd/lib/math/Math.ci:592: (8 bytes): return .result := Bits.asFloat64(ix);
	<sqrt+?>: mov.x64 sp(12, 7)
	<sqrt+?>: inc.sp(-36)
	<sqrt+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:43: referenced as `sqrt`
	cmplStd/lib/math/Easing.ci:42: referenced as `sqrt`
	cmplStd/lib/math/Complex.ci:79: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:1047: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:1047: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:1034: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:959: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:956: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:926: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:923: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:652: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:647: referenced as `sqrt`
	cmplStd/lib/math/Math.ci:602: referenced as `sqrt`
}
Math.sqrt(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'sqrt'
.file: 'cmplStd/lib/math/Math.ci:596'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the square root of the parameter `x`: $\sqrt{x}$.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.sqrt)) != null) {
		return .result := float32.sqrt(x);
	}
	return .result := float32(sqrt(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:599: (9 bytes): return .result := float32.sqrt(x);
	<sqrt>  : dup.x32 sp(1)
	<sqrt+?>: nfc(40) ;float32.sqrt(x: float32): float32
	<sqrt+?>: set.x32 sp(3)
	<sqrt+?>: ret
	cmplStd/lib/math/Math.ci:602: (18 bytes): return .result := float32(sqrt(float64(x)));
	<sqrt+?>: load.z64
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: f32.2f64
	<sqrt+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-8)
	<sqrt+?>: f64.2f32
	<sqrt+?>: set.x32 sp(3)
	<sqrt+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:52: referenced as `sqrt`
	cmplStd/lib/math/Vector4f.ci:137: referenced as `sqrt`
}
Math.pow(x: float64, y: float64): float64: function {
.kind: static function
.base: `function`
.size: 590
.name: 'pow'
.file: 'cmplStd/lib/math/Math.ci:607'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: 'Returns `x` raised to the power of `y`: $ x^y $.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.pow)) != null) {
		return .result := float64.pow(x, y);
	}
	if (y == (0)) {
		return .result := 1;
	}
	flip: int32 := 0;
	if (y < (0)) {
		y := -y;
		flip := 1;
	}
	ye: float64;
	xy: float64 := 1;
	y1: float64 := modf(y, &ye);
	if (y1 != 0.000000) {
		if (x <= 0.000000) {
			if (x == (0) && !(flip)) {
				return .result := 0;
			}
			return .result := nan;
		}
		if (y1 > 0.500000) {
			y1 := y1 - (1);
			ye := ye + (1);
		}
		xy := exp(y1 * log(x));
	}
	if (ye > (2147483647)) {
		if (x <= (0)) {
			if (x == (0) && !(flip)) {
				return .result := 0;
			}
			return .result := nan;
		}
		if (flip) {
			if (y == 0.500000) {
				return .result := (1) / sqrt(x);
			}
			y := -y;
		}
		else if (y == 0.500000) {
			return .result := sqrt(x);
		}
		return .result := exp(y * log(x));
	}
	ex: int32;
	x := frexp(x, &ex);
	ey: int32 := 0;
	i: int64 := ye;
	if (i) {
		for ( ; ; ) {
			if (i & (1)) {
				xy := xy * x;
				ey := ey + ex;
			}
			i := i >> 1;
			if (i == (0)) {
				break;
			}
			x := x * x;
			ex := ex << 1;
			if (x < 0.500000) {
				x := x + x;
				ex := ex - 1;
			}
		}
	}
	if (flip) {
		xy := 1.000000 / xy;
		ey := -ey;
	}
	return .result := ldexp(xy, ey);
}
.instructions: (590 bytes)
	cmplStd/lib/math/Math.ci:610: (11 bytes): return .result := float64.pow(x, y);
	<pow>  : dup.x64 sp(3)
	<pow+?>: dup.x64 sp(3)
	<pow+?>: nfc(47) ;float64.pow(x: float64, y: float64): float64
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:613: (20 bytes): if (y == (0))
	<pow+?>: dup.x64 sp(1)
	<pow+?>: load.z64
	<pow+?>: ceq.f64
	<pow+?>: jz +16
	cmplStd/lib/math/Math.ci:614: (12 bytes): return .result := 1;
	<pow+?>: load.f64 1.000000
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:617: (1 byte): flip: int32 := 0
	<pow+?>: load.z32
	cmplStd/lib/math/Math.ci:618: (20 bytes): if (y < (0))
	<pow+?>: dup.x64 sp(2)
	<pow+?>: load.z64
	<pow+?>: clt.f64
	<pow+?>: jz +16
	cmplStd/lib/math/Math.ci:619: (5 bytes): y := -y;
	<pow+?>: dup.x64 sp(2)
	<pow+?>: neg.f64
	<pow+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:620: (7 bytes): flip := 1;
	<pow+?>: load.c32 1
	<pow+?>: set.x32 sp(1)
	cmplStd/lib/math/Math.ci:622: (1 byte): ye: float64
	<pow+?>: load.z64
	cmplStd/lib/math/Math.ci:623: (9 bytes): xy: float64 := 1
	<pow+?>: load.f64 1.000000
	cmplStd/lib/math/Math.ci:624: (17 bytes): y1: float64 := modf(y, &ye)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(8)
	<pow+?>: load.sp(+24)
	<pow+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-12)
	cmplStd/lib/math/Math.ci:625: (131 bytes): if (y1 != 0.000000)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.z64
	<pow+?>: ceq.f64
	<pow+?>: jnz +127
	cmplStd/lib/math/Math.ci:626: (54 bytes): if (x <= 0.000000)
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: cgt.f64
	<pow+?>: jnz +50
	cmplStd/lib/math/Math.ci:627: (30 bytes): if (x == (0) && !(flip))
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: ceq.f64
	<pow+?>: dup.x32 sp(0)
	<pow+?>: jz +12
	<pow+?>: inc.sp(-4)
	<pow+?>: dup.x32 sp(6)
	<pow+?>: i32.2bool
	<pow+?>: not.b32
	<pow+?>: jz +12
	cmplStd/lib/math/Math.ci:628: (8 bytes): return .result := 0;
	<pow+?>: load.z64
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:630: (16 bytes): return .result := nan;
	<pow+?>: load.f64 -nan
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:632: (40 bytes): if (y1 > 0.500000)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.f64 0.500000
	<pow+?>: cgt.f64
	<pow+?>: jz +28
	cmplStd/lib/math/Math.ci:633: (10 bytes): y1 := y1 - (1);
	<pow+?>: load.f64 1.000000
	<pow+?>: sub.f64
	cmplStd/lib/math/Math.ci:634: (14 bytes): ye := ye + (1);
	<pow+?>: dup.x64 sp(4)
	<pow+?>: load.f64 1.000000
	<pow+?>: add.f64
	<pow+?>: set.x64 sp(6)
	cmplStd/lib/math/Math.ci:636: (29 bytes): xy := exp(y1 * log(x));
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(2)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(16)
	<pow+?>: load.ref <?> ;Math.log(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: load.ref <?> ;Math.exp(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:638: (201 bytes): if (ye > (2147483647))
	<pow+?>: dup.x64 sp(4)
	<pow+?>: load.f64 2147483647.000000
	<pow+?>: cgt.f64
	<pow+?>: jz +189
	cmplStd/lib/math/Math.ci:639: (54 bytes): if (x <= (0))
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: cgt.f64
	<pow+?>: jnz +50
	cmplStd/lib/math/Math.ci:640: (30 bytes): if (x == (0) && !(flip))
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: ceq.f64
	<pow+?>: dup.x32 sp(0)
	<pow+?>: jz +12
	<pow+?>: inc.sp(-4)
	<pow+?>: dup.x32 sp(6)
	<pow+?>: i32.2bool
	<pow+?>: not.b32
	<pow+?>: jz +12
	cmplStd/lib/math/Math.ci:641: (8 bytes): return .result := 0;
	<pow+?>: load.z64
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:643: (16 bytes): return .result := nan;
	<pow+?>: load.f64 -nan
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:645: (97 bytes): if (flip)
	<pow+?>: dup.x32 sp(6)
	<pow+?>: jz +59
	cmplStd/lib/math/Math.ci:646: (46 bytes): if (y == 0.500000)
	<pow+?>: dup.x64 sp(8)
	<pow+?>: load.f64 0.500000
	<pow+?>: ceq.f64
	<pow+?>: jz +34
	cmplStd/lib/math/Math.ci:647: (30 bytes): return .result := (1) / sqrt(x);
	<pow+?>: load.f64 1.000000
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(14)
	<pow+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: div.f64
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:649: (5 bytes): y := -y;
	<pow+?>: dup.x64 sp(8)
	<pow+?>: neg.f64
	<pow+?>: set.x64 sp(10)
	<pow+?>: jmp +40
	cmplStd/lib/math/Math.ci:651: (36 bytes): if (y == 0.500000)
	<pow+?>: dup.x64 sp(8)
	<pow+?>: load.f64 0.500000
	<pow+?>: ceq.f64
	<pow+?>: jz +24
	cmplStd/lib/math/Math.ci:652: (20 bytes): return .result := sqrt(x);
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(12)
	<pow+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:654: (34 bytes): return .result := exp(y * log(x));
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(10)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(16)
	<pow+?>: load.ref <?> ;Math.log(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: load.ref <?> ;Math.exp(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(14)
	<pow+?>: inc.sp(-28)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:657: (1 byte): ex: int32
	<pow+?>: load.z32
	cmplStd/lib/math/Math.ci:658: (19 bytes): x := frexp(x, &ex);
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(13)
	<pow+?>: load.sp(+16)
	<pow+?>: load.ref <?> ;Math.frexp(f: float64, exp: int32): float64
	<pow+?>: call
	<pow+?>: inc.sp(-12)
	<pow+?>: set.x64 sp(13)
	cmplStd/lib/math/Math.ci:659: (1 byte): ey: int32 := 0
	<pow+?>: load.z32
	cmplStd/lib/math/Math.ci:660: (3 bytes): i: int64 := ye
	<pow+?>: dup.x64 sp(6)
	<pow+?>: f64.2i64
	cmplStd/lib/math/Math.ci:661: (108 bytes): if (i)
	<pow+?>: dup.x64 sp(0)
	<pow+?>: i64.2bool
	<pow+?>: jz +105
	cmplStd/lib/math/Math.ci:662: (101 bytes): for ( ; ; )
	<pow+?>: jmp +97
	cmplStd/lib/math/Math.ci:663: (31 bytes): if (i & (1))
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.c64 1
	<pow+?>: and.b64
	<pow+?>: i64.2bool
	<pow+?>: jz +18
	cmplStd/lib/math/Math.ci:664: (7 bytes): xy := xy * x;
	<pow+?>: dup.x64 sp(6)
	<pow+?>: dup.x64 sp(16)
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(8)
	cmplStd/lib/math/Math.ci:665: (7 bytes): ey := ey + ex;
	<pow+?>: dup.x32 sp(2)
	<pow+?>: dup.x32 sp(4)
	<pow+?>: add.i32
	<pow+?>: set.x32 sp(3)
	cmplStd/lib/math/Math.ci:667: (6 bytes): i := i >> 1;
	<pow+?>: load.c32 1
	<pow+?>: sar.b64
	cmplStd/lib/math/Math.ci:668: (12 bytes): if (i == (0))
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.z64
	<pow+?>: ceq.i64
	<pow+?>: jz +8
	cmplStd/lib/math/Math.ci:669: (4 bytes): break;
	<pow+?>: jmp +52
	cmplStd/lib/math/Math.ci:671: (7 bytes): x := x * x;
	<pow+?>: dup.x64 sp(14)
	<pow+?>: dup.x64 sp(16)
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(16)
	cmplStd/lib/math/Math.ci:672: (6 bytes): ex := ex << 1;
	<pow+?>: dup.x32 sp(3)
	<pow+?>: b32.shl 0x01
	<pow+?>: set.x32 sp(4)
	cmplStd/lib/math/Math.ci:673: (31 bytes): if (x < 0.500000)
	<pow+?>: dup.x64 sp(14)
	<pow+?>: load.f64 0.500000
	<pow+?>: clt.f64
	<pow+?>: jz +19
	cmplStd/lib/math/Math.ci:674: (7 bytes): x := x + x;
	<pow+?>: dup.x64 sp(14)
	<pow+?>: dup.x64 sp(16)
	<pow+?>: add.f64
	<pow+?>: set.x64 sp(16)
	cmplStd/lib/math/Math.ci:675: (8 bytes): ex := ex - 1;
	<pow+?>: dup.x32 sp(3)
	<pow+?>: inc.i32(-1)
	<pow+?>: set.x32 sp(4)
	:: (4 bytes)
	<pow+?>: jmp -93
	cmplStd/lib/math/Math.ci:679: (25 bytes): if (flip)
	<pow+?>: dup.x32 sp(10)
	<pow+?>: jz +23
	cmplStd/lib/math/Math.ci:680: (14 bytes): xy := 1.000000 / xy;
	<pow+?>: load.f64 1.000000
	<pow+?>: dup.x64 sp(8)
	<pow+?>: div.f64
	<pow+?>: set.x64 sp(8)
	cmplStd/lib/math/Math.ci:681: (5 bytes): ey := -ey;
	<pow+?>: dup.x32 sp(2)
	<pow+?>: neg.i32
	<pow+?>: set.x32 sp(3)
	cmplStd/lib/math/Math.ci:683: (22 bytes): return .result := ldexp(xy, ey);
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(8)
	<pow+?>: dup.x32 sp(6)
	<pow+?>: load.ref <?> ;Math.ldexp(f: float64, exp: int32): float64
	<pow+?>: call
	<pow+?>: inc.sp(-12)
	<pow+?>: set.x64 sp(18)
	<pow+?>: inc.sp(-44)
	<pow+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:42: referenced as `pow`
	cmplStd/lib/math/Easing.ci:49: referenced as `pow`
	cmplStd/lib/math/Easing.ci:32: referenced as `pow`
	cmplStd/lib/text/Format.ci:211: referenced as `pow`
	cmplStd/lib/math/Complex.ci:106: referenced as `pow`
	cmplStd/lib/math/Math.ci:693: referenced as `pow`
}
Math.pow(x: float32, y: float32): float32: function {
.kind: static function
.base: `function`
.size: 32
.name: 'pow'
.file: 'cmplStd/lib/math/Math.ci:687'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.doc: 'Returns `x` raised to the power of `y`: $ x^y $.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.pow)) != null) {
		return .result := float32.pow(x, y);
	}
	return .result := float32(pow(float64(x), float64(y)));
}
.instructions: (32 bytes)
	cmplStd/lib/math/Math.ci:690: (11 bytes): return .result := float32.pow(x, y);
	<pow>  : dup.x32 sp(2)
	<pow+?>: dup.x32 sp(2)
	<pow+?>: nfc(39) ;float32.pow(x: float32, y: float32): float32
	<pow+?>: set.x32 sp(4)
	<pow+?>: ret
	cmplStd/lib/math/Math.ci:693: (21 bytes): return .result := float32(pow(float64(x), float64(y)));
	<pow+?>: load.z64
	<pow+?>: dup.x32 sp(4)
	<pow+?>: f32.2f64
	<pow+?>: dup.x32 sp(5)
	<pow+?>: f32.2f64
	<pow+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-16)
	<pow+?>: f64.2f32
	<pow+?>: set.x32 sp(4)
	<pow+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:51: referenced as `pow`
}
Math.sincos(x: float64, quad: int32): float64: function {
.kind: static function
.base: `function`
.size: 357
.name: 'sincos'
.file: 'cmplStd/lib/math/Math.ci:698'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param quad: int32 (size: 4, cast: variable(i32))
.value: {
	if (x < (0)) {
		x := -x;
		quad := quad + 2;
	}
	y: float64;
	x := x * (2) / pi;
	if (x > (32764)) {
		e: float64;
		y := modf(x, &e);
		e := e + (quad);
		f: float64;
		modf(0.250000 * e, &f);
		quad := (e - (4) * f);
	}
	else {
		k: int32 := x;
		y := x - (k);
		quad := quad + k;
		quad := quad & 3;
	}
	if (quad & 1) {
		y := (1) - y;
	}
	if (quad > 1) {
		y := -y;
	}
	ysq: float64 := y * y;
	p: float64 := y * eval(ysq, p0, p1, p2, p3, p4);
	q: float64 := eval(ysq, q0, q1, q2, q3 + ysq);
	return .result := p / q;
}
.instructions: (357 bytes)
	cmplStd/lib/math/Math.ci:711: (21 bytes): if (x < (0))
	<sincos>  : dup.x64 sp(2)
	<sincos+?>: load.z64
	<sincos+?>: clt.f64
	<sincos+?>: jz +17
	cmplStd/lib/math/Math.ci:712: (5 bytes): x := -x;
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: neg.f64
	<sincos+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:713: (8 bytes): quad := quad + 2;
	<sincos+?>: dup.x32 sp(1)
	<sincos+?>: inc.i32(+2)
	<sincos+?>: set.x32 sp(2)
	cmplStd/lib/math/Math.ci:716: (1 byte): y: float64
	<sincos+?>: load.z64
	cmplStd/lib/math/Math.ci:717: (24 bytes): x := x * (2) / pi;
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 2.000000
	<sincos+?>: load.f64 3.141593
	<sincos+?>: div.f64
	<sincos+?>: mul.f64
	<sincos+?>: set.x64 sp(6)
	cmplStd/lib/math/Math.ci:718: (124 bytes): if (x > (32764))
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 32764.000000
	<sincos+?>: cgt.f64
	<sincos+?>: jz +84
	cmplStd/lib/math/Math.ci:719: (1 byte): e: float64
	<sincos+?>: load.z128
	cmplStd/lib/math/Math.ci:720: (18 bytes): y := modf(x, &e);
	<sincos+?>: dup.x64 sp(8)
	<sincos+?>: load.sp(+16)
	<sincos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sincos+?>: call
	<sincos+?>: inc.sp(-12)
	<sincos+?>: set.x64 sp(4)
	cmplStd/lib/math/Math.ci:721: (4 bytes): e := e + (quad);
	<sincos+?>: dup.x32 sp(5)
	<sincos+?>: i32.2f64
	<sincos+?>: add.f64
	cmplStd/lib/math/Math.ci:723: (1 byte): f: float64
	<sincos+?>: load.z128
	cmplStd/lib/math/Math.ci:724: (30 bytes): modf(0.250000 * e, &f);
	<sincos+?>: load.f64 0.250000
	<sincos+?>: dup.x64 sp(6)
	<sincos+?>: mul.f64
	<sincos+?>: load.sp(+16)
	<sincos+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<sincos+?>: call
	<sincos+?>: inc.sp(-12)
	<sincos+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:725: (18 bytes): quad := (e - (4) * f);
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 4.000000
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: mul.f64
	<sincos+?>: sub.f64
	<sincos+?>: f64.2i32
	<sincos+?>: set.x32 sp(8)
	<sincos+?>: inc.sp(-16)
	<sincos+?>: jmp +32
	cmplStd/lib/math/Math.ci:727: (3 bytes): k: int32 := x
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: f64.2i32
	cmplStd/lib/math/Math.ci:728: (8 bytes): y := x - (k);
	<sincos+?>: dup.x64 sp(5)
	<sincos+?>: dup.x32 sp(2)
	<sincos+?>: i32.2f64
	<sincos+?>: sub.f64
	<sincos+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:729: (7 bytes): quad := quad + k;
	<sincos+?>: dup.x32 sp(4)
	<sincos+?>: dup.x32 sp(1)
	<sincos+?>: add.i32
	<sincos+?>: set.x32 sp(5)
	cmplStd/lib/math/Math.ci:730: (6 bytes): quad := quad & 3;
	<sincos+?>: dup.x32 sp(4)
	<sincos+?>: b32.and 0x03
	<sincos+?>: set.x32 sp(5)
	<sincos+?>: inc.sp(-4)
	cmplStd/lib/math/Math.ci:732: (22 bytes): if (quad & 1)
	<sincos+?>: dup.x32 sp(3)
	<sincos+?>: b32.and 0x01
	<sincos+?>: jz +18
	cmplStd/lib/math/Math.ci:733: (14 bytes): y := (1) - y;
	<sincos+?>: load.f64 1.000000
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: sub.f64
	<sincos+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:735: (13 bytes): if (quad > 1)
	<sincos+?>: dup.x32 sp(3)
	<sincos+?>: load.c32 1
	<sincos+?>: cgt.i32
	<sincos+?>: jz +5
	cmplStd/lib/math/Math.ci:736: (1 byte): y := -y;
	<sincos+?>: neg.f64
	cmplStd/lib/math/Math.ci:739: (5 bytes): ysq: float64 := y * y
	<sincos+?>: dup.x64 sp(0)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: mul.f64
	cmplStd/lib/math/Math.ci:740: (76 bytes): p: float64 := y * eval(ysq, p0, p1, p2, p3, p4)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 13578840.978774
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 -4942908.100903
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 440103.053538
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 -13847.272500
	<sincos+?>: dup.x64 sp(6)
	<sincos+?>: load.f64 145.968841
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	<sincos+?>: mul.f64
	cmplStd/lib/math/Math.ci:741: (59 bytes): q: float64 := eval(ysq, q0, q1, q2, q3 + ysq)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 8644558.652923
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(4)
	<sincos+?>: load.f64 408179.225234
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: load.f64 9463.096102
	<sincos+?>: dup.x64 sp(6)
	<sincos+?>: load.f64 132.653491
	<sincos+?>: dup.x64 sp(20)
	<sincos+?>: add.f64
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	<sincos+?>: mul.f64
	<sincos+?>: add.f64
	<sincos+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:742: (12 bytes): return .result := p / q;
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: dup.x64 sp(2)
	<sincos+?>: div.f64
	<sincos+?>: set.x64 sp(14)
	<sincos+?>: inc.sp(-32)
	<sincos+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:939: referenced as `sincos`
	cmplStd/lib/math/Math.ci:906: referenced as `sincos`
}
Math.tancot(x: float64, flag: int32): float64: function {
.kind: static function
.base: `function`
.size: 447
.name: 'tancot'
.file: 'cmplStd/lib/math/Math.ci:746'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.param flag: int32 (size: 4, cast: variable(i32))
.value: {
	sign: float64 := 1;
	if (x < (0)) {
		x := -x;
		sign := (-1);
	}
	if (x > lossth) {
		return .result := 0;
	}
	y: float64 := floor(x / (pi / (4)));
	z: float64 := ldexp(y, -3);
	z := floor(z);
	z := y - ldexp(z, 3);
	j: int32 := z;
	if (j & 1) {
		j := j + 1;
		y := y + 1.000000;
	}
	z := ((x - y * dp1) - y * dp2) - y * dp3;
	zz: float64 := z * z;
	if (zz > 0.000000) {
		y := z + z * (zz * eval(zz, p2, p1, p0) / eval(zz, q4, q3, q2, q1, q0));
	}
	else {
		y := z;
	}
	if (j & 2) {
		if (flag) {
			y := -y;
		}
		else {
			y := (-1) / y;
		}
	}
	else if (flag) {
		y := (1) / y;
	}
	return .result := sign * y;
}
.instructions: (447 bytes)
	cmplStd/lib/math/Math.ci:766: (9 bytes): sign: float64 := 1
	<tancot>  : load.f64 1.000000
	cmplStd/lib/math/Math.ci:767: (24 bytes): if (x < (0))
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.z64
	<tancot+?>: clt.f64
	<tancot+?>: jz +20
	cmplStd/lib/math/Math.ci:768: (5 bytes): x := -x;
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: neg.f64
	<tancot+?>: set.x64 sp(6)
	cmplStd/lib/math/Math.ci:769: (11 bytes): sign := (-1);
	<tancot+?>: load.f64 -1.000000
	<tancot+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:772: (24 bytes): if (x > lossth)
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.f64 1073741824.000000
	<tancot+?>: cgt.f64
	<tancot+?>: jz +12
	cmplStd/lib/math/Math.ci:774: (8 bytes): return .result := 0;
	<tancot+?>: load.z64
	<tancot+?>: set.x64 sp(8)
	<tancot+?>: inc.sp(-8)
	<tancot+?>: ret
	cmplStd/lib/math/Math.ci:778: (33 bytes): y: float64 := floor(x / (pi / (4)))
	<tancot+?>: load.z64
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 3.141593
	<tancot+?>: load.f64 4.000000
	<tancot+?>: div.f64
	<tancot+?>: div.f64
	<tancot+?>: load.ref <?> ;Math.floor(x: float64): float64
	<tancot+?>: call
	<tancot+?>: inc.sp(-8)
	cmplStd/lib/math/Math.ci:781: (18 bytes): z: float64 := ldexp(y, -3)
	<tancot+?>: load.z64
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.c32 -3
	<tancot+?>: load.ref <?> ;Math.ldexp(f: float64, exp: int32): float64
	<tancot+?>: call
	<tancot+?>: inc.sp(-12)
	cmplStd/lib/math/Math.ci:782: (15 bytes): z := floor(z);
	<tancot+?>: load.z64
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.ref <?> ;Math.floor(x: float64): float64
	<tancot+?>: call
	<tancot+?>: inc.sp(-8)
	<tancot+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:783: (23 bytes): z := y - ldexp(z, 3);
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.z64
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.c32 3
	<tancot+?>: load.ref <?> ;Math.ldexp(f: float64, exp: int32): float64
	<tancot+?>: call
	<tancot+?>: inc.sp(-12)
	<tancot+?>: sub.f64
	<tancot+?>: set.x64 sp(2)
	cmplStd/lib/math/Math.ci:786: (3 bytes): j: int32 := z
	<tancot+?>: dup.x64 sp(0)
	<tancot+?>: f64.2i32
	cmplStd/lib/math/Math.ci:789: (26 bytes): if (j & 1)
	<tancot+?>: dup.x32 sp(0)
	<tancot+?>: b32.and 0x01
	<tancot+?>: jz +22
	cmplStd/lib/math/Math.ci:790: (4 bytes): j := j + 1;
	<tancot+?>: inc.i32(+1)
	cmplStd/lib/math/Math.ci:791: (14 bytes): y := y + 1.000000;
	<tancot+?>: dup.x64 sp(3)
	<tancot+?>: load.f64 1.000000
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(5)
	cmplStd/lib/math/Math.ci:794: (43 bytes): z := ((x - y * dp1) - y * dp2) - y * dp3;
	<tancot+?>: dup.x64 sp(9)
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: load.f64 0.785398
	<tancot+?>: mul.f64
	<tancot+?>: sub.f64
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: load.f64 0.000000
	<tancot+?>: mul.f64
	<tancot+?>: sub.f64
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: load.f64 0.000000
	<tancot+?>: mul.f64
	<tancot+?>: sub.f64
	<tancot+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:796: (5 bytes): zz: float64 := z * z
	<tancot+?>: dup.x64 sp(1)
	<tancot+?>: dup.x64 sp(3)
	<tancot+?>: mul.f64
	cmplStd/lib/math/Math.ci:797: (147 bytes): if (zz > 0.000000)
	<tancot+?>: dup.x64 sp(0)
	<tancot+?>: load.f64 0.000000
	<tancot+?>: cgt.f64
	<tancot+?>: jz +132
	cmplStd/lib/math/Math.ci:798: (124 bytes): y := z + z * (zz * eval(zz, p2, p1, p0) / eval(zz, q4, q3, q2, q1, q0));
	<tancot+?>: dup.x64 sp(3)
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 -17956525.197648
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.f64 1153516.648386
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 -13093.693918
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(2)
	<tancot+?>: mul.f64
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 -53869575.592945
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.f64 25008380.182336
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: dup.x64 sp(4)
	<tancot+?>: load.f64 -1320892.344402
	<tancot+?>: dup.x64 sp(2)
	<tancot+?>: load.f64 13681.296347
	<tancot+?>: dup.x64 sp(6)
	<tancot+?>: load.f64 1.000000
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(2)
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(2)
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(2)
	<tancot+?>: div.f64
	<tancot+?>: mul.f64
	<tancot+?>: add.f64
	<tancot+?>: set.x64 sp(7)
	<tancot+?>: jmp +7
	cmplStd/lib/math/Math.ci:800: (3 bytes): y := z;
	<tancot+?>: mov.x64 sp(5, 3)
	cmplStd/lib/math/Math.ci:803: (65 bytes): if (j & 2)
	<tancot+?>: dup.x32 sp(2)
	<tancot+?>: load.c32 2
	<tancot+?>: and.b32
	<tancot+?>: jz +37
	cmplStd/lib/math/Math.ci:804: (29 bytes): if (flag)
	<tancot+?>: dup.x32 sp(10)
	<tancot+?>: jz +13
	cmplStd/lib/math/Math.ci:805: (5 bytes): y := -y;
	<tancot+?>: dup.x64 sp(5)
	<tancot+?>: neg.f64
	<tancot+?>: set.x64 sp(7)
	<tancot+?>: jmp +18
	cmplStd/lib/math/Math.ci:807: (14 bytes): y := (-1) / y;
	<tancot+?>: load.f64 -1.000000
	<tancot+?>: dup.x64 sp(7)
	<tancot+?>: div.f64
	<tancot+?>: set.x64 sp(7)
	<tancot+?>: jmp +24
	cmplStd/lib/math/Math.ci:810: (20 bytes): if (flag)
	<tancot+?>: dup.x32 sp(10)
	<tancot+?>: jz +18
	cmplStd/lib/math/Math.ci:811: (14 bytes): y := (1) / y;
	<tancot+?>: load.f64 1.000000
	<tancot+?>: dup.x64 sp(7)
	<tancot+?>: div.f64
	<tancot+?>: set.x64 sp(7)
	cmplStd/lib/math/Math.ci:815: (12 bytes): return .result := sign * y;
	<tancot+?>: dup.x64 sp(7)
	<tancot+?>: dup.x64 sp(7)
	<tancot+?>: mul.f64
	<tancot+?>: set.x64 sp(15)
	<tancot+?>: inc.sp(-36)
	<tancot+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:1011: referenced as `tancot`
	cmplStd/lib/math/Math.ci:981: referenced as `tancot`
}
Math.atan(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 42
.name: 'atan'
.file: 'cmplStd/lib/math/Math.ci:820'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse tangent of the radian argument `x`.'
.value: {
	static xatan(x: float64): float64 := {
		z: float64 := x * x;
		p: float64 := eval(z, p0, p1, p2, p3, p4);
		q: float64 := eval(z, q0, q1, q2, q3, q4 + z);
		return .result := p / q * x;
	};
	static satan(x: float64): float64 := {
		if (x < sq2m1) {
			return .result := xatan(x);
		}
		if (x > sq2p1) {
			return .result := pi / (2) - xatan((1) / x);
		}
		return .result := pi / (4) + xatan((x - (1)) / (x + (1)));
	};
	if (x > (0)) {
		return .result := satan(x);
	}
	return .result := -satan(-x);
}
.instructions: (42 bytes)
	cmplStd/lib/math/Math.ci:857: (24 bytes): if (x > (0))
	<atan>  : dup.x64 sp(1)
	<atan+?>: load.z64
	<atan+?>: cgt.f64
	<atan+?>: jz +20
	cmplStd/lib/math/Math.ci:858: (16 bytes): return .result := satan(x);
	<atan+?>: load.z64
	<atan+?>: dup.x64 sp(3)
	<atan+?>: load.ref <?> ;Math.atan.satan(x: float64): float64
	<atan+?>: call
	<atan+?>: inc.sp(-8)
	<atan+?>: set.x64 sp(5)
	<atan+?>: ret
	cmplStd/lib/math/Math.ci:860: (18 bytes): return .result := -satan(-x);
	<atan+?>: load.z64
	<atan+?>: dup.x64 sp(3)
	<atan+?>: neg.f64
	<atan+?>: load.ref <?> ;Math.atan.satan(x: float64): float64
	<atan+?>: call
	<atan+?>: inc.sp(-8)
	<atan+?>: neg.f64
	<atan+?>: set.x64 sp(5)
	<atan+?>: ret
.usages:
	cmplStd/lib/math/Math.ci:1018: referenced as `atan`
	cmplStd/lib/math/Math.ci:878: referenced as `atan`
}
Math.atan2(arg1: float64, arg2: float64): float64: function {
.kind: static function
.base: `function`
.size: 143
.name: 'atan2'
.file: 'cmplStd/lib/math/Math.ci:865'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param arg1: float64 (size: 8, cast: variable(f64))
.param arg2: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse tangent of y/x.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.atan2)) != null) {
		return .result := float64.atan2(arg1, arg2);
	}
	if (arg1 + arg2 == arg1) {
		if (arg1 >= (0)) {
			return .result := pi / (2);
		}
		return .result := -pi / (2);
	}
	arg1 := atan(arg1 / arg2);
	if (arg2 < (0)) {
		if (arg1 <= (0)) {
			return .result := arg1 + pi;
		}
		return .result := arg1 - pi;
	}
	return .result := arg1;
}
.instructions: (143 bytes)
	cmplStd/lib/math/Math.ci:868: (11 bytes): return .result := float64.atan2(arg1, arg2);
	<atan2>  : dup.x64 sp(3)
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: nfc(49) ;float64.atan2(x: float64, y: float64): float64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:871: (64 bytes): if (arg1 + arg2 == arg1)
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: add.f64
	<atan2+?>: dup.x64 sp(5)
	<atan2+?>: ceq.f64
	<atan2+?>: jz +56
	cmplStd/lib/math/Math.ci:872: (30 bytes): if (arg1 >= (0))
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: load.z64
	<atan2+?>: clt.f64
	<atan2+?>: jnz +26
	cmplStd/lib/math/Math.ci:873: (22 bytes): return .result := pi / (2);
	<atan2+?>: load.f64 3.141593
	<atan2+?>: load.f64 2.000000
	<atan2+?>: div.f64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:875: (22 bytes): return .result := -pi / (2);
	<atan2+?>: load.f64 -3.141593
	<atan2+?>: load.f64 2.000000
	<atan2+?>: div.f64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:878: (18 bytes): arg1 := atan(arg1 / arg2);
	<atan2+?>: load.z64
	<atan2+?>: dup.x64 sp(5)
	<atan2+?>: dup.x64 sp(5)
	<atan2+?>: div.f64
	<atan2+?>: load.ref <?> ;Math.atan(x: float64): float64
	<atan2+?>: call
	<atan2+?>: inc.sp(-8)
	<atan2+?>: set.x64 sp(5)
	cmplStd/lib/math/Math.ci:879: (46 bytes): if (arg2 < (0))
	<atan2+?>: dup.x64 sp(1)
	<atan2+?>: load.z64
	<atan2+?>: clt.f64
	<atan2+?>: jz +42
	cmplStd/lib/math/Math.ci:880: (23 bytes): if (arg1 <= (0))
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: load.z64
	<atan2+?>: cgt.f64
	<atan2+?>: jnz +19
	cmplStd/lib/math/Math.ci:881: (15 bytes): return .result := arg1 + pi;
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: load.f64 3.141593
	<atan2+?>: add.f64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:883: (15 bytes): return .result := arg1 - pi;
	<atan2+?>: dup.x64 sp(3)
	<atan2+?>: load.f64 3.141593
	<atan2+?>: sub.f64
	<atan2+?>: set.x64 sp(7)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:885: (4 bytes): return .result := arg1;
	<atan2+?>: mov.x64 sp(5, 3)
	<atan2+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:44: referenced as `atan2`
	cmplStd/lib/math/Complex.ci:81: referenced as `atan2`
	cmplStd/lib/math/Math.ci:956: referenced as `atan2`
	cmplStd/lib/math/Math.ci:923: referenced as `atan2`
	cmplStd/lib/math/Math.ci:895: referenced as `atan2`
}
Math.atan2(y: float32, x: float32): float32: function {
.kind: static function
.base: `function`
.size: 32
.name: 'atan2'
.file: 'cmplStd/lib/math/Math.ci:889'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param y: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the inverse tangent of y/x.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.atan2)) != null) {
		return .result := float32.atan2(y, x);
	}
	return .result := float32(atan2(float64(y), float64(x)));
}
.instructions: (32 bytes)
	cmplStd/lib/math/Math.ci:892: (11 bytes): return .result := float32.atan2(y, x);
	<atan2>  : dup.x32 sp(2)
	<atan2+?>: dup.x32 sp(2)
	<atan2+?>: nfc(41) ;float32.atan2(x: float32, y: float32): float32
	<atan2+?>: set.x32 sp(4)
	<atan2+?>: ret
	cmplStd/lib/math/Math.ci:895: (21 bytes): return .result := float32(atan2(float64(y), float64(x)));
	<atan2+?>: load.z64
	<atan2+?>: dup.x32 sp(4)
	<atan2+?>: f32.2f64
	<atan2+?>: dup.x32 sp(5)
	<atan2+?>: f32.2f64
	<atan2+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<atan2+?>: call
	<atan2+?>: inc.sp(-16)
	<atan2+?>: f64.2f32
	<atan2+?>: set.x32 sp(4)
	<atan2+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:53: referenced as `atan2`
}
Math.sin(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 26
.name: 'sin'
.file: 'cmplStd/lib/math/Math.ci:900'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the sine of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.sin)) != null) {
		return .result := float64.sin(x);
	}
	return .result := sincos(x, 0);
}
.instructions: (26 bytes)
	cmplStd/lib/math/Math.ci:903: (9 bytes): return .result := float64.sin(x);
	<sin>  : dup.x64 sp(1)
	<sin+?>: nfc(42) ;float64.sin(x: float64): float64
	<sin+?>: set.x64 sp(5)
	<sin+?>: ret
	cmplStd/lib/math/Math.ci:906: (17 bytes): return .result := sincos(x, 0);
	<sin+?>: load.z64
	<sin+?>: dup.x64 sp(3)
	<sin+?>: load.z32
	<sin+?>: load.ref <?> ;Math.sincos(x: float64, quad: int32): float64
	<sin+?>: call
	<sin+?>: inc.sp(-12)
	<sin+?>: set.x64 sp(5)
	<sin+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:83: referenced as `sin`
	cmplStd/test/math/test.Bits.ci:37: referenced as `sin`
	cmplStd/lib/math/Easing.ci:49: referenced as `sin`
	cmplStd/lib/math/Complex.ci:142: referenced as `sin`
	cmplStd/lib/math/Complex.ci:118: referenced as `sin`
	cmplStd/lib/math/Complex.ci:116: referenced as `sin`
	cmplStd/lib/math/Complex.ci:109: referenced as `sin`
	cmplStd/lib/math/Complex.ci:96: referenced as `sin`
	cmplStd/lib/math/Math.ci:1038: referenced as `sin`
	cmplStd/lib/math/Math.ci:916: referenced as `sin`
}
Math.sin(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'sin'
.file: 'cmplStd/lib/math/Math.ci:910'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the sine of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.sin)) != null) {
		return .result := float32.sin(x);
	}
	return .result := float32(sin(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:913: (9 bytes): return .result := float32.sin(x);
	<sin>  : dup.x32 sp(1)
	<sin+?>: nfc(34) ;float32.sin(x: float32): float32
	<sin+?>: set.x32 sp(3)
	<sin+?>: ret
	cmplStd/lib/math/Math.ci:916: (18 bytes): return .result := float32(sin(float64(x)));
	<sin+?>: load.z64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: f32.2f64
	<sin+?>: load.ref <?> ;Math.sin(x: float64): float64
	<sin+?>: call
	<sin+?>: inc.sp(-8)
	<sin+?>: f64.2f32
	<sin+?>: set.x32 sp(3)
	<sin+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:46: referenced as `sin`
	cmplStd/lib/math/Matrix4f.ci:165: referenced as `sin`
	cmplStd/lib/math/Matrix4f.ci:133: referenced as `sin`
}
Math.sinh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'cmplStd/lib/math/Math.ci:920'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic sine of the radian argument `x`.'
.value: x == (0) ? (0) : (exp(x) - exp(-x)) / (2)
.usages:
	cmplStd/test/math/test.Math.ci:86: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:118: referenced as `sinh`
	cmplStd/lib/math/Complex.ci:116: referenced as `sinh`
	cmplStd/lib/math/Math.ci:1041: referenced as `sinh`
}
Math.asin(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asin'
.file: 'cmplStd/lib/math/Math.ci:923'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse sine of the radian argument `x`.'
.value: atan2(x, sqrt(((1) + x) * ((1) - x)))
.usages:
	cmplStd/test/math/test.Math.ci:89: referenced as `asin`
	cmplStd/lib/math/Math.ci:1044: referenced as `asin`
}
Math.asinh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asinh'
.file: 'cmplStd/lib/math/Math.ci:926'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic sine of the radian argument `x`.'
.value: log(x + sqrt((x * x) + (1)))
.usages:
}
Math.cos(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 43
.name: 'cos'
.file: 'cmplStd/lib/math/Math.ci:930'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the cosine of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.cos)) != null) {
		return .result := float64.cos(x);
	}
	if (x < (0)) {
		x := -x;
	}
	return .result := sincos(x, 1);
}
.instructions: (43 bytes)
	cmplStd/lib/math/Math.ci:933: (9 bytes): return .result := float64.cos(x);
	<cos>  : dup.x64 sp(1)
	<cos+?>: nfc(43) ;float64.cos(x: float64): float64
	<cos+?>: set.x64 sp(5)
	<cos+?>: ret
	cmplStd/lib/math/Math.ci:936: (13 bytes): if (x < (0))
	<cos+?>: dup.x64 sp(1)
	<cos+?>: load.z64
	<cos+?>: clt.f64
	<cos+?>: jz +9
	cmplStd/lib/math/Math.ci:937: (5 bytes): x := -x;
	<cos+?>: dup.x64 sp(1)
	<cos+?>: neg.f64
	<cos+?>: set.x64 sp(3)
	cmplStd/lib/math/Math.ci:939: (21 bytes): return .result := sincos(x, 1);
	<cos+?>: load.z64
	<cos+?>: dup.x64 sp(3)
	<cos+?>: load.c32 1
	<cos+?>: load.ref <?> ;Math.sincos(x: float64, quad: int32): float64
	<cos+?>: call
	<cos+?>: inc.sp(-12)
	<cos+?>: set.x64 sp(5)
	<cos+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:84: referenced as `cos`
	cmplStd/test/math/test.Bits.ci:38: referenced as `cos`
	cmplStd/lib/math/Easing.ci:37: referenced as `cos`
	cmplStd/lib/math/Complex.ci:142: referenced as `cos`
	cmplStd/lib/math/Complex.ci:118: referenced as `cos`
	cmplStd/lib/math/Complex.ci:116: referenced as `cos`
	cmplStd/lib/math/Complex.ci:108: referenced as `cos`
	cmplStd/lib/math/Complex.ci:96: referenced as `cos`
	cmplStd/lib/math/Math.ci:1025: referenced as `cos`
	cmplStd/lib/math/Math.ci:949: referenced as `cos`
}
Math.cos(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'cos'
.file: 'cmplStd/lib/math/Math.ci:943'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the sine of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.cos)) != null) {
		return .result := float32.cos(x);
	}
	return .result := float32(cos(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:946: (9 bytes): return .result := float32.cos(x);
	<cos>  : dup.x32 sp(1)
	<cos+?>: nfc(35) ;float32.cos(x: float32): float32
	<cos+?>: set.x32 sp(3)
	<cos+?>: ret
	cmplStd/lib/math/Math.ci:949: (18 bytes): return .result := float32(cos(float64(x)));
	<cos+?>: load.z64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: f32.2f64
	<cos+?>: load.ref <?> ;Math.cos(x: float64): float64
	<cos+?>: call
	<cos+?>: inc.sp(-8)
	<cos+?>: f64.2f32
	<cos+?>: set.x32 sp(3)
	<cos+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:47: referenced as `cos`
	cmplStd/lib/math/Matrix4f.ci:166: referenced as `cos`
	cmplStd/lib/math/Matrix4f.ci:134: referenced as `cos`
}
Math.cosh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'cmplStd/lib/math/Math.ci:953'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the hyperbolic cosine of the radian argument `x`.'
.value: x == (0) ? (1) : (exp(x) + exp(-x)) / (2)
.usages:
	cmplStd/test/math/test.Math.ci:87: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:118: referenced as `cosh`
	cmplStd/lib/math/Complex.ci:116: referenced as `cosh`
	cmplStd/lib/math/Math.ci:1028: referenced as `cosh`
}
Math.acos(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acos'
.file: 'cmplStd/lib/math/Math.ci:956'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse cosine of the radian argument `x`.'
.value: atan2(sqrt(((1) + x) * ((1) - x)), x)
.usages:
	cmplStd/test/math/test.Math.ci:90: referenced as `acos`
	cmplStd/lib/math/Math.ci:1031: referenced as `acos`
}
Math.acosh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acosh'
.file: 'cmplStd/lib/math/Math.ci:959'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic cosine of the radian argument `x`.'
.value: log(x + sqrt(x * x - (1)))
.usages:
}
Math.tan(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 82
.name: 'tan'
.file: 'cmplStd/lib/math/Math.ci:963'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the tangent of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.tan)) != null) {
		return .result := float64.tan(x);
	}
	if (x == (0)) {
		return .result := x;
	}
	if (x != x) {
		return .result := x;
	}
	if (x == (2) * x) {
		return .result := nan;
	}
	return .result := tancot(x, 0);
}
.instructions: (82 bytes)
	cmplStd/lib/math/Math.ci:966: (9 bytes): return .result := float64.tan(x);
	<tan>  : dup.x64 sp(1)
	<tan+?>: nfc(44) ;float64.tan(x: float64): float64
	<tan+?>: set.x64 sp(5)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:969: (12 bytes): if (x == (0))
	<tan+?>: dup.x64 sp(1)
	<tan+?>: load.z64
	<tan+?>: ceq.f64
	<tan+?>: jz +8
	cmplStd/lib/math/Math.ci:970: (4 bytes): return .result := x;
	<tan+?>: mov.x64 sp(3, 1)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:972: (13 bytes): if (x != x)
	<tan+?>: dup.x64 sp(1)
	<tan+?>: dup.x64 sp(3)
	<tan+?>: ceq.f64
	<tan+?>: jnz +8
	cmplStd/lib/math/Math.ci:974: (4 bytes): return .result := x;
	<tan+?>: mov.x64 sp(3, 1)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:976: (31 bytes): if (x == (2) * x)
	<tan+?>: dup.x64 sp(1)
	<tan+?>: load.f64 2.000000
	<tan+?>: dup.x64 sp(5)
	<tan+?>: mul.f64
	<tan+?>: ceq.f64
	<tan+?>: jz +16
	cmplStd/lib/math/Math.ci:978: (12 bytes): return .result := nan;
	<tan+?>: load.f64 -nan
	<tan+?>: set.x64 sp(5)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:981: (17 bytes): return .result := tancot(x, 0);
	<tan+?>: load.z64
	<tan+?>: dup.x64 sp(3)
	<tan+?>: load.z32
	<tan+?>: load.ref <?> ;Math.tancot(x: float64, flag: int32): float64
	<tan+?>: call
	<tan+?>: inc.sp(-12)
	<tan+?>: set.x64 sp(5)
	<tan+?>: ret
.usages:
	cmplStd/test/math/test.Math.ci:85: referenced as `tan`
	cmplStd/test/math/test.Bits.ci:39: referenced as `tan`
	cmplStd/lib/math/Math.ci:991: referenced as `tan`
}
Math.tan(x: float32): float32: function {
.kind: static function
.base: `function`
.size: 27
.name: 'tan'
.file: 'cmplStd/lib/math/Math.ci:985'
.owner: Math
.param .result: float32 (size: 4, cast: variable(f32))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Returns the tangent of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float32.tan)) != null) {
		return .result := float32.tan(x);
	}
	return .result := float32(tan(float64(x)));
}
.instructions: (27 bytes)
	cmplStd/lib/math/Math.ci:988: (9 bytes): return .result := float32.tan(x);
	<tan>  : dup.x32 sp(1)
	<tan+?>: nfc(36) ;float32.tan(x: float32): float32
	<tan+?>: set.x32 sp(3)
	<tan+?>: ret
	cmplStd/lib/math/Math.ci:991: (18 bytes): return .result := float32(tan(float64(x)));
	<tan+?>: load.z64
	<tan+?>: dup.x32 sp(3)
	<tan+?>: f32.2f64
	<tan+?>: load.ref <?> ;Math.tan(x: float64): float64
	<tan+?>: call
	<tan+?>: inc.sp(-8)
	<tan+?>: f64.2f32
	<tan+?>: set.x32 sp(3)
	<tan+?>: ret
.usages:
	cmplStd/test/math/test.Bits.ci:48: referenced as `tan`
}
Math.tanh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'cmplStd/lib/math/Math.ci:995'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the hyperbolic tangent of the radian argument `x`.'
.value: (1) - (2) / (exp((2) * x) + (1))
.usages:
	cmplStd/lib/math/Math.ci:1015: referenced as `tanh`
}
Math.atanh(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'atanh'
.file: 'cmplStd/lib/math/Math.ci:998'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic tangent of the radian argument `x`.'
.value: x >= (1) ? inf : x <= (-1) ? -inf : 0.500000 * log(((1) + x) / ((1) - x))
.usages:
}
Math.cot(x: float64): float64: function {
.kind: static function
.base: `function`
.size: 41
.name: 'cot'
.file: 'cmplStd/lib/math/Math.ci:1002'
.owner: Math
.param .result: float64 (size: 8, cast: variable(f64))
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the cotangent of the radian argument `x`.'
.value: {
	static if ((preferNativeCalls) && (typename(float64.cot)) != null) {
		return .result := float64.cot(x);
	}
	if (x == (0)) {
		return .result := inf;
	}
	return .result := tancot(x, 1);
}
.instructions: (41 bytes)
	cmplStd/lib/math/Math.ci:1008: (20 bytes): if (x == (0))
	<cot>  : dup.x64 sp(1)
	<cot+?>: load.z64
	<cot+?>: ceq.f64
	<cot+?>: jz +16
	cmplStd/lib/math/Math.ci:1009: (12 bytes): return .result := inf;
	<cot+?>: load.f64 inf
	<cot+?>: set.x64 sp(5)
	<cot+?>: ret
	cmplStd/lib/math/Math.ci:1011: (21 bytes): return .result := tancot(x, 1);
	<cot+?>: load.z64
	<cot+?>: dup.x64 sp(3)
	<cot+?>: load.c32 1
	<cot+?>: load.ref <?> ;Math.tancot(x: float64, flag: int32): float64
	<cot+?>: call
	<cot+?>: inc.sp(-12)
	<cot+?>: set.x64 sp(5)
	<cot+?>: ret
.usages:
}
Math.coth(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'cmplStd/lib/math/Math.ci:1015'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the hyperbolic cotangent of the radian argument `x`.'
.value: (1) / tanh(x)
.usages:
}
Math.acot(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acot'
.file: 'cmplStd/lib/math/Math.ci:1018'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse cotangent of the radian argument `x`.'
.value: x == (0) ? pi / (2) : atan((1) / x)
.usages:
}
Math.acoth(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acoth'
.file: 'cmplStd/lib/math/Math.ci:1021'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic cotangent of the radian argument `x`.'
.value: x == (1) ? inf : x == (-1) ? -inf : 0.500000 * log((x + (1)) / (x - (1)))
.usages:
}
Math.sec(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'cmplStd/lib/math/Math.ci:1025'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the secant of the radian argument `x`.'
.value: (1) / cos(x)
.usages:
}
Math.sech(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'cmplStd/lib/math/Math.ci:1028'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the hyperbolic secant of the radian argument `x`.'
.value: (1) / cosh(x)
.usages:
}
Math.asec(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asec'
.file: 'cmplStd/lib/math/Math.ci:1031'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse secant of the radian argument `x`.'
.value: x == (0) ? inf : acos((1) / x)
.usages:
}
Math.asech(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'asech'
.file: 'cmplStd/lib/math/Math.ci:1034'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic secant of the radian argument `x`.'
.value: x == (0) ? inf : x == (1) ? (0) : log((sqrt((1) - x * x) + (1)) / x)
.usages:
}
Math.csc(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'cmplStd/lib/math/Math.ci:1038'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the cosecant of the radian argument `x`.'
.value: (1) / sin(x)
.usages:
}
Math.csch(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'cmplStd/lib/math/Math.ci:1041'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: f64)
.doc: 'Returns the hyperbolic cosecant of the radian argument `x`.'
.value: (1) / sinh(x)
.usages:
}
Math.acsc(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acsc'
.file: 'cmplStd/lib/math/Math.ci:1044'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse cosecant of the radian argument `x`.'
.value: x == (0) ? inf : asin((1) / x)
.usages:
}
Math.acsch(x: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'acsch'
.file: 'cmplStd/lib/math/Math.ci:1047'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param x: float64 (size: 8, cast: variable(f64))
.doc: 'Returns the inverse hyperbolic cosecant of the radian argument `x`.'
.value: x == (0) ? inf : x < (0) ? log(((1) - sqrt((1) + x * x)) / x) : log(((1) + sqrt((1) + x * x)) / x)
.usages:
}
Math.radians(degrees: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'radians'
.file: 'cmplStd/lib/math/Math.ci:1051'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param degrees: float64 (size: 8, cast: f64)
.doc: 'Converts the input to radians from degrees.'
.value: float64(degrees * pi / (180))
.usages:
}
Math.degrees(radians: float64): float64: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'degrees'
.file: 'cmplStd/lib/math/Math.ci:1054'
.owner: Math
.param .result: float64 (size: 8, cast: f64)
.param radians: float64 (size: 8, cast: f64)
.doc: 'Converts the input to degrees from radians.'
.value: float64(radians * (180) / pi)
.usages:
}
Fixed: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Fixed'
.file: 'cmplStd/lib/math/Fixed.ci:2'
.field value: int32 (size: 4, cast: variable(i32))
.field precision: int32 (size: 0, cast: static const val)
.field one: int32 (size: 0, cast: static const val)
.field nan: int32 (size: 0, cast: static const val)
.field inf: int32 (size: 0, cast: static const val)
.field half: int32 (size: 0, cast: static const val)
.field mask: int32 (size: 0, cast: static const val)
.field pow2max: int32 (size: 0, cast: static const val)
.field mpi_28: int32 (size: 0, cast: static const val)
.field ln2_28: int32 (size: 0, cast: static const val)
.field lg2_28: int32 (size: 0, cast: static const val)
.field l2e_28: int32 (size: 0, cast: static const val)
.field l2t_28: int32 (size: 0, cast: static const val)
.field d2r_28: int32 (size: 0, cast: static const val)
.field r2d_24: int32 (size: 0, cast: static const val)
.field piMul2: int32 (size: 0, cast: static const val)
.field piDiv2: int32 (size: 0, cast: static const val)
.field pi: int32 (size: 0, cast: static const val)
.field ln2: int32 (size: 0, cast: static const val)
.field lg2: int32 (size: 0, cast: static const val)
.field l2e: int32 (size: 0, cast: static const val)
.field l2t: int32 (size: 0, cast: static const val)
.field as: function (size: 4, cast: static function)
.field neg: function (size: 6, cast: static function)
.field add: function (size: 8, cast: static function)
.field sub: function (size: 8, cast: static function)
.field mul: function (size: 17, cast: static function)
.field mul: function (size: 8, cast: static function)
.field mul_28: function (size: 17, cast: static function)
.field div: function (size: 94, cast: static function)
.field div: function (size: 8, cast: static function)
.field mod: function (size: 8, cast: static function)
.field inv: function (size: 95, cast: static function)
.field fract: function (size: 34, cast: static function)
.field floor: function (size: 12, cast: static function)
.field ceil: function (size: 47, cast: static function)
.field round: function (size: 37, cast: static function)
.field isFinite: function (size: 68, cast: static function)
.field isNan: function (size: 14, cast: static function)
.field compare: function (size: 14, cast: static function)
.field log2: function (size: 194, cast: static function)
.field log: function (size: 63, cast: static function)
.field log10: function (size: 63, cast: static function)
.field log: function (size: 99, cast: static function)
.field pow2: function (size: 216, cast: static function)
.field exp: function (size: 38, cast: static function)
.field exp10: function (size: 38, cast: static function)
.field sqrt: function (size: 175, cast: static function)
.field pow: function (size: 410, cast: static function)
.field horner: function (size: 0, cast: static inline)
.field horner: function (size: 0, cast: static inline)
.field horner: function (size: 0, cast: static inline)
.field horner: function (size: 0, cast: static inline)
.field horner: function (size: 0, cast: static inline)
.field sin: function (size: 250, cast: static function)
.field sinh: function (size: 129, cast: static function)
.field cos: function (size: 234, cast: static function)
.field tan: function (size: 49, cast: static function)
.field degrees: function (size: 37, cast: static function)
.field radians: function (size: 24, cast: static function)
.doc: 'simple fixed point, `precision` bits used for decimal part, the rest for integer part'
.usages:
	cmplStd/lib/math/Fixed.ci:761: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:757: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:754: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:751: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:750: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:742: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:739: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:736: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:734: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:733: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:733: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:733: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:732: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:728: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:728: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:725: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:725: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:719: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:719: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:714: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:714: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:605: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:605: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:530: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:530: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:490: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:490: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:451: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:451: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:382: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:382: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:382: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:346: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:346: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:334: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:334: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:322: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:322: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:254: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:254: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:231: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:231: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:231: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:215: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:215: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:198: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:198: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:134: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:134: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:121: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:121: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:116: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:103: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:98: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:98: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:93: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:93: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:88: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:88: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:80: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:80: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:67: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:67: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:64: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:64: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:64: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:61: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:61: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:52: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:52: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:52: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:49: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:49: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:48: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:48: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:47: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:47: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:47: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:44: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:44: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:44: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:41: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:41: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:41: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:38: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:38: referenced as `Fixed`
	cmplStd/lib/math/Fixed.ci:35: referenced as `Fixed`
}
Fixed.value: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'value'
.file: 'cmplStd/lib/math/Fixed.ci:3'
.owner: Fixed
.value: 0
.usages:
	cmplStd/lib/math/Fixed.ci:761: referenced as `value`
	cmplStd/lib/math/Fixed.ci:757: referenced as `value`
	cmplStd/lib/math/Fixed.ci:754: referenced as `value`
	cmplStd/lib/math/Fixed.ci:751: referenced as `value`
	cmplStd/lib/math/Fixed.ci:742: referenced as `value`
	cmplStd/lib/math/Fixed.ci:739: referenced as `value`
	cmplStd/lib/math/Fixed.ci:736: referenced as `value`
	cmplStd/lib/math/Fixed.ci:734: referenced as `value`
	cmplStd/lib/math/Fixed.ci:728: referenced as `value`
	cmplStd/lib/math/Fixed.ci:715: referenced as `value`
	cmplStd/lib/math/Fixed.ci:562: referenced as `value`
	cmplStd/lib/math/Fixed.ci:562: referenced as `value`
	cmplStd/lib/math/Fixed.ci:557: referenced as `value`
	cmplStd/lib/math/Fixed.ci:556: referenced as `value`
	cmplStd/lib/math/Fixed.ci:551: referenced as `value`
	cmplStd/lib/math/Fixed.ci:551: referenced as `value`
	cmplStd/lib/math/Fixed.ci:550: referenced as `value`
	cmplStd/lib/math/Fixed.ci:546: referenced as `value`
	cmplStd/lib/math/Fixed.ci:545: referenced as `value`
	cmplStd/lib/math/Fixed.ci:544: referenced as `value`
	cmplStd/lib/math/Fixed.ci:495: referenced as `value`
	cmplStd/lib/math/Fixed.ci:484: referenced as `value`
	cmplStd/lib/math/Fixed.ci:484: referenced as `value`
	cmplStd/lib/math/Fixed.ci:480: referenced as `value`
	cmplStd/lib/math/Fixed.ci:480: referenced as `value`
	cmplStd/lib/math/Fixed.ci:479: referenced as `value`
	cmplStd/lib/math/Fixed.ci:474: referenced as `value`
	cmplStd/lib/math/Fixed.ci:473: referenced as `value`
	cmplStd/lib/math/Fixed.ci:468: referenced as `value`
	cmplStd/lib/math/Fixed.ci:467: referenced as `value`
	cmplStd/lib/math/Fixed.ci:466: referenced as `value`
	cmplStd/lib/math/Fixed.ci:437: referenced as `value`
	cmplStd/lib/math/Fixed.ci:428: referenced as `value`
	cmplStd/lib/math/Fixed.ci:428: referenced as `value`
	cmplStd/lib/math/Fixed.ci:428: referenced as `value`
	cmplStd/lib/math/Fixed.ci:427: referenced as `value`
	cmplStd/lib/math/Fixed.ci:425: referenced as `value`
	cmplStd/lib/math/Fixed.ci:408: referenced as `value`
	cmplStd/lib/math/Fixed.ci:401: referenced as `value`
	cmplStd/lib/math/Fixed.ci:396: referenced as `value`
	cmplStd/lib/math/Fixed.ci:396: referenced as `value`
	cmplStd/lib/math/Fixed.ci:392: referenced as `value`
	cmplStd/lib/math/Fixed.ci:388: referenced as `value`
	cmplStd/lib/math/Fixed.ci:383: referenced as `value`
	cmplStd/lib/math/Fixed.ci:383: referenced as `value`
	cmplStd/lib/math/Fixed.ci:367: referenced as `value`
	cmplStd/lib/math/Fixed.ci:354: referenced as `value`
	cmplStd/lib/math/Fixed.ci:353: referenced as `value`
	cmplStd/lib/math/Fixed.ci:317: referenced as `value`
	cmplStd/lib/math/Fixed.ci:312: referenced as `value`
	cmplStd/lib/math/Fixed.ci:311: referenced as `value`
	cmplStd/lib/math/Fixed.ci:306: referenced as `value`
	cmplStd/lib/math/Fixed.ci:299: referenced as `value`
	cmplStd/lib/math/Fixed.ci:296: referenced as `value`
	cmplStd/lib/math/Fixed.ci:194: referenced as `value`
	cmplStd/lib/math/Fixed.ci:190: referenced as `value`
	cmplStd/lib/math/Fixed.ci:189: referenced as `value`
	cmplStd/lib/math/Fixed.ci:185: referenced as `value`
	cmplStd/lib/math/Fixed.ci:185: referenced as `value`
	cmplStd/lib/math/Fixed.ci:183: referenced as `value`
	cmplStd/lib/math/Fixed.ci:180: referenced as `value`
	cmplStd/lib/math/Fixed.ci:178: referenced as `value`
	cmplStd/lib/math/Fixed.ci:177: referenced as `value`
	cmplStd/lib/math/Fixed.ci:176: referenced as `value`
	cmplStd/lib/math/Fixed.ci:122: referenced as `value`
	cmplStd/lib/math/Fixed.ci:122: referenced as `value`
	cmplStd/lib/math/Fixed.ci:122: referenced as `value`
	cmplStd/lib/math/Fixed.ci:122: referenced as `value`
	cmplStd/lib/math/Fixed.ci:117: referenced as `value`
	cmplStd/lib/math/Fixed.ci:110: referenced as `value`
	cmplStd/lib/math/Fixed.ci:107: referenced as `value`
	cmplStd/lib/math/Fixed.ci:104: referenced as `value`
	cmplStd/lib/math/Fixed.ci:99: referenced as `value`
	cmplStd/lib/math/Fixed.ci:89: referenced as `value`
	cmplStd/lib/math/Fixed.ci:89: referenced as `value`
	cmplStd/lib/math/Fixed.ci:84: referenced as `value`
	cmplStd/lib/math/Fixed.ci:84: referenced as `value`
	cmplStd/lib/math/Fixed.ci:82: referenced as `value`
	cmplStd/lib/math/Fixed.ci:82: referenced as `value`
	cmplStd/lib/math/Fixed.ci:81: referenced as `value`
	cmplStd/lib/math/Fixed.ci:75: referenced as `value`
	cmplStd/lib/math/Fixed.ci:73: referenced as `value`
	cmplStd/lib/math/Fixed.ci:71: referenced as `value`
	cmplStd/lib/math/Fixed.ci:69: referenced as `value`
	cmplStd/lib/math/Fixed.ci:68: referenced as `value`
	cmplStd/lib/math/Fixed.ci:64: referenced as `value`
	cmplStd/lib/math/Fixed.ci:64: referenced as `value`
	cmplStd/lib/math/Fixed.ci:64: referenced as `value`
	cmplStd/lib/math/Fixed.ci:61: referenced as `value`
	cmplStd/lib/math/Fixed.ci:61: referenced as `value`
	cmplStd/lib/math/Fixed.ci:59: referenced as `value`
	cmplStd/lib/math/Fixed.ci:59: referenced as `value`
	cmplStd/lib/math/Fixed.ci:59: referenced as `value`
	cmplStd/lib/math/Fixed.ci:57: referenced as `value`
	cmplStd/lib/math/Fixed.ci:54: referenced as `value`
	cmplStd/lib/math/Fixed.ci:53: referenced as `value`
	cmplStd/lib/math/Fixed.ci:49: referenced as `value`
	cmplStd/lib/math/Fixed.ci:49: referenced as `value`
	cmplStd/lib/math/Fixed.ci:48: referenced as `value`
	cmplStd/lib/math/Fixed.ci:48: referenced as `value`
	cmplStd/lib/math/Fixed.ci:47: referenced as `value`
	cmplStd/lib/math/Fixed.ci:47: referenced as `value`
	cmplStd/lib/math/Fixed.ci:47: referenced as `value`
	cmplStd/lib/math/Fixed.ci:44: referenced as `value`
	cmplStd/lib/math/Fixed.ci:44: referenced as `value`
	cmplStd/lib/math/Fixed.ci:44: referenced as `value`
	cmplStd/lib/math/Fixed.ci:41: referenced as `value`
	cmplStd/lib/math/Fixed.ci:41: referenced as `value`
	cmplStd/lib/math/Fixed.ci:41: referenced as `value`
	cmplStd/lib/math/Fixed.ci:38: referenced as `value`
	cmplStd/lib/math/Fixed.ci:38: referenced as `value`
	cmplStd/lib/math/Fixed.ci:35: referenced as `value`
}
Fixed.precision: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'precision'
.file: 'cmplStd/lib/math/Fixed.ci:6'
.owner: Fixed
.doc: 'precision'
.value: 20
.usages:
	cmplStd/lib/math/Fixed.ci:761: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:733: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:728: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:725: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:562: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:484: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:444: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:434: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:432: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:428: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:368: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:360: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:317: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:317: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:310: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:312: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:311: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:309: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:307: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:306: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:194: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:194: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:194: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:187: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:184: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:71: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:59: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:47: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:33: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:30: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:29: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:28: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:27: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:26: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:24: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:23: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:13: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:13: referenced as `precision`
	cmplStd/lib/math/Fixed.ci:8: referenced as `precision`
}
Fixed.one: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'one'
.file: 'cmplStd/lib/math/Fixed.ci:8'
.owner: Fixed
.doc: 'one'
.value: 1048576
.usages:
	cmplStd/lib/math/Fixed.ci:541: referenced as `one`
	cmplStd/lib/math/Fixed.ci:540: referenced as `one`
	cmplStd/lib/math/Fixed.ci:539: referenced as `one`
	cmplStd/lib/math/Fixed.ci:538: referenced as `one`
	cmplStd/lib/math/Fixed.ci:537: referenced as `one`
	cmplStd/lib/math/Fixed.ci:536: referenced as `one`
	cmplStd/lib/math/Fixed.ci:463: referenced as `one`
	cmplStd/lib/math/Fixed.ci:462: referenced as `one`
	cmplStd/lib/math/Fixed.ci:461: referenced as `one`
	cmplStd/lib/math/Fixed.ci:460: referenced as `one`
	cmplStd/lib/math/Fixed.ci:459: referenced as `one`
	cmplStd/lib/math/Fixed.ci:458: referenced as `one`
	cmplStd/lib/math/Fixed.ci:426: referenced as `one`
	cmplStd/lib/math/Fixed.ci:388: referenced as `one`
	cmplStd/lib/math/Fixed.ci:386: referenced as `one`
	cmplStd/lib/math/Fixed.ci:383: referenced as `one`
	cmplStd/lib/math/Fixed.ci:71: referenced as `one`
	cmplStd/lib/math/Fixed.ci:12: referenced as `one`
	cmplStd/lib/math/Fixed.ci:11: referenced as `one`
}
Fixed.nan: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'nan'
.file: 'cmplStd/lib/math/Fixed.ci:9'
.owner: Fixed
.doc: 'nan'
.value: (2147483648)
.usages:
	cmplStd/lib/math/Fixed.ci:751: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:736: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:734: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:399: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:396: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:396: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:355: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:180: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:117: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:104: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:84: referenced as `nan`
	cmplStd/lib/math/Fixed.ci:55: referenced as `nan`
}
Fixed.inf: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'inf'
.file: 'cmplStd/lib/math/Fixed.ci:10'
.owner: Fixed
.doc: 'inf'
.value: 2147483647
.usages:
	cmplStd/lib/math/Fixed.ci:757: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:754: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:742: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:739: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:409: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:297: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:178: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:110: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:107: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:73: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:73: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:69: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:57: referenced as `inf`
	cmplStd/lib/math/Fixed.ci:57: referenced as `inf`
}
Fixed.half: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'half'
.file: 'cmplStd/lib/math/Fixed.ci:11'
.owner: Fixed
.doc: 'half'
.value: 524288
.usages:
	cmplStd/lib/math/Fixed.ci:392: referenced as `half`
	cmplStd/lib/math/Fixed.ci:99: referenced as `half`
}
Fixed.mask: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'mask'
.file: 'cmplStd/lib/math/Fixed.ci:12'
.owner: Fixed
.doc: 'mask'
.value: 1048575
.usages:
	cmplStd/lib/math/Fixed.ci:425: referenced as `mask`
	cmplStd/lib/math/Fixed.ci:89: referenced as `mask`
	cmplStd/lib/math/Fixed.ci:84: referenced as `mask`
	cmplStd/lib/math/Fixed.ci:82: referenced as `mask`
}
Fixed.pow2max: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'pow2max'
.file: 'cmplStd/lib/math/Fixed.ci:13'
.owner: Fixed
.doc: 'pow2max'
.value: 11534336
.usages:
	cmplStd/lib/math/Fixed.ci:299: referenced as `pow2max`
	cmplStd/lib/math/Fixed.ci:296: referenced as `pow2max`
}
Fixed.mpi_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'mpi_28'
.file: 'cmplStd/lib/math/Fixed.ci:15'
.owner: Fixed
.doc: 'mpi_28'
.value: 843314856
.usages:
	cmplStd/lib/math/Fixed.ci:26: referenced as `mpi_28`
	cmplStd/lib/math/Fixed.ci:24: referenced as `mpi_28`
	cmplStd/lib/math/Fixed.ci:23: referenced as `mpi_28`
}
Fixed.ln2_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'ln2_28'
.file: 'cmplStd/lib/math/Fixed.ci:16'
.owner: Fixed
.doc: 'ln2_28'
.value: 186065279
.usages:
	cmplStd/lib/math/Fixed.ci:211: referenced as `ln2_28`
	cmplStd/lib/math/Fixed.ci:27: referenced as `ln2_28`
}
Fixed.lg2_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'lg2_28'
.file: 'cmplStd/lib/math/Fixed.ci:17'
.owner: Fixed
.doc: 'lg2_28'
.value: 80807124
.usages:
	cmplStd/lib/math/Fixed.ci:227: referenced as `lg2_28`
	cmplStd/lib/math/Fixed.ci:28: referenced as `lg2_28`
}
Fixed.l2e_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'l2e_28'
.file: 'cmplStd/lib/math/Fixed.ci:18'
.owner: Fixed
.doc: 'l2e_28'
.value: 387270501
.usages:
	cmplStd/lib/math/Fixed.ci:330: referenced as `l2e_28`
	cmplStd/lib/math/Fixed.ci:29: referenced as `l2e_28`
}
Fixed.l2t_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'l2t_28'
.file: 'cmplStd/lib/math/Fixed.ci:19'
.owner: Fixed
.doc: 'l2t_28'
.value: 891723282
.usages:
	cmplStd/lib/math/Fixed.ci:342: referenced as `l2t_28`
	cmplStd/lib/math/Fixed.ci:30: referenced as `l2t_28`
}
Fixed.d2r_28: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'd2r_28'
.file: 'cmplStd/lib/math/Fixed.ci:20'
.owner: Fixed
.doc: 'd2r_28'
.value: 4685082
.usages:
	cmplStd/lib/math/Fixed.ci:720: referenced as `d2r_28`
}
Fixed.r2d_24: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'r2d_24'
.file: 'cmplStd/lib/math/Fixed.ci:21'
.owner: Fixed
.doc: 'r2d_24'
.value: 961263668
.usages:
	cmplStd/lib/math/Fixed.ci:715: referenced as `r2d_24`
}
Fixed.piMul2: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'piMul2'
.file: 'cmplStd/lib/math/Fixed.ci:23'
.owner: Fixed
.doc: 'piMul2'
.value: 6588397
.usages:
	cmplStd/lib/math/Fixed.ci:551: referenced as `piMul2`
	cmplStd/lib/math/Fixed.ci:546: referenced as `piMul2`
	cmplStd/lib/math/Fixed.ci:544: referenced as `piMul2`
	cmplStd/lib/math/Fixed.ci:468: referenced as `piMul2`
	cmplStd/lib/math/Fixed.ci:466: referenced as `piMul2`
}
Fixed.piDiv2: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'piDiv2'
.file: 'cmplStd/lib/math/Fixed.ci:24'
.owner: Fixed
.doc: 'piDiv2'
.value: 1647099
.usages:
	cmplStd/lib/math/Fixed.ci:556: referenced as `piDiv2`
	cmplStd/lib/math/Fixed.ci:479: referenced as `piDiv2`
}
Fixed.pi: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'pi'
.file: 'cmplStd/lib/math/Fixed.ci:26'
.owner: Fixed
.doc: 'pi'
.value: 3294198
.usages:
	cmplStd/lib/math/Fixed.ci:557: referenced as `pi`
	cmplStd/lib/math/Fixed.ci:550: referenced as `pi`
	cmplStd/lib/math/Fixed.ci:480: referenced as `pi`
	cmplStd/lib/math/Fixed.ci:474: referenced as `pi`
	cmplStd/lib/math/Fixed.ci:473: referenced as `pi`
}
Fixed.ln2: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'ln2'
.file: 'cmplStd/lib/math/Fixed.ci:27'
.owner: Fixed
.doc: 'ln2'
.value: 726817
.usages:
}
Fixed.lg2: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'lg2'
.file: 'cmplStd/lib/math/Fixed.ci:28'
.owner: Fixed
.doc: 'lg2'
.value: 315652
.usages:
}
Fixed.l2e: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'l2e'
.file: 'cmplStd/lib/math/Fixed.ci:29'
.owner: Fixed
.doc: 'l2e'
.value: 1512775
.usages:
}
Fixed.l2t: int32 {
.kind: static const val
.base: `int32`
.size: 0
.name: 'l2t'
.file: 'cmplStd/lib/math/Fixed.ci:30'
.owner: Fixed
.doc: 'l2t'
.value: 3483294
.usages:
}
Fixed.as(value: int32): Fixed: function {
.kind: static function
.base: `function`
.size: 4
.name: 'as'
.file: 'cmplStd/lib/math/Fixed.ci:35'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param value: int32 (size: 4, cast: variable(i32))
.value: {
	return .result := {
			.result.value := value;
		};
}
.instructions: (4 bytes)
	cmplStd/lib/math/Fixed.ci:35: (4 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:35: (3 bytes): .result.value := value;
	<as>  : mov.x32 sp(2, 1)
	<as+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:733: referenced as `as`
	cmplStd/lib/math/Fixed.ci:725: referenced as `as`
	cmplStd/lib/math/Fixed.ci:715: referenced as `as`
	cmplStd/lib/math/Fixed.ci:564: referenced as `as`
	cmplStd/lib/math/Fixed.ci:496: referenced as `as`
	cmplStd/lib/math/Fixed.ci:486: referenced as `as`
	cmplStd/lib/math/Fixed.ci:437: referenced as `as`
	cmplStd/lib/math/Fixed.ci:437: referenced as `as`
	cmplStd/lib/math/Fixed.ci:411: referenced as `as`
	cmplStd/lib/math/Fixed.ci:409: referenced as `as`
	cmplStd/lib/math/Fixed.ci:399: referenced as `as`
	cmplStd/lib/math/Fixed.ci:386: referenced as `as`
	cmplStd/lib/math/Fixed.ci:378: referenced as `as`
	cmplStd/lib/math/Fixed.ci:357: referenced as `as`
	cmplStd/lib/math/Fixed.ci:355: referenced as `as`
	cmplStd/lib/math/Fixed.ci:318: referenced as `as`
	cmplStd/lib/math/Fixed.ci:303: referenced as `as`
	cmplStd/lib/math/Fixed.ci:297: referenced as `as`
	cmplStd/lib/math/Fixed.ci:99: referenced as `as`
	cmplStd/lib/math/Fixed.ci:57: referenced as `as`
	cmplStd/lib/math/Fixed.ci:55: referenced as `as`
}
Fixed.neg(a: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 6
.name: 'neg'
.file: 'cmplStd/lib/math/Fixed.ci:38'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.doc: 'Computes the negated value of the given number.'
.value: {
	return .result := {
			.result.value := -a.value;
		};
}
.instructions: (6 bytes)
	cmplStd/lib/math/Fixed.ci:38: (6 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:38: (5 bytes): .result.value := -a.value;
	<neg>  : dup.x32 sp(1)
	<neg+?>: neg.i32
	<neg+?>: set.x32 sp(4)
	<neg+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:503: referenced as `neg`
	cmplStd/lib/math/Fixed.ci:94: referenced as `neg`
	cmplStd/lib/math/Fixed.ci:94: referenced as `neg`
}
Fixed.add(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'add'
.file: 'cmplStd/lib/math/Fixed.ci:41'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Adds the two fixed point numbers.'
.value: {
	return .result := {
			.result.value := a.value + b.value;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:41: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:41: (7 bytes): .result.value := a.value + b.value;
	<add>  : dup.x32 sp(3)
	<add+?>: dup.x32 sp(2)
	<add+?>: add.i32
	<add+?>: set.x32 sp(6)
	<add+?>: ret
.usages:
}
Fixed.sub(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'sub'
.file: 'cmplStd/lib/math/Fixed.ci:44'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Subtract one from another fixed point number.'
.value: {
	return .result := {
			.result.value := a.value - b.value;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:44: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:44: (7 bytes): .result.value := a.value - b.value;
	<sub>  : dup.x32 sp(3)
	<sub+?>: dup.x32 sp(2)
	<sub+?>: sub.i32
	<sub+?>: set.x32 sp(6)
	<sub+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:503: referenced as `sub`
}
Fixed.mul(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 17
.name: 'mul'
.file: 'cmplStd/lib/math/Fixed.ci:47'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Multiply two fixed-point numbers.'
.value: {
	return .result := {
			.result.value := ((int64(a.value) * (b.value)) >> precision);
		};
}
.instructions: (17 bytes)
	cmplStd/lib/math/Fixed.ci:47: (17 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:47: (16 bytes): .result.value := ((int64(a.value) * (b.value)) >> precision);
	<mul>  : dup.x32 sp(3)
	<mul+?>: i32.2i64
	<mul+?>: dup.x32 sp(3)
	<mul+?>: i32.2i64
	<mul+?>: mul.i64
	<mul+?>: load.c32 20
	<mul+?>: sar.b64
	<mul+?>: i64.2i32
	<mul+?>: set.x32 sp(6)
	<mul+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:486: referenced as `mul`
	cmplStd/lib/math/Fixed.ci:440: referenced as `mul`
}
Fixed.mul(a: Fixed, b: int32): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'mul'
.file: 'cmplStd/lib/math/Fixed.ci:48'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: int32 (size: 4, cast: variable(i32))
.value: {
	return .result := {
			.result.value := a.value * b;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:48: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:48: (7 bytes): .result.value := a.value * b;
	<mul>  : dup.x32 sp(2)
	<mul+?>: dup.x32 sp(2)
	<mul+?>: mul.i32
	<mul+?>: set.x32 sp(5)
	<mul+?>: ret
.usages:
}
Fixed.mul_28(a: Fixed, b: int32): Fixed: function {
.kind: static function
.base: `function`
.size: 17
.name: 'mul_28'
.file: 'cmplStd/lib/math/Fixed.ci:49'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: int32 (size: 4, cast: variable(i32))
.value: {
	return .result := {
			.result.value := (int64(a.value) * (b) >> 28);
		};
}
.instructions: (17 bytes)
	cmplStd/lib/math/Fixed.ci:49: (17 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:49: (16 bytes): .result.value := (int64(a.value) * (b) >> 28);
	<mul_28>  : dup.x32 sp(2)
	<mul_28+?>: i32.2i64
	<mul_28+?>: dup.x32 sp(3)
	<mul_28+?>: i32.2i64
	<mul_28+?>: mul.i64
	<mul_28+?>: load.c32 28
	<mul_28+?>: sar.b64
	<mul_28+?>: i64.2i32
	<mul_28+?>: set.x32 sp(5)
	<mul_28+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:720: referenced as `mul_28`
	cmplStd/lib/math/Fixed.ci:342: referenced as `mul_28`
	cmplStd/lib/math/Fixed.ci:330: referenced as `mul_28`
	cmplStd/lib/math/Fixed.ci:227: referenced as `mul_28`
	cmplStd/lib/math/Fixed.ci:211: referenced as `mul_28`
}
Fixed.div(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 94
.name: 'div'
.file: 'cmplStd/lib/math/Fixed.ci:52'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Divide one fixed-point number with another one.'
.value: {
	if (b.value == 0) {
		if (a.value == 0) {
			return .result := as(nan);
		}
		return .result := as(a.value < 0 ? -inf : inf);
	}
	return .result := {
			.result.value := ((int64(a.value) << precision) / (b.value));
		};
}
.instructions: (94 bytes)
	cmplStd/lib/math/Fixed.ci:53: (77 bytes): if (b.value == 0)
	<div>  : dup.x32 sp(1)
	<div+?>: load.z32
	<div+?>: ceq.i32
	<div+?>: jz +73
	cmplStd/lib/math/Fixed.ci:54: (30 bytes): if (a.value == 0)
	<div+?>: dup.x32 sp(3)
	<div+?>: load.z32
	<div+?>: ceq.i32
	<div+?>: jz +26
	cmplStd/lib/math/Fixed.ci:55: (22 bytes): return .result := as(nan);
	<div+?>: inc.sp(+8)
	<div+?>: load.c32 -2147483648
	<div+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<div+?>: call
	<div+?>: inc.sp(-4)
	<div+?>: set.x64 sp(7)
	<div+?>: ret
	cmplStd/lib/math/Fixed.ci:57: (39 bytes): return .result := as(a.value < 0 ? -inf : inf);
	<div+?>: inc.sp(+8)
	<div+?>: dup.x32 sp(5)
	<div+?>: load.z32
	<div+?>: clt.i32
	<div+?>: jz +13
	<div+?>: load.c32 -2147483647
	<div+?>: jmp +9
	<div+?>: load.c32 2147483647
	<div+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<div+?>: call
	<div+?>: inc.sp(-4)
	<div+?>: set.x64 sp(7)
	<div+?>: ret
	cmplStd/lib/math/Fixed.ci:59: (17 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:59: (16 bytes): .result.value := ((int64(a.value) << precision) / (b.value));
	<div+?>: dup.x32 sp(3)
	<div+?>: i32.2i64
	<div+?>: load.c32 20
	<div+?>: shl.b64
	<div+?>: dup.x32 sp(3)
	<div+?>: i32.2i64
	<div+?>: div.i64
	<div+?>: i64.2i32
	<div+?>: set.x32 sp(6)
	<div+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:610: referenced as `div`
	cmplStd/lib/math/Fixed.ci:241: referenced as `div`
}
Fixed.div(a: Fixed, b: int32): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'div'
.file: 'cmplStd/lib/math/Fixed.ci:61'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: int32 (size: 4, cast: variable(i32))
.value: {
	return .result := {
			.result.value := a.value / b;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:61: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:61: (7 bytes): .result.value := a.value / b;
	<div>  : dup.x32 sp(2)
	<div+?>: dup.x32 sp(2)
	<div+?>: div.i32
	<div+?>: set.x32 sp(5)
	<div+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:503: referenced as `div`
	cmplStd/lib/math/Fixed.ci:361: referenced as `div`
}
Fixed.mod(a: Fixed, b: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 8
.name: 'mod'
.file: 'cmplStd/lib/math/Fixed.ci:64'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the remainder of the division of `a` by `b`.'
.value: {
	return .result := {
			.result.value := a.value % b.value;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/math/Fixed.ci:64: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:64: (7 bytes): .result.value := a.value % b.value;
	<mod>  : dup.x32 sp(3)
	<mod+?>: dup.x32 sp(2)
	<mod+?>: mod.i32
	<mod+?>: set.x32 sp(6)
	<mod+?>: ret
.usages:
}
Fixed.inv(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 95
.name: 'inv'
.file: 'cmplStd/lib/math/Fixed.ci:67'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Compute the reciprocal of a complex number (1 / a)'
.value: {
	if (x.value == 0) {
		return .result := {
			.result.value := inf;
		};
	}
	value: int64 := (int64(one) << precision) / (x.value);
	if (value >> 31 != value >> 63) {
		return .result := {
			.result.value := value < (0) ? -inf : inf;
		};
	}
	return .result := {
			.result.value := (value);
		};
}
.instructions: (95 bytes)
	cmplStd/lib/math/Fixed.ci:68: (16 bytes): if (x.value == 0)
	<inv>  : dup.x32 sp(1)
	<inv+?>: load.z32
	<inv+?>: ceq.i32
	<inv+?>: jz +12
	cmplStd/lib/math/Fixed.ci:69: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:69: (7 bytes): .result.value := inf;
	<inv+?>: load.c32 2147483647
	<inv+?>: set.x32 sp(4)
	<inv+?>: ret
	cmplStd/lib/math/Fixed.ci:71: (19 bytes): value: int64 := (int64(one) << precision) / (x.value)
	<inv+?>: load.c64 1048576
	<inv+?>: load.c32 20
	<inv+?>: shl.b64
	<inv+?>: dup.x32 sp(3)
	<inv+?>: i32.2i64
	<inv+?>: div.i64
	cmplStd/lib/math/Fixed.ci:72: (50 bytes): if (value >> 31 != value >> 63)
	<inv+?>: dup.x64 sp(0)
	<inv+?>: load.c32 31
	<inv+?>: sar.b64
	<inv+?>: dup.x64 sp(2)
	<inv+?>: load.c32 63
	<inv+?>: sar.b64
	<inv+?>: ceq.i64
	<inv+?>: jnz +33
	cmplStd/lib/math/Fixed.ci:73: (29 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:73: (24 bytes): .result.value := value < (0) ? -inf : inf;
	<inv+?>: dup.x64 sp(0)
	<inv+?>: load.z64
	<inv+?>: clt.i64
	<inv+?>: jz +13
	<inv+?>: load.c32 -2147483647
	<inv+?>: jmp +9
	<inv+?>: load.c32 2147483647
	<inv+?>: set.x32 sp(6)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
	cmplStd/lib/math/Fixed.ci:75: (10 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:75: (5 bytes): .result.value := (value);
	<inv+?>: dup.x64 sp(0)
	<inv+?>: i64.2i32
	<inv+?>: set.x32 sp(6)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:437: referenced as `inv`
}
Fixed.fract(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 34
.name: 'fract'
.file: 'cmplStd/lib/math/Fixed.ci:80'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the fractional part of the fixed point number'
.value: {
	if (x.value < 0) {
		return .result := {
			.result.value := -(-x.value & mask);
		};
	}
	return .result := {
			.result.value := x.value & (nan | mask);
		};
}
.instructions: (34 bytes)
	cmplStd/lib/math/Fixed.ci:81: (17 bytes): if (x.value < 0)
	<fract>  : dup.x32 sp(1)
	<fract+?>: load.z32
	<fract+?>: clt.i32
	<fract+?>: jz +13
	cmplStd/lib/math/Fixed.ci:82: (9 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:82: (8 bytes): .result.value := -(-x.value & mask);
	<fract+?>: dup.x32 sp(1)
	<fract+?>: neg.i32
	<fract+?>: b32.and 0xfffff
	<fract+?>: neg.i32
	<fract+?>: set.x32 sp(4)
	<fract+?>: ret
	cmplStd/lib/math/Fixed.ci:84: (17 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:84: (16 bytes): .result.value := x.value & (nan | mask);
	<fract+?>: dup.x32 sp(1)
	<fract+?>: load.c32 -2147483648
	<fract+?>: load.c32 1048575
	<fract+?>: or.b32
	<fract+?>: and.b32
	<fract+?>: set.x32 sp(4)
	<fract+?>: ret
.usages:
}
Fixed.floor(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 12
.name: 'floor'
.file: 'cmplStd/lib/math/Fixed.ci:88'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Computes the largest integer that is less than or equal to `x`.'
.value: {
	return .result := {
			.result.value := x.value & ~mask;
		};
}
.instructions: (12 bytes)
	cmplStd/lib/math/Fixed.ci:89: (12 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:89: (11 bytes): .result.value := x.value & ~mask;
	<floor>  : dup.x32 sp(1)
	<floor+?>: load.c32 1048575
	<floor+?>: cmt.b32
	<floor+?>: and.b32
	<floor+?>: set.x32 sp(4)
	<floor+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:99: referenced as `floor`
	cmplStd/lib/math/Fixed.ci:94: referenced as `floor`
}
Fixed.ceil(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 47
.name: 'ceil'
.file: 'cmplStd/lib/math/Fixed.ci:93'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Computes the smallest integer that is greater than or equal to `x`.'
.value: {
	return .result := neg(floor(neg(x)));
}
.instructions: (47 bytes)
	cmplStd/lib/math/Fixed.ci:94: (47 bytes): return .result := neg(floor(neg(x)));
	<ceil>  : inc.sp(+8)
	<ceil+?>: inc.sp(+8)
	<ceil+?>: inc.sp(+8)
	<ceil+?>: dup.x64 sp(7)
	<ceil+?>: load.ref <?> ;Fixed.neg(a: Fixed): Fixed
	<ceil+?>: call
	<ceil+?>: inc.sp(-8)
	<ceil+?>: load.ref <?> ;Fixed.floor(x: Fixed): Fixed
	<ceil+?>: call
	<ceil+?>: inc.sp(-8)
	<ceil+?>: load.ref <?> ;Fixed.neg(a: Fixed): Fixed
	<ceil+?>: call
	<ceil+?>: inc.sp(-8)
	<ceil+?>: set.x64 sp(5)
	<ceil+?>: ret
.usages:
}
Fixed.round(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 37
.name: 'round'
.file: 'cmplStd/lib/math/Fixed.ci:98'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Computes the nearest integer to `x`.'
.value: {
	return .result := floor(as(x.value + half));
}
.instructions: (37 bytes)
	cmplStd/lib/math/Fixed.ci:99: (37 bytes): return .result := floor(as(x.value + half));
	<round>  : inc.sp(+8)
	<round+?>: inc.sp(+8)
	<round+?>: dup.x32 sp(5)
	<round+?>: inc.i32(+524288)
	<round+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<round+?>: call
	<round+?>: inc.sp(-4)
	<round+?>: load.ref <?> ;Fixed.floor(x: Fixed): Fixed
	<round+?>: call
	<round+?>: inc.sp(-8)
	<round+?>: set.x64 sp(5)
	<round+?>: ret
.usages:
}
Fixed.isFinite(x: Fixed): bool: function {
.kind: static function
.base: `function`
.size: 68
.name: 'isFinite'
.file: 'cmplStd/lib/math/Fixed.ci:103'
.owner: Fixed
.param .result: bool (size: 4, cast: variable(bool))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Determines whether the given fixed point value is finite: `!isNan(x) && !isInf(x)`'
.value: {
	if (x.value == nan) {
		return .result := false;
	}
	if (x.value == inf) {
		return .result := false;
	}
	if (x.value == -inf) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (68 bytes)
	cmplStd/lib/math/Fixed.ci:104: (19 bytes): if (x.value == nan)
	<isFinite>  : dup.x32 sp(1)
	<isFinite+?>: load.c32 -2147483648
	<isFinite+?>: ceq.i32
	<isFinite+?>: jz +11
	cmplStd/lib/math/Fixed.ci:105: (7 bytes): return .result := false;
	<isFinite+?>: load.z32
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
	cmplStd/lib/math/Fixed.ci:107: (19 bytes): if (x.value == inf)
	<isFinite+?>: dup.x32 sp(1)
	<isFinite+?>: load.c32 2147483647
	<isFinite+?>: ceq.i32
	<isFinite+?>: jz +11
	cmplStd/lib/math/Fixed.ci:108: (7 bytes): return .result := false;
	<isFinite+?>: load.z32
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
	cmplStd/lib/math/Fixed.ci:110: (19 bytes): if (x.value == -inf)
	<isFinite+?>: dup.x32 sp(1)
	<isFinite+?>: load.c32 -2147483647
	<isFinite+?>: ceq.i32
	<isFinite+?>: jz +11
	cmplStd/lib/math/Fixed.ci:111: (7 bytes): return .result := false;
	<isFinite+?>: load.z32
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
	cmplStd/lib/math/Fixed.ci:113: (11 bytes): return .result := true;
	<isFinite+?>: load.c32 1
	<isFinite+?>: load.sp(+16)
	<isFinite+?>: store.i8
	<isFinite+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:498: referenced as `isFinite`
	cmplStd/lib/math/Fixed.ci:238: referenced as `isFinite`
	cmplStd/lib/math/Fixed.ci:234: referenced as `isFinite`
	cmplStd/lib/math/Fixed.ci:224: referenced as `isFinite`
	cmplStd/lib/math/Fixed.ci:207: referenced as `isFinite`
}
Fixed.isNan(x: Fixed): bool: function {
.kind: static function
.base: `function`
.size: 14
.name: 'isNan'
.file: 'cmplStd/lib/math/Fixed.ci:116'
.owner: Fixed
.param .result: bool (size: 4, cast: variable(bool))
.param x: Fixed (size: 8, cast: variable(val))
.value: {
	return .result := x.value == nan;
}
.instructions: (14 bytes)
	cmplStd/lib/math/Fixed.ci:117: (14 bytes): return .result := x.value == nan;
	<isNan>  : dup.x32 sp(1)
	<isNan+?>: load.c32 -2147483648
	<isNan+?>: ceq.i32
	<isNan+?>: load.sp(+16)
	<isNan+?>: store.i8
	<isNan+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:300: referenced as `isNan`
}
Fixed.compare(a: Fixed, b: Fixed): int32: function {
.kind: static function
.base: `function`
.size: 14
.name: 'compare'
.file: 'cmplStd/lib/math/Fixed.ci:121'
.owner: Fixed
.param .result: int32 (size: 4, cast: variable(i32))
.param a: Fixed (size: 8, cast: variable(val))
.param b: Fixed (size: 8, cast: variable(val))
.doc: 'Determines whether the given fixed point is less than the other one.'
.value: {
	return .result := int32(a.value < b.value) - int32(a.value > b.value);
}
.instructions: (14 bytes)
	cmplStd/lib/math/Fixed.ci:122: (14 bytes): return .result := int32(a.value < b.value) - int32(a.value > b.value);
	<compare>  : dup.x32 sp(3)
	<compare+?>: dup.x32 sp(2)
	<compare+?>: clt.i32
	<compare+?>: dup.x32 sp(4)
	<compare+?>: dup.x32 sp(3)
	<compare+?>: cgt.i32
	<compare+?>: sub.i32
	<compare+?>: set.x32 sp(6)
	<compare+?>: ret
.usages:
}
Fixed.log2(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 194
.name: 'log2'
.file: 'cmplStd/lib/math/Fixed.ci:134'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the binary logarithm of the argument `x`.
	log2(x) = log2((2 ** n) * ((x / 2) ** n)) =
	= log2(2 ** n) + log2((x / 2) ** n) = n + log2(q)
	n = most significant bit of x (BSR (bit scan reverse))
	q = (x / 2) ** n = (x > 1) ? (x >> n) : (x << -n)
	x > 1 <=> n - precision > 0
	log2(q) = look up from table'
.value: {
	static const tbl_log2: uint32[257] := {
		tbl_log2[0] := (0);
		tbl_log2[1] := (6039313);
		tbl_log2[2] := (12055173);
		tbl_log2[3] := (18047761);
		tbl_log2[4] := (24017256);
		tbl_log2[5] := (29963835);
		tbl_log2[6] := (35887674);
		tbl_log2[7] := (41788946);
		tbl_log2[8] := (47667822);
		tbl_log2[9] := (53524472);
		tbl_log2[10] := (59359063);
		tbl_log2[11] := (65171760);
		tbl_log2[12] := (70962727);
		tbl_log2[13] := (76732127);
		tbl_log2[14] := (82480119);
		tbl_log2[15] := (88206861);
		tbl_log2[16] := (93912510);
		tbl_log2[17] := (99597221);
		tbl_log2[18] := (105261147);
		tbl_log2[19] := (110904439);
		tbl_log2[20] := (116527248);
		tbl_log2[21] := (122129720);
		tbl_log2[22] := (127712004);
		tbl_log2[23] := (133274243);
		tbl_log2[24] := (138816582);
		tbl_log2[25] := (144339162);
		tbl_log2[26] := (149842123);
		tbl_log2[27] := (155325605);
		tbl_log2[28] := (160789745);
		tbl_log2[29] := (166234678);
		tbl_log2[30] := (171660540);
		tbl_log2[31] := (177067464);
		tbl_log2[32] := (182455580);
		tbl_log2[33] := (187825021);
		tbl_log2[34] := (193175914);
		tbl_log2[35] := (198508387);
		tbl_log2[36] := (203822568);
		tbl_log2[37] := (209118580);
		tbl_log2[38] := (214396547);
		tbl_log2[39] := (219656593);
		tbl_log2[40] := (224898838);
		tbl_log2[41] := (230123403);
		tbl_log2[42] := (235330406);
		tbl_log2[43] := (240519966);
		tbl_log2[44] := (245692198);
		tbl_log2[45] := (250847217);
		tbl_log2[46] := (255985139);
		tbl_log2[47] := (261106076);
		tbl_log2[48] := (266210140);
		tbl_log2[49] := (271297442);
		tbl_log2[50] := (276368091);
		tbl_log2[51] := (281422197);
		tbl_log2[52] := (286459866);
		tbl_log2[53] := (291481206);
		tbl_log2[54] := (296486322);
		tbl_log2[55] := (301475318);
		tbl_log2[56] := (306448299);
		tbl_log2[57] := (311405365);
		tbl_log2[58] := (316346620);
		tbl_log2[59] := (321272163);
		tbl_log2[60] := (326182094);
		tbl_log2[61] := (331076512);
		tbl_log2[62] := (335955515);
		tbl_log2[63] := (340819198);
		tbl_log2[64] := (345667659);
		tbl_log2[65] := (350500992);
		tbl_log2[66] := (355319292);
		tbl_log2[67] := (360122651);
		tbl_log2[68] := (364911161);
		tbl_log2[69] := (369684916);
		tbl_log2[70] := (374444004);
		tbl_log2[71] := (379188516);
		tbl_log2[72] := (383918541);
		tbl_log2[73] := (388634167);
		tbl_log2[74] := (393335482);
		tbl_log2[75] := (398022572);
		tbl_log2[76] := (402695523);
		tbl_log2[77] := (407354419);
		tbl_log2[78] := (411999346);
		tbl_log2[79] := (416630387);
		tbl_log2[80] := (421247625);
		tbl_log2[81] := (425851141);
		tbl_log2[82] := (430441017);
		tbl_log2[83] := (435017333);
		tbl_log2[84] := (439580170);
		tbl_log2[85] := (444129606);
		tbl_log2[86] := (448665721);
		tbl_log2[87] := (453188591);
		tbl_log2[88] := (457698295);
		tbl_log2[89] := (462194907);
		tbl_log2[90] := (466678505);
		tbl_log2[91] := (471149164);
		tbl_log2[92] := (475606957);
		tbl_log2[93] := (480051958);
		tbl_log2[94] := (484484242);
		tbl_log2[95] := (488903880);
		tbl_log2[96] := (493310944);
		tbl_log2[97] := (497705506);
		tbl_log2[98] := (502087636);
		tbl_log2[99] := (506457405);
		tbl_log2[100] := (510814881);
		tbl_log2[101] := (515160135);
		tbl_log2[102] := (519493235);
		tbl_log2[103] := (523814247);
		tbl_log2[104] := (528123240);
		tbl_log2[105] := (532420281);
		tbl_log2[106] := (536705434);
		tbl_log2[107] := (540978766);
		tbl_log2[108] := (545240343);
		tbl_log2[109] := (549490227);
		tbl_log2[110] := (553728484);
		tbl_log2[111] := (557955177);
		tbl_log2[112] := (562170369);
		tbl_log2[113] := (566374122);
		tbl_log2[114] := (570566498);
		tbl_log2[115] := (574747559);
		tbl_log2[116] := (578917365);
		tbl_log2[117] := (583075977);
		tbl_log2[118] := (587223454);
		tbl_log2[119] := (591359857);
		tbl_log2[120] := (595485245);
		tbl_log2[121] := (599599675);
		tbl_log2[122] := (603703206);
		tbl_log2[123] := (607795895);
		tbl_log2[124] := (611877800);
		tbl_log2[125] := (615948977);
		tbl_log2[126] := (620009483);
		tbl_log2[127] := (624059372);
		tbl_log2[128] := (628098702);
		tbl_log2[129] := (632127526);
		tbl_log2[130] := (636145899);
		tbl_log2[131] := (640153876);
		tbl_log2[132] := (644151509);
		tbl_log2[133] := (648138852);
		tbl_log2[134] := (652115958);
		tbl_log2[135] := (656082880);
		tbl_log2[136] := (660039669);
		tbl_log2[137] := (663986377);
		tbl_log2[138] := (667923055);
		tbl_log2[139] := (671849754);
		tbl_log2[140] := (675766525);
		tbl_log2[141] := (679673417);
		tbl_log2[142] := (683570481);
		tbl_log2[143] := (687457765);
		tbl_log2[144] := (691335319);
		tbl_log2[145] := (695203191);
		tbl_log2[146] := (699061430);
		tbl_log2[147] := (702910083);
		tbl_log2[148] := (706749198);
		tbl_log2[149] := (710578821);
		tbl_log2[150] := (714399001);
		tbl_log2[151] := (718209783);
		tbl_log2[152] := (722011213);
		tbl_log2[153] := (725803337);
		tbl_log2[154] := (729586201);
		tbl_log2[155] := (733359850);
		tbl_log2[156] := (737124328);
		tbl_log2[157] := (740879680);
		tbl_log2[158] := (744625950);
		tbl_log2[159] := (748363182);
		tbl_log2[160] := (752091420);
		tbl_log2[161] := (755810706);
		tbl_log2[162] := (759521084);
		tbl_log2[163] := (763222596);
		tbl_log2[164] := (766915284);
		tbl_log2[165] := (770599191);
		tbl_log2[166] := (774274358);
		tbl_log2[167] := (777940826);
		tbl_log2[168] := (781598636);
		tbl_log2[169] := (785247830);
		tbl_log2[170] := (788888447);
		tbl_log2[171] := (792520529);
		tbl_log2[172] := (796144114);
		tbl_log2[173] := (799759243);
		tbl_log2[174] := (803365955);
		tbl_log2[175] := (806964288);
		tbl_log2[176] := (810554283);
		tbl_log2[177] := (814135977);
		tbl_log2[178] := (817709409);
		tbl_log2[179] := (821274616);
		tbl_log2[180] := (824831638);
		tbl_log2[181] := (828380510);
		tbl_log2[182] := (831921270);
		tbl_log2[183] := (835453956);
		tbl_log2[184] := (838978604);
		tbl_log2[185] := (842495250);
		tbl_log2[186] := (846003931);
		tbl_log2[187] := (849504683);
		tbl_log2[188] := (852997541);
		tbl_log2[189] := (856482541);
		tbl_log2[190] := (859959719);
		tbl_log2[191] := (863429109);
		tbl_log2[192] := (866890746);
		tbl_log2[193] := (870344665);
		tbl_log2[194] := (873790900);
		tbl_log2[195] := (877229485);
		tbl_log2[196] := (880660455);
		tbl_log2[197] := (884083842);
		tbl_log2[198] := (887499680);
		tbl_log2[199] := (890908002);
		tbl_log2[200] := (894308843);
		tbl_log2[201] := (897702233);
		tbl_log2[202] := (901088206);
		tbl_log2[203] := (904466794);
		tbl_log2[204] := (907838029);
		tbl_log2[205] := (911201943);
		tbl_log2[206] := (914558569);
		tbl_log2[207] := (917907937);
		tbl_log2[208] := (921250078);
		tbl_log2[209] := (924585025);
		tbl_log2[210] := (927912807);
		tbl_log2[211] := (931233455);
		tbl_log2[212] := (934547001);
		tbl_log2[213] := (937853474);
		tbl_log2[214] := (941152904);
		tbl_log2[215] := (944445322);
		tbl_log2[216] := (947730757);
		tbl_log2[217] := (951009239);
		tbl_log2[218] := (954280797);
		tbl_log2[219] := (957545460);
		tbl_log2[220] := (960803257);
		tbl_log2[221] := (964054217);
		tbl_log2[222] := (967298369);
		tbl_log2[223] := (970535741);
		tbl_log2[224] := (973766362);
		tbl_log2[225] := (976990259);
		tbl_log2[226] := (980207460);
		tbl_log2[227] := (983417994);
		tbl_log2[228] := (986621888);
		tbl_log2[229] := (989819169);
		tbl_log2[230] := (993009864);
		tbl_log2[231] := (996194001);
		tbl_log2[232] := (999371606);
		tbl_log2[233] := (1002542706);
		tbl_log2[234] := (1005707329);
		tbl_log2[235] := (1008865499);
		tbl_log2[236] := (1012017244);
		tbl_log2[237] := (1015162589);
		tbl_log2[238] := (1018301561);
		tbl_log2[239] := (1021434184);
		tbl_log2[240] := (1024560486);
		tbl_log2[241] := (1027680491);
		tbl_log2[242] := (1030794225);
		tbl_log2[243] := (1033901713);
		tbl_log2[244] := (1037002979);
		tbl_log2[245] := (1040098049);
		tbl_log2[246] := (1043186947);
		tbl_log2[247] := (1046269698);
		tbl_log2[248] := (1049346327);
		tbl_log2[249] := (1052416857);
		tbl_log2[250] := (1055481313);
		tbl_log2[251] := (1058539719);
		tbl_log2[252] := (1061592098);
		tbl_log2[253] := (1064638475);
		tbl_log2[254] := (1067678872);
		tbl_log2[255] := (1070713314);
		tbl_log2[256] := (1073741824);
	};
	if (x.value <= 0) {
		if (x.value == 0) {
			return .result := {
			.result.value := -inf;
		};
		}
		return .result := {
			.result.value := nan;
		};
	}
	n: int32 := Bits.scanReverse(x.value);
	static if (precision < 8) {
		error_not_implemented_yet
	}
	idx: uint32 := (n > 8 ? x.value >> n - 8 : x.value << 8 - n) & 255;
	value: int32 := tbl_log2[idx];
	static if (precision > 8) {
		mix: uint32 := (n > 16 ? x.value >> n - 16 : x.value << 16 - n) & 255;
		value := value + (mix * (tbl_log2[idx + (1)] - (value)) >> 8);
	}
	return .result := {
			.result.value := (n - precision << precision) + (value >> 30 - precision);
		};
}
.instructions: (194 bytes)
	cmplStd/lib/math/Fixed.ci:176: (32 bytes): if (x.value <= 0)
	<log2>  : dup.x32 sp(1)
	<log2+?>: load.z32
	<log2+?>: cgt.i32
	<log2+?>: jnz +28
	cmplStd/lib/math/Fixed.ci:177: (16 bytes): if (x.value == 0)
	<log2+?>: dup.x32 sp(1)
	<log2+?>: load.z32
	<log2+?>: ceq.i32
	<log2+?>: jz +12
	cmplStd/lib/math/Fixed.ci:178: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:178: (7 bytes): .result.value := -inf;
	<log2+?>: load.c32 -2147483647
	<log2+?>: set.x32 sp(4)
	<log2+?>: ret
	cmplStd/lib/math/Fixed.ci:180: (8 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:180: (7 bytes): .result.value := nan;
	<log2+?>: load.c32 -2147483648
	<log2+?>: set.x32 sp(4)
	<log2+?>: ret
	cmplStd/lib/math/Fixed.ci:183: (13 bytes): n: int32 := Bits.scanReverse(x.value)
	<log2+?>: load.z32
	<log2+?>: dup.x32 sp(2)
	<log2+?>: load.ref <?> ;Bits.scanReverse(x: uint32): int32
	<log2+?>: call
	<log2+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:185: (38 bytes): idx: uint32 := (n > 8 ? x.value >> n - 8 : x.value << 8 - n) & 255
	<log2+?>: dup.x32 sp(0)
	<log2+?>: load.c32 8
	<log2+?>: cgt.i32
	<log2+?>: jz +17
	<log2+?>: dup.x32 sp(2)
	<log2+?>: dup.x32 sp(1)
	<log2+?>: inc.i32(-8)
	<log2+?>: sar.b32
	<log2+?>: jmp +15
	<log2+?>: dup.x32 sp(2)
	<log2+?>: load.c32 8
	<log2+?>: dup.x32 sp(2)
	<log2+?>: sub.i32
	<log2+?>: shl.b32
	<log2+?>: b32.and 0xff
	cmplStd/lib/math/Fixed.ci:186: (12 bytes): value: int32 := tbl_log2[idx]
	<log2+?>: load.ref <?> ;Fixed.log2.tbl_log2
	<log2+?>: dup.x32 sp(1)
	<log2+?>: mad.u32 4
	<log2+?>: load.i32
	cmplStd/lib/math/Fixed.ci:188: (38 bytes): mix: uint32 := (n > 16 ? x.value >> n - 16 : x.value << 16 - n) & 255
	<log2+?>: dup.x32 sp(2)
	<log2+?>: load.c32 16
	<log2+?>: cgt.i32
	<log2+?>: jz +17
	<log2+?>: dup.x32 sp(4)
	<log2+?>: dup.x32 sp(3)
	<log2+?>: inc.i32(-16)
	<log2+?>: sar.b32
	<log2+?>: jmp +15
	<log2+?>: dup.x32 sp(4)
	<log2+?>: load.c32 16
	<log2+?>: dup.x32 sp(4)
	<log2+?>: sub.i32
	<log2+?>: shl.b32
	<log2+?>: b32.and 0xff
	cmplStd/lib/math/Fixed.ci:192: (29 bytes): value := value + (mix * (tbl_log2[idx + (1)] - (value)) >> 8);
	<log2+?>: dup.x32 sp(1)
	<log2+?>: dup.x32 sp(1)
	<log2+?>: load.ref <?> ;Fixed.log2.tbl_log2
	<log2+?>: dup.x32 sp(5)
	<log2+?>: inc.i32(+1)
	<log2+?>: mad.u32 4
	<log2+?>: load.i32
	<log2+?>: dup.x32 sp(4)
	<log2+?>: sub.i32
	<log2+?>: mul.u32
	<log2+?>: b32.shr 0x08
	<log2+?>: add.i32
	<log2+?>: set.x32 sp(2)
	<log2+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:194: (28 bytes): return .result := {...};
	cmplStd/lib/math/Fixed.ci:194: (23 bytes): .result.value := (n - precision << precision) + (value >> 30 - precision);
	<log2+?>: dup.x32 sp(2)
	<log2+?>: inc.i32(-20)
	<log2+?>: b32.shl 0x14
	<log2+?>: dup.x32 sp(1)
	<log2+?>: load.c32 30
	<log2+?>: inc.i32(-20)
	<log2+?>: sar.b32
	<log2+?>: add.i32
	<log2+?>: set.x32 sp(7)
	<log2+?>: inc.sp(-12)
	<log2+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:440: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:361: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:237: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:233: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:223: referenced as `log2`
	cmplStd/lib/math/Fixed.ci:206: referenced as `log2`
}
Fixed.log(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 63
.name: 'log'
.file: 'cmplStd/lib/math/Fixed.ci:198'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the natural logarithm of the argument `x`.'
.value: {
	x := log2(x);
	if (!isFinite(x)) {
		return .result := x;
	}
	return .result := mul_28(x, ln2_28);
}
.instructions: (63 bytes)
	cmplStd/lib/math/Fixed.ci:206: (18 bytes): x := log2(x);
	<log>  : inc.sp(+8)
	<log+?>: dup.x64 sp(3)
	<log+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: set.x64 sp(3)
	cmplStd/lib/math/Fixed.ci:207: (21 bytes): if (!isFinite(x))
	<log+?>: load.z32
	<log+?>: dup.x64 sp(2)
	<log+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:208: (4 bytes): return .result := x;
	<log+?>: mov.x64 sp(3, 1)
	<log+?>: ret
	cmplStd/lib/math/Fixed.ci:211: (24 bytes): return .result := mul_28(x, ln2_28);
	<log+?>: inc.sp(+8)
	<log+?>: dup.x64 sp(3)
	<log+?>: load.c32 186065279
	<log+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<log+?>: call
	<log+?>: inc.sp(-12)
	<log+?>: set.x64 sp(5)
	<log+?>: ret
.usages:
}
Fixed.log10(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 63
.name: 'log10'
.file: 'cmplStd/lib/math/Fixed.ci:215'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the decimal logarithm of the argument `x`.'
.value: {
	x := log2(x);
	if (!isFinite(x)) {
		return .result := x;
	}
	return .result := mul_28(x, lg2_28);
}
.instructions: (63 bytes)
	cmplStd/lib/math/Fixed.ci:223: (18 bytes): x := log2(x);
	<log10>  : inc.sp(+8)
	<log10+?>: dup.x64 sp(3)
	<log10+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<log10+?>: call
	<log10+?>: inc.sp(-8)
	<log10+?>: set.x64 sp(3)
	cmplStd/lib/math/Fixed.ci:224: (21 bytes): if (!isFinite(x))
	<log10+?>: load.z32
	<log10+?>: dup.x64 sp(2)
	<log10+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<log10+?>: call
	<log10+?>: inc.sp(-8)
	<log10+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:225: (4 bytes): return .result := x;
	<log10+?>: mov.x64 sp(3, 1)
	<log10+?>: ret
	cmplStd/lib/math/Fixed.ci:227: (24 bytes): return .result := mul_28(x, lg2_28);
	<log10+?>: inc.sp(+8)
	<log10+?>: dup.x64 sp(3)
	<log10+?>: load.c32 80807124
	<log10+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<log10+?>: call
	<log10+?>: inc.sp(-12)
	<log10+?>: set.x64 sp(5)
	<log10+?>: ret
.usages:
}
Fixed.log(x: Fixed, base: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 99
.name: 'log'
.file: 'cmplStd/lib/math/Fixed.ci:231'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.param base: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the logarithm of the argument `x`.'
.value: {
	x := log2(x);
	if (!isFinite(x)) {
		return .result := x;
	}
	base := log2(base);
	if (!isFinite(base)) {
		return .result := base;
	}
	return .result := div(x, base);
}
.instructions: (99 bytes)
	cmplStd/lib/math/Fixed.ci:233: (18 bytes): x := log2(x);
	<log>  : inc.sp(+8)
	<log+?>: dup.x64 sp(5)
	<log+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: set.x64 sp(5)
	cmplStd/lib/math/Fixed.ci:234: (21 bytes): if (!isFinite(x))
	<log+?>: load.z32
	<log+?>: dup.x64 sp(4)
	<log+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:235: (4 bytes): return .result := x;
	<log+?>: mov.x64 sp(5, 3)
	<log+?>: ret
	cmplStd/lib/math/Fixed.ci:237: (18 bytes): base := log2(base);
	<log+?>: inc.sp(+8)
	<log+?>: dup.x64 sp(3)
	<log+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: set.x64 sp(3)
	cmplStd/lib/math/Fixed.ci:238: (21 bytes): if (!isFinite(base))
	<log+?>: load.z32
	<log+?>: dup.x64 sp(2)
	<log+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<log+?>: call
	<log+?>: inc.sp(-8)
	<log+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:239: (4 bytes): return .result := base;
	<log+?>: mov.x64 sp(5, 1)
	<log+?>: ret
	cmplStd/lib/math/Fixed.ci:241: (21 bytes): return .result := div(x, base);
	<log+?>: inc.sp(+8)
	<log+?>: dup.x64 sp(5)
	<log+?>: dup.x64 sp(5)
	<log+?>: load.ref <?> ;Fixed.div(a: Fixed, b: Fixed): Fixed
	<log+?>: call
	<log+?>: inc.sp(-16)
	<log+?>: set.x64 sp(7)
	<log+?>: ret
.usages:
}
Fixed.pow2(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 216
.name: 'pow2'
.file: 'cmplStd/lib/math/Fixed.ci:254'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'pow2(x) <=> 2 ** x
pow2(x) = pow2(n + q) = pow2(n) * pow2(q)
let n = floor(x);
 let q = fract(x);
 pow2(n) = 2 ** n = 1 << n
pow2(q) = 1 + look up from table
pow2(x) = (x >= 0) ? (pow2(q) << n) : (pow2(q) >> -n)
---------------------------------------------------'
.value: {
	static const tbl_pow2: uint32[257] := {
		tbl_pow2[0] := (1073741824);
		tbl_pow2[1] := (1076653033);
		tbl_pow2[2] := (1079572135);
		tbl_pow2[3] := (1082499152);
		tbl_pow2[4] := (1085434105);
		tbl_pow2[5] := (1088377016);
		tbl_pow2[6] := (1091327905);
		tbl_pow2[7] := (1094286795);
		tbl_pow2[8] := (1097253708);
		tbl_pow2[9] := (1100228664);
		tbl_pow2[10] := (1103211687);
		tbl_pow2[11] := (1106202797);
		tbl_pow2[12] := (1109202017);
		tbl_pow2[13] := (1112209369);
		tbl_pow2[14] := (1115224875);
		tbl_pow2[15] := (1118248556);
		tbl_pow2[16] := (1121280435);
		tbl_pow2[17] := (1124320535);
		tbl_pow2[18] := (1127368877);
		tbl_pow2[19] := (1130425484);
		tbl_pow2[20] := (1133490379);
		tbl_pow2[21] := (1136563583);
		tbl_pow2[22] := (1139645119);
		tbl_pow2[23] := (1142735011);
		tbl_pow2[24] := (1145833280);
		tbl_pow2[25] := (1148939949);
		tbl_pow2[26] := (1152055041);
		tbl_pow2[27] := (1155178579);
		tbl_pow2[28] := (1158310586);
		tbl_pow2[29] := (1161451085);
		tbl_pow2[30] := (1164600098);
		tbl_pow2[31] := (1167757649);
		tbl_pow2[32] := (1170923761);
		tbl_pow2[33] := (1174098458);
		tbl_pow2[34] := (1177281762);
		tbl_pow2[35] := (1180473696);
		tbl_pow2[36] := (1183674285);
		tbl_pow2[37] := (1186883552);
		tbl_pow2[38] := (1190101520);
		tbl_pow2[39] := (1193328212);
		tbl_pow2[40] := (1196563653);
		tbl_pow2[41] := (1199807866);
		tbl_pow2[42] := (1203060875);
		tbl_pow2[43] := (1206322704);
		tbl_pow2[44] := (1209593377);
		tbl_pow2[45] := (1212872917);
		tbl_pow2[46] := (1216161349);
		tbl_pow2[47] := (1219458697);
		tbl_pow2[48] := (1222764985);
		tbl_pow2[49] := (1226080238);
		tbl_pow2[50] := (1229404478);
		tbl_pow2[51] := (1232737732);
		tbl_pow2[52] := (1236080023);
		tbl_pow2[53] := (1239431376);
		tbl_pow2[54] := (1242791815);
		tbl_pow2[55] := (1246161366);
		tbl_pow2[56] := (1249540052);
		tbl_pow2[57] := (1252927899);
		tbl_pow2[58] := (1256324931);
		tbl_pow2[59] := (1259731173);
		tbl_pow2[60] := (1263146651);
		tbl_pow2[61] := (1266571389);
		tbl_pow2[62] := (1270005412);
		tbl_pow2[63] := (1273448746);
		tbl_pow2[64] := (1276901416);
		tbl_pow2[65] := (1280363447);
		tbl_pow2[66] := (1283834865);
		tbl_pow2[67] := (1287315694);
		tbl_pow2[68] := (1290805961);
		tbl_pow2[69] := (1294305691);
		tbl_pow2[70] := (1297814910);
		tbl_pow2[71] := (1301333643);
		tbl_pow2[72] := (1304861916);
		tbl_pow2[73] := (1308399756);
		tbl_pow2[74] := (1311947188);
		tbl_pow2[75] := (1315504237);
		tbl_pow2[76] := (1319070931);
		tbl_pow2[77] := (1322647295);
		tbl_pow2[78] := (1326233356);
		tbl_pow2[79] := (1329829139);
		tbl_pow2[80] := (1333434672);
		tbl_pow2[81] := (1337049980);
		tbl_pow2[82] := (1340675090);
		tbl_pow2[83] := (1344310029);
		tbl_pow2[84] := (1347954823);
		tbl_pow2[85] := (1351609500);
		tbl_pow2[86] := (1355274085);
		tbl_pow2[87] := (1358948606);
		tbl_pow2[88] := (1362633089);
		tbl_pow2[89] := (1366327562);
		tbl_pow2[90] := (1370032052);
		tbl_pow2[91] := (1373746586);
		tbl_pow2[92] := (1377471191);
		tbl_pow2[93] := (1381205894);
		tbl_pow2[94] := (1384950723);
		tbl_pow2[95] := (1388705705);
		tbl_pow2[96] := (1392470868);
		tbl_pow2[97] := (1396246240);
		tbl_pow2[98] := (1400031847);
		tbl_pow2[99] := (1403827719);
		tbl_pow2[100] := (1407633882);
		tbl_pow2[101] := (1411450365);
		tbl_pow2[102] := (1415277195);
		tbl_pow2[103] := (1419114400);
		tbl_pow2[104] := (1422962010);
		tbl_pow2[105] := (1426820051);
		tbl_pow2[106] := (1430688553);
		tbl_pow2[107] := (1434567543);
		tbl_pow2[108] := (1438457050);
		tbl_pow2[109] := (1442357103);
		tbl_pow2[110] := (1446267730);
		tbl_pow2[111] := (1450188959);
		tbl_pow2[112] := (1454120821);
		tbl_pow2[113] := (1458063342);
		tbl_pow2[114] := (1462016553);
		tbl_pow2[115] := (1465980482);
		tbl_pow2[116] := (1469955158);
		tbl_pow2[117] := (1473940611);
		tbl_pow2[118] := (1477936869);
		tbl_pow2[119] := (1481943963);
		tbl_pow2[120] := (1485961920);
		tbl_pow2[121] := (1489990772);
		tbl_pow2[122] := (1494030547);
		tbl_pow2[123] := (1498081274);
		tbl_pow2[124] := (1502142985);
		tbl_pow2[125] := (1506215708);
		tbl_pow2[126] := (1510299473);
		tbl_pow2[127] := (1514394310);
		tbl_pow2[128] := (1518500249);
		tbl_pow2[129] := (1522617321);
		tbl_pow2[130] := (1526745556);
		tbl_pow2[131] := (1530884983);
		tbl_pow2[132] := (1535035633);
		tbl_pow2[133] := (1539197537);
		tbl_pow2[134] := (1543370725);
		tbl_pow2[135] := (1547555227);
		tbl_pow2[136] := (1551751075);
		tbl_pow2[137] := (1555958299);
		tbl_pow2[138] := (1560176930);
		tbl_pow2[139] := (1564406999);
		tbl_pow2[140] := (1568648537);
		tbl_pow2[141] := (1572901574);
		tbl_pow2[142] := (1577166143);
		tbl_pow2[143] := (1581442274);
		tbl_pow2[144] := (1585729999);
		tbl_pow2[145] := (1590029349);
		tbl_pow2[146] := (1594340356);
		tbl_pow2[147] := (1598663051);
		tbl_pow2[148] := (1602997467);
		tbl_pow2[149] := (1607343634);
		tbl_pow2[150] := (1611701584);
		tbl_pow2[151] := (1616071351);
		tbl_pow2[152] := (1620452965);
		tbl_pow2[153] := (1624846458);
		tbl_pow2[154] := (1629251864);
		tbl_pow2[155] := (1633669214);
		tbl_pow2[156] := (1638098541);
		tbl_pow2[157] := (1642539876);
		tbl_pow2[158] := (1646993254);
		tbl_pow2[159] := (1651458705);
		tbl_pow2[160] := (1655936264);
		tbl_pow2[161] := (1660425963);
		tbl_pow2[162] := (1664927834);
		tbl_pow2[163] := (1669441912);
		tbl_pow2[164] := (1673968228);
		tbl_pow2[165] := (1678506816);
		tbl_pow2[166] := (1683057710);
		tbl_pow2[167] := (1687620942);
		tbl_pow2[168] := (1692196547);
		tbl_pow2[169] := (1696784557);
		tbl_pow2[170] := (1701385007);
		tbl_pow2[171] := (1705997929);
		tbl_pow2[172] := (1710623359);
		tbl_pow2[173] := (1715261329);
		tbl_pow2[174] := (1719911875);
		tbl_pow2[175] := (1724575029);
		tbl_pow2[176] := (1729250826);
		tbl_pow2[177] := (1733939301);
		tbl_pow2[178] := (1738640487);
		tbl_pow2[179] := (1743354420);
		tbl_pow2[180] := (1748081133);
		tbl_pow2[181] := (1752820662);
		tbl_pow2[182] := (1757573041);
		tbl_pow2[183] := (1762338305);
		tbl_pow2[184] := (1767116488);
		tbl_pow2[185] := (1771907627);
		tbl_pow2[186] := (1776711756);
		tbl_pow2[187] := (1781528911);
		tbl_pow2[188] := (1786359125);
		tbl_pow2[189] := (1791202436);
		tbl_pow2[190] := (1796058879);
		tbl_pow2[191] := (1800928488);
		tbl_pow2[192] := (1805811301);
		tbl_pow2[193] := (1810707352);
		tbl_pow2[194] := (1815616678);
		tbl_pow2[195] := (1820539314);
		tbl_pow2[196] := (1825475297);
		tbl_pow2[197] := (1830424662);
		tbl_pow2[198] := (1835387447);
		tbl_pow2[199] := (1840363687);
		tbl_pow2[200] := (1845353419);
		tbl_pow2[201] := (1850356680);
		tbl_pow2[202] := (1855373506);
		tbl_pow2[203] := (1860403934);
		tbl_pow2[204] := (1865448001);
		tbl_pow2[205] := (1870505743);
		tbl_pow2[206] := (1875577199);
		tbl_pow2[207] := (1880662405);
		tbl_pow2[208] := (1885761398);
		tbl_pow2[209] := (1890874215);
		tbl_pow2[210] := (1896000895);
		tbl_pow2[211] := (1901141475);
		tbl_pow2[212] := (1906295993);
		tbl_pow2[213] := (1911464486);
		tbl_pow2[214] := (1916646992);
		tbl_pow2[215] := (1921843549);
		tbl_pow2[216] := (1927054195);
		tbl_pow2[217] := (1932278969);
		tbl_pow2[218] := (1937517909);
		tbl_pow2[219] := (1942771053);
		tbl_pow2[220] := (1948038440);
		tbl_pow2[221] := (1953320108);
		tbl_pow2[222] := (1958616096);
		tbl_pow2[223] := (1963926443);
		tbl_pow2[224] := (1969251187);
		tbl_pow2[225] := (1974590369);
		tbl_pow2[226] := (1979944027);
		tbl_pow2[227] := (1985312199);
		tbl_pow2[228] := (1990694927);
		tbl_pow2[229] := (1996092248);
		tbl_pow2[230] := (2001504204);
		tbl_pow2[231] := (2006930832);
		tbl_pow2[232] := (2012372173);
		tbl_pow2[233] := (2017828268);
		tbl_pow2[234] := (2023299155);
		tbl_pow2[235] := (2028784876);
		tbl_pow2[236] := (2034285470);
		tbl_pow2[237] := (2039800977);
		tbl_pow2[238] := (2045331439);
		tbl_pow2[239] := (2050876895);
		tbl_pow2[240] := (2056437386);
		tbl_pow2[241] := (2062012953);
		tbl_pow2[242] := (2067603638);
		tbl_pow2[243] := (2073209480);
		tbl_pow2[244] := (2078830521);
		tbl_pow2[245] := (2084466802);
		tbl_pow2[246] := (2090118365);
		tbl_pow2[247] := (2095785251);
		tbl_pow2[248] := (2101467501);
		tbl_pow2[249] := (2107165158);
		tbl_pow2[250] := (2112878262);
		tbl_pow2[251] := (2118606856);
		tbl_pow2[252] := (2124350982);
		tbl_pow2[253] := (2130110682);
		tbl_pow2[254] := (2135885998);
		tbl_pow2[255] := (2141676972);
		tbl_pow2[256] := (2147483648);
	};
	if (x.value > pow2max) {
		return .result := as(inf);
	}
	if (x.value <= -pow2max) {
		if (isNan(x)) {
			return .result := x;
		}
		return .result := as(0);
	}
	idx: uint32 := (x.value >> (precision - 8)) & 255;
	static if (precision < 8) {
		error_not_implemented_yet
	}
	q: uint32 := tbl_pow2[idx];
	static if (precision > 8) {
		mix: uint32 := (precision > 16 ? x.value >> (precision - 16) : x.value << (16 - precision)) & 255;
		q := q + (mix * (tbl_pow2[idx + (1)] - q) >> 8);
	}
	n: int32 := (x.value >> precision) - (30 - precision);
	return .result := as(n < 0 ? q >> -n : q << n);
}
.instructions: (216 bytes)
	cmplStd/lib/math/Fixed.ci:296: (34 bytes): if (x.value > pow2max)
	<pow2>  : dup.x32 sp(1)
	<pow2+?>: load.c32 11534336
	<pow2+?>: cgt.i32
	<pow2+?>: jz +26
	cmplStd/lib/math/Fixed.ci:297: (22 bytes): return .result := as(inf);
	<pow2+?>: inc.sp(+8)
	<pow2+?>: load.c32 2147483647
	<pow2+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow2+?>: call
	<pow2+?>: inc.sp(-4)
	<pow2+?>: set.x64 sp(5)
	<pow2+?>: ret
	cmplStd/lib/math/Fixed.ci:299: (51 bytes): if (x.value <= -pow2max)
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: load.c32 -11534336
	<pow2+?>: cgt.i32
	<pow2+?>: jnz +43
	cmplStd/lib/math/Fixed.ci:300: (21 bytes): if (isNan(x))
	<pow2+?>: load.z32
	<pow2+?>: dup.x64 sp(2)
	<pow2+?>: load.ref <?> ;Fixed.isNan(x: Fixed): bool
	<pow2+?>: call
	<pow2+?>: inc.sp(-8)
	<pow2+?>: jz +8
	cmplStd/lib/math/Fixed.ci:301: (4 bytes): return .result := x;
	<pow2+?>: mov.x64 sp(3, 1)
	<pow2+?>: ret
	cmplStd/lib/math/Fixed.ci:303: (18 bytes): return .result := as(0);
	<pow2+?>: inc.sp(+8)
	<pow2+?>: load.z32
	<pow2+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow2+?>: call
	<pow2+?>: inc.sp(-4)
	<pow2+?>: set.x64 sp(5)
	<pow2+?>: ret
	cmplStd/lib/math/Fixed.ci:306: (14 bytes): idx: uint32 := (x.value >> (precision - 8)) & 255
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: load.c32 20
	<pow2+?>: inc.i32(-8)
	<pow2+?>: sar.b32
	<pow2+?>: b32.and 0xff
	cmplStd/lib/math/Fixed.ci:308: (12 bytes): q: uint32 := tbl_pow2[idx]
	<pow2+?>: load.ref <?> ;Fixed.pow2.tbl_pow2
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: mad.u32 4
	<pow2+?>: load.i32
	cmplStd/lib/math/Fixed.ci:310: (14 bytes): mix: uint32 := (precision > 16 ? x.value >> (precision - 16) : x.value << (16 - precision)) & 255
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: load.c32 20
	<pow2+?>: inc.i32(-16)
	<pow2+?>: sar.b32
	<pow2+?>: b32.and 0xff
	cmplStd/lib/math/Fixed.ci:314: (29 bytes): q := q + (mix * (tbl_pow2[idx + (1)] - q) >> 8);
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: dup.x32 sp(1)
	<pow2+?>: load.ref <?> ;Fixed.pow2.tbl_pow2
	<pow2+?>: dup.x32 sp(5)
	<pow2+?>: inc.i32(+1)
	<pow2+?>: mad.u32 4
	<pow2+?>: load.i32
	<pow2+?>: dup.x32 sp(4)
	<pow2+?>: sub.i32
	<pow2+?>: mul.u32
	<pow2+?>: b32.shr 0x08
	<pow2+?>: add.i32
	<pow2+?>: set.x32 sp(2)
	<pow2+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:317: (14 bytes): n: int32 := (x.value >> precision) - (30 - precision)
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: b32.sar 0x14
	<pow2+?>: load.c32 30
	<pow2+?>: inc.i32(-20)
	<pow2+?>: sub.i32
	cmplStd/lib/math/Fixed.ci:318: (44 bytes): return .result := as(n < 0 ? q >> -n : q << n);
	<pow2+?>: inc.sp(+8)
	<pow2+?>: dup.x32 sp(2)
	<pow2+?>: load.z32
	<pow2+?>: clt.i32
	<pow2+?>: jz +14
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: neg.i32
	<pow2+?>: shr.b32
	<pow2+?>: jmp +9
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: dup.x32 sp(3)
	<pow2+?>: shl.b32
	<pow2+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow2+?>: call
	<pow2+?>: inc.sp(-4)
	<pow2+?>: set.x64 sp(8)
	<pow2+?>: inc.sp(-12)
	<pow2+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:440: referenced as `pow2`
	cmplStd/lib/math/Fixed.ci:361: referenced as `pow2`
	cmplStd/lib/math/Fixed.ci:342: referenced as `pow2`
	cmplStd/lib/math/Fixed.ci:330: referenced as `pow2`
}
Fixed.exp(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 38
.name: 'exp'
.file: 'cmplStd/lib/math/Fixed.ci:322'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the base-e exponential: $ e^x $.'
.value: {
	return .result := pow2(mul_28(x, l2e_28));
}
.instructions: (38 bytes)
	cmplStd/lib/math/Fixed.ci:330: (38 bytes): return .result := pow2(mul_28(x, l2e_28));
	<exp>  : inc.sp(+8)
	<exp+?>: inc.sp(+8)
	<exp+?>: dup.x64 sp(5)
	<exp+?>: load.c32 387270501
	<exp+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<exp+?>: call
	<exp+?>: inc.sp(-12)
	<exp+?>: load.ref <?> ;Fixed.pow2(x: Fixed): Fixed
	<exp+?>: call
	<exp+?>: inc.sp(-8)
	<exp+?>: set.x64 sp(5)
	<exp+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:503: referenced as `exp`
	cmplStd/lib/math/Fixed.ci:503: referenced as `exp`
}
Fixed.exp10(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 38
.name: 'exp10'
.file: 'cmplStd/lib/math/Fixed.ci:334'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the base 10 exponential: $ 10^x $.'
.value: {
	return .result := pow2(mul_28(x, l2t_28));
}
.instructions: (38 bytes)
	cmplStd/lib/math/Fixed.ci:342: (38 bytes): return .result := pow2(mul_28(x, l2t_28));
	<exp10>  : inc.sp(+8)
	<exp10+?>: inc.sp(+8)
	<exp10+?>: dup.x64 sp(5)
	<exp10+?>: load.c32 891723282
	<exp10+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<exp10+?>: call
	<exp10+?>: inc.sp(-12)
	<exp10+?>: load.ref <?> ;Fixed.pow2(x: Fixed): Fixed
	<exp10+?>: call
	<exp10+?>: inc.sp(-8)
	<exp10+?>: set.x64 sp(5)
	<exp10+?>: ret
.usages:
}
Fixed.sqrt(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 175
.name: 'sqrt'
.file: 'cmplStd/lib/math/Fixed.ci:346'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the square root of the parameter `x`: $\sqrt{x}$.'
.value: {
	if (x.value <= 0) {
		if (x.value < 0) {
			return .result := as(nan);
		}
		return .result := as(0);
	}
	static if ((precision & 1) != 0) {
		return .result := pow2(div(log2(x), 2));
	}
	root: uint32 := 0;
	remHi: uint32 := 0;
	remLo: uint32 := x.value;
	for (count: uint32 := 16 + (precision >> 1); count != (0); count := count - (1)) {
		remHi := (remHi << 2) | (remLo >> 30);
		remLo := remLo << 2;
		root := root << 1;
		testDiv: uint32 := (root << 1) + (1);
		if (remHi >= testDiv) {
			remHi := remHi - testDiv;
			root := root + (1);
		}
	}
	return .result := as(root);
}
.instructions: (175 bytes)
	cmplStd/lib/math/Fixed.ci:353: (56 bytes): if (x.value <= 0)
	<sqrt>  : dup.x32 sp(1)
	<sqrt+?>: load.z32
	<sqrt+?>: cgt.i32
	<sqrt+?>: jnz +52
	cmplStd/lib/math/Fixed.ci:354: (30 bytes): if (x.value < 0)
	<sqrt+?>: dup.x32 sp(1)
	<sqrt+?>: load.z32
	<sqrt+?>: clt.i32
	<sqrt+?>: jz +26
	cmplStd/lib/math/Fixed.ci:355: (22 bytes): return .result := as(nan);
	<sqrt+?>: inc.sp(+8)
	<sqrt+?>: load.c32 -2147483648
	<sqrt+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: set.x64 sp(5)
	<sqrt+?>: ret
	cmplStd/lib/math/Fixed.ci:357: (18 bytes): return .result := as(0);
	<sqrt+?>: inc.sp(+8)
	<sqrt+?>: load.z32
	<sqrt+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: set.x64 sp(5)
	<sqrt+?>: ret
	cmplStd/lib/math/Fixed.ci:365: (1 byte): root: uint32 := 0
	<sqrt+?>: load.z32
	cmplStd/lib/math/Fixed.ci:366: (1 byte): remHi: uint32 := 0
	<sqrt+?>: load.z32
	cmplStd/lib/math/Fixed.ci:367: (2 bytes): remLo: uint32 := x.value
	<sqrt+?>: dup.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:368: (92 bytes): for (count: uint32 := 16 + (precision >> 1); count != (0); count := count - (1))
	<sqrt+?>: load.c32 16
	<sqrt+?>: load.c32 20
	<sqrt+?>: b32.sar 0x01
	<sqrt+?>: add.i32
	<sqrt+?>: jmp +67
	cmplStd/lib/math/Fixed.ci:369: (11 bytes): remHi := (remHi << 2) | (remLo >> 30);
	<sqrt+?>: dup.x32 sp(2)
	<sqrt+?>: b32.shl 0x02
	<sqrt+?>: dup.x32 sp(2)
	<sqrt+?>: b32.shr 0x1e
	<sqrt+?>: or.b32
	<sqrt+?>: set.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:370: (6 bytes): remLo := remLo << 2;
	<sqrt+?>: dup.x32 sp(1)
	<sqrt+?>: b32.shl 0x02
	<sqrt+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:371: (6 bytes): root := root << 1;
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: b32.shl 0x01
	<sqrt+?>: set.x32 sp(4)
	cmplStd/lib/math/Fixed.ci:372: (8 bytes): testDiv: uint32 := (root << 1) + (1)
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: b32.shl 0x01
	<sqrt+?>: inc.i32(+1)
	cmplStd/lib/math/Fixed.ci:373: (24 bytes): if (remHi >= testDiv)
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: dup.x32 sp(1)
	<sqrt+?>: clt.u32
	<sqrt+?>: jnz +19
	cmplStd/lib/math/Fixed.ci:374: (7 bytes): remHi := remHi - testDiv;
	<sqrt+?>: dup.x32 sp(3)
	<sqrt+?>: dup.x32 sp(1)
	<sqrt+?>: sub.i32
	<sqrt+?>: set.x32 sp(4)
	cmplStd/lib/math/Fixed.ci:375: (8 bytes): root := root + (1);
	<sqrt+?>: dup.x32 sp(4)
	<sqrt+?>: inc.i32(+1)
	<sqrt+?>: set.x32 sp(5)
	<sqrt+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:368: (4 bytes): count := count - (1)
	<sqrt+?>: inc.i32(-1)
	cmplStd/lib/math/Fixed.ci:368: (8 bytes): count != (0)
	<sqrt+?>: dup.x32 sp(0)
	<sqrt+?>: load.z32
	<sqrt+?>: ceq.i32
	<sqrt+?>: jz -67
	<sqrt+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:378: (23 bytes): return .result := as(root);
	<sqrt+?>: inc.sp(+8)
	<sqrt+?>: dup.x32 sp(4)
	<sqrt+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sqrt+?>: call
	<sqrt+?>: inc.sp(-4)
	<sqrt+?>: set.x64 sp(8)
	<sqrt+?>: inc.sp(-12)
	<sqrt+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:394: referenced as `sqrt`
}
Fixed.pow(x: Fixed, y: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 410
.name: 'pow'
.file: 'cmplStd/lib/math/Fixed.ci:382'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.param y: Fixed (size: 8, cast: variable(val))
.doc: 'Returns `x` raised to the power of `y`: $ x^y $.'
.value: {
	if (y.value == 0 || x.value == one) {
		return .result := as(one);
	}
	if (y.value == one) {
		return .result := x;
	}
	if (y.value == half) {
		return .result := sqrt(x);
	}
	if (x.value == nan || y.value == nan) {
		return .result := as(nan);
	}
	if (x.value == 0) {
		if (y.value < 0) {
			return .result := as(inf);
		}
		return .result := as(0);
	}
	if ((y.value & mask) == 0) {
		res: int32 := one;
		sqr: int64 := x.value;
		pow: int32 := (y.value < 0 ? -y.value : y.value) >> precision;
		for ( ; pow != 0; ) {
			if ((pow & 1) != 0) {
				res := ((res) * sqr >> precision);
			}
			sqr := sqr * sqr >> precision;
			pow := pow >> 1;
		}
		return .result := y.value < 0 ? inv(as(res)) : as(res);
	}
	return .result := pow2(mul(y, log2(x)));
}
.instructions: (410 bytes)
	cmplStd/lib/math/Fixed.ci:383: (48 bytes): if (y.value == 0 || x.value == one)
	<pow>  : dup.x32 sp(1)
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: dup.x32 sp(0)
	<pow+?>: jnz +16
	<pow+?>: inc.sp(-4)
	<pow+?>: dup.x32 sp(3)
	<pow+?>: load.c32 1048576
	<pow+?>: ceq.i32
	<pow+?>: jz +26
	cmplStd/lib/math/Fixed.ci:386: (22 bytes): return .result := as(one);
	<pow+?>: inc.sp(+8)
	<pow+?>: load.c32 1048576
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:388: (16 bytes): if (y.value == one)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: load.c32 1048576
	<pow+?>: ceq.i32
	<pow+?>: jz +8
	cmplStd/lib/math/Fixed.ci:390: (4 bytes): return .result := x;
	<pow+?>: mov.x64 sp(5, 3)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:392: (31 bytes): if (y.value == half)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: load.c32 524288
	<pow+?>: ceq.i32
	<pow+?>: jz +23
	cmplStd/lib/math/Fixed.ci:394: (19 bytes): return .result := sqrt(x);
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x64 sp(5)
	<pow+?>: load.ref <?> ;Fixed.sqrt(x: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:396: (52 bytes): if (x.value == nan || y.value == nan)
	<pow+?>: dup.x32 sp(3)
	<pow+?>: load.c32 -2147483648
	<pow+?>: ceq.i32
	<pow+?>: dup.x32 sp(0)
	<pow+?>: jnz +16
	<pow+?>: inc.sp(-4)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: load.c32 -2147483648
	<pow+?>: ceq.i32
	<pow+?>: jz +26
	cmplStd/lib/math/Fixed.ci:399: (22 bytes): return .result := as(nan);
	<pow+?>: inc.sp(+8)
	<pow+?>: load.c32 -2147483648
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:401: (56 bytes): if (x.value == 0)
	<pow+?>: dup.x32 sp(3)
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: jz +52
	cmplStd/lib/math/Fixed.ci:408: (30 bytes): if (y.value < 0)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: load.z32
	<pow+?>: clt.i32
	<pow+?>: jz +26
	cmplStd/lib/math/Fixed.ci:409: (22 bytes): return .result := as(inf);
	<pow+?>: inc.sp(+8)
	<pow+?>: load.c32 2147483647
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:411: (18 bytes): return .result := as(0);
	<pow+?>: inc.sp(+8)
	<pow+?>: load.z32
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
	cmplStd/lib/math/Fixed.ci:425: (158 bytes): if ((y.value & mask) == 0)
	<pow+?>: dup.x32 sp(1)
	<pow+?>: b32.and 0xfffff
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: jz +152
	cmplStd/lib/math/Fixed.ci:426: (5 bytes): res: int32 := one
	<pow+?>: load.c32 1048576
	cmplStd/lib/math/Fixed.ci:427: (3 bytes): sqr: int64 := x.value
	<pow+?>: dup.x32 sp(4)
	<pow+?>: i32.2i64
	cmplStd/lib/math/Fixed.ci:428: (19 bytes): pow: int32 := (y.value < 0 ? -y.value : y.value) >> precision
	<pow+?>: dup.x32 sp(4)
	<pow+?>: load.z32
	<pow+?>: clt.i32
	<pow+?>: jz +11
	<pow+?>: dup.x32 sp(4)
	<pow+?>: neg.i32
	<pow+?>: jmp +6
	<pow+?>: dup.x32 sp(4)
	<pow+?>: b32.sar 0x14
	cmplStd/lib/math/Fixed.ci:430: (52 bytes): for ( ; pow != 0; )
	<pow+?>: jmp +44
	cmplStd/lib/math/Fixed.ci:431: (25 bytes): if ((pow & 1) != 0)
	<pow+?>: dup.x32 sp(0)
	<pow+?>: b32.and 0x01
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: jnz +19
	cmplStd/lib/math/Fixed.ci:432: (15 bytes): res := ((res) * sqr >> precision);
	<pow+?>: dup.x32 sp(3)
	<pow+?>: i32.2i64
	<pow+?>: dup.x64 sp(3)
	<pow+?>: mul.i64
	<pow+?>: load.c32 20
	<pow+?>: sar.b64
	<pow+?>: i64.2i32
	<pow+?>: set.x32 sp(4)
	cmplStd/lib/math/Fixed.ci:434: (13 bytes): sqr := sqr * sqr >> precision;
	<pow+?>: dup.x64 sp(1)
	<pow+?>: dup.x64 sp(3)
	<pow+?>: mul.i64
	<pow+?>: load.c32 20
	<pow+?>: sar.b64
	<pow+?>: set.x64 sp(3)
	cmplStd/lib/math/Fixed.ci:435: (2 bytes): pow := pow >> 1;
	<pow+?>: b32.sar 0x01
	cmplStd/lib/math/Fixed.ci:430: (8 bytes): pow != 0
	<pow+?>: dup.x32 sp(0)
	<pow+?>: load.z32
	<pow+?>: ceq.i32
	<pow+?>: jz -44
	cmplStd/lib/math/Fixed.ci:437: (65 bytes): return .result := y.value < 0 ? inv(as(res)) : as(res);
	<pow+?>: dup.x32 sp(5)
	<pow+?>: load.z32
	<pow+?>: clt.i32
	<pow+?>: jz +38
	<pow+?>: inc.sp(+8)
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x32 sp(7)
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: load.ref <?> ;Fixed.inv(x: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: jmp +20
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x32 sp(5)
	<pow+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-4)
	<pow+?>: set.x64 sp(11)
	<pow+?>: inc.sp(-16)
	<pow+?>: ret
	<pow+?>: inc.sp(-16)
	cmplStd/lib/math/Fixed.ci:440: (49 bytes): return .result := pow2(mul(y, log2(x)));
	<pow+?>: inc.sp(+8)
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x64 sp(5)
	<pow+?>: inc.sp(+8)
	<pow+?>: dup.x64 sp(11)
	<pow+?>: load.ref <?> ;Fixed.log2(x: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: load.ref <?> ;Fixed.mul(a: Fixed, b: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-16)
	<pow+?>: load.ref <?> ;Fixed.pow2(x: Fixed): Fixed
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: set.x64 sp(7)
	<pow+?>: ret
.usages:
}
Fixed.horner(x: int32, a0: int32, a1: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:444'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: i32)
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.value: a0 + int32((a1) * int64(x) >> precision)
.usages:
	cmplStd/lib/math/Fixed.ci:448: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:447: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:446: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:445: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:445: referenced as `horner`
}
Fixed.horner(x: int32, a0: int32, a1: int32, a2: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:445'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.param a2: int32 (size: 4, cast: i32)
.value: horner(x, a0, horner(x, a1, a2))
.usages:
	cmplStd/lib/math/Fixed.ci:446: referenced as `horner`
}
Fixed.horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:446'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.param a2: int32 (size: 4, cast: i32)
.param a3: int32 (size: 4, cast: i32)
.value: horner(x, a0, horner(x, a1, a2, a3))
.usages:
	cmplStd/lib/math/Fixed.ci:447: referenced as `horner`
}
Fixed.horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32, a4: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:447'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.param a2: int32 (size: 4, cast: i32)
.param a3: int32 (size: 4, cast: i32)
.param a4: int32 (size: 4, cast: i32)
.value: horner(x, a0, horner(x, a1, a2, a3, a4))
.usages:
	cmplStd/lib/math/Fixed.ci:448: referenced as `horner`
}
Fixed.horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32, a4: int32, a5: int32): int32: function {
.kind: static inline
.base: `function`
.size: 0
.name: 'horner'
.file: 'cmplStd/lib/math/Fixed.ci:448'
.owner: Fixed
.param .result: int32 (size: 4, cast: i32)
.param x: int32 (size: 4, cast: variable(i32))
.param a0: int32 (size: 4, cast: i32)
.param a1: int32 (size: 4, cast: i32)
.param a2: int32 (size: 4, cast: i32)
.param a3: int32 (size: 4, cast: i32)
.param a4: int32 (size: 4, cast: i32)
.param a5: int32 (size: 4, cast: i32)
.value: horner(x, a0, horner(x, a1, a2, a3, a4, a5))
.usages:
	cmplStd/lib/math/Fixed.ci:563: referenced as `horner`
	cmplStd/lib/math/Fixed.ci:485: referenced as `horner`
}
Fixed.sin(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 250
.name: 'sin'
.file: 'cmplStd/lib/math/Fixed.ci:451'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the sine of the radian argument `x`.'
.value: {
	x.value := x.value % piMul2;
	if (x.value < 0) {
		x.value := x.value + piMul2;
	}
	sign: int32 := 1;
	if (x.value >= pi) {
		x.value := x.value - pi;
		sign := -1;
	}
	if (x.value >= piDiv2) {
		x.value := pi - x.value;
	}
	xsq: int32 := int64(x.value) * (x.value) >> precision;
	res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5);
	return .result := mul(x, as(sign * res));
}
.instructions: (250 bytes)
	cmplStd/lib/math/Fixed.ci:466: (10 bytes): x.value := x.value % piMul2;
	<sin>  : dup.x32 sp(1)
	<sin+?>: load.c32 6588397
	<sin+?>: mod.i32
	<sin+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:467: (16 bytes): if (x.value < 0)
	<sin+?>: dup.x32 sp(1)
	<sin+?>: load.z32
	<sin+?>: clt.i32
	<sin+?>: jz +12
	cmplStd/lib/math/Fixed.ci:468: (8 bytes): x.value := x.value + piMul2;
	<sin+?>: dup.x32 sp(1)
	<sin+?>: inc.i32(+6588397)
	<sin+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:472: (5 bytes): sign: int32 := 1
	<sin+?>: load.c32 1
	cmplStd/lib/math/Fixed.ci:473: (27 bytes): if (x.value >= pi)
	<sin+?>: dup.x32 sp(2)
	<sin+?>: load.c32 3294198
	<sin+?>: clt.i32
	<sin+?>: jnz +19
	cmplStd/lib/math/Fixed.ci:474: (8 bytes): x.value := x.value - pi;
	<sin+?>: dup.x32 sp(2)
	<sin+?>: inc.i32(-3294198)
	<sin+?>: set.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:475: (7 bytes): sign := -1;
	<sin+?>: load.c32 -1
	<sin+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:479: (22 bytes): if (x.value >= piDiv2)
	<sin+?>: dup.x32 sp(2)
	<sin+?>: load.c32 1647099
	<sin+?>: clt.i32
	<sin+?>: jnz +14
	cmplStd/lib/math/Fixed.ci:480: (10 bytes): x.value := pi - x.value;
	<sin+?>: load.c32 3294198
	<sin+?>: dup.x32 sp(3)
	<sin+?>: sub.i32
	<sin+?>: set.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:484: (14 bytes): xsq: int32 := int64(x.value) * (x.value) >> precision
	<sin+?>: dup.x32 sp(2)
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(4)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	cmplStd/lib/math/Fixed.ci:485: (114 bytes): res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5)
	<sin+?>: dup.x32 sp(0)
	<sin+?>: load.c32 1048576
	<sin+?>: dup.x32 sp(1)
	<sin+?>: load.c32 -174762
	<sin+?>: dup.x32 sp(1)
	<sin+?>: load.c32 8738
	<sin+?>: dup.x32 sp(1)
	<sin+?>: load.c32 -208
	<sin+?>: load.c32 2
	<sin+?>: load.c64 0
	<sin+?>: dup.x32 sp(4)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: set.x32 sp(1)
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: set.x32 sp(1)
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: set.x32 sp(1)
	<sin+?>: i32.2i64
	<sin+?>: dup.x32 sp(3)
	<sin+?>: i32.2i64
	<sin+?>: mul.i64
	<sin+?>: load.c32 20
	<sin+?>: sar.b64
	<sin+?>: i64.2i32
	<sin+?>: add.i32
	<sin+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:486: (42 bytes): return .result := mul(x, as(sign * res));
	<sin+?>: inc.sp(+8)
	<sin+?>: dup.x64 sp(6)
	<sin+?>: inc.sp(+8)
	<sin+?>: dup.x32 sp(8)
	<sin+?>: dup.x32 sp(7)
	<sin+?>: mul.i32
	<sin+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sin+?>: call
	<sin+?>: inc.sp(-4)
	<sin+?>: load.ref <?> ;Fixed.mul(a: Fixed, b: Fixed): Fixed
	<sin+?>: call
	<sin+?>: inc.sp(-16)
	<sin+?>: set.x64 sp(8)
	<sin+?>: inc.sp(-12)
	<sin+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:610: referenced as `sin`
}
Fixed.sinh(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 129
.name: 'sinh'
.file: 'cmplStd/lib/math/Fixed.ci:490'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the hyperbolic sine of the radian argument `x`.'
.value: {
	if (x.value == 0) {
		return .result := as(0);
	}
	if (!isFinite(x)) {
		return .result := x;
	}
	return .result := div(sub(exp(x), exp(neg(x))), 2);
}
.instructions: (129 bytes)
	cmplStd/lib/math/Fixed.ci:495: (26 bytes): if (x.value == 0)
	<sinh>  : dup.x32 sp(1)
	<sinh+?>: load.z32
	<sinh+?>: ceq.i32
	<sinh+?>: jz +22
	cmplStd/lib/math/Fixed.ci:496: (18 bytes): return .result := as(0);
	<sinh+?>: inc.sp(+8)
	<sinh+?>: load.z32
	<sinh+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-4)
	<sinh+?>: set.x64 sp(5)
	<sinh+?>: ret
	cmplStd/lib/math/Fixed.ci:498: (21 bytes): if (!isFinite(x))
	<sinh+?>: load.z32
	<sinh+?>: dup.x64 sp(2)
	<sinh+?>: load.ref <?> ;Fixed.isFinite(x: Fixed): bool
	<sinh+?>: call
	<sinh+?>: inc.sp(-8)
	<sinh+?>: jnz +8
	cmplStd/lib/math/Fixed.ci:499: (4 bytes): return .result := x;
	<sinh+?>: mov.x64 sp(3, 1)
	<sinh+?>: ret
	cmplStd/lib/math/Fixed.ci:503: (82 bytes): return .result := div(sub(exp(x), exp(neg(x))), 2);
	<sinh+?>: inc.sp(+8)
	<sinh+?>: inc.sp(+8)
	<sinh+?>: inc.sp(+8)
	<sinh+?>: dup.x64 sp(7)
	<sinh+?>: load.ref <?> ;Fixed.exp(x: Fixed): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-8)
	<sinh+?>: inc.sp(+8)
	<sinh+?>: inc.sp(+8)
	<sinh+?>: dup.x64 sp(11)
	<sinh+?>: load.ref <?> ;Fixed.neg(a: Fixed): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-8)
	<sinh+?>: load.ref <?> ;Fixed.exp(x: Fixed): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-8)
	<sinh+?>: load.ref <?> ;Fixed.sub(a: Fixed, b: Fixed): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-16)
	<sinh+?>: load.c32 2
	<sinh+?>: load.ref <?> ;Fixed.div(a: Fixed, b: int32): Fixed
	<sinh+?>: call
	<sinh+?>: inc.sp(-12)
	<sinh+?>: set.x64 sp(5)
	<sinh+?>: ret
.usages:
}
Fixed.cos(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 234
.name: 'cos'
.file: 'cmplStd/lib/math/Fixed.ci:530'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the cosine of the radian argument `x`.'
.value: {
	x.value := x.value % piMul2;
	if (x.value < 0) {
		x.value := x.value + piMul2;
	}
	if (x.value > pi) {
		x.value := piMul2 - x.value;
	}
	sign: int32 := 1;
	if (x.value >= piDiv2) {
		x.value := x.value - pi;
		sign := -1;
	}
	xsq: int32 := int64(x.value) * (x.value) >> precision;
	res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5);
	return .result := as(sign * res);
}
.instructions: (234 bytes)
	cmplStd/lib/math/Fixed.ci:544: (10 bytes): x.value := x.value % piMul2;
	<cos>  : dup.x32 sp(1)
	<cos+?>: load.c32 6588397
	<cos+?>: mod.i32
	<cos+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:545: (16 bytes): if (x.value < 0)
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.z32
	<cos+?>: clt.i32
	<cos+?>: jz +12
	cmplStd/lib/math/Fixed.ci:546: (8 bytes): x.value := x.value + piMul2;
	<cos+?>: dup.x32 sp(1)
	<cos+?>: inc.i32(+6588397)
	<cos+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:550: (22 bytes): if (x.value > pi)
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.c32 3294198
	<cos+?>: cgt.i32
	<cos+?>: jz +14
	cmplStd/lib/math/Fixed.ci:551: (10 bytes): x.value := piMul2 - x.value;
	<cos+?>: load.c32 6588397
	<cos+?>: dup.x32 sp(2)
	<cos+?>: sub.i32
	<cos+?>: set.x32 sp(2)
	cmplStd/lib/math/Fixed.ci:555: (5 bytes): sign: int32 := 1
	<cos+?>: load.c32 1
	cmplStd/lib/math/Fixed.ci:556: (27 bytes): if (x.value >= piDiv2)
	<cos+?>: dup.x32 sp(2)
	<cos+?>: load.c32 1647099
	<cos+?>: clt.i32
	<cos+?>: jnz +19
	cmplStd/lib/math/Fixed.ci:557: (8 bytes): x.value := x.value - pi;
	<cos+?>: dup.x32 sp(2)
	<cos+?>: inc.i32(-3294198)
	<cos+?>: set.x32 sp(3)
	cmplStd/lib/math/Fixed.ci:558: (7 bytes): sign := -1;
	<cos+?>: load.c32 -1
	<cos+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:562: (14 bytes): xsq: int32 := int64(x.value) * (x.value) >> precision
	<cos+?>: dup.x32 sp(2)
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(4)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	cmplStd/lib/math/Fixed.ci:563: (114 bytes): res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5)
	<cos+?>: dup.x32 sp(0)
	<cos+?>: load.c32 1048576
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.c32 -524288
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.c32 43690
	<cos+?>: dup.x32 sp(1)
	<cos+?>: load.c32 -1456
	<cos+?>: load.c32 26
	<cos+?>: load.c64 0
	<cos+?>: dup.x32 sp(4)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: set.x32 sp(1)
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: set.x32 sp(1)
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: set.x32 sp(1)
	<cos+?>: i32.2i64
	<cos+?>: dup.x32 sp(3)
	<cos+?>: i32.2i64
	<cos+?>: mul.i64
	<cos+?>: load.c32 20
	<cos+?>: sar.b64
	<cos+?>: i64.2i32
	<cos+?>: add.i32
	<cos+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:564: (26 bytes): return .result := as(sign * res);
	<cos+?>: inc.sp(+8)
	<cos+?>: dup.x32 sp(4)
	<cos+?>: dup.x32 sp(3)
	<cos+?>: mul.i32
	<cos+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<cos+?>: call
	<cos+?>: inc.sp(-4)
	<cos+?>: set.x64 sp(8)
	<cos+?>: inc.sp(-12)
	<cos+?>: ret
.usages:
	cmplStd/lib/math/Fixed.ci:610: referenced as `cos`
}
Fixed.tan(x: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 49
.name: 'tan'
.file: 'cmplStd/lib/math/Fixed.ci:605'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param x: Fixed (size: 8, cast: variable(val))
.doc: 'Returns the tangent of the radian argument `x`.'
.value: {
	return .result := div(sin(x), cos(x));
}
.instructions: (49 bytes)
	cmplStd/lib/math/Fixed.ci:610: (49 bytes): return .result := div(sin(x), cos(x));
	<tan>  : inc.sp(+8)
	<tan+?>: inc.sp(+8)
	<tan+?>: dup.x64 sp(5)
	<tan+?>: load.ref <?> ;Fixed.sin(x: Fixed): Fixed
	<tan+?>: call
	<tan+?>: inc.sp(-8)
	<tan+?>: inc.sp(+8)
	<tan+?>: dup.x64 sp(7)
	<tan+?>: load.ref <?> ;Fixed.cos(x: Fixed): Fixed
	<tan+?>: call
	<tan+?>: inc.sp(-8)
	<tan+?>: load.ref <?> ;Fixed.div(a: Fixed, b: Fixed): Fixed
	<tan+?>: call
	<tan+?>: inc.sp(-16)
	<tan+?>: set.x64 sp(5)
	<tan+?>: ret
.usages:
}
Fixed.degrees(radians: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 37
.name: 'degrees'
.file: 'cmplStd/lib/math/Fixed.ci:714'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param radians: Fixed (size: 8, cast: variable(val))
.doc: 'Converts the input to degrees from radians: $radians * 180 / pi$'
.value: {
	return .result := as((radians.value) * int64(r2d_24) >> 24);
}
.instructions: (37 bytes)
	cmplStd/lib/math/Fixed.ci:715: (37 bytes): return .result := as((radians.value) * int64(r2d_24) >> 24);
	<degrees>  : inc.sp(+8)
	<degrees+?>: dup.x32 sp(3)
	<degrees+?>: i32.2i64
	<degrees+?>: load.c64 961263668
	<degrees+?>: mul.i64
	<degrees+?>: load.c32 24
	<degrees+?>: sar.b64
	<degrees+?>: i64.2i32
	<degrees+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<degrees+?>: call
	<degrees+?>: inc.sp(-4)
	<degrees+?>: set.x64 sp(5)
	<degrees+?>: ret
.usages:
}
Fixed.radians(degrees: Fixed): Fixed: function {
.kind: static function
.base: `function`
.size: 24
.name: 'radians'
.file: 'cmplStd/lib/math/Fixed.ci:719'
.owner: Fixed
.param .result: Fixed (size: 8, cast: variable(val))
.param degrees: Fixed (size: 8, cast: variable(val))
.doc: 'Converts the input to radians from degrees: $degrees * pi / 180$'
.value: {
	return .result := mul_28(degrees, d2r_28);
}
.instructions: (24 bytes)
	cmplStd/lib/math/Fixed.ci:720: (24 bytes): return .result := mul_28(degrees, d2r_28);
	<radians>  : inc.sp(+8)
	<radians+?>: dup.x64 sp(3)
	<radians+?>: load.c32 4685082
	<radians+?>: load.ref <?> ;Fixed.mul_28(a: Fixed, b: int32): Fixed
	<radians+?>: call
	<radians+?>: inc.sp(-12)
	<radians+?>: set.x64 sp(5)
	<radians+?>: ret
.usages:
}
Fixed(value: int32): Fixed: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fixed'
.file: 'cmplStd/lib/math/Fixed.ci:725'
.param .result: Fixed (size: 8, cast: val)
.param value: int32 (size: 4, cast: i32)
.doc: 'Convert the integer `value` to fixed-point value'
.value: Fixed.as(value << Fixed.precision)
.usages:
}
int32(value: Fixed): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'int32'
.file: 'cmplStd/lib/math/Fixed.ci:728'
.param .result: int32 (size: 4, cast: i32)
.param value: Fixed (size: 4, cast: const ref)
.doc: 'Convert the fixed point `value` to integer value'
.value: value.value >> Fixed.precision
.usages:
}
Fixed(value: float64): Fixed: function {
.kind: static function
.base: `function`
.size: 95
.name: 'Fixed'
.file: 'cmplStd/lib/math/Fixed.ci:732'
.param .result: Fixed (size: 8, cast: variable(val))
.param value: float64 (size: 8, cast: variable(f64))
.doc: 'Convert the floating point `value` to fixed-point value'
.value: {
	result: Fixed := Fixed.as(value * ((1 << Fixed.precision)));
	if (result.value == Fixed.nan) {
		if (value != value) {
			result.value := Fixed.nan;
		}
		else if (value > (0)) {
			result.value := Fixed.inf;
		}
		else if (value < (0)) {
			result.value := -Fixed.inf;
		}
	}
	return .result := result;
}
.instructions: (95 bytes)
	cmplStd/lib/math/Fixed.ci:733: (26 bytes): result: Fixed := Fixed.as(value * ((1 << Fixed.precision)))
	<Fixed>  : inc.sp(+8)
	<Fixed+?>: dup.x64 sp(3)
	<Fixed+?>: load.c32 1
	<Fixed+?>: b32.shl 0x14
	<Fixed+?>: i32.2f64
	<Fixed+?>: mul.f64
	<Fixed+?>: f64.2i32
	<Fixed+?>: load.ref <?> ;Fixed.as(value: int32): Fixed
	<Fixed+?>: call
	<Fixed+?>: inc.sp(-4)
	cmplStd/lib/math/Fixed.ci:734: (66 bytes): if (result.value == Fixed.nan)
	<Fixed+?>: dup.x32 sp(0)
	<Fixed+?>: load.c32 -2147483648
	<Fixed+?>: ceq.i32
	<Fixed+?>: jz +58
	cmplStd/lib/math/Fixed.ci:735: (54 bytes): if (value != value)
	<Fixed+?>: dup.x64 sp(3)
	<Fixed+?>: dup.x64 sp(5)
	<Fixed+?>: ceq.f64
	<Fixed+?>: jnz +15
	cmplStd/lib/math/Fixed.ci:736: (7 bytes): result.value := Fixed.nan;
	<Fixed+?>: load.c32 -2147483648
	<Fixed+?>: set.x32 sp(1)
	<Fixed+?>: jmp +38
	cmplStd/lib/math/Fixed.ci:738: (34 bytes): if (value > (0))
	<Fixed+?>: dup.x64 sp(3)
	<Fixed+?>: load.z64
	<Fixed+?>: cgt.f64
	<Fixed+?>: jz +15
	cmplStd/lib/math/Fixed.ci:739: (7 bytes): result.value := Fixed.inf;
	<Fixed+?>: load.c32 2147483647
	<Fixed+?>: set.x32 sp(1)
	<Fixed+?>: jmp +19
	cmplStd/lib/math/Fixed.ci:741: (15 bytes): if (value < (0))
	<Fixed+?>: dup.x64 sp(3)
	<Fixed+?>: load.z64
	<Fixed+?>: clt.f64
	<Fixed+?>: jz +11
	cmplStd/lib/math/Fixed.ci:742: (7 bytes): result.value := -Fixed.inf;
	<Fixed+?>: load.c32 -2147483647
	<Fixed+?>: set.x32 sp(1)
	cmplStd/lib/math/Fixed.ci:745: (3 bytes): return .result := result;
	<Fixed+?>: set.x64 sp(5)
	<Fixed+?>: ret
.usages:
}
float64(value: Fixed): float64: function {
.kind: static function
.base: `function`
.size: 87
.name: 'float64'
.file: 'cmplStd/lib/math/Fixed.ci:750'
.param .result: float64 (size: 8, cast: variable(f64))
.param value: Fixed (size: 8, cast: variable(val))
.doc: 'Convert the fixed point `value` to floating point value'
.value: {
	if (value.value == Fixed.nan) {
		return .result := Math.nan;
	}
	if (value.value == Fixed.inf) {
		return .result := Math.inf;
	}
	if (value.value == -Fixed.inf) {
		return .result := -Math.inf;
	}
	return .result := (value.value) / float64(1 << Fixed.precision);
}
.instructions: (87 bytes)
	cmplStd/lib/math/Fixed.ci:751: (24 bytes): if (value.value == Fixed.nan)
	<float64>  : dup.x32 sp(1)
	<float64+?>: load.c32 -2147483648
	<float64+?>: ceq.i32
	<float64+?>: jz +16
	cmplStd/lib/math/Fixed.ci:752: (12 bytes): return .result := Math.nan;
	<float64+?>: load.f64 -nan
	<float64+?>: set.x64 sp(5)
	<float64+?>: ret
	cmplStd/lib/math/Fixed.ci:754: (24 bytes): if (value.value == Fixed.inf)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: load.c32 2147483647
	<float64+?>: ceq.i32
	<float64+?>: jz +16
	cmplStd/lib/math/Fixed.ci:755: (12 bytes): return .result := Math.inf;
	<float64+?>: load.f64 inf
	<float64+?>: set.x64 sp(5)
	<float64+?>: ret
	cmplStd/lib/math/Fixed.ci:757: (24 bytes): if (value.value == -Fixed.inf)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: load.c32 -2147483647
	<float64+?>: ceq.i32
	<float64+?>: jz +16
	cmplStd/lib/math/Fixed.ci:758: (12 bytes): return .result := -Math.inf;
	<float64+?>: load.f64 -inf
	<float64+?>: set.x64 sp(5)
	<float64+?>: ret
	cmplStd/lib/math/Fixed.ci:761: (15 bytes): return .result := (value.value) / float64(1 << Fixed.precision);
	<float64+?>: dup.x32 sp(1)
	<float64+?>: i32.2f64
	<float64+?>: load.c32 1
	<float64+?>: b32.shl 0x14
	<float64+?>: i32.2f64
	<float64+?>: div.f64
	<float64+?>: set.x64 sp(5)
	<float64+?>: ret
.usages:
}
Complex: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:2'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
.doc: 'Complex number'
.usages:
	cmplStd/test/math/test.Complex.ci:21: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:20: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:18: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:17: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:15: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:14: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:12: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:11: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:9: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:8: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:6: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:6: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:5: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:5: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:4: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:4: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:3: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:144: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:142: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:139: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:137: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:135: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:133: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:131: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:129: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:126: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:124: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:122: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:120: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:118: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:116: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:113: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:102: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:102: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:102: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:99: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:96: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:93: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:84: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:84: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:81: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:79: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:74: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:54: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:54: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:54: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:51: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:49: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:44: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:44: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:44: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:41: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:39: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:37: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:37: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:37: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:34: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:32: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:30: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:30: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:30: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:27: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:27: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:19: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:12: referenced as `Complex`
}
Complex.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'cmplStd/lib/math/Complex.ci:5'
.owner: Complex
.doc: 'The real component of a complex number.'
.usages:
	cmplStd/test/math/test.Complex.ci:9: referenced as `re`
	cmplStd/test/math/test.Complex.ci:8: referenced as `re`
	cmplStd/test/math/test.Complex.ci:6: referenced as `re`
	cmplStd/test/math/test.Complex.ci:6: referenced as `re`
	cmplStd/test/math/test.Complex.ci:6: referenced as `re`
	cmplStd/test/math/test.Complex.ci:6: referenced as `re`
	cmplStd/test/math/test.Complex.ci:5: referenced as `re`
	cmplStd/test/math/test.Complex.ci:5: referenced as `re`
	cmplStd/test/math/test.Complex.ci:4: referenced as `re`
	cmplStd/test/math/test.Complex.ci:4: referenced as `re`
	cmplStd/test/math/test.Complex.ci:3: referenced as `re`
	cmplStd/lib/math/Complex.ci:142: referenced as `re`
	cmplStd/lib/math/Complex.ci:142: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:118: referenced as `re`
	cmplStd/lib/math/Complex.ci:116: referenced as `re`
	cmplStd/lib/math/Complex.ci:116: referenced as `re`
	cmplStd/lib/math/Complex.ci:108: referenced as `re`
	cmplStd/lib/math/Complex.ci:106: referenced as `re`
	cmplStd/lib/math/Complex.ci:105: referenced as `re`
	cmplStd/lib/math/Complex.ci:96: referenced as `re`
	cmplStd/lib/math/Complex.ci:96: referenced as `re`
	cmplStd/lib/math/Complex.ci:93: referenced as `re`
	cmplStd/lib/math/Complex.ci:87: referenced as `re`
	cmplStd/lib/math/Complex.ci:87: referenced as `re`
	cmplStd/lib/math/Complex.ci:85: referenced as `re`
	cmplStd/lib/math/Complex.ci:85: referenced as `re`
	cmplStd/lib/math/Complex.ci:81: referenced as `re`
	cmplStd/lib/math/Complex.ci:79: referenced as `re`
	cmplStd/lib/math/Complex.ci:79: referenced as `re`
	cmplStd/lib/math/Complex.ci:69: referenced as `re`
	cmplStd/lib/math/Complex.ci:70: referenced as `re`
	cmplStd/lib/math/Complex.ci:69: referenced as `re`
	cmplStd/lib/math/Complex.ci:67: referenced as `re`
	cmplStd/lib/math/Complex.ci:66: referenced as `re`
	cmplStd/lib/math/Complex.ci:62: referenced as `re`
	cmplStd/lib/math/Complex.ci:63: referenced as `re`
	cmplStd/lib/math/Complex.ci:62: referenced as `re`
	cmplStd/lib/math/Complex.ci:60: referenced as `re`
	cmplStd/lib/math/Complex.ci:59: referenced as `re`
	cmplStd/lib/math/Complex.ci:58: referenced as `re`
	cmplStd/lib/math/Complex.ci:51: referenced as `re`
	cmplStd/lib/math/Complex.ci:49: referenced as `re`
	cmplStd/lib/math/Complex.ci:41: referenced as `re`
	cmplStd/lib/math/Complex.ci:39: referenced as `re`
	cmplStd/lib/math/Complex.ci:34: referenced as `re`
	cmplStd/lib/math/Complex.ci:32: referenced as `re`
	cmplStd/lib/math/Complex.ci:21: referenced as `re`
	cmplStd/lib/math/Complex.ci:14: referenced as `re`
}
Complex.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'cmplStd/lib/math/Complex.ci:8'
.owner: Complex
.doc: 'The imaginary component of a complex number.'
.value: 0
.usages:
	cmplStd/test/math/test.Complex.ci:9: referenced as `im`
	cmplStd/test/math/test.Complex.ci:8: referenced as `im`
	cmplStd/test/math/test.Complex.ci:6: referenced as `im`
	cmplStd/test/math/test.Complex.ci:6: referenced as `im`
	cmplStd/test/math/test.Complex.ci:6: referenced as `im`
	cmplStd/test/math/test.Complex.ci:6: referenced as `im`
	cmplStd/test/math/test.Complex.ci:5: referenced as `im`
	cmplStd/test/math/test.Complex.ci:5: referenced as `im`
	cmplStd/test/math/test.Complex.ci:4: referenced as `im`
	cmplStd/test/math/test.Complex.ci:4: referenced as `im`
	cmplStd/test/math/test.Complex.ci:3: referenced as `im`
	cmplStd/lib/math/Complex.ci:142: referenced as `im`
	cmplStd/lib/math/Complex.ci:142: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:118: referenced as `im`
	cmplStd/lib/math/Complex.ci:116: referenced as `im`
	cmplStd/lib/math/Complex.ci:116: referenced as `im`
	cmplStd/lib/math/Complex.ci:109: referenced as `im`
	cmplStd/lib/math/Complex.ci:106: referenced as `im`
	cmplStd/lib/math/Complex.ci:105: referenced as `im`
	cmplStd/lib/math/Complex.ci:96: referenced as `im`
	cmplStd/lib/math/Complex.ci:96: referenced as `im`
	cmplStd/lib/math/Complex.ci:93: referenced as `im`
	cmplStd/lib/math/Complex.ci:88: referenced as `im`
	cmplStd/lib/math/Complex.ci:88: referenced as `im`
	cmplStd/lib/math/Complex.ci:85: referenced as `im`
	cmplStd/lib/math/Complex.ci:85: referenced as `im`
	cmplStd/lib/math/Complex.ci:81: referenced as `im`
	cmplStd/lib/math/Complex.ci:79: referenced as `im`
	cmplStd/lib/math/Complex.ci:79: referenced as `im`
	cmplStd/lib/math/Complex.ci:70: referenced as `im`
	cmplStd/lib/math/Complex.ci:70: referenced as `im`
	cmplStd/lib/math/Complex.ci:69: referenced as `im`
	cmplStd/lib/math/Complex.ci:67: referenced as `im`
	cmplStd/lib/math/Complex.ci:66: referenced as `im`
	cmplStd/lib/math/Complex.ci:63: referenced as `im`
	cmplStd/lib/math/Complex.ci:63: referenced as `im`
	cmplStd/lib/math/Complex.ci:62: referenced as `im`
	cmplStd/lib/math/Complex.ci:60: referenced as `im`
	cmplStd/lib/math/Complex.ci:59: referenced as `im`
	cmplStd/lib/math/Complex.ci:58: referenced as `im`
	cmplStd/lib/math/Complex.ci:51: referenced as `im`
	cmplStd/lib/math/Complex.ci:49: referenced as `im`
	cmplStd/lib/math/Complex.ci:41: referenced as `im`
	cmplStd/lib/math/Complex.ci:39: referenced as `im`
	cmplStd/lib/math/Complex.ci:34: referenced as `im`
	cmplStd/lib/math/Complex.ci:32: referenced as `im`
	cmplStd/lib/math/Complex.ci:22: referenced as `im`
	internal usages: 1
}
Complex(value: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:12'
.param .result: Complex (size: 16, cast: variable(val))
.param value: float64 (size: 8, cast: variable(f64))
.doc: 'Create a Complex number from the given `value`'
.value: {
	return .result := {
			.result.re := value;
			.result.im := (0);
		};
}
.instructions: (7 bytes)
	cmplStd/lib/math/Complex.ci:13: (7 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:14: (3 bytes): .result.re := value;
	<Complex>  : mov.x64 sp(3, 1)
	:: (3 bytes): .result.im := (0);
	<Complex+?>: load.z64
	<Complex+?>: set.x64 sp(7)
	<Complex+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:113: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:76: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:74: referenced as `Complex`
}
Complex(real: float64, imaginary: float64): Complex: function {
.kind: static function
.base: `function`
.size: 7
.name: 'Complex'
.file: 'cmplStd/lib/math/Complex.ci:19'
.param .result: Complex (size: 16, cast: variable(val))
.param real: float64 (size: 8, cast: variable(f64))
.param imaginary: float64 (size: 8, cast: variable(f64))
.doc: 'Create a Complex number from the given `real` and `imaginary` values'
.value: {
	return .result := {
			.result.re := real;
			.result.im := imaginary;
		};
}
.instructions: (7 bytes)
	cmplStd/lib/math/Complex.ci:20: (7 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:21: (3 bytes): .result.re := real;
	<Complex>  : mov.x64 sp(5, 3)
	cmplStd/lib/math/Complex.ci:22: (3 bytes): .result.im := imaginary;
	<Complex+?>: mov.x64 sp(7, 1)
	<Complex+?>: ret
.usages:
	cmplStd/test/math/test.Complex.ci:6: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:5: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:4: referenced as `Complex`
	cmplStd/test/math/test.Complex.ci:3: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:144: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:142: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:118: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:116: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:99: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:96: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:93: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:51: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:49: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:41: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:39: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:34: referenced as `Complex`
	cmplStd/lib/math/Complex.ci:32: referenced as `Complex`
}
neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'cmplStd/lib/math/Complex.ci:27'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Unary negation of a complex number: -a := Complex(-a.re, -a.im);'
.value: Complex(emit(struct(a), neg.p2d))
.usages:
	cmplStd/test/math/test.Complex.ci:12: referenced as `neg`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `neg`
	cmplStd/lib/math/Complex.ci:131: referenced as `neg`
	cmplStd/lib/math/Complex.ci:129: referenced as `neg`
}
add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:30'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: Complex (size: 16, cast: val)
.doc: 'Add two complex numbers: a + b := Complex(a.re + b.re, a.im + b.im);'
.value: Complex(emit(struct(a), struct(b), add.p2d))
.usages:
	cmplStd/test/math/test.Complex.ci:15: referenced as `add`
	cmplStd/lib/math/Complex.ci:131: referenced as `add`
}
add(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:32'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: 'Add a complex number `a` to a real number `b`'
.value: Complex(a.re + b, a.im)
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `add`
	cmplStd/lib/math/Complex.ci:133: referenced as `add`
}
add(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Complex.ci:34'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Add a complex number `b` to a real number `a`'
.value: Complex(a + b.re, b.im)
.usages:
}
sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:37'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: Complex (size: 16, cast: val)
.doc: 'Subtract two complex numbers: a - b := Complex(a.re - b.re, a.im - b.im);'
.value: Complex(emit(struct(a), struct(b), sub.p2d))
.usages:
	cmplStd/test/math/test.Complex.ci:18: referenced as `sub`
	cmplStd/lib/math/Complex.ci:129: referenced as `sub`
}
sub(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:39'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: f64)
.doc: 'Subtract the real number `b` from the complex number `a`'
.value: Complex(a.re - b, a.im)
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `sub`
	cmplStd/lib/math/Complex.ci:133: referenced as `sub`
}
sub(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Complex.ci:41'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Subtract the complex number `b` from the real number `a`'
.value: Complex(a - b.re, b.im)
.usages:
}
mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:44'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Multiply two complex numbers: a * b := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);'
.value: Complex(emit(struct(a), struct(b), swz.x2, mul.p2d, add.f64, struct(a), struct(b), mul.p2d, swz.x2, sub.f64))
.usages:
	cmplStd/test/math/test.Complex.ci:21: referenced as `mul`
}
mul(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:49'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: float64 (size: 8, cast: variable(f64))
.doc: 'Multiply a complex number `a` with a real number `b`'
.value: Complex(a.re * b, a.im * b)
.usages:
}
mul(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Complex.ci:51'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: variable(f64))
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Multiply a complex number `b` with a real number `a`'
.value: Complex(a * b.re, a * b.im)
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `mul`
	cmplStd/lib/math/Complex.ci:135: referenced as `mul`
	cmplStd/lib/math/Complex.ci:133: referenced as `mul`
	cmplStd/lib/math/Complex.ci:133: referenced as `mul`
}
div(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 139
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:54'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Divide two complex numbers'
.value: {
	if (Math.abs(b.re) >= Math.abs(b.im)) {
		r: float64 := b.im / b.re;
		den: float64 := b.re + r * b.im;
		return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
	}
	r: float64 := b.re / b.im;
	den: float64 := b.im + r * b.re;
	return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
}
.instructions: (139 bytes)
	cmplStd/lib/math/Complex.ci:58: (95 bytes): if (Math.abs(b.re) >= Math.abs(b.im))
	<div>  : dup.x64 sp(1)
	<div+?>: dup.x64 sp(0)
	<div+?>: load.z64
	<div+?>: clt.f64
	<div+?>: jz +11
	<div+?>: dup.x64 sp(0)
	<div+?>: neg.f64
	<div+?>: jmp +6
	<div+?>: dup.x64 sp(0)
	<div+?>: set.x64 sp(2)
	<div+?>: dup.x64 sp(5)
	<div+?>: dup.x64 sp(0)
	<div+?>: load.z64
	<div+?>: clt.f64
	<div+?>: jz +11
	<div+?>: dup.x64 sp(0)
	<div+?>: neg.f64
	<div+?>: jmp +6
	<div+?>: dup.x64 sp(0)
	<div+?>: set.x64 sp(2)
	<div+?>: clt.f64
	<div+?>: jnz +52
	cmplStd/lib/math/Complex.ci:59: (5 bytes): r: float64 := b.im / b.re
	<div+?>: dup.x64 sp(3)
	<div+?>: dup.x64 sp(3)
	<div+?>: div.f64
	cmplStd/lib/math/Complex.ci:60: (8 bytes): den: float64 := b.re + r * b.im
	<div+?>: dup.x64 sp(3)
	<div+?>: dup.x64 sp(2)
	<div+?>: dup.x64 sp(9)
	<div+?>: mul.f64
	<div+?>: add.f64
	cmplStd/lib/math/Complex.ci:61: (31 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:62: (13 bytes): .result.re := (a.re + r * a.im) / den;
	<div+?>: dup.x64 sp(9)
	<div+?>: dup.x64 sp(4)
	<div+?>: dup.x64 sp(15)
	<div+?>: mul.f64
	<div+?>: add.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:63: (13 bytes): .result.im := (a.im - r * a.re) / den;
	<div+?>: dup.x64 sp(11)
	<div+?>: dup.x64 sp(4)
	<div+?>: dup.x64 sp(13)
	<div+?>: mul.f64
	<div+?>: sub.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
	<div+?>: inc.sp(-16)
	cmplStd/lib/math/Complex.ci:66: (5 bytes): r: float64 := b.re / b.im
	<div+?>: dup.x64 sp(1)
	<div+?>: dup.x64 sp(5)
	<div+?>: div.f64
	cmplStd/lib/math/Complex.ci:67: (8 bytes): den: float64 := b.im + r * b.re
	<div+?>: dup.x64 sp(5)
	<div+?>: dup.x64 sp(2)
	<div+?>: dup.x64 sp(7)
	<div+?>: mul.f64
	<div+?>: add.f64
	cmplStd/lib/math/Complex.ci:68: (31 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:69: (13 bytes): .result.re := (a.re * r + a.im) / den;
	<div+?>: dup.x64 sp(9)
	<div+?>: dup.x64 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x64 sp(13)
	<div+?>: add.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(15)
	cmplStd/lib/math/Complex.ci:70: (13 bytes): .result.im := (a.im * r - a.re) / den;
	<div+?>: dup.x64 sp(11)
	<div+?>: dup.x64 sp(4)
	<div+?>: mul.f64
	<div+?>: dup.x64 sp(11)
	<div+?>: sub.f64
	<div+?>: dup.x64 sp(2)
	<div+?>: div.f64
	<div+?>: set.x64 sp(17)
	<div+?>: inc.sp(-16)
	<div+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `div`
	cmplStd/lib/math/Complex.ci:133: referenced as `div`
	cmplStd/lib/math/Complex.ci:122: referenced as `div`
	cmplStd/lib/math/Complex.ci:120: referenced as `div`
	cmplStd/lib/math/Complex.ci:76: referenced as `div`
	cmplStd/lib/math/Complex.ci:74: referenced as `div`
}
div(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:74'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: 'Divide the complex number `a` by the real number `b`'
.value: div(a, Complex(b))
.usages:
	cmplStd/lib/math/Complex.ci:131: referenced as `div`
	cmplStd/lib/math/Complex.ci:129: referenced as `div`
}
div(a: float64, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Complex.ci:76'
.param .result: Complex (size: 16, cast: val)
.param a: float64 (size: 8, cast: f64)
.param b: Complex (size: 16, cast: val)
.doc: 'Divide the real number `a` by the complex number `b`'
.value: div(Complex(a), b)
.usages:
}
abs(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Complex.ci:79'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the absolute value of the complex number `a`'
.value: Math.sqrt(a.re * a.re + a.im * a.im)
.usages:
	cmplStd/lib/math/Complex.ci:144: referenced as `abs`
	cmplStd/lib/math/Complex.ci:103: referenced as `abs`
	cmplStd/lib/math/Complex.ci:99: referenced as `abs`
}
arg(a: Complex): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'arg'
.file: 'cmplStd/lib/math/Complex.ci:81'
.param .result: float64 (size: 8, cast: f64)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the argument of the complex number `a`'
.value: Math.atan2(a.re, a.im)
.usages:
	cmplStd/lib/math/Complex.ci:144: referenced as `arg`
	cmplStd/lib/math/Complex.ci:104: referenced as `arg`
	cmplStd/lib/math/Complex.ci:99: referenced as `arg`
}
inv(a: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 31
.name: 'inv'
.file: 'cmplStd/lib/math/Complex.ci:84'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the reciprocal of a complex number (1 / a)'
.value: {
	d: float64 := a.re * a.re + a.im * a.im;
	return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
}
.instructions: (31 bytes)
	cmplStd/lib/math/Complex.ci:85: (11 bytes): d: float64 := a.re * a.re + a.im * a.im
	<inv>  : dup.x64 sp(1)
	<inv+?>: dup.x64 sp(3)
	<inv+?>: mul.f64
	<inv+?>: dup.x64 sp(5)
	<inv+?>: dup.x64 sp(7)
	<inv+?>: mul.f64
	<inv+?>: add.f64
	cmplStd/lib/math/Complex.ci:86: (20 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:87: (7 bytes): .result.re := +a.re / d;
	<inv+?>: dup.x64 sp(3)
	<inv+?>: dup.x64 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x64 sp(9)
	cmplStd/lib/math/Complex.ci:88: (8 bytes): .result.im := -a.im / d;
	<inv+?>: dup.x64 sp(5)
	<inv+?>: neg.f64
	<inv+?>: dup.x64 sp(2)
	<inv+?>: div.f64
	<inv+?>: set.x64 sp(11)
	<inv+?>: inc.sp(-8)
	<inv+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:139: referenced as `inv`
	cmplStd/lib/math/Complex.ci:137: referenced as `inv`
	cmplStd/lib/math/Complex.ci:126: referenced as `inv`
	cmplStd/lib/math/Complex.ci:124: referenced as `inv`
}
conj(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'conj'
.file: 'cmplStd/lib/math/Complex.ci:93'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the conjugate of the complex number `a`'
.value: Complex(a.re, -a.im)
.usages:
}
exp(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'exp'
.file: 'cmplStd/lib/math/Complex.ci:96'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the exponential of a complex number: $ e^a $.'
.value: Complex(Math.exp(a.re) * Math.cos(a.im), Math.exp(a.re) * Math.sin(a.im))
.usages:
	cmplStd/lib/math/Complex.ci:135: referenced as `exp`
	cmplStd/lib/math/Complex.ci:135: referenced as `exp`
	cmplStd/lib/math/Complex.ci:133: referenced as `exp`
	cmplStd/lib/math/Complex.ci:133: referenced as `exp`
	cmplStd/lib/math/Complex.ci:131: referenced as `exp`
	cmplStd/lib/math/Complex.ci:131: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
	cmplStd/lib/math/Complex.ci:129: referenced as `exp`
}
log(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'log'
.file: 'cmplStd/lib/math/Complex.ci:99'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the natural logarithm of the complex number `a`.'
.value: Complex(Math.log(abs(a)), arg(a))
.usages:
}
pow(a: Complex, b: Complex): Complex: function {
.kind: static function
.base: `function`
.size: 151
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:102'
.param .result: Complex (size: 16, cast: variable(val))
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.doc: 'Compute the complex number `a` raised to the power of `b`: $ a^b $.'
.value: {
	r: float64 := abs(a);
	t: float64 := arg(a);
	u: float64 := b.re * t + b.im * Math.log(r);
	v: float64 := Math.pow(r, b.re) * Math.exp(-b.im * t);
	return .result := {
			.result.re := v * Math.cos(u);
			.result.im := v * Math.sin(u);
		};
}
.instructions: (151 bytes)
	cmplStd/lib/math/Complex.ci:103: (31 bytes): r: float64 := abs(a)
	<pow>  : dup.x128 sp(5)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(2)
	<pow+?>: dup.x64 sp(4)
	<pow+?>: mul.f64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: dup.x64 sp(8)
	<pow+?>: mul.f64
	<pow+?>: add.f64
	<pow+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mov.x64 sp(4, 0)
	<pow+?>: inc.sp(-16)
	cmplStd/lib/math/Complex.ci:104: (24 bytes): t: float64 := arg(a)
	<pow+?>: dup.x128 sp(7)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(2)
	<pow+?>: dup.x64 sp(6)
	<pow+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-16)
	<pow+?>: mov.x64 sp(4, 0)
	<pow+?>: inc.sp(-16)
	cmplStd/lib/math/Complex.ci:105: (22 bytes): u: float64 := b.re * t + b.im * Math.log(r)
	<pow+?>: dup.x64 sp(5)
	<pow+?>: dup.x64 sp(2)
	<pow+?>: mul.f64
	<pow+?>: dup.x64 sp(9)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(8)
	<pow+?>: load.ref <?> ;Math.log(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: add.f64
	cmplStd/lib/math/Complex.ci:106: (33 bytes): v: float64 := Math.pow(r, b.re) * Math.exp(-b.im * t)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: dup.x64 sp(11)
	<pow+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-16)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(13)
	<pow+?>: neg.f64
	<pow+?>: dup.x64 sp(8)
	<pow+?>: mul.f64
	<pow+?>: load.ref <?> ;Math.exp(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	cmplStd/lib/math/Complex.ci:107: (41 bytes): return .result := {...};
	cmplStd/lib/math/Complex.ci:108: (18 bytes): .result.re := v * Math.cos(u);
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: load.ref <?> ;Math.cos(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(19)
	cmplStd/lib/math/Complex.ci:109: (18 bytes): .result.im := v * Math.sin(u);
	<pow+?>: dup.x64 sp(0)
	<pow+?>: load.z64
	<pow+?>: dup.x64 sp(6)
	<pow+?>: load.ref <?> ;Math.sin(x: float64): float64
	<pow+?>: call
	<pow+?>: inc.sp(-8)
	<pow+?>: mul.f64
	<pow+?>: set.x64 sp(21)
	<pow+?>: inc.sp(-32)
	<pow+?>: ret
.usages:
	cmplStd/lib/math/Complex.ci:113: referenced as `pow`
}
pow(a: Complex, b: float64): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'pow'
.file: 'cmplStd/lib/math/Complex.ci:113'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.param b: float64 (size: 8, cast: f64)
.doc: 'Compute the complex number `a` raised to the power of `b`: $ a^b $.'
.value: pow(a, Complex(b))
.usages:
}
sin(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sin'
.file: 'cmplStd/lib/math/Complex.ci:116'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the sine of the complex number `a`.'
.value: Complex(Math.sin(a.re) * Math.cosh(a.im), +Math.cos(a.re) * Math.sinh(a.im))
.usages:
	cmplStd/lib/math/Complex.ci:126: referenced as `sin`
	cmplStd/lib/math/Complex.ci:122: referenced as `sin`
	cmplStd/lib/math/Complex.ci:120: referenced as `sin`
}
cos(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cos'
.file: 'cmplStd/lib/math/Complex.ci:118'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the cosine of the complex number `a`.'
.value: Complex(Math.cos(a.re) * Math.cosh(a.im), -Math.sin(a.re) * Math.sinh(a.im))
.usages:
	cmplStd/lib/math/Complex.ci:124: referenced as `cos`
	cmplStd/lib/math/Complex.ci:122: referenced as `cos`
	cmplStd/lib/math/Complex.ci:120: referenced as `cos`
}
tan(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tan'
.file: 'cmplStd/lib/math/Complex.ci:120'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the tangent of the complex number `a`.'
.value: div(sin(a), cos(a))
.usages:
}
cot(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cot'
.file: 'cmplStd/lib/math/Complex.ci:122'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the cotangent of the complex number `a`.'
.value: div(cos(a), sin(a))
.usages:
}
sec(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sec'
.file: 'cmplStd/lib/math/Complex.ci:124'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Compute the secant of the complex number `a`.'
.value: inv(cos(a))
.usages:
}
csc(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csc'
.file: 'cmplStd/lib/math/Complex.ci:126'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Compute the cosecant of the complex number `a`.'
.value: inv(sin(a))
.usages:
}
sinh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sinh'
.file: 'cmplStd/lib/math/Complex.ci:129'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the hyperbolic sine of the complex number `a`.'
.value: div(sub(exp(a), exp(neg(a))), 2)
.usages:
	cmplStd/lib/math/Complex.ci:139: referenced as `sinh`
}
cosh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cosh'
.file: 'cmplStd/lib/math/Complex.ci:131'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the hyperbolic cosine of the complex number `a`.'
.value: div(add(exp(a), exp(neg(a))), 2)
.usages:
	cmplStd/lib/math/Complex.ci:137: referenced as `cosh`
}
tanh(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'tanh'
.file: 'cmplStd/lib/math/Complex.ci:133'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the hyperbolic tangent of the complex number `a`.'
.value: div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1))
.usages:
}
coth(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'coth'
.file: 'cmplStd/lib/math/Complex.ci:135'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.doc: 'Compute the hyperbolic cotangent of the complex number `a`.'
.value: div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1))
.usages:
}
sech(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sech'
.file: 'cmplStd/lib/math/Complex.ci:137'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Compute the hyperbolic secant of the complex number `a`.'
.value: inv(cosh(a))
.usages:
}
csch(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'csch'
.file: 'cmplStd/lib/math/Complex.ci:139'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: val)
.doc: 'Compute the hyperbolic cosecant of the complex number `a`.'
.value: inv(sinh(a))
.usages:
}
toCartesian(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toCartesian'
.file: 'cmplStd/lib/math/Complex.ci:142'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: 'Convert the from polar(r,) to cartesian(x,y) coordinates'
.value: Complex(x.re * Math.cos(x.im), x.re * Math.sin(x.im))
.usages:
}
toPolar(x: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toPolar'
.file: 'cmplStd/lib/math/Complex.ci:144'
.param .result: Complex (size: 16, cast: val)
.param x: Complex (size: 16, cast: variable(val))
.doc: 'Convert the from cartesian(x,y) to polar(r,) coordinates'
.value: Complex(abs(x), arg(x))
.usages:
}
vec4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:2'
.field <?>: vec4f.<?> (size: 16, cast: variable(val))
.field x: float32 (size: 0, cast: inline)
.field y: float32 (size: 0, cast: inline)
.field z: float32 (size: 0, cast: inline)
.field w: float32 (size: 0, cast: inline)
.field data: float32[4] (size: 16, cast: variable(val))
.doc: 'A 4d vector (4x float32)'
.usages:
	cmplStd/lib/math/Matrix4f.ci:201: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:191: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:158: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:109: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:109: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:20: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:18: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:16: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:14: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:10: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:139: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:137: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:131: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:127: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:123: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:114: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:114: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:105: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:103: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:103: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:103: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:77: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:75: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:73: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:71: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:69: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:26: referenced as `vec4f`
}
vec4f.<?>: vec4f.<?> {
.kind: variable(val)
.base: `vec4f.<?>`
.size: 16
.name: '<?>'
.file: 'cmplStd/lib/math/Vector4f.ci:153'
.owner: vec4f
.field x: float32 (size: 4, cast: variable(f32))
.field y: float32 (size: 4, cast: variable(f32))
.field z: float32 (size: 4, cast: variable(f32))
.field w: float32 (size: 4, cast: variable(f32))
.usages:
}
vec4f.<?>.x: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:182: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:162: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:159: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:159: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:123: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:120: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:115: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:115: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `x`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `x`
}
vec4f.<?>.y: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:181: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:164: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:162: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:160: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:124: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:121: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:116: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `y`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `y`
}
vec4f.<?>.z: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f.<?>
.doc: 'Z component of the vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:172: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:164: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:163: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:161: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:161: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:125: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:122: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:142: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:134: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:117: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:117: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `z`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `z`
}
vec4f.<?>.w: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f.<?>
.doc: 'W component of the vector'
.usages:
	cmplStd/lib/math/Vector4f.ci:142: referenced as `w`
	cmplStd/lib/math/Vector4f.ci:118: referenced as `w`
	cmplStd/lib/math/Vector4f.ci:118: referenced as `w`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `w`
}
vec4f.x: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'x'
.file: 'cmplStd/lib/math/Vector4f.ci:5'
.owner: vec4f
.doc: 'X component of the vector'
.value: x: float32
}
vec4f.y: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'y'
.file: 'cmplStd/lib/math/Vector4f.ci:7'
.owner: vec4f
.doc: 'Y component of the vector'
.value: y: float32
}
vec4f.z: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'z'
.file: 'cmplStd/lib/math/Vector4f.ci:9'
.owner: vec4f
.doc: 'Z component of the vector'
.value: z: float32
}
vec4f.w: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'w'
.file: 'cmplStd/lib/math/Vector4f.ci:11'
.owner: vec4f
.doc: 'W component of the vector'
.value: w: float32
}
vec4f.data: float32[4] {
.kind: variable(val)
.base: `float32[4]`
.size: 16
.name: 'data'
.file: 'cmplStd/lib/math/Vector4f.ci:14'
.owner: vec4f
.doc: 'Access the components as an array'
.usages:
}
vec4f(x: float32, y: float32, z: float32, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:26'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.param z: float32 (size: 4, cast: f32)
.param w: float32 (size: 4, cast: f32)
.doc: 'Initialize with given x, y, z, w components'
.value: vec4f(emit(struct(w), struct(z), struct(y), struct(x)))
.usages:
	cmplStd/lib/math/Matrix4f.ci:186: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:153: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:115: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:114: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:114: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:100: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:38: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:35: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:32: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:29: referenced as `vec4f`
}
vec4f(x: float32, y: float32, z: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:29'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.param z: float32 (size: 4, cast: f32)
.doc: 'Initialize with  (x: x, y: y, z: z, w: 1)'
.value: vec4f(x, y, z, 1.000000)
.usages:
	cmplStd/lib/math/Vector4f.ci:134: referenced as `vec4f`
}
vec4f(x: float32, y: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:32'
.param .result: vec4f (size: 16, cast: val)
.param x: float32 (size: 4, cast: f32)
.param y: float32 (size: 4, cast: f32)
.doc: 'Initialize with (x: x, y: y, z: 0, w: 1)'
.value: vec4f(x, y, 0.000000, 1.000000)
.usages:
}
vec4f(xyz: vec4f, w: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:35'
.param .result: vec4f (size: 16, cast: val)
.param xyz: vec4f (size: 16, cast: variable(val))
.param w: float32 (size: 4, cast: f32)
.doc: 'Initialize x, y, z components using the components form the given vector, and w with the given value'
.value: vec4f(xyz.x, xyz.y, xyz.z, w)
.usages:
}
vec4f(val: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'vec4f'
.file: 'cmplStd/lib/math/Vector4f.ci:38'
.param .result: vec4f (size: 16, cast: val)
.param val: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize x, y, z, w components with the given scalar value'
.value: vec4f(val, val, val, val)
.usages:
	cmplStd/lib/math/Vector4f.ci:139: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:111: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:92: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:87: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:82: referenced as `vec4f`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `vec4f`
}
neg(rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'neg'
.file: 'cmplStd/lib/math/Vector4f.ci:69'
.param .result: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Returns a negated copy of the vector.'
.value: vec4f(emit(struct(rhs), neg.p4f))
.usages:
}
add(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:71'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), add.p4f))
.usages:
	cmplStd/lib/math/Vector4f.ci:82: referenced as `add`
	cmplStd/lib/math/Vector4f.ci:80: referenced as `add`
}
sub(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:73'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), sub.p4f))
.usages:
	cmplStd/lib/math/Vector4f.ci:87: referenced as `sub`
	cmplStd/lib/math/Vector4f.ci:85: referenced as `sub`
}
mul(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:75'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), mul.p4f))
.usages:
	cmplStd/lib/math/Vector4f.ci:92: referenced as `mul`
	cmplStd/lib/math/Vector4f.ci:90: referenced as `mul`
}
div(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:77'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), div.p4f))
.usages:
	cmplStd/lib/math/Vector4f.ci:139: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:97: referenced as `div`
	cmplStd/lib/math/Vector4f.ci:95: referenced as `div`
}
add(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:80'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise add vector and scalar.'
.value: add(vec4f(a), b)
.usages:
}
add(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector4f.ci:82'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise add vector and scalar.'
.value: add(a, vec4f(b))
.usages:
}
sub(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:85'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(vec4f(a), b)
.usages:
}
sub(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector4f.ci:87'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise subtract vector and scalar.'
.value: sub(a, vec4f(b))
.usages:
}
mul(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:90'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(vec4f(a), b)
.usages:
}
mul(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector4f.ci:92'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise multiply vector and scalar.'
.value: mul(a, vec4f(b))
.usages:
	cmplStd/lib/math/Matrix4f.ci:168: referenced as `mul`
}
div(a: float32, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:95'
.param .result: vec4f (size: 16, cast: val)
.param a: float32 (size: 4, cast: f32)
.param b: vec4f (size: 16, cast: val)
.doc: 'Component wise divide vector and scalar.'
.value: div(vec4f(a), b)
.usages:
}
div(a: vec4f, b: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector4f.ci:97'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: val)
.param b: float32 (size: 4, cast: f32)
.doc: 'Component wise divide vector and scalar.'
.value: div(a, vec4f(b))
.usages:
}
abs(a: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'abs'
.file: 'cmplStd/lib/math/Vector4f.ci:100'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: variable(val))
.doc: 'Component wise absolute value of a vector.'
.value: vec4f(Math.abs(a.x), Math.abs(a.y), Math.abs(a.z), Math.abs(a.w))
.usages:
}
min(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Vector4f.ci:103'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise minimum of the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), min.p4f))
.usages:
	cmplStd/lib/math/Vector2d.ci:34: referenced as `min`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `min`
}
max(lhs: vec4f, rhs: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Vector4f.ci:105'
.param .result: vec4f (size: 16, cast: val)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Component wise maximum of the two vectors.'
.value: vec4f(emit(struct(lhs), struct(rhs), max.p4f))
.usages:
	cmplStd/lib/math/Vector2d.ci:37: referenced as `max`
	cmplStd/lib/math/Vector4f.ci:108: referenced as `max`
}
clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:108'
.param .result: vec4f (size: 16, cast: val)
.param vec: vec4f (size: 16, cast: val)
.param min: vec4f (size: 16, cast: val)
.param max: vec4f (size: 16, cast: val)
.doc: 'Clamp the vector component wise to the range [min ... max]'
.value: min(max(vec, min), max)
.usages:
	cmplStd/lib/math/Vector4f.ci:111: referenced as `clamp`
}
clamp(vec: vec4f, min: float32, max: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'clamp'
.file: 'cmplStd/lib/math/Vector4f.ci:111'
.param .result: vec4f (size: 16, cast: val)
.param vec: vec4f (size: 16, cast: val)
.param min: float32 (size: 4, cast: f32)
.param max: float32 (size: 4, cast: f32)
.doc: 'Clamp each component of the vector to the range [min ... max]'
.value: clamp(vec, vec4f(min), vec4f(max))
.usages:
}
mix(a: vec4f, b: vec4f, t: float32): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mix'
.file: 'cmplStd/lib/math/Vector4f.ci:114'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 16, cast: variable(val))
.param b: vec4f (size: 16, cast: variable(val))
.param t: float32 (size: 4, cast: variable(f32))
.doc: 'linear interpolate'
.value: vec4f(Math.mix(a.x, b.x, t), Math.mix(a.y, b.y, t), Math.mix(a.z, b.z, t), Math.mix(a.w, b.w, t))
.usages:
}
dp3(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'cmplStd/lib/math/Vector4f.ci:123'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product of the first 3 elements'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dp3))
.usages:
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `dp3`
	cmplStd/lib/math/Vector4f.ci:137: referenced as `dp3`
}
dph(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'cmplStd/lib/math/Vector4f.ci:127'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Homogeneous dot product'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dph))
.usages:
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `dph`
}
dp4(lhs: vec4f, rhs: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'cmplStd/lib/math/Vector4f.ci:131'
.param .result: float32 (size: 4, cast: f32)
.param lhs: vec4f (size: 16, cast: val)
.param rhs: vec4f (size: 16, cast: val)
.doc: 'Dot product'
.value: float32(emit(struct(lhs), struct(rhs), p4x.dp4))
.usages:
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `dp4`
}
cross(a: vec4f, b: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'cross'
.file: 'cmplStd/lib/math/Vector4f.ci:134'
.param .result: vec4f (size: 16, cast: val)
.param a: vec4f (size: 4, cast: const variable(ref))
.param b: vec4f (size: 4, cast: const variable(ref))
.doc: 'Cross product of the first 3 elements'
.value: vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x)
.usages:
}
length(v: vec4f): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'length'
.file: 'cmplStd/lib/math/Vector4f.ci:137'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 16, cast: variable(val))
.doc: 'Length of the vector(xyz)'
.value: Math.sqrt(dp3(v, v))
.usages:
	cmplStd/lib/math/Matrix4f.ci:110: referenced as `length`
	cmplStd/lib/math/Vector4f.ci:139: referenced as `length`
}
normalize(v: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'normalize'
.file: 'cmplStd/lib/math/Vector4f.ci:139'
.param .result: vec4f (size: 16, cast: val)
.param v: vec4f (size: 4, cast: const variable(ref))
.doc: 'Normalize the vector(xyz)'
.value: div(v, vec4f(length(v)))
.usages:
}
eval(v: vec4f, x: float32): float32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'eval'
.file: 'cmplStd/lib/math/Vector4f.ci:142'
.param .result: float32 (size: 4, cast: f32)
.param v: vec4f (size: 4, cast: const variable(ref))
.param x: float32 (size: 4, cast: variable(f32))
.doc: 'Evaluate as a polynomial in point x'
.value: float32((((v.w * x + v.z) * x + v.y) * x) + v.x)
.usages:
}
mat4f: typename {
.kind: static const typename(val)
.base: `typename`
.size: 64
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:2'
.field m: float32[4][4] (size: 64, cast: variable(val))
.field data: float32[16] (size: 64, cast: variable(val))
.field v: vec4f[4] (size: 64, cast: variable(val))
.field <?>: mat4f.<?> (size: 64, cast: variable(val))
.field x: vec4f (size: 0, cast: inline)
.field y: vec4f (size: 0, cast: inline)
.field z: vec4f (size: 0, cast: inline)
.field w: vec4f (size: 0, cast: inline)
.field <?>: mat4f.<?> (size: 64, cast: variable(val))
.field xx: float32 (size: 0, cast: inline)
.field xy: float32 (size: 0, cast: inline)
.field xz: float32 (size: 0, cast: inline)
.field xw: float32 (size: 0, cast: inline)
.field yx: float32 (size: 0, cast: inline)
.field yy: float32 (size: 0, cast: inline)
.field yz: float32 (size: 0, cast: inline)
.field yw: float32 (size: 0, cast: inline)
.field zx: float32 (size: 0, cast: inline)
.field zy: float32 (size: 0, cast: inline)
.field zz: float32 (size: 0, cast: inline)
.field zw: float32 (size: 0, cast: inline)
.field wx: float32 (size: 0, cast: inline)
.field wy: float32 (size: 0, cast: inline)
.field wz: float32 (size: 0, cast: inline)
.field ww: float32 (size: 0, cast: inline)
.doc: 'A 4x4 matrix'
.usages:
	cmplStd/lib/math/Matrix4f.ci:213: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:213: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:201: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:191: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:158: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:109: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:97: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:87: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:75: referenced as `mat4f`
	cmplStd/lib/math/Matrix4f.ci:62: referenced as `mat4f`
}
mat4f.m: float32[4][4] {
.kind: variable(val)
.base: `float32[4][4]`
.size: 64
.name: 'm'
.file: 'cmplStd/lib/math/Matrix4f.ci:4'
.owner: mat4f
.doc: 'Access elements as an array: m[1][0]'
.usages:
}
mat4f.data: float32[16] {
.kind: variable(val)
.base: `float32[16]`
.size: 64
.name: 'data'
.file: 'cmplStd/lib/math/Matrix4f.ci:7'
.owner: mat4f
.doc: 'Access elements as a flatten array: data[4] => m[1][0]'
.usages:
}
mat4f.v: vec4f[4] {
.kind: variable(val)
.base: `vec4f[4]`
.size: 64
.name: 'v'
.file: 'cmplStd/lib/math/Matrix4f.ci:10'
.owner: mat4f
.doc: 'Access elements as an array of vectors: v[1].x => m[1][0]'
.usages:
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:268'
.owner: mat4f
.field x: vec4f (size: 16, cast: variable(val))
.field y: vec4f (size: 16, cast: variable(val))
.field z: vec4f (size: 16, cast: variable(val))
.field w: vec4f (size: 16, cast: variable(val))
.usages:
}
mat4f.<?>.x: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f.<?>
.doc: 'The first row as a vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:114: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `x`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `x`
}
mat4f.<?>.y: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f.<?>
.doc: 'The second row as a vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:115: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `y`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `y`
}
mat4f.<?>.z: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f.<?>
.doc: 'The third row as a vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:116: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:80: referenced as `z`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `z`
}
mat4f.<?>.w: vec4f {
.kind: variable(val)
.base: `vec4f`
.size: 16
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f.<?>
.doc: 'The fourth row as a vector'
.usages:
	cmplStd/lib/math/Matrix4f.ci:186: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:153: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:117: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:84: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:82: referenced as `w`
	cmplStd/lib/math/Matrix4f.ci:76: referenced as `w`
}
mat4f.x: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'x'
.file: 'cmplStd/lib/math/Matrix4f.ci:14'
.owner: mat4f
.doc: 'The first row as a vector'
.value: x: vec4f
}
mat4f.y: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'y'
.file: 'cmplStd/lib/math/Matrix4f.ci:16'
.owner: mat4f
.doc: 'The second row as a vector'
.value: y: vec4f
}
mat4f.z: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'z'
.file: 'cmplStd/lib/math/Matrix4f.ci:18'
.owner: mat4f
.doc: 'The third row as a vector'
.value: z: vec4f
}
mat4f.w: vec4f {
.kind: inline
.base: `vec4f`
.size: 0
.name: 'w'
.file: 'cmplStd/lib/math/Matrix4f.ci:20'
.owner: mat4f
.doc: 'The fourth row as a vector'
.value: w: vec4f
}
mat4f.<?>: mat4f.<?> {
.kind: variable(val)
.base: `mat4f.<?>`
.size: 64
.name: '<?>'
.file: 'cmplStd/lib/math/Matrix4f.ci:268'
.owner: mat4f
.field xx: float32 (size: 4, cast: variable(f32))
.field xy: float32 (size: 4, cast: variable(f32))
.field xz: float32 (size: 4, cast: variable(f32))
.field xw: float32 (size: 4, cast: variable(f32))
.field yx: float32 (size: 4, cast: variable(f32))
.field yy: float32 (size: 4, cast: variable(f32))
.field yz: float32 (size: 4, cast: variable(f32))
.field yw: float32 (size: 4, cast: variable(f32))
.field zx: float32 (size: 4, cast: variable(f32))
.field zy: float32 (size: 4, cast: variable(f32))
.field zz: float32 (size: 4, cast: variable(f32))
.field zw: float32 (size: 4, cast: variable(f32))
.field wx: float32 (size: 4, cast: variable(f32))
.field wy: float32 (size: 4, cast: variable(f32))
.field wz: float32 (size: 4, cast: variable(f32))
.field ww: float32 (size: 4, cast: variable(f32))
.usages:
}
mat4f.<?>.xx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f.<?>
.doc: 'The first element of the first row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:250: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:214: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:171: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:138: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xx`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xx`
}
mat4f.<?>.xy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f.<?>
.doc: 'The second element of the first row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:251: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:215: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:172: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:139: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `xy`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xy`
}
mat4f.<?>.xz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f.<?>
.doc: 'The third element of the first row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:252: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:216: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:173: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:140: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `xz`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xz`
}
mat4f.<?>.xw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f.<?>
.doc: 'The fourth element of the first row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:253: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:217: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:204: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:193: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:174: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:141: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `xw`
	cmplStd/lib/math/Matrix4f.ci:67: referenced as `xw`
}
mat4f.<?>.yx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f.<?>
.doc: 'The first element of the second row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:254: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:219: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:176: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:143: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `yx`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yx`
}
mat4f.<?>.yy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f.<?>
.doc: 'The second element of the second row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:255: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:220: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:177: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:144: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yy`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yy`
}
mat4f.<?>.yz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f.<?>
.doc: 'The third element of the second row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:256: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:221: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:178: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:145: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `yz`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yz`
}
mat4f.<?>.yw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f.<?>
.doc: 'The fourth element of the second row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:257: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:222: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:205: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:194: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:179: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:146: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `yw`
	cmplStd/lib/math/Matrix4f.ci:68: referenced as `yw`
}
mat4f.<?>.zx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f.<?>
.doc: 'The first element of the third row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:258: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:224: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:181: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:148: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `zx`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zx`
}
mat4f.<?>.zy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f.<?>
.doc: 'The second element of the third row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:259: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:225: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:182: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:149: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `zy`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zy`
}
mat4f.<?>.zz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f.<?>
.doc: 'The third element of the third row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:260: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:226: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:183: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:150: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zz`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zz`
}
mat4f.<?>.zw: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f.<?>
.doc: 'The fourth element of the third row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:261: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:227: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:206: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:195: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:184: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:151: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `zw`
	cmplStd/lib/math/Matrix4f.ci:69: referenced as `zw`
}
mat4f.<?>.wx: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f.<?>
.doc: 'The first element of the fourth row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:262: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:229: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:89: referenced as `wx`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wx`
}
mat4f.<?>.wy: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f.<?>
.doc: 'The second element of the fourth row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:263: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:230: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:90: referenced as `wy`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wy`
}
mat4f.<?>.wz: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f.<?>
.doc: 'The third element of the fourth row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:264: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:231: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:91: referenced as `wz`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `wz`
}
mat4f.<?>.ww: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f.<?>
.doc: 'The fourth element of the fourth row'
.usages:
	cmplStd/lib/math/Matrix4f.ci:265: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:232: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:207: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:196: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:92: referenced as `ww`
	cmplStd/lib/math/Matrix4f.ci:70: referenced as `ww`
}
mat4f.xx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xx'
.file: 'cmplStd/lib/math/Matrix4f.ci:24'
.owner: mat4f
.doc: 'The first element of the first row'
.value: xx: float32
}
mat4f.xy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xy'
.file: 'cmplStd/lib/math/Matrix4f.ci:26'
.owner: mat4f
.doc: 'The second element of the first row'
.value: xy: float32
}
mat4f.xz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xz'
.file: 'cmplStd/lib/math/Matrix4f.ci:28'
.owner: mat4f
.doc: 'The third element of the first row'
.value: xz: float32
}
mat4f.xw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'xw'
.file: 'cmplStd/lib/math/Matrix4f.ci:30'
.owner: mat4f
.doc: 'The fourth element of the first row'
.value: xw: float32
}
mat4f.yx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yx'
.file: 'cmplStd/lib/math/Matrix4f.ci:33'
.owner: mat4f
.doc: 'The first element of the second row'
.value: yx: float32
}
mat4f.yy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yy'
.file: 'cmplStd/lib/math/Matrix4f.ci:35'
.owner: mat4f
.doc: 'The second element of the second row'
.value: yy: float32
}
mat4f.yz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yz'
.file: 'cmplStd/lib/math/Matrix4f.ci:37'
.owner: mat4f
.doc: 'The third element of the second row'
.value: yz: float32
}
mat4f.yw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'yw'
.file: 'cmplStd/lib/math/Matrix4f.ci:39'
.owner: mat4f
.doc: 'The fourth element of the second row'
.value: yw: float32
}
mat4f.zx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zx'
.file: 'cmplStd/lib/math/Matrix4f.ci:42'
.owner: mat4f
.doc: 'The first element of the third row'
.value: zx: float32
}
mat4f.zy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zy'
.file: 'cmplStd/lib/math/Matrix4f.ci:44'
.owner: mat4f
.doc: 'The second element of the third row'
.value: zy: float32
}
mat4f.zz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zz'
.file: 'cmplStd/lib/math/Matrix4f.ci:46'
.owner: mat4f
.doc: 'The third element of the third row'
.value: zz: float32
}
mat4f.zw: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'zw'
.file: 'cmplStd/lib/math/Matrix4f.ci:48'
.owner: mat4f
.doc: 'The fourth element of the third row'
.value: zw: float32
}
mat4f.wx: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wx'
.file: 'cmplStd/lib/math/Matrix4f.ci:51'
.owner: mat4f
.doc: 'The first element of the fourth row'
.value: wx: float32
}
mat4f.wy: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wy'
.file: 'cmplStd/lib/math/Matrix4f.ci:53'
.owner: mat4f
.doc: 'The second element of the fourth row'
.value: wy: float32
}
mat4f.wz: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'wz'
.file: 'cmplStd/lib/math/Matrix4f.ci:55'
.owner: mat4f
.doc: 'The third element of the fourth row'
.value: wz: float32
}
mat4f.ww: float32 {
.kind: inline
.base: `float32`
.size: 0
.name: 'ww'
.file: 'cmplStd/lib/math/Matrix4f.ci:57'
.owner: mat4f
.doc: 'The fourth element of the fourth row'
.value: ww: float32
}
mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:62'
.param .result: mat4f (size: 64, cast: variable(val))
.param xx: float32 (size: 4, cast: variable(f32))
.param xy: float32 (size: 4, cast: variable(f32))
.param xz: float32 (size: 4, cast: variable(f32))
.param xw: float32 (size: 4, cast: variable(f32))
.param yx: float32 (size: 4, cast: variable(f32))
.param yy: float32 (size: 4, cast: variable(f32))
.param yz: float32 (size: 4, cast: variable(f32))
.param yw: float32 (size: 4, cast: variable(f32))
.param zx: float32 (size: 4, cast: variable(f32))
.param zy: float32 (size: 4, cast: variable(f32))
.param zz: float32 (size: 4, cast: variable(f32))
.param zw: float32 (size: 4, cast: variable(f32))
.param wx: float32 (size: 4, cast: variable(f32))
.param wy: float32 (size: 4, cast: variable(f32))
.param wz: float32 (size: 4, cast: variable(f32))
.param ww: float32 (size: 4, cast: variable(f32))
.doc: 'Initialize all elements with the given values'
.value: {
	return .result := {
			.result.xx := xx;
			.result.xy := xy;
			.result.xz := xz;
			.result.xw := xw;
			.result.yx := yx;
			.result.yy := yy;
			.result.yz := yz;
			.result.yw := yw;
			.result.zx := zx;
			.result.zy := zy;
			.result.zz := zz;
			.result.zw := zw;
			.result.wx := wx;
			.result.wy := wy;
			.result.wz := wz;
			.result.ww := ww;
		};
}
.instructions: (49 bytes)
	cmplStd/lib/math/Matrix4f.ci:66: (49 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xx := xx;
	<mat4f>  : mov.x32 sp(17, 16)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xy := xy;
	<mat4f+?>: mov.x32 sp(18, 15)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xz := xz;
	<mat4f+?>: mov.x32 sp(19, 14)
	cmplStd/lib/math/Matrix4f.ci:67: (3 bytes): .result.xw := xw;
	<mat4f+?>: mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yx := yx;
	<mat4f+?>: mov.x32 sp(21, 12)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yy := yy;
	<mat4f+?>: mov.x32 sp(22, 11)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yz := yz;
	<mat4f+?>: mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:68: (3 bytes): .result.yw := yw;
	<mat4f+?>: mov.x32 sp(24, 9)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zx := zx;
	<mat4f+?>: mov.x32 sp(25, 8)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zy := zy;
	<mat4f+?>: mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zz := zz;
	<mat4f+?>: mov.x32 sp(27, 6)
	cmplStd/lib/math/Matrix4f.ci:69: (3 bytes): .result.zw := zw;
	<mat4f+?>: mov.x32 sp(28, 5)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.wx := wx;
	<mat4f+?>: mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.wy := wy;
	<mat4f+?>: mov.x32 sp(30, 3)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.wz := wz;
	<mat4f+?>: mov.x32 sp(31, 2)
	cmplStd/lib/math/Matrix4f.ci:70: (3 bytes): .result.ww := ww;
	<mat4f+?>: mov.x32 sp(32, 1)
	<mat4f+?>: ret
.usages:
}
mat4f(x: vec4f, y: vec4f, z: vec4f, w: vec4f): mat4f: function {
.kind: static function
.base: `function`
.size: 21
.name: 'mat4f'
.file: 'cmplStd/lib/math/Matrix4f.ci:75'
.param .result: mat4f (size: 64, cast: variable(val))
.param x: vec4f (size: 4, cast: const variable(ref))
.param y: vec4f (size: 4, cast: const variable(ref))
.param z: vec4f (size: 4, cast: const variable(ref))
.param w: vec4f (size: 4, cast: const variable(ref))
.doc: 'Initialize matrix with row vectors'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
}
.instructions: (21 bytes)
	cmplStd/lib/math/Matrix4f.ci:76: (21 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.x := x;
	<mat4f>  : dup.x32 sp(4)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.y := y;
	<mat4f+?>: dup.x32 sp(3)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.z := z;
	<mat4f+?>: dup.x32 sp(2)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:76: (5 bytes): .result.w := w;
	<mat4f+?>: dup.x32 sp(1)
	<mat4f+?>: load.i128
	<mat4f+?>: set.x128 sp(21)
	<mat4f+?>: ret
.usages:
}
dp3(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp3'
.file: 'cmplStd/lib/math/Matrix4f.ci:80'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: dot product of the first 3 elements'
.value: vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000)
.usages:
}
dph(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dph'
.file: 'cmplStd/lib/math/Matrix4f.ci:82'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: homogeneous dot product'
.value: vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec))
.usages:
}
dp4(mat: mat4f, vec: vec4f): vec4f: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dp4'
.file: 'cmplStd/lib/math/Matrix4f.ci:84'
.param .result: vec4f (size: 16, cast: val)
.param mat: mat4f (size: 4, cast: const variable(ref))
.param vec: vec4f (size: 4, cast: const variable(ref))
.doc: 'Multiply with vector: full dot product'
.value: vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec))
.usages:
	cmplStd/lib/math/Matrix4f.ci:103: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:102: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:101: referenced as `dp4`
	cmplStd/lib/math/Matrix4f.ci:100: referenced as `dp4`
}
transpose(mat: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 49
.name: 'transpose'
.file: 'cmplStd/lib/math/Matrix4f.ci:87'
.param .result: mat4f (size: 64, cast: variable(val))
.param mat: mat4f (size: 64, cast: const variable(val))
.doc: 'Transpose the matrix'
.value: {
	return .result := {
			.result.xx := mat.xx;
			.result.xy := mat.yx;
			.result.xz := mat.zx;
			.result.xw := mat.wx;
			.result.yx := mat.xy;
			.result.yy := mat.yy;
			.result.yz := mat.zy;
			.result.yw := mat.wy;
			.result.zx := mat.xz;
			.result.zy := mat.yz;
			.result.zz := mat.zz;
			.result.zw := mat.wz;
			.result.wx := mat.xw;
			.result.wy := mat.yw;
			.result.wz := mat.zw;
			.result.ww := mat.ww;
		};
}
.instructions: (49 bytes)
	cmplStd/lib/math/Matrix4f.ci:88: (49 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xx := mat.xx;
	<transpose>  : mov.x32 sp(17, 1)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xy := mat.yx;
	<transpose+?>: mov.x32 sp(18, 5)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xz := mat.zx;
	<transpose+?>: mov.x32 sp(19, 9)
	cmplStd/lib/math/Matrix4f.ci:89: (3 bytes): .result.xw := mat.wx;
	<transpose+?>: mov.x32 sp(20, 13)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yx := mat.xy;
	<transpose+?>: mov.x32 sp(21, 2)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yy := mat.yy;
	<transpose+?>: mov.x32 sp(22, 6)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yz := mat.zy;
	<transpose+?>: mov.x32 sp(23, 10)
	cmplStd/lib/math/Matrix4f.ci:90: (3 bytes): .result.yw := mat.wy;
	<transpose+?>: mov.x32 sp(24, 14)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zx := mat.xz;
	<transpose+?>: mov.x32 sp(25, 3)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zy := mat.yz;
	<transpose+?>: mov.x32 sp(26, 7)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zz := mat.zz;
	<transpose+?>: mov.x32 sp(27, 11)
	cmplStd/lib/math/Matrix4f.ci:91: (3 bytes): .result.zw := mat.wz;
	<transpose+?>: mov.x32 sp(28, 15)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.wx := mat.xw;
	<transpose+?>: mov.x32 sp(29, 4)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.wy := mat.yw;
	<transpose+?>: mov.x32 sp(30, 8)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.wz := mat.zw;
	<transpose+?>: mov.x32 sp(31, 12)
	cmplStd/lib/math/Matrix4f.ci:92: (3 bytes): .result.ww := mat.ww;
	<transpose+?>: mov.x32 sp(32, 16)
	<transpose+?>: ret
.usages:
	cmplStd/lib/math/Matrix4f.ci:98: referenced as `transpose`
}
mul(lhs: mat4f, rhs: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 265
.name: 'mul'
.file: 'cmplStd/lib/math/Matrix4f.ci:97'
.param .result: mat4f (size: 64, cast: variable(val))
.param lhs: mat4f (size: 4, cast: const variable(ref))
.param rhs: mat4f (size: 4, cast: const variable(ref))
.doc: 'Multiply two matrices (rows * cols)'
.value: {
	transposed: mat4f := transpose(rhs);
	return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
}
.instructions: (265 bytes)
	cmplStd/lib/math/Matrix4f.ci:98: (28 bytes): transposed: mat4f := transpose(rhs)
	<mul>  : inc.sp(+64)
	<mul+?>: dup.x32 sp(17)
	<mul+?>: load.sp(-60)
	<mul+?>: copy.mem -64
	<mul+?>: inc.sp(+64)
	<mul+?>: load.ref <?> ;transpose(mat: mat4f): mat4f
	<mul+?>: call
	<mul+?>: inc.sp(-64)
	cmplStd/lib/math/Matrix4f.ci:99: (237 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:100: (55 bytes): .result.x := dp4(transposed, lhs.x);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: mov.x128 sp(2, 0)
	<mul+?>: inc.sp(-8)
	<mul+?>: set.x128 sp(23)
	cmplStd/lib/math/Matrix4f.ci:101: (59 bytes): .result.y := dp4(transposed, lhs.y);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+16)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: mov.x128 sp(2, 0)
	<mul+?>: inc.sp(-8)
	<mul+?>: set.x128 sp(27)
	cmplStd/lib/math/Matrix4f.ci:102: (59 bytes): .result.z := dp4(transposed, lhs.z);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+32)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: mov.x128 sp(2, 0)
	<mul+?>: inc.sp(-8)
	<mul+?>: set.x128 sp(31)
	cmplStd/lib/math/Matrix4f.ci:103: (59 bytes): .result.w := dp4(transposed, lhs.w);
	<mul+?>: load.sp(+0)
	<mul+?>: dup.x32 sp(19)
	<mul+?>: inc.i32(+48)
	<mul+?>: dup.x32 sp(1)
	<mul+?>: inc.i32(+48)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+32)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(5)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(3)
	<mul+?>: inc.i32(+16)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: dup.x32 sp(4)
	<mul+?>: load.i128
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.i128
	<mul+?>: dp4.v4f
	<mul+?>: mov.x128 sp(2, 0)
	<mul+?>: inc.sp(-8)
	<mul+?>: set.x128 sp(35)
	<mul+?>: inc.sp(-64)
	<mul+?>: ret
.usages:
}
rotation(center: vec4f, direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 491
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:109'
.param .result: mat4f (size: 64, cast: variable(val))
.param center: vec4f (size: 4, cast: const variable(ref))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param angle: float32 (size: 4, cast: variable(f32))
.doc: 'Build a rotation matrix'
.value: {
	len: float32 := length(direction);
	if ((len) < 0.000000) {
		trace("invalid direction of rotation", direction);
		return .result := {
			.result.x := vec4f(0, 0, 0, 0);
			.result.y := vec4f(0, 0, 0, 0);
			.result.z := vec4f(0, 0, 0, 0);
			.result.w := vec4f(0, 0, 0, 0);
		};
	}
	x: float32 := direction.x / len;
	y: float32 := direction.y / len;
	z: float32 := direction.z / len;
	cx: float32 := center.x;
	cy: float32 := center.y;
	cz: float32 := center.z;
	xx: float32 := x * x;
	xy: float32 := x * y;
	xz: float32 := x * z;
	yy: float32 := y * y;
	yz: float32 := y * z;
	zz: float32 := z * z;
	s: float32 := Math.sin(angle);
	c: float32 := Math.cos(angle);
	k: float32 := (1) - c;
	return .result := {
			.result.xx := xx + (yy + zz) * c;
			.result.xy := xy * k - z * s;
			.result.xz := xz * k + y * s;
			.result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
			.result.yx := xy * k + z * s;
			.result.yy := yy + (xx + zz) * c;
			.result.yz := yz * k - x * s;
			.result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
			.result.zx := xz * k - y * s;
			.result.zy := yz * k + x * s;
			.result.zz := zz + (xx + yy) * c;
			.result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
			.result.w := vec4f(0, 0, 0, 1);
		};
}
.instructions: (491 bytes)
	cmplStd/lib/math/Matrix4f.ci:110: (26 bytes): len: float32 := length(direction)
	<rotation>  : dup.x32 sp(2)
	<rotation+?>: load.i128
	<rotation+?>: load.z32
	<rotation+?>: dup.x128 sp(1)
	<rotation+?>: dup.x128 sp(5)
	<rotation+?>: dp3.v4f
	<rotation+?>: load.ref <?> ;Math.sqrt(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	<rotation+?>: mov.x32 sp(4, 0)
	<rotation+?>: inc.sp(-16)
	cmplStd/lib/math/Matrix4f.ci:111: (97 bytes): if ((len) < 0.000000)
	<rotation+?>: dup.x32 sp(0)
	<rotation+?>: f32.2f64
	<rotation+?>: load.f64 0.000000
	<rotation+?>: clt.f64
	<rotation+?>: jz +84
	cmplStd/lib/math/Matrix4f.ci:112: (51 bytes): trace("invalid direction of rotation", direction);
	<rotation+?>: load.ref <?> ;vec4f
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: load.c32 1
	<rotation+?>: load.sp(+4)
	<rotation+?>: load.ref <?> ;"cmplStd/lib/math/Matrix4f.ci"
	<rotation+?>: load.c32 112
	<rotation+?>: load.c32 14
	<rotation+?>: load.c32 128
	<rotation+?>: load.ref <?> ;"invalid direction of rotation"
	<rotation+?>: dup.x64 sp(5)
	<rotation+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<rotation+?>: inc.sp(-16)
	cmplStd/lib/math/Matrix4f.ci:113: (29 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:114: (6 bytes): .result.x := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(9)
	cmplStd/lib/math/Matrix4f.ci:115: (6 bytes): .result.y := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(13)
	cmplStd/lib/math/Matrix4f.ci:116: (6 bytes): .result.z := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(17)
	cmplStd/lib/math/Matrix4f.ci:117: (6 bytes): .result.w := vec4f(0, 0, 0, 0);
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(21)
	<rotation+?>: inc.sp(-4)
	<rotation+?>: ret
	cmplStd/lib/math/Matrix4f.ci:120: (6 bytes): x: float32 := direction.x / len
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: div.f32
	cmplStd/lib/math/Matrix4f.ci:121: (10 bytes): y: float32 := direction.y / len
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: div.f32
	cmplStd/lib/math/Matrix4f.ci:122: (10 bytes): z: float32 := direction.z / len
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: div.f32
	cmplStd/lib/math/Matrix4f.ci:123: (3 bytes): cx: float32 := center.x
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:124: (7 bytes): cy: float32 := center.y
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:125: (7 bytes): cz: float32 := center.z
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:126: (5 bytes): xx: float32 := x * x
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:127: (5 bytes): xy: float32 := x * y
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:128: (5 bytes): xz: float32 := x * z
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:129: (5 bytes): yy: float32 := y * y
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:130: (5 bytes): yz: float32 := y * z
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:131: (5 bytes): zz: float32 := z * z
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:133: (13 bytes): s: float32 := Math.sin(angle)
	<rotation+?>: load.z32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: load.ref <?> ;Math.sin(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	cmplStd/lib/math/Matrix4f.ci:134: (13 bytes): c: float32 := Math.cos(angle)
	<rotation+?>: load.z32
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: load.ref <?> ;Math.cos(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	cmplStd/lib/math/Matrix4f.ci:135: (8 bytes): k: float32 := (1) - c
	<rotation+?>: load.f32 1.000000
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:137: (261 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:138: (13 bytes): .result.xx := xx + (yy + zz) * c;
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:139: (13 bytes): .result.xy := xy * k - z * s;
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:140: (13 bytes): .result.xz := xz * k + y * s;
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:141: (43 bytes): .result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:143: (13 bytes): .result.yx := xy * k + z * s;
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:144: (13 bytes): .result.yy := yy + (xx + zz) * c;
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:145: (13 bytes): .result.yz := yz * k - x * s;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:146: (43 bytes): .result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: dup.x32 sp(16)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:148: (13 bytes): .result.zx := xz * k - y * s;
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(14)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(29)
	cmplStd/lib/math/Matrix4f.ci:149: (13 bytes): .result.zy := yz * k + x * s;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(30)
	cmplStd/lib/math/Matrix4f.ci:150: (13 bytes): .result.zz := zz + (xx + yy) * c;
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: add.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(31)
	cmplStd/lib/math/Matrix4f.ci:151: (43 bytes): .result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(15)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: dup.x32 sp(17)
	<rotation+?>: mul.f32
	<rotation+?>: sub.f32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: mul.f32
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(32)
	cmplStd/lib/math/Matrix4f.ci:153: (10 bytes): .result.w := vec4f(0, 0, 0, 1);
	<rotation+?>: load.f32 1.000000
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(36)
	<rotation+?>: inc.sp(-64)
	<rotation+?>: ret
.usages:
}
rotation(direction: vec4f, angle: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 243
.name: 'rotation'
.file: 'cmplStd/lib/math/Matrix4f.ci:158'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param angle: float32 (size: 4, cast: variable(f32))
.doc: 'Build a rotation matrix'
.value: {
	xx: float32 := direction.x * direction.x;
	yy: float32 := direction.y * direction.y;
	zz: float32 := direction.z * direction.z;
	xy: float32 := direction.x * direction.y;
	xz: float32 := direction.x * direction.z;
	yz: float32 := direction.y * direction.z;
	s: float32 := Math.sin(angle);
	c: float32 := Math.cos(angle);
	k: float32 := (1) - c;
	tmp: vec4f := mul(direction, s);
	return .result := {
			.result.xx := k * xx + c;
			.result.xy := k * xy - tmp.z;
			.result.xz := k * xz + tmp.y;
			.result.xw := (0);
			.result.yx := k * xy + tmp.z;
			.result.yy := k * yy + c;
			.result.yz := k * yz - tmp.x;
			.result.yw := (0);
			.result.zx := k * xz - tmp.y;
			.result.zy := k * yz + tmp.x;
			.result.zz := k * zz + c;
			.result.zw := (0);
			.result.w := vec4f(0, 0, 0, 1);
		};
}
.instructions: (243 bytes)
	cmplStd/lib/math/Matrix4f.ci:159: (7 bytes): xx: float32 := direction.x * direction.x
	<rotation>  : dup.x32 sp(2)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:160: (15 bytes): yy: float32 := direction.y * direction.y
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:161: (15 bytes): zz: float32 := direction.z * direction.z
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:162: (11 bytes): xy: float32 := direction.x * direction.y
	<rotation+?>: dup.x32 sp(5)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:163: (11 bytes): xz: float32 := direction.x * direction.z
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:164: (15 bytes): yz: float32 := direction.y * direction.z
	<rotation+?>: dup.x32 sp(7)
	<rotation+?>: inc.i32(+4)
	<rotation+?>: load.i32
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: inc.i32(+8)
	<rotation+?>: load.i32
	<rotation+?>: mul.f32
	cmplStd/lib/math/Matrix4f.ci:165: (13 bytes): s: float32 := Math.sin(angle)
	<rotation+?>: load.z32
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: load.ref <?> ;Math.sin(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	cmplStd/lib/math/Matrix4f.ci:166: (13 bytes): c: float32 := Math.cos(angle)
	<rotation+?>: load.z32
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: load.ref <?> ;Math.cos(x: float32): float32
	<rotation+?>: call
	<rotation+?>: inc.sp(-4)
	cmplStd/lib/math/Matrix4f.ci:167: (8 bytes): k: float32 := (1) - c
	<rotation+?>: load.f32 1.000000
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:168: (21 bytes): tmp: vec4f := mul(direction, s)
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: load.i128
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: dup.x32 sp(0)
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: mov.x128 sp(1, 0)
	<rotation+?>: inc.sp(-4)
	<rotation+?>: mul.v4f
	cmplStd/lib/math/Matrix4f.ci:170: (114 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:171: (10 bytes): .result.xx := k * xx + c;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(13)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:172: (10 bytes): .result.xy := k * xy - tmp.z;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:173: (10 bytes): .result.xz := k * xz + tmp.y;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(19)
	cmplStd/lib/math/Matrix4f.ci:174: (3 bytes): .result.xw := (0);
	<rotation+?>: load.z32
	<rotation+?>: set.x32 sp(20)
	cmplStd/lib/math/Matrix4f.ci:176: (10 bytes): .result.yx := k * xy + tmp.z;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(10)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(3)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(21)
	cmplStd/lib/math/Matrix4f.ci:177: (10 bytes): .result.yy := k * yy + c;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(12)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(22)
	cmplStd/lib/math/Matrix4f.ci:178: (10 bytes): .result.yz := k * yz - tmp.x;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(23)
	cmplStd/lib/math/Matrix4f.ci:179: (3 bytes): .result.yw := (0);
	<rotation+?>: load.z32
	<rotation+?>: set.x32 sp(24)
	cmplStd/lib/math/Matrix4f.ci:181: (10 bytes): .result.zx := k * xz - tmp.y;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(9)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(2)
	<rotation+?>: sub.f32
	<rotation+?>: set.x32 sp(25)
	cmplStd/lib/math/Matrix4f.ci:182: (10 bytes): .result.zy := k * yz + tmp.x;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(8)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(1)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(26)
	cmplStd/lib/math/Matrix4f.ci:183: (10 bytes): .result.zz := k * zz + c;
	<rotation+?>: dup.x32 sp(4)
	<rotation+?>: dup.x32 sp(11)
	<rotation+?>: mul.f32
	<rotation+?>: dup.x32 sp(6)
	<rotation+?>: add.f32
	<rotation+?>: set.x32 sp(27)
	cmplStd/lib/math/Matrix4f.ci:184: (3 bytes): .result.zw := (0);
	<rotation+?>: load.z32
	<rotation+?>: set.x32 sp(28)
	cmplStd/lib/math/Matrix4f.ci:186: (10 bytes): .result.w := vec4f(0, 0, 0, 1);
	<rotation+?>: load.f32 1.000000
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: load.z32
	<rotation+?>: set.x128 sp(32)
	<rotation+?>: inc.sp(-52)
	<rotation+?>: ret
.usages:
}
translation(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 88
.name: 'translation'
.file: 'cmplStd/lib/math/Matrix4f.ci:191'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Build a translation matrix'
.value: {
	return .result := {
			.result.xx := (1);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := direction.x * amount;
			.result.yx := (0);
			.result.yy := (1);
			.result.yz := (0);
			.result.yw := direction.y * amount;
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := (1);
			.result.zw := direction.z * amount;
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
}
.instructions: (88 bytes)
	cmplStd/lib/math/Matrix4f.ci:192: (88 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:193: (7 bytes): .result.xx := (1);
	<translation>  : load.f32 1.000000
	<translation+?>: set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:193: (3 bytes): .result.xy := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:193: (3 bytes): .result.xz := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:193: (8 bytes): .result.xw := direction.x * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:194: (3 bytes): .result.yx := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:194: (7 bytes): .result.yy := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:194: (3 bytes): .result.yz := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:194: (12 bytes): .result.yw := direction.y * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: inc.i32(+4)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:195: (3 bytes): .result.zx := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:195: (3 bytes): .result.zy := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:195: (7 bytes): .result.zz := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:195: (12 bytes): .result.zw := direction.z * amount;
	<translation+?>: dup.x32 sp(2)
	<translation+?>: inc.i32(+8)
	<translation+?>: load.i32
	<translation+?>: dup.x32 sp(2)
	<translation+?>: mul.f32
	<translation+?>: set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:196: (3 bytes): .result.wx := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:196: (3 bytes): .result.wy := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:196: (3 bytes): .result.wz := (0);
	<translation+?>: load.z32
	<translation+?>: set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:196: (7 bytes): .result.ww := (1);
	<translation+?>: load.f32 1.000000
	<translation+?>: set.x32 sp(19)
	<translation+?>: ret
.usages:
}
scale(direction: vec4f, amount: float32): mat4f: function {
.kind: static function
.base: `function`
.size: 217
.name: 'scale'
.file: 'cmplStd/lib/math/Matrix4f.ci:201'
.param .result: mat4f (size: 64, cast: variable(val))
.param direction: vec4f (size: 4, cast: const variable(ref))
.param amount: float32 (size: 4, cast: variable(f32))
.doc: 'Build a scaling matrix'
.value: {
	rcp(val: float32): float32 := ((val < (0) ? -val : val)) < 0.000000 ? (0) : (1) / val;
	return .result := {
			.result.xx := rcp(direction.x * amount);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := (0);
			.result.yx := (0);
			.result.yy := rcp(direction.y * amount);
			.result.yz := (0);
			.result.yw := (0);
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := rcp(direction.z * amount);
			.result.zw := (0);
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
}
.instructions: (217 bytes)
	cmplStd/lib/math/Matrix4f.ci:203: (217 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:204: (55 bytes): .result.xx := rcp(direction.x * amount);
	<scale>  : dup.x32 sp(2)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(4)
	cmplStd/lib/math/Matrix4f.ci:204: (3 bytes): .result.xy := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(5)
	cmplStd/lib/math/Matrix4f.ci:204: (3 bytes): .result.xz := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(6)
	cmplStd/lib/math/Matrix4f.ci:204: (3 bytes): .result.xw := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(7)
	cmplStd/lib/math/Matrix4f.ci:205: (3 bytes): .result.yx := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(8)
	cmplStd/lib/math/Matrix4f.ci:205: (59 bytes): .result.yy := rcp(direction.y * amount);
	<scale+?>: dup.x32 sp(2)
	<scale+?>: inc.i32(+4)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(9)
	cmplStd/lib/math/Matrix4f.ci:205: (3 bytes): .result.yz := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(10)
	cmplStd/lib/math/Matrix4f.ci:205: (3 bytes): .result.yw := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(11)
	cmplStd/lib/math/Matrix4f.ci:206: (3 bytes): .result.zx := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(12)
	cmplStd/lib/math/Matrix4f.ci:206: (3 bytes): .result.zy := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(13)
	cmplStd/lib/math/Matrix4f.ci:206: (59 bytes): .result.zz := rcp(direction.z * amount);
	<scale+?>: dup.x32 sp(2)
	<scale+?>: inc.i32(+8)
	<scale+?>: load.i32
	<scale+?>: dup.x32 sp(2)
	<scale+?>: mul.f32
	<scale+?>: dup.x32 sp(0)
	<scale+?>: load.z32
	<scale+?>: clt.f32
	<scale+?>: jz +11
	<scale+?>: dup.x32 sp(0)
	<scale+?>: neg.f32
	<scale+?>: jmp +6
	<scale+?>: dup.x32 sp(0)
	<scale+?>: f32.2f64
	<scale+?>: load.f64 0.000000
	<scale+?>: clt.f64
	<scale+?>: jz +9
	<scale+?>: load.z32
	<scale+?>: jmp +12
	<scale+?>: load.f32 1.000000
	<scale+?>: dup.x32 sp(1)
	<scale+?>: div.f32
	<scale+?>: set.x32 sp(1)
	<scale+?>: set.x32 sp(14)
	cmplStd/lib/math/Matrix4f.ci:206: (3 bytes): .result.zw := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(15)
	cmplStd/lib/math/Matrix4f.ci:207: (3 bytes): .result.wx := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(16)
	cmplStd/lib/math/Matrix4f.ci:207: (3 bytes): .result.wy := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(17)
	cmplStd/lib/math/Matrix4f.ci:207: (3 bytes): .result.wz := (0);
	<scale+?>: load.z32
	<scale+?>: set.x32 sp(18)
	cmplStd/lib/math/Matrix4f.ci:207: (7 bytes): .result.ww := (1);
	<scale+?>: load.f32 1.000000
	<scale+?>: set.x32 sp(19)
	<scale+?>: ret
.usages:
}
inverse(mat: mat4f): mat4f: function {
.kind: static function
.base: `function`
.size: 632
.name: 'inverse'
.file: 'cmplStd/lib/math/Matrix4f.ci:213'
.param .result: mat4f (size: 64, cast: variable(val))
.param mat: mat4f (size: 4, cast: const variable(ref))
.doc: 'Build the inverse of the matrix'
.value: {
	a00: float32 := mat.xx;
	a01: float32 := mat.xy;
	a02: float32 := mat.xz;
	a03: float32 := mat.xw;
	a10: float32 := mat.yx;
	a11: float32 := mat.yy;
	a12: float32 := mat.yz;
	a13: float32 := mat.yw;
	a20: float32 := mat.zx;
	a21: float32 := mat.zy;
	a22: float32 := mat.zz;
	a23: float32 := mat.zw;
	a30: float32 := mat.wx;
	a31: float32 := mat.wy;
	a32: float32 := mat.wz;
	a33: float32 := mat.ww;
	b00: float32 := a00 * a11 - a01 * a10;
	b01: float32 := a00 * a12 - a02 * a10;
	b02: float32 := a00 * a13 - a03 * a10;
	b03: float32 := a01 * a12 - a02 * a11;
	b04: float32 := a01 * a13 - a03 * a11;
	b05: float32 := a02 * a13 - a03 * a12;
	b06: float32 := a20 * a31 - a21 * a30;
	b07: float32 := a20 * a32 - a22 * a30;
	b08: float32 := a20 * a33 - a23 * a30;
	b09: float32 := a21 * a32 - a22 * a31;
	b10: float32 := a21 * a33 - a23 * a31;
	b11: float32 := a22 * a33 - a23 * a32;
	det: float32 := b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	return .result := {
			.result.xx := (a11 * b11 - a12 * b10 + a13 * b09) / det;
			.result.xy := (a02 * b10 - a01 * b11 - a03 * b09) / det;
			.result.xz := (a31 * b05 - a32 * b04 + a33 * b03) / det;
			.result.xw := (a22 * b04 - a21 * b05 - a23 * b03) / det;
			.result.yx := (a12 * b08 - a10 * b11 - a13 * b07) / det;
			.result.yy := (a00 * b11 - a02 * b08 + a03 * b07) / det;
			.result.yz := (a32 * b02 - a30 * b05 - a33 * b01) / det;
			.result.yw := (a20 * b05 - a22 * b02 + a23 * b01) / det;
			.result.zx := (a10 * b10 - a11 * b08 + a13 * b06) / det;
			.result.zy := (a01 * b08 - a00 * b10 - a03 * b06) / det;
			.result.zz := (a30 * b04 - a31 * b02 + a33 * b00) / det;
			.result.zw := (a21 * b02 - a20 * b04 - a23 * b00) / det;
			.result.wx := (a11 * b07 - a10 * b09 - a12 * b06) / det;
			.result.wy := (a00 * b09 - a01 * b07 + a02 * b06) / det;
			.result.wz := (a31 * b01 - a30 * b03 - a32 * b00) / det;
			.result.ww := (a20 * b03 - a21 * b01 + a22 * b00) / det;
		};
}
.instructions: (632 bytes)
	cmplStd/lib/math/Matrix4f.ci:214: (3 bytes): a00: float32 := mat.xx
	<inverse>  : dup.x32 sp(1)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:215: (7 bytes): a01: float32 := mat.xy
	<inverse+?>: dup.x32 sp(2)
	<inverse+?>: inc.i32(+4)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:216: (7 bytes): a02: float32 := mat.xz
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: inc.i32(+8)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:217: (7 bytes): a03: float32 := mat.xw
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: inc.i32(+12)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:219: (7 bytes): a10: float32 := mat.yx
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: inc.i32(+16)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:220: (7 bytes): a11: float32 := mat.yy
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: inc.i32(+20)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:221: (7 bytes): a12: float32 := mat.yz
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: inc.i32(+24)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:222: (7 bytes): a13: float32 := mat.yw
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: inc.i32(+28)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:224: (7 bytes): a20: float32 := mat.zx
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: inc.i32(+32)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:225: (7 bytes): a21: float32 := mat.zy
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: inc.i32(+36)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:226: (7 bytes): a22: float32 := mat.zz
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: inc.i32(+40)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:227: (7 bytes): a23: float32 := mat.zw
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: inc.i32(+44)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:229: (7 bytes): a30: float32 := mat.wx
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: inc.i32(+48)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:230: (7 bytes): a31: float32 := mat.wy
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: inc.i32(+52)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:231: (7 bytes): a32: float32 := mat.wz
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: inc.i32(+56)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:232: (7 bytes): a33: float32 := mat.ww
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: inc.i32(+60)
	<inverse+?>: load.i32
	cmplStd/lib/math/Matrix4f.ci:234: (11 bytes): b00: float32 := a00 * a11 - a01 * a10
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:235: (11 bytes): b01: float32 := a00 * a12 - a02 * a10
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:236: (11 bytes): b02: float32 := a00 * a13 - a03 * a10
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:237: (11 bytes): b03: float32 := a01 * a12 - a02 * a11
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:238: (11 bytes): b04: float32 := a01 * a13 - a03 * a11
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:239: (11 bytes): b05: float32 := a02 * a13 - a03 * a12
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:240: (11 bytes): b06: float32 := a20 * a31 - a21 * a30
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:241: (11 bytes): b07: float32 := a20 * a32 - a22 * a30
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:242: (11 bytes): b08: float32 := a20 * a33 - a23 * a30
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:243: (11 bytes): b09: float32 := a21 * a32 - a22 * a31
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:244: (11 bytes): b10: float32 := a21 * a33 - a23 * a31
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:245: (11 bytes): b11: float32 := a22 * a33 - a23 * a32
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	cmplStd/lib/math/Matrix4f.ci:247: (35 bytes): det: float32 := b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	cmplStd/lib/math/Matrix4f.ci:249: (357 bytes): return .result := {...};
	cmplStd/lib/math/Matrix4f.ci:250: (22 bytes): .result.xx := (a11 * b11 - a12 * b10 + a13 * b09) / det;
	<inverse+?>: dup.x32 sp(23)
	<inverse+?>: dup.x32 sp(2)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(23)
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(22)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(32)
	cmplStd/lib/math/Matrix4f.ci:251: (22 bytes): .result.xy := (a02 * b10 - a01 * b11 - a03 * b09) / det;
	<inverse+?>: dup.x32 sp(26)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(28)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(26)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(33)
	cmplStd/lib/math/Matrix4f.ci:252: (22 bytes): .result.xz := (a31 * b05 - a32 * b04 + a33 * b03) / det;
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(34)
	cmplStd/lib/math/Matrix4f.ci:253: (22 bytes): .result.xw := (a22 * b04 - a21 * b05 - a23 * b03) / det;
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(20)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(35)
	cmplStd/lib/math/Matrix4f.ci:254: (22 bytes): .result.yx := (a12 * b08 - a10 * b11 - a13 * b07) / det;
	<inverse+?>: dup.x32 sp(22)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(25)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(22)
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(36)
	cmplStd/lib/math/Matrix4f.ci:255: (22 bytes): .result.yy := (a00 * b11 - a02 * b08 + a03 * b07) / det;
	<inverse+?>: dup.x32 sp(28)
	<inverse+?>: dup.x32 sp(2)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(27)
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(26)
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(37)
	cmplStd/lib/math/Matrix4f.ci:256: (22 bytes): .result.yz := (a32 * b02 - a30 * b05 - a33 * b01) / det;
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(38)
	cmplStd/lib/math/Matrix4f.ci:257: (22 bytes): .result.yw := (a20 * b05 - a22 * b02 + a23 * b01) / det;
	<inverse+?>: dup.x32 sp(20)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(19)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(39)
	cmplStd/lib/math/Matrix4f.ci:258: (22 bytes): .result.zx := (a10 * b10 - a11 * b08 + a13 * b06) / det;
	<inverse+?>: dup.x32 sp(24)
	<inverse+?>: dup.x32 sp(3)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(24)
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(22)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(40)
	cmplStd/lib/math/Matrix4f.ci:259: (22 bytes): .result.zy := (a01 * b08 - a00 * b10 - a03 * b06) / det;
	<inverse+?>: dup.x32 sp(27)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(29)
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(26)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(41)
	cmplStd/lib/math/Matrix4f.ci:260: (22 bytes): .result.zz := (a30 * b04 - a31 * b02 + a33 * b00) / det;
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(9)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(16)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(42)
	cmplStd/lib/math/Matrix4f.ci:261: (22 bytes): .result.zw := (a21 * b02 - a20 * b04 - a23 * b00) / det;
	<inverse+?>: dup.x32 sp(19)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(21)
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(18)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(43)
	cmplStd/lib/math/Matrix4f.ci:262: (22 bytes): .result.wx := (a11 * b07 - a10 * b09 - a12 * b06) / det;
	<inverse+?>: dup.x32 sp(23)
	<inverse+?>: dup.x32 sp(6)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(25)
	<inverse+?>: dup.x32 sp(5)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(23)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(44)
	cmplStd/lib/math/Matrix4f.ci:263: (22 bytes): .result.wy := (a00 * b09 - a01 * b07 + a02 * b06) / det;
	<inverse+?>: dup.x32 sp(28)
	<inverse+?>: dup.x32 sp(4)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(28)
	<inverse+?>: dup.x32 sp(7)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(27)
	<inverse+?>: dup.x32 sp(8)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(45)
	cmplStd/lib/math/Matrix4f.ci:264: (22 bytes): .result.wz := (a31 * b01 - a30 * b03 - a32 * b00) / det;
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(12)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(17)
	<inverse+?>: dup.x32 sp(11)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(15)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(46)
	cmplStd/lib/math/Matrix4f.ci:265: (22 bytes): .result.ww := (a20 * b03 - a21 * b01 + a22 * b00) / det;
	<inverse+?>: dup.x32 sp(20)
	<inverse+?>: dup.x32 sp(10)
	<inverse+?>: mul.f32
	<inverse+?>: dup.x32 sp(20)
	<inverse+?>: dup.x32 sp(13)
	<inverse+?>: mul.f32
	<inverse+?>: sub.f32
	<inverse+?>: dup.x32 sp(19)
	<inverse+?>: dup.x32 sp(14)
	<inverse+?>: mul.f32
	<inverse+?>: add.f32
	<inverse+?>: dup.x32 sp(1)
	<inverse+?>: div.f32
	<inverse+?>: set.x32 sp(47)
	<inverse+?>: inc.sp(-116)
	<inverse+?>: ret
.usages:
}
vec2d: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:2'
.field <?>: vec2d.<?> (size: 16, cast: variable(val))
.field x: float64 (size: 0, cast: inline)
.field y: float64 (size: 0, cast: inline)
.field data: float64[2] (size: 16, cast: variable(val))
.doc: 'A 2d vector (2x float64)'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:40: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:37: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:34: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:31: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:28: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:25: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:22: referenced as `vec2d`
	cmplStd/lib/math/Vector2d.ci:14: referenced as `vec2d`
}
vec2d.<?>: vec2d.<?> {
.kind: variable(val)
.base: `vec2d.<?>`
.size: 16
.name: '<?>'
.file: 'cmplStd/lib/math/Vector2d.ci:44'
.owner: vec2d
.field x: float64 (size: 8, cast: variable(f64))
.field y: float64 (size: 8, cast: variable(f64))
.usages:
}
vec2d.<?>.x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d.<?>
.doc: 'X component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `x`
	cmplStd/lib/math/Vector2d.ci:16: referenced as `x`
}
vec2d.<?>.y: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d.<?>
.doc: 'Y component of the vector'
.usages:
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:43: referenced as `y`
	cmplStd/lib/math/Vector2d.ci:17: referenced as `y`
}
vec2d.x: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'x'
.file: 'cmplStd/lib/math/Vector2d.ci:5'
.owner: vec2d
.doc: 'X component of the vector'
.value: x: float64
}
vec2d.y: float64 {
.kind: inline
.base: `float64`
.size: 0
.name: 'y'
.file: 'cmplStd/lib/math/Vector2d.ci:7'
.owner: vec2d
.doc: 'Y component of the vector'
.value: y: float64
}
vec2d.data: float64[2] {
.kind: variable(val)
.base: `float64[2]`
.size: 16
.name: 'data'
.file: 'cmplStd/lib/math/Vector2d.ci:10'
.owner: vec2d
.doc: 'Access the components as an array'
.usages:
}
vec2d(x: float64, y: float64): vec2d: function {
.kind: static function
.base: `function`
.size: 7
.name: 'vec2d'
.file: 'cmplStd/lib/math/Vector2d.ci:14'
.param .result: vec2d (size: 16, cast: variable(val))
.param x: float64 (size: 8, cast: variable(f64))
.param y: float64 (size: 8, cast: variable(f64))
.doc: 'Initialize with given x, y components'
.value: {
	return .result := {
			.result.x := x;
			.result.y := y;
		};
}
.instructions: (7 bytes)
	cmplStd/lib/math/Vector2d.ci:15: (7 bytes): return .result := {...};
	cmplStd/lib/math/Vector2d.ci:16: (3 bytes): .result.x := x;
	<vec2d>  : mov.x64 sp(5, 3)
	cmplStd/lib/math/Vector2d.ci:17: (3 bytes): .result.y := y;
	<vec2d+?>: mov.x64 sp(7, 1)
	<vec2d+?>: ret
.usages:
}
add(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'add'
.file: 'cmplStd/lib/math/Vector2d.ci:22'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise add the two vectors.'
.value: vec2d(emit(struct(a), struct(b), add.p2d))
.usages:
}
sub(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sub'
.file: 'cmplStd/lib/math/Vector2d.ci:25'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise subtract the two vectors.'
.value: vec2d(emit(struct(a), struct(b), sub.p2d))
.usages:
}
mul(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'mul'
.file: 'cmplStd/lib/math/Vector2d.ci:28'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise multiply the two vectors.'
.value: vec2d(emit(struct(a), struct(b), mul.p2d))
.usages:
}
div(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'div'
.file: 'cmplStd/lib/math/Vector2d.ci:31'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise divide the two vectors.'
.value: vec2d(emit(struct(a), struct(b), div.p2d))
.usages:
}
min(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/lib/math/Vector2d.ci:34'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise select the minimum from the two vectors.'
.value: vec2d(emit(struct(a), struct(b), min.p2d))
.usages:
}
max(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/lib/math/Vector2d.ci:37'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Component wise select the maximum from the two vectors.'
.value: vec2d(emit(struct(a), struct(b), max.p2d))
.usages:
}
ceq(a: vec2d, b: vec2d): vec2d: function {
.kind: inline
.base: `function`
.size: 0
.name: 'ceq'
.file: 'cmplStd/lib/math/Vector2d.ci:40'
.param .result: vec2d (size: 16, cast: val)
.param a: vec2d (size: 16, cast: val)
.param b: vec2d (size: 16, cast: val)
.doc: 'Compare the two vectors for equality.'
.value: vec2d(emit(struct(a), struct(b), ceq.p2d))
.usages:
}
dot(a: vec2d, b: vec2d): float64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'dot'
.file: 'cmplStd/lib/math/Vector2d.ci:43'
.param .result: float64 (size: 8, cast: f64)
.param a: vec2d (size: 4, cast: const variable(ref))
.param b: vec2d (size: 4, cast: const variable(ref))
.doc: 'Dot product of thw two vectors'
.value: a.x * b.x + a.y * b.y
.usages:
}
Timeunit: int64 {
.kind: static const typename(ERR)
.base: `int64`
.size: 8
.name: 'Timeunit'
.file: 'cmplStd/lib/time/Timeunit.ci:2'
.field Nanos: int64 (size: 0, cast: static const val)
.field Micros: int64 (size: 0, cast: static const val)
.field Millis: int64 (size: 0, cast: static const val)
.field Seconds: int64 (size: 0, cast: static const val)
.field Minutes: int64 (size: 0, cast: static const val)
.field Hours: int64 (size: 0, cast: static const val)
.field Days: int64 (size: 0, cast: static const val)
.doc: 'enumeration of some known time unit, used for conversions and to specify the precision'
.usages:
	cmplStd/lib/text/Format.ci:436: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:256: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:255: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:254: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:253: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:198: referenced as `Timeunit`
	cmplStd/lib/time/Datetime.ci:175: referenced as `Timeunit`
	cmplStd/lib/time/Timezone.ci:29: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:120: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:94: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:73: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:55: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:42: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:32: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:17: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:12: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:9: referenced as `Timeunit`
	cmplStd/lib/time/Timestamp.ci:9: referenced as `Timeunit`
	cmplStd/lib/time/Duration.ci:22: referenced as `Timeunit`
	cmplStd/lib/time/Duration.ci:11: referenced as `Timeunit`
	cmplStd/lib/time/Duration.ci:8: referenced as `Timeunit`
	cmplStd/lib/time/Duration.ci:8: referenced as `Timeunit`
	cmplStd/lib/time/Timeunit.ci:24: referenced as `Timeunit`
	cmplStd/lib/time/Timeunit.ci:24: referenced as `Timeunit`
	cmplStd/lib/time/Timeunit.ci:14: referenced as `Timeunit`
	cmplStd/lib/time/Timeunit.ci:14: referenced as `Timeunit`
}
Timeunit.Nanos: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Nanos'
.file: 'cmplStd/lib/time/Timeunit.ci:4'
.owner: Timeunit
.doc: 'Nanos'
.value: (1)
.usages:
	cmplStd/lib/time/Timeunit.ci:5: referenced as `Nanos`
}
Timeunit.Micros: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Micros'
.file: 'cmplStd/lib/time/Timeunit.ci:5'
.owner: Timeunit
.doc: 'Micros'
.value: (1000)
.usages:
	cmplStd/lib/time/Timeunit.ci:6: referenced as `Micros`
}
Timeunit.Millis: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Millis'
.file: 'cmplStd/lib/time/Timeunit.ci:6'
.owner: Timeunit
.doc: 'Millis'
.value: (1000000)
.usages:
	cmplStd/lib/time/Datetime.ci:256: referenced as `Millis`
	cmplStd/lib/time/Datetime.ci:175: referenced as `Millis`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `Millis`
	cmplStd/lib/time/Timestamp.ci:9: referenced as `Millis`
	cmplStd/lib/time/Duration.ci:8: referenced as `Millis`
	cmplStd/lib/time/Timeunit.ci:7: referenced as `Millis`
}
Timeunit.Seconds: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Seconds'
.file: 'cmplStd/lib/time/Timeunit.ci:7'
.owner: Timeunit
.doc: 'Seconds'
.value: (1000000000)
.usages:
	cmplStd/lib/text/Format.ci:436: referenced as `Seconds`
	cmplStd/lib/time/Datetime.ci:255: referenced as `Seconds`
	cmplStd/lib/time/Timeunit.ci:8: referenced as `Seconds`
}
Timeunit.Minutes: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Minutes'
.file: 'cmplStd/lib/time/Timeunit.ci:8'
.owner: Timeunit
.doc: 'Minutes'
.value: (60000000000)
.usages:
	cmplStd/lib/time/Datetime.ci:254: referenced as `Minutes`
	cmplStd/lib/time/Timeunit.ci:9: referenced as `Minutes`
}
Timeunit.Hours: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Hours'
.file: 'cmplStd/lib/time/Timeunit.ci:9'
.owner: Timeunit
.doc: 'Hours'
.value: (3600000000000)
.usages:
	cmplStd/lib/time/Datetime.ci:253: referenced as `Hours`
	cmplStd/lib/time/Timezone.ci:29: referenced as `Hours`
	cmplStd/lib/time/Timeunit.ci:10: referenced as `Hours`
}
Timeunit.Days: int64 {
.kind: static const val
.base: `int64`
.size: 0
.name: 'Days'
.file: 'cmplStd/lib/time/Timeunit.ci:10'
.owner: Timeunit
.doc: 'Days'
.value: (86400000000000)
.usages:
	cmplStd/lib/time/Datetime.ci:198: referenced as `Days`
}
convert(value: int64, from: Timeunit, to: Timeunit): int64: function {
.kind: static function
.base: `function`
.size: 31
.name: 'convert'
.file: 'cmplStd/lib/time/Timeunit.ci:14'
.param .result: int64 (size: 8, cast: variable(i64))
.param value: int64 (size: 8, cast: variable(i64))
.param from: Timeunit (size: 8, cast: variable(i64))
.param to: Timeunit (size: 8, cast: variable(i64))
.doc: 'Convert the given integer `value` from the `from` to `to` unit'
.value: {
	if (from > to) {
		return .result := value * (from / to);
	}
	return .result := value / (to / from);
}
.instructions: (31 bytes)
	cmplStd/lib/time/Timeunit.ci:15: (20 bytes): if (from > to)
	<convert>  : dup.x64 sp(3)
	<convert+?>: dup.x64 sp(3)
	<convert+?>: cgt.i64
	<convert+?>: jz +15
	cmplStd/lib/time/Timeunit.ci:17: (11 bytes): return .result := value * (from / to);
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(5)
	<convert+?>: div.i64
	<convert+?>: mul.i64
	<convert+?>: set.x64 sp(9)
	<convert+?>: ret
	cmplStd/lib/time/Timeunit.ci:20: (11 bytes): return .result := value / (to / from);
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(3)
	<convert+?>: dup.x64 sp(7)
	<convert+?>: div.i64
	<convert+?>: div.i64
	<convert+?>: set.x64 sp(9)
	<convert+?>: ret
.usages:
	cmplStd/lib/time/Timestamp.ci:121: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:78: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:60: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `convert`
	cmplStd/lib/time/Timestamp.ci:13: referenced as `convert`
	cmplStd/lib/time/Duration.ci:23: referenced as `convert`
	cmplStd/lib/time/Duration.ci:12: referenced as `convert`
}
convert(value: float64, from: Timeunit, to: Timeunit): float64: function {
.kind: static function
.base: `function`
.size: 33
.name: 'convert'
.file: 'cmplStd/lib/time/Timeunit.ci:24'
.param .result: float64 (size: 8, cast: variable(f64))
.param value: float64 (size: 8, cast: variable(f64))
.param from: Timeunit (size: 8, cast: variable(i64))
.param to: Timeunit (size: 8, cast: variable(i64))
.doc: 'Convert the given floating point `value` from the `from` to `to` unit'
.value: {
	if (from > to) {
		return .result := value * ((from / to));
	}
	return .result := value / ((to / from));
}
.instructions: (33 bytes)
	cmplStd/lib/time/Timeunit.ci:25: (21 bytes): if (from > to)
	<convert>  : dup.x64 sp(3)
	<convert+?>: dup.x64 sp(3)
	<convert+?>: cgt.i64
	<convert+?>: jz +16
	cmplStd/lib/time/Timeunit.ci:27: (12 bytes): return .result := value * ((from / to));
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(5)
	<convert+?>: div.i64
	<convert+?>: i64.2f64
	<convert+?>: mul.f64
	<convert+?>: set.x64 sp(9)
	<convert+?>: ret
	cmplStd/lib/time/Timeunit.ci:30: (12 bytes): return .result := value / ((to / from));
	<convert+?>: dup.x64 sp(5)
	<convert+?>: dup.x64 sp(3)
	<convert+?>: dup.x64 sp(7)
	<convert+?>: div.i64
	<convert+?>: i64.2f64
	<convert+?>: div.f64
	<convert+?>: set.x64 sp(9)
	<convert+?>: ret
.usages:
}
Duration: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Duration'
.file: 'cmplStd/lib/time/Duration.ci:5'
.field value: int64 (size: 8, cast: const variable(i64))
.field precision: Timeunit (size: 8, cast: static const variable(i64))
.field value: function (size: 22, cast: static function)
.field add: function (size: 8, cast: static function)
.doc: 'Timespan is just a duration
for example: 33 seconds'
.usages:
	cmplStd/lib/time/Datetime.ci:197: referenced as `Duration`
	cmplStd/lib/time/Datetime.ci:196: referenced as `Duration`
	cmplStd/lib/time/Timezone.ci:27: referenced as `Duration`
	cmplStd/lib/time/Timezone.ci:12: referenced as `Duration`
	cmplStd/lib/time/Timezone.ci:6: referenced as `Duration`
	cmplStd/lib/time/Timezone.ci:4: referenced as `Duration`
	cmplStd/lib/time/Timestamp.ci:22: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:23: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:22: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:16: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:16: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:16: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:12: referenced as `Duration`
	cmplStd/lib/time/Duration.ci:11: referenced as `Duration`
}
Duration.value: int64 {
.kind: const variable(i64)
.base: `int64`
.size: 8
.name: 'value'
.file: 'cmplStd/lib/time/Duration.ci:6'
.owner: Duration
.value: 0
.usages:
	cmplStd/lib/time/Datetime.ci:197: referenced as `value`
	cmplStd/lib/time/Timezone.ci:14: referenced as `value`
	cmplStd/lib/time/Duration.ci:23: referenced as `value`
	cmplStd/lib/time/Duration.ci:17: referenced as `value`
	cmplStd/lib/time/Duration.ci:17: referenced as `value`
	cmplStd/lib/time/Duration.ci:17: referenced as `value`
	cmplStd/lib/time/Duration.ci:12: referenced as `value`
}
Duration.precision: Timeunit {
.kind: static const variable(i64)
.base: `Timeunit`
.size: 8
.name: 'precision'
.file: 'cmplStd/lib/time/Duration.ci:8'
.owner: Duration
.value: Timeunit.(Millis)
.usages:
	cmplStd/lib/time/Datetime.ci:197: referenced as `precision`
	cmplStd/lib/time/Duration.ci:23: referenced as `precision`
	cmplStd/lib/time/Duration.ci:12: referenced as `precision`
}
Duration.value(duration: Duration, precision: Timeunit): int64: function {
.kind: static function
.base: `function`
.size: 22
.name: 'value'
.file: 'cmplStd/lib/time/Duration.ci:11'
.owner: Duration
.param .result: int64 (size: 8, cast: variable(i64))
.param duration: Duration (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Returns the value of the `duration` at the given `precision` (Seconds and Millis are mostly used as unix epoch)'
.value: {
	return .result := convert(duration.value, Duration.precision, precision);
}
.instructions: (22 bytes)
	cmplStd/lib/time/Duration.ci:12: (22 bytes): return .result := convert(duration.value, Duration.precision, precision);
	<value>  : load.z64
	<value+?>: dup.x64 sp(5)
	<value+?>: load.m64 <?> ;Duration.precision
	<value+?>: dup.x64 sp(7)
	<value+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<value+?>: call
	<value+?>: inc.sp(-24)
	<value+?>: set.x64 sp(7)
	<value+?>: ret
.usages:
}
Duration.add(lhs: Duration, rhs: Duration): Duration: function {
.kind: static function
.base: `function`
.size: 8
.name: 'add'
.file: 'cmplStd/lib/time/Duration.ci:16'
.owner: Duration
.param .result: Duration (size: 8, cast: variable(val))
.param lhs: Duration (size: 8, cast: variable(val))
.param rhs: Duration (size: 8, cast: variable(val))
.doc: 'Add two durations'
.value: {
	return .result := {
			.result.value := lhs.value + rhs.value;
		};
}
.instructions: (8 bytes)
	cmplStd/lib/time/Duration.ci:17: (8 bytes): return .result := {...};
	cmplStd/lib/time/Duration.ci:17: (7 bytes): .result.value := lhs.value + rhs.value;
	<add>  : dup.x64 sp(3)
	<add+?>: dup.x64 sp(3)
	<add+?>: add.i64
	<add+?>: set.x64 sp(7)
	<add+?>: ret
.usages:
}
Duration(value: int64, precision: Timeunit): Duration: function {
.kind: static function
.base: `function`
.size: 22
.name: 'Duration'
.file: 'cmplStd/lib/time/Duration.ci:22'
.param .result: Duration (size: 8, cast: variable(val))
.param value: int64 (size: 8, cast: variable(i64))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Construct a duration from the given `value` at the given `precision`'
.value: {
	return .result := {
			.result.value := convert(value, precision, Duration.precision);
		};
}
.instructions: (22 bytes)
	cmplStd/lib/time/Duration.ci:23: (22 bytes): return .result := {...};
	cmplStd/lib/time/Duration.ci:23: (21 bytes): .result.value := convert(value, precision, Duration.precision);
	<Duration>  : load.z64
	<Duration+?>: dup.x64 sp(5)
	<Duration+?>: dup.x64 sp(5)
	<Duration+?>: load.m64 <?> ;Duration.precision
	<Duration+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<Duration+?>: call
	<Duration+?>: inc.sp(-24)
	<Duration+?>: set.x64 sp(7)
	<Duration+?>: ret
.usages:
	cmplStd/lib/time/Timezone.ci:29: referenced as `Duration`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `Duration`
}
Timestamp: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Timestamp'
.file: 'cmplStd/lib/time/Timestamp.ci:5'
.field value: int64 (size: 8, cast: variable(i64))
.field precision: Timeunit (size: 8, cast: static const variable(i64))
.field value: function (size: 22, cast: static function)
.field diff: function (size: 25, cast: static function)
.field diff: function (size: 26, cast: static function)
.field compare: function (size: 14, cast: static function)
.field equal: function (size: 37, cast: static function)
.field equal: function (size: 11, cast: static function)
.field add: function (size: 25, cast: static function)
.field floor: function (size: 109, cast: static function)
.field ceil: function (size: 130, cast: static function)
.field distribute: function (size: 44, cast: static function)
.field distribute: function (size: 27, cast: static function)
.field now: function (size: 31, cast: static function)
.doc: 'Timestamp is a position in time, without timezone information
in case locale is needed use Datetime.'
.usages:
	cmplStd/lib/time/Datetime.ci:270: referenced as `Timestamp`
	cmplStd/lib/time/Datetime.ci:179: referenced as `Timestamp`
	cmplStd/lib/time/Datetime.ci:153: referenced as `Timestamp`
	cmplStd/lib/time/Datetime.ci:149: referenced as `Timestamp`
	cmplStd/lib/time/Timezone.ci:27: referenced as `Timestamp`
	cmplStd/lib/time/Timezone.ci:12: referenced as `Timestamp`
	cmplStd/lib/time/Timezone.ci:6: referenced as `Timestamp`
	cmplStd/lib/time/Timezone.ci:4: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:121: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:120: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:114: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:109: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:94: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:94: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:78: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:74: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:73: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:73: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:60: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:56: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:55: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:55: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:42: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:42: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:37: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:37: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:32: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:32: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:27: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:27: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:22: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:22: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:17: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:17: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:13: referenced as `Timestamp`
	cmplStd/lib/time/Timestamp.ci:12: referenced as `Timestamp`
}
Timestamp.value: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'value'
.file: 'cmplStd/lib/time/Timestamp.ci:6'
.owner: Timestamp
.value: 0
.usages:
	cmplStd/lib/time/Timestamp.ci:121: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:96: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:83: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:83: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:79: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:61: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:61: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:61: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:38: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:38: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:28: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:13: referenced as `value`
}
Timestamp.precision: Timeunit {
.kind: static const variable(i64)
.base: `Timeunit`
.size: 8
.name: 'precision'
.file: 'cmplStd/lib/time/Timestamp.ci:9'
.owner: Timestamp
.doc: 'The time unit specifying the precision of the timestamp'
.value: Timeunit.(Millis)
.usages:
	cmplStd/lib/time/Datetime.ci:153: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:121: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:115: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:78: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:74: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:60: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:56: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:43: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:23: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:18: referenced as `precision`
	cmplStd/lib/time/Timestamp.ci:13: referenced as `precision`
}
Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64: function {
.kind: static function
.base: `function`
.size: 22
.name: 'value'
.file: 'cmplStd/lib/time/Timestamp.ci:12'
.owner: Timestamp
.param .result: int64 (size: 8, cast: variable(i64))
.param timestamp: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Returns the value of `timestamp` at the given `precision` (Seconds and Millis are mostly used as unix epoch)'
.value: {
	return .result := convert(timestamp.value, Timestamp.precision, precision);
}
.instructions: (22 bytes)
	cmplStd/lib/time/Timestamp.ci:13: (22 bytes): return .result := convert(timestamp.value, Timestamp.precision, precision);
	<value>  : load.z64
	<value+?>: dup.x64 sp(5)
	<value+?>: load.m64 <?> ;Timestamp.precision
	<value+?>: dup.x64 sp(7)
	<value+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<value+?>: call
	<value+?>: inc.sp(-24)
	<value+?>: set.x64 sp(7)
	<value+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:436: referenced as `value`
	cmplStd/lib/time/Datetime.ci:256: referenced as `value`
	cmplStd/lib/time/Datetime.ci:255: referenced as `value`
	cmplStd/lib/time/Datetime.ci:254: referenced as `value`
	cmplStd/lib/time/Datetime.ci:253: referenced as `value`
	cmplStd/lib/time/Datetime.ci:198: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:33: referenced as `value`
	cmplStd/lib/time/Timestamp.ci:33: referenced as `value`
}
Timestamp.diff(a: Timestamp, b: Timestamp, precision: Timeunit): int64: function {
.kind: static function
.base: `function`
.size: 25
.name: 'diff'
.file: 'cmplStd/lib/time/Timestamp.ci:17'
.owner: Timestamp
.param .result: int64 (size: 8, cast: variable(i64))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Returns the difference of `a` and `b` at the given `precision`'
.value: {
	return .result := convert(a.value - b.value, Timestamp.precision, precision);
}
.instructions: (25 bytes)
	cmplStd/lib/time/Timestamp.ci:18: (25 bytes): return .result := convert(a.value - b.value, Timestamp.precision, precision);
	<diff>  : load.z64
	<diff+?>: dup.x64 sp(7)
	<diff+?>: dup.x64 sp(7)
	<diff+?>: sub.i64
	<diff+?>: load.m64 <?> ;Timestamp.precision
	<diff+?>: dup.x64 sp(7)
	<diff+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<diff+?>: call
	<diff+?>: inc.sp(-24)
	<diff+?>: set.x64 sp(9)
	<diff+?>: ret
.usages:
}
Timestamp.diff(a: Timestamp, b: Timestamp): Duration: function {
.kind: static function
.base: `function`
.size: 26
.name: 'diff'
.file: 'cmplStd/lib/time/Timestamp.ci:22'
.owner: Timestamp
.param .result: Duration (size: 8, cast: variable(val))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.doc: 'Returns the difference of `a` and `b'
.value: {
	return .result := Duration(a.value - b.value, Timestamp.precision);
}
.instructions: (26 bytes)
	cmplStd/lib/time/Timestamp.ci:23: (26 bytes): return .result := Duration(a.value - b.value, Timestamp.precision);
	<diff>  : inc.sp(+8)
	<diff+?>: dup.x64 sp(5)
	<diff+?>: dup.x64 sp(5)
	<diff+?>: sub.i64
	<diff+?>: load.m64 <?> ;Timestamp.precision
	<diff+?>: load.ref <?> ;Duration(value: int64, precision: Timeunit): Duration
	<diff+?>: call
	<diff+?>: inc.sp(-16)
	<diff+?>: set.x64 sp(7)
	<diff+?>: ret
.usages:
}
Timestamp.compare(a: Timestamp, b: Timestamp): int32: function {
.kind: static function
.base: `function`
.size: 14
.name: 'compare'
.file: 'cmplStd/lib/time/Timestamp.ci:27'
.owner: Timestamp
.param .result: int32 (size: 4, cast: variable(i32))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.doc: 'Returns whether the firs timestamp is less(<0), equal(=0), or greater(>0) than the second timestamp'
.value: {
	return .result := int32(a.value > b.value) - int32(a.value < b.value);
}
.instructions: (14 bytes)
	cmplStd/lib/time/Timestamp.ci:28: (14 bytes): return .result := int32(a.value > b.value) - int32(a.value < b.value);
	<compare>  : dup.x64 sp(3)
	<compare+?>: dup.x64 sp(3)
	<compare+?>: cgt.i64
	<compare+?>: dup.x64 sp(4)
	<compare+?>: dup.x64 sp(4)
	<compare+?>: clt.i64
	<compare+?>: sub.i32
	<compare+?>: set.x32 sp(6)
	<compare+?>: ret
.usages:
}
Timestamp.equal(a: Timestamp, b: Timestamp, precision: Timeunit): bool: function {
.kind: static function
.base: `function`
.size: 37
.name: 'equal'
.file: 'cmplStd/lib/time/Timestamp.ci:32'
.owner: Timestamp
.param .result: bool (size: 4, cast: variable(bool))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Check whether the two timestamps `a` and `b` are equal at the given `precision`'
.value: {
	return .result := value(a, precision) == value(b, precision);
}
.instructions: (37 bytes)
	cmplStd/lib/time/Timestamp.ci:33: (37 bytes): return .result := value(a, precision) == value(b, precision);
	<equal>  : load.z64
	<equal+?>: dup.x64 sp(7)
	<equal+?>: dup.x64 sp(5)
	<equal+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<equal+?>: call
	<equal+?>: inc.sp(-16)
	<equal+?>: load.z64
	<equal+?>: dup.x64 sp(7)
	<equal+?>: dup.x64 sp(7)
	<equal+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<equal+?>: call
	<equal+?>: inc.sp(-16)
	<equal+?>: ceq.i64
	<equal+?>: load.sp(+32)
	<equal+?>: store.i8
	<equal+?>: ret
.usages:
}
Timestamp.equal(a: Timestamp, b: Timestamp): bool: function {
.kind: static function
.base: `function`
.size: 11
.name: 'equal'
.file: 'cmplStd/lib/time/Timestamp.ci:37'
.owner: Timestamp
.param .result: bool (size: 4, cast: variable(bool))
.param a: Timestamp (size: 8, cast: variable(val))
.param b: Timestamp (size: 8, cast: variable(val))
.doc: 'Check whether the two timestamps `a` and `b` are equal'
.value: {
	return .result := a.value == b.value;
}
.instructions: (11 bytes)
	cmplStd/lib/time/Timestamp.ci:38: (11 bytes): return .result := a.value == b.value;
	<equal>  : dup.x64 sp(3)
	<equal+?>: dup.x64 sp(3)
	<equal+?>: ceq.i64
	<equal+?>: load.sp(+24)
	<equal+?>: store.i8
	<equal+?>: ret
.usages:
}
Timestamp.add(lhs: Timestamp, value: int64, precision: Timeunit): Timestamp: function {
.kind: static function
.base: `function`
.size: 25
.name: 'add'
.file: 'cmplStd/lib/time/Timestamp.ci:42'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param lhs: Timestamp (size: 8, cast: variable(val))
.param value: int64 (size: 8, cast: variable(i64))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Increment the the current timestamp with the given `value` at the given `precision`'
.value: {
	return .result := {
			.result.value := lhs.value + convert(value, precision, Timestamp.precision);
		};
}
.instructions: (25 bytes)
	cmplStd/lib/time/Timestamp.ci:43: (25 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:43: (24 bytes): .result.value := lhs.value + convert(value, precision, Timestamp.precision);
	<add>  : dup.x64 sp(5)
	<add+?>: load.z64
	<add+?>: dup.x64 sp(7)
	<add+?>: dup.x64 sp(7)
	<add+?>: load.m64 <?> ;Timestamp.precision
	<add+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<add+?>: call
	<add+?>: inc.sp(-24)
	<add+?>: add.i64
	<add+?>: set.x64 sp(9)
	<add+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:197: referenced as `add`
}
Timestamp.floor(value: Timestamp, precision: Timeunit): Timestamp: function {
.kind: static function
.base: `function`
.size: 109
.name: 'floor'
.file: 'cmplStd/lib/time/Timestamp.ci:55'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param value: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Floor the current timestamp, leaving the field specified as the most significant field.
For example, if you have the timestamp: 2002-03-28 13:45:01.231,
using resolution Timeunit.Days, it should return 2002-03-28 00:00:00.000.
using resolution Timeunit.Hours, it should return 2002-03-28 13:00:00.000.
using resolution Timeunit.Minutes, it should return 2002-03-28 13:45:00.000.
	 * @param unit Resolution of the operation.'
.value: {
	if (precision <= (Timestamp.precision)) {
		trace("small precision", precision);
		return .result := value;
	}
	one: int64 := convert(1, precision, Timestamp.precision);
	return .result := {
			.result.value := value.value - value.value % one;
		};
}
.instructions: (109 bytes)
	cmplStd/lib/time/Timestamp.ci:56: (68 bytes): if (precision <= (Timestamp.precision))
	<floor>  : dup.x64 sp(1)
	<floor+?>: load.m64 <?> ;Timestamp.precision
	<floor+?>: cgt.i64
	<floor+?>: jnz +61
	cmplStd/lib/time/Timestamp.ci:57: (53 bytes): trace("small precision", precision);
	<floor+?>: load.ref <?> ;Timeunit
	<floor+?>: load.sp(+8)
	<floor+?>: load.c32 1
	<floor+?>: load.sp(+4)
	<floor+?>: load.ref <?> ;"cmplStd/lib/time/Timestamp.ci"
	<floor+?>: load.c32 57
	<floor+?>: load.c32 14
	<floor+?>: load.c32 128
	<floor+?>: load.ref <?> ;"small precision"
	<floor+?>: dup.x64 sp(5)
	<floor+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<floor+?>: inc.sp(-16)
	cmplStd/lib/time/Timestamp.ci:58: (4 bytes): return .result := value;
	<floor+?>: mov.x64 sp(5, 3)
	<floor+?>: ret
	cmplStd/lib/time/Timestamp.ci:60: (26 bytes): one: int64 := convert(1, precision, Timestamp.precision)
	<floor+?>: load.z64
	<floor+?>: load.c64 1
	<floor+?>: dup.x64 sp(5)
	<floor+?>: load.m64 <?> ;Timestamp.precision
	<floor+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<floor+?>: call
	<floor+?>: inc.sp(-24)
	cmplStd/lib/time/Timestamp.ci:61: (15 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:61: (10 bytes): .result.value := value.value - value.value % one;
	<floor+?>: dup.x64 sp(5)
	<floor+?>: dup.x64 sp(7)
	<floor+?>: dup.x64 sp(4)
	<floor+?>: mod.i64
	<floor+?>: sub.i64
	<floor+?>: set.x64 sp(9)
	<floor+?>: inc.sp(-8)
	<floor+?>: ret
.usages:
}
Timestamp.ceil(value: Timestamp, precision: Timeunit): Timestamp: function {
.kind: static function
.base: `function`
.size: 130
.name: 'ceil'
.file: 'cmplStd/lib/time/Timestamp.ci:73'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param value: Timestamp (size: 8, cast: variable(val))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Ceil the current timestamp, leaving the field specified as the most significant field.
For example, if you have the timestamp: 2002-03-28 13:45:01.231,
using resolution Timeunit.Days, it should return 2002-03-29 00:00:00.000.
using resolution Timeunit.Hours, it should return 2002-03-28 14:00:00.000.
using resolution Timeunit.Minutes, it should return 2002-03-28 13:46:00.000.
	 * @param unit Resolution of the operation.'
.value: {
	if (precision <= (Timestamp.precision)) {
		trace("small precision", precision);
		return .result := value;
	}
	one: int64 := convert(1, precision, Timestamp.precision);
	part: int64 := value.value % one;
	if (part == (0)) {
		return .result := value;
	}
	return .result := {
			.result.value := value.value - part + one;
		};
}
.instructions: (130 bytes)
	cmplStd/lib/time/Timestamp.ci:74: (68 bytes): if (precision <= (Timestamp.precision))
	<ceil>  : dup.x64 sp(1)
	<ceil+?>: load.m64 <?> ;Timestamp.precision
	<ceil+?>: cgt.i64
	<ceil+?>: jnz +61
	cmplStd/lib/time/Timestamp.ci:75: (53 bytes): trace("small precision", precision);
	<ceil+?>: load.ref <?> ;Timeunit
	<ceil+?>: load.sp(+8)
	<ceil+?>: load.c32 1
	<ceil+?>: load.sp(+4)
	<ceil+?>: load.ref <?> ;"cmplStd/lib/time/Timestamp.ci"
	<ceil+?>: load.c32 75
	<ceil+?>: load.c32 14
	<ceil+?>: load.c32 128
	<ceil+?>: load.ref <?> ;"small precision"
	<ceil+?>: dup.x64 sp(5)
	<ceil+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<ceil+?>: inc.sp(-16)
	cmplStd/lib/time/Timestamp.ci:76: (4 bytes): return .result := value;
	<ceil+?>: mov.x64 sp(5, 3)
	<ceil+?>: ret
	cmplStd/lib/time/Timestamp.ci:78: (26 bytes): one: int64 := convert(1, precision, Timestamp.precision)
	<ceil+?>: load.z64
	<ceil+?>: load.c64 1
	<ceil+?>: dup.x64 sp(5)
	<ceil+?>: load.m64 <?> ;Timestamp.precision
	<ceil+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<ceil+?>: call
	<ceil+?>: inc.sp(-24)
	cmplStd/lib/time/Timestamp.ci:79: (5 bytes): part: int64 := value.value % one
	<ceil+?>: dup.x64 sp(5)
	<ceil+?>: dup.x64 sp(2)
	<ceil+?>: mod.i64
	cmplStd/lib/time/Timestamp.ci:80: (16 bytes): if (part == (0))
	<ceil+?>: dup.x64 sp(0)
	<ceil+?>: load.z64
	<ceil+?>: ceq.i64
	<ceil+?>: jz +12
	cmplStd/lib/time/Timestamp.ci:81: (8 bytes): return .result := value;
	<ceil+?>: mov.x64 sp(9, 7)
	<ceil+?>: inc.sp(-16)
	<ceil+?>: ret
	cmplStd/lib/time/Timestamp.ci:83: (15 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:83: (10 bytes): .result.value := value.value - part + one;
	<ceil+?>: dup.x64 sp(7)
	<ceil+?>: dup.x64 sp(2)
	<ceil+?>: sub.i64
	<ceil+?>: dup.x64 sp(4)
	<ceil+?>: add.i64
	<ceil+?>: set.x64 sp(11)
	<ceil+?>: inc.sp(-16)
	<ceil+?>: ret
.usages:
}
Timestamp.distribute(this: Timestamp, unit: Timeunit, duration: uint64): Timestamp: function {
.kind: static function
.base: `function`
.size: 44
.name: 'distribute'
.file: 'cmplStd/lib/time/Timestamp.ci:94'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param this: Timestamp (size: 8, cast: variable(val))
.param unit: Timeunit (size: 8, cast: variable(i64))
.param duration: uint64 (size: 8, cast: variable(u64))
.doc: 'Distribute randomly between current value and the duration at the given time-unit resolution.
For example, if you had the timestamp: 2002-03-28 13:45:01.231,
using distribute(Timeunit.Hours, 2), it will return a date between 2002-03-28 13:46:01.231 and 2002-03-28 15:46:01.231.
	 * @param unit  Resolution of the duration.
@param duration The duration of the distribution time frame, negative values are allowed.'
.value: {
	abort("not implemented");
	return .result := {
			.result.value := (0);
		};
}
.instructions: (44 bytes)
	cmplStd/lib/time/Timestamp.ci:95: (40 bytes): abort("not implemented");
	<distribute>  : load.z32
	<distribute+?>: load.sp(+4)
	<distribute+?>: load.ref <?> ;"cmplStd/lib/time/Timestamp.ci"
	<distribute+?>: load.c32 95
	<distribute+?>: load.c32 -2
	<distribute+?>: load.c32 128
	<distribute+?>: load.ref <?> ;"not implemented"
	<distribute+?>: dup.x64 sp(5)
	<distribute+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<distribute+?>: inc.sp(-8)
	cmplStd/lib/time/Timestamp.ci:96: (4 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:96: (3 bytes): .result.value := (0);
	<distribute+?>: load.z64
	<distribute+?>: set.x64 sp(9)
	<distribute+?>: ret
.usages:
	cmplStd/lib/time/Timestamp.ci:110: referenced as `distribute`
}
Timestamp.distribute(this: Timestamp, unit: Timeunit, start: int32, end: int32): Timestamp: function {
.kind: static function
.base: `function`
.size: 27
.name: 'distribute'
.file: 'cmplStd/lib/time/Timestamp.ci:109'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.param this: Timestamp (size: 8, cast: variable(val))
.param unit: Timeunit (size: 8, cast: variable(i64))
.param start: int32 (size: 4, cast: variable(i32))
.param end: int32 (size: 4, cast: variable(i32))
.doc: 'Distribute randomly between start and end at the given time-unit resolution.
For example, if you have the timestamp of 2002-03-28 13:46:01.231,
using distribute(Timeunit.Hours, 15, 17) as start and end, it will return a date between 2002-03-28 15:46:01.231 and 2002-03-28 17:46:01.231.
in case you need a timestamp between 15:00:00.000 and 17:00:00.000 yo will need to use the floor method before or after this operation.
	 * @param unit  Resolution of the operation.
@param start The beginning of the distribution time frame.
@param end   The end of the distribution time frame.'
.value: {
	return .result := distribute(this, unit, end - start);
}
.instructions: (27 bytes)
	cmplStd/lib/time/Timestamp.ci:110: (27 bytes): return .result := distribute(this, unit, end - start);
	<distribute>  : inc.sp(+8)
	<distribute+?>: dup.x64 sp(7)
	<distribute+?>: dup.x64 sp(7)
	<distribute+?>: dup.x32 sp(7)
	<distribute+?>: dup.x32 sp(9)
	<distribute+?>: sub.i32
	<distribute+?>: i32.2i64
	<distribute+?>: load.ref <?> ;Timestamp.distribute(this: Timestamp, unit: Timeunit, duration: uint64): Timestamp
	<distribute+?>: call
	<distribute+?>: inc.sp(-24)
	<distribute+?>: set.x64 sp(9)
	<distribute+?>: ret
.usages:
}
Timestamp.now(): Timestamp: function {
.kind: static function
.base: `function`
.size: 31
.name: 'now'
.file: 'cmplStd/lib/time/Timestamp.ci:114'
.owner: Timestamp
.param .result: Timestamp (size: 8, cast: variable(val))
.doc: 'get the current utc time as timestamp from the system'
.value: {
	return .result := {
			.result.value := convert(System.millis(), Timeunit.(Millis), Timestamp.precision);
		};
}
.instructions: (31 bytes)
	cmplStd/lib/time/Timestamp.ci:115: (31 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:115: (30 bytes): .result.value := convert(System.millis(), Timeunit.(Millis), Timestamp.precision);
	<now>  : load.z64
	<now+?>: nfc(20) ;System.millis(): int64
	<now+?>: load.c64 1000000
	<now+?>: load.m64 <?> ;Timestamp.precision
	<now+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<now+?>: call
	<now+?>: inc.sp(-24)
	<now+?>: set.x64 sp(3)
	<now+?>: ret
.usages:
}
Timestamp(value: int64, precision: Timeunit): Timestamp: function {
.kind: static function
.base: `function`
.size: 22
.name: 'Timestamp'
.file: 'cmplStd/lib/time/Timestamp.ci:120'
.param .result: Timestamp (size: 8, cast: variable(val))
.param value: int64 (size: 8, cast: variable(i64))
.param precision: Timeunit (size: 8, cast: variable(i64))
.doc: 'Create a timestamp from the given `value` at the given `precision`'
.value: {
	return .result := {
			.result.value := convert(value, precision, Timestamp.precision);
		};
}
.instructions: (22 bytes)
	cmplStd/lib/time/Timestamp.ci:121: (22 bytes): return .result := {...};
	cmplStd/lib/time/Timestamp.ci:121: (21 bytes): .result.value := convert(value, precision, Timestamp.precision);
	<Timestamp>  : load.z64
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: load.m64 <?> ;Timestamp.precision
	<Timestamp+?>: load.ref <?> ;convert(value: int64, from: Timeunit, to: Timeunit): int64
	<Timestamp+?>: call
	<Timestamp+?>: inc.sp(-24)
	<Timestamp+?>: set.x64 sp(7)
	<Timestamp+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:175: referenced as `Timestamp`
	cmplStd/lib/time/Datetime.ci:153: referenced as `Timestamp`
}
Timezone: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'Timezone'
.file: 'cmplStd/lib/time/Timezone.ci:2'
.field name: char[] (size: 8, cast: const variable(arr))
.field offset: function (size: 4, cast: variable(ref))
.field offset: function (size: 32, cast: static function)
.field utc: function (size: 20, cast: static function)
.field lookup: function (size: 41, cast: static function)
.field local: function (size: 56, cast: static function)
.usages:
	cmplStd/lib/time/Datetime.ci:307: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:301: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:296: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:292: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:273: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:270: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:179: referenced as `Timezone`
	cmplStd/lib/time/Datetime.ci:79: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:27: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:24: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:22: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:12: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:11: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:6: referenced as `Timezone`
	cmplStd/lib/time/Timezone.ci:4: referenced as `Timezone`
}
Timezone.name: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'name'
.file: 'cmplStd/lib/time/Timezone.ci:3'
.owner: Timezone
.usages:
	cmplStd/lib/time/Timezone.ci:33: referenced as `name`
	cmplStd/lib/time/Timezone.ci:18: referenced as `name`
}
Timezone.offset(zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'offset'
.file: 'cmplStd/lib/time/Timezone.ci:4'
.owner: Timezone
.param .result: Duration (size: 8, cast: variable(val))
.param zone: Timezone (size: 4, cast: const variable(ref))
.param timestamp: Timestamp (size: 8, cast: variable(val))
.param isDaylightSaving: bool (size: 4, cast: variable(ref))
.usages:
	cmplStd/lib/time/Timezone.ci:32: referenced as `offset`
	cmplStd/lib/time/Timezone.ci:17: referenced as `offset`
	cmplStd/lib/time/Timezone.ci:8: referenced as `offset`
}
Timezone.offset(zone: Timezone, timestamp: Timestamp): Duration: function {
.kind: static function
.base: `function`
.size: 32
.name: 'offset'
.file: 'cmplStd/lib/time/Timezone.ci:6'
.owner: Timezone
.param .result: Duration (size: 8, cast: variable(val))
.param zone: Timezone (size: 4, cast: const variable(ref))
.param timestamp: Timestamp (size: 8, cast: variable(val))
.value: {
	isDaylightSaving: bool;
	return .result := zone.offset(zone, timestamp, &isDaylightSaving);
}
.instructions: (32 bytes)
	cmplStd/lib/time/Timezone.ci:7: (1 byte): isDaylightSaving: bool
	<offset>  : load.z32
	cmplStd/lib/time/Timezone.ci:8: (31 bytes): return .result := zone.offset(zone, timestamp, &isDaylightSaving);
	<offset+?>: inc.sp(+8)
	<offset+?>: dup.x32 sp(6)
	<offset+?>: dup.x64 sp(5)
	<offset+?>: load.sp(+20)
	<offset+?>: dup.x32 sp(10)
	<offset+?>: inc.i32(+8)
	<offset+?>: load.i32
	<offset+?>: call
	<offset+?>: inc.sp(-16)
	<offset+?>: set.x64 sp(7)
	<offset+?>: inc.sp(-4)
	<offset+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:196: referenced as `offset`
}
Timezone.utc(): Timezone: function {
.kind: static function
.base: `function`
.size: 20
.name: 'utc'
.file: 'cmplStd/lib/time/Timezone.ci:11'
.owner: Timezone
.param .result: Timezone (size: 16, cast: variable(val))
.value: {
	static offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration := {
		isDaylightSaving := false;
		return .result := {
			.result.value := (0);
		};
	};
	return .result := {
			.result.offset := offset;
			.result.name := ("UTC");
		};
}
.instructions: (20 bytes)
	cmplStd/lib/time/Timezone.ci:16: (20 bytes): return .result := {...};
	cmplStd/lib/time/Timezone.ci:17: (7 bytes): .result.offset := offset;
	<utc>  : load.ref <?> ;Timezone.utc.offset(zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration
	<utc+?>: set.x32 sp(4)
	cmplStd/lib/time/Timezone.ci:18: (12 bytes): .result.name := ("UTC");
	<utc+?>: load.c32 3
	<utc+?>: load.ref <?> ;"UTC"
	<utc+?>: set.x64 sp(3)
	<utc+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:307: referenced as `utc`
	cmplStd/lib/time/Datetime.ci:292: referenced as `utc`
	cmplStd/lib/time/Datetime.ci:270: referenced as `utc`
}
Timezone.lookup(name: char[]): Timezone: function {
.kind: static function
.base: `function`
.size: 41
.name: 'lookup'
.file: 'cmplStd/lib/time/Timezone.ci:22'
.owner: Timezone
.param .result: Timezone (size: 16, cast: variable(val))
.param name: char[] (size: 8, cast: const variable(arr))
.value: {
	abort("todo");
}
.instructions: (41 bytes)
	cmplStd/lib/time/Timezone.ci:22: (40 bytes): abort("todo");
	<lookup>  : load.z32
	<lookup+?>: load.sp(+4)
	<lookup+?>: load.ref <?> ;"cmplStd/lib/time/Timezone.ci"
	<lookup+?>: load.c32 22
	<lookup+?>: load.c32 -2
	<lookup+?>: load.c32 128
	<lookup+?>: load.ref <?> ;"todo"
	<lookup+?>: dup.x64 sp(5)
	<lookup+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<lookup+?>: inc.sp(-8)
	<lookup+?>: ret
.usages:
}
Timezone.local(): Timezone: function {
.kind: static function
.base: `function`
.size: 56
.name: 'local'
.file: 'cmplStd/lib/time/Timezone.ci:24'
.owner: Timezone
.param .result: Timezone (size: 16, cast: variable(val))
.value: {
	warn("using fake timezone");
	static offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration := {
		isDaylightSaving := false;
		return .result := Duration(3, Timeunit.(Hours));
	};
	return .result := {
			.result.offset := offset;
			.result.name := ("GMT+3");
		};
}
.instructions: (56 bytes)
	cmplStd/lib/time/Timezone.ci:25: (36 bytes): warn("using fake timezone");
	<local>  : load.z32
	<local+?>: load.sp(+4)
	<local+?>: load.ref <?> ;"cmplStd/lib/time/Timezone.ci"
	<local+?>: load.c32 25
	<local+?>: load.c32 1
	<local+?>: load.z32
	<local+?>: load.ref <?> ;"using fake timezone"
	<local+?>: dup.x64 sp(5)
	<local+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<local+?>: inc.sp(-8)
	cmplStd/lib/time/Timezone.ci:31: (20 bytes): return .result := {...};
	cmplStd/lib/time/Timezone.ci:32: (7 bytes): .result.offset := offset;
	<local+?>: load.ref <?> ;Timezone.local.offset(zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration
	<local+?>: set.x32 sp(4)
	cmplStd/lib/time/Timezone.ci:33: (12 bytes): .result.name := ("GMT+3");
	<local+?>: load.c32 5
	<local+?>: load.ref <?> ;"GMT+3"
	<local+?>: set.x64 sp(3)
	<local+?>: ret
.usages:
}
Month: uint8 {
.kind: static const typename(ERR)
.base: `uint8`
.size: 1
.name: 'Month'
.file: 'cmplStd/lib/time/Datetime.ci:2'
.field January: uint8 (size: 0, cast: static const val)
.field February: uint8 (size: 0, cast: static const val)
.field March: uint8 (size: 0, cast: static const val)
.field April: uint8 (size: 0, cast: static const val)
.field May: uint8 (size: 0, cast: static const val)
.field June: uint8 (size: 0, cast: static const val)
.field July: uint8 (size: 0, cast: static const val)
.field August: uint8 (size: 0, cast: static const val)
.field September: uint8 (size: 0, cast: static const val)
.field October: uint8 (size: 0, cast: static const val)
.field November: uint8 (size: 0, cast: static const val)
.field December: uint8 (size: 0, cast: static const val)
.doc: 'Month of year, January is 1, February is 2, ...'
.usages:
	cmplStd/lib/time/Datetime.ci:159: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:159: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:157: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:157: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:63: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:19: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:19: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:17: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:17: referenced as `Month`
}
Month.January: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'January'
.file: 'cmplStd/lib/time/Datetime.ci:3'
.owner: Month
.doc: 'January'
.value: (1)
.usages:
	cmplStd/lib/time/Datetime.ci:159: referenced as `January`
	cmplStd/lib/time/Datetime.ci:157: referenced as `January`
	cmplStd/lib/time/Datetime.ci:19: referenced as `January`
	cmplStd/lib/time/Datetime.ci:17: referenced as `January`
}
Month.February: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'February'
.file: 'cmplStd/lib/time/Datetime.ci:4'
.owner: Month
.doc: 'February'
.value: (2)
.usages:
}
Month.March: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'March'
.file: 'cmplStd/lib/time/Datetime.ci:5'
.owner: Month
.doc: 'March'
.value: (3)
.usages:
}
Month.April: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'April'
.file: 'cmplStd/lib/time/Datetime.ci:6'
.owner: Month
.doc: 'April'
.value: (4)
.usages:
}
Month.May: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'May'
.file: 'cmplStd/lib/time/Datetime.ci:7'
.owner: Month
.doc: 'May'
.value: (5)
.usages:
}
Month.June: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'June'
.file: 'cmplStd/lib/time/Datetime.ci:8'
.owner: Month
.doc: 'June'
.value: (6)
.usages:
}
Month.July: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'July'
.file: 'cmplStd/lib/time/Datetime.ci:9'
.owner: Month
.doc: 'July'
.value: (7)
.usages:
}
Month.August: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'August'
.file: 'cmplStd/lib/time/Datetime.ci:10'
.owner: Month
.doc: 'August'
.value: (8)
.usages:
}
Month.September: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'September'
.file: 'cmplStd/lib/time/Datetime.ci:11'
.owner: Month
.doc: 'September'
.value: (9)
.usages:
}
Month.October: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'October'
.file: 'cmplStd/lib/time/Datetime.ci:12'
.owner: Month
.doc: 'October'
.value: (10)
.usages:
}
Month.November: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'November'
.file: 'cmplStd/lib/time/Datetime.ci:13'
.owner: Month
.doc: 'November'
.value: (11)
.usages:
}
Month.December: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'December'
.file: 'cmplStd/lib/time/Datetime.ci:14'
.owner: Month
.doc: 'December'
.value: (12)
.usages:
	cmplStd/lib/time/Datetime.ci:159: referenced as `December`
	cmplStd/lib/time/Datetime.ci:157: referenced as `December`
}
Month(index: int32): Month: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Month'
.file: 'cmplStd/lib/time/Datetime.ci:17'
.param .result: Month (size: 1, cast: u32)
.param index: int32 (size: 4, cast: i32)
.doc: 'FIXME: implement enum indexing'
.value: Month(emit(int32(index + (Month.(January)))))
.usages:
	cmplStd/lib/time/Datetime.ci:276: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:249: referenced as `Month`
	cmplStd/lib/time/Datetime.ci:133: referenced as `Month`
}
indexOf(value: Month): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'indexOf'
.file: 'cmplStd/lib/time/Datetime.ci:19'
.param .result: int32 (size: 4, cast: i32)
.param value: Month (size: 4, cast: u32)
.doc: 'FIXME: implement enum indexing'
.value: int32(value - (Month.(January)))
.usages:
	cmplStd/lib/text/Format.ci:405: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:381: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:354: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:350: referenced as `indexOf`
	cmplStd/lib/time/Datetime.ci:119: referenced as `indexOf`
}
Weekday: uint8 {
.kind: static const typename(ERR)
.base: `uint8`
.size: 1
.name: 'Weekday'
.file: 'cmplStd/lib/time/Datetime.ci:22'
.field Monday: uint8 (size: 0, cast: static const val)
.field Tuesday: uint8 (size: 0, cast: static const val)
.field Wednesday: uint8 (size: 0, cast: static const val)
.field Thursday: uint8 (size: 0, cast: static const val)
.field Friday: uint8 (size: 0, cast: static const val)
.field Saturday: uint8 (size: 0, cast: static const val)
.field Sunday: uint8 (size: 0, cast: static const val)
.doc: 'Day of week, Monday is 1, Tuesday is 2, ...'
.usages:
	cmplStd/lib/time/Datetime.ci:285: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:264: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:92: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:34: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:34: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:32: referenced as `Weekday`
	cmplStd/lib/time/Datetime.ci:32: referenced as `Weekday`
}
Weekday.Monday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Monday'
.file: 'cmplStd/lib/time/Datetime.ci:23'
.owner: Weekday
.doc: 'Monday'
.value: (1)
.usages:
	cmplStd/lib/time/Datetime.ci:285: referenced as `Monday`
	cmplStd/lib/time/Datetime.ci:34: referenced as `Monday`
	cmplStd/lib/time/Datetime.ci:32: referenced as `Monday`
}
Weekday.Tuesday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Tuesday'
.file: 'cmplStd/lib/time/Datetime.ci:24'
.owner: Weekday
.doc: 'Tuesday'
.value: (2)
.usages:
}
Weekday.Wednesday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Wednesday'
.file: 'cmplStd/lib/time/Datetime.ci:25'
.owner: Weekday
.doc: 'Wednesday'
.value: (3)
.usages:
}
Weekday.Thursday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Thursday'
.file: 'cmplStd/lib/time/Datetime.ci:26'
.owner: Weekday
.doc: 'Thursday'
.value: (4)
.usages:
	cmplStd/lib/time/Datetime.ci:264: referenced as `Thursday`
}
Weekday.Friday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Friday'
.file: 'cmplStd/lib/time/Datetime.ci:27'
.owner: Weekday
.doc: 'Friday'
.value: (5)
.usages:
}
Weekday.Saturday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Saturday'
.file: 'cmplStd/lib/time/Datetime.ci:28'
.owner: Weekday
.doc: 'Saturday'
.value: (6)
.usages:
}
Weekday.Sunday: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Sunday'
.file: 'cmplStd/lib/time/Datetime.ci:29'
.owner: Weekday
.doc: 'Sunday'
.value: (7)
.usages:
}
Weekday(index: int32): Weekday: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Weekday'
.file: 'cmplStd/lib/time/Datetime.ci:32'
.param .result: Weekday (size: 1, cast: u32)
.param index: int32 (size: 4, cast: i32)
.doc: 'FIXME: implement enum indexing'
.value: Weekday(emit(int32(index + (Weekday.(Monday)))))
.usages:
	cmplStd/lib/time/Datetime.ci:263: referenced as `Weekday`
}
indexOf(value: Weekday): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'indexOf'
.file: 'cmplStd/lib/time/Datetime.ci:34'
.param .result: int32 (size: 4, cast: i32)
.param value: Weekday (size: 4, cast: u32)
.doc: 'FIXME: implement enum indexing'
.value: int32(value - (Weekday.(Monday)))
.usages:
	cmplStd/lib/text/Format.ci:452: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:346: referenced as `indexOf`
	cmplStd/lib/text/Format.ci:342: referenced as `indexOf`
	cmplStd/lib/time/Datetime.ci:264: referenced as `indexOf`
}
Calendar: uint8 {
.kind: static const typename(ERR)
.base: `uint8`
.size: 1
.name: 'Calendar'
.file: 'cmplStd/lib/time/Datetime.ci:37'
.field Gregorian: uint8 (size: 0, cast: static const val)
.doc: 'Type of the calendar'
.usages:
	cmplStd/lib/time/Datetime.ci:270: referenced as `Calendar`
	cmplStd/lib/time/Datetime.ci:180: referenced as `Calendar`
	cmplStd/lib/time/Datetime.ci:179: referenced as `Calendar`
}
Calendar.Gregorian: uint8 {
.kind: static const val
.base: `uint8`
.size: 0
.name: 'Gregorian'
.file: 'cmplStd/lib/time/Datetime.ci:38'
.owner: Calendar
.doc: 'Gregorian'
.value: (0)
.usages:
	cmplStd/lib/time/Datetime.ci:270: referenced as `Gregorian`
	cmplStd/lib/time/Datetime.ci:180: referenced as `Gregorian`
}
Datetime: typename {
.kind: static const typename(val)
.base: `typename`
.size: 40
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:57'
.field year: int32 (size: 4, cast: const variable(i32))
.field month: Month (size: 1, cast: const variable(u32))
.field day: uint8 (size: 1, cast: const variable(u32))
.field hour: uint8 (size: 1, cast: const variable(u32))
.field minute: uint8 (size: 1, cast: const variable(u32))
.field second: uint8 (size: 1, cast: const variable(u32))
.field millis: uint16 (size: 2, cast: const variable(u32))
.field timezone: Timezone (size: 16, cast: const variable(val))
.field weekOfYear: uint8 (size: 1, cast: const variable(u32))
.field dayOfYear: uint16 (size: 2, cast: const variable(u32))
.field dayOfWeek: Weekday (size: 1, cast: const variable(u32))
.field leapYear: bool (size: 1, cast: const variable(bool))
.field DaysToMonth365: int32[13] (size: 52, cast: static const variable(val))
.field DaysToMonth366: int32[13] (size: 52, cast: static const variable(val))
.field DaysTil1970: int32 (size: 4, cast: static const variable(i32))
.field isLeapYear: function (size: 78, cast: static function)
.field add: function (size: 272, cast: static function)
.doc: 'DateTime represents the parts of an instant in time.'
.usages:
	cmplStd/lib/text/Format.ci:507: referenced as `Datetime`
	cmplStd/lib/text/Format.ci:501: referenced as `Datetime`
	cmplStd/lib/text/Format.ci:313: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:306: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:301: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:296: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:291: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:286: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:273: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:265: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:239: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:239: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:239: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:198: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:179: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:173: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:162: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:162: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:162: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:149: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:116: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:116: referenced as `Datetime`
}
Datetime.year: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'year'
.file: 'cmplStd/lib/time/Datetime.ci:61'
.owner: Datetime
.doc: 'Year: 1970'
.usages:
	cmplStd/lib/text/Format.ci:475: referenced as `year`
	cmplStd/lib/text/Format.ci:471: referenced as `year`
	cmplStd/lib/text/Format.ci:359: referenced as `year`
	cmplStd/lib/time/Datetime.ci:275: referenced as `year`
	cmplStd/lib/time/Datetime.ci:248: referenced as `year`
	cmplStd/lib/time/Datetime.ci:150: referenced as `year`
	cmplStd/lib/time/Datetime.ci:132: referenced as `year`
	cmplStd/lib/time/Datetime.ci:117: referenced as `year`
}
Datetime.month: Month {
.kind: const variable(u32)
.base: `Month`
.size: 1
.name: 'month'
.file: 'cmplStd/lib/time/Datetime.ci:63'
.owner: Datetime
.doc: 'Month of year: 1 ... 12 / [Jan, Feb, Mar, ...]'
.usages:
	cmplStd/lib/text/Format.ci:405: referenced as `month`
	cmplStd/lib/text/Format.ci:381: referenced as `month`
	cmplStd/lib/text/Format.ci:354: referenced as `month`
	cmplStd/lib/text/Format.ci:350: referenced as `month`
	cmplStd/lib/time/Datetime.ci:276: referenced as `month`
	cmplStd/lib/time/Datetime.ci:249: referenced as `month`
	cmplStd/lib/time/Datetime.ci:156: referenced as `month`
	cmplStd/lib/time/Datetime.ci:133: referenced as `month`
	cmplStd/lib/time/Datetime.ci:119: referenced as `month`
}
Datetime.day: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'day'
.file: 'cmplStd/lib/time/Datetime.ci:65'
.owner: Datetime
.doc: 'Day of month: 1 ... 30'
.usages:
	cmplStd/lib/text/Format.ci:371: referenced as `day`
	cmplStd/lib/text/Format.ci:363: referenced as `day`
	cmplStd/lib/time/Datetime.ci:277: referenced as `day`
	cmplStd/lib/time/Datetime.ci:250: referenced as `day`
	cmplStd/lib/time/Datetime.ci:164: referenced as `day`
	cmplStd/lib/time/Datetime.ci:134: referenced as `day`
	cmplStd/lib/time/Datetime.ci:134: referenced as `day`
}
Datetime.hour: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'hour'
.file: 'cmplStd/lib/time/Datetime.ci:70'
.owner: Datetime
.doc: 'Hour of day: 0 ... 23'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:426: referenced as `hour`
	cmplStd/lib/text/Format.ci:422: referenced as `hour`
	cmplStd/lib/text/Format.ci:401: referenced as `hour`
	cmplStd/lib/text/Format.ci:397: referenced as `hour`
	cmplStd/lib/text/Format.ci:389: referenced as `hour`
	cmplStd/lib/text/Format.ci:385: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:278: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:253: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:174: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:135: referenced as `hour`
	cmplStd/lib/time/Datetime.ci:135: referenced as `hour`
}
Datetime.minute: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'minute'
.file: 'cmplStd/lib/time/Datetime.ci:72'
.owner: Datetime
.doc: 'Minute of hour: 0 ... 59'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:409: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:279: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:254: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:174: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:136: referenced as `minute`
	cmplStd/lib/time/Datetime.ci:136: referenced as `minute`
}
Datetime.second: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'second'
.file: 'cmplStd/lib/time/Datetime.ci:74'
.owner: Datetime
.doc: 'Second of minute: 0 ... 59'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:440: referenced as `second`
	cmplStd/lib/time/Datetime.ci:280: referenced as `second`
	cmplStd/lib/time/Datetime.ci:255: referenced as `second`
	cmplStd/lib/time/Datetime.ci:174: referenced as `second`
	cmplStd/lib/time/Datetime.ci:137: referenced as `second`
	cmplStd/lib/time/Datetime.ci:137: referenced as `second`
}
Datetime.millis: uint16 {
.kind: const variable(u32)
.base: `uint16`
.size: 2
.name: 'millis'
.file: 'cmplStd/lib/time/Datetime.ci:76'
.owner: Datetime
.doc: 'Milliseconds of second: 0 ... 999'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:418: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:281: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:256: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:174: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:138: referenced as `millis`
	cmplStd/lib/time/Datetime.ci:138: referenced as `millis`
}
Datetime.timezone: Timezone {
.kind: const variable(val)
.base: `Timezone`
.size: 16
.name: 'timezone'
.file: 'cmplStd/lib/time/Datetime.ci:79'
.owner: Datetime
.doc: 'timezone'
.usages:
	cmplStd/lib/time/Datetime.ci:282: referenced as `timezone`
	cmplStd/lib/time/Datetime.ci:259: referenced as `timezone`
	cmplStd/lib/time/Datetime.ci:139: referenced as `timezone`
	cmplStd/lib/time/Datetime.ci:139: referenced as `timezone`
}
Datetime.weekOfYear: uint8 {
.kind: const variable(u32)
.base: `uint8`
.size: 1
.name: 'weekOfYear'
.file: 'cmplStd/lib/time/Datetime.ci:86'
.owner: Datetime
.doc: 'Nth week of the year: 1 ... 53'
.usages:
	cmplStd/lib/text/Format.ci:459: referenced as `weekOfYear`
	cmplStd/lib/time/Datetime.ci:283: referenced as `weekOfYear`
	cmplStd/lib/time/Datetime.ci:264: referenced as `weekOfYear`
	cmplStd/lib/time/Datetime.ci:140: referenced as `weekOfYear`
	cmplStd/lib/time/Datetime.ci:140: referenced as `weekOfYear`
}
Datetime.dayOfYear: uint16 {
.kind: const variable(u32)
.base: `uint16`
.size: 2
.name: 'dayOfYear'
.file: 'cmplStd/lib/time/Datetime.ci:89'
.owner: Datetime
.doc: 'Nth day of the year: 1 ... 365'
.usages:
	cmplStd/lib/text/Format.ci:393: referenced as `dayOfYear`
	cmplStd/lib/time/Datetime.ci:284: referenced as `dayOfYear`
	cmplStd/lib/time/Datetime.ci:262: referenced as `dayOfYear`
	cmplStd/lib/time/Datetime.ci:141: referenced as `dayOfYear`
	cmplStd/lib/time/Datetime.ci:141: referenced as `dayOfYear`
}
Datetime.dayOfWeek: Weekday {
.kind: const variable(u32)
.base: `Weekday`
.size: 1
.name: 'dayOfWeek'
.file: 'cmplStd/lib/time/Datetime.ci:92'
.owner: Datetime
.doc: 'Day of week: 1 ... 7 / [Mon, Tue, ...]'
.usages:
	cmplStd/lib/text/Format.ci:452: referenced as `dayOfWeek`
	cmplStd/lib/text/Format.ci:346: referenced as `dayOfWeek`
	cmplStd/lib/text/Format.ci:342: referenced as `dayOfWeek`
	cmplStd/lib/time/Datetime.ci:285: referenced as `dayOfWeek`
	cmplStd/lib/time/Datetime.ci:263: referenced as `dayOfWeek`
	cmplStd/lib/time/Datetime.ci:142: referenced as `dayOfWeek`
	cmplStd/lib/time/Datetime.ci:142: referenced as `dayOfWeek`
}
Datetime.leapYear: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'leapYear'
.file: 'cmplStd/lib/time/Datetime.ci:95'
.owner: Datetime
.doc: 'this is a leap year'
.usages:
	cmplStd/lib/time/Datetime.ci:286: referenced as `leapYear`
	cmplStd/lib/time/Datetime.ci:265: referenced as `leapYear`
	cmplStd/lib/time/Datetime.ci:143: referenced as `leapYear`
}
Datetime.DaysToMonth365: int32[13] {
.kind: static const variable(val)
.base: `int32[13]`
.size: 52
.name: 'DaysToMonth365'
.file: 'cmplStd/lib/time/Datetime.ci:97'
.owner: Datetime
.value: {
	DaysToMonth365[0] := 0;
	DaysToMonth365[1] := 31;
	DaysToMonth365[2] := 59;
	DaysToMonth365[3] := 90;
	DaysToMonth365[4] := 120;
	DaysToMonth365[5] := 151;
	DaysToMonth365[6] := 181;
	DaysToMonth365[7] := 212;
	DaysToMonth365[8] := 243;
	DaysToMonth365[9] := 273;
	DaysToMonth365[10] := 304;
	DaysToMonth365[11] := 334;
	DaysToMonth365[12] := 365;
}
.usages:
	cmplStd/lib/time/Datetime.ci:239: referenced as `DaysToMonth365`
	cmplStd/lib/time/Datetime.ci:162: referenced as `DaysToMonth365`
}
Datetime.DaysToMonth366: int32[13] {
.kind: static const variable(val)
.base: `int32[13]`
.size: 52
.name: 'DaysToMonth366'
.file: 'cmplStd/lib/time/Datetime.ci:98'
.owner: Datetime
.value: {
	DaysToMonth366[0] := 0;
	DaysToMonth366[1] := 31;
	DaysToMonth366[2] := 60;
	DaysToMonth366[3] := 91;
	DaysToMonth366[4] := 121;
	DaysToMonth366[5] := 152;
	DaysToMonth366[6] := 182;
	DaysToMonth366[7] := 213;
	DaysToMonth366[8] := 244;
	DaysToMonth366[9] := 274;
	DaysToMonth366[10] := 305;
	DaysToMonth366[11] := 335;
	DaysToMonth366[12] := 366;
}
.usages:
	cmplStd/lib/time/Datetime.ci:265: referenced as `DaysToMonth366`
	cmplStd/lib/time/Datetime.ci:239: referenced as `DaysToMonth366`
	cmplStd/lib/time/Datetime.ci:162: referenced as `DaysToMonth366`
}
Datetime.DaysTil1970: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.name: 'DaysTil1970'
.file: 'cmplStd/lib/time/Datetime.ci:99'
.owner: Datetime
.value: 719162
.usages:
	cmplStd/lib/time/Datetime.ci:198: referenced as `DaysTil1970`
	cmplStd/lib/time/Datetime.ci:173: referenced as `DaysTil1970`
}
Datetime.isLeapYear(year: int32): bool: function {
.kind: static function
.base: `function`
.size: 78
.name: 'isLeapYear'
.file: 'cmplStd/lib/time/Datetime.ci:102'
.owner: Datetime
.param .result: bool (size: 4, cast: variable(bool))
.param year: int32 (size: 4, cast: variable(i32))
.doc: 'Checks weather the given year is a leap year or not'
.value: {
	if (year % 4 != 0) {
		return .result := false;
	}
	if (year % 100 != 0) {
		return .result := true;
	}
	if (year % 400 != 0) {
		return .result := false;
	}
	return .result := true;
}
.instructions: (78 bytes)
	cmplStd/lib/time/Datetime.ci:103: (21 bytes): if (year % 4 != 0)
	<isLeapYear>  : dup.x32 sp(1)
	<isLeapYear+?>: load.c32 4
	<isLeapYear+?>: mod.i32
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: ceq.i32
	<isLeapYear+?>: jnz +11
	cmplStd/lib/time/Datetime.ci:104: (7 bytes): return .result := false;
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: load.sp(+12)
	<isLeapYear+?>: store.i8
	<isLeapYear+?>: ret
	cmplStd/lib/time/Datetime.ci:106: (25 bytes): if (year % 100 != 0)
	<isLeapYear+?>: dup.x32 sp(1)
	<isLeapYear+?>: load.c32 100
	<isLeapYear+?>: mod.i32
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: ceq.i32
	<isLeapYear+?>: jnz +15
	cmplStd/lib/time/Datetime.ci:107: (11 bytes): return .result := true;
	<isLeapYear+?>: load.c32 1
	<isLeapYear+?>: load.sp(+12)
	<isLeapYear+?>: store.i8
	<isLeapYear+?>: ret
	cmplStd/lib/time/Datetime.ci:109: (21 bytes): if (year % 400 != 0)
	<isLeapYear+?>: dup.x32 sp(1)
	<isLeapYear+?>: load.c32 400
	<isLeapYear+?>: mod.i32
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: ceq.i32
	<isLeapYear+?>: jnz +11
	cmplStd/lib/time/Datetime.ci:110: (7 bytes): return .result := false;
	<isLeapYear+?>: load.z32
	<isLeapYear+?>: load.sp(+12)
	<isLeapYear+?>: store.i8
	<isLeapYear+?>: ret
	cmplStd/lib/time/Datetime.ci:112: (11 bytes): return .result := true;
	<isLeapYear+?>: load.c32 1
	<isLeapYear+?>: load.sp(+12)
	<isLeapYear+?>: store.i8
	<isLeapYear+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:286: referenced as `isLeapYear`
	cmplStd/lib/time/Datetime.ci:239: referenced as `isLeapYear`
	cmplStd/lib/time/Datetime.ci:162: referenced as `isLeapYear`
	cmplStd/lib/time/Datetime.ci:143: referenced as `isLeapYear`
}
Datetime.add(cal: Datetime, years: int32, months: int32, days: int32): Datetime: function {
.kind: static function
.base: `function`
.size: 272
.name: 'add'
.file: 'cmplStd/lib/time/Datetime.ci:116'
.owner: Datetime
.param .result: Datetime (size: 40, cast: variable(val))
.param cal: Datetime (size: 40, cast: variable(val))
.param years: int32 (size: 4, cast: variable(i32))
.param months: int32 (size: 4, cast: variable(i32))
.param days: int32 (size: 4, cast: variable(i32))
.doc: 'Add the amount of `years`, `months` and `days` to the datetime'
.value: {
	year: int32 := cal.year + years;
	month: int32 := indexOf(cal.month) + months;
	if (month >= 12) {
		year := year + month / 12;
		month := month % 12;
	}
	else if (month < 0) {
		year := year + month / 12 - 1;
		month := 12 - (-month % 12);
	}
	assert(days == 0);
	return .result := {
			.result.year := year;
			.result.month := Month(month % 12);
			.result.day := cal.day;
			.result.hour := cal.hour;
			.result.minute := cal.minute;
			.result.second := cal.second;
			.result.millis := cal.millis;
			.result.timezone := cal.timezone;
			.result.weekOfYear := cal.weekOfYear;
			.result.dayOfYear := cal.dayOfYear;
			.result.dayOfWeek := cal.dayOfWeek;
			.result.leapYear := isLeapYear(year);
		};
}
.instructions: (272 bytes)
	cmplStd/lib/time/Datetime.ci:117: (5 bytes): year: int32 := cal.year + years
	<add>  : dup.x32 sp(4)
	<add+?>: dup.x32 sp(4)
	<add+?>: add.i32
	cmplStd/lib/time/Datetime.ci:119: (12 bytes): month: int32 := indexOf(cal.month) + months
	<add+?>: load.sp(+24)
	<add+?>: load.iu8
	<add+?>: inc.i32(-1)
	<add+?>: dup.x32 sp(4)
	<add+?>: add.i32
	cmplStd/lib/time/Datetime.ci:120: (77 bytes): if (month >= 12)
	<add+?>: dup.x32 sp(0)
	<add+?>: load.c32 12
	<add+?>: clt.i32
	<add+?>: jnz +27
	cmplStd/lib/time/Datetime.ci:121: (13 bytes): year := year + month / 12;
	<add+?>: dup.x32 sp(1)
	<add+?>: dup.x32 sp(1)
	<add+?>: load.c32 12
	<add+?>: div.i32
	<add+?>: add.i32
	<add+?>: set.x32 sp(2)
	cmplStd/lib/time/Datetime.ci:122: (6 bytes): month := month % 12;
	<add+?>: load.c32 12
	<add+?>: mod.i32
	<add+?>: jmp +46
	cmplStd/lib/time/Datetime.ci:124: (42 bytes): if (month < 0)
	<add+?>: dup.x32 sp(0)
	<add+?>: load.z32
	<add+?>: clt.i32
	<add+?>: jz +38
	cmplStd/lib/time/Datetime.ci:125: (17 bytes): year := year + month / 12 - 1;
	<add+?>: dup.x32 sp(1)
	<add+?>: dup.x32 sp(1)
	<add+?>: load.c32 12
	<add+?>: div.i32
	<add+?>: inc.i32(-1)
	<add+?>: add.i32
	<add+?>: set.x32 sp(2)
	cmplStd/lib/time/Datetime.ci:126: (17 bytes): month := 12 - (-month % 12);
	<add+?>: load.c32 12
	<add+?>: dup.x32 sp(1)
	<add+?>: neg.i32
	<add+?>: load.c32 12
	<add+?>: mod.i32
	<add+?>: sub.i32
	<add+?>: set.x32 sp(1)
	cmplStd/lib/time/Datetime.ci:129: (52 bytes): assert(days == 0);
	<add+?>: load.z32
	<add+?>: load.sp(+4)
	<add+?>: dup.x32 sp(5)
	<add+?>: load.z32
	<add+?>: ceq.i32
	<add+?>: jz +8
	<add+?>: jmp +35
	<add+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<add+?>: load.c32 129
	<add+?>: load.c32 -2
	<add+?>: load.c32 128
	<add+?>: load.ref <?> ;"assertion failed!"
	<add+?>: dup.x64 sp(5)
	<add+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<add+?>: inc.sp(-8)
	cmplStd/lib/time/Datetime.ci:131: (126 bytes): return .result := {...};
	cmplStd/lib/time/Datetime.ci:132: (3 bytes): .result.year := year;
	<add+?>: mov.x32 sp(16, 1)
	cmplStd/lib/time/Datetime.ci:133: (17 bytes): .result.month := Month(month % 12);
	<add+?>: dup.x32 sp(0)
	<add+?>: load.c32 12
	<add+?>: mod.i32
	<add+?>: inc.i32(+1)
	<add+?>: load.sp(+72)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:134: (10 bytes): .result.day := cal.day;
	<add+?>: load.sp(+29)
	<add+?>: load.iu8
	<add+?>: load.sp(+73)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:135: (10 bytes): .result.hour := cal.hour;
	<add+?>: load.sp(+30)
	<add+?>: load.iu8
	<add+?>: load.sp(+74)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:136: (10 bytes): .result.minute := cal.minute;
	<add+?>: load.sp(+31)
	<add+?>: load.iu8
	<add+?>: load.sp(+75)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:137: (10 bytes): .result.second := cal.second;
	<add+?>: load.sp(+32)
	<add+?>: load.iu8
	<add+?>: load.sp(+76)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:138: (10 bytes): .result.millis := cal.millis;
	<add+?>: load.sp(+34)
	<add+?>: load.iu16
	<add+?>: load.sp(+78)
	<add+?>: store.i16
	cmplStd/lib/time/Datetime.ci:139: (3 bytes): .result.timezone := cal.timezone;
	<add+?>: mov.x128 sp(20, 10)
	cmplStd/lib/time/Datetime.ci:140: (10 bytes): .result.weekOfYear := cal.weekOfYear;
	<add+?>: load.sp(+56)
	<add+?>: load.iu8
	<add+?>: load.sp(+100)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:141: (10 bytes): .result.dayOfYear := cal.dayOfYear;
	<add+?>: load.sp(+58)
	<add+?>: load.iu16
	<add+?>: load.sp(+102)
	<add+?>: store.i16
	cmplStd/lib/time/Datetime.ci:142: (10 bytes): .result.dayOfWeek := cal.dayOfWeek;
	<add+?>: load.sp(+60)
	<add+?>: load.iu8
	<add+?>: load.sp(+104)
	<add+?>: store.i8
	cmplStd/lib/time/Datetime.ci:143: (18 bytes): .result.leapYear := isLeapYear(year);
	<add+?>: load.z32
	<add+?>: dup.x32 sp(2)
	<add+?>: load.ref <?> ;Datetime.isLeapYear(year: int32): bool
	<add+?>: call
	<add+?>: inc.sp(-4)
	<add+?>: load.sp(+105)
	<add+?>: store.i8
	<add+?>: inc.sp(-8)
	<add+?>: ret
.usages:
}
Timestamp(value: Datetime): Timestamp: function {
.kind: static function
.base: `function`
.size: 626
.name: 'Timestamp'
.file: 'cmplStd/lib/time/Datetime.ci:149'
.param .result: Timestamp (size: 8, cast: variable(val))
.param value: Datetime (size: 40, cast: variable(val))
.doc: 'Convert the given Datetime `value` to a timestamp (milliseconds since 1970)'
.value: {
	year: int32 := value.year;
	if (year < 0 || year > 9999) {
		trace("invalid year", year);
		return .result := Timestamp(1 << 63, Timestamp.precision);
	}
	month: int32 := value.month;
	if (month < (Month.(January)) || month > (Month.(December))) {
		trace("invalid month", month);
		month := Math.clamp(month, int32(Month.(January)), int32(Month.(December)));
	}
	const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365;
	day: int32 := value.day;
	daysInYear: int32 := DaysToMonth[month - 1];
	daysInMonth: int32 := DaysToMonth[month] - daysInYear;
	if (day < 1 || day > daysInMonth) {
		trace("invalid day of month", day);
		day := Math.clamp(day, 1, daysInMonth);
	}
	y: int32 := year - 1;
	d: int64 := y * 365 + y / 4 - y / 100 + y / 400 + daysInYear + day - 1 - Datetime.DaysTil1970;
	t: int64 := (((d * (24) + (value.hour)) * (60) + (value.minute)) * (60) + (value.second)) * (1000) + (value.millis);
	return .result := Timestamp(t, Timeunit.(Millis));
}
.instructions: (626 bytes)
	cmplStd/lib/time/Datetime.ci:150: (2 bytes): year: int32 := value.year
	<Timestamp>  : dup.x32 sp(1)
	cmplStd/lib/time/Datetime.ci:151: (119 bytes): if (year < 0 || year > 9999)
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.z32
	<Timestamp+?>: clt.i32
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: jnz +16
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.c32 9999
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +97
	cmplStd/lib/time/Datetime.ci:152: (53 bytes): trace("invalid year", year);
	<Timestamp+?>: load.ref <?> ;int32
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<Timestamp+?>: load.c32 152
	<Timestamp+?>: load.c32 14
	<Timestamp+?>: load.c32 128
	<Timestamp+?>: load.ref <?> ;"invalid year"
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<Timestamp+?>: inc.sp(-16)
	cmplStd/lib/time/Datetime.ci:153: (40 bytes): return .result := Timestamp(1 << 63, Timestamp.precision);
	<Timestamp+?>: inc.sp(+8)
	<Timestamp+?>: load.c64 1
	<Timestamp+?>: load.c32 63
	<Timestamp+?>: shl.b64
	<Timestamp+?>: load.m64 <?> ;Timestamp.precision
	<Timestamp+?>: load.ref <?> ;Timestamp(value: int64, precision: Timeunit): Timestamp
	<Timestamp+?>: call
	<Timestamp+?>: inc.sp(-16)
	<Timestamp+?>: set.x64 sp(14)
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: ret
	cmplStd/lib/time/Datetime.ci:156: (5 bytes): month: int32 := value.month
	<Timestamp+?>: load.sp(+12)
	<Timestamp+?>: load.iu8
	cmplStd/lib/time/Datetime.ci:157: (141 bytes): if (month < (Month.(January)) || month > (Month.(December)))
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: clt.i32
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: jnz +16
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.c32 12
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +115
	cmplStd/lib/time/Datetime.ci:158: (53 bytes): trace("invalid month", month);
	<Timestamp+?>: load.ref <?> ;int32
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<Timestamp+?>: load.c32 158
	<Timestamp+?>: load.c32 14
	<Timestamp+?>: load.c32 128
	<Timestamp+?>: load.ref <?> ;"invalid month"
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<Timestamp+?>: inc.sp(-16)
	cmplStd/lib/time/Datetime.ci:159: (58 bytes): month := Math.clamp(month, int32(Month.(January)), int32(Month.(December)));
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +10
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: jmp +6
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: mov.x32 sp(2, 0)
	<Timestamp+?>: inc.sp(-8)
	<Timestamp+?>: load.c32 12
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: clt.i32
	<Timestamp+?>: jz +10
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: jmp +6
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: mov.x32 sp(2, 0)
	<Timestamp+?>: inc.sp(-8)
	cmplStd/lib/time/Datetime.ci:162: (31 bytes): const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365
	<Timestamp+?>: load.z32
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: load.ref <?> ;Datetime.isLeapYear(year: int32): bool
	<Timestamp+?>: call
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: jz +13
	<Timestamp+?>: load.ref <?> ;Datetime.DaysToMonth366
	<Timestamp+?>: jmp +9
	<Timestamp+?>: load.ref <?> ;Datetime.DaysToMonth365
	cmplStd/lib/time/Datetime.ci:164: (5 bytes): day: int32 := value.day
	<Timestamp+?>: load.sp(+21)
	<Timestamp+?>: load.iu8
	cmplStd/lib/time/Datetime.ci:165: (13 bytes): daysInYear: int32 := DaysToMonth[month - 1]
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(3)
	<Timestamp+?>: inc.i32(-1)
	<Timestamp+?>: mad.u32 4
	<Timestamp+?>: load.i32
	cmplStd/lib/time/Datetime.ci:166: (12 bytes): daysInMonth: int32 := DaysToMonth[month] - daysInYear
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: dup.x32 sp(4)
	<Timestamp+?>: mad.u32 4
	<Timestamp+?>: load.i32
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: sub.i32
	cmplStd/lib/time/Datetime.ci:167: (139 bytes): if (day < 1 || day > daysInMonth)
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: clt.i32
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: jnz +13
	<Timestamp+?>: inc.sp(-4)
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +116
	cmplStd/lib/time/Datetime.ci:168: (53 bytes): trace("invalid day of month", day);
	<Timestamp+?>: load.ref <?> ;int32
	<Timestamp+?>: load.sp(+12)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: load.sp(+4)
	<Timestamp+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<Timestamp+?>: load.c32 168
	<Timestamp+?>: load.c32 14
	<Timestamp+?>: load.c32 128
	<Timestamp+?>: load.ref <?> ;"invalid day of month"
	<Timestamp+?>: dup.x64 sp(5)
	<Timestamp+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<Timestamp+?>: inc.sp(-16)
	cmplStd/lib/time/Datetime.ci:169: (59 bytes): day := Math.clamp(day, 1, daysInMonth);
	<Timestamp+?>: dup.x32 sp(2)
	<Timestamp+?>: load.c32 1
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: cgt.i32
	<Timestamp+?>: jz +10
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: jmp +6
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: mov.x32 sp(2, 0)
	<Timestamp+?>: inc.sp(-8)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: clt.i32
	<Timestamp+?>: jz +10
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: jmp +6
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: mov.x32 sp(2, 0)
	<Timestamp+?>: inc.sp(-8)
	<Timestamp+?>: set.x32 sp(3)
	cmplStd/lib/time/Datetime.ci:172: (6 bytes): y: int32 := year - 1
	<Timestamp+?>: dup.x32 sp(5)
	<Timestamp+?>: inc.i32(-1)
	cmplStd/lib/time/Datetime.ci:173: (51 bytes): d: int64 := y * 365 + y / 4 - y / 100 + y / 400 + daysInYear + day - 1 - Datetime.DaysTil1970
	<Timestamp+?>: dup.x32 sp(0)
	<Timestamp+?>: load.c32 365
	<Timestamp+?>: mul.i32
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: load.c32 4
	<Timestamp+?>: div.i32
	<Timestamp+?>: add.i32
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: load.c32 100
	<Timestamp+?>: div.i32
	<Timestamp+?>: sub.i32
	<Timestamp+?>: dup.x32 sp(1)
	<Timestamp+?>: load.c32 400
	<Timestamp+?>: div.i32
	<Timestamp+?>: add.i32
	<Timestamp+?>: dup.x32 sp(3)
	<Timestamp+?>: add.i32
	<Timestamp+?>: dup.x32 sp(4)
	<Timestamp+?>: add.i32
	<Timestamp+?>: inc.i32(-1)
	<Timestamp+?>: load.m32 <?> ;Datetime.DaysTil1970
	<Timestamp+?>: sub.i32
	<Timestamp+?>: i32.2i64
	cmplStd/lib/time/Datetime.ci:174: (70 bytes): t: int64 := (((d * (24) + (value.hour)) * (60) + (value.minute)) * (60) + (value.second)) * (1000) + (value.millis)
	<Timestamp+?>: dup.x64 sp(0)
	<Timestamp+?>: load.c64 24
	<Timestamp+?>: mul.i64
	<Timestamp+?>: load.sp(+54)
	<Timestamp+?>: load.iu8
	<Timestamp+?>: u32.2i64
	<Timestamp+?>: add.i64
	<Timestamp+?>: load.c64 60
	<Timestamp+?>: mul.i64
	<Timestamp+?>: load.sp(+55)
	<Timestamp+?>: load.iu8
	<Timestamp+?>: u32.2i64
	<Timestamp+?>: add.i64
	<Timestamp+?>: load.c64 60
	<Timestamp+?>: mul.i64
	<Timestamp+?>: load.sp(+56)
	<Timestamp+?>: load.iu8
	<Timestamp+?>: u32.2i64
	<Timestamp+?>: add.i64
	<Timestamp+?>: load.c64 1000
	<Timestamp+?>: mul.i64
	<Timestamp+?>: load.sp(+58)
	<Timestamp+?>: load.iu16
	<Timestamp+?>: u32.2i64
	<Timestamp+?>: add.i64
	cmplStd/lib/time/Datetime.ci:175: (32 bytes): return .result := Timestamp(t, Timeunit.(Millis));
	<Timestamp+?>: inc.sp(+8)
	<Timestamp+?>: dup.x64 sp(2)
	<Timestamp+?>: load.c64 1000000
	<Timestamp+?>: load.ref <?> ;Timestamp(value: int64, precision: Timeunit): Timestamp
	<Timestamp+?>: call
	<Timestamp+?>: inc.sp(-16)
	<Timestamp+?>: set.x64 sp(24)
	<Timestamp+?>: inc.sp(-44)
	<Timestamp+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:436: referenced as `Timestamp`
}
Datetime(timestamp: Timestamp, calendar: Calendar, timezone: Timezone): Datetime: function {
.kind: static function
.base: `function`
.size: 630
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:179'
.param .result: Datetime (size: 40, cast: variable(val))
.param timestamp: Timestamp (size: 8, cast: variable(val))
.param calendar: Calendar (size: 4, cast: variable(u32))
.param timezone: Timezone (size: 16, cast: variable(val))
.doc: 'Convert the given `timestamp` to a datetime(year, month, day, ...) using the given `calendar` and `timezone`'
.value: {
	assert(calendar == (Calendar.(Gregorian)));
	offset: Duration := Timezone.offset(timezone, timestamp);
	timestamp := Timestamp.add(timestamp, offset.value, Duration.precision);
	n: int32 := (Datetime.DaysTil1970) + Timestamp.value(timestamp, Timeunit.(Days));
	dayOfWeek: int32 := n % 7;
	y400: int32 := n / DaysPer400Years;
	n := n - y400 * DaysPer400Years;
	y100: int32 := n / DaysPer100Years;
	if (y100 == 4) {
		y100 := 3;
	}
	n := n - y100 * DaysPer100Years;
	y4: int32 := n / DaysPer4Years;
	n := n - y4 * DaysPer4Years;
	y1: int32 := n / DaysPerYear;
	if (y1 == 4) {
		y1 := 3;
	}
	year: int32 := y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1;
	n := n - y1 * DaysPerYear;
	m: int32 := n >> 5 + 1;
	const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365;
	for ( ; n >= DaysToMonth[m]; ) {
		m := m + 1;
	}
	return .result := {
			.result.year := year;
			.result.month := Month(m - 1);
			.result.day := (n - DaysToMonth[m - 1] + 1);
			.result.hour := (Timestamp.value(timestamp, Timeunit.(Hours)) % (24));
			.result.minute := (Timestamp.value(timestamp, Timeunit.(Minutes)) % (60));
			.result.second := (Timestamp.value(timestamp, Timeunit.(Seconds)) % (60));
			.result.millis := (Timestamp.value(timestamp, Timeunit.(Millis)) % (1000));
			.result.timezone := timezone;
			.result.dayOfYear := (n + 1);
			.result.dayOfWeek := Weekday(dayOfWeek);
			.result.weekOfYear := ((n - dayOfWeek + indexOf(Weekday.(Thursday))) / 7 + 1);
			.result.leapYear := (DaysToMonth) == Datetime.DaysToMonth366;
		};
}
.instructions: (630 bytes)
	cmplStd/lib/time/Datetime.ci:180: (55 bytes): assert(calendar == (Calendar.(Gregorian)));
	<Datetime>  : load.z32
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: load.sp(+28)
	<Datetime+?>: load.iu8
	<Datetime+?>: load.z32
	<Datetime+?>: ceq.i32
	<Datetime+?>: jz +8
	<Datetime+?>: jmp +35
	<Datetime+?>: load.ref <?> ;"cmplStd/lib/time/Datetime.ci"
	<Datetime+?>: load.c32 180
	<Datetime+?>: load.c32 -2
	<Datetime+?>: load.c32 128
	<Datetime+?>: load.ref <?> ;"assertion failed!"
	<Datetime+?>: dup.x64 sp(5)
	<Datetime+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<Datetime+?>: inc.sp(-8)
	cmplStd/lib/time/Datetime.ci:196: (20 bytes): offset: Duration := Timezone.offset(timezone, timestamp)
	<Datetime+?>: inc.sp(+8)
	<Datetime+?>: load.sp(+12)
	<Datetime+?>: dup.x64 sp(9)
	<Datetime+?>: load.ref <?> ;Timezone.offset(zone: Timezone, timestamp: Timestamp): Duration
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-12)
	cmplStd/lib/time/Datetime.ci:197: (24 bytes): timestamp := Timestamp.add(timestamp, offset.value, Duration.precision);
	<Datetime+?>: inc.sp(+8)
	<Datetime+?>: dup.x64 sp(10)
	<Datetime+?>: dup.x64 sp(4)
	<Datetime+?>: load.m64 <?> ;Duration.precision
	<Datetime+?>: load.ref <?> ;Timestamp.add(lhs: Timestamp, value: int64, precision: Timeunit): Timestamp
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-24)
	<Datetime+?>: set.x64 sp(10)
	cmplStd/lib/time/Datetime.ci:198: (29 bytes): n: int32 := (Datetime.DaysTil1970) + Timestamp.value(timestamp, Timeunit.(Days))
	<Datetime+?>: load.m32 <?> ;Datetime.DaysTil1970
	<Datetime+?>: i32.2i64
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(12)
	<Datetime+?>: load.c64 86400000000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: add.i64
	<Datetime+?>: i64.2i32
	cmplStd/lib/time/Datetime.ci:201: (8 bytes): dayOfWeek: int32 := n % 7
	<Datetime+?>: dup.x32 sp(0)
	<Datetime+?>: load.c32 7
	<Datetime+?>: mod.i32
	cmplStd/lib/time/Datetime.ci:204: (8 bytes): y400: int32 := n / DaysPer400Years
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: load.c32 146097
	<Datetime+?>: div.i32
	cmplStd/lib/time/Datetime.ci:206: (13 bytes): n := n - y400 * DaysPer400Years;
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: load.c32 146097
	<Datetime+?>: mul.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: set.x32 sp(3)
	cmplStd/lib/time/Datetime.ci:209: (8 bytes): y100: int32 := n / DaysPer100Years
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: load.c32 36524
	<Datetime+?>: div.i32
	cmplStd/lib/time/Datetime.ci:212: (19 bytes): if (y100 == 4)
	<Datetime+?>: dup.x32 sp(0)
	<Datetime+?>: load.c32 4
	<Datetime+?>: ceq.i32
	<Datetime+?>: jz +11
	cmplStd/lib/time/Datetime.ci:213: (7 bytes): y100 := 3;
	<Datetime+?>: load.c32 3
	<Datetime+?>: set.x32 sp(1)
	cmplStd/lib/time/Datetime.ci:216: (13 bytes): n := n - y100 * DaysPer100Years;
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: load.c32 36524
	<Datetime+?>: mul.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: set.x32 sp(4)
	cmplStd/lib/time/Datetime.ci:219: (8 bytes): y4: int32 := n / DaysPer4Years
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: load.c32 1461
	<Datetime+?>: div.i32
	cmplStd/lib/time/Datetime.ci:221: (13 bytes): n := n - y4 * DaysPer4Years;
	<Datetime+?>: dup.x32 sp(4)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: load.c32 1461
	<Datetime+?>: mul.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: set.x32 sp(5)
	cmplStd/lib/time/Datetime.ci:224: (8 bytes): y1: int32 := n / DaysPerYear
	<Datetime+?>: dup.x32 sp(4)
	<Datetime+?>: load.c32 365
	<Datetime+?>: div.i32
	cmplStd/lib/time/Datetime.ci:226: (19 bytes): if (y1 == 4)
	<Datetime+?>: dup.x32 sp(0)
	<Datetime+?>: load.c32 4
	<Datetime+?>: ceq.i32
	<Datetime+?>: jz +11
	cmplStd/lib/time/Datetime.ci:227: (7 bytes): y1 := 3;
	<Datetime+?>: load.c32 3
	<Datetime+?>: set.x32 sp(1)
	cmplStd/lib/time/Datetime.ci:231: (33 bytes): year: int32 := y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: load.c32 400
	<Datetime+?>: mul.i32
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: load.c32 100
	<Datetime+?>: mul.i32
	<Datetime+?>: add.i32
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: load.c32 4
	<Datetime+?>: mul.i32
	<Datetime+?>: add.i32
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: add.i32
	<Datetime+?>: inc.i32(+1)
	cmplStd/lib/time/Datetime.ci:234: (13 bytes): n := n - y1 * DaysPerYear;
	<Datetime+?>: dup.x32 sp(6)
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: load.c32 365
	<Datetime+?>: mul.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: set.x32 sp(7)
	cmplStd/lib/time/Datetime.ci:238: (12 bytes): m: int32 := n >> 5 + 1
	<Datetime+?>: dup.x32 sp(6)
	<Datetime+?>: load.c32 5
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: sar.b32
	cmplStd/lib/time/Datetime.ci:239: (31 bytes): const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365
	<Datetime+?>: load.z32
	<Datetime+?>: dup.x32 sp(2)
	<Datetime+?>: load.ref <?> ;Datetime.isLeapYear(year: int32): bool
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-4)
	<Datetime+?>: jz +13
	<Datetime+?>: load.ref <?> ;Datetime.DaysToMonth366
	<Datetime+?>: jmp +9
	<Datetime+?>: load.ref <?> ;Datetime.DaysToMonth365
	cmplStd/lib/time/Datetime.ci:242: (28 bytes): for ( ; n >= DaysToMonth[m]; )
	<Datetime+?>: jmp +12
	cmplStd/lib/time/Datetime.ci:243: (8 bytes): m := m + 1;
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: set.x32 sp(2)
	cmplStd/lib/time/Datetime.ci:242: (16 bytes): n >= DaysToMonth[m]
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: mad.u32 4
	<Datetime+?>: load.i32
	<Datetime+?>: clt.i32
	<Datetime+?>: jz -20
	cmplStd/lib/time/Datetime.ci:246: (268 bytes): return .result := {...};
	cmplStd/lib/time/Datetime.ci:248: (3 bytes): .result.year := year;
	<Datetime+?>: mov.x32 sp(19, 2)
	cmplStd/lib/time/Datetime.ci:249: (15 bytes): .result.month := Month(m - 1);
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: inc.i32(-1)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+84)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:250: (25 bytes): .result.day := (n - DaysToMonth[m - 1] + 1);
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: dup.x32 sp(1)
	<Datetime+?>: dup.x32 sp(3)
	<Datetime+?>: inc.i32(-1)
	<Datetime+?>: mad.u32 4
	<Datetime+?>: load.i32
	<Datetime+?>: sub.i32
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+85)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:253: (38 bytes): .result.hour := (Timestamp.value(timestamp, Timeunit.(Hours)) % (24));
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(19)
	<Datetime+?>: load.c64 3600000000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: load.c64 24
	<Datetime+?>: mod.i64
	<Datetime+?>: i64.2i32
	<Datetime+?>: load.sp(+86)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:254: (38 bytes): .result.minute := (Timestamp.value(timestamp, Timeunit.(Minutes)) % (60));
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(19)
	<Datetime+?>: load.c64 60000000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: load.c64 60
	<Datetime+?>: mod.i64
	<Datetime+?>: i64.2i32
	<Datetime+?>: load.sp(+87)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:255: (38 bytes): .result.second := (Timestamp.value(timestamp, Timeunit.(Seconds)) % (60));
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(19)
	<Datetime+?>: load.c64 1000000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: load.c64 60
	<Datetime+?>: mod.i64
	<Datetime+?>: i64.2i32
	<Datetime+?>: load.sp(+88)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:256: (38 bytes): .result.millis := (Timestamp.value(timestamp, Timeunit.(Millis)) % (1000));
	<Datetime+?>: load.z64
	<Datetime+?>: dup.x64 sp(19)
	<Datetime+?>: load.c64 1000000
	<Datetime+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-16)
	<Datetime+?>: load.c64 1000
	<Datetime+?>: mod.i64
	<Datetime+?>: i64.2i32
	<Datetime+?>: load.sp(+90)
	<Datetime+?>: store.i16
	cmplStd/lib/time/Datetime.ci:259: (3 bytes): .result.timezone := timezone;
	<Datetime+?>: mov.x128 sp(23, 12)
	cmplStd/lib/time/Datetime.ci:262: (11 bytes): .result.dayOfYear := (n + 1);
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+114)
	<Datetime+?>: store.i16
	cmplStd/lib/time/Datetime.ci:263: (11 bytes): .result.dayOfWeek := Weekday(dayOfWeek);
	<Datetime+?>: dup.x32 sp(7)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+116)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:264: (30 bytes): .result.weekOfYear := ((n - dayOfWeek + indexOf(Weekday.(Thursday))) / 7 + 1);
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: sub.i32
	<Datetime+?>: load.c32 4
	<Datetime+?>: inc.i32(-1)
	<Datetime+?>: add.i32
	<Datetime+?>: load.c32 7
	<Datetime+?>: div.i32
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+112)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:265: (13 bytes): .result.leapYear := (DaysToMonth) == Datetime.DaysToMonth366;
	<Datetime+?>: dup.x32 sp(0)
	<Datetime+?>: load.ref <?> ;Datetime.DaysToMonth366
	<Datetime+?>: ceq.i32
	<Datetime+?>: load.sp(+117)
	<Datetime+?>: store.i8
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:270: referenced as `Datetime`
}
Datetime(timestamp: Timestamp): Datetime: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:270'
.param .result: Datetime (size: 40, cast: val)
.param timestamp: Timestamp (size: 8, cast: val)
.doc: 'Convert the given timestamp to a datetime'
.value: Datetime(timestamp, Calendar.(Gregorian), Timezone.utc())
.usages:
}
Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime: function {
.kind: static function
.base: `function`
.size: 97
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:273'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.param hour: int32 (size: 4, cast: variable(i32))
.param minute: int32 (size: 4, cast: variable(i32))
.param second: int32 (size: 4, cast: variable(i32))
.param millis: int32 (size: 4, cast: variable(i32))
.param zone: Timezone (size: 16, cast: variable(val))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := {
			.result.year := year;
			.result.month := Month(month - 1);
			.result.day := (day);
			.result.hour := (hour);
			.result.minute := (minute);
			.result.second := (second);
			.result.millis := (millis);
			.result.timezone := zone;
			.result.weekOfYear := (0);
			.result.dayOfYear := (0);
			.result.dayOfWeek := Weekday.(Monday);
			.result.leapYear := Datetime.isLeapYear(year);
		};
}
.instructions: (97 bytes)
	cmplStd/lib/time/Datetime.ci:274: (97 bytes): return .result := {...};
	cmplStd/lib/time/Datetime.ci:275: (3 bytes): .result.year := year;
	<Datetime>  : mov.x32 sp(12, 11)
	cmplStd/lib/time/Datetime.ci:276: (15 bytes): .result.month := Month(month - 1);
	<Datetime+?>: dup.x32 sp(10)
	<Datetime+?>: inc.i32(-1)
	<Datetime+?>: inc.i32(+1)
	<Datetime+?>: load.sp(+56)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:277: (7 bytes): .result.day := (day);
	<Datetime+?>: dup.x32 sp(9)
	<Datetime+?>: load.sp(+57)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:278: (7 bytes): .result.hour := (hour);
	<Datetime+?>: dup.x32 sp(8)
	<Datetime+?>: load.sp(+58)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:279: (7 bytes): .result.minute := (minute);
	<Datetime+?>: dup.x32 sp(7)
	<Datetime+?>: load.sp(+59)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:280: (7 bytes): .result.second := (second);
	<Datetime+?>: dup.x32 sp(6)
	<Datetime+?>: load.sp(+60)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:281: (7 bytes): .result.millis := (millis);
	<Datetime+?>: dup.x32 sp(5)
	<Datetime+?>: load.sp(+62)
	<Datetime+?>: store.i16
	cmplStd/lib/time/Datetime.ci:282: (3 bytes): .result.timezone := zone;
	<Datetime+?>: mov.x128 sp(16, 1)
	cmplStd/lib/time/Datetime.ci:283: (6 bytes): .result.weekOfYear := (0);
	<Datetime+?>: load.z32
	<Datetime+?>: load.sp(+84)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:284: (6 bytes): .result.dayOfYear := (0);
	<Datetime+?>: load.z32
	<Datetime+?>: load.sp(+86)
	<Datetime+?>: store.i16
	cmplStd/lib/time/Datetime.ci:285: (10 bytes): .result.dayOfWeek := Weekday.(Monday);
	<Datetime+?>: load.c32 1
	<Datetime+?>: load.sp(+88)
	<Datetime+?>: store.i8
	cmplStd/lib/time/Datetime.ci:286: (18 bytes): .result.leapYear := Datetime.isLeapYear(year);
	<Datetime+?>: load.z32
	<Datetime+?>: dup.x32 sp(12)
	<Datetime+?>: load.ref <?> ;Datetime.isLeapYear(year: int32): bool
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-4)
	<Datetime+?>: load.sp(+89)
	<Datetime+?>: store.i8
	<Datetime+?>: ret
.usages:
	cmplStd/lib/time/Datetime.ci:307: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:302: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:297: referenced as `Datetime`
	cmplStd/lib/time/Datetime.ci:292: referenced as `Datetime`
}
Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32): Datetime: function {
.kind: static function
.base: `function`
.size: 55
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:291'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.param hour: int32 (size: 4, cast: variable(i32))
.param minute: int32 (size: 4, cast: variable(i32))
.param second: int32 (size: 4, cast: variable(i32))
.param millis: int32 (size: 4, cast: variable(i32))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := Datetime(year, month, day, hour, minute, second, millis, Timezone.utc());
}
.instructions: (55 bytes)
	cmplStd/lib/time/Datetime.ci:292: (55 bytes): return .result := Datetime(year, month, day, hour, minute, second, millis, Timezone.utc());
	<Datetime>  : inc.sp(+40)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: inc.sp(+16)
	<Datetime+?>: load.ref <?> ;Timezone.utc(): Timezone
	<Datetime+?>: call
	<Datetime+?>: load.ref <?> ;Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: load.sp(+72)
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: copy.mem 40
	<Datetime+?>: inc.sp(-40)
	<Datetime+?>: ret
.usages:
}
Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, zone: Timezone): Datetime: function {
.kind: static function
.base: `function`
.size: 46
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:296'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.param hour: int32 (size: 4, cast: variable(i32))
.param minute: int32 (size: 4, cast: variable(i32))
.param second: int32 (size: 4, cast: variable(i32))
.param zone: Timezone (size: 16, cast: variable(val))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := Datetime(year, month, day, hour, minute, second, 0, zone);
}
.instructions: (46 bytes)
	cmplStd/lib/time/Datetime.ci:297: (46 bytes): return .result := Datetime(year, month, day, hour, minute, second, 0, zone);
	<Datetime>  : inc.sp(+40)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: dup.x32 sp(20)
	<Datetime+?>: load.z32
	<Datetime+?>: dup.x128 sp(18)
	<Datetime+?>: load.ref <?> ;Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: load.sp(+84)
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: copy.mem 40
	<Datetime+?>: inc.sp(-40)
	<Datetime+?>: ret
.usages:
}
Datetime(year: int32, month: int32, day: int32, zone: Timezone): Datetime: function {
.kind: static function
.base: `function`
.size: 43
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:301'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.param zone: Timezone (size: 16, cast: variable(val))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := Datetime(year, month, day, 0, 0, 0, 0, zone);
}
.instructions: (43 bytes)
	cmplStd/lib/time/Datetime.ci:302: (43 bytes): return .result := Datetime(year, month, day, 0, 0, 0, 0, zone);
	<Datetime>  : inc.sp(+40)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: dup.x32 sp(17)
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: dup.x128 sp(18)
	<Datetime+?>: load.ref <?> ;Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: load.sp(+72)
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: copy.mem 40
	<Datetime+?>: inc.sp(-40)
	<Datetime+?>: ret
.usages:
}
Datetime(year: int32, month: int32, day: int32): Datetime: function {
.kind: static function
.base: `function`
.size: 51
.name: 'Datetime'
.file: 'cmplStd/lib/time/Datetime.ci:306'
.param .result: Datetime (size: 40, cast: variable(val))
.param year: int32 (size: 4, cast: variable(i32))
.param month: int32 (size: 4, cast: variable(i32))
.param day: int32 (size: 4, cast: variable(i32))
.doc: 'Construct the Datetime from the given parts'
.value: {
	return .result := Datetime(year, month, day, 0, 0, 0, 0, Timezone.utc());
}
.instructions: (51 bytes)
	cmplStd/lib/time/Datetime.ci:307: (51 bytes): return .result := Datetime(year, month, day, 0, 0, 0, 0, Timezone.utc());
	<Datetime>  : inc.sp(+40)
	<Datetime+?>: dup.x32 sp(13)
	<Datetime+?>: dup.x32 sp(13)
	<Datetime+?>: dup.x32 sp(13)
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: load.z32
	<Datetime+?>: inc.sp(+16)
	<Datetime+?>: load.ref <?> ;Timezone.utc(): Timezone
	<Datetime+?>: call
	<Datetime+?>: load.ref <?> ;Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime
	<Datetime+?>: call
	<Datetime+?>: inc.sp(-44)
	<Datetime+?>: load.sp(+56)
	<Datetime+?>: load.sp(+4)
	<Datetime+?>: copy.mem 40
	<Datetime+?>: inc.sp(-40)
	<Datetime+?>: ret
.usages:
}
length(str: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 38
.name: 'length'
.file: 'cmplStd/lib/text/cstr.ci:4'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.doc: 'Computes the length of the string'
.value: {
	if ((str) == null) {
		return .result := 0;
	}
	result: int32 := 0;
	for ( ; str[result]; result := result + 1) ;
	return .result := result;
}
.instructions: (38 bytes)
	cmplStd/lib/text/cstr.ci:5: (16 bytes): if ((str) == null)
	<length>  : dup.x32 sp(1)
	<length+?>: load.ref <?> ;null
	<length+?>: ceq.i32
	<length+?>: jz +8
	cmplStd/lib/text/cstr.ci:6: (4 bytes): return .result := 0;
	<length+?>: load.z32
	<length+?>: set.x32 sp(3)
	<length+?>: ret
	cmplStd/lib/text/cstr.ci:8: (1 byte): result: int32 := 0
	<length+?>: load.z32
	cmplStd/lib/text/cstr.ci:9: (18 bytes): for ( ; str[result]; result := result + 1)
	<length+?>: jmp +8
	cmplStd/lib/text/cstr.ci:9: (4 bytes): result := result + 1
	<length+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:9: (10 bytes): str[result]
	<length+?>: dup.x32 sp(2)
	<length+?>: dup.x32 sp(1)
	<length+?>: add.i32
	<length+?>: load.is8
	<length+?>: jnz -10
	cmplStd/lib/text/cstr.ci:11: (3 bytes): return .result := result;
	<length+?>: set.x32 sp(3)
	<length+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:48: referenced as `length`
	cmplStd/lib/text/cstr.ci:47: referenced as `length`
}
indexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.name: 'indexOf'
.file: 'cmplStd/lib/text/cstr.ci:15'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the first occurrence of a character in string'
.value: {
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			return .result := i;
		}
	}
	return .result := -1;
}
.instructions: (50 bytes)
	cmplStd/lib/text/cstr.ci:16: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<indexOf>  : load.z32
	<indexOf+?>: jmp +27
	cmplStd/lib/text/cstr.ci:17: (19 bytes): if (str[i] == chr)
	<indexOf+?>: dup.x32 sp(3)
	<indexOf+?>: dup.x32 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.is8
	<indexOf+?>: load.sp(+12)
	<indexOf+?>: load.is8
	<indexOf+?>: ceq.i32
	<indexOf+?>: jz +7
	cmplStd/lib/text/cstr.ci:18: (3 bytes): return .result := i;
	<indexOf+?>: set.x32 sp(4)
	<indexOf+?>: ret
	cmplStd/lib/text/cstr.ci:16: (4 bytes): i := i + 1
	<indexOf+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:16: (10 bytes): str[i]
	<indexOf+?>: dup.x32 sp(3)
	<indexOf+?>: dup.x32 sp(1)
	<indexOf+?>: add.i32
	<indexOf+?>: load.is8
	<indexOf+?>: jnz -29
	<indexOf+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:21: (8 bytes): return .result := -1;
	<indexOf+?>: load.c32 -1
	<indexOf+?>: set.x32 sp(4)
	<indexOf+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:105: referenced as `indexOf`
}
lastIndexOf(str: char[*], chr: char): int32: function {
.kind: static function
.base: `function`
.size: 50
.name: 'lastIndexOf'
.file: 'cmplStd/lib/text/cstr.ci:25'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.param chr: char (size: 4, cast: variable(i32))
.doc: 'Returns the index of the last occurrence of a character in string'
.value: {
	result: int32 := -1;
	for (i: int32 := 0; str[i]; i := i + 1) {
		if (str[i] == chr) {
			result := i;
		}
	}
	return .result := result;
}
.instructions: (50 bytes)
	cmplStd/lib/text/cstr.ci:26: (5 bytes): result: int32 := -1
	<lastIndexOf>  : load.c32 -1
	cmplStd/lib/text/cstr.ci:27: (42 bytes): for (i: int32 := 0; str[i]; i := i + 1)
	<lastIndexOf+?>: load.z32
	<lastIndexOf+?>: jmp +27
	cmplStd/lib/text/cstr.ci:28: (19 bytes): if (str[i] == chr)
	<lastIndexOf+?>: dup.x32 sp(4)
	<lastIndexOf+?>: dup.x32 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.is8
	<lastIndexOf+?>: load.sp(+16)
	<lastIndexOf+?>: load.is8
	<lastIndexOf+?>: ceq.i32
	<lastIndexOf+?>: jz +7
	cmplStd/lib/text/cstr.ci:29: (3 bytes): result := i;
	<lastIndexOf+?>: mov.x32 sp(1, 0)
	cmplStd/lib/text/cstr.ci:27: (4 bytes): i := i + 1
	<lastIndexOf+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:27: (10 bytes): str[i]
	<lastIndexOf+?>: dup.x32 sp(4)
	<lastIndexOf+?>: dup.x32 sp(1)
	<lastIndexOf+?>: add.i32
	<lastIndexOf+?>: load.is8
	<lastIndexOf+?>: jnz -29
	<lastIndexOf+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:32: (3 bytes): return .result := result;
	<lastIndexOf+?>: set.x32 sp(4)
	<lastIndexOf+?>: ret
.usages:
}
startsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 73
.name: 'startsWith'
.file: 'cmplStd/lib/text/cstr.ci:36'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: const variable(ref))
.param with: char[*] (size: 4, cast: const variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string begins with a specified string, using a custom comparator'
.value: {
	for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
		if (cmp(str[i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (73 bytes)
	cmplStd/lib/text/cstr.ci:37: (62 bytes): for (i: int32 := 0; (with[i]) != 0; i := i + 1)
	<startsWith>  : load.z32
	<startsWith+?>: jmp +45
	cmplStd/lib/text/cstr.ci:38: (37 bytes): if (cmp(str[i], with[i]) != 0)
	<startsWith+?>: load.z32
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: dup.x32 sp(2)
	<startsWith+?>: add.i32
	<startsWith+?>: load.is8
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: dup.x32 sp(3)
	<startsWith+?>: add.i32
	<startsWith+?>: load.is8
	<startsWith+?>: dup.x32 sp(5)
	<startsWith+?>: call
	<startsWith+?>: inc.sp(-8)
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jnz +15
	cmplStd/lib/text/cstr.ci:39: (11 bytes): return .result := false;
	<startsWith+?>: load.z32
	<startsWith+?>: load.sp(+24)
	<startsWith+?>: store.i8
	<startsWith+?>: inc.sp(-4)
	<startsWith+?>: ret
	cmplStd/lib/text/cstr.ci:37: (4 bytes): i := i + 1
	<startsWith+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:37: (12 bytes): (with[i]) != 0
	<startsWith+?>: dup.x32 sp(3)
	<startsWith+?>: dup.x32 sp(1)
	<startsWith+?>: add.i32
	<startsWith+?>: load.is8
	<startsWith+?>: load.z32
	<startsWith+?>: ceq.i32
	<startsWith+?>: jz -49
	<startsWith+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:42: (11 bytes): return .result := true;
	<startsWith+?>: load.c32 1
	<startsWith+?>: load.sp(+20)
	<startsWith+?>: store.i8
	<startsWith+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:96: referenced as `startsWith`
}
endsWith(str: char[*], with: char[*], cmp(chr: char, with: char): int32): bool: function {
.kind: static function
.base: `function`
.size: 126
.name: 'endsWith'
.file: 'cmplStd/lib/text/cstr.ci:46'
.param .result: bool (size: 4, cast: variable(bool))
.param str: char[*] (size: 4, cast: const variable(ref))
.param with: char[*] (size: 4, cast: const variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if a string ends in a specified string, using a custom comparator'
.value: {
	withLen: int32 := length(with);
	strLen: int32 := length(str);
	if (strLen < withLen) {
		return .result := false;
	}
	for (i: int32 := 0; i < withLen; i := i + 1) {
		if (cmp(str[strLen - withLen + i], with[i]) != 0) {
			return .result := false;
		}
	}
	return .result := true;
}
.instructions: (126 bytes)
	cmplStd/lib/text/cstr.ci:47: (13 bytes): withLen: int32 := length(with)
	<endsWith>  : load.z32
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:48: (13 bytes): strLen: int32 := length(str)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x32 sp(5)
	<endsWith+?>: load.ref <?> ;length(str: char[*]): int32
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:49: (20 bytes): if (strLen < withLen)
	<endsWith+?>: dup.x32 sp(0)
	<endsWith+?>: dup.x32 sp(2)
	<endsWith+?>: clt.i32
	<endsWith+?>: jz +15
	cmplStd/lib/text/cstr.ci:50: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
	cmplStd/lib/text/cstr.ci:52: (65 bytes): for (i: int32 := 0; i < withLen; i := i + 1)
	<endsWith+?>: load.z32
	<endsWith+?>: jmp +51
	cmplStd/lib/text/cstr.ci:53: (43 bytes): if (cmp(str[strLen - withLen + i], with[i]) != 0)
	<endsWith+?>: load.z32
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: dup.x32 sp(5)
	<endsWith+?>: sub.i32
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: add.i32
	<endsWith+?>: load.is8
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: add.i32
	<endsWith+?>: load.is8
	<endsWith+?>: dup.x32 sp(7)
	<endsWith+?>: call
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: load.z32
	<endsWith+?>: ceq.i32
	<endsWith+?>: jnz +15
	cmplStd/lib/text/cstr.ci:54: (11 bytes): return .result := false;
	<endsWith+?>: load.z32
	<endsWith+?>: load.sp(+32)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-12)
	<endsWith+?>: ret
	cmplStd/lib/text/cstr.ci:52: (4 bytes): i := i + 1
	<endsWith+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:52: (9 bytes): i < withLen
	<endsWith+?>: dup.x32 sp(0)
	<endsWith+?>: dup.x32 sp(3)
	<endsWith+?>: clt.i32
	<endsWith+?>: jnz -52
	<endsWith+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:57: (15 bytes): return .result := true;
	<endsWith+?>: load.c32 1
	<endsWith+?>: load.sp(+28)
	<endsWith+?>: store.i8
	<endsWith+?>: inc.sp(-8)
	<endsWith+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:98: referenced as `endsWith`
}
compare(str: char[*], with: char[*], cmp(chr: char, with: char): int32): int32: function {
.kind: static function
.base: `function`
.size: 63
.name: 'compare'
.file: 'cmplStd/lib/text/cstr.ci:61'
.param .result: int32 (size: 4, cast: variable(i32))
.param str: char[*] (size: 4, cast: const variable(ref))
.param with: char[*] (size: 4, cast: const variable(ref))
.param cmp: function (size: 4, cast: variable(ref))
.doc: 'Check if the two strings are equal, less or greater, using a custom comparator'
.value: {
	result: int32 := 0;
	for (i: int32 := 0; result == 0; i := i + 1) {
		result := cmp(str[i], with[i]);
		if ((str[i]) == 0) {
			break;
		}
	}
	return .result := result;
}
.instructions: (63 bytes)
	cmplStd/lib/text/cstr.ci:62: (1 byte): result: int32 := 0
	<compare>  : load.z32
	cmplStd/lib/text/cstr.ci:63: (59 bytes): for (i: int32 := 0; result == 0; i := i + 1)
	<compare+?>: load.z32
	<compare+?>: jmp +46
	cmplStd/lib/text/cstr.ci:64: (22 bytes): result := cmp(str[i], with[i]);
	<compare+?>: load.z32
	<compare+?>: dup.x32 sp(6)
	<compare+?>: dup.x32 sp(2)
	<compare+?>: add.i32
	<compare+?>: load.is8
	<compare+?>: dup.x32 sp(6)
	<compare+?>: dup.x32 sp(3)
	<compare+?>: add.i32
	<compare+?>: load.is8
	<compare+?>: dup.x32 sp(6)
	<compare+?>: call
	<compare+?>: inc.sp(-8)
	<compare+?>: set.x32 sp(2)
	cmplStd/lib/text/cstr.ci:65: (16 bytes): if ((str[i]) == 0)
	<compare+?>: dup.x32 sp(5)
	<compare+?>: dup.x32 sp(1)
	<compare+?>: add.i32
	<compare+?>: load.is8
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jz +8
	cmplStd/lib/text/cstr.ci:66: (4 bytes): break;
	<compare+?>: jmp +16
	cmplStd/lib/text/cstr.ci:63: (4 bytes): i := i + 1
	<compare+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:63: (8 bytes): result == 0
	<compare+?>: dup.x32 sp(1)
	<compare+?>: load.z32
	<compare+?>: ceq.i32
	<compare+?>: jnz -46
	<compare+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:69: (3 bytes): return .result := result;
	<compare+?>: set.x32 sp(5)
	<compare+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:102: referenced as `compare`
	cmplStd/lib/text/cstr.ci:100: referenced as `compare`
}
ignCaseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 36
.name: 'ignCaseCmp'
.file: 'cmplStd/lib/text/cstr.ci:73'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'ignore case character comparator'
.value: {
	static ignCase(chr: char): char := {
		if (chr < 'A') {
			return .result := chr;
		}
		if (chr > 'Z') {
			return .result := chr;
		}
		return .result := chr - 'A' + 'a';
	};
	return .result := ignCase(chr) - ignCase(with);
}
.instructions: (36 bytes)
	cmplStd/lib/text/cstr.ci:84: (36 bytes): return .result := ignCase(chr) - ignCase(with);
	<ignCaseCmp>  : load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.is8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: load.z32
	<ignCaseCmp+?>: load.sp(+12)
	<ignCaseCmp+?>: load.is8
	<ignCaseCmp+?>: load.ref <?> ;ignCaseCmp.ignCase(chr: char): char
	<ignCaseCmp+?>: call
	<ignCaseCmp+?>: inc.sp(-4)
	<ignCaseCmp+?>: sub.i32
	<ignCaseCmp+?>: set.x32 sp(4)
	<ignCaseCmp+?>: ret
.usages:
}
caseCmp(chr: char, with: char): int32: function {
.kind: static function
.base: `function`
.size: 14
.name: 'caseCmp'
.file: 'cmplStd/lib/text/cstr.ci:88'
.param .result: int32 (size: 4, cast: variable(i32))
.param chr: char (size: 4, cast: variable(i32))
.param with: char (size: 4, cast: variable(i32))
.doc: 'default character comparator'
.value: {
	return .result := chr - with;
}
.instructions: (14 bytes)
	cmplStd/lib/text/cstr.ci:89: (14 bytes): return .result := chr - with;
	<caseCmp>  : load.sp(+8)
	<caseCmp+?>: load.is8
	<caseCmp+?>: load.sp(+8)
	<caseCmp+?>: load.is8
	<caseCmp+?>: sub.i32
	<caseCmp+?>: set.x32 sp(4)
	<caseCmp+?>: ret
.usages:
	cmplStd/lib/text/cstr.ci:102: referenced as `caseCmp`
	cmplStd/lib/text/cstr.ci:100: referenced as `caseCmp`
	cmplStd/lib/text/cstr.ci:98: referenced as `caseCmp`
	cmplStd/lib/text/cstr.ci:96: referenced as `caseCmp`
}
toHex(value: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'toHex'
.file: 'cmplStd/lib/text/cstr.ci:93'
.param .result: int32 (size: 4, cast: i32)
.param value: int32 (size: 4, cast: i32)
.doc: 'convert lower part (4 bits) of the input value to the corresponding lower case hexadecimal character'
.value: int32("0123456789abcdef"[value & 15])
.usages:
}
startsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'startsWith'
.file: 'cmplStd/lib/text/cstr.ci:96'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if a string begins with a specified string, using case-sensitive comparison'
.value: startsWith(str, with, caseCmp)
.usages:
}
endsWith(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'endsWith'
.file: 'cmplStd/lib/text/cstr.ci:98'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if a string ends in a specified string, using case-sensitive comparison'
.value: endsWith(str, with, caseCmp)
.usages:
}
compare(str: char[*], with: char[*]): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'compare'
.file: 'cmplStd/lib/text/cstr.ci:100'
.param .result: int32 (size: 4, cast: i32)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if the two strings are equal, less or greater, using case-sensitive comparison'
.value: compare(str, with, caseCmp)
.usages:
}
equals(str: char[*], with: char[*]): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'equals'
.file: 'cmplStd/lib/text/cstr.ci:102'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param with: char[*] (size: 4, cast: const ref)
.doc: 'Check if the two strings are equal, using case-sensitive comparison'
.value: compare(str, with, caseCmp) == 0
.usages:
}
contains(str: char[*], chr: char): bool: function {
.kind: inline
.base: `function`
.size: 0
.name: 'contains'
.file: 'cmplStd/lib/text/cstr.ci:105'
.param .result: bool (size: 1, cast: bool)
.param str: char[*] (size: 4, cast: const ref)
.param chr: char (size: 4, cast: i32)
.doc: 'Check if a string contains the given character'
.value: indexOf(str, chr) >= 0
.usages:
	cmplStd/lib/text/Format.ci:135: referenced as `contains`
}
float64(value: char[]): float64: function {
.kind: static function
.base: `function`
.size: 423
.name: 'float64'
.file: 'cmplStd/lib/text/cstr.ci:117'
.param .result: float64 (size: 8, cast: variable(f64))
.param value: char[] (size: 8, cast: const variable(arr))
.doc: 'Convert a string to a 64 bit floating point value'
.value: {
	result: float64 := 0;
	static if ((preferNativeCalls) && (typename(float64.parse)) != null) {
		len: int32 := float64.parse(value, &result);
		if (len > 0 && len < (value.length) && (value[len]) == 0) {
			return .result := result;
		}
		return .result := Math.nan;
	}
	sign: float64 := 1;
	decimal: float64 := 0;
	for (i: int32 := 0; i < (value.length) && (value[i]) != 0; i := i + 1) {
		chr: char := value[i];
		if (chr >= '0' && chr <= '9') {
			result := result * (10) + ((chr - '0'));
			decimal := decimal * (10);
		}
		else if (chr == '.') {
			if (decimal != (0)) {
				return .result := Math.nan;
			}
			decimal := (1);
		}
		else if (chr == '-' && i == 0) {
			sign := (-1);
		}
		else if (chr == '+' && i == 0) {
			sign := (1);
		}
		else {
			return .result := Math.nan;
		}
	}
	if (decimal == (0)) {
		if (value.length > (0)) {
			return .result := sign * result;
		}
	}
	return .result := sign * result / decimal;
}
.instructions: (423 bytes)
	cmplStd/lib/text/cstr.ci:118: (1 byte): result: float64 := 0
	<float64>  : load.z64
	cmplStd/lib/text/cstr.ci:121: (10 bytes): len: int32 := float64.parse(value, &result)
	<float64+?>: dup.x64 sp(3)
	<float64+?>: load.sp(+8)
	<float64+?>: nfc(52) ;float64.parse(value: char[], out: float64): int32
	cmplStd/lib/text/cstr.ci:122: (49 bytes): if (len > 0 && len < (value.length) && (value[len]) == 0)
	<float64+?>: dup.x32 sp(0)
	<float64+?>: load.z32
	<float64+?>: cgt.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +13
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(0)
	<float64+?>: dup.x32 sp(6)
	<float64+?>: clt.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +16
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(4)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: add.i32
	<float64+?>: load.is8
	<float64+?>: load.z32
	<float64+?>: ceq.i32
	<float64+?>: jz +12
	cmplStd/lib/text/cstr.ci:123: (8 bytes): return .result := result;
	<float64+?>: mov.x64 sp(6, 1)
	<float64+?>: inc.sp(-12)
	<float64+?>: ret
	cmplStd/lib/text/cstr.ci:126: (16 bytes): return .result := Math.nan;
	<float64+?>: load.f64 -nan
	<float64+?>: set.x64 sp(8)
	<float64+?>: inc.sp(-12)
	<float64+?>: ret
	<float64+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:129: (9 bytes): sign: float64 := 1
	<float64+?>: load.f64 1.000000
	cmplStd/lib/text/cstr.ci:130: (1 byte): decimal: float64 := 0
	<float64+?>: load.z128
	cmplStd/lib/text/cstr.ci:132: (290 bytes): for (i: int32 := 0; i < (value.length) && (value[i]) != 0; i := i + 1)
	<float64+?>: i64.2i32
	<float64+?>: jmp +257
	cmplStd/lib/text/cstr.ci:133: (6 bytes): chr: char := value[i]
	<float64+?>: dup.x32 sp(8)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: add.i32
	<float64+?>: load.is8
	cmplStd/lib/text/cstr.ci:134: (239 bytes): if (chr >= '0' && chr <= '9')
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 48
	<float64+?>: clt.i32
	<float64+?>: not.b32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +20
	<float64+?>: inc.sp(-4)
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 57
	<float64+?>: cgt.i32
	<float64+?>: not.b32
	<float64+?>: jz +47
	cmplStd/lib/text/cstr.ci:135: (25 bytes): result := result * (10) + ((chr - '0'));
	<float64+?>: dup.x64 sp(6)
	<float64+?>: load.f64 10.000000
	<float64+?>: mul.f64
	<float64+?>: load.sp(+8)
	<float64+?>: load.is8
	<float64+?>: inc.i32(-48)
	<float64+?>: i32.2f64
	<float64+?>: add.f64
	<float64+?>: set.x64 sp(8)
	cmplStd/lib/text/cstr.ci:136: (14 bytes): decimal := decimal * (10);
	<float64+?>: dup.x64 sp(2)
	<float64+?>: load.f64 10.000000
	<float64+?>: mul.f64
	<float64+?>: set.x64 sp(4)
	<float64+?>: jmp +162
	cmplStd/lib/text/cstr.ci:138: (158 bytes): if (chr == '.')
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 46
	<float64+?>: ceq.i32
	<float64+?>: jz +43
	cmplStd/lib/text/cstr.ci:139: (24 bytes): if (decimal != (0))
	<float64+?>: dup.x64 sp(2)
	<float64+?>: load.z64
	<float64+?>: ceq.f64
	<float64+?>: jnz +20
	cmplStd/lib/text/cstr.ci:141: (16 bytes): return .result := Math.nan;
	<float64+?>: load.f64 -nan
	<float64+?>: set.x64 sp(13)
	<float64+?>: inc.sp(-32)
	<float64+?>: ret
	cmplStd/lib/text/cstr.ci:143: (11 bytes): decimal := (1);
	<float64+?>: load.f64 1.000000
	<float64+?>: set.x64 sp(4)
	<float64+?>: jmp +108
	cmplStd/lib/text/cstr.ci:145: (104 bytes): if (chr == '-' && i == 0)
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 45
	<float64+?>: ceq.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +12
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: load.z32
	<float64+?>: ceq.i32
	<float64+?>: jz +19
	cmplStd/lib/text/cstr.ci:146: (11 bytes): sign := (-1);
	<float64+?>: load.f64 -1.000000
	<float64+?>: set.x64 sp(6)
	<float64+?>: jmp +64
	cmplStd/lib/text/cstr.ci:148: (60 bytes): if (chr == '+' && i == 0)
	<float64+?>: load.sp(+0)
	<float64+?>: load.is8
	<float64+?>: load.c32 43
	<float64+?>: ceq.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +12
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: load.z32
	<float64+?>: ceq.i32
	<float64+?>: jz +19
	cmplStd/lib/text/cstr.ci:149: (11 bytes): sign := (1);
	<float64+?>: load.f64 1.000000
	<float64+?>: set.x64 sp(6)
	<float64+?>: jmp +20
	cmplStd/lib/text/cstr.ci:153: (16 bytes): return .result := Math.nan;
	<float64+?>: load.f64 -nan
	<float64+?>: set.x64 sp(13)
	<float64+?>: inc.sp(-32)
	<float64+?>: ret
	<float64+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:132: (4 bytes): i := i + 1
	<float64+?>: inc.i32(+1)
	cmplStd/lib/text/cstr.ci:132: (28 bytes): i < (value.length) && (value[i]) != 0
	<float64+?>: dup.x32 sp(0)
	<float64+?>: dup.x32 sp(10)
	<float64+?>: clt.i32
	<float64+?>: dup.x32 sp(0)
	<float64+?>: jz +17
	<float64+?>: inc.sp(-4)
	<float64+?>: dup.x32 sp(8)
	<float64+?>: dup.x32 sp(1)
	<float64+?>: add.i32
	<float64+?>: load.is8
	<float64+?>: load.z32
	<float64+?>: ceq.i32
	<float64+?>: not.b32
	<float64+?>: jnz -277
	<float64+?>: inc.sp(-4)
	cmplStd/lib/text/cstr.ci:157: (28 bytes): if (decimal == (0))
	<float64+?>: dup.x64 sp(0)
	<float64+?>: load.z64
	<float64+?>: ceq.f64
	<float64+?>: jz +24
	cmplStd/lib/text/cstr.ci:158: (20 bytes): if (value.length > (0))
	<float64+?>: dup.x32 sp(8)
	<float64+?>: load.z32
	<float64+?>: cgt.u32
	<float64+?>: jz +16
	cmplStd/lib/text/cstr.ci:159: (12 bytes): return .result := sign * result;
	<float64+?>: dup.x64 sp(2)
	<float64+?>: dup.x64 sp(6)
	<float64+?>: mul.f64
	<float64+?>: set.x64 sp(11)
	<float64+?>: inc.sp(-24)
	<float64+?>: ret
	cmplStd/lib/text/cstr.ci:162: (15 bytes): return .result := sign * result / decimal;
	<float64+?>: dup.x64 sp(2)
	<float64+?>: dup.x64 sp(6)
	<float64+?>: mul.f64
	<float64+?>: dup.x64 sp(2)
	<float64+?>: div.f64
	<float64+?>: set.x64 sp(11)
	<float64+?>: inc.sp(-24)
	<float64+?>: ret
.usages:
}
FormatFlags: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'FormatFlags'
.file: 'cmplStd/lib/text/Format.ci:2'
.field sign: char (size: 1, cast: const variable(i32))
.field padChr: char (size: 1, cast: const variable(i32))
.field width: int32 (size: 4, cast: const variable(i32))
.field precision: int32 (size: 4, cast: const variable(i32))
.field trimDecimal: bool (size: 1, cast: const variable(bool))
.field read: function (size: 420, cast: static function)
.field defPad: function (size: 60, cast: static function)
.doc: 'Flags to convert numbers to string'
.usages:
	cmplStd/lib/text/stream/TextStream.ci:133: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:126: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:119: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:112: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:105: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:98: referenced as `FormatFlags`
	cmplStd/lib/text/stream/TextStream.ci:59: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:564: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:334: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:334: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:279: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:276: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:273: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:270: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:267: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:264: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:261: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:258: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:255: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:185: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:184: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:172: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:170: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:107: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:73: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:73: referenced as `FormatFlags`
	cmplStd/lib/text/Format.ci:19: referenced as `FormatFlags`
}
FormatFlags.sign: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'sign'
.file: 'cmplStd/lib/text/Format.ci:4'
.owner: FormatFlags
.doc: 'forced show sign '+' or '-''
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:186: referenced as `sign`
	cmplStd/lib/text/Format.ci:186: referenced as `sign`
	cmplStd/lib/text/Format.ci:173: referenced as `sign`
	cmplStd/lib/text/Format.ci:144: referenced as `sign`
	cmplStd/lib/text/Format.ci:133: referenced as `sign`
	cmplStd/lib/text/Format.ci:76: referenced as `sign`
	cmplStd/lib/text/Format.ci:76: referenced as `sign`
	cmplStd/lib/text/Format.ci:65: referenced as `sign`
	internal usages: 3
}
FormatFlags.padChr: char {
.kind: const variable(i32)
.base: `char`
.size: 1
.name: 'padChr'
.file: 'cmplStd/lib/text/Format.ci:7'
.owner: FormatFlags
.doc: 'padding character: usually '0' or space'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:187: referenced as `padChr`
	cmplStd/lib/text/Format.ci:187: referenced as `padChr`
	cmplStd/lib/text/Format.ci:174: referenced as `padChr`
	cmplStd/lib/text/Format.ci:174: referenced as `padChr`
	cmplStd/lib/text/Format.ci:127: referenced as `padChr`
	cmplStd/lib/text/Format.ci:78: referenced as `padChr`
	cmplStd/lib/text/Format.ci:67: referenced as `padChr`
	internal usages: 3
}
FormatFlags.width: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'width'
.file: 'cmplStd/lib/text/Format.ci:10'
.owner: FormatFlags
.doc: 'padding length'
.value: 0
.usages:
	cmplStd/lib/text/Format.ci:191: referenced as `width`
	cmplStd/lib/text/Format.ci:188: referenced as `width`
	cmplStd/lib/text/Format.ci:188: referenced as `width`
	cmplStd/lib/text/Format.ci:175: referenced as `width`
	cmplStd/lib/text/Format.ci:175: referenced as `width`
	cmplStd/lib/text/Format.ci:125: referenced as `width`
	cmplStd/lib/text/Format.ci:79: referenced as `width`
	cmplStd/lib/text/Format.ci:74: referenced as `width`
	cmplStd/lib/text/Format.ci:66: referenced as `width`
	internal usages: 3
}
FormatFlags.precision: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'precision'
.file: 'cmplStd/lib/text/Format.ci:13'
.owner: FormatFlags
.doc: 'precision length'
.value: 10
.usages:
	cmplStd/lib/text/Format.ci:218: referenced as `precision`
	cmplStd/lib/text/Format.ci:205: referenced as `precision`
	cmplStd/lib/text/Format.ci:188: referenced as `precision`
	cmplStd/lib/text/Format.ci:176: referenced as `precision`
	cmplStd/lib/text/Format.ci:176: referenced as `precision`
	cmplStd/lib/text/Format.ci:77: referenced as `precision`
	cmplStd/lib/text/Format.ci:77: referenced as `precision`
	cmplStd/lib/text/Format.ci:68: referenced as `precision`
	internal usages: 4
}
FormatFlags.trimDecimal: bool {
.kind: const variable(bool)
.base: `bool`
.size: 1
.name: 'trimDecimal'
.file: 'cmplStd/lib/text/Format.ci:16'
.owner: FormatFlags
.doc: 'trim extra `0` decimal digits'
.value: true
.usages:
	cmplStd/lib/text/Format.ci:233: referenced as `trimDecimal`
	internal usages: 7
}
FormatFlags.read(format: char[], pos: int32): FormatFlags: function {
.kind: static function
.base: `function`
.size: 420
.name: 'read'
.file: 'cmplStd/lib/text/Format.ci:19'
.owner: FormatFlags
.param .result: FormatFlags (size: 16, cast: variable(val))
.param format: char[] (size: 8, cast: const variable(arr))
.param pos: int32 (size: 4, cast: variable(ref))
.doc: 'read and process c style format flags like: "%02d"'
.value: {
	chr: int32 := format[pos];
	if (chr != ('%')) {
		return .result := {
			.result.trimDecimal := true;
			.result.precision := 10;
			.result.width := 0;
			.result.padChr := (0);
			.result.sign := (0);
		};
	}
	pos := pos + 1;
	chr := (format[pos]);
	if (chr == ('%')) {
		return .result := {
			.result.trimDecimal := true;
			.result.precision := 10;
			.result.width := 0;
			.result.padChr := (0);
			.result.sign := (0);
		};
	}
	sgnChr: int32 := 0;
	if (chr == ('-') || chr == ('+')) {
		pos := pos + 1;
		sgnChr := chr;
		chr := (format[pos]);
	}
	padChr: int32 := ' ';
	if (chr == ('0')) {
		pos := pos + 1;
		padChr := chr;
		chr := (format[pos]);
	}
	padLen: int32 := 0;
	for ( ; chr >= ('0') && chr <= ('9'); ) {
		pos := pos + 1;
		padLen := padLen * 10 + chr - ('0');
		chr := (format[pos]);
	}
	precision: int32 := 0;
	if (chr == ('.')) {
		pos := pos + 1;
		chr := (format[pos]);
		for ( ; chr >= ('0') && chr <= ('9'); ) {
			pos := pos + 1;
			precision := precision * 10 + chr - ('0');
			chr := (format[pos]);
		}
	}
	return .result := {
			.result.sign := (sgnChr);
			.result.width := padLen;
			.result.padChr := (padChr);
			.result.precision := precision;
			.result.trimDecimal := true;
		};
}
.instructions: (420 bytes)
	cmplStd/lib/text/Format.ci:20: (7 bytes): chr: int32 := format[pos]
	<read>  : dup.x32 sp(2)
	<read+?>: dup.x32 sp(2)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	cmplStd/lib/text/Format.ci:21: (49 bytes): if (chr != ('%'))
	<read+?>: dup.x32 sp(0)
	<read+?>: load.c32 37
	<read+?>: ceq.i32
	<read+?>: jnz +41
	cmplStd/lib/text/Format.ci:22: (37 bytes): return .result := {...};
	:: (10 bytes): .result.trimDecimal := true;
	<read+?>: load.c32 1
	<read+?>: load.sp(+36)
	<read+?>: store.i8
	:: (7 bytes): .result.precision := 10;
	<read+?>: load.c32 10
	<read+?>: set.x32 sp(8)
	:: (3 bytes): .result.width := 0;
	<read+?>: load.z32
	<read+?>: set.x32 sp(7)
	:: (6 bytes): .result.padChr := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+25)
	<read+?>: store.i8
	:: (6 bytes): .result.sign := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+24)
	<read+?>: store.i8
	<read+?>: inc.sp(-4)
	<read+?>: ret
	cmplStd/lib/text/Format.ci:25: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(2)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(3)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:26: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(3)
	<read+?>: dup.x32 sp(3)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(1)
	cmplStd/lib/text/Format.ci:28: (49 bytes): if (chr == ('%'))
	<read+?>: dup.x32 sp(0)
	<read+?>: load.c32 37
	<read+?>: ceq.i32
	<read+?>: jz +41
	cmplStd/lib/text/Format.ci:29: (37 bytes): return .result := {...};
	:: (10 bytes): .result.trimDecimal := true;
	<read+?>: load.c32 1
	<read+?>: load.sp(+36)
	<read+?>: store.i8
	:: (7 bytes): .result.precision := 10;
	<read+?>: load.c32 10
	<read+?>: set.x32 sp(8)
	:: (3 bytes): .result.width := 0;
	<read+?>: load.z32
	<read+?>: set.x32 sp(7)
	:: (6 bytes): .result.padChr := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+25)
	<read+?>: store.i8
	:: (6 bytes): .result.sign := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+24)
	<read+?>: store.i8
	<read+?>: inc.sp(-4)
	<read+?>: ret
	cmplStd/lib/text/Format.ci:32: (1 byte): sgnChr: int32 := 0
	<read+?>: load.z32
	cmplStd/lib/text/Format.ci:33: (52 bytes): if (chr == ('-') || chr == ('+'))
	<read+?>: dup.x32 sp(1)
	<read+?>: load.c32 45
	<read+?>: ceq.i32
	<read+?>: dup.x32 sp(0)
	<read+?>: jnz +16
	<read+?>: inc.sp(-4)
	<read+?>: dup.x32 sp(1)
	<read+?>: load.c32 43
	<read+?>: ceq.i32
	<read+?>: jz +26
	cmplStd/lib/text/Format.ci:34: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(3)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(4)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:35: (3 bytes): sgnChr := chr;
	<read+?>: mov.x32 sp(0, 1)
	cmplStd/lib/text/Format.ci:36: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(4)
	<read+?>: dup.x32 sp(4)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:39: (5 bytes): padChr: int32 := ' '
	<read+?>: load.c32 32
	cmplStd/lib/text/Format.ci:40: (34 bytes): if (chr == ('0'))
	<read+?>: dup.x32 sp(2)
	<read+?>: load.c32 48
	<read+?>: ceq.i32
	<read+?>: jz +26
	cmplStd/lib/text/Format.ci:41: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(4)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(5)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:42: (3 bytes): padChr := chr;
	<read+?>: mov.x32 sp(0, 2)
	cmplStd/lib/text/Format.ci:43: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(5)
	<read+?>: dup.x32 sp(5)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(3)
	cmplStd/lib/text/Format.ci:46: (1 byte): padLen: int32 := 0
	<read+?>: load.z32
	cmplStd/lib/text/Format.ci:47: (68 bytes): for ( ; chr >= ('0') && chr <= ('9'); )
	<read+?>: jmp +36
	cmplStd/lib/text/Format.ci:48: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(5)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(6)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:49: (13 bytes): padLen := padLen * 10 + chr - ('0');
	<read+?>: load.c32 10
	<read+?>: mul.i32
	<read+?>: dup.x32 sp(3)
	<read+?>: add.i32
	<read+?>: inc.i32(-48)
	cmplStd/lib/text/Format.ci:50: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(6)
	<read+?>: dup.x32 sp(6)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(4)
	cmplStd/lib/text/Format.ci:47: (32 bytes): chr >= ('0') && chr <= ('9')
	<read+?>: dup.x32 sp(3)
	<read+?>: load.c32 48
	<read+?>: clt.i32
	<read+?>: not.b32
	<read+?>: dup.x32 sp(0)
	<read+?>: jz +17
	<read+?>: inc.sp(-4)
	<read+?>: dup.x32 sp(3)
	<read+?>: load.c32 57
	<read+?>: cgt.i32
	<read+?>: not.b32
	<read+?>: jnz -60
	cmplStd/lib/text/Format.ci:53: (1 byte): precision: int32 := 0
	<read+?>: load.z32
	cmplStd/lib/text/Format.ci:54: (99 bytes): if (chr == ('.'))
	<read+?>: dup.x32 sp(4)
	<read+?>: load.c32 46
	<read+?>: ceq.i32
	<read+?>: jz +91
	cmplStd/lib/text/Format.ci:55: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(6)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(7)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:56: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(7)
	<read+?>: dup.x32 sp(7)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:57: (68 bytes): for ( ; chr >= ('0') && chr <= ('9'); )
	<read+?>: jmp +36
	cmplStd/lib/text/Format.ci:58: (10 bytes): pos := pos + 1;
	<read+?>: dup.x32 sp(6)
	<read+?>: load.i32
	<read+?>: inc.i32(+1)
	<read+?>: dup.x32 sp(7)
	<read+?>: store.i32
	cmplStd/lib/text/Format.ci:59: (13 bytes): precision := precision * 10 + chr - ('0');
	<read+?>: load.c32 10
	<read+?>: mul.i32
	<read+?>: dup.x32 sp(4)
	<read+?>: add.i32
	<read+?>: inc.i32(-48)
	cmplStd/lib/text/Format.ci:60: (9 bytes): chr := (format[pos]);
	<read+?>: dup.x32 sp(7)
	<read+?>: dup.x32 sp(7)
	<read+?>: load.i32
	<read+?>: add.i32
	<read+?>: load.is8
	<read+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:57: (32 bytes): chr >= ('0') && chr <= ('9')
	<read+?>: dup.x32 sp(4)
	<read+?>: load.c32 48
	<read+?>: clt.i32
	<read+?>: not.b32
	<read+?>: dup.x32 sp(0)
	<read+?>: jz +17
	<read+?>: inc.sp(-4)
	<read+?>: dup.x32 sp(4)
	<read+?>: load.c32 57
	<read+?>: cgt.i32
	<read+?>: not.b32
	<read+?>: jnz -60
	cmplStd/lib/text/Format.ci:64: (35 bytes): return .result := {...};
	cmplStd/lib/text/Format.ci:65: (7 bytes): .result.sign := (sgnChr);
	<read+?>: dup.x32 sp(3)
	<read+?>: load.sp(+40)
	<read+?>: store.i8
	cmplStd/lib/text/Format.ci:66: (3 bytes): .result.width := padLen;
	<read+?>: mov.x32 sp(10, 1)
	cmplStd/lib/text/Format.ci:67: (7 bytes): .result.padChr := (padChr);
	<read+?>: dup.x32 sp(2)
	<read+?>: load.sp(+41)
	<read+?>: store.i8
	cmplStd/lib/text/Format.ci:68: (3 bytes): .result.precision := precision;
	<read+?>: mov.x32 sp(11, 0)
	:: (10 bytes): .result.trimDecimal := true;
	<read+?>: load.c32 1
	<read+?>: load.sp(+52)
	<read+?>: store.i8
	<read+?>: inc.sp(-20)
	<read+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:334: referenced as `read`
}
FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags: function {
.kind: static function
.base: `function`
.size: 60
.name: 'defPad'
.file: 'cmplStd/lib/text/Format.ci:73'
.owner: FormatFlags
.param .result: FormatFlags (size: 16, cast: variable(val))
.param this: FormatFlags (size: 4, cast: const variable(ref))
.param width: int32 (size: 4, cast: variable(i32))
.param padChr: char (size: 4, cast: variable(i32))
.doc: 'override the default padding, in case it's length is zero'
.value: {
	if (this.width == 0) {
		return .result := {
			.result.sign := this.sign;
			.result.precision := this.precision;
			.result.padChr := padChr;
			.result.width := width;
			.result.trimDecimal := true;
		};
	}
	return .result := this;
}
.instructions: (60 bytes)
	cmplStd/lib/text/Format.ci:74: (54 bytes): if (this.width == 0)
	<defPad>  : dup.x32 sp(3)
	<defPad+?>: inc.i32(+4)
	<defPad+?>: load.i32
	<defPad+?>: load.z32
	<defPad+?>: ceq.i32
	<defPad+?>: jz +45
	cmplStd/lib/text/Format.ci:75: (41 bytes): return .result := {...};
	cmplStd/lib/text/Format.ci:76: (8 bytes): .result.sign := this.sign;
	<defPad+?>: dup.x32 sp(3)
	<defPad+?>: load.is8
	<defPad+?>: load.sp(+20)
	<defPad+?>: store.i8
	cmplStd/lib/text/Format.ci:77: (9 bytes): .result.precision := this.precision;
	<defPad+?>: dup.x32 sp(3)
	<defPad+?>: inc.i32(+8)
	<defPad+?>: load.i32
	<defPad+?>: set.x32 sp(7)
	cmplStd/lib/text/Format.ci:78: (10 bytes): .result.padChr := padChr;
	<defPad+?>: load.sp(+4)
	<defPad+?>: load.is8
	<defPad+?>: load.sp(+21)
	<defPad+?>: store.i8
	cmplStd/lib/text/Format.ci:79: (3 bytes): .result.width := width;
	<defPad+?>: mov.x32 sp(5, 2)
	:: (10 bytes): .result.trimDecimal := true;
	<defPad+?>: load.c32 1
	<defPad+?>: load.sp(+32)
	<defPad+?>: store.i8
	<defPad+?>: ret
	cmplStd/lib/text/Format.ci:82: (6 bytes): return .result := this;
	<defPad+?>: dup.x32 sp(3)
	<defPad+?>: load.i128
	<defPad+?>: set.x128 sp(8)
	<defPad+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:471: referenced as `defPad`
	cmplStd/lib/text/Format.ci:459: referenced as `defPad`
	cmplStd/lib/text/Format.ci:440: referenced as `defPad`
	cmplStd/lib/text/Format.ci:418: referenced as `defPad`
	cmplStd/lib/text/Format.ci:409: referenced as `defPad`
	cmplStd/lib/text/Format.ci:405: referenced as `defPad`
	cmplStd/lib/text/Format.ci:401: referenced as `defPad`
	cmplStd/lib/text/Format.ci:397: referenced as `defPad`
	cmplStd/lib/text/Format.ci:393: referenced as `defPad`
	cmplStd/lib/text/Format.ci:389: referenced as `defPad`
	cmplStd/lib/text/Format.ci:385: referenced as `defPad`
	cmplStd/lib/text/Format.ci:371: referenced as `defPad`
	cmplStd/lib/text/Format.ci:363: referenced as `defPad`
	cmplStd/lib/text/Format.ci:359: referenced as `defPad`
}
append(output: char[], pos: int32, value: char[*]): int32: function {
.kind: static function
.base: `function`
.size: 119
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:87'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: char[*] (size: 4, cast: const variable(ref))
.doc: 'Append a string to the output at the given position'
.value: {
	if ((value) == null) {
		return .result := append(output, pos, "NULL");
	}
	for (i: int32 := 0; value[i]; i := i + 1) {
		if (pos >= (output.length)) {
			break;
		}
		output[pos] := value[i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (119 bytes)
	cmplStd/lib/text/Format.ci:88: (35 bytes): if ((value) == null)
	<append>  : dup.x32 sp(1)
	<append+?>: load.ref <?> ;null
	<append+?>: ceq.i32
	<append+?>: jz +27
	cmplStd/lib/text/Format.ci:89: (23 bytes): return .result := append(output, pos, "NULL");
	<append+?>: load.z32
	<append+?>: dup.x64 sp(4)
	<append+?>: dup.x32 sp(5)
	<append+?>: load.ref <?> ;"NULL"
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: set.x32 sp(6)
	<append+?>: ret
	cmplStd/lib/text/Format.ci:91: (56 bytes): for (i: int32 := 0; value[i]; i := i + 1)
	<append+?>: load.z32
	<append+?>: jmp +41
	cmplStd/lib/text/Format.ci:92: (13 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(3)
	<append+?>: dup.x32 sp(6)
	<append+?>: clt.i32
	<append+?>: jnz +8
	cmplStd/lib/text/Format.ci:93: (4 bytes): break;
	<append+?>: jmp +38
	cmplStd/lib/text/Format.ci:95: (12 bytes): output[pos] := value[i];
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: dup.x32 sp(5)
	<append+?>: dup.x32 sp(5)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:96: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(3)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(4)
	cmplStd/lib/text/Format.ci:91: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	cmplStd/lib/text/Format.ci:91: (10 bytes): value[i]
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: jnz -43
	<append+?>: inc.sp(-4)
	cmplStd/lib/text/Format.ci:99: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(5)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:100: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(4)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(3)
	cmplStd/lib/text/Format.ci:102: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(4)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:103: (4 bytes): return .result := pos;
	<append+?>: mov.x32 sp(5, 2)
	<append+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:444: referenced as `append`
	cmplStd/lib/text/Format.ci:426: referenced as `append`
	cmplStd/lib/text/Format.ci:422: referenced as `append`
	cmplStd/lib/text/Format.ci:413: referenced as `append`
	cmplStd/lib/text/Format.ci:381: referenced as `append`
	cmplStd/lib/text/Format.ci:354: referenced as `append`
	cmplStd/lib/text/Format.ci:350: referenced as `append`
	cmplStd/lib/text/Format.ci:346: referenced as `append`
	cmplStd/lib/text/Format.ci:342: referenced as `append`
	cmplStd/lib/text/Format.ci:338: referenced as `append`
	cmplStd/lib/text/Format.ci:217: referenced as `append`
	cmplStd/lib/text/Format.ci:204: referenced as `append`
	cmplStd/lib/text/Format.ci:89: referenced as `append`
}
append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 687
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:107'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param radix: int32 (size: 4, cast: variable(i32))
.param value: uint64 (size: 8, cast: variable(u64))
.param format: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	static const whiteSpace: char[] := " \t\n\r";
	static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
	len: int32 := 0;
	digits: char[80] := {
	};
	assert(radix > 1, "radix is too small", radix);
	assert(radix < (radixDigits.length), "radix is too big", radix);
	for ( ; value > (0); value := value / (radix)) {
		digits[len := len + 1] := radixDigits[value % (radix)];
	}
	if (len == 0) {
		digits[len := len + 1] := '0';
	}
	maxLen: int32 := format.width - len;
	padChr: char := format.padChr;
	if (padChr == '') {
		padChr := ' ';
	}
	if ((format.sign) != 0) {
		maxLen := maxLen - 1;
		if (contains(whiteSpace, padChr)) {
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
		}
		assert(pos < (output.length));
		output[pos] := format.sign;
		pos := pos + 1;
	}
	for ( ; maxLen > 0; maxLen := maxLen - 1) {
		assert(pos < (output.length));
		output[pos] := padChr;
		pos := pos + 1;
	}
	for (i: int32 := 0; i < len; i := i + 1) {
		assert(i < (output.length));
		output[pos] := digits[len - i];
		pos := pos + 1;
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	output[pos] := (0);
	return .result := pos;
}
.instructions: (687 bytes)
	cmplStd/lib/text/Format.ci:111: (1 byte): len: int32 := 0
	<append>  : load.z32
	cmplStd/lib/text/Format.ci:112: (4 bytes): digits: char[80] := {...}
	<append+?>: inc.sp(+80)
	cmplStd/lib/text/Format.ci:114: (69 bytes): assert(radix > 1, "radix is too small", radix);
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+104)
	<append+?>: load.c32 1
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(29)
	<append+?>: load.c32 1
	<append+?>: cgt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 114
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too small"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-16)
	cmplStd/lib/text/Format.ci:115: (68 bytes): assert(radix < (radixDigits.length), "radix is too big", radix);
	<append+?>: load.ref <?> ;int32
	<append+?>: load.sp(+104)
	<append+?>: load.c32 1
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(29)
	<append+?>: load.m32 <?> ;append.radixDigits+4
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 115
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"radix is too big"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-16)
	cmplStd/lib/text/Format.ci:118: (49 bytes): for ( ; value > (0); value := value / (radix))
	<append+?>: jmp +41
	cmplStd/lib/text/Format.ci:119: (29 bytes): digits[len := len + 1] := radixDigits[value % (radix)];
	<append+?>: load.m32 <?> ;append.radixDigits
	<append+?>: dup.x64 sp(24)
	<append+?>: dup.x32 sp(28)
	<append+?>: i32.2i64
	<append+?>: mod.u64
	<append+?>: i64.2i32
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(22)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x32 sp(0)
	<append+?>: set.x32 sp(24)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:118: (8 bytes): value := value / (radix)
	<append+?>: dup.x64 sp(23)
	<append+?>: dup.x32 sp(27)
	<append+?>: i32.2i64
	<append+?>: div.u64
	<append+?>: set.x64 sp(25)
	cmplStd/lib/text/Format.ci:118: (8 bytes): value > (0)
	<append+?>: dup.x64 sp(23)
	<append+?>: load.z64
	<append+?>: cgt.u64
	<append+?>: jnz -41
	cmplStd/lib/text/Format.ci:121: (29 bytes): if (len == 0)
	<append+?>: dup.x32 sp(20)
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +25
	cmplStd/lib/text/Format.ci:122: (21 bytes): digits[len := len + 1] := '0';
	<append+?>: load.c32 48
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(22)
	<append+?>: inc.i32(+1)
	<append+?>: dup.x32 sp(0)
	<append+?>: set.x32 sp(24)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:125: (10 bytes): maxLen: int32 := format.width - len
	<append+?>: dup.x32 sp(22)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: dup.x32 sp(21)
	<append+?>: sub.i32
	cmplStd/lib/text/Format.ci:127: (7 bytes): padChr: char := format.padChr
	<append+?>: dup.x32 sp(23)
	<append+?>: inc.i32(+1)
	<append+?>: load.is8
	cmplStd/lib/text/Format.ci:128: (21 bytes): if (padChr == '')
	<append+?>: load.sp(+0)
	<append+?>: load.is8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jz +14
	cmplStd/lib/text/Format.ci:129: (10 bytes): padChr := ' ';
	<append+?>: load.c32 32
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:133: (205 bytes): if ((format.sign) != 0)
	<append+?>: dup.x32 sp(24)
	<append+?>: load.is8
	<append+?>: load.z32
	<append+?>: ceq.i32
	<append+?>: jnz +200
	cmplStd/lib/text/Format.ci:134: (8 bytes): maxLen := maxLen - 1;
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:135: (118 bytes): if (contains(whiteSpace, padChr))
	<append+?>: load.z32
	<append+?>: load.m32 <?> ;append.whiteSpace
	<append+?>: load.sp(+8)
	<append+?>: load.is8
	<append+?>: load.ref <?> ;indexOf(str: char[*], chr: char): int32
	<append+?>: call
	<append+?>: inc.sp(-8)
	<append+?>: load.z32
	<append+?>: clt.i32
	<append+?>: jnz +96
	cmplStd/lib/text/Format.ci:137: (92 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +84
	cmplStd/lib/text/Format.ci:138: (53 bytes): assert(pos < (output.length));
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(33)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 138
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-8)
	cmplStd/lib/text/Format.ci:139: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.is8
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:140: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(29)
	cmplStd/lib/text/Format.ci:137: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:137: (8 bytes): maxLen > 0
	<append+?>: dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -84
	cmplStd/lib/text/Format.ci:143: (53 bytes): assert(pos < (output.length));
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(33)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 143
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-8)
	cmplStd/lib/text/Format.ci:144: (9 bytes): output[pos] := format.sign;
	<append+?>: dup.x32 sp(24)
	<append+?>: load.is8
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:145: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(29)
	cmplStd/lib/text/Format.ci:149: (92 bytes): for ( ; maxLen > 0; maxLen := maxLen - 1)
	<append+?>: jmp +84
	cmplStd/lib/text/Format.ci:150: (53 bytes): assert(pos < (output.length));
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(33)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 150
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-8)
	cmplStd/lib/text/Format.ci:151: (11 bytes): output[pos] := padChr;
	<append+?>: load.sp(+0)
	<append+?>: load.is8
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:152: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(28)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(29)
	cmplStd/lib/text/Format.ci:149: (8 bytes): maxLen := maxLen - 1
	<append+?>: dup.x32 sp(1)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:149: (8 bytes): maxLen > 0
	<append+?>: dup.x32 sp(1)
	<append+?>: load.z32
	<append+?>: cgt.i32
	<append+?>: jnz -84
	cmplStd/lib/text/Format.ci:156: (100 bytes): for (i: int32 := 0; i < len; i := i + 1)
	<append+?>: load.z32
	<append+?>: jmp +86
	cmplStd/lib/text/Format.ci:157: (53 bytes): assert(i < (output.length));
	<append+?>: load.z32
	<append+?>: load.sp(+4)
	<append+?>: dup.x32 sp(2)
	<append+?>: dup.x32 sp(34)
	<append+?>: clt.i32
	<append+?>: jz +8
	<append+?>: jmp +35
	<append+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<append+?>: load.c32 157
	<append+?>: load.c32 -2
	<append+?>: load.c32 128
	<append+?>: load.ref <?> ;"assertion failed!"
	<append+?>: dup.x64 sp(5)
	<append+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<append+?>: inc.sp(-8)
	cmplStd/lib/text/Format.ci:158: (17 bytes): output[pos] := digits[len - i];
	<append+?>: load.sp(+12)
	<append+?>: dup.x32 sp(24)
	<append+?>: dup.x32 sp(2)
	<append+?>: sub.i32
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: dup.x32 sp(31)
	<append+?>: dup.x32 sp(31)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:159: (8 bytes): pos := pos + 1;
	<append+?>: dup.x32 sp(29)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(30)
	cmplStd/lib/text/Format.ci:156: (4 bytes): i := i + 1
	<append+?>: inc.i32(+1)
	cmplStd/lib/text/Format.ci:156: (9 bytes): i < len
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(24)
	<append+?>: clt.i32
	<append+?>: jnz -87
	<append+?>: inc.sp(-4)
	cmplStd/lib/text/Format.ci:162: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(28)
	<append+?>: dup.x32 sp(31)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:163: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(30)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(29)
	cmplStd/lib/text/Format.ci:165: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(30)
	<append+?>: dup.x32 sp(30)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:166: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(31, 28)
	<append+?>: inc.sp(-92)
	<append+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:264: referenced as `append`
	cmplStd/lib/text/Format.ci:261: referenced as `append`
	cmplStd/lib/text/Format.ci:258: referenced as `append`
	cmplStd/lib/text/Format.ci:255: referenced as `append`
	cmplStd/lib/text/Format.ci:215: referenced as `append`
	cmplStd/lib/text/Format.ci:200: referenced as `append`
	cmplStd/lib/text/Format.ci:180: referenced as `append`
	cmplStd/lib/text/Format.ci:178: referenced as `append`
}
append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 121
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:170'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param radix: int32 (size: 4, cast: variable(i32))
.param value: int64 (size: 8, cast: variable(i64))
.param format: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	if (value < (0)) {
		signedFormat: FormatFlags := {
			signedFormat.sign := '-';
			signedFormat.padChr := format.padChr;
			signedFormat.width := format.width;
			signedFormat.precision := format.precision;
			signedFormat.trimDecimal := true;
		};
		return .result := append(output, pos, radix, uint64(-value), signedFormat);
	}
	return .result := append(output, pos, radix, uint64(value), format);
}
.instructions: (121 bytes)
	cmplStd/lib/text/Format.ci:171: (97 bytes): if (value < (0))
	<append>  : dup.x64 sp(2)
	<append+?>: load.z64
	<append+?>: clt.i64
	<append+?>: jz +93
	cmplStd/lib/text/Format.ci:172: (54 bytes): signedFormat: FormatFlags := {...}
	<append+?>: inc.sp(+16)
	cmplStd/lib/text/Format.ci:173: (10 bytes): signedFormat.sign := '-';
	<append+?>: load.c32 45
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:174: (12 bytes): signedFormat.padChr := format.padChr;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+1)
	<append+?>: load.is8
	<append+?>: load.sp(+5)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:175: (9 bytes): signedFormat.width := format.width;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: set.x32 sp(2)
	cmplStd/lib/text/Format.ci:176: (9 bytes): signedFormat.precision := format.precision;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: set.x32 sp(3)
	:: (10 bytes): signedFormat.trimDecimal := true;
	<append+?>: load.c32 1
	<append+?>: load.sp(+16)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:178: (31 bytes): return .result := append(output, pos, radix, uint64(-value), signedFormat);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(11)
	<append+?>: dup.x32 sp(12)
	<append+?>: dup.x32 sp(12)
	<append+?>: dup.x64 sp(11)
	<append+?>: neg.i64
	<append+?>: load.sp(+28)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(13)
	<append+?>: inc.sp(-16)
	<append+?>: ret
	<append+?>: inc.sp(-16)
	cmplStd/lib/text/Format.ci:180: (24 bytes): return .result := append(output, pos, radix, uint64(value), format);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(7)
	<append+?>: dup.x32 sp(8)
	<append+?>: dup.x32 sp(8)
	<append+?>: dup.x64 sp(7)
	<append+?>: dup.x32 sp(8)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(9)
	<append+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:276: referenced as `append`
	cmplStd/lib/text/Format.ci:273: referenced as `append`
	cmplStd/lib/text/Format.ci:270: referenced as `append`
	cmplStd/lib/text/Format.ci:267: referenced as `append`
}
append(output: char[], pos: int32, value: float64, format: FormatFlags): int32: function {
.kind: static function
.base: `function`
.size: 649
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:184'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: float64 (size: 8, cast: variable(f64))
.param format: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Append a number to the output at the given position'
.value: {
	formatInt: FormatFlags := {
		formatInt.sign := value < (0) ? '-' : format.sign;
		formatInt.padChr := format.padChr;
		formatInt.width := format.width - format.precision - 1;
		formatInt.precision := 10;
		formatInt.trimDecimal := true;
	};
	end: int32 := pos + format.width;
	if (end >= (output.length)) {
		end := (output.length - (1));
	}
	const beg: int32 := pos;
	fraction: float64 := Math.modf(Math.abs(value), &value);
	pos := append(output, pos, 10, uint64(int64(value)), formatInt);
	dotIndex: int32 := pos;
	pos := append(output, pos, ".");
	end := Math.max(end, pos + format.precision);
	if (end >= (output.length)) {
		end := (output.length - (1));
	}
	fraction := fraction + Math.pow(10.000000, float64(pos - end)) / (2);
	if (fraction >= (1)) {
		fraction := fraction % (1);
		pos := append(output, beg, 10, uint64(int64(value + (1))), formatInt);
		dotIndex := pos;
		pos := append(output, pos, ".");
		end := Math.max(end, pos + format.precision);
		if (end >= (output.length)) {
			end := (output.length - (1));
		}
	}
	for ( ; pos < end; pos := pos + 1) {
		fraction := Math.modf(fraction * (10), &value);
		output[pos] := (('0') + int32(value));
	}
	if (pos >= (output.length)) {
		pos := (output.length - (1));
	}
	if (!format.trimDecimal) {
		output[pos] := (0);
		return .result := pos;
	}
	for (i: int32 := pos - 1; i >= dotIndex; i := i - 1) {
		if (output[i] != '0') {
			if (i == dotIndex) {
				output[i] := (0);
				return .result := i;
			}
			output[i + 1] := (0);
			return .result := i + 1;
		}
	}
	return .result := pos;
}
.instructions: (649 bytes)
	cmplStd/lib/text/Format.ci:185: (79 bytes): formatInt: FormatFlags := {...}
	<append>  : inc.sp(+16)
	cmplStd/lib/text/Format.ci:186: (25 bytes): formatInt.sign := value < (0) ? '-' : format.sign;
	<append+?>: dup.x64 sp(6)
	<append+?>: load.z64
	<append+?>: clt.f64
	<append+?>: jz +13
	<append+?>: load.c32 45
	<append+?>: jmp +7
	<append+?>: dup.x32 sp(5)
	<append+?>: load.is8
	<append+?>: load.sp(+4)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:187: (12 bytes): formatInt.padChr := format.padChr;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+1)
	<append+?>: load.is8
	<append+?>: load.sp(+5)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:188: (21 bytes): formatInt.width := format.width - format.precision - 1;
	<append+?>: dup.x32 sp(5)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: dup.x32 sp(6)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: sub.i32
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(2)
	:: (7 bytes): formatInt.precision := 10;
	<append+?>: load.c32 10
	<append+?>: set.x32 sp(3)
	:: (10 bytes): formatInt.trimDecimal := true;
	<append+?>: load.c32 1
	<append+?>: load.sp(+16)
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:191: (10 bytes): end: int32 := pos + format.width
	<append+?>: dup.x32 sp(8)
	<append+?>: dup.x32 sp(6)
	<append+?>: inc.i32(+4)
	<append+?>: load.i32
	<append+?>: add.i32
	cmplStd/lib/text/Format.ci:192: (17 bytes): if (end >= (output.length))
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(12)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:193: (8 bytes): end := (output.length - (1));
	<append+?>: dup.x32 sp(11)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(1)
	cmplStd/lib/text/Format.ci:196: (2 bytes): const beg: int32 := pos
	<append+?>: dup.x32 sp(9)
	cmplStd/lib/text/Format.ci:197: (36 bytes): fraction: float64 := Math.modf(Math.abs(value), &value)
	<append+?>: load.z64
	<append+?>: dup.x64 sp(10)
	<append+?>: dup.x64 sp(0)
	<append+?>: load.z64
	<append+?>: clt.f64
	<append+?>: jz +11
	<append+?>: dup.x64 sp(0)
	<append+?>: neg.f64
	<append+?>: jmp +6
	<append+?>: dup.x64 sp(0)
	<append+?>: set.x64 sp(2)
	<append+?>: load.sp(+48)
	<append+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<append+?>: call
	<append+?>: inc.sp(-12)
	cmplStd/lib/text/Format.ci:200: (29 bytes): pos := append(output, pos, 10, uint64(int64(value)), formatInt);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(14)
	<append+?>: dup.x32 sp(15)
	<append+?>: load.c32 10
	<append+?>: dup.x64 sp(15)
	<append+?>: f64.2i64
	<append+?>: load.sp(+44)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(13)
	cmplStd/lib/text/Format.ci:203: (2 bytes): dotIndex: int32 := pos
	<append+?>: dup.x32 sp(12)
	cmplStd/lib/text/Format.ci:204: (22 bytes): pos := append(output, pos, ".");
	<append+?>: load.z32
	<append+?>: dup.x64 sp(15)
	<append+?>: dup.x32 sp(16)
	<append+?>: load.ref <?> ;"."
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:205: (38 bytes): end := Math.max(end, pos + format.precision);
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(14)
	<append+?>: dup.x32 sp(12)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: add.i32
	<append+?>: dup.x32 sp(1)
	<append+?>: dup.x32 sp(1)
	<append+?>: cgt.i32
	<append+?>: jz +10
	<append+?>: dup.x32 sp(1)
	<append+?>: jmp +6
	<append+?>: dup.x32 sp(0)
	<append+?>: mov.x32 sp(2, 0)
	<append+?>: inc.sp(-8)
	<append+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:206: (17 bytes): if (end >= (output.length))
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(16)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:207: (8 bytes): end := (output.length - (1));
	<append+?>: dup.x32 sp(15)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:211: (41 bytes): fraction := fraction + Math.pow(10.000000, float64(pos - end)) / (2);
	<append+?>: dup.x64 sp(1)
	<append+?>: load.z64
	<append+?>: load.f64 10.000000
	<append+?>: dup.x32 sp(19)
	<append+?>: dup.x32 sp(11)
	<append+?>: sub.i32
	<append+?>: i32.2f64
	<append+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: load.f64 2.000000
	<append+?>: div.f64
	<append+?>: add.f64
	<append+?>: set.x64 sp(3)
	cmplStd/lib/text/Format.ci:213: (149 bytes): if (fraction >= (1))
	<append+?>: dup.x64 sp(1)
	<append+?>: load.f64 1.000000
	<append+?>: clt.f64
	<append+?>: jnz +137
	cmplStd/lib/text/Format.ci:214: (14 bytes): fraction := fraction % (1);
	<append+?>: dup.x64 sp(1)
	<append+?>: load.f64 1.000000
	<append+?>: mod.f64
	<append+?>: set.x64 sp(3)
	cmplStd/lib/text/Format.ci:215: (39 bytes): pos := append(output, beg, 10, uint64(int64(value + (1))), formatInt);
	<append+?>: load.z32
	<append+?>: dup.x64 sp(15)
	<append+?>: dup.x32 sp(6)
	<append+?>: load.c32 10
	<append+?>: dup.x64 sp(16)
	<append+?>: load.f64 1.000000
	<append+?>: add.f64
	<append+?>: f64.2i64
	<append+?>: load.sp(+48)
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:216: (3 bytes): dotIndex := pos;
	<append+?>: mov.x32 sp(0, 13)
	cmplStd/lib/text/Format.ci:217: (22 bytes): pos := append(output, pos, ".");
	<append+?>: load.z32
	<append+?>: dup.x64 sp(15)
	<append+?>: dup.x32 sp(16)
	<append+?>: load.ref <?> ;"."
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<append+?>: call
	<append+?>: inc.sp(-16)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:218: (38 bytes): end := Math.max(end, pos + format.precision);
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(14)
	<append+?>: dup.x32 sp(12)
	<append+?>: inc.i32(+8)
	<append+?>: load.i32
	<append+?>: add.i32
	<append+?>: dup.x32 sp(1)
	<append+?>: dup.x32 sp(1)
	<append+?>: cgt.i32
	<append+?>: jz +10
	<append+?>: dup.x32 sp(1)
	<append+?>: jmp +6
	<append+?>: dup.x32 sp(0)
	<append+?>: mov.x32 sp(2, 0)
	<append+?>: inc.sp(-8)
	<append+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:219: (17 bytes): if (end >= (output.length))
	<append+?>: dup.x32 sp(4)
	<append+?>: dup.x32 sp(16)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:220: (8 bytes): end := (output.length - (1));
	<append+?>: dup.x32 sp(15)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(5)
	cmplStd/lib/text/Format.ci:224: (65 bytes): for ( ; pos < end; pos := pos + 1)
	<append+?>: jmp +56
	cmplStd/lib/text/Format.ci:225: (29 bytes): fraction := Math.modf(fraction * (10), &value);
	<append+?>: load.z64
	<append+?>: dup.x64 sp(3)
	<append+?>: load.f64 10.000000
	<append+?>: mul.f64
	<append+?>: load.sp(+60)
	<append+?>: load.ref <?> ;Math.modf(x: float64, intPart: float64): float64
	<append+?>: call
	<append+?>: inc.sp(-12)
	<append+?>: set.x64 sp(3)
	cmplStd/lib/text/Format.ci:226: (15 bytes): output[pos] := (('0') + int32(value));
	<append+?>: load.c32 48
	<append+?>: dup.x64 sp(12)
	<append+?>: f64.2i32
	<append+?>: add.i32
	<append+?>: dup.x32 sp(15)
	<append+?>: dup.x32 sp(15)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:224: (8 bytes): pos := pos + 1
	<append+?>: dup.x32 sp(13)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:224: (9 bytes): pos < end
	<append+?>: dup.x32 sp(13)
	<append+?>: dup.x32 sp(5)
	<append+?>: clt.i32
	<append+?>: jnz -57
	cmplStd/lib/text/Format.ci:229: (17 bytes): if (pos >= (output.length))
	<append+?>: dup.x32 sp(13)
	<append+?>: dup.x32 sp(16)
	<append+?>: clt.i32
	<append+?>: jnz +12
	cmplStd/lib/text/Format.ci:230: (8 bytes): pos := (output.length - (1));
	<append+?>: dup.x32 sp(15)
	<append+?>: inc.i32(-1)
	<append+?>: set.x32 sp(14)
	cmplStd/lib/text/Format.ci:233: (26 bytes): if (!format.trimDecimal)
	<append+?>: dup.x32 sp(10)
	<append+?>: inc.i32(+12)
	<append+?>: load.is8
	<append+?>: jnz +19
	cmplStd/lib/text/Format.ci:234: (7 bytes): output[pos] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(15)
	<append+?>: dup.x32 sp(15)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:235: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(16, 13)
	<append+?>: inc.sp(-36)
	<append+?>: ret
	cmplStd/lib/text/Format.ci:239: (91 bytes): for (i: int32 := pos - 1; i >= dotIndex; i := i - 1)
	<append+?>: dup.x32 sp(13)
	<append+?>: inc.i32(-1)
	<append+?>: jmp +72
	cmplStd/lib/text/Format.ci:240: (64 bytes): if (output[i] != '0')
	<append+?>: dup.x32 sp(15)
	<append+?>: dup.x32 sp(1)
	<append+?>: add.i32
	<append+?>: load.is8
	<append+?>: load.c32 48
	<append+?>: ceq.i32
	<append+?>: jnz +52
	cmplStd/lib/text/Format.ci:241: (24 bytes): if (i == dotIndex)
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(2)
	<append+?>: ceq.i32
	<append+?>: jz +19
	cmplStd/lib/text/Format.ci:243: (7 bytes): output[i] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(16)
	<append+?>: dup.x32 sp(2)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:244: (8 bytes): return .result := i;
	<append+?>: mov.x32 sp(17, 0)
	<append+?>: inc.sp(-40)
	<append+?>: ret
	cmplStd/lib/text/Format.ci:246: (11 bytes): output[i + 1] := (0);
	<append+?>: load.z32
	<append+?>: dup.x32 sp(16)
	<append+?>: dup.x32 sp(2)
	<append+?>: inc.i32(+1)
	<append+?>: add.i32
	<append+?>: store.i8
	cmplStd/lib/text/Format.ci:247: (13 bytes): return .result := i + 1;
	<append+?>: dup.x32 sp(0)
	<append+?>: inc.i32(+1)
	<append+?>: set.x32 sp(18)
	<append+?>: inc.sp(-40)
	<append+?>: ret
	cmplStd/lib/text/Format.ci:239: (4 bytes): i := i - 1
	<append+?>: inc.i32(-1)
	cmplStd/lib/text/Format.ci:239: (9 bytes): i >= dotIndex
	<append+?>: dup.x32 sp(0)
	<append+?>: dup.x32 sp(2)
	<append+?>: clt.i32
	<append+?>: jz -73
	<append+?>: inc.sp(-4)
	cmplStd/lib/text/Format.ci:251: (8 bytes): return .result := pos;
	<append+?>: mov.x32 sp(16, 13)
	<append+?>: inc.sp(-36)
	<append+?>: ret
.usages:
	cmplStd/lib/text/stream/TextStream.ci:135: referenced as `append`
	cmplStd/lib/text/Format.ci:279: referenced as `append`
}
append(output: char[], pos: int32, value: uint64, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:255'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint64 (size: 8, cast: u64)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, uint64(value), format)
.usages:
	cmplStd/lib/text/stream/TextStream.ci:121: referenced as `append`
}
append(output: char[], pos: int32, value: uint32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:258'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint32 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, uint64(value), format)
.usages:
	cmplStd/lib/text/stream/TextStream.ci:114: referenced as `append`
}
append(output: char[], pos: int32, value: uint16, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:261'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint16 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, uint64(value), format)
.usages:
	cmplStd/lib/text/Format.ci:393: referenced as `append`
}
append(output: char[], pos: int32, value: uint8, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:264'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: uint8 (size: 4, cast: u32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, uint64(value), format)
.usages:
	cmplStd/lib/text/Format.ci:459: referenced as `append`
	cmplStd/lib/text/Format.ci:440: referenced as `append`
	cmplStd/lib/text/Format.ci:409: referenced as `append`
	cmplStd/lib/text/Format.ci:397: referenced as `append`
	cmplStd/lib/text/Format.ci:385: referenced as `append`
	cmplStd/lib/text/Format.ci:371: referenced as `append`
	cmplStd/lib/text/Format.ci:363: referenced as `append`
}
append(output: char[], pos: int32, value: int64, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:267'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int64 (size: 8, cast: i64)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, int64(value), format)
.usages:
	cmplStd/lib/text/stream/TextStream.ci:107: referenced as `append`
	cmplStd/lib/text/Format.ci:436: referenced as `append`
}
append(output: char[], pos: int32, value: int32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:270'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int32 (size: 4, cast: i32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, int64(value), format)
.usages:
	cmplStd/lib/text/stream/TextStream.ci:100: referenced as `append`
	cmplStd/lib/text/Format.ci:565: referenced as `append`
	cmplStd/lib/text/Format.ci:475: referenced as `append`
	cmplStd/lib/text/Format.ci:471: referenced as `append`
	cmplStd/lib/text/Format.ci:452: referenced as `append`
	cmplStd/lib/text/Format.ci:418: referenced as `append`
	cmplStd/lib/text/Format.ci:405: referenced as `append`
	cmplStd/lib/text/Format.ci:401: referenced as `append`
	cmplStd/lib/text/Format.ci:389: referenced as `append`
	cmplStd/lib/text/Format.ci:359: referenced as `append`
}
append(output: char[], pos: int32, value: int16, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:273'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int16 (size: 4, cast: i32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, int64(value), format)
.usages:
}
append(output: char[], pos: int32, value: int8, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:276'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: int8 (size: 4, cast: i32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, 10, int64(value), format)
.usages:
}
append(output: char[], pos: int32, value: float32, format: FormatFlags): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:279'
.param .result: int32 (size: 4, cast: i32)
.param output: char[] (size: 8, cast: arr)
.param pos: int32 (size: 4, cast: i32)
.param value: float32 (size: 4, cast: f32)
.param format: FormatFlags (size: 4, cast: const ref)
.doc: 'Append a number to the output at the given position'
.value: append(output, pos, float64(value), format)
.usages:
	cmplStd/lib/text/stream/TextStream.ci:128: referenced as `append`
}
DatetimeFormat: typename {
.kind: static const typename(val)
.base: `typename`
.size: 80
.name: 'DatetimeFormat'
.file: 'cmplStd/lib/text/Format.ci:298'
.field monthsLong: char[][] (size: 8, cast: const variable(arr))
.field monthsShort: char[][] (size: 8, cast: const variable(arr))
.field weeksLong: char[][] (size: 8, cast: const variable(arr))
.field weeksShort: char[][] (size: 8, cast: const variable(arr))
.field amPmUpper: char[][] (size: 8, cast: const variable(arr))
.field amPmLower: char[][] (size: 8, cast: const variable(arr))
.field dateLong: char[] (size: 8, cast: const variable(arr))
.field timeLong: char[] (size: 8, cast: const variable(arr))
.field dateShort: char[] (size: 8, cast: const variable(arr))
.field timeShort: char[] (size: 8, cast: const variable(arr))
.field format: function (size: 2638, cast: static function)
.field format: function (size: 23, cast: static function)
.doc: 'datetime regional formatter, currently 'en' if instantiated with: `DatetimeFormat fmt = {};`'
.usages:
	cmplStd/lib/text/Format.ci:550: referenced as `DatetimeFormat`
	cmplStd/lib/text/Format.ci:501: referenced as `DatetimeFormat`
	cmplStd/lib/text/Format.ci:313: referenced as `DatetimeFormat`
}
DatetimeFormat.monthsLong: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'monthsLong'
.file: 'cmplStd/lib/text/Format.ci:302'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:551: referenced as `monthsLong`
	cmplStd/lib/text/Format.ci:354: referenced as `monthsLong`
}
DatetimeFormat.monthsShort: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'monthsShort'
.file: 'cmplStd/lib/text/Format.ci:303'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:552: referenced as `monthsShort`
	cmplStd/lib/text/Format.ci:381: referenced as `monthsShort`
	cmplStd/lib/text/Format.ci:350: referenced as `monthsShort`
}
DatetimeFormat.weeksLong: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'weeksLong'
.file: 'cmplStd/lib/text/Format.ci:304'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:553: referenced as `weeksLong`
	cmplStd/lib/text/Format.ci:346: referenced as `weeksLong`
}
DatetimeFormat.weeksShort: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'weeksShort'
.file: 'cmplStd/lib/text/Format.ci:305'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:554: referenced as `weeksShort`
	cmplStd/lib/text/Format.ci:342: referenced as `weeksShort`
}
DatetimeFormat.amPmUpper: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'amPmUpper'
.file: 'cmplStd/lib/text/Format.ci:306'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:555: referenced as `amPmUpper`
	cmplStd/lib/text/Format.ci:422: referenced as `amPmUpper`
}
DatetimeFormat.amPmLower: char[][] {
.kind: const variable(arr)
.base: `char[][]`
.size: 8
.name: 'amPmLower'
.file: 'cmplStd/lib/text/Format.ci:307'
.owner: DatetimeFormat
.usages:
	cmplStd/lib/text/Format.ci:556: referenced as `amPmLower`
	cmplStd/lib/text/Format.ci:426: referenced as `amPmLower`
}
DatetimeFormat.dateLong: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'dateLong'
.file: 'cmplStd/lib/text/Format.ci:308'
.owner: DatetimeFormat
.value: "%A %d %B %Y"
.usages:
	internal usages: 1
}
DatetimeFormat.timeLong: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'timeLong'
.file: 'cmplStd/lib/text/Format.ci:309'
.owner: DatetimeFormat
.value: "%r"
.usages:
	internal usages: 1
}
DatetimeFormat.dateShort: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'dateShort'
.file: 'cmplStd/lib/text/Format.ci:310'
.owner: DatetimeFormat
.value: "%x"
.usages:
	cmplStd/lib/text/Format.ci:463: referenced as `dateShort`
	internal usages: 1
}
DatetimeFormat.timeShort: char[] {
.kind: const variable(arr)
.base: `char[]`
.size: 8
.name: 'timeShort'
.file: 'cmplStd/lib/text/Format.ci:311'
.owner: DatetimeFormat
.value: "%I:%M %p"
.usages:
	cmplStd/lib/text/Format.ci:467: referenced as `timeShort`
	internal usages: 1
}
DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32: function {
.kind: static function
.base: `function`
.size: 2638
.name: 'format'
.file: 'cmplStd/lib/text/Format.ci:313'
.owner: DatetimeFormat
.param .result: int32 (size: 4, cast: variable(i32))
.param formatter: DatetimeFormat (size: 4, cast: const variable(ref))
.param output: char[] (size: 8, cast: variable(arr))
.param end: int32 (size: 4, cast: variable(i32))
.param value: Datetime (size: 4, cast: const variable(ref))
.param format: char[] (size: 8, cast: const variable(arr))
.value: {
	hours24to12(hour: int32): int32 := hour > 12 ? hour - 12 : hour == 0 ? 12 : hour;
	if (pointer(format) == null) {
		return .result := format(formatter, output, end, value, "%Y.%m.%d");
	}
	chr: char := 0;
	for (pos: int32 := 0; pos < (format.length); pos := pos + 1) {
		if (end >= (output.length)) {
			output[output.length - (1)] := (0);
			return .result := output.length - (1);
		}
		chr := format[pos];
		if (chr != '%') {
			output[end] := chr;
			end := end + 1;
			continue;
		}
		flags: FormatFlags := FormatFlags.read(format, &pos);
		chr := format[pos];
		if (chr == '%') {
			end := append(output, end, "%");
		}
		else if (chr == 'a') {
			end := append(output, end, formatter.weeksShort[indexOf(value.dayOfWeek)]);
		}
		else if (chr == 'A') {
			end := append(output, end, formatter.weeksLong[indexOf(value.dayOfWeek)]);
		}
		else if (chr == 'b') {
			end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
		}
		else if (chr == 'B') {
			end := append(output, end, formatter.monthsLong[indexOf(value.month)]);
		}
		else if (chr == 'C') {
			end := append(output, end, value.year / 100, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'd') {
			end := append(output, end, value.day, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'D') {
			end := format(formatter, output, end, value, "%m/%d/%y");
		}
		else if (chr == 'e') {
			end := append(output, end, value.day, FormatFlags.defPad(flags, 2, ' '));
		}
		else if (chr == 'F') {
			end := format(formatter, output, end, value, "%04Y-%m-%d");
		}
		else if (chr == 'h') {
			end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
		}
		else if (chr == 'H') {
			end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'I') {
			end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'j') {
			end := append(output, end, value.dayOfYear, FormatFlags.defPad(flags, 3, '0'));
		}
		else if (chr == 'k') {
			end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, ' '));
		}
		else if (chr == 'l') {
			end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, ' '));
		}
		else if (chr == 'm') {
			end := append(output, end, indexOf(value.month) + 1, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'M') {
			end := append(output, end, value.minute, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'n') {
			end := append(output, end, "\n");
		}
		else if (chr == 'N') {
			end := append(output, end, (value.millis) * 1000000, FormatFlags.defPad(flags, 9, '0'));
		}
		else if (chr == 'p') {
			end := append(output, end, formatter.amPmUpper[int32((value.hour) < 12)]);
		}
		else if (chr == 'P') {
			end := append(output, end, formatter.amPmLower[int32((value.hour) < 12)]);
		}
		else if (chr == 'R') {
			end := format(formatter, output, end, value, "%H:%M");
		}
		else if (chr == 's') {
			end := append(output, end, typename.value(Timestamp(value), Timeunit.(Seconds)), flags);
		}
		else if (chr == 'S') {
			end := append(output, end, value.second, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 't') {
			end := append(output, end, "\t");
		}
		else if (chr == 'T') {
			end := format(formatter, output, end, value, "%H:%M:%S");
		}
		else if (chr == 'u') {
			end := append(output, end, indexOf(value.dayOfWeek) + 1, flags);
		}
		else if (chr == 'W') {
			end := append(output, end, value.weekOfYear, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'x') {
			end := format(formatter, output, end, value, formatter.dateShort);
		}
		else if (chr == 'X') {
			end := format(formatter, output, end, value, formatter.timeShort);
		}
		else if (chr == 'y') {
			end := append(output, end, value.year % 100, FormatFlags.defPad(flags, 2, '0'));
		}
		else if (chr == 'Y') {
			end := append(output, end, value.year, flags);
		}
		else {
			abort("unimplemented or invalid format character", chr);
		}
	}
	if (end >= (output.length)) {
		end := (output.length - (1));
	}
	output[end] := (0);
	return .result := end;
}
.instructions: (2638 bytes)
	cmplStd/lib/text/Format.ci:316: (44 bytes): if (pointer(format) == null)
	<format>  : dup.x32 sp(1)
	<format+?>: load.ref <?> ;null
	<format+?>: ceq.i32
	<format+?>: jz +36
	cmplStd/lib/text/Format.ci:317: (32 bytes): return .result := format(formatter, output, end, value, "%Y.%m.%d");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x64 sp(7)
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x32 sp(8)
	<format+?>: load.c32 8
	<format+?>: load.ref <?> ;"%Y.%m.%d"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(9)
	<format+?>: ret
	cmplStd/lib/text/Format.ci:320: (1 byte): chr: char := 0
	<format+?>: load.z32
	cmplStd/lib/text/Format.ci:321: (2561 bytes): for (pos: int32 := 0; pos < (format.length); pos := pos + 1)
	<format+?>: load.z32
	<format+?>: jmp +2547
	cmplStd/lib/text/Format.ci:322: (33 bytes): if (end >= (output.length))
	<format+?>: dup.x32 sp(6)
	<format+?>: dup.x32 sp(9)
	<format+?>: clt.i32
	<format+?>: jnz +28
	cmplStd/lib/text/Format.ci:323: (11 bytes): output[output.length - (1)] := (0);
	<format+?>: load.z32
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x32 sp(10)
	<format+?>: inc.i32(-1)
	<format+?>: add.i32
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:324: (13 bytes): return .result := output.length - (1);
	<format+?>: dup.x32 sp(8)
	<format+?>: inc.i32(-1)
	<format+?>: set.x32 sp(11)
	<format+?>: inc.sp(-8)
	<format+?>: ret
	cmplStd/lib/text/Format.ci:327: (11 bytes): chr := format[pos];
	<format+?>: dup.x32 sp(3)
	<format+?>: dup.x32 sp(1)
	<format+?>: add.i32
	<format+?>: load.is8
	<format+?>: load.sp(+8)
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:328: (38 bytes): if (chr != '%')
	<format+?>: load.sp(+4)
	<format+?>: load.is8
	<format+?>: load.c32 37
	<format+?>: ceq.i32
	<format+?>: jnz +27
	cmplStd/lib/text/Format.ci:329: (11 bytes): output[end] := chr;
	<format+?>: load.sp(+4)
	<format+?>: load.is8
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x32 sp(8)
	<format+?>: add.i32
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:330: (8 bytes): end := end + 1;
	<format+?>: dup.x32 sp(6)
	<format+?>: inc.i32(+1)
	<format+?>: set.x32 sp(7)
	cmplStd/lib/text/Format.ci:331: (4 bytes): continue;
	<format+?>: jmp +2461
	cmplStd/lib/text/Format.ci:334: (20 bytes): flags: FormatFlags := FormatFlags.read(format, &pos)
	<format+?>: inc.sp(+16)
	<format+?>: dup.x64 sp(7)
	<format+?>: load.sp(+24)
	<format+?>: load.ref <?> ;FormatFlags.read(format: char[], pos: int32): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	cmplStd/lib/text/Format.ci:335: (11 bytes): chr := format[pos];
	<format+?>: dup.x32 sp(7)
	<format+?>: dup.x32 sp(5)
	<format+?>: add.i32
	<format+?>: load.is8
	<format+?>: load.sp(+24)
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:337: (2422 bytes): if (chr == '%')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 37
	<format+?>: ceq.i32
	<format+?>: jz +30
	cmplStd/lib/text/Format.ci:338: (22 bytes): end := append(output, end, "%");
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.ref <?> ;"%"
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2385
	cmplStd/lib/text/Format.ci:340: (2381 bytes): if (chr == 'a')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 97
	<format+?>: ceq.i32
	<format+?>: jz +48
	cmplStd/lib/text/Format.ci:342: (40 bytes): end := append(output, end, formatter.weeksShort[indexOf(value.dayOfWeek)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+24)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+36)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2326
	cmplStd/lib/text/Format.ci:344: (2322 bytes): if (chr == 'A')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 65
	<format+?>: ceq.i32
	<format+?>: jz +48
	cmplStd/lib/text/Format.ci:346: (40 bytes): end := append(output, end, formatter.weeksLong[indexOf(value.dayOfWeek)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+16)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+36)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2267
	cmplStd/lib/text/Format.ci:348: (2263 bytes): if (chr == 'b')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 98
	<format+?>: ceq.i32
	<format+?>: jz +48
	cmplStd/lib/text/Format.ci:350: (40 bytes): end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+8)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+4)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2208
	cmplStd/lib/text/Format.ci:352: (2204 bytes): if (chr == 'B')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 66
	<format+?>: ceq.i32
	<format+?>: jz +44
	cmplStd/lib/text/Format.ci:354: (36 bytes): end := append(output, end, formatter.monthsLong[indexOf(value.month)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+4)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2153
	cmplStd/lib/text/Format.ci:357: (2149 bytes): if (chr == 'C')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 67
	<format+?>: ceq.i32
	<format+?>: jz +79
	cmplStd/lib/text/Format.ci:359: (71 bytes): end := append(output, end, value.year / 100, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: load.i32
	<format+?>: load.c32 100
	<format+?>: div.i32
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +2063
	cmplStd/lib/text/Format.ci:361: (2059 bytes): if (chr == 'd')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 100
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:363: (69 bytes): end := append(output, end, value.day, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+5)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1975
	cmplStd/lib/text/Format.ci:365: (1971 bytes): if (chr == 'D')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 68
	<format+?>: ceq.i32
	<format+?>: jz +39
	cmplStd/lib/text/Format.ci:367: (31 bytes): end := format(formatter, output, end, value, "%m/%d/%y");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: load.c32 8
	<format+?>: load.ref <?> ;"%m/%d/%y"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1925
	cmplStd/lib/text/Format.ci:369: (1921 bytes): if (chr == 'e')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 101
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:371: (69 bytes): end := append(output, end, value.day, FormatFlags.defPad(flags, 2, ' '));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 32
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+5)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1837
	cmplStd/lib/text/Format.ci:373: (1833 bytes): if (chr == 'F')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 70
	<format+?>: ceq.i32
	<format+?>: jz +39
	cmplStd/lib/text/Format.ci:375: (31 bytes): end := format(formatter, output, end, value, "%04Y-%m-%d");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: load.c32 10
	<format+?>: load.ref <?> ;"%04Y-%m-%d"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1787
	cmplStd/lib/text/Format.ci:379: (1783 bytes): if (chr == 'h')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 104
	<format+?>: ceq.i32
	<format+?>: jz +48
	cmplStd/lib/text/Format.ci:381: (40 bytes): end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+8)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+4)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1728
	cmplStd/lib/text/Format.ci:383: (1724 bytes): if (chr == 'H')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 72
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:385: (69 bytes): end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1640
	cmplStd/lib/text/Format.ci:387: (1636 bytes): if (chr == 'I')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 73
	<format+?>: ceq.i32
	<format+?>: jz +120
	cmplStd/lib/text/Format.ci:389: (112 bytes): end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: dup.x32 sp(0)
	<format+?>: load.c32 12
	<format+?>: cgt.i32
	<format+?>: jz +14
	<format+?>: dup.x32 sp(0)
	<format+?>: inc.i32(-12)
	<format+?>: jmp +23
	<format+?>: dup.x32 sp(0)
	<format+?>: load.z32
	<format+?>: ceq.i32
	<format+?>: jz +13
	<format+?>: load.c32 12
	<format+?>: jmp +6
	<format+?>: dup.x32 sp(0)
	<format+?>: set.x32 sp(1)
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1509
	cmplStd/lib/text/Format.ci:391: (1505 bytes): if (chr == 'j')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 106
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:393: (69 bytes): end := append(output, end, value.dayOfYear, FormatFlags.defPad(flags, 3, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 3
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+34)
	<format+?>: load.iu16
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1421
	cmplStd/lib/text/Format.ci:395: (1417 bytes): if (chr == 'k')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 107
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:397: (69 bytes): end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, ' '));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 32
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1333
	cmplStd/lib/text/Format.ci:399: (1329 bytes): if (chr == 'l')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 108
	<format+?>: ceq.i32
	<format+?>: jz +120
	cmplStd/lib/text/Format.ci:401: (112 bytes): end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, ' '));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 32
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: dup.x32 sp(0)
	<format+?>: load.c32 12
	<format+?>: cgt.i32
	<format+?>: jz +14
	<format+?>: dup.x32 sp(0)
	<format+?>: inc.i32(-12)
	<format+?>: jmp +23
	<format+?>: dup.x32 sp(0)
	<format+?>: load.z32
	<format+?>: ceq.i32
	<format+?>: jz +13
	<format+?>: load.c32 12
	<format+?>: jmp +6
	<format+?>: dup.x32 sp(0)
	<format+?>: set.x32 sp(1)
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1202
	cmplStd/lib/text/Format.ci:403: (1198 bytes): if (chr == 'm')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 109
	<format+?>: ceq.i32
	<format+?>: jz +85
	cmplStd/lib/text/Format.ci:405: (77 bytes): end := append(output, end, indexOf(value.month) + 1, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+4)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: inc.i32(+1)
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1106
	cmplStd/lib/text/Format.ci:407: (1102 bytes): if (chr == 'M')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 77
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:409: (69 bytes): end := append(output, end, value.minute, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+7)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +1018
	cmplStd/lib/text/Format.ci:411: (1014 bytes): if (chr == 'n')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 110
	<format+?>: ceq.i32
	<format+?>: jz +30
	cmplStd/lib/text/Format.ci:413: (22 bytes): end := append(output, end, "\n");
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.ref <?> ;"\n"
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +977
	cmplStd/lib/text/Format.ci:415: (973 bytes): if (chr == 'N')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 78
	<format+?>: ceq.i32
	<format+?>: jz +83
	cmplStd/lib/text/Format.ci:418: (75 bytes): end := append(output, end, (value.millis) * 1000000, FormatFlags.defPad(flags, 9, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 9
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+10)
	<format+?>: load.iu16
	<format+?>: load.c32 1000000
	<format+?>: mul.i32
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +883
	cmplStd/lib/text/Format.ci:420: (879 bytes): if (chr == 'p')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 112
	<format+?>: ceq.i32
	<format+?>: jz +50
	cmplStd/lib/text/Format.ci:422: (42 bytes): end := append(output, end, formatter.amPmUpper[int32((value.hour) < 12)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+32)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: load.c32 12
	<format+?>: clt.i32
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +822
	cmplStd/lib/text/Format.ci:424: (818 bytes): if (chr == 'P')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 80
	<format+?>: ceq.i32
	<format+?>: jz +50
	cmplStd/lib/text/Format.ci:426: (42 bytes): end := append(output, end, formatter.amPmLower[int32((value.hour) < 12)]);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: dup.x32 sp(17)
	<format+?>: inc.i32(+40)
	<format+?>: load.i32
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+6)
	<format+?>: load.iu8
	<format+?>: load.c32 12
	<format+?>: clt.i32
	<format+?>: mad.u32 8
	<format+?>: load.i32
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +761
	cmplStd/lib/text/Format.ci:430: (757 bytes): if (chr == 'R')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 82
	<format+?>: ceq.i32
	<format+?>: jz +39
	cmplStd/lib/text/Format.ci:432: (31 bytes): end := format(formatter, output, end, value, "%H:%M");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: load.c32 5
	<format+?>: load.ref <?> ;"%H:%M"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +711
	cmplStd/lib/text/Format.ci:434: (707 bytes): if (chr == 's')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 115
	<format+?>: ceq.i32
	<format+?>: jz +82
	cmplStd/lib/text/Format.ci:436: (74 bytes): end := append(output, end, typename.value(Timestamp(value), Timeunit.(Seconds)), flags);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.c32 10
	<format+?>: load.z64
	<format+?>: inc.sp(+8)
	<format+?>: dup.x32 sp(18)
	<format+?>: load.sp(-36)
	<format+?>: copy.mem -40
	<format+?>: inc.sp(+40)
	<format+?>: load.ref <?> ;Timestamp(value: Datetime): Timestamp
	<format+?>: call
	<format+?>: inc.sp(-40)
	<format+?>: load.c64 1000000000
	<format+?>: load.ref <?> ;Timestamp.value(timestamp: Timestamp, precision: Timeunit): int64
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +618
	cmplStd/lib/text/Format.ci:438: (614 bytes): if (chr == 'S')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 83
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:440: (69 bytes): end := append(output, end, value.second, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+8)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +530
	cmplStd/lib/text/Format.ci:442: (526 bytes): if (chr == 't')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 116
	<format+?>: ceq.i32
	<format+?>: jz +30
	cmplStd/lib/text/Format.ci:444: (22 bytes): end := append(output, end, "\t");
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.ref <?> ;"\t"
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, value: char[*]): int32
	<format+?>: call
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +489
	cmplStd/lib/text/Format.ci:446: (485 bytes): if (chr == 'T')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 84
	<format+?>: ceq.i32
	<format+?>: jz +39
	cmplStd/lib/text/Format.ci:448: (31 bytes): end := format(formatter, output, end, value, "%H:%M:%S");
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: load.c32 8
	<format+?>: load.ref <?> ;"%H:%M:%S"
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +439
	cmplStd/lib/text/Format.ci:450: (435 bytes): if (chr == 'u')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 117
	<format+?>: ceq.i32
	<format+?>: jz +50
	cmplStd/lib/text/Format.ci:452: (42 bytes): end := append(output, end, indexOf(value.dayOfWeek) + 1, flags);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(14)
	<format+?>: inc.i32(+36)
	<format+?>: load.iu8
	<format+?>: inc.i32(-1)
	<format+?>: inc.i32(+1)
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +378
	cmplStd/lib/text/Format.ci:457: (374 bytes): if (chr == 'W')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 87
	<format+?>: ceq.i32
	<format+?>: jz +77
	cmplStd/lib/text/Format.ci:459: (69 bytes): end := append(output, end, value.weekOfYear, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: inc.i32(+32)
	<format+?>: load.iu8
	<format+?>: u32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +290
	cmplStd/lib/text/Format.ci:461: (286 bytes): if (chr == 'x')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 120
	<format+?>: ceq.i32
	<format+?>: jz +36
	cmplStd/lib/text/Format.ci:463: (28 bytes): end := format(formatter, output, end, value, formatter.dateShort);
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(19)
	<format+?>: inc.i32(+64)
	<format+?>: load.i64
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +243
	cmplStd/lib/text/Format.ci:465: (239 bytes): if (chr == 'X')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 88
	<format+?>: ceq.i32
	<format+?>: jz +36
	cmplStd/lib/text/Format.ci:467: (28 bytes): end := format(formatter, output, end, value, formatter.timeShort);
	<format+?>: load.z32
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x64 sp(13)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(14)
	<format+?>: dup.x32 sp(19)
	<format+?>: inc.i32(+72)
	<format+?>: load.i64
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +196
	cmplStd/lib/text/Format.ci:469: (192 bytes): if (chr == 'y')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 121
	<format+?>: ceq.i32
	<format+?>: jz +79
	cmplStd/lib/text/Format.ci:471: (71 bytes): end := append(output, end, value.year % 100, FormatFlags.defPad(flags, 2, '0'));
	<format+?>: inc.sp(+16)
	<format+?>: load.sp(+16)
	<format+?>: load.c32 2
	<format+?>: load.c32 48
	<format+?>: load.ref <?> ;FormatFlags.defPad(this: FormatFlags, width: int32, padChr: char): FormatFlags
	<format+?>: call
	<format+?>: inc.sp(-12)
	<format+?>: load.z32
	<format+?>: dup.x64 sp(16)
	<format+?>: dup.x32 sp(17)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(18)
	<format+?>: load.i32
	<format+?>: load.c32 100
	<format+?>: mod.i32
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: mov.x32 sp(4, 0)
	<format+?>: inc.sp(-16)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +106
	cmplStd/lib/text/Format.ci:473: (102 bytes): if (chr == 'Y')
	<format+?>: load.sp(+20)
	<format+?>: load.is8
	<format+?>: load.c32 89
	<format+?>: ceq.i32
	<format+?>: jz +38
	cmplStd/lib/text/Format.ci:475: (30 bytes): end := append(output, end, value.year, flags);
	<format+?>: load.z32
	<format+?>: dup.x64 sp(12)
	<format+?>: dup.x32 sp(13)
	<format+?>: load.c32 10
	<format+?>: dup.x32 sp(14)
	<format+?>: load.i32
	<format+?>: i32.2i64
	<format+?>: load.sp(+28)
	<format+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(11)
	<format+?>: jmp +57
	cmplStd/lib/text/Format.ci:483: (53 bytes): abort("unimplemented or invalid format character", chr);
	<format+?>: load.ref <?> ;char
	<format+?>: load.sp(+24)
	<format+?>: load.c32 1
	<format+?>: load.sp(+4)
	<format+?>: load.ref <?> ;"cmplStd/lib/text/Format.ci"
	<format+?>: load.c32 483
	<format+?>: load.c32 -2
	<format+?>: load.c32 128
	<format+?>: load.ref <?> ;"unimplemented or invalid format character"
	<format+?>: dup.x64 sp(5)
	<format+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<format+?>: inc.sp(-16)
	<format+?>: inc.sp(-16)
	cmplStd/lib/text/Format.ci:321: (4 bytes): pos := pos + 1
	<format+?>: inc.i32(+1)
	cmplStd/lib/text/Format.ci:321: (9 bytes): pos < (format.length)
	<format+?>: dup.x32 sp(0)
	<format+?>: dup.x32 sp(5)
	<format+?>: clt.i32
	<format+?>: jnz -2548
	<format+?>: inc.sp(-4)
	cmplStd/lib/text/Format.ci:487: (17 bytes): if (end >= (output.length))
	<format+?>: dup.x32 sp(5)
	<format+?>: dup.x32 sp(8)
	<format+?>: clt.i32
	<format+?>: jnz +12
	cmplStd/lib/text/Format.ci:488: (8 bytes): end := (output.length - (1));
	<format+?>: dup.x32 sp(7)
	<format+?>: inc.i32(-1)
	<format+?>: set.x32 sp(6)
	cmplStd/lib/text/Format.ci:490: (7 bytes): output[end] := (0);
	<format+?>: load.z32
	<format+?>: dup.x32 sp(7)
	<format+?>: dup.x32 sp(7)
	<format+?>: add.i32
	<format+?>: store.i8
	cmplStd/lib/text/Format.ci:491: (8 bytes): return .result := end;
	<format+?>: mov.x32 sp(9, 5)
	<format+?>: inc.sp(-4)
	<format+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:502: referenced as `format`
	cmplStd/lib/text/Format.ci:467: referenced as `format`
	cmplStd/lib/text/Format.ci:463: referenced as `format`
	cmplStd/lib/text/Format.ci:448: referenced as `format`
	cmplStd/lib/text/Format.ci:432: referenced as `format`
	cmplStd/lib/text/Format.ci:375: referenced as `format`
	cmplStd/lib/text/Format.ci:367: referenced as `format`
	cmplStd/lib/text/Format.ci:317: referenced as `format`
}
DatetimeFormat.format(formatter: DatetimeFormat, output: char[], value: Datetime, format: char[]): int32: function {
.kind: static function
.base: `function`
.size: 23
.name: 'format'
.file: 'cmplStd/lib/text/Format.ci:501'
.owner: DatetimeFormat
.param .result: int32 (size: 4, cast: variable(i32))
.param formatter: DatetimeFormat (size: 4, cast: const variable(ref))
.param output: char[] (size: 8, cast: variable(arr))
.param value: Datetime (size: 4, cast: const variable(ref))
.param format: char[] (size: 8, cast: const variable(arr))
.doc: 'Format date to text
@param value date to format
@param output write output to this buffer
@param format format string
 	@null defaults to: "%Y.%m.%d"'
.value: {
	return .result := format(formatter, output, 0, value, format);
}
.instructions: (23 bytes)
	cmplStd/lib/text/Format.ci:502: (23 bytes): return .result := format(formatter, output, 0, value, format);
	<format>  : load.z32
	<format+?>: dup.x32 sp(7)
	<format+?>: dup.x64 sp(6)
	<format+?>: load.z32
	<format+?>: dup.x32 sp(8)
	<format+?>: dup.x64 sp(7)
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], end: int32, value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-28)
	<format+?>: set.x32 sp(8)
	<format+?>: ret
.usages:
	cmplStd/lib/text/Format.ci:558: referenced as `format`
}
format(value: Datetime, output: char[], format: char[]): int32: function {
.kind: static function
.base: `function`
.size: 25
.name: 'format'
.file: 'cmplStd/lib/text/Format.ci:507'
.param .result: int32 (size: 4, cast: variable(i32))
.param value: Datetime (size: 4, cast: const variable(ref))
.param output: char[] (size: 8, cast: variable(arr))
.param format: char[] (size: 8, cast: const variable(arr))
.doc: 'extension method for backward compatibility, using english region'
.value: {
	static const monthsLongEn: char[][] := {
		monthsLongEn := monthsLongEn.init;
		monthsLongEn.init[0] := ("January");
		monthsLongEn.init[1] := ("February");
		monthsLongEn.init[2] := ("March");
		monthsLongEn.init[3] := ("April");
		monthsLongEn.init[4] := ("May");
		monthsLongEn.init[5] := ("June");
		monthsLongEn.init[6] := ("July");
		monthsLongEn.init[7] := ("August");
		monthsLongEn.init[8] := ("September");
		monthsLongEn.init[9] := ("October");
		monthsLongEn.init[10] := ("November");
		monthsLongEn.init[11] := ("December");
	};
	static const monthsShortEn: char[][] := {
		monthsShortEn := monthsShortEn.init;
		monthsShortEn.init[0] := ("Jan");
		monthsShortEn.init[1] := ("Feb");
		monthsShortEn.init[2] := ("Mar");
		monthsShortEn.init[3] := ("Apr");
		monthsShortEn.init[4] := ("May");
		monthsShortEn.init[5] := ("Jun");
		monthsShortEn.init[6] := ("Jul");
		monthsShortEn.init[7] := ("Aug");
		monthsShortEn.init[8] := ("Sep");
		monthsShortEn.init[9] := ("Oct");
		monthsShortEn.init[10] := ("Nov");
		monthsShortEn.init[11] := ("Dec");
	};
	static const weeksLongEn: char[][] := {
		weeksLongEn := weeksLongEn.init;
		weeksLongEn.init[0] := ("Monday");
		weeksLongEn.init[1] := ("Tuesday");
		weeksLongEn.init[2] := ("Wednesday");
		weeksLongEn.init[3] := ("Thursday");
		weeksLongEn.init[4] := ("Friday");
		weeksLongEn.init[5] := ("Saturday");
		weeksLongEn.init[6] := ("Sunday");
	};
	static const weeksShortEn: char[][] := {
		weeksShortEn := weeksShortEn.init;
		weeksShortEn.init[0] := ("Mon");
		weeksShortEn.init[1] := ("Tue");
		weeksShortEn.init[2] := ("Wed");
		weeksShortEn.init[3] := ("Thu");
		weeksShortEn.init[4] := ("Fri");
		weeksShortEn.init[5] := ("Sat");
		weeksShortEn.init[6] := ("Sun");
	};
	static const amPmUpperEn: char[][] := {
		amPmUpperEn := amPmUpperEn.init;
		amPmUpperEn.init[0] := ("AM");
		amPmUpperEn.init[1] := ("PM");
	};
	static const amPmLowerEn: char[][] := {
		amPmLowerEn := amPmLowerEn.init;
		amPmLowerEn.init[0] := ("am");
		amPmLowerEn.init[1] := ("pm");
	};
	static const fmtEN: DatetimeFormat := {
		fmtEN.monthsLong := (monthsLongEn);
		fmtEN.monthsShort := (monthsShortEn);
		fmtEN.weeksLong := (weeksLongEn);
		fmtEN.weeksShort := (weeksShortEn);
		fmtEN.amPmUpper := (amPmUpperEn);
		fmtEN.amPmLower := (amPmLowerEn);
		fmtEN.dateLong := ("%A %d %B %Y");
		fmtEN.timeLong := ("%r");
		fmtEN.dateShort := ("%x");
		fmtEN.timeShort := ("%I:%M %p");
	};
	return .result := DatetimeFormat.format(fmtEN, output, value, format);
}
.instructions: (25 bytes)
	cmplStd/lib/text/Format.ci:558: (25 bytes): return .result := DatetimeFormat.format(fmtEN, output, value, format);
	<format>  : load.z32
	<format+?>: load.ref <?> ;format.fmtEN
	<format+?>: dup.x64 sp(5)
	<format+?>: dup.x32 sp(9)
	<format+?>: dup.x64 sp(6)
	<format+?>: load.ref <?> ;DatetimeFormat.format(formatter: DatetimeFormat, output: char[], value: Datetime, format: char[]): int32
	<format+?>: call
	<format+?>: inc.sp(-24)
	<format+?>: set.x32 sp(7)
	<format+?>: ret
.usages:
}
append(output: char[], pos: int32, value: int32): int32: function {
.kind: static function
.base: `function`
.size: 31
.name: 'append'
.file: 'cmplStd/lib/text/Format.ci:563'
.param .result: int32 (size: 4, cast: variable(i32))
.param output: char[] (size: 8, cast: variable(arr))
.param pos: int32 (size: 4, cast: variable(i32))
.param value: int32 (size: 4, cast: variable(i32))
.doc: 'Append a number to the output at the given position'
.value: {
	static const format: FormatFlags := {
		format.sign := (0);
		format.padChr := (0);
		format.width := 0;
		format.precision := 10;
		format.trimDecimal := true;
	};
	return .result := append(output, pos, value, format);
}
.instructions: (31 bytes)
	cmplStd/lib/text/Format.ci:565: (31 bytes): return .result := append(output, pos, value, format);
	<append>  : load.z32
	<append+?>: dup.x64 sp(4)
	<append+?>: dup.x32 sp(5)
	<append+?>: load.c32 10
	<append+?>: dup.x32 sp(6)
	<append+?>: i32.2i64
	<append+?>: load.ref <?> ;append.format
	<append+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<append+?>: call
	<append+?>: inc.sp(-28)
	<append+?>: set.x32 sp(6)
	<append+?>: ret
.usages:
}
Closeable: object {
.kind: static const typename(ref)
.base: `object`
.size: 8
.name: 'Closeable'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:2'
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Represents the base class of closeable objects like files, streams, etc'
.usages:
	cmplStd/lib/text/stream/TextStream.ci:74: referenced as `Closeable`
	cmplStd/lib/text/stream/TextStream.ci:48: referenced as `Closeable`
	cmplStd/lib/text/stream/TextStream.ci:21: referenced as `Closeable`
	cmplStd/lib/text/stream/TextStream.ci:7: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:115: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:114: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:44: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:17: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:7: referenced as `Closeable`
	cmplStd/lib/text/stream/ByteStream.ci:5: referenced as `Closeable`
}
Closeable.close(this: Closeable): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'close'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:5'
.owner: Closeable
.param .result: void (size: 0, cast: variable(void))
.param this: Closeable (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:12: referenced as `close`
	cmplStd/lib/text/stream/ByteStream.ci:8: referenced as `close`
}
Closeable.closeSafe(this: Closeable): void: function {
.kind: static function
.base: `function`
.size: 33
.name: 'closeSafe'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:7'
.owner: Closeable
.param .result: void (size: 0, cast: variable(void))
.param this: Closeable (size: 4, cast: variable(ref))
.value: {
	if ((this.close) == null) {
		return;
	}
	this.close(this);
}
.instructions: (33 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:8: (18 bytes): if ((this.close) == null)
	<closeSafe>  : dup.x32 sp(1)
	<closeSafe+?>: inc.i32(+4)
	<closeSafe+?>: load.i32
	<closeSafe+?>: load.ref <?> ;null
	<closeSafe+?>: ceq.i32
	<closeSafe+?>: jz +5
	cmplStd/lib/text/stream/ByteStream.ci:10: (1 byte): return;
	<closeSafe+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:12: (14 bytes): this.close(this);
	<closeSafe+?>: dup.x32 sp(1)
	<closeSafe+?>: dup.x32 sp(2)
	<closeSafe+?>: inc.i32(+4)
	<closeSafe+?>: load.i32
	<closeSafe+?>: call
	<closeSafe+?>: inc.sp(-4)
	<closeSafe+?>: ret
.usages:
	cmplStd/lib/text/stream/TextStream.ci:74: referenced as `closeSafe`
	cmplStd/lib/text/stream/TextStream.ci:21: referenced as `closeSafe`
	cmplStd/lib/text/stream/ByteStream.ci:115: referenced as `closeSafe`
	cmplStd/lib/text/stream/ByteStream.ci:114: referenced as `closeSafe`
}
ByteReader: Closeable {
.kind: static const typename(ref)
.base: `Closeable`
.size: 12
.name: 'ByteReader'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:17'
.field read: function (size: 4, cast: variable(ref))
.field read: function (size: 59, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'ByteReader can be used to read bytes from a stream (~= java:InputStream)'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:7: referenced as `ByteReader`
	cmplStd/lib/text/encoding/Ascii.ci:5: referenced as `ByteReader`
	cmplStd/lib/text/encoding/binary/Base64.ci:166: referenced as `ByteReader`
	cmplStd/lib/text/encoding/binary/Base64.ci:156: referenced as `ByteReader`
	cmplStd/lib/text/encoding/binary/Base64.ci:135: referenced as `ByteReader`
	cmplStd/lib/text/stream/TextStream.ci:10: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:100: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:99: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:76: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:26: referenced as `ByteReader`
	cmplStd/lib/text/stream/ByteStream.ci:23: referenced as `ByteReader`
}
ByteReader.read(this: ByteReader, bytes: uint8[]): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:23'
.owner: ByteReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteReader (size: 4, cast: variable(ref))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of bytes read from the stream into the `bytes` array
in case there is an error -1 should be returned'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:35: referenced as `read`
	cmplStd/lib/text/encoding/Utf8.ci:26: referenced as `read`
	cmplStd/lib/text/encoding/Utf8.ci:18: referenced as `read`
	cmplStd/lib/text/encoding/Utf8.ci:9: referenced as `read`
	cmplStd/lib/text/encoding/Ascii.ci:8: referenced as `read`
	cmplStd/lib/text/encoding/binary/Base64.ci:170: referenced as `read`
	cmplStd/lib/text/stream/ByteStream.ci:105: referenced as `read`
	cmplStd/lib/text/stream/ByteStream.ci:80: referenced as `read`
	cmplStd/lib/text/stream/ByteStream.ci:28: referenced as `read`
}
ByteReader.read(this: ByteReader): int32: function {
.kind: static function
.base: `function`
.size: 59
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:26'
.owner: ByteReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteReader (size: 4, cast: variable(ref))
.doc: 'Read a single byte from the stream, a negative number is returned in case of error'
.value: {
	bytes: uint8[1] := {
		bytes[0] := (0);
	};
	if (read(this, bytes) <= 0) {
		return .result := -1;
	}
	return .result := bytes[0];
}
.instructions: (59 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:27: (10 bytes): bytes: uint8[1] := {...}
	<read>  : inc.sp(+4)
	cmplStd/lib/text/stream/ByteStream.ci:27: (6 bytes): bytes[0] := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+4)
	<read+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:28: (37 bytes): if (read(this, bytes) <= 0)
	<read+?>: load.z32
	<read+?>: dup.x32 sp(3)
	<read+?>: load.c32 1
	<read+?>: load.sp(+12)
	<read+?>: dup.x32 sp(6)
	<read+?>: call
	<read+?>: inc.sp(-12)
	<read+?>: load.z32
	<read+?>: cgt.i32
	<read+?>: jnz +16
	cmplStd/lib/text/stream/ByteStream.ci:29: (12 bytes): return .result := -1;
	<read+?>: load.c32 -1
	<read+?>: set.x32 sp(4)
	<read+?>: inc.sp(-4)
	<read+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:31: (12 bytes): return .result := bytes[0];
	<read+?>: load.sp(+0)
	<read+?>: load.iu8
	<read+?>: set.x32 sp(4)
	<read+?>: inc.sp(-4)
	<read+?>: ret
.usages:
}
ByteWriter: Closeable {
.kind: static const typename(ref)
.base: `Closeable`
.size: 16
.name: 'ByteWriter'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:44'
.field write: function (size: 4, cast: variable(ref))
.field flush: function (size: 4, cast: variable(ref))
.field write: function (size: 42, cast: static function)
.field copy: function (size: 112, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'ByteWriter can be used to write bytes to a stream (~= java:OutputStream)'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:54: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/Ascii.ci:22: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/binary/Base64.ci:44: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/binary/Base64.ci:17: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/binary/Base64.ci:6: referenced as `ByteWriter`
	cmplStd/lib/text/encoding/binary/Base64.ci:2: referenced as `ByteWriter`
	cmplStd/lib/text/stream/TextStream.ci:56: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:101: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:76: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:56: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:53: referenced as `ByteWriter`
	cmplStd/lib/text/stream/ByteStream.ci:48: referenced as `ByteWriter`
}
ByteWriter.write(this: ByteWriter, bytes: uint8[]): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'write'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:48'
.owner: ByteWriter
.param .result: void (size: 0, cast: variable(void))
.param this: ByteWriter (size: 4, cast: variable(ref))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must write all the bytes from the `bytes` array'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:84: referenced as `write`
	cmplStd/lib/text/encoding/Utf8.ci:75: referenced as `write`
	cmplStd/lib/text/encoding/Utf8.ci:67: referenced as `write`
	cmplStd/lib/text/encoding/Utf8.ci:60: referenced as `write`
	cmplStd/lib/text/encoding/Ascii.ci:25: referenced as `write`
	cmplStd/lib/text/encoding/binary/Base64.ci:34: referenced as `write`
	cmplStd/lib/text/encoding/binary/Base64.ci:30: referenced as `write`
	cmplStd/lib/text/encoding/binary/Base64.ci:25: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:79: referenced as `write`
	cmplStd/lib/text/stream/ByteStream.ci:107: referenced as `write`
	cmplStd/lib/text/stream/ByteStream.ci:84: referenced as `write`
	cmplStd/lib/text/stream/ByteStream.ci:58: referenced as `write`
}
ByteWriter.flush(this: ByteWriter): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'flush'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:53'
.owner: ByteWriter
.param .result: void (size: 0, cast: variable(void))
.param this: ByteWriter (size: 4, cast: variable(ref))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
if a buffer is used directly or indirectly this method must flush all buffered data to the stream.'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:126: referenced as `flush`
	cmplStd/lib/text/stream/TextStream.ci:68: referenced as `flush`
}
ByteWriter.write(this: ByteWriter, oneByte: uint8): void: function {
.kind: static function
.base: `function`
.size: 42
.name: 'write'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:56'
.owner: ByteWriter
.param .result: void (size: 0, cast: variable(void))
.param this: ByteWriter (size: 4, cast: variable(ref))
.param oneByte: uint8 (size: 4, cast: variable(u32))
.doc: 'Write a single byte to the stream'
.value: {
	bytes: uint8[1] := {
		bytes[0] := oneByte;
	};
	return .result := this.write(this, bytes);
}
.instructions: (42 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:57: (14 bytes): bytes: uint8[1] := {...}
	<write>  : inc.sp(+4)
	cmplStd/lib/text/stream/ByteStream.ci:57: (10 bytes): bytes[0] := oneByte;
	<write+?>: load.sp(+8)
	<write+?>: load.iu8
	<write+?>: load.sp(+4)
	<write+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:58: (28 bytes): return .result := this.write(this, bytes);
	<write+?>: dup.x32 sp(3)
	<write+?>: load.c32 1
	<write+?>: load.sp(+8)
	<write+?>: dup.x32 sp(6)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
}
ByteWriter.copy(this: ByteWriter, reader: ByteReader): int32: function {
.kind: static function
.base: `function`
.size: 112
.name: 'copy'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:76'
.owner: ByteWriter
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteWriter (size: 4, cast: variable(ref))
.param reader: ByteReader (size: 4, cast: variable(ref))
.doc: 'Copy all bytes from the reader to the writer'
.value: {
	buffer: uint8[4096] := {
	};
	result: int32 := 0;
	for ( ; ; ) {
		read: int32 := reader.read(reader, buffer);
		if (read <= 0) {
			return .result := result;
		}
		this.write(this, buffer[...read]);
		result := result + read;
	}
	return .result := result;
}
.instructions: (112 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:77: (4 bytes): buffer: uint8[4096] := {...}
	<copy>  : inc.sp(+4096)
	cmplStd/lib/text/stream/ByteStream.ci:78: (1 byte): result: int32 := 0
	<copy+?>: load.z32
	cmplStd/lib/text/stream/ByteStream.ci:79: (95 bytes): for ( ; ; )
	<copy+?>: jmp +91
	cmplStd/lib/text/stream/ByteStream.ci:80: (30 bytes): read: int32 := reader.read(reader, buffer)
	<copy+?>: load.z32
	<copy+?>: load.sp(+4108)
	<copy+?>: load.i32
	<copy+?>: load.c32 4096
	<copy+?>: load.sp(+16)
	<copy+?>: load.sp(+4120)
	<copy+?>: load.i32
	<copy+?>: inc.i32(+8)
	<copy+?>: load.i32
	<copy+?>: call
	<copy+?>: inc.sp(-12)
	cmplStd/lib/text/stream/ByteStream.ci:81: (20 bytes): if (read <= 0)
	<copy+?>: dup.x32 sp(0)
	<copy+?>: load.z32
	<copy+?>: cgt.i32
	<copy+?>: jnz +16
	cmplStd/lib/text/stream/ByteStream.ci:82: (12 bytes): return .result := result;
	<copy+?>: dup.x32 sp(1)
	<copy+?>: load.sp(+4120)
	<copy+?>: store.i32
	<copy+?>: inc.sp(-4104)
	<copy+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:84: (26 bytes): this.write(this, buffer[...read]);
	<copy+?>: load.sp(+4112)
	<copy+?>: load.i32
	<copy+?>: dup.x32 sp(1)
	<copy+?>: load.sp(+16)
	<copy+?>: load.sp(+4124)
	<copy+?>: load.i32
	<copy+?>: inc.i32(+8)
	<copy+?>: load.i32
	<copy+?>: call
	<copy+?>: inc.sp(-12)
	cmplStd/lib/text/stream/ByteStream.ci:85: (7 bytes): result := result + read;
	<copy+?>: dup.x32 sp(1)
	<copy+?>: dup.x32 sp(1)
	<copy+?>: add.i32
	<copy+?>: set.x32 sp(2)
	<copy+?>: inc.sp(-4)
	:: (4 bytes)
	<copy+?>: jmp -87
	cmplStd/lib/text/stream/ByteStream.ci:87: (12 bytes): return .result := result;
	<copy+?>: dup.x32 sp(0)
	<copy+?>: load.sp(+4116)
	<copy+?>: store.i32
	<copy+?>: inc.sp(-4100)
	<copy+?>: ret
.usages:
}
CopyReader: ByteReader {
.kind: static const typename(ref)
.base: `ByteReader`
.size: 20
.name: 'CopyReader'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:99'
.field source: ByteReader (size: 4, cast: const variable(ref))
.field clone: ByteWriter (size: 4, cast: const variable(ref))
.field read: function (size: 56, cast: static function)
.field close: function (size: 35, cast: static function)
.field read: function (size: 4, cast: variable(ref))
.field read: function (size: 59, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:113: referenced as `CopyReader`
	cmplStd/lib/text/stream/ByteStream.ci:104: referenced as `CopyReader`
}
CopyReader.source: ByteReader {
.kind: const variable(ref)
.base: `ByteReader`
.size: 4
.name: 'source'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:100'
.owner: CopyReader
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:114: referenced as `source`
	cmplStd/lib/text/stream/ByteStream.ci:105: referenced as `source`
}
CopyReader.clone: ByteWriter {
.kind: const variable(ref)
.base: `ByteWriter`
.size: 4
.name: 'clone'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:101'
.owner: CopyReader
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:115: referenced as `clone`
	cmplStd/lib/text/stream/ByteStream.ci:107: referenced as `clone`
}
CopyReader.read(this: CopyReader, bytes: uint8[]): int32: function {
.kind: static function
.base: `function`
.size: 56
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:104'
.owner: CopyReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: CopyReader (size: 4, cast: variable(ref))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of bytes read from the stream into the `bytes` array
in case there is an error -1 should be returned'
.value: {
	result: int32 := read(this.source, bytes);
	if (result > 0) {
		this.clone.write(this.clone, bytes[...result]);
	}
	return .result := result;
}
.instructions: (56 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:105: (17 bytes): result: int32 := read(this.source, bytes)
	<read>  : load.z32
	<read+?>: dup.x32 sp(4)
	<read+?>: inc.i32(+12)
	<read+?>: load.i32
	<read+?>: dup.x64 sp(3)
	<read+?>: dup.x32 sp(7)
	<read+?>: call
	<read+?>: inc.sp(-12)
	cmplStd/lib/text/stream/ByteStream.ci:106: (36 bytes): if (result > 0)
	<read+?>: dup.x32 sp(0)
	<read+?>: load.z32
	<read+?>: cgt.i32
	<read+?>: jz +32
	cmplStd/lib/text/stream/ByteStream.ci:107: (28 bytes): this.clone.write(this.clone, bytes[...result]);
	<read+?>: dup.x32 sp(4)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: dup.x32 sp(1)
	<read+?>: dup.x32 sp(4)
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: inc.i32(+8)
	<read+?>: load.i32
	<read+?>: call
	<read+?>: inc.sp(-12)
	cmplStd/lib/text/stream/ByteStream.ci:109: (3 bytes): return .result := result;
	<read+?>: set.x32 sp(5)
	<read+?>: ret
.usages:
}
CopyReader.close(this: CopyReader): void: function {
.kind: static function
.base: `function`
.size: 35
.name: 'close'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:113'
.owner: CopyReader
.param .result: void (size: 0, cast: variable(void))
.param this: CopyReader (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	Closeable.closeSafe(this.source);
	Closeable.closeSafe(this.clone);
}
.instructions: (35 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:114: (17 bytes): Closeable.closeSafe(this.source);
	<close>  : dup.x32 sp(1)
	<close+?>: inc.i32(+12)
	<close+?>: load.i32
	<close+?>: load.ref <?> ;Closeable.closeSafe(this: Closeable): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	cmplStd/lib/text/stream/ByteStream.ci:115: (17 bytes): Closeable.closeSafe(this.clone);
	<close+?>: dup.x32 sp(1)
	<close+?>: inc.i32(+16)
	<close+?>: load.i32
	<close+?>: load.ref <?> ;Closeable.closeSafe(this: Closeable): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	<close+?>: ret
.usages:
}
ByteBuffer: typename {
.kind: static const typename(val)
.base: `typename`
.size: 40
.name: 'ByteBuffer'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:120'
.field position: int32 (size: 4, cast: variable(i32))
.field capacity: int32 (size: 4, cast: variable(i32))
.field length: int32 (size: 4, cast: variable(i32))
.field buffer: uint8[*] (size: 4, cast: variable(ref))
.field read: function (size: 75, cast: static function)
.field read: function (size: 4, cast: const variable(ref))
.field read: function (size: 34, cast: static function)
.field read: function (size: 4, cast: const variable(ref))
.field write: function (size: 154, cast: static function)
.field write: function (size: 4, cast: const variable(ref))
.field flush: function (size: 1, cast: static function)
.field flush: function (size: 4, cast: const variable(ref))
.field close: function (size: 28, cast: static function)
.field close: function (size: 4, cast: const variable(ref))
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:179: referenced as `ByteBuffer`
	cmplStd/lib/text/stream/ByteStream.ci:175: referenced as `ByteBuffer`
	cmplStd/lib/text/stream/ByteStream.ci:149: referenced as `ByteBuffer`
	cmplStd/lib/text/stream/ByteStream.ci:140: referenced as `ByteBuffer`
	cmplStd/lib/text/stream/ByteStream.ci:126: referenced as `ByteBuffer`
}
ByteBuffer.position: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'position'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:121'
.owner: ByteBuffer
.value: 0
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:184: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:171: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:170: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:161: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:150: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:145: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:144: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:141: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:135: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:134: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:131: referenced as `position`
	cmplStd/lib/text/stream/ByteStream.ci:127: referenced as `position`
}
ByteBuffer.capacity: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'capacity'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:122'
.owner: ByteBuffer
.value: 32
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:185: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:160: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:156: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:154: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:153: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:151: referenced as `capacity`
	cmplStd/lib/text/stream/ByteStream.ci:124: referenced as `capacity`
}
ByteBuffer.length: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'length'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:123'
.owner: ByteBuffer
.value: 0
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:186: referenced as `length`
	cmplStd/lib/text/stream/ByteStream.ci:141: referenced as `length`
	cmplStd/lib/text/stream/ByteStream.ci:131: referenced as `length`
	cmplStd/lib/text/stream/ByteStream.ci:127: referenced as `length`
}
ByteBuffer.buffer: uint8[*] {
.kind: variable(ref)
.base: `uint8[*]`
.size: 4
.name: 'buffer'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:124'
.owner: ByteBuffer
.value: pointer.alloc(null, capacity)
.usages:
	cmplStd/lib/text/stream/ByteStream.ci:183: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:181: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:170: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:165: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:164: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:162: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:144: referenced as `buffer`
	cmplStd/lib/text/stream/ByteStream.ci:134: referenced as `buffer`
}
ByteBuffer.read(this: ByteBuffer, bytes: uint8[]): int32: function {
.kind: static function
.base: `function`
.size: 75
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:126'
.owner: ByteBuffer
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteBuffer (size: 40, cast: variable(val))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.value: {
	if (this.position >= this.length) {
		return .result := -1;
	}
	for (i: int32 := 0; i < (bytes.length); i := i + 1) {
		if (this.position >= this.length) {
			return .result := i;
		}
		bytes[i] := this.buffer[this.position];
		this.position := this.position + 1;
	}
	return .result := bytes.length;
}
.instructions: (75 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:127: (17 bytes): if (this.position >= this.length)
	<read>  : dup.x32 sp(3)
	<read+?>: dup.x32 sp(6)
	<read+?>: clt.i32
	<read+?>: jnz +12
	cmplStd/lib/text/stream/ByteStream.ci:128: (8 bytes): return .result := -1;
	<read+?>: load.c32 -1
	<read+?>: set.x32 sp(14)
	<read+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:130: (54 bytes): for (i: int32 := 0; i < (bytes.length); i := i + 1)
	<read+?>: load.z32
	<read+?>: jmp +40
	cmplStd/lib/text/stream/ByteStream.ci:131: (12 bytes): if (this.position >= this.length)
	<read+?>: dup.x32 sp(4)
	<read+?>: dup.x32 sp(7)
	<read+?>: clt.i32
	<read+?>: jnz +7
	cmplStd/lib/text/stream/ByteStream.ci:132: (3 bytes): return .result := i;
	<read+?>: set.x32 sp(14)
	<read+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:134: (12 bytes): bytes[i] := this.buffer[this.position];
	<read+?>: dup.x32 sp(7)
	<read+?>: dup.x32 sp(5)
	<read+?>: add.i32
	<read+?>: load.iu8
	<read+?>: dup.x32 sp(3)
	<read+?>: dup.x32 sp(2)
	<read+?>: add.i32
	<read+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:135: (8 bytes): this.position := this.position + 1;
	<read+?>: dup.x32 sp(4)
	<read+?>: inc.i32(+1)
	<read+?>: set.x32 sp(5)
	cmplStd/lib/text/stream/ByteStream.ci:130: (4 bytes): i := i + 1
	<read+?>: inc.i32(+1)
	cmplStd/lib/text/stream/ByteStream.ci:130: (9 bytes): i < (bytes.length)
	<read+?>: dup.x32 sp(0)
	<read+?>: dup.x32 sp(4)
	<read+?>: clt.i32
	<read+?>: jnz -41
	<read+?>: inc.sp(-4)
	cmplStd/lib/text/stream/ByteStream.ci:137: (4 bytes): return .result := bytes.length;
	<read+?>: mov.x32 sp(13, 2)
	<read+?>: ret
.usages:
}
ByteBuffer.read(this: ByteBuffer, bytes: uint8[]): int32: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:126'
.owner: ByteBuffer
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteBuffer (size: 40, cast: variable(val))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.value: read
.usages:
}
ByteBuffer.read(this: ByteBuffer): int32: function {
.kind: static function
.base: `function`
.size: 34
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:140'
.owner: ByteBuffer
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: {
	if (this.position >= this.length) {
		return .result := -1;
	}
	result: int32 := this.buffer[this.position];
	this.position := this.position + 1;
	return .result := result;
}
.instructions: (34 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:141: (17 bytes): if (this.position >= this.length)
	<read>  : dup.x32 sp(1)
	<read+?>: dup.x32 sp(4)
	<read+?>: clt.i32
	<read+?>: jnz +12
	cmplStd/lib/text/stream/ByteStream.ci:142: (8 bytes): return .result := -1;
	<read+?>: load.c32 -1
	<read+?>: set.x32 sp(12)
	<read+?>: ret
	cmplStd/lib/text/stream/ByteStream.ci:144: (6 bytes): result: int32 := this.buffer[this.position]
	<read+?>: dup.x32 sp(4)
	<read+?>: dup.x32 sp(2)
	<read+?>: add.i32
	<read+?>: load.iu8
	cmplStd/lib/text/stream/ByteStream.ci:145: (8 bytes): this.position := this.position + 1;
	<read+?>: dup.x32 sp(2)
	<read+?>: inc.i32(+1)
	<read+?>: set.x32 sp(3)
	cmplStd/lib/text/stream/ByteStream.ci:146: (3 bytes): return .result := result;
	<read+?>: set.x32 sp(12)
	<read+?>: ret
.usages:
}
ByteBuffer.read(this: ByteBuffer): int32: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'read'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:140'
.owner: ByteBuffer
.param .result: int32 (size: 4, cast: variable(i32))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: read
.usages:
}
ByteBuffer.write(this: ByteBuffer, bytes: uint8[]): void: function {
.kind: static function
.base: `function`
.size: 154
.name: 'write'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:149'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.value: {
	size: int32 := this.position + (bytes.length);
	if (size >= this.capacity) {
		this.capacity := this.capacity * 2;
		if (size > 2 * this.capacity) {
			this.capacity := size * 2;
		}
		new: uint8[*] := pointer.alloc(null, this.capacity);
		for (i: int32 := 0; i < this.position; i := i + 1) {
			new[i] := this.buffer[i];
		}
		pointer.alloc(this.buffer, 0);
		this.buffer := (new);
	}
	for (i: int32 := 0; i < (bytes.length); i := i + 1) {
		this.buffer[this.position] := bytes[i];
		this.position := this.position + 1;
	}
}
.instructions: (154 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:150: (5 bytes): size: int32 := this.position + (bytes.length)
	<write>  : dup.x32 sp(3)
	<write+?>: dup.x32 sp(3)
	<write+?>: add.i32
	cmplStd/lib/text/stream/ByteStream.ci:151: (102 bytes): if (size >= this.capacity)
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(6)
	<write+?>: clt.i32
	<write+?>: jnz +97
	cmplStd/lib/text/stream/ByteStream.ci:153: (10 bytes): this.capacity := this.capacity * 2;
	<write+?>: dup.x32 sp(5)
	<write+?>: load.c32 2
	<write+?>: mul.i32
	<write+?>: set.x32 sp(6)
	cmplStd/lib/text/stream/ByteStream.ci:154: (25 bytes): if (size > 2 * this.capacity)
	<write+?>: dup.x32 sp(0)
	<write+?>: load.c32 2
	<write+?>: dup.x32 sp(7)
	<write+?>: mul.i32
	<write+?>: cgt.i32
	<write+?>: jz +14
	cmplStd/lib/text/stream/ByteStream.ci:156: (10 bytes): this.capacity := size * 2;
	<write+?>: dup.x32 sp(0)
	<write+?>: load.c32 2
	<write+?>: mul.i32
	<write+?>: set.x32 sp(6)
	cmplStd/lib/text/stream/ByteStream.ci:160: (11 bytes): new: uint8[*] := pointer.alloc(null, this.capacity)
	<write+?>: load.ref <?> ;null
	<write+?>: dup.x32 sp(6)
	<write+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/lib/text/stream/ByteStream.ci:161: (34 bytes): for (i: int32 := 0; i < this.position; i := i + 1)
	<write+?>: load.z32
	<write+?>: jmp +20
	cmplStd/lib/text/stream/ByteStream.ci:162: (12 bytes): new[i] := this.buffer[i];
	<write+?>: dup.x32 sp(9)
	<write+?>: dup.x32 sp(1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(2)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:161: (4 bytes): i := i + 1
	<write+?>: inc.i32(+1)
	cmplStd/lib/text/stream/ByteStream.ci:161: (9 bytes): i < this.position
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(7)
	<write+?>: clt.i32
	<write+?>: jnz -21
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/stream/ByteStream.ci:164: (11 bytes): pointer.alloc(this.buffer, 0);
	<write+?>: dup.x32 sp(8)
	<write+?>: load.z32
	<write+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<write+?>: inc.sp(-4)
	<write+?>: set.x32 sp(8)
	<write+?>: load.z32
	<write+?>: jmp +28
	cmplStd/lib/text/stream/ByteStream.ci:170: (12 bytes): this.buffer[this.position] := bytes[i];
	<write+?>: dup.x32 sp(3)
	<write+?>: dup.x32 sp(1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(9)
	<write+?>: dup.x32 sp(7)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/stream/ByteStream.ci:171: (8 bytes): this.position := this.position + 1;
	<write+?>: dup.x32 sp(5)
	<write+?>: inc.i32(+1)
	<write+?>: set.x32 sp(6)
	cmplStd/lib/text/stream/ByteStream.ci:169: (4 bytes): i := i + 1
	<write+?>: inc.i32(+1)
	cmplStd/lib/text/stream/ByteStream.ci:169: (9 bytes): i < (bytes.length)
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(5)
	<write+?>: clt.i32
	<write+?>: jnz -29
	<write+?>: inc.sp(-4)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
}
ByteBuffer.write(this: ByteBuffer, bytes: uint8[]): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'write'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:149'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.param bytes: uint8[] (size: 8, cast: variable(arr))
.value: write
.usages:
}
ByteBuffer.flush(this: ByteBuffer): void: function {
.kind: static function
.base: `function`
.size: 1
.name: 'flush'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:175'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: {
}
.instructions: (1 byte)
	<flush>  : ret
.usages:
}
ByteBuffer.flush(this: ByteBuffer): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'flush'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:175'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: flush
.usages:
}
ByteBuffer.close(this: ByteBuffer): void: function {
.kind: static function
.base: `function`
.size: 28
.name: 'close'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:179'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: {
	pointer.alloc(this.buffer, 0);
	this.buffer := (null);
	this.position := 0;
	this.capacity := 0;
	this.length := 0;
}
.instructions: (28 bytes)
	cmplStd/lib/text/stream/ByteStream.ci:181: (11 bytes): pointer.alloc(this.buffer, 0);
	<close>  : dup.x32 sp(4)
	<close+?>: load.z32
	<close+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<close+?>: inc.sp(-4)
	cmplStd/lib/text/stream/ByteStream.ci:183: (7 bytes): this.buffer := (null);
	<close+?>: load.ref <?> ;null
	<close+?>: set.x32 sp(5)
	cmplStd/lib/text/stream/ByteStream.ci:184: (3 bytes): this.position := 0;
	<close+?>: load.z32
	<close+?>: set.x32 sp(2)
	cmplStd/lib/text/stream/ByteStream.ci:185: (3 bytes): this.capacity := 0;
	<close+?>: load.z32
	<close+?>: set.x32 sp(3)
	cmplStd/lib/text/stream/ByteStream.ci:186: (3 bytes): this.length := 0;
	<close+?>: load.z32
	<close+?>: set.x32 sp(4)
	<close+?>: ret
.usages:
}
ByteBuffer.close(this: ByteBuffer): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'close'
.file: 'cmplStd/lib/text/stream/ByteStream.ci:179'
.owner: ByteBuffer
.param .result: void (size: 0, cast: variable(void))
.param this: ByteBuffer (size: 40, cast: variable(val))
.value: close
.usages:
}
unicode: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'unicode'
.file: 'cmplStd/lib/text/stream/TextStream.ci:3'
.value: uint32
.usages:
}
TextReader: Closeable {
.kind: static const typename(ref)
.base: `Closeable`
.size: 16
.name: 'TextReader'
.file: 'cmplStd/lib/text/stream/TextStream.ci:7'
.field reader: ByteReader (size: 4, cast: const variable(ref))
.field decode: function (size: 4, cast: variable(ref))
.field close: function (size: 18, cast: static function)
.field decode: function (size: 55, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'TextReader can be used to read decoded text from a stream, including basic parsing'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:2: referenced as `TextReader`
	cmplStd/lib/text/encoding/Ascii.ci:2: referenced as `TextReader`
	cmplStd/lib/text/stream/TextStream.ci:168: referenced as `TextReader`
	cmplStd/lib/text/stream/TextStream.ci:25: referenced as `TextReader`
	cmplStd/lib/text/stream/TextStream.ci:19: referenced as `TextReader`
	cmplStd/lib/text/stream/TextStream.ci:16: referenced as `TextReader`
}
TextReader.reader: ByteReader {
.kind: const variable(ref)
.base: `ByteReader`
.size: 4
.name: 'reader'
.file: 'cmplStd/lib/text/stream/TextStream.ci:10'
.owner: TextReader
.doc: '@public'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:7: referenced as `reader`
	cmplStd/lib/text/encoding/Ascii.ci:5: referenced as `reader`
	cmplStd/lib/text/stream/TextStream.ci:21: referenced as `reader`
}
TextReader.decode(this: TextReader, chars: uint32[]): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'decode'
.file: 'cmplStd/lib/text/stream/TextStream.ci:16'
.owner: TextReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: TextReader (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of characters decoded from the stream into the `chars` array
in case there is an error -1 should be returned'
.usages:
	cmplStd/lib/text/stream/TextStream.ci:172: referenced as `decode`
	cmplStd/lib/text/stream/TextStream.ci:27: referenced as `decode`
}
TextReader.close(this: TextReader): void: function {
.kind: static function
.base: `function`
.size: 18
.name: 'close'
.file: 'cmplStd/lib/text/stream/TextStream.ci:19'
.owner: TextReader
.param .result: void (size: 0, cast: variable(void))
.param this: TextReader (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	Closeable.closeSafe(this.reader);
}
.instructions: (18 bytes)
	cmplStd/lib/text/stream/TextStream.ci:21: (17 bytes): Closeable.closeSafe(this.reader);
	<close>  : dup.x32 sp(1)
	<close+?>: inc.i32(+8)
	<close+?>: load.i32
	<close+?>: load.ref <?> ;Closeable.closeSafe(this: Closeable): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	<close+?>: ret
.usages:
}
TextReader.decode(this: TextReader): int32: function {
.kind: static function
.base: `function`
.size: 55
.name: 'decode'
.file: 'cmplStd/lib/text/stream/TextStream.ci:25'
.owner: TextReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: TextReader (size: 4, cast: variable(ref))
.doc: 'Read a single character from the stream, a negative number is returned in case of error'
.value: {
	chars: uint32[1] := {
		chars[0] := (0);
	};
	if (decode(this, chars) <= 0) {
		return .result := -1;
	}
	return .result := chars[0] & (16777215);
}
.instructions: (55 bytes)
	cmplStd/lib/text/stream/TextStream.ci:26: (7 bytes): chars: uint32[1] := {...}
	<decode>  : inc.sp(+4)
	cmplStd/lib/text/stream/TextStream.ci:26: (3 bytes): chars[0] := (0);
	<decode+?>: load.z32
	<decode+?>: set.x32 sp(1)
	cmplStd/lib/text/stream/TextStream.ci:27: (37 bytes): if (decode(this, chars) <= 0)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(3)
	<decode+?>: load.c32 1
	<decode+?>: load.sp(+12)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.z32
	<decode+?>: cgt.i32
	<decode+?>: jnz +16
	cmplStd/lib/text/stream/TextStream.ci:28: (12 bytes): return .result := -1;
	<decode+?>: load.c32 -1
	<decode+?>: set.x32 sp(4)
	<decode+?>: inc.sp(-4)
	<decode+?>: ret
	cmplStd/lib/text/stream/TextStream.ci:30: (11 bytes): return .result := chars[0] & (16777215);
	<decode+?>: dup.x32 sp(0)
	<decode+?>: b32.and 0xffffff
	<decode+?>: set.x32 sp(4)
	<decode+?>: inc.sp(-4)
	<decode+?>: ret
.usages:
}
TextWriter: Closeable {
.kind: static const typename(ref)
.base: `Closeable`
.size: 36
.name: 'TextWriter'
.file: 'cmplStd/lib/text/stream/TextStream.ci:48'
.field Writeable: object (size: 8, cast: static const typename(ref))
.field writer: ByteWriter (size: 4, cast: const variable(ref))
.field format: FormatFlags (size: 16, cast: const variable(val))
.field encode: function (size: 4, cast: variable(ref))
.field flush: function (size: 25, cast: static function)
.field flush: function (size: 4, cast: const variable(ref))
.field close: function (size: 18, cast: static function)
.field write: function (size: 30, cast: static function)
.field write: function (size: 46, cast: static function)
.field write: function (size: 67, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 71, cast: static function)
.field write: function (size: 70, cast: static function)
.field write: function (size: 20, cast: static function)
.field writeln: function (size: 29, cast: static function)
.field writeln: function (size: 35, cast: static function)
.field copy: function (size: 107, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'TextWriter can be used to write encoded text to a stream, including basic printing'
.usages:
	cmplStd/lib/math/Polynomial.ci:14: referenced as `TextWriter`
	cmplStd/lib/math/Polynomial.ci:4: referenced as `TextWriter`
	cmplStd/lib/text/encoding/Utf8.ci:51: referenced as `TextWriter`
	cmplStd/lib/text/encoding/Ascii.ci:21: referenced as `TextWriter`
	cmplStd/lib/text/encoding/Ascii.ci:19: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:168: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:146: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:146: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:140: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:140: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:133: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:133: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:126: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:126: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:119: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:119: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:112: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:112: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:105: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:105: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:98: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:98: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:90: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:90: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:84: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:84: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:78: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:78: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:72: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:67: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:64: referenced as `TextWriter`
	cmplStd/lib/text/stream/TextStream.ci:52: referenced as `TextWriter`
}
TextWriter.Writeable: object {
.kind: static const typename(ref)
.base: `object`
.size: 8
.name: 'Writeable'
.file: 'cmplStd/lib/text/stream/TextStream.ci:50'
.owner: TextWriter
.field write: function (size: 4, cast: variable(ref))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplStd/lib/math/Polynomial.ci:4: referenced as `Writeable`
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `Writeable`
	cmplStd/lib/text/stream/TextStream.ci:140: referenced as `Writeable`
	cmplStd/lib/text/stream/TextStream.ci:52: referenced as `Writeable`
}
TextWriter.Writeable.write(this: Writeable, writer: TextWriter): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:52'
.owner: TextWriter.Writeable
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter.Writeable (size: 4, cast: variable(ref))
.param writer: TextWriter (size: 4, cast: variable(ref))
.usages:
	cmplStd/lib/text/stream/TextStream.ci:141: referenced as `write`
	internal usages: 1
}
TextWriter.writer: ByteWriter {
.kind: const variable(ref)
.base: `ByteWriter`
.size: 4
.name: 'writer'
.file: 'cmplStd/lib/text/stream/TextStream.ci:56'
.owner: TextWriter
.doc: '@public'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:54: referenced as `writer`
	cmplStd/lib/text/encoding/Ascii.ci:22: referenced as `writer`
	cmplStd/lib/text/stream/TextStream.ci:79: referenced as `writer`
	cmplStd/lib/text/stream/TextStream.ci:74: referenced as `writer`
	cmplStd/lib/text/stream/TextStream.ci:68: referenced as `writer`
}
TextWriter.format: FormatFlags {
.kind: const variable(val)
.base: `FormatFlags`
.size: 16
.name: 'format'
.file: 'cmplStd/lib/text/stream/TextStream.ci:59'
.owner: TextWriter
.doc: 'default formatter'
.usages:
	cmplStd/lib/math/Polynomial.ci:46: referenced as `format`
	cmplStd/lib/math/Polynomial.ci:39: referenced as `format`
}
TextWriter.encode(this: TextWriter, chars: uint32[]): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'encode'
.file: 'cmplStd/lib/text/stream/TextStream.ci:64'
.owner: TextWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must encode and write all the characters from the `chars` array'
.usages:
	cmplStd/lib/text/stream/TextStream.ci:176: referenced as `encode`
}
TextWriter.flush(this: TextWriter): void: function {
.kind: static function
.base: `function`
.size: 25
.name: 'flush'
.file: 'cmplStd/lib/text/stream/TextStream.ci:67'
.owner: TextWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.value: {
	this.writer.flush(this.writer);
}
.instructions: (25 bytes)
	cmplStd/lib/text/stream/TextStream.ci:68: (24 bytes): this.writer.flush(this.writer);
	<flush>  : dup.x32 sp(1)
	<flush+?>: inc.i32(+8)
	<flush+?>: load.i32
	<flush+?>: dup.x32 sp(2)
	<flush+?>: inc.i32(+8)
	<flush+?>: load.i32
	<flush+?>: inc.i32(+12)
	<flush+?>: load.i32
	<flush+?>: call
	<flush+?>: inc.sp(-4)
	<flush+?>: ret
.usages:
}
TextWriter.flush(this: TextWriter): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'flush'
.file: 'cmplStd/lib/text/stream/TextStream.ci:67'
.owner: TextWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.value: flush
.usages:
}
TextWriter.close(this: TextWriter): void: function {
.kind: static function
.base: `function`
.size: 18
.name: 'close'
.file: 'cmplStd/lib/text/stream/TextStream.ci:72'
.owner: TextWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	Closeable.closeSafe(this.writer);
}
.instructions: (18 bytes)
	cmplStd/lib/text/stream/TextStream.ci:74: (17 bytes): Closeable.closeSafe(this.writer);
	<close>  : dup.x32 sp(1)
	<close+?>: inc.i32(+8)
	<close+?>: load.i32
	<close+?>: load.ref <?> ;Closeable.closeSafe(this: Closeable): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	<close+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: char[]): TextWriter: function {
.kind: static function
.base: `function`
.size: 30
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:78'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: char[] (size: 8, cast: variable(arr))
.doc: 'Write an array of raw characters to the stream (no encoding)'
.value: {
	this.writer.write(this.writer, value);
	return .result := this;
}
.instructions: (30 bytes)
	cmplStd/lib/text/stream/TextStream.ci:79: (26 bytes): this.writer.write(this.writer, value);
	<write>  : dup.x32 sp(3)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: dup.x64 sp(2)
	<write+?>: dup.x32 sp(6)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: call
	<write+?>: inc.sp(-12)
	cmplStd/lib/text/stream/TextStream.ci:80: (4 bytes): return .result := this;
	<write+?>: mov.x32 sp(4, 3)
	<write+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:45: referenced as `write`
	cmplStd/lib/math/Polynomial.ci:43: referenced as `write`
	cmplStd/lib/math/Polynomial.ci:35: referenced as `write`
	cmplStd/lib/math/Polynomial.ci:30: referenced as `write`
	cmplStd/lib/math/Polynomial.ci:26: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:147: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:136: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:129: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:122: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:115: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:108: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:101: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:94: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:92: referenced as `write`
	cmplStd/lib/text/stream/TextStream.ci:86: referenced as `write`
}
TextWriter.write(this: TextWriter, value: char): TextWriter: function {
.kind: static function
.base: `function`
.size: 46
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:84'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: char (size: 4, cast: variable(i32))
.doc: 'Write a single raw character to the stream (no encoding)'
.value: {
	buffer: char[1] := {
		buffer[0] := value;
	};
	return .result := write(this, buffer);
}
.instructions: (46 bytes)
	cmplStd/lib/text/stream/TextStream.ci:85: (14 bytes): buffer: char[1] := {...}
	<write>  : inc.sp(+4)
	cmplStd/lib/text/stream/TextStream.ci:85: (10 bytes): buffer[0] := value;
	<write+?>: load.sp(+8)
	<write+?>: load.is8
	<write+?>: load.sp(+4)
	<write+?>: store.i8
	cmplStd/lib/text/stream/TextStream.ci:86: (32 bytes): return .result := write(this, buffer);
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.c32 1
	<write+?>: load.sp(+12)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: set.x32 sp(5)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: bool): TextWriter: function {
.kind: static function
.base: `function`
.size: 67
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:90'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: bool (size: 4, cast: variable(bool))
.doc: 'Write the value of the boolean parameter: "true" or "false"'
.value: {
	if (value) {
		return .result := write(this, "true");
	}
	return .result := write(this, "false");
}
.instructions: (67 bytes)
	cmplStd/lib/text/stream/TextStream.ci:91: (38 bytes): if (value)
	<write>  : load.sp(+4)
	<write+?>: load.is8
	<write+?>: jz +33
	cmplStd/lib/text/stream/TextStream.ci:92: (29 bytes): return .result := write(this, "true");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(3)
	<write+?>: load.c32 4
	<write+?>: load.ref <?> ;"true"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: set.x32 sp(4)
	<write+?>: ret
	cmplStd/lib/text/stream/TextStream.ci:94: (29 bytes): return .result := write(this, "false");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(3)
	<write+?>: load.c32 5
	<write+?>: load.ref <?> ;"false"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: set.x32 sp(4)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: int32, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 76
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:98'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: int32 (size: 4, cast: variable(i32))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 32-bit integer parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (76 bytes)
	cmplStd/lib/text/stream/TextStream.ci:99: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:100: (37 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.c32 10
	<write+?>: load.sp(+1052)
	<write+?>: load.i32
	<write+?>: i32.2i64
	<write+?>: load.sp(+1056)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-28)
	cmplStd/lib/text/stream/TextStream.ci:101: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1044)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1048)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:46: referenced as `write`
}
TextWriter.write(this: TextWriter, value: int64, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 75
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:105'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: int64 (size: 8, cast: variable(i64))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 64-bit integer parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (75 bytes)
	cmplStd/lib/text/stream/TextStream.ci:106: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:107: (36 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.c32 10
	<write+?>: load.sp(+1052)
	<write+?>: load.i64
	<write+?>: load.sp(+1056)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: int64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-28)
	cmplStd/lib/text/stream/TextStream.ci:108: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1048)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1052)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: uint32, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 76
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:112'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: uint32 (size: 4, cast: variable(u32))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 32-bit unsigned integer parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (76 bytes)
	cmplStd/lib/text/stream/TextStream.ci:113: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:114: (37 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.c32 10
	<write+?>: load.sp(+1052)
	<write+?>: load.i32
	<write+?>: u32.2i64
	<write+?>: load.sp(+1056)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-28)
	cmplStd/lib/text/stream/TextStream.ci:115: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1044)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1048)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: uint64, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 75
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:119'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: uint64 (size: 8, cast: variable(u64))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 64-bit unsigned integer parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (75 bytes)
	cmplStd/lib/text/stream/TextStream.ci:120: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:121: (36 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.c32 10
	<write+?>: load.sp(+1052)
	<write+?>: load.i64
	<write+?>: load.sp(+1056)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, radix: int32, value: uint64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-28)
	cmplStd/lib/text/stream/TextStream.ci:122: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1048)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1052)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: float32, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 71
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:126'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: float32 (size: 4, cast: variable(f32))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 32-bit floating-point parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (71 bytes)
	cmplStd/lib/text/stream/TextStream.ci:127: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:128: (32 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.sp(+1048)
	<write+?>: load.i32
	<write+?>: f32.2f64
	<write+?>: load.sp(+1052)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-24)
	cmplStd/lib/text/stream/TextStream.ci:129: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1044)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1048)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
}
TextWriter.write(this: TextWriter, value: float64, flags: FormatFlags): TextWriter: function {
.kind: static function
.base: `function`
.size: 70
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:133'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: float64 (size: 8, cast: variable(f64))
.param flags: FormatFlags (size: 4, cast: const variable(ref))
.doc: 'Write the value of the 64-bit floating-point parameter'
.value: {
	buff: char[1024] := {
	};
	n: int32 := append(buff, 0, value, flags);
	return .result := write(this, buff[...n]);
}
.instructions: (70 bytes)
	cmplStd/lib/text/stream/TextStream.ci:134: (4 bytes): buff: char[1024] := {...}
	<write>  : inc.sp(+1024)
	cmplStd/lib/text/stream/TextStream.ci:135: (31 bytes): n: int32 := append(buff, 0, value, flags)
	<write+?>: load.z32
	<write+?>: load.c32 1024
	<write+?>: load.sp(+8)
	<write+?>: load.z32
	<write+?>: load.sp(+1048)
	<write+?>: load.i64
	<write+?>: load.sp(+1052)
	<write+?>: load.i32
	<write+?>: load.ref <?> ;append(output: char[], pos: int32, value: float64, format: FormatFlags): int32
	<write+?>: call
	<write+?>: inc.sp(-24)
	cmplStd/lib/text/stream/TextStream.ci:136: (35 bytes): return .result := write(this, buff[...n]);
	<write+?>: inc.sp(+4)
	<write+?>: load.sp(+1048)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(2)
	<write+?>: load.sp(+16)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: load.sp(+1052)
	<write+?>: store.i32
	<write+?>: inc.sp(-1028)
	<write+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:39: referenced as `write`
}
TextWriter.write(this: TextWriter, value: Writeable): TextWriter: function {
.kind: static function
.base: `function`
.size: 20
.name: 'write'
.file: 'cmplStd/lib/text/stream/TextStream.ci:140'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: TextWriter.Writeable (size: 4, cast: variable(ref))
.doc: 'Write the value of the writeable parameter'
.value: {
	value.write(value, this);
	return .result := this;
}
.instructions: (20 bytes)
	cmplStd/lib/text/stream/TextStream.ci:141: (16 bytes): value.write(value, this);
	<write>  : dup.x32 sp(1)
	<write+?>: dup.x32 sp(3)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+4)
	<write+?>: load.i32
	<write+?>: call
	<write+?>: inc.sp(-8)
	cmplStd/lib/text/stream/TextStream.ci:142: (4 bytes): return .result := this;
	<write+?>: mov.x32 sp(3, 2)
	<write+?>: ret
.usages:
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `write`
}
TextWriter.writeln(this: TextWriter): TextWriter: function {
.kind: static function
.base: `function`
.size: 29
.name: 'writeln'
.file: 'cmplStd/lib/text/stream/TextStream.ci:146'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.doc: 'Write a newline character'
.value: {
	return .result := write(this, "\n");
}
.instructions: (29 bytes)
	cmplStd/lib/text/stream/TextStream.ci:147: (29 bytes): return .result := write(this, "\n");
	<writeln>  : inc.sp(+4)
	<writeln+?>: dup.x32 sp(2)
	<writeln+?>: load.c32 1
	<writeln+?>: load.ref <?> ;"\n"
	<writeln+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<writeln+?>: call
	<writeln+?>: inc.sp(-12)
	<writeln+?>: set.x32 sp(3)
	<writeln+?>: ret
.usages:
	cmplStd/lib/text/stream/TextStream.ci:151: referenced as `writeln`
}
TextWriter.writeln(this: TextWriter, value: Writeable): TextWriter: function {
.kind: static function
.base: `function`
.size: 35
.name: 'writeln'
.file: 'cmplStd/lib/text/stream/TextStream.ci:151'
.owner: TextWriter
.param .result: TextWriter (size: 4, cast: variable(ref))
.param this: TextWriter (size: 4, cast: variable(ref))
.param value: TextWriter.Writeable (size: 4, cast: variable(ref))
.doc: '@public'
.value: {
	return .result := writeln(write(this, value));
}
.instructions: (35 bytes)
	cmplStd/lib/text/stream/TextStream.ci:151: (35 bytes): return .result := writeln(write(this, value));
	<writeln>  : inc.sp(+4)
	<writeln+?>: inc.sp(+4)
	<writeln+?>: dup.x32 sp(4)
	<writeln+?>: dup.x32 sp(4)
	<writeln+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: Writeable): TextWriter
	<writeln+?>: call
	<writeln+?>: inc.sp(-8)
	<writeln+?>: load.ref <?> ;TextWriter.writeln(this: TextWriter): TextWriter
	<writeln+?>: call
	<writeln+?>: inc.sp(-4)
	<writeln+?>: set.x32 sp(4)
	<writeln+?>: ret
.usages:
}
TextWriter.copy(writer: TextWriter, reader: TextReader): int32: function {
.kind: static function
.base: `function`
.size: 107
.name: 'copy'
.file: 'cmplStd/lib/text/stream/TextStream.ci:168'
.owner: TextWriter
.param .result: int32 (size: 4, cast: variable(i32))
.param writer: TextWriter (size: 4, cast: variable(ref))
.param reader: TextReader (size: 4, cast: variable(ref))
.doc: 'Convert from one encoding to another one.
@returns converted character count.
	 * example: convert utf-8 encoded file to ascii
TextWriter output = AsciiWriter("out.txt");
TextReader input = Utf8Reader("in.txt");
output.write(input);'
.value: {
	buffer: uint32[1024] := {
	};
	result: int32 := 0;
	for ( ; ; ) {
		n: int32 := reader.decode(reader, buffer);
		if (n <= 0) {
			return .result := result;
		}
		encode(writer, buffer[...n]);
		result := result + n;
	}
	return .result := result;
}
.instructions: (107 bytes)
	cmplStd/lib/text/stream/TextStream.ci:169: (4 bytes): buffer: uint32[1024] := {...}
	<copy>  : inc.sp(+4096)
	cmplStd/lib/text/stream/TextStream.ci:170: (1 byte): result: int32 := 0
	<copy+?>: load.z32
	cmplStd/lib/text/stream/TextStream.ci:171: (90 bytes): for ( ; ; )
	<copy+?>: jmp +86
	cmplStd/lib/text/stream/TextStream.ci:172: (30 bytes): n: int32 := reader.decode(reader, buffer)
	<copy+?>: load.z32
	<copy+?>: load.sp(+4108)
	<copy+?>: load.i32
	<copy+?>: load.c32 1024
	<copy+?>: load.sp(+16)
	<copy+?>: load.sp(+4120)
	<copy+?>: load.i32
	<copy+?>: inc.i32(+12)
	<copy+?>: load.i32
	<copy+?>: call
	<copy+?>: inc.sp(-12)
	cmplStd/lib/text/stream/TextStream.ci:173: (20 bytes): if (n <= 0)
	<copy+?>: dup.x32 sp(0)
	<copy+?>: load.z32
	<copy+?>: cgt.i32
	<copy+?>: jnz +16
	cmplStd/lib/text/stream/TextStream.ci:174: (12 bytes): return .result := result;
	<copy+?>: dup.x32 sp(1)
	<copy+?>: load.sp(+4120)
	<copy+?>: store.i32
	<copy+?>: inc.sp(-4104)
	<copy+?>: ret
	cmplStd/lib/text/stream/TextStream.ci:176: (21 bytes): encode(writer, buffer[...n]);
	<copy+?>: load.sp(+4112)
	<copy+?>: load.i32
	<copy+?>: dup.x32 sp(1)
	<copy+?>: load.sp(+16)
	<copy+?>: load.sp(+4104)
	<copy+?>: load.i32
	<copy+?>: call
	<copy+?>: inc.sp(-12)
	cmplStd/lib/text/stream/TextStream.ci:177: (7 bytes): result := result + n;
	<copy+?>: dup.x32 sp(1)
	<copy+?>: dup.x32 sp(1)
	<copy+?>: add.i32
	<copy+?>: set.x32 sp(2)
	<copy+?>: inc.sp(-4)
	:: (4 bytes)
	<copy+?>: jmp -82
	cmplStd/lib/text/stream/TextStream.ci:179: (12 bytes): return .result := result;
	<copy+?>: dup.x32 sp(0)
	<copy+?>: load.sp(+4116)
	<copy+?>: store.i32
	<copy+?>: inc.sp(-4100)
	<copy+?>: ret
.usages:
}
Base64Encoder: ByteWriter {
.kind: static const typename(ref)
.base: `ByteWriter`
.size: 1060
.name: 'Base64Encoder'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:2'
.field lookup: uint8[] (size: 8, cast: static const variable(arr))
.field writer: ByteWriter (size: 4, cast: const variable(ref))
.field buffer: uint8[1024] (size: 1024, cast: variable(val))
.field bufferSize: int32 (size: 4, cast: variable(i32))
.field padding: int32 (size: 4, cast: variable(i32))
.field wrap: int32 (size: 4, cast: const variable(i32))
.field wrapSize: int32 (size: 4, cast: variable(i32))
.field flushBuffer: function (size: 232, cast: static function)
.field write: function (size: 896, cast: static function)
.field flush: function (size: 27, cast: static function)
.field close: function (size: 13, cast: static function)
.field write: function (size: 4, cast: variable(ref))
.field flush: function (size: 4, cast: variable(ref))
.field write: function (size: 42, cast: static function)
.field copy: function (size: 112, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Base64 encoder'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:129: referenced as `Base64Encoder`
	cmplStd/lib/text/encoding/binary/Base64.ci:124: referenced as `Base64Encoder`
	cmplStd/lib/text/encoding/binary/Base64.ci:41: referenced as `Base64Encoder`
	cmplStd/lib/text/encoding/binary/Base64.ci:16: referenced as `Base64Encoder`
}
Base64Encoder.lookup: uint8[] {
.kind: static const variable(arr)
.base: `uint8[]`
.size: 8
.name: 'lookup'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:3'
.owner: Base64Encoder
.value: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:115: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:114: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:107: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:106: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:105: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:92: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:91: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:90: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:89: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:74: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:73: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:67: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:66: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:65: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:57: referenced as `lookup`
	cmplStd/lib/text/encoding/binary/Base64.ci:56: referenced as `lookup`
}
Base64Encoder.writer: ByteWriter {
.kind: const variable(ref)
.base: `ByteWriter`
.size: 4
.name: 'writer'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:6'
.owner: Base64Encoder
.doc: '@public'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:126: referenced as `writer`
	cmplStd/lib/text/encoding/binary/Base64.ci:44: referenced as `writer`
	cmplStd/lib/text/encoding/binary/Base64.ci:17: referenced as `writer`
}
Base64Encoder.buffer: uint8[1024] {
.kind: variable(val)
.base: `uint8[1024]`
.size: 1024
.name: 'buffer'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:8'
.owner: Base64Encoder
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:45: referenced as `buffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:42: referenced as `buffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:33: referenced as `buffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:25: referenced as `buffer`
}
Base64Encoder.bufferSize: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'bufferSize'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:9'
.owner: Base64Encoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:46: referenced as `bufferSize`
	cmplStd/lib/text/encoding/binary/Base64.ci:38: referenced as `bufferSize`
	cmplStd/lib/text/encoding/binary/Base64.ci:18: referenced as `bufferSize`
}
Base64Encoder.padding: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'padding'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:10'
.owner: Base64Encoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:118: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:109: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:71: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:62: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:58: referenced as `padding`
	cmplStd/lib/text/encoding/binary/Base64.ci:54: referenced as `padding`
}
Base64Encoder.wrap: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'wrap'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:13'
.owner: Base64Encoder
.doc: 'wrap at the given position with a newline'
.value: 80
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:32: referenced as `wrap`
	cmplStd/lib/text/encoding/binary/Base64.ci:21: referenced as `wrap`
	cmplStd/lib/text/encoding/binary/Base64.ci:20: referenced as `wrap`
}
Base64Encoder.wrapSize: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'wrapSize'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:14'
.owner: Base64Encoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:35: referenced as `wrapSize`
	cmplStd/lib/text/encoding/binary/Base64.ci:26: referenced as `wrapSize`
	cmplStd/lib/text/encoding/binary/Base64.ci:20: referenced as `wrapSize`
}
Base64Encoder.flushBuffer(this: Base64Encoder): void: function {
.kind: static function
.base: `function`
.size: 232
.name: 'flushBuffer'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:16'
.owner: Base64Encoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Encoder (size: 4, cast: variable(ref))
.value: {
	writer: ByteWriter := this.writer;
	size: int32 := this.bufferSize;
	wrap: int32 := this.wrap - this.wrapSize;
	if (wrap > size || this.wrap == 0) {
		wrap := size;
	}
	writer.write(writer, this.buffer[...wrap]);
	this.wrapSize := this.wrapSize + wrap;
	for ( ; wrap < size; ) {
		writer.write(writer, "\n");
		len: int32 := Math.min(size - wrap, this.wrap);
		buffer: uint8[*] := inc(this.buffer, wrap);
		writer.write(writer, buffer[...len]);
		this.wrapSize := len;
		wrap := wrap + len;
	}
	this.bufferSize := 0;
}
.instructions: (232 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:17: (7 bytes): writer: ByteWriter := this.writer
	<flushBuffer>  : dup.x32 sp(1)
	<flushBuffer+?>: inc.i32(+16)
	<flushBuffer+?>: load.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:18: (7 bytes): size: int32 := this.bufferSize
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: inc.i32(+1044)
	<flushBuffer+?>: load.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:20: (15 bytes): wrap: int32 := this.wrap - this.wrapSize
	<flushBuffer+?>: dup.x32 sp(3)
	<flushBuffer+?>: inc.i32(+1052)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: dup.x32 sp(4)
	<flushBuffer+?>: inc.i32(+1056)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: sub.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:21: (31 bytes): if (wrap > size || this.wrap == 0)
	<flushBuffer+?>: dup.x32 sp(0)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: cgt.i32
	<flushBuffer+?>: dup.x32 sp(0)
	<flushBuffer+?>: jnz +17
	<flushBuffer+?>: inc.sp(-4)
	<flushBuffer+?>: dup.x32 sp(4)
	<flushBuffer+?>: inc.i32(+1052)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: load.z32
	<flushBuffer+?>: ceq.i32
	<flushBuffer+?>: jz +7
	cmplStd/lib/text/encoding/binary/Base64.ci:22: (3 bytes): wrap := size;
	<flushBuffer+?>: mov.x32 sp(0, 1)
	cmplStd/lib/text/encoding/binary/Base64.ci:25: (22 bytes): writer.write(writer, this.buffer[...wrap]);
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: dup.x32 sp(6)
	<flushBuffer+?>: inc.i32(+20)
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+8)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: call
	<flushBuffer+?>: inc.sp(-12)
	cmplStd/lib/text/encoding/binary/Base64.ci:26: (17 bytes): this.wrapSize := this.wrapSize + wrap;
	<flushBuffer+?>: dup.x32 sp(4)
	<flushBuffer+?>: inc.i32(+1056)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: add.i32
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+1056)
	<flushBuffer+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:29: (120 bytes): for ( ; wrap < size; )
	<flushBuffer+?>: jmp +111
	cmplStd/lib/text/encoding/binary/Base64.ci:30: (24 bytes): writer.write(writer, "\n");
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: load.c32 1
	<flushBuffer+?>: load.ref <?> ;"\n"
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+8)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: call
	<flushBuffer+?>: inc.sp(-12)
	cmplStd/lib/text/encoding/binary/Base64.ci:32: (36 bytes): len: int32 := Math.min(size - wrap, this.wrap)
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: sub.i32
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+1052)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: clt.i32
	<flushBuffer+?>: jz +10
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: jmp +6
	<flushBuffer+?>: dup.x32 sp(0)
	<flushBuffer+?>: mov.x32 sp(2, 0)
	<flushBuffer+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/binary/Base64.ci:33: (9 bytes): buffer: uint8[*] := inc(this.buffer, wrap)
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+20)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: add.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:34: (18 bytes): writer.write(writer, buffer[...len]);
	<flushBuffer+?>: dup.x32 sp(4)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: dup.x32 sp(7)
	<flushBuffer+?>: inc.i32(+8)
	<flushBuffer+?>: load.i32
	<flushBuffer+?>: call
	<flushBuffer+?>: inc.sp(-12)
	cmplStd/lib/text/encoding/binary/Base64.ci:35: (9 bytes): this.wrapSize := len;
	<flushBuffer+?>: dup.x32 sp(1)
	<flushBuffer+?>: dup.x32 sp(7)
	<flushBuffer+?>: inc.i32(+1056)
	<flushBuffer+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:36: (7 bytes): wrap := wrap + len;
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: add.i32
	<flushBuffer+?>: set.x32 sp(3)
	<flushBuffer+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/binary/Base64.ci:29: (9 bytes): wrap < size
	<flushBuffer+?>: dup.x32 sp(0)
	<flushBuffer+?>: dup.x32 sp(2)
	<flushBuffer+?>: clt.i32
	<flushBuffer+?>: jnz -112
	cmplStd/lib/text/encoding/binary/Base64.ci:38: (8 bytes): this.bufferSize := 0;
	<flushBuffer+?>: load.z32
	<flushBuffer+?>: dup.x32 sp(5)
	<flushBuffer+?>: inc.i32(+1044)
	<flushBuffer+?>: store.i32
	<flushBuffer+?>: inc.sp(-12)
	<flushBuffer+?>: ret
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:130: referenced as `flushBuffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:125: referenced as `flushBuffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:99: referenced as `flushBuffer`
	cmplStd/lib/text/encoding/binary/Base64.ci:82: referenced as `flushBuffer`
}
Base64Encoder.write(this: Base64Encoder, data: uint8[]): void: function {
.kind: static function
.base: `function`
.size: 896
.name: 'write'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:41'
.owner: Base64Encoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Encoder (size: 4, cast: variable(ref))
.param data: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must write all the bytes from the `bytes` array'
.value: {
	assert(buffer.(length) > 3);
	writer: ByteWriter := this.writer;
	buffer: uint8[] := this.buffer;
	size: int32 := this.bufferSize;
	i: int32 := 0;
	if (size > 3 && buffer[size - 1] == ('=') && data.length > (0)) {
		if (buffer[size - 2] == ('=')) {
			if (data.length < (2)) {
				b: int32 := (this.padding << 6) | (((data[i]) & 255) << 2);
				buffer[size - 3] := lookup[b >> 6 & 63];
				buffer[size - 2] := lookup[b & 63];
				this.padding := b;
				return;
			}
			b: int32 := (this.padding << 12) | (((data[i]) & 255) << 8) | ((data[i + 1]) & 255);
			buffer[size - 3] := lookup[b >> 12 & 63];
			buffer[size - 2] := lookup[b >> 6 & 63];
			buffer[size - 1] := lookup[b & 63];
			i := i + 2;
		}
		else {
			b: int32 := (this.padding << 6) | ((data[i]) & 255);
			buffer[size - 2] := lookup[b >> 6 & 63];
			buffer[size - 1] := lookup[b & 63];
			i := i + 1;
		}
	}
	for (n: int32 := data.length - (2); i < n; i := i + 3) {
		if (size + 4 > (buffer.length)) {
			flushBuffer(this);
		}
		b: int32 := (((data[i + 0]) & 255) << 16) | (((data[i + 1]) & 255) << 8) | (((data[i + 2]) & 255) << 0);
		buffer[size + 0] := lookup[b >> 18 & 63];
		buffer[size + 1] := lookup[b >> 12 & 63];
		buffer[size + 2] := lookup[b >> 6 & 63];
		buffer[size + 3] := lookup[b & 63];
		size := size + 4;
	}
	if (left) {
		if (size + 4 > (buffer.length)) {
			flushBuffer(this);
		}
		if (left == 2) {
			b: int32 := (((data[i + 0]) & 255) << 10) | (((data[i + 1]) & 255) << 2);
			buffer[size + 0] := lookup[b >> 12 & 63];
			buffer[size + 1] := lookup[b >> 6 & 63];
			buffer[size + 2] := lookup[b & 63];
			buffer[size + 3] := ('=');
			this.padding := b;
			size := size + 4;
		}
		else {
			b: int32 := ((data[i]) & 255) << 4;
			buffer[size + 0] := lookup[(b >> 6) & 63];
			buffer[size + 1] := lookup[(b >> 0) & 63];
			buffer[size + 2] := ('=');
			buffer[size + 3] := ('=');
			this.padding := b;
			size := size + 4;
		}
	}
}
.instructions: (896 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:42: (9 bytes): assert(buffer.(length) > 3);
	<write>  : load.z32
	<write+?>: load.sp(+4)
	<write+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/binary/Base64.ci:44: (7 bytes): writer: ByteWriter := this.writer
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+16)
	<write+?>: load.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:45: (11 bytes): buffer: uint8[] := this.buffer
	<write+?>: load.c32 1024
	<write+?>: dup.x32 sp(5)
	<write+?>: inc.i32(+20)
	cmplStd/lib/text/encoding/binary/Base64.ci:46: (6 bytes): size: int32 := this.bufferSize
	<write+?>: dup.x32 sp(6)
	<write+?>: inc.i32(+1044)
	cmplStd/lib/text/encoding/binary/Base64.ci:47: (1 byte): i: int32 := 0
	<write+?>: load.z32
	cmplStd/lib/text/encoding/binary/Base64.ci:50: (359 bytes): if (size > 3 && buffer[size - 1] == ('=') && data.length > (0))
	<write+?>: dup.x32 sp(1)
	<write+?>: load.i32
	<write+?>: load.c32 3
	<write+?>: cgt.i32
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +25
	<write+?>: inc.sp(-4)
	<write+?>: dup.x32 sp(2)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.i32
	<write+?>: inc.i32(-1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: load.c32 61
	<write+?>: ceq.i32
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +12
	<write+?>: inc.sp(-4)
	<write+?>: dup.x32 sp(7)
	<write+?>: load.z32
	<write+?>: cgt.u32
	<write+?>: jz +309
	cmplStd/lib/text/encoding/binary/Base64.ci:51: (305 bytes): if (buffer[size - 2] == ('='))
	<write+?>: dup.x32 sp(2)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.i32
	<write+?>: inc.i32(-2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: load.c32 61
	<write+?>: ceq.i32
	<write+?>: jz +214
	cmplStd/lib/text/encoding/binary/Base64.ci:52: (94 bytes): if (data.length < (2))
	<write+?>: dup.x32 sp(7)
	<write+?>: load.c32 2
	<write+?>: clt.u32
	<write+?>: jz +86
	cmplStd/lib/text/encoding/binary/Base64.ci:54: (20 bytes): b: int32 := (this.padding << 6) | (((data[i]) & 255) << 2)
	<write+?>: dup.x32 sp(8)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	<write+?>: b32.shl 0x06
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x02
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:56: (23 bytes): buffer[size - 3] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:57: (21 bytes): buffer[size - 2] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:58: (9 bytes): this.padding := b;
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(10)
	<write+?>: inc.i32(+1048)
	<write+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:59: (5 bytes): return;
	<write+?>: inc.sp(-24)
	<write+?>: ret
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:62: (33 bytes): b: int32 := (this.padding << 12) | (((data[i]) & 255) << 8) | ((data[i + 1]) & 255)
	<write+?>: dup.x32 sp(8)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	<write+?>: b32.shl 0x0c
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x08
	<write+?>: or.b32
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:65: (23 bytes): buffer[size - 3] := lookup[b >> 12 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x0c
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:66: (23 bytes): buffer[size - 2] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:67: (21 bytes): buffer[size - 1] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:68: (8 bytes): i := i + 2;
	<write+?>: dup.x32 sp(1)
	<write+?>: inc.i32(+2)
	<write+?>: set.x32 sp(2)
	<write+?>: inc.sp(-4)
	<write+?>: jmp +78
	cmplStd/lib/text/encoding/binary/Base64.ci:71: (18 bytes): b: int32 := (this.padding << 6) | ((data[i]) & 255)
	<write+?>: dup.x32 sp(8)
	<write+?>: inc.i32(+1048)
	<write+?>: load.i32
	<write+?>: b32.shl 0x06
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:73: (23 bytes): buffer[size - 2] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:74: (21 bytes): buffer[size - 1] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(4)
	<write+?>: load.i32
	<write+?>: inc.i32(-1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:75: (8 bytes): i := i + 1;
	<write+?>: dup.x32 sp(1)
	<write+?>: inc.i32(+1)
	<write+?>: set.x32 sp(2)
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:80: (201 bytes): for (n: int32 := data.length - (2); i < n; i := i + 3)
	<write+?>: dup.x32 sp(7)
	<write+?>: inc.i32(-2)
	<write+?>: jmp +182
	cmplStd/lib/text/encoding/binary/Base64.ci:81: (26 bytes): if (size + 4 > (buffer.length))
	<write+?>: dup.x32 sp(2)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(5)
	<write+?>: cgt.i32
	<write+?>: jz +16
	cmplStd/lib/text/encoding/binary/Base64.ci:82: (12 bytes): flushBuffer(this);
	<write+?>: dup.x32 sp(9)
	<write+?>: load.ref <?> ;Base64Encoder.flushBuffer(this: Base64Encoder): void
	<write+?>: call
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:86: (42 bytes): b: int32 := (((data[i + 0]) & 255) << 16) | (((data[i + 1]) & 255) << 8) | (((data[i + 2]) & 255) << 0)
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x10
	<write+?>: dup.x32 sp(8)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x08
	<write+?>: or.b32
	<write+?>: dup.x32 sp(8)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: load.z32
	<write+?>: shl.b32
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:89: (21 bytes): buffer[size + 0] := lookup[b >> 18 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x12
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:90: (23 bytes): buffer[size + 1] := lookup[b >> 12 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x0c
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:91: (23 bytes): buffer[size + 2] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:92: (21 bytes): buffer[size + 3] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:93: (10 bytes): size := size + 4;
	<write+?>: dup.x32 sp(3)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(4)
	<write+?>: store.i32
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:80: (8 bytes): i := i + 3
	<write+?>: dup.x32 sp(1)
	<write+?>: inc.i32(+3)
	<write+?>: set.x32 sp(2)
	cmplStd/lib/text/encoding/binary/Base64.ci:80: (9 bytes): i < n
	<write+?>: dup.x32 sp(1)
	<write+?>: dup.x32 sp(1)
	<write+?>: clt.i32
	<write+?>: jnz -183
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:97: (297 bytes): if (left)
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(1)
	<write+?>: sub.i32
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +286
	cmplStd/lib/text/encoding/binary/Base64.ci:98: (26 bytes): if (size + 4 > (buffer.length))
	<write+?>: dup.x32 sp(2)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(5)
	<write+?>: cgt.i32
	<write+?>: jz +16
	cmplStd/lib/text/encoding/binary/Base64.ci:99: (12 bytes): flushBuffer(this);
	<write+?>: dup.x32 sp(9)
	<write+?>: load.ref <?> ;Base64Encoder.flushBuffer(this: Base64Encoder): void
	<write+?>: call
	<write+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:101: (256 bytes): if (left == 2)
	<write+?>: dup.x32 sp(0)
	<write+?>: load.c32 2
	<write+?>: ceq.i32
	<write+?>: jz +139
	cmplStd/lib/text/encoding/binary/Base64.ci:103: (27 bytes): b: int32 := (((data[i + 0]) & 255) << 10) | (((data[i + 1]) & 255) << 2)
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x0a
	<write+?>: dup.x32 sp(8)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x02
	<write+?>: or.b32
	cmplStd/lib/text/encoding/binary/Base64.ci:105: (21 bytes): buffer[size + 0] := lookup[b >> 12 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x0c
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:106: (23 bytes): buffer[size + 1] := lookup[b >> 6 & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:107: (21 bytes): buffer[size + 2] := lookup[b & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:108: (16 bytes): buffer[size + 3] := ('=');
	<write+?>: load.c32 61
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:109: (9 bytes): this.padding := b;
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(11)
	<write+?>: inc.i32(+1048)
	<write+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:110: (10 bytes): size := size + 4;
	<write+?>: dup.x32 sp(3)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(4)
	<write+?>: store.i32
	<write+?>: inc.sp(-4)
	<write+?>: jmp +113
	cmplStd/lib/text/encoding/binary/Base64.ci:113: (10 bytes): b: int32 := ((data[i]) & 255) << 4
	<write+?>: dup.x32 sp(7)
	<write+?>: dup.x32 sp(2)
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: b32.and 0xff
	<write+?>: b32.shl 0x04
	cmplStd/lib/text/encoding/binary/Base64.ci:114: (21 bytes): buffer[size + 0] := lookup[(b >> 6) & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: b32.sar 0x06
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: load.z32
	<write+?>: add.i32
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:115: (23 bytes): buffer[size + 1] := lookup[(b >> 0) & 63];
	<write+?>: load.m32 <?> ;Base64Encoder.lookup
	<write+?>: dup.x32 sp(1)
	<write+?>: load.z32
	<write+?>: sar.b32
	<write+?>: b32.and 0x3f
	<write+?>: add.i32
	<write+?>: load.iu8
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+1)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:116: (16 bytes): buffer[size + 2] := ('=');
	<write+?>: load.c32 61
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+2)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:117: (16 bytes): buffer[size + 3] := ('=');
	<write+?>: load.c32 61
	<write+?>: dup.x32 sp(5)
	<write+?>: dup.x32 sp(5)
	<write+?>: load.i32
	<write+?>: inc.i32(+3)
	<write+?>: add.i32
	<write+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:118: (9 bytes): this.padding := b;
	<write+?>: dup.x32 sp(0)
	<write+?>: dup.x32 sp(11)
	<write+?>: inc.i32(+1048)
	<write+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:119: (10 bytes): size := size + 4;
	<write+?>: dup.x32 sp(3)
	<write+?>: load.i32
	<write+?>: inc.i32(+4)
	<write+?>: dup.x32 sp(4)
	<write+?>: store.i32
	<write+?>: inc.sp(-4)
	<write+?>: inc.sp(-4)
	<write+?>: inc.sp(-20)
	<write+?>: ret
.usages:
}
Base64Encoder.flush(this: Base64Encoder): void: function {
.kind: static function
.base: `function`
.size: 27
.name: 'flush'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:124'
.owner: Base64Encoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Encoder (size: 4, cast: variable(ref))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
if a buffer is used directly or indirectly this method must flush all buffered data to the stream.'
.value: {
	flushBuffer(this);
	flush(this.writer);
}
.instructions: (27 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:125: (12 bytes): flushBuffer(this);
	<flush>  : dup.x32 sp(1)
	<flush+?>: load.ref <?> ;Base64Encoder.flushBuffer(this: Base64Encoder): void
	<flush+?>: call
	<flush+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:126: (14 bytes): flush(this.writer);
	<flush+?>: dup.x32 sp(1)
	<flush+?>: inc.i32(+16)
	<flush+?>: load.i32
	<flush+?>: dup.x32 sp(0)
	<flush+?>: call
	<flush+?>: inc.sp(-4)
	<flush+?>: ret
.usages:
}
Base64Encoder.close(this: Base64Encoder): void: function {
.kind: static function
.base: `function`
.size: 13
.name: 'close'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:129'
.owner: Base64Encoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Encoder (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	flushBuffer(this);
}
.instructions: (13 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:130: (12 bytes): flushBuffer(this);
	<close>  : dup.x32 sp(1)
	<close+?>: load.ref <?> ;Base64Encoder.flushBuffer(this: Base64Encoder): void
	<close+?>: call
	<close+?>: inc.sp(-4)
	<close+?>: ret
.usages:
}
Base64Decoder: ByteReader {
.kind: static const typename(ref)
.base: `ByteReader`
.size: 24
.name: 'Base64Decoder'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:135'
.field lookup: int32[256] (size: 1024, cast: static const variable(val))
.field reader: ByteReader (size: 4, cast: const variable(ref))
.field bitsDecoded: int32 (size: 4, cast: variable(i32))
.field charDecoded: int32 (size: 4, cast: variable(i32))
.field read: function (size: 345, cast: static function)
.field close: function (size: 73, cast: static function)
.field read: function (size: 4, cast: variable(ref))
.field read: function (size: 59, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Base64 decoder'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:190: referenced as `Base64Decoder`
	cmplStd/lib/text/encoding/binary/Base64.ci:162: referenced as `Base64Decoder`
}
Base64Decoder.lookup: int32[256] {
.kind: static const variable(val)
.base: `int32[256]`
.size: 1024
.name: 'lookup'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:136'
.owner: Base64Decoder
.value: {
	lookup[0] := -1;
	lookup[1] := -1;
	lookup[2] := -1;
	lookup[3] := -1;
	lookup[4] := -1;
	lookup[5] := -1;
	lookup[6] := -1;
	lookup[7] := -1;
	lookup[8] := -1;
	lookup[9] := -1;
	lookup[10] := -1;
	lookup[11] := -1;
	lookup[12] := -1;
	lookup[13] := -1;
	lookup[14] := -1;
	lookup[15] := -1;
	lookup[16] := -1;
	lookup[17] := -1;
	lookup[18] := -1;
	lookup[19] := -1;
	lookup[20] := -1;
	lookup[21] := -1;
	lookup[22] := -1;
	lookup[23] := -1;
	lookup[24] := -1;
	lookup[25] := -1;
	lookup[26] := -1;
	lookup[27] := -1;
	lookup[28] := -1;
	lookup[29] := -1;
	lookup[30] := -1;
	lookup[31] := -1;
	lookup[32] := -1;
	lookup[33] := -1;
	lookup[34] := -1;
	lookup[35] := -1;
	lookup[36] := -1;
	lookup[37] := -1;
	lookup[38] := -1;
	lookup[39] := -1;
	lookup[40] := -1;
	lookup[41] := -1;
	lookup[42] := -1;
	lookup[43] := 62;
	lookup[44] := -1;
	lookup[45] := -1;
	lookup[46] := -1;
	lookup[47] := 63;
	lookup[48] := 52;
	lookup[49] := 53;
	lookup[50] := 54;
	lookup[51] := 55;
	lookup[52] := 56;
	lookup[53] := 57;
	lookup[54] := 58;
	lookup[55] := 59;
	lookup[56] := 60;
	lookup[57] := 61;
	lookup[58] := -1;
	lookup[59] := -1;
	lookup[60] := -1;
	lookup[61] := -2;
	lookup[62] := -1;
	lookup[63] := -1;
	lookup[64] := -1;
	lookup[65] := 0;
	lookup[66] := 1;
	lookup[67] := 2;
	lookup[68] := 3;
	lookup[69] := 4;
	lookup[70] := 5;
	lookup[71] := 6;
	lookup[72] := 7;
	lookup[73] := 8;
	lookup[74] := 9;
	lookup[75] := 10;
	lookup[76] := 11;
	lookup[77] := 12;
	lookup[78] := 13;
	lookup[79] := 14;
	lookup[80] := 15;
	lookup[81] := 16;
	lookup[82] := 17;
	lookup[83] := 18;
	lookup[84] := 19;
	lookup[85] := 20;
	lookup[86] := 21;
	lookup[87] := 22;
	lookup[88] := 23;
	lookup[89] := 24;
	lookup[90] := 25;
	lookup[91] := -1;
	lookup[92] := -1;
	lookup[93] := -1;
	lookup[94] := -1;
	lookup[95] := -1;
	lookup[96] := -1;
	lookup[97] := 26;
	lookup[98] := 27;
	lookup[99] := 28;
	lookup[100] := 29;
	lookup[101] := 30;
	lookup[102] := 31;
	lookup[103] := 32;
	lookup[104] := 33;
	lookup[105] := 34;
	lookup[106] := 35;
	lookup[107] := 36;
	lookup[108] := 37;
	lookup[109] := 38;
	lookup[110] := 39;
	lookup[111] := 40;
	lookup[112] := 41;
	lookup[113] := 42;
	lookup[114] := 43;
	lookup[115] := 44;
	lookup[116] := 45;
	lookup[117] := 46;
	lookup[118] := 47;
	lookup[119] := 48;
	lookup[120] := 49;
	lookup[121] := 50;
	lookup[122] := 51;
	lookup[123] := -1;
	lookup[124] := -1;
	lookup[125] := -1;
	lookup[126] := -1;
	lookup[127] := -1;
	lookup[128] := -1;
	lookup[129] := -1;
	lookup[130] := -1;
	lookup[131] := -1;
	lookup[132] := -1;
	lookup[133] := -1;
	lookup[134] := -1;
	lookup[135] := -1;
	lookup[136] := -1;
	lookup[137] := -1;
	lookup[138] := -1;
	lookup[139] := -1;
	lookup[140] := -1;
	lookup[141] := -1;
	lookup[142] := -1;
	lookup[143] := -1;
	lookup[144] := -1;
	lookup[145] := -1;
	lookup[146] := -1;
	lookup[147] := -1;
	lookup[148] := -1;
	lookup[149] := -1;
	lookup[150] := -1;
	lookup[151] := -1;
	lookup[152] := -1;
	lookup[153] := -1;
	lookup[154] := -1;
	lookup[155] := -1;
	lookup[156] := -1;
	lookup[157] := -1;
	lookup[158] := -1;
	lookup[159] := -1;
	lookup[160] := -1;
	lookup[161] := -1;
	lookup[162] := -1;
	lookup[163] := -1;
	lookup[164] := -1;
	lookup[165] := -1;
	lookup[166] := -1;
	lookup[167] := -1;
	lookup[168] := -1;
	lookup[169] := -1;
	lookup[170] := -1;
	lookup[171] := -1;
	lookup[172] := -1;
	lookup[173] := -1;
	lookup[174] := -1;
	lookup[175] := -1;
	lookup[176] := -1;
	lookup[177] := -1;
	lookup[178] := -1;
	lookup[179] := -1;
	lookup[180] := -1;
	lookup[181] := -1;
	lookup[182] := -1;
	lookup[183] := -1;
	lookup[184] := -1;
	lookup[185] := -1;
	lookup[186] := -1;
	lookup[187] := -1;
	lookup[188] := -1;
	lookup[189] := -1;
	lookup[190] := -1;
	lookup[191] := -1;
	lookup[192] := -1;
	lookup[193] := -1;
	lookup[194] := -1;
	lookup[195] := -1;
	lookup[196] := -1;
	lookup[197] := -1;
	lookup[198] := -1;
	lookup[199] := -1;
	lookup[200] := -1;
	lookup[201] := -1;
	lookup[202] := -1;
	lookup[203] := -1;
	lookup[204] := -1;
	lookup[205] := -1;
	lookup[206] := -1;
	lookup[207] := -1;
	lookup[208] := -1;
	lookup[209] := -1;
	lookup[210] := -1;
	lookup[211] := -1;
	lookup[212] := -1;
	lookup[213] := -1;
	lookup[214] := -1;
	lookup[215] := -1;
	lookup[216] := -1;
	lookup[217] := -1;
	lookup[218] := -1;
	lookup[219] := -1;
	lookup[220] := -1;
	lookup[221] := -1;
	lookup[222] := -1;
	lookup[223] := -1;
	lookup[224] := -1;
	lookup[225] := -1;
	lookup[226] := -1;
	lookup[227] := -1;
	lookup[228] := -1;
	lookup[229] := -1;
	lookup[230] := -1;
	lookup[231] := -1;
	lookup[232] := -1;
	lookup[233] := -1;
	lookup[234] := -1;
	lookup[235] := -1;
	lookup[236] := -1;
	lookup[237] := -1;
	lookup[238] := -1;
	lookup[239] := -1;
	lookup[240] := -1;
	lookup[241] := -1;
	lookup[242] := -1;
	lookup[243] := -1;
	lookup[244] := -1;
	lookup[245] := -1;
	lookup[246] := -1;
	lookup[247] := -1;
	lookup[248] := -1;
	lookup[249] := -1;
	lookup[250] := -1;
	lookup[251] := -1;
	lookup[252] := -1;
	lookup[253] := -1;
	lookup[254] := -1;
	lookup[255] := -1;
}
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:179: referenced as `lookup`
}
Base64Decoder.reader: ByteReader {
.kind: const variable(ref)
.base: `ByteReader`
.size: 4
.name: 'reader'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:156'
.owner: Base64Decoder
.doc: '@public'
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:166: referenced as `reader`
}
Base64Decoder.bitsDecoded: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'bitsDecoded'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:159'
.owner: Base64Decoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:191: referenced as `bitsDecoded`
	cmplStd/lib/text/encoding/binary/Base64.ci:191: referenced as `bitsDecoded`
	cmplStd/lib/text/encoding/binary/Base64.ci:167: referenced as `bitsDecoded`
}
Base64Decoder.charDecoded: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'charDecoded'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:160'
.owner: Base64Decoder
.value: 0
.usages:
	cmplStd/lib/text/encoding/binary/Base64.ci:168: referenced as `charDecoded`
}
Base64Decoder.read(this: Base64Decoder, data: uint8[]): int32: function {
.kind: static function
.base: `function`
.size: 345
.name: 'read'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:162'
.owner: Base64Decoder
.param .result: int32 (size: 4, cast: variable(i32))
.param this: Base64Decoder (size: 4, cast: variable(ref))
.param data: uint8[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of bytes read from the stream into the `bytes` array
in case there is an error -1 should be returned'
.value: {
	isWhite(c: char): bool := c == ' ' || c == '\t' || c == '\n' || c == '\r';
	in: uint8[1] := {
		in[0] := (0);
	};
	reader: ByteReader := this.reader;
	bitsDecoded: typename := this.bitsDecoded;
	charDecoded: typename := this.charDecoded;
	for (i: int32 := 0; i < (data.length); ) {
		if (reader.read(reader, in) <= 0) {
			return .result := i;
		}
		else if (in[0] == ('=')) {
			bitsDecoded := bitsDecoded - 2;
		}
		else if (!isWhite(in[0])) {
			bitsDecoded := bitsDecoded + 6;
			charDecoded := charDecoded << 6;
			charDecoded := charDecoded | lookup[in[0]] & 63;
			if (bitsDecoded >= 8) {
				bitsDecoded := bitsDecoded - 8;
				data[i] := uint8(charDecoded >> bitsDecoded);
				i := i + 1;
			}
		}
	}
	return .result := data.length;
}
.instructions: (345 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:165: (10 bytes): in: uint8[1] := {...}
	<read>  : inc.sp(+4)
	cmplStd/lib/text/encoding/binary/Base64.ci:165: (6 bytes): in[0] := (0);
	<read+?>: load.z32
	<read+?>: load.sp(+4)
	<read+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:166: (7 bytes): reader: ByteReader := this.reader
	<read+?>: dup.x32 sp(4)
	<read+?>: inc.i32(+12)
	<read+?>: load.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:169: (320 bytes): for (i: int32 := 0; i < (data.length); )
	<read+?>: load.z32
	<read+?>: jmp +306
	cmplStd/lib/text/encoding/binary/Base64.ci:170: (302 bytes): if (reader.read(reader, in) <= 0)
	<read+?>: load.z32
	<read+?>: dup.x32 sp(2)
	<read+?>: load.c32 1
	<read+?>: load.sp(+20)
	<read+?>: dup.x32 sp(5)
	<read+?>: inc.i32(+8)
	<read+?>: load.i32
	<read+?>: call
	<read+?>: inc.sp(-12)
	<read+?>: load.z32
	<read+?>: cgt.i32
	<read+?>: jnz +16
	cmplStd/lib/text/encoding/binary/Base64.ci:171: (8 bytes): return .result := i;
	<read+?>: mov.x32 sp(7, 0)
	<read+?>: inc.sp(-12)
	<read+?>: ret
	<read+?>: jmp +264
	cmplStd/lib/text/encoding/binary/Base64.ci:173: (260 bytes): if (in[0] == ('='))
	<read+?>: load.sp(+8)
	<read+?>: load.iu8
	<read+?>: load.c32 61
	<read+?>: ceq.i32
	<read+?>: jz +26
	cmplStd/lib/text/encoding/binary/Base64.ci:174: (18 bytes): bitsDecoded := bitsDecoded - 2;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: inc.i32(-2)
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: store.i32
	<read+?>: jmp +227
	cmplStd/lib/text/encoding/binary/Base64.ci:176: (223 bytes): if (!isWhite(in[0]))
	<read+?>: load.sp(+8)
	<read+?>: load.iu8
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.c32 32
	<read+?>: ceq.i32
	<read+?>: dup.x32 sp(0)
	<read+?>: jnz +19
	<read+?>: inc.sp(-4)
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.c32 9
	<read+?>: ceq.i32
	<read+?>: dup.x32 sp(0)
	<read+?>: jnz +19
	<read+?>: inc.sp(-4)
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.c32 10
	<read+?>: ceq.i32
	<read+?>: dup.x32 sp(0)
	<read+?>: jnz +19
	<read+?>: inc.sp(-4)
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.c32 13
	<read+?>: ceq.i32
	<read+?>: load.sp(+0)
	<read+?>: load.is8
	<read+?>: load.sp(+8)
	<read+?>: store.i8
	<read+?>: inc.sp(-4)
	<read+?>: jnz +130
	cmplStd/lib/text/encoding/binary/Base64.ci:177: (18 bytes): bitsDecoded := bitsDecoded + 6;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: inc.i32(+6)
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:178: (16 bytes): charDecoded := charDecoded << 6;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+20)
	<read+?>: load.i32
	<read+?>: b32.shl 0x06
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+20)
	<read+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:179: (32 bytes): charDecoded := charDecoded | lookup[in[0]] & 63;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+20)
	<read+?>: load.i32
	<read+?>: load.ref <?> ;Base64Decoder.lookup
	<read+?>: load.sp(+16)
	<read+?>: load.iu8
	<read+?>: mad.u32 4
	<read+?>: load.i32
	<read+?>: b32.and 0x3f
	<read+?>: or.b32
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+20)
	<read+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:180: (60 bytes): if (bitsDecoded >= 8)
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: load.c32 8
	<read+?>: clt.i32
	<read+?>: jnz +47
	cmplStd/lib/text/encoding/binary/Base64.ci:181: (18 bytes): bitsDecoded := bitsDecoded - 8;
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: inc.i32(-8)
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: store.i32
	cmplStd/lib/text/encoding/binary/Base64.ci:182: (21 bytes): data[i] := uint8(charDecoded >> bitsDecoded);
	<read+?>: dup.x32 sp(6)
	<read+?>: inc.i32(+20)
	<read+?>: load.i32
	<read+?>: dup.x32 sp(7)
	<read+?>: inc.i32(+16)
	<read+?>: load.i32
	<read+?>: sar.b32
	<read+?>: dup.x32 sp(5)
	<read+?>: dup.x32 sp(2)
	<read+?>: add.i32
	<read+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:183: (4 bytes): i := i + 1;
	<read+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/binary/Base64.ci:169: (9 bytes): i < (data.length)
	<read+?>: dup.x32 sp(0)
	<read+?>: dup.x32 sp(6)
	<read+?>: clt.i32
	<read+?>: jnz -307
	<read+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/binary/Base64.ci:187: (8 bytes): return .result := data.length;
	<read+?>: mov.x32 sp(6, 4)
	<read+?>: inc.sp(-8)
	<read+?>: ret
.usages:
}
Base64Decoder.close(this: Base64Decoder): void: function {
.kind: static function
.base: `function`
.size: 73
.name: 'close'
.file: 'cmplStd/lib/text/encoding/binary/Base64.ci:190'
.owner: Base64Decoder
.param .result: void (size: 0, cast: variable(void))
.param this: Base64Decoder (size: 4, cast: variable(ref))
.doc: 'Release the resources hold by this object.'
.value: {
	assert(this.bitsDecoded == 0, "unprocessed bits remaining.", this.bitsDecoded);
}
.instructions: (73 bytes)
	cmplStd/lib/text/encoding/binary/Base64.ci:191: (72 bytes): assert(this.bitsDecoded == 0, "unprocessed bits remaining.", this.bitsDecoded);
	<close>  : load.ref <?> ;int32
	<close+?>: dup.x32 sp(2)
	<close+?>: inc.i32(+16)
	<close+?>: load.c32 1
	<close+?>: load.sp(+4)
	<close+?>: dup.x32 sp(5)
	<close+?>: inc.i32(+16)
	<close+?>: load.i32
	<close+?>: load.z32
	<close+?>: ceq.i32
	<close+?>: jz +8
	<close+?>: jmp +35
	<close+?>: load.ref <?> ;"cmplStd/lib/text/encoding/binary/Base64.ci"
	<close+?>: load.c32 191
	<close+?>: load.c32 -2
	<close+?>: load.c32 128
	<close+?>: load.ref <?> ;"unprocessed bits remaining."
	<close+?>: dup.x64 sp(5)
	<close+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<close+?>: inc.sp(-16)
	<close+?>: ret
.usages:
}
AsciiReader: TextReader {
.kind: static const typename(ref)
.base: `TextReader`
.size: 16
.name: 'AsciiReader'
.file: 'cmplStd/lib/text/encoding/Ascii.ci:2'
.field decode: function (size: 97, cast: static function)
.field reader: ByteReader (size: 4, cast: const variable(ref))
.field decode: function (size: 4, cast: variable(ref))
.field close: function (size: 18, cast: static function)
.field decode: function (size: 55, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Ascii reader converts the given input by mapping every byte to a character'
.usages:
	cmplStd/lib/text/encoding/Ascii.ci:4: referenced as `AsciiReader`
}
AsciiReader.decode(this: AsciiReader, chars: uint32[]): int32: function {
.kind: static function
.base: `function`
.size: 97
.name: 'decode'
.file: 'cmplStd/lib/text/encoding/Ascii.ci:4'
.owner: AsciiReader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: AsciiReader (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of characters decoded from the stream into the `chars` array
in case there is an error -1 should be returned'
.value: {
	reader: ByteReader := this.reader;
	for (i: int32 := 0; i < (chars.length); i := i + 1) {
		value: uint8[1] := {
		};
		if (reader.read(reader, value) <= 0) {
			return .result := i;
		}
		chars[i] := (value[0]);
	}
	return .result := chars.length;
}
.instructions: (97 bytes)
	cmplStd/lib/text/encoding/Ascii.ci:5: (7 bytes): reader: ByteReader := this.reader
	<decode>  : dup.x32 sp(3)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	cmplStd/lib/text/encoding/Ascii.ci:6: (82 bytes): for (i: int32 := 0; i < (chars.length); i := i + 1)
	<decode+?>: load.z32
	<decode+?>: jmp +68
	cmplStd/lib/text/encoding/Ascii.ci:7: (4 bytes): value: uint8[1] := {...}
	<decode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Ascii.ci:8: (38 bytes): if (reader.read(reader, value) <= 0)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(3)
	<decode+?>: load.c32 1
	<decode+?>: load.sp(+12)
	<decode+?>: dup.x32 sp(6)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.z32
	<decode+?>: cgt.i32
	<decode+?>: jnz +12
	cmplStd/lib/text/encoding/Ascii.ci:10: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(7, 1)
	<decode+?>: inc.sp(-12)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Ascii.ci:12: (14 bytes): chars[i] := (value[0]);
	<decode+?>: load.sp(+0)
	<decode+?>: load.iu8
	<decode+?>: dup.x32 sp(5)
	<decode+?>: dup.x32 sp(3)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	<decode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Ascii.ci:6: (4 bytes): i := i + 1
	<decode+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/Ascii.ci:6: (9 bytes): i < (chars.length)
	<decode+?>: dup.x32 sp(0)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: clt.i32
	<decode+?>: jnz -69
	<decode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Ascii.ci:14: (8 bytes): return .result := chars.length;
	<decode+?>: mov.x32 sp(5, 3)
	<decode+?>: inc.sp(-4)
	<decode+?>: ret
.usages:
}
AsciiWriter: TextWriter {
.kind: static const typename(ref)
.base: `TextWriter`
.size: 36
.name: 'AsciiWriter'
.file: 'cmplStd/lib/text/encoding/Ascii.ci:19'
.field encode: function (size: 79, cast: static function)
.field Writeable: object (size: 8, cast: static const typename(ref))
.field writer: ByteWriter (size: 4, cast: const variable(ref))
.field format: FormatFlags (size: 16, cast: const variable(val))
.field encode: function (size: 4, cast: variable(ref))
.field flush: function (size: 25, cast: static function)
.field flush: function (size: 4, cast: const variable(ref))
.field close: function (size: 18, cast: static function)
.field write: function (size: 30, cast: static function)
.field write: function (size: 46, cast: static function)
.field write: function (size: 67, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 71, cast: static function)
.field write: function (size: 70, cast: static function)
.field write: function (size: 20, cast: static function)
.field writeln: function (size: 29, cast: static function)
.field writeln: function (size: 35, cast: static function)
.field copy: function (size: 107, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Ascii Writer converts the given input by chopping each character to a byte'
.usages:
}
AsciiWriter.encode(this: TextWriter, chars: uint32[]): void: function {
.kind: static function
.base: `function`
.size: 79
.name: 'encode'
.file: 'cmplStd/lib/text/encoding/Ascii.ci:21'
.owner: AsciiWriter
.param .result: void (size: 0, cast: variable(void))
.param this: TextWriter (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must encode and write all the characters from the `chars` array'
.value: {
	writer: ByteWriter := this.writer;
	for (i: int32 := 0; i < (chars.length); i := i + 1) {
		value: uint8[1] := {
			value[0] := (chars[i]);
		};
		writer.write(writer, value);
	}
}
.instructions: (79 bytes)
	cmplStd/lib/text/encoding/Ascii.ci:22: (7 bytes): writer: ByteWriter := this.writer
	<encode>  : dup.x32 sp(3)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	cmplStd/lib/text/encoding/Ascii.ci:23: (67 bytes): for (i: int32 := 0; i < (chars.length); i := i + 1)
	<encode+?>: load.z32
	<encode+?>: jmp +53
	cmplStd/lib/text/encoding/Ascii.ci:24: (18 bytes): value: uint8[1] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Ascii.ci:24: (14 bytes): value[0] := (chars[i]);
	<encode+?>: dup.x32 sp(4)
	<encode+?>: dup.x32 sp(2)
	<encode+?>: mad.u32 4
	<encode+?>: load.i32
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Ascii.ci:25: (23 bytes): writer.write(writer, value);
	<encode+?>: dup.x32 sp(2)
	<encode+?>: load.c32 1
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(5)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Ascii.ci:23: (4 bytes): i := i + 1
	<encode+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/Ascii.ci:23: (9 bytes): i < (chars.length)
	<encode+?>: dup.x32 sp(0)
	<encode+?>: dup.x32 sp(5)
	<encode+?>: clt.i32
	<encode+?>: jnz -54
	<encode+?>: inc.sp(-4)
	<encode+?>: inc.sp(-4)
	<encode+?>: ret
.usages:
}
Utf8Reader: TextReader {
.kind: static const typename(ref)
.base: `TextReader`
.size: 16
.name: 'Utf8Reader'
.file: 'cmplStd/lib/text/encoding/Utf8.ci:2'
.field decode: function (size: 945, cast: static function)
.field reader: ByteReader (size: 4, cast: const variable(ref))
.field decode: function (size: 4, cast: variable(ref))
.field close: function (size: 18, cast: static function)
.field decode: function (size: 55, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Utf-8 decoder'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:4: referenced as `Utf8Reader`
}
Utf8Reader.decode(this: Utf8Reader, chars: uint32[]): int32: function {
.kind: static function
.base: `function`
.size: 945
.name: 'decode'
.file: 'cmplStd/lib/text/encoding/Utf8.ci:4'
.owner: Utf8Reader
.param .result: int32 (size: 4, cast: variable(i32))
.param this: Utf8Reader (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must return the number of characters decoded from the stream into the `chars` array
in case there is an error -1 should be returned'
.value: {
	buff: uint8[1] := {
		buff[0] := (0);
	};
	ext: uint8[3] := {
		ext[0] := (0);
	};
	reader: ByteReader := this.reader;
	for (i: int32 := 0; i < (chars.length); i := i + 1) {
		if (reader.read(reader, buff) <= 0) {
			return .result := i;
		}
		if (((buff[0]) & 128) == 0) {
			chars[i] := (buff[0]);
		}
		else if (((buff[0]) & 224) == 192) {
			if (reader.read(reader, ext[...1]) != 1) {
				error("invalid codepoint");
				return .result := i;
			}
			assert(((ext[0]) & 192) == 128, "10xxxxxx");
			chars[i] := (((buff[0]) & 31) << 6 | ((ext[0]) & 63));
		}
		else if (((buff[0]) & 240) == 224) {
			if (reader.read(reader, ext[...2]) != 2) {
				error("invalid codepoint");
				return .result := i;
			}
			assert(((ext[0]) & 192) == 128, "10xxxxxx");
			assert(((ext[1]) & 192) == 128, "10xxxxxx");
			chars[i] := (((buff[0]) & 15) << 12 | ((ext[0]) & 63) << 6 | ((ext[1]) & 63));
		}
		else if (((buff[0]) & 248) == 240) {
			if (reader.read(reader, ext[...3]) != 3) {
				error("invalid codepoint");
				return .result := i;
			}
			assert(((ext[0]) & 192) == 128, "10xxxxxx");
			assert(((ext[1]) & 192) == 128, "10xxxxxx");
			assert(((ext[2]) & 192) == 128, "10xxxxxx");
			chars[i] := (((buff[0]) & 7) << 18 | ((ext[0]) & 63) << 12 | ((ext[1]) & 63) << 6 | ((ext[2]) & 63));
		}
	}
	return .result := chars.length;
}
.instructions: (945 bytes)
	cmplStd/lib/text/encoding/Utf8.ci:5: (10 bytes): buff: uint8[1] := {...}
	<decode>  : inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:5: (6 bytes): buff[0] := (0);
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:6: (10 bytes): ext: uint8[3] := {...}
	<decode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:6: (6 bytes): ext[0] := (0);
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:7: (7 bytes): reader: ByteReader := this.reader
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	cmplStd/lib/text/encoding/Utf8.ci:8: (910 bytes): for (i: int32 := 0; i < (chars.length); i := i + 1)
	<decode+?>: load.z32
	<decode+?>: jmp +896
	cmplStd/lib/text/encoding/Utf8.ci:9: (38 bytes): if (reader.read(reader, buff) <= 0)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(2)
	<decode+?>: load.c32 1
	<decode+?>: load.sp(+24)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.z32
	<decode+?>: cgt.i32
	<decode+?>: jnz +12
	cmplStd/lib/text/encoding/Utf8.ci:11: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(8, 0)
	<decode+?>: inc.sp(-16)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Utf8.ci:14: (850 bytes): if (((buff[0]) & 128) == 0)
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: load.c32 128
	<decode+?>: and.b32
	<decode+?>: load.z32
	<decode+?>: ceq.i32
	<decode+?>: jz +22
	cmplStd/lib/text/encoding/Utf8.ci:15: (14 bytes): chars[i] := (buff[0]);
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: dup.x32 sp(6)
	<decode+?>: dup.x32 sp(2)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	<decode+?>: jmp +819
	cmplStd/lib/text/encoding/Utf8.ci:17: (815 bytes): if (((buff[0]) & 224) == 192)
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: load.c32 224
	<decode+?>: and.b32
	<decode+?>: load.c32 192
	<decode+?>: ceq.i32
	<decode+?>: jz +181
	cmplStd/lib/text/encoding/Utf8.ci:18: (82 bytes): if (reader.read(reader, ext[...1]) != 1)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(2)
	<decode+?>: load.c32 1
	<decode+?>: load.sp(+20)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.c32 1
	<decode+?>: ceq.i32
	<decode+?>: jnz +52
	cmplStd/lib/text/encoding/Utf8.ci:19: (40 bytes): error("invalid codepoint");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 19
	<decode+?>: load.c32 -1
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"invalid codepoint"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:20: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(8, 0)
	<decode+?>: inc.sp(-16)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Utf8.ci:22: (65 bytes): assert(((ext[0]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+16)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 22
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:23: (26 bytes): chars[i] := (((buff[0]) & 31) << 6 | ((ext[0]) & 63));
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x1f
	<decode+?>: b32.shl 0x06
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: or.b32
	<decode+?>: dup.x32 sp(6)
	<decode+?>: dup.x32 sp(2)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	<decode+?>: jmp +621
	cmplStd/lib/text/encoding/Utf8.ci:25: (617 bytes): if (((buff[0]) & 240) == 224)
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: load.c32 240
	<decode+?>: and.b32
	<decode+?>: load.c32 224
	<decode+?>: ceq.i32
	<decode+?>: jz +256
	cmplStd/lib/text/encoding/Utf8.ci:26: (82 bytes): if (reader.read(reader, ext[...2]) != 2)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(2)
	<decode+?>: load.c32 2
	<decode+?>: load.sp(+20)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.c32 2
	<decode+?>: ceq.i32
	<decode+?>: jnz +52
	cmplStd/lib/text/encoding/Utf8.ci:27: (40 bytes): error("invalid codepoint");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 27
	<decode+?>: load.c32 -1
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"invalid codepoint"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:28: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(8, 0)
	<decode+?>: inc.sp(-16)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Utf8.ci:30: (65 bytes): assert(((ext[0]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+16)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 30
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:31: (65 bytes): assert(((ext[1]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+17)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 31
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:32: (36 bytes): chars[i] := (((buff[0]) & 15) << 12 | ((ext[0]) & 63) << 6 | ((ext[1]) & 63));
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x0f
	<decode+?>: b32.shl 0x0c
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: b32.shl 0x06
	<decode+?>: or.b32
	<decode+?>: load.sp(+13)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: or.b32
	<decode+?>: dup.x32 sp(6)
	<decode+?>: dup.x32 sp(2)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	<decode+?>: jmp +348
	cmplStd/lib/text/encoding/Utf8.ci:34: (344 bytes): if (((buff[0]) & 248) == 240)
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: load.c32 248
	<decode+?>: and.b32
	<decode+?>: load.c32 240
	<decode+?>: ceq.i32
	<decode+?>: jz +327
	cmplStd/lib/text/encoding/Utf8.ci:35: (82 bytes): if (reader.read(reader, ext[...3]) != 3)
	<decode+?>: load.z32
	<decode+?>: dup.x32 sp(2)
	<decode+?>: load.c32 3
	<decode+?>: load.sp(+20)
	<decode+?>: dup.x32 sp(5)
	<decode+?>: inc.i32(+8)
	<decode+?>: load.i32
	<decode+?>: call
	<decode+?>: inc.sp(-12)
	<decode+?>: load.c32 3
	<decode+?>: ceq.i32
	<decode+?>: jnz +52
	cmplStd/lib/text/encoding/Utf8.ci:36: (40 bytes): error("invalid codepoint");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 36
	<decode+?>: load.c32 -1
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"invalid codepoint"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:37: (8 bytes): return .result := i;
	<decode+?>: mov.x32 sp(8, 0)
	<decode+?>: inc.sp(-16)
	<decode+?>: ret
	cmplStd/lib/text/encoding/Utf8.ci:39: (65 bytes): assert(((ext[0]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+16)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 39
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:40: (65 bytes): assert(((ext[1]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+17)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 40
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:41: (65 bytes): assert(((ext[2]) & 192) == 128, "10xxxxxx");
	<decode+?>: load.z32
	<decode+?>: load.sp(+4)
	<decode+?>: load.sp(+18)
	<decode+?>: load.iu8
	<decode+?>: load.c32 192
	<decode+?>: and.b32
	<decode+?>: load.c32 128
	<decode+?>: ceq.i32
	<decode+?>: jz +8
	<decode+?>: jmp +35
	<decode+?>: load.ref <?> ;"cmplStd/lib/text/encoding/Utf8.ci"
	<decode+?>: load.c32 41
	<decode+?>: load.c32 -2
	<decode+?>: load.c32 128
	<decode+?>: load.ref <?> ;"10xxxxxx"
	<decode+?>: dup.x64 sp(5)
	<decode+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<decode+?>: inc.sp(-8)
	cmplStd/lib/text/encoding/Utf8.ci:42: (46 bytes): chars[i] := (((buff[0]) & 7) << 18 | ((ext[0]) & 63) << 12 | ((ext[1]) & 63) << 6 | ((ext[2]) & 63));
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x07
	<decode+?>: b32.shl 0x12
	<decode+?>: load.sp(+12)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: b32.shl 0x0c
	<decode+?>: or.b32
	<decode+?>: load.sp(+13)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: b32.shl 0x06
	<decode+?>: or.b32
	<decode+?>: load.sp(+14)
	<decode+?>: load.iu8
	<decode+?>: b32.and 0x3f
	<decode+?>: or.b32
	<decode+?>: dup.x32 sp(6)
	<decode+?>: dup.x32 sp(2)
	<decode+?>: mad.u32 4
	<decode+?>: store.i32
	cmplStd/lib/text/encoding/Utf8.ci:8: (4 bytes): i := i + 1
	<decode+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/Utf8.ci:8: (9 bytes): i < (chars.length)
	<decode+?>: dup.x32 sp(0)
	<decode+?>: dup.x32 sp(7)
	<decode+?>: clt.i32
	<decode+?>: jnz -897
	<decode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Utf8.ci:45: (8 bytes): return .result := chars.length;
	<decode+?>: mov.x32 sp(7, 5)
	<decode+?>: inc.sp(-12)
	<decode+?>: ret
.usages:
}
Utf8Writer: TextWriter {
.kind: static const typename(ref)
.base: `TextWriter`
.size: 36
.name: 'Utf8Writer'
.file: 'cmplStd/lib/text/encoding/Utf8.ci:51'
.field encode: function (size: 367, cast: static function)
.field Writeable: object (size: 8, cast: static const typename(ref))
.field writer: ByteWriter (size: 4, cast: const variable(ref))
.field format: FormatFlags (size: 16, cast: const variable(val))
.field encode: function (size: 4, cast: variable(ref))
.field flush: function (size: 25, cast: static function)
.field flush: function (size: 4, cast: const variable(ref))
.field close: function (size: 18, cast: static function)
.field write: function (size: 30, cast: static function)
.field write: function (size: 46, cast: static function)
.field write: function (size: 67, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 76, cast: static function)
.field write: function (size: 75, cast: static function)
.field write: function (size: 71, cast: static function)
.field write: function (size: 70, cast: static function)
.field write: function (size: 20, cast: static function)
.field writeln: function (size: 29, cast: static function)
.field writeln: function (size: 35, cast: static function)
.field copy: function (size: 107, cast: static function)
.field close: function (size: 4, cast: variable(ref))
.field closeSafe: function (size: 33, cast: static function)
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: 'Utf-8 encoder'
.usages:
	cmplStd/lib/text/encoding/Utf8.ci:53: referenced as `Utf8Writer`
}
Utf8Writer.encode(this: Utf8Writer, chars: uint32[]): void: function {
.kind: static function
.base: `function`
.size: 367
.name: 'encode'
.file: 'cmplStd/lib/text/encoding/Utf8.ci:53'
.owner: Utf8Writer
.param .result: void (size: 0, cast: variable(void))
.param this: Utf8Writer (size: 4, cast: variable(ref))
.param chars: uint32[] (size: 8, cast: variable(arr))
.doc: 'This abstract method must be implemented in subclasses containing the proper implementation
the method must encode and write all the characters from the `chars` array'
.value: {
	writer: ByteWriter := this.writer;
	for (i: int32 := 0; i < (chars.length); i := i + 1) {
		cp: uint32 := chars[i];
		if (cp < (128)) {
			bytes: uint8[1] := {
				bytes[0] := (cp);
			};
			writer.write(writer, bytes[...1]);
		}
		else if (cp < (2048)) {
			bytes: uint8[2] := {
				bytes[0] := (192 | ((cp >> 6)));
				bytes[1] := (128 | ((cp & (63))));
			};
			writer.write(writer, bytes[...2]);
		}
		else if (cp < (65536)) {
			bytes: uint8[3] := {
				bytes[0] := (224 | ((cp >> 12)));
				bytes[1] := (128 | (((cp >> 6) & (63))));
				bytes[2] := (128 | ((cp & (63))));
			};
			writer.write(writer, bytes[...3]);
		}
		else {
			bytes: uint8[4] := {
				bytes[0] := (240 | ((cp >> 18)));
				bytes[1] := (128 | (((cp >> 12) & (63))));
				bytes[2] := (128 | (((cp >> 6) & (63))));
				bytes[3] := (128 | ((cp & (63))));
			};
			writer.write(writer, bytes[...4]);
		}
	}
}
.instructions: (367 bytes)
	cmplStd/lib/text/encoding/Utf8.ci:54: (7 bytes): writer: ByteWriter := this.writer
	<encode>  : dup.x32 sp(3)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	cmplStd/lib/text/encoding/Utf8.ci:55: (355 bytes): for (i: int32 := 0; i < (chars.length); i := i + 1)
	<encode+?>: load.z32
	<encode+?>: jmp +341
	cmplStd/lib/text/encoding/Utf8.ci:56: (9 bytes): cp: uint32 := chars[i]
	<encode+?>: dup.x32 sp(3)
	<encode+?>: dup.x32 sp(1)
	<encode+?>: mad.u32 4
	<encode+?>: load.i32
	cmplStd/lib/text/encoding/Utf8.ci:58: (320 bytes): if (cp < (128))
	<encode+?>: dup.x32 sp(0)
	<encode+?>: load.c32 128
	<encode+?>: clt.u32
	<encode+?>: jz +46
	cmplStd/lib/text/encoding/Utf8.ci:59: (11 bytes): bytes: uint8[1] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:59: (7 bytes): bytes[0] := (cp);
	<encode+?>: dup.x32 sp(1)
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:60: (23 bytes): writer.write(writer, bytes[...1]);
	<encode+?>: dup.x32 sp(3)
	<encode+?>: load.c32 1
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(6)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	<encode+?>: jmp +270
	cmplStd/lib/text/encoding/Utf8.ci:62: (266 bytes): if (cp < (2048))
	<encode+?>: dup.x32 sp(0)
	<encode+?>: load.c32 2048
	<encode+?>: clt.u32
	<encode+?>: jz +69
	cmplStd/lib/text/encoding/Utf8.ci:63: (34 bytes): bytes: uint8[2] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:64: (15 bytes): bytes[0] := (192 | ((cp >> 6)));
	<encode+?>: load.c32 192
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x06
	<encode+?>: or.b32
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:65: (15 bytes): bytes[1] := (128 | ((cp & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+5)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:67: (23 bytes): writer.write(writer, bytes[...2]);
	<encode+?>: dup.x32 sp(3)
	<encode+?>: load.c32 2
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(6)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	<encode+?>: jmp +193
	cmplStd/lib/text/encoding/Utf8.ci:69: (189 bytes): if (cp < (65536))
	<encode+?>: dup.x32 sp(0)
	<encode+?>: load.c32 65536
	<encode+?>: clt.u32
	<encode+?>: jz +86
	cmplStd/lib/text/encoding/Utf8.ci:70: (51 bytes): bytes: uint8[3] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:71: (15 bytes): bytes[0] := (224 | ((cp >> 12)));
	<encode+?>: load.c32 224
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x0c
	<encode+?>: or.b32
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:72: (17 bytes): bytes[1] := (128 | (((cp >> 6) & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x06
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+5)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:73: (15 bytes): bytes[2] := (128 | ((cp & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+6)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:75: (23 bytes): writer.write(writer, bytes[...3]);
	<encode+?>: dup.x32 sp(3)
	<encode+?>: load.c32 3
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(6)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	<encode+?>: jmp +99
	cmplStd/lib/text/encoding/Utf8.ci:78: (68 bytes): bytes: uint8[4] := {...}
	<encode+?>: inc.sp(+4)
	cmplStd/lib/text/encoding/Utf8.ci:79: (15 bytes): bytes[0] := (240 | ((cp >> 18)));
	<encode+?>: load.c32 240
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x12
	<encode+?>: or.b32
	<encode+?>: load.sp(+4)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:80: (17 bytes): bytes[1] := (128 | (((cp >> 12) & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x0c
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+5)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:81: (17 bytes): bytes[2] := (128 | (((cp >> 6) & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.shr 0x06
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+6)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:82: (15 bytes): bytes[3] := (128 | ((cp & (63))));
	<encode+?>: load.c32 128
	<encode+?>: dup.x32 sp(2)
	<encode+?>: b32.and 0x3f
	<encode+?>: or.b32
	<encode+?>: load.sp(+7)
	<encode+?>: store.i8
	cmplStd/lib/text/encoding/Utf8.ci:84: (23 bytes): writer.write(writer, bytes[...4]);
	<encode+?>: dup.x32 sp(3)
	<encode+?>: load.c32 4
	<encode+?>: load.sp(+8)
	<encode+?>: dup.x32 sp(6)
	<encode+?>: inc.i32(+8)
	<encode+?>: load.i32
	<encode+?>: call
	<encode+?>: inc.sp(-12)
	<encode+?>: inc.sp(-4)
	<encode+?>: inc.sp(-4)
	cmplStd/lib/text/encoding/Utf8.ci:55: (4 bytes): i := i + 1
	<encode+?>: inc.i32(+1)
	cmplStd/lib/text/encoding/Utf8.ci:55: (9 bytes): i < (chars.length)
	<encode+?>: dup.x32 sp(0)
	<encode+?>: dup.x32 sp(5)
	<encode+?>: clt.i32
	<encode+?>: jnz -342
	<encode+?>: inc.sp(-4)
	<encode+?>: inc.sp(-4)
	<encode+?>: ret
.usages:
}
Easing: typename {
.kind: static const typename(void)
.base: `typename`
.size: 0
.name: 'Easing'
.file: 'cmplStd/lib/math/Easing.ci:4'
.field linear: function (size: 4, cast: static function)
.field quad: function (size: 8, cast: static function)
.field cubic: function (size: 11, cast: static function)
.field quart: function (size: 14, cast: static function)
.field quint: function (size: 17, cast: static function)
.field expo: function (size: 58, cast: static function)
.field sine: function (size: 47, cast: static function)
.field circle: function (size: 40, cast: static function)
.field elastic: function (size: 148, cast: static function)
.field back: function (size: 41, cast: static function)
.field bounce: function (size: 54, cast: static function)
.doc: 'Easing functions maps an input of [0, 1) usually to [0, 1) with an acceleration'
.usages:
}
Easing.linear(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 4
.name: 'linear'
.file: 'cmplStd/lib/math/Easing.ci:6'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t;
}
.instructions: (4 bytes)
	cmplStd/lib/math/Easing.ci:7: (4 bytes): return .result := t;
	<linear>  : mov.x64 sp(3, 1)
	<linear+?>: ret
.usages:
}
Easing.quad(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 8
.name: 'quad'
.file: 'cmplStd/lib/math/Easing.ci:11'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t * t;
}
.instructions: (8 bytes)
	cmplStd/lib/math/Easing.ci:12: (8 bytes): return .result := t * t;
	<quad>  : dup.x64 sp(1)
	<quad+?>: dup.x64 sp(3)
	<quad+?>: mul.f64
	<quad+?>: set.x64 sp(5)
	<quad+?>: ret
.usages:
}
Easing.cubic(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 11
.name: 'cubic'
.file: 'cmplStd/lib/math/Easing.ci:16'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t * t * t;
}
.instructions: (11 bytes)
	cmplStd/lib/math/Easing.ci:17: (11 bytes): return .result := t * t * t;
	<cubic>  : dup.x64 sp(1)
	<cubic+?>: dup.x64 sp(3)
	<cubic+?>: mul.f64
	<cubic+?>: dup.x64 sp(3)
	<cubic+?>: mul.f64
	<cubic+?>: set.x64 sp(5)
	<cubic+?>: ret
.usages:
}
Easing.quart(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 14
.name: 'quart'
.file: 'cmplStd/lib/math/Easing.ci:21'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t * t * t * t;
}
.instructions: (14 bytes)
	cmplStd/lib/math/Easing.ci:22: (14 bytes): return .result := t * t * t * t;
	<quart>  : dup.x64 sp(1)
	<quart+?>: dup.x64 sp(3)
	<quart+?>: mul.f64
	<quart+?>: dup.x64 sp(3)
	<quart+?>: mul.f64
	<quart+?>: dup.x64 sp(3)
	<quart+?>: mul.f64
	<quart+?>: set.x64 sp(5)
	<quart+?>: ret
.usages:
}
Easing.quint(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 17
.name: 'quint'
.file: 'cmplStd/lib/math/Easing.ci:26'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t * t * t * t * t;
}
.instructions: (17 bytes)
	cmplStd/lib/math/Easing.ci:27: (17 bytes): return .result := t * t * t * t * t;
	<quint>  : dup.x64 sp(1)
	<quint+?>: dup.x64 sp(3)
	<quint+?>: mul.f64
	<quint+?>: dup.x64 sp(3)
	<quint+?>: mul.f64
	<quint+?>: dup.x64 sp(3)
	<quint+?>: mul.f64
	<quint+?>: dup.x64 sp(3)
	<quint+?>: mul.f64
	<quint+?>: set.x64 sp(5)
	<quint+?>: ret
.usages:
}
Easing.expo(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 58
.name: 'expo'
.file: 'cmplStd/lib/math/Easing.ci:31'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := t == (0) ? (0) : Math.pow(2.000000, (10) * (t - (1)));
}
.instructions: (58 bytes)
	cmplStd/lib/math/Easing.ci:32: (58 bytes): return .result := t == (0) ? (0) : Math.pow(2.000000, (10) * (t - (1)));
	<expo>  : dup.x64 sp(1)
	<expo+?>: load.z64
	<expo+?>: ceq.f64
	<expo+?>: jz +9
	<expo+?>: load.z64
	<expo+?>: jmp +46
	<expo+?>: load.z64
	<expo+?>: load.f64 2.000000
	<expo+?>: load.f64 10.000000
	<expo+?>: dup.x64 sp(7)
	<expo+?>: load.f64 1.000000
	<expo+?>: sub.f64
	<expo+?>: mul.f64
	<expo+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<expo+?>: call
	<expo+?>: inc.sp(-16)
	<expo+?>: set.x64 sp(5)
	<expo+?>: ret
.usages:
}
Easing.sine(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 47
.name: 'sine'
.file: 'cmplStd/lib/math/Easing.ci:36'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := -Math.cos(t * Math.pi / (2)) + (1);
}
.instructions: (47 bytes)
	cmplStd/lib/math/Easing.ci:37: (47 bytes): return .result := -Math.cos(t * Math.pi / (2)) + (1);
	<sine>  : load.z64
	<sine+?>: dup.x64 sp(3)
	<sine+?>: load.f64 3.141593
	<sine+?>: mul.f64
	<sine+?>: load.f64 2.000000
	<sine+?>: div.f64
	<sine+?>: load.ref <?> ;Math.cos(x: float64): float64
	<sine+?>: call
	<sine+?>: inc.sp(-8)
	<sine+?>: neg.f64
	<sine+?>: load.f64 1.000000
	<sine+?>: add.f64
	<sine+?>: set.x64 sp(5)
	<sine+?>: ret
.usages:
}
Easing.circle(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 40
.name: 'circle'
.file: 'cmplStd/lib/math/Easing.ci:41'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	return .result := -(Math.sqrt((1) - t * t) - (1));
}
.instructions: (40 bytes)
	cmplStd/lib/math/Easing.ci:42: (40 bytes): return .result := -(Math.sqrt((1) - t * t) - (1));
	<circle>  : load.z64
	<circle+?>: load.f64 1.000000
	<circle+?>: dup.x64 sp(5)
	<circle+?>: dup.x64 sp(7)
	<circle+?>: mul.f64
	<circle+?>: sub.f64
	<circle+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<circle+?>: call
	<circle+?>: inc.sp(-8)
	<circle+?>: load.f64 1.000000
	<circle+?>: sub.f64
	<circle+?>: neg.f64
	<circle+?>: set.x64 sp(5)
	<circle+?>: ret
.usages:
}
Easing.elastic(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 148
.name: 'elastic'
.file: 'cmplStd/lib/math/Easing.ci:46'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	if (t == 0.000000 || t == 1.000000) {
		return .result := t;
	}
	t := t - 1.000000;
	return .result := -Math.pow(2.000000, 10.000000 * t) * Math.sin((t - 0.300000 / 4.000000) * (2.000000 * Math.pi) / 0.300000);
}
.instructions: (148 bytes)
	cmplStd/lib/math/Easing.ci:47: (34 bytes): if (t == 0.000000 || t == 1.000000)
	<elastic>  : dup.x64 sp(1)
	<elastic+?>: load.z64
	<elastic+?>: ceq.f64
	<elastic+?>: dup.x32 sp(0)
	<elastic+?>: jnz +20
	<elastic+?>: inc.sp(-4)
	<elastic+?>: dup.x64 sp(1)
	<elastic+?>: load.f64 1.000000
	<elastic+?>: ceq.f64
	<elastic+?>: jz +8
	cmplStd/lib/math/Easing.ci:47: (4 bytes): return .result := t;
	<elastic+?>: mov.x64 sp(3, 1)
	<elastic+?>: ret
	cmplStd/lib/math/Easing.ci:48: (14 bytes): t := t - 1.000000;
	<elastic+?>: dup.x64 sp(1)
	<elastic+?>: load.f64 1.000000
	<elastic+?>: sub.f64
	<elastic+?>: set.x64 sp(3)
	cmplStd/lib/math/Easing.ci:49: (100 bytes): return .result := -Math.pow(2.000000, 10.000000 * t) * Math.sin((t - 0.300000 / 4.000000) * (2.000000 * Math.pi) / 0.300000);
	<elastic+?>: load.z64
	<elastic+?>: load.f64 2.000000
	<elastic+?>: load.f64 10.000000
	<elastic+?>: dup.x64 sp(7)
	<elastic+?>: mul.f64
	<elastic+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<elastic+?>: call
	<elastic+?>: inc.sp(-16)
	<elastic+?>: neg.f64
	<elastic+?>: load.z64
	<elastic+?>: dup.x64 sp(5)
	<elastic+?>: load.f64 0.300000
	<elastic+?>: load.f64 4.000000
	<elastic+?>: div.f64
	<elastic+?>: sub.f64
	<elastic+?>: load.f64 2.000000
	<elastic+?>: load.f64 3.141593
	<elastic+?>: mul.f64
	<elastic+?>: mul.f64
	<elastic+?>: load.f64 0.300000
	<elastic+?>: div.f64
	<elastic+?>: load.ref <?> ;Math.sin(x: float64): float64
	<elastic+?>: call
	<elastic+?>: inc.sp(-8)
	<elastic+?>: mul.f64
	<elastic+?>: set.x64 sp(5)
	<elastic+?>: ret
.usages:
}
Easing.back(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 41
.name: 'back'
.file: 'cmplStd/lib/math/Easing.ci:53'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	s: typename := 1.701580;
	return .result := t * t * ((s + (1)) * t - s);
}
.instructions: (41 bytes)
	cmplStd/lib/math/Easing.ci:55: (41 bytes): return .result := t * t * ((s + (1)) * t - s);
	<back>  : dup.x64 sp(1)
	<back+?>: dup.x64 sp(3)
	<back+?>: mul.f64
	<back+?>: load.f64 1.701580
	<back+?>: load.f64 1.000000
	<back+?>: add.f64
	<back+?>: dup.x64 sp(5)
	<back+?>: mul.f64
	<back+?>: load.f64 1.701580
	<back+?>: sub.f64
	<back+?>: mul.f64
	<back+?>: set.x64 sp(5)
	<back+?>: ret
.usages:
}
Easing.bounce(t: float64): float64: function {
.kind: static function
.base: `function`
.size: 54
.name: 'bounce'
.file: 'cmplStd/lib/math/Easing.ci:59'
.owner: Easing
.param .result: float64 (size: 8, cast: variable(f64))
.param t: float64 (size: 8, cast: variable(f64))
.doc: '@public'
.value: {
	static Helper(t: float64, c: float64, a: float64): float64 := {
		if (t == (1)) {
			return .result := c;
		}
		if (t < ((4) / 11.000000)) {
			return .result := c * (7.562500 * t * t);
		}
		if (t < ((8) / 11.000000)) {
			t := t - ((6) / 11.000000);
			return .result := -a * ((1) - (7.562500 * t * t + 0.750000)) + c;
		}
		if (t < ((10) / 11.000000)) {
			t := t - (((9) / 11.000000));
			return .result := -a * ((1) - (7.562500 * t * t + 0.937500)) + c;
		}
		t := t - ((21) / 22.000000);
		return .result := -a * ((1) - (7.562500 * t * t + 0.984375)) + c;
	};
	a: typename := 1.701580;
	return .result := (1) - Helper((1) - t, 1, a);
}
.instructions: (54 bytes)
	cmplStd/lib/math/Easing.ci:79: (54 bytes): return .result := (1) - Helper((1) - t, 1, a);
	<bounce>  : load.f64 1.000000
	<bounce+?>: load.z64
	<bounce+?>: load.f64 1.000000
	<bounce+?>: dup.x64 sp(7)
	<bounce+?>: sub.f64
	<bounce+?>: load.f64 1.000000
	<bounce+?>: load.f64 1.701580
	<bounce+?>: load.ref <?> ;Easing.bounce.Helper(t: float64, c: float64, a: float64): float64
	<bounce+?>: call
	<bounce+?>: inc.sp(-24)
	<bounce+?>: sub.f64
	<bounce+?>: set.x64 sp(5)
	<bounce+?>: ret
.usages:
}
in(ease(ratio: float64): float64, ratio: float64): float64: function {
.kind: static function
.base: `function`
.size: 29
.name: 'in'
.file: 'cmplStd/lib/math/Easing.ci:84'
.param .result: float64 (size: 8, cast: variable(f64))
.param ease: function (size: 4, cast: variable(ref))
.param ratio: float64 (size: 8, cast: variable(f64))
.doc: 'ease in, ex: Easing.elastic.in(t)'
.value: {
	if ((ease) == null) {
		return .result := ratio;
	}
	return .result := ease(ratio);
}
.instructions: (29 bytes)
	cmplStd/lib/math/Easing.ci:85: (16 bytes): if ((ease) == null)
	<in>  : dup.x32 sp(3)
	<in+?>: load.ref <?> ;null
	<in+?>: ceq.i32
	<in+?>: jz +8
	cmplStd/lib/math/Easing.ci:86: (4 bytes): return .result := ratio;
	<in+?>: mov.x64 sp(4, 1)
	<in+?>: ret
	cmplStd/lib/math/Easing.ci:88: (13 bytes): return .result := ease(ratio);
	<in+?>: load.z64
	<in+?>: dup.x64 sp(3)
	<in+?>: dup.x32 sp(7)
	<in+?>: call
	<in+?>: inc.sp(-8)
	<in+?>: set.x64 sp(6)
	<in+?>: ret
.usages:
}
out(ease(ratio: float64): float64, ratio: float64): float64: function {
.kind: static function
.base: `function`
.size: 49
.name: 'out'
.file: 'cmplStd/lib/math/Easing.ci:92'
.param .result: float64 (size: 8, cast: variable(f64))
.param ease: function (size: 4, cast: variable(ref))
.param ratio: float64 (size: 8, cast: variable(f64))
.doc: 'ease out, ex: Easing.elastic.out(t)'
.value: {
	if ((ease) == null) {
		return .result := ratio;
	}
	return .result := 1.000000 - ease((1) - ratio);
}
.instructions: (49 bytes)
	cmplStd/lib/math/Easing.ci:93: (16 bytes): if ((ease) == null)
	<out>  : dup.x32 sp(3)
	<out+?>: load.ref <?> ;null
	<out+?>: ceq.i32
	<out+?>: jz +8
	cmplStd/lib/math/Easing.ci:94: (4 bytes): return .result := ratio;
	<out+?>: mov.x64 sp(4, 1)
	<out+?>: ret
	cmplStd/lib/math/Easing.ci:96: (33 bytes): return .result := 1.000000 - ease((1) - ratio);
	<out+?>: load.f64 1.000000
	<out+?>: load.z64
	<out+?>: load.f64 1.000000
	<out+?>: dup.x64 sp(7)
	<out+?>: sub.f64
	<out+?>: dup.x32 sp(9)
	<out+?>: call
	<out+?>: inc.sp(-8)
	<out+?>: sub.f64
	<out+?>: set.x64 sp(6)
	<out+?>: ret
.usages:
	cmplStd/lib/math/Easing.ci:114: referenced as `out`
	cmplStd/lib/math/Easing.ci:105: referenced as `out`
}
inOut(ease(ratio: float64): float64, ratio: float64): float64: function {
.kind: static function
.base: `function`
.size: 118
.name: 'inOut'
.file: 'cmplStd/lib/math/Easing.ci:100'
.param .result: float64 (size: 8, cast: variable(f64))
.param ease: function (size: 4, cast: variable(ref))
.param ratio: float64 (size: 8, cast: variable(f64))
.doc: 'ease in and out, ex: Easing.elastic.inOut(t)'
.value: {
	if ((ease) == null) {
		return .result := ratio;
	}
	ratio := ratio * (2);
	return .result := (ratio < (1)) ? 0.500000 * ease(ratio) : 0.500000 * out(ease, ratio - (1)) + 0.500000;
}
.instructions: (118 bytes)
	cmplStd/lib/math/Easing.ci:101: (16 bytes): if ((ease) == null)
	<inOut>  : dup.x32 sp(3)
	<inOut+?>: load.ref <?> ;null
	<inOut+?>: ceq.i32
	<inOut+?>: jz +8
	cmplStd/lib/math/Easing.ci:102: (4 bytes): return .result := ratio;
	<inOut+?>: mov.x64 sp(4, 1)
	<inOut+?>: ret
	cmplStd/lib/math/Easing.ci:104: (14 bytes): ratio := ratio * (2);
	<inOut+?>: dup.x64 sp(1)
	<inOut+?>: load.f64 2.000000
	<inOut+?>: mul.f64
	<inOut+?>: set.x64 sp(3)
	cmplStd/lib/math/Easing.ci:105: (88 bytes): return .result := (ratio < (1)) ? 0.500000 * ease(ratio) : 0.500000 * out(ease, ratio - (1)) + 0.500000;
	<inOut+?>: dup.x64 sp(1)
	<inOut+?>: load.f64 1.000000
	<inOut+?>: clt.f64
	<inOut+?>: jz +28
	<inOut+?>: load.f64 0.500000
	<inOut+?>: load.z64
	<inOut+?>: dup.x64 sp(5)
	<inOut+?>: dup.x32 sp(9)
	<inOut+?>: call
	<inOut+?>: inc.sp(-8)
	<inOut+?>: mul.f64
	<inOut+?>: jmp +49
	<inOut+?>: load.f64 0.500000
	<inOut+?>: load.z64
	<inOut+?>: dup.x32 sp(7)
	<inOut+?>: dup.x64 sp(6)
	<inOut+?>: load.f64 1.000000
	<inOut+?>: sub.f64
	<inOut+?>: load.ref <?> ;out(ease(ratio: float64): float64, ratio: float64): float64
	<inOut+?>: call
	<inOut+?>: inc.sp(-12)
	<inOut+?>: mul.f64
	<inOut+?>: load.f64 0.500000
	<inOut+?>: add.f64
	<inOut+?>: set.x64 sp(6)
	<inOut+?>: ret
.usages:
}
outIn(ease(ratio: float64): float64, ratio: float64): float64: function {
.kind: static function
.base: `function`
.size: 118
.name: 'outIn'
.file: 'cmplStd/lib/math/Easing.ci:109'
.param .result: float64 (size: 8, cast: variable(f64))
.param ease: function (size: 4, cast: variable(ref))
.param ratio: float64 (size: 8, cast: variable(f64))
.doc: 'ease out and in, ex: Easing.elastic.outIn(t)'
.value: {
	if ((ease) == null) {
		return .result := ratio;
	}
	ratio := ratio * (2);
	return .result := (ratio < (1)) ? 0.500000 * out(ease, ratio) : 0.500000 * ease(ratio - (1)) + 0.500000;
}
.instructions: (118 bytes)
	cmplStd/lib/math/Easing.ci:110: (16 bytes): if ((ease) == null)
	<outIn>  : dup.x32 sp(3)
	<outIn+?>: load.ref <?> ;null
	<outIn+?>: ceq.i32
	<outIn+?>: jz +8
	cmplStd/lib/math/Easing.ci:111: (4 bytes): return .result := ratio;
	<outIn+?>: mov.x64 sp(4, 1)
	<outIn+?>: ret
	cmplStd/lib/math/Easing.ci:113: (14 bytes): ratio := ratio * (2);
	<outIn+?>: dup.x64 sp(1)
	<outIn+?>: load.f64 2.000000
	<outIn+?>: mul.f64
	<outIn+?>: set.x64 sp(3)
	cmplStd/lib/math/Easing.ci:114: (88 bytes): return .result := (ratio < (1)) ? 0.500000 * out(ease, ratio) : 0.500000 * ease(ratio - (1)) + 0.500000;
	<outIn+?>: dup.x64 sp(1)
	<outIn+?>: load.f64 1.000000
	<outIn+?>: clt.f64
	<outIn+?>: jz +33
	<outIn+?>: load.f64 0.500000
	<outIn+?>: load.z64
	<outIn+?>: dup.x32 sp(7)
	<outIn+?>: dup.x64 sp(6)
	<outIn+?>: load.ref <?> ;out(ease(ratio: float64): float64, ratio: float64): float64
	<outIn+?>: call
	<outIn+?>: inc.sp(-12)
	<outIn+?>: mul.f64
	<outIn+?>: jmp +44
	<outIn+?>: load.f64 0.500000
	<outIn+?>: load.z64
	<outIn+?>: dup.x64 sp(5)
	<outIn+?>: load.f64 1.000000
	<outIn+?>: sub.f64
	<outIn+?>: dup.x32 sp(9)
	<outIn+?>: call
	<outIn+?>: inc.sp(-8)
	<outIn+?>: mul.f64
	<outIn+?>: load.f64 0.500000
	<outIn+?>: add.f64
	<outIn+?>: set.x64 sp(6)
	<outIn+?>: ret
.usages:
}
scalar: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'scalar'
.file: 'cmplStd/lib/math/Polynomial.ci:1'
.value: float64
.usages:
}
Polynomial: TextWriter.Writeable {
.kind: static const typename(ref)
.base: `TextWriter.Writeable`
.size: 20
.name: 'Polynomial'
.file: 'cmplStd/lib/math/Polynomial.ci:4'
.field coefficients: float64[*] (size: 4, cast: variable(ref))
.field capacity: int32 (size: 4, cast: variable(i32))
.field c_zero: float64 (size: 0, cast: static const val)
.field c_unit: float64 (size: 0, cast: static const val)
.field write: function (size: 411, cast: static function)
.field destroy: function (size: 17, cast: static function)
.field destroy: function (size: 4, cast: const variable(ref))
.field create: function (size: 253, cast: static function)
.field degree: function (size: 58, cast: static function)
.field get: function (size: 100, cast: static function)
.field set: function (size: 140, cast: static function)
.field neg: function (size: 93, cast: static function)
.field add: function (size: 145, cast: static function)
.field sub: function (size: 145, cast: static function)
.field mul: function (size: 169, cast: static function)
.field evaluate: function (size: 59, cast: static function)
.field derivative: function (size: 107, cast: static function)
.field integral: function (size: 117, cast: static function)
.field write: function (size: 4, cast: variable(ref))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.doc: '@public'
.usages:
	cmplStd/lib/math/Polynomial.ci:178: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:178: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:177: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:174: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:174: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:164: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:163: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:163: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:155: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:154: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:154: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:145: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:135: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:132: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:132: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:132: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:123: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:123: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:123: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:114: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:114: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:114: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:106: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:105: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:105: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:98: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:89: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:79: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:63: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:59: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:54: referenced as `Polynomial`
	cmplStd/lib/math/Polynomial.ci:14: referenced as `Polynomial`
}
Polynomial.coefficients: float64[*] {
.kind: variable(ref)
.base: `float64[*]`
.size: 4
.name: 'coefficients'
.file: 'cmplStd/lib/math/Polynomial.ci:5'
.owner: Polynomial
.usages:
	cmplStd/lib/math/Polynomial.ci:180: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:174: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:167: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:167: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:165: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:157: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:157: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:148: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:138: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:126: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:117: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:108: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:101: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:94: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:81: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:73: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:70: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:65: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:55: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:21: referenced as `coefficients`
	cmplStd/lib/math/Polynomial.ci:17: referenced as `coefficients`
}
Polynomial.capacity: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'capacity'
.file: 'cmplStd/lib/math/Polynomial.ci:6'
.owner: Polynomial
.usages:
	cmplStd/lib/math/Polynomial.ci:166: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:156: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:125: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:116: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:107: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:100: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:91: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:80: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:66: referenced as `capacity`
	cmplStd/lib/math/Polynomial.ci:16: referenced as `capacity`
}
Polynomial.c_zero: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'c_zero'
.file: 'cmplStd/lib/math/Polynomial.ci:9'
.owner: Polynomial
.doc: 'c_zero'
.value: (0)
.usages:
	cmplStd/lib/math/Polynomial.ci:146: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:92: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:81: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:73: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:22: referenced as `c_zero`
	cmplStd/lib/math/Polynomial.ci:17: referenced as `c_zero`
}
Polynomial.c_unit: float64 {
.kind: static const val
.base: `float64`
.size: 0
.name: 'c_unit'
.file: 'cmplStd/lib/math/Polynomial.ci:10'
.owner: Polynomial
.doc: 'c_unit'
.value: (1)
.usages:
	cmplStd/lib/math/Polynomial.ci:38: referenced as `c_unit`
}
Polynomial.write(this: Polynomial, writer: TextWriter): void: function {
.kind: static function
.base: `function`
.size: 411
.name: 'write'
.file: 'cmplStd/lib/math/Polynomial.ci:14'
.owner: Polynomial
.param .result: void (size: 0, cast: variable(void))
.param this: Polynomial (size: 4, cast: variable(ref))
.param writer: TextWriter (size: 4, cast: variable(ref))
.value: {
	first: bool := true;
	for (i: int32 := this.capacity - 1; i >= 0; i := i - 1) {
		if (this.coefficients[i] == c_zero && !(first && i == 0)) {
			continue;
		}
		value: float64 := this.coefficients[i];
		if (value < c_zero) {
			value := -value;
			if (!first) {
				TextWriter.write(writer, " - ");
			}
			else {
				TextWriter.write(writer, "-");
			}
		}
		else if (!first) {
			TextWriter.write(writer, " + ");
		}
		if (value != c_unit || i == 0) {
			TextWriter.write(writer, value, writer.format);
		}
		if (i > 0) {
			TextWriter.write(writer, "x");
			if (i > 1) {
				TextWriter.write(writer, "^");
				TextWriter.write(writer, i, writer.format);
			}
		}
		first := false;
	}
}
.instructions: (411 bytes)
	cmplStd/lib/math/Polynomial.ci:15: (5 bytes): first: bool := true
	<write>  : load.c32 1
	cmplStd/lib/math/Polynomial.ci:16: (401 bytes): for (i: int32 := this.capacity - 1; i >= 0; i := i - 1)
	<write+?>: dup.x32 sp(3)
	<write+?>: inc.i32(+12)
	<write+?>: load.i32
	<write+?>: inc.i32(-1)
	<write+?>: jmp +378
	cmplStd/lib/math/Polynomial.ci:17: (54 bytes): if (this.coefficients[i] == c_zero && !(first && i == 0))
	<write+?>: dup.x32 sp(4)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(1)
	<write+?>: mad.u32 8
	<write+?>: load.i64
	<write+?>: load.z64
	<write+?>: ceq.f64
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +28
	<write+?>: inc.sp(-4)
	<write+?>: load.sp(+4)
	<write+?>: load.is8
	<write+?>: dup.x32 sp(0)
	<write+?>: jz +12
	<write+?>: inc.sp(-4)
	<write+?>: dup.x32 sp(0)
	<write+?>: load.z32
	<write+?>: ceq.i32
	<write+?>: not.b32
	<write+?>: jz +8
	cmplStd/lib/math/Polynomial.ci:18: (4 bytes): continue;
	<write+?>: jmp +320
	cmplStd/lib/math/Polynomial.ci:21: (14 bytes): value: float64 := this.coefficients[i]
	<write+?>: dup.x32 sp(4)
	<write+?>: inc.i32(+8)
	<write+?>: load.i32
	<write+?>: dup.x32 sp(1)
	<write+?>: mad.u32 8
	<write+?>: load.i64
	cmplStd/lib/math/Polynomial.ci:22: (125 bytes): if (value < c_zero)
	<write+?>: dup.x64 sp(0)
	<write+?>: load.z64
	<write+?>: clt.f64
	<write+?>: jz +82
	cmplStd/lib/math/Polynomial.ci:23: (1 byte): value := -value;
	<write+?>: neg.f64
	cmplStd/lib/math/Polynomial.ci:24: (73 bytes): if (!first)
	<write+?>: load.sp(+12)
	<write+?>: load.is8
	<write+?>: jnz +38
	cmplStd/lib/math/Polynomial.ci:26: (30 bytes): TextWriter.write(writer, " - ");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 3
	<write+?>: load.ref <?> ;" - "
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	<write+?>: jmp +34
	cmplStd/lib/math/Polynomial.ci:30: (30 bytes): TextWriter.write(writer, "-");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 1
	<write+?>: load.ref <?> ;"-"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	<write+?>: jmp +43
	cmplStd/lib/math/Polynomial.ci:33: (39 bytes): if (!first)
	<write+?>: load.sp(+12)
	<write+?>: load.is8
	<write+?>: jnz +34
	cmplStd/lib/math/Polynomial.ci:35: (30 bytes): TextWriter.write(writer, " + ");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 3
	<write+?>: load.ref <?> ;" + "
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:38: (59 bytes): if (value != c_unit || i == 0)
	<write+?>: dup.x64 sp(0)
	<write+?>: load.f64 1.000000
	<write+?>: ceq.f64
	<write+?>: not.b32
	<write+?>: dup.x32 sp(0)
	<write+?>: jnz +12
	<write+?>: inc.sp(-4)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.z32
	<write+?>: ceq.i32
	<write+?>: jz +32
	cmplStd/lib/math/Polynomial.ci:39: (28 bytes): TextWriter.write(writer, value, writer.format);
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: dup.x64 sp(2)
	<write+?>: dup.x32 sp(9)
	<write+?>: inc.i32(+12)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: float64, flags: FormatFlags): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-16)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:42: (108 bytes): if (i > 0)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.z32
	<write+?>: cgt.i32
	<write+?>: jz +104
	cmplStd/lib/math/Polynomial.ci:43: (30 bytes): TextWriter.write(writer, "x");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 1
	<write+?>: load.ref <?> ;"x"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:44: (70 bytes): if (i > 1)
	<write+?>: dup.x32 sp(2)
	<write+?>: load.c32 1
	<write+?>: cgt.i32
	<write+?>: jz +62
	cmplStd/lib/math/Polynomial.ci:45: (30 bytes): TextWriter.write(writer, "^");
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: load.c32 1
	<write+?>: load.ref <?> ;"^"
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: char[]): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:46: (28 bytes): TextWriter.write(writer, i, writer.format);
	<write+?>: inc.sp(+4)
	<write+?>: dup.x32 sp(6)
	<write+?>: dup.x32 sp(4)
	<write+?>: dup.x32 sp(8)
	<write+?>: inc.i32(+12)
	<write+?>: load.ref <?> ;TextWriter.write(this: TextWriter, value: int32, flags: FormatFlags): TextWriter
	<write+?>: call
	<write+?>: inc.sp(-12)
	<write+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:49: (6 bytes): first := false;
	<write+?>: load.z32
	<write+?>: load.sp(+16)
	<write+?>: store.i8
	<write+?>: inc.sp(-8)
	cmplStd/lib/math/Polynomial.ci:16: (4 bytes): i := i - 1
	<write+?>: inc.i32(-1)
	cmplStd/lib/math/Polynomial.ci:16: (8 bytes): i >= 0
	<write+?>: dup.x32 sp(0)
	<write+?>: load.z32
	<write+?>: clt.i32
	<write+?>: jz -378
	<write+?>: inc.sp(-4)
	<write+?>: inc.sp(-4)
	<write+?>: ret
.usages:
}
Polynomial.destroy(this: Polynomial): void: function {
.kind: static function
.base: `function`
.size: 17
.name: 'destroy'
.file: 'cmplStd/lib/math/Polynomial.ci:54'
.owner: Polynomial
.param .result: void (size: 0, cast: variable(void))
.param this: Polynomial (size: 4, cast: variable(ref))
.doc: 'Dispose the polynomial, free up used memory for coefficients'
.value: {
	pointer.alloc(this.coefficients, 0);
}
.instructions: (17 bytes)
	cmplStd/lib/math/Polynomial.ci:55: (16 bytes): pointer.alloc(this.coefficients, 0);
	<destroy>  : dup.x32 sp(1)
	<destroy+?>: inc.i32(+8)
	<destroy+?>: load.i32
	<destroy+?>: load.z32
	<destroy+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<destroy+?>: inc.sp(-4)
	<destroy+?>: ret
.usages:
}
Polynomial.destroy(this: Polynomial): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'destroy'
.file: 'cmplStd/lib/math/Polynomial.ci:54'
.owner: Polynomial
.param .result: void (size: 0, cast: variable(void))
.param this: Polynomial (size: 4, cast: variable(ref))
.doc: 'Dispose the polynomial, free up used memory for coefficients'
.value: destroy
.usages:
	internal usages: 1
}
Polynomial.create(degree: int32, values: float64[]): Polynomial: function {
.kind: static function
.base: `function`
.size: 253
.name: 'create'
.file: 'cmplStd/lib/math/Polynomial.ci:59'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param degree: int32 (size: 4, cast: variable(i32))
.param values: float64[] (size: 8, cast: variable(arr))
.value: {
	capacity: int32 := Math.max(0, degree) + 1;
	assert(capacity >= (values.length));
	coefficients: float64[*] := pointer.alloc(null, capacity * sizeof(float64));
	result: Polynomial := {
		result := create(Polynomial);
		result.coefficients := (coefficients);
		result.capacity := capacity;
		result.destroy := destroy;
		result.write := write;
	};
	for (i: int32 := 0; i < (values.length); i := i + 1) {
		result.coefficients[i] := values[i];
	}
	for (i: int32 := values.length; i < capacity; i := i + 1) {
		result.coefficients[i] := c_zero;
	}
	return .result := result;
}
.instructions: (253 bytes)
	cmplStd/lib/math/Polynomial.ci:60: (31 bytes): capacity: int32 := Math.max(0, degree) + 1
	<create>  : load.z32
	<create+?>: dup.x32 sp(4)
	<create+?>: dup.x32 sp(1)
	<create+?>: dup.x32 sp(1)
	<create+?>: cgt.i32
	<create+?>: jz +10
	<create+?>: dup.x32 sp(1)
	<create+?>: jmp +6
	<create+?>: dup.x32 sp(0)
	<create+?>: mov.x32 sp(2, 0)
	<create+?>: inc.sp(-8)
	<create+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:61: (53 bytes): assert(capacity >= (values.length));
	<create+?>: load.z32
	<create+?>: load.sp(+4)
	<create+?>: dup.x32 sp(2)
	<create+?>: dup.x32 sp(6)
	<create+?>: clt.i32
	<create+?>: jnz +8
	<create+?>: jmp +35
	<create+?>: load.ref <?> ;"cmplStd/lib/math/Polynomial.ci"
	<create+?>: load.c32 61
	<create+?>: load.c32 -2
	<create+?>: load.c32 128
	<create+?>: load.ref <?> ;"assertion failed!"
	<create+?>: dup.x64 sp(5)
	<create+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<create+?>: inc.sp(-8)
	cmplStd/lib/math/Polynomial.ci:62: (21 bytes): coefficients: float64[*] := pointer.alloc(null, capacity * sizeof(float64))
	<create+?>: load.ref <?> ;null
	<create+?>: dup.x32 sp(1)
	<create+?>: load.ref <?> ;float64
	<create+?>: nfc(6) ;typename.size(type: typename): int32
	<create+?>: mul.i32
	<create+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/lib/math/Polynomial.ci:63: (57 bytes): result: Polynomial := {...}
	<create+?>: inc.sp(+4)
	cmplStd/lib/math/Polynomial.ci:63: (11 bytes): result := create(Polynomial);
	<create+?>: load.ref <?> ;Polynomial
	<create+?>: nfc(7) ;object.create(type: typename): pointer
	<create+?>: set.x32 sp(1)
	cmplStd/lib/math/Polynomial.ci:65: (9 bytes): result.coefficients := (coefficients);
	<create+?>: dup.x32 sp(1)
	<create+?>: dup.x32 sp(1)
	<create+?>: inc.i32(+8)
	<create+?>: store.i32
	cmplStd/lib/math/Polynomial.ci:66: (9 bytes): result.capacity := capacity;
	<create+?>: dup.x32 sp(2)
	<create+?>: dup.x32 sp(1)
	<create+?>: inc.i32(+12)
	<create+?>: store.i32
	:: (12 bytes): result.destroy := destroy;
	<create+?>: load.ref <?> ;Polynomial.destroy(this: Polynomial): void
	<create+?>: dup.x32 sp(1)
	<create+?>: inc.i32(+16)
	<create+?>: store.i32
	:: (12 bytes): result.write := write;
	<create+?>: load.ref <?> ;Polynomial.write(this: Polynomial, writer: TextWriter): void
	<create+?>: dup.x32 sp(1)
	<create+?>: inc.i32(+4)
	<create+?>: store.i32
	cmplStd/lib/math/Polynomial.ci:69: (45 bytes): for (i: int32 := 0; i < (values.length); i := i + 1)
	<create+?>: load.z32
	<create+?>: jmp +31
	cmplStd/lib/math/Polynomial.ci:70: (23 bytes): result.coefficients[i] := values[i];
	<create+?>: dup.x32 sp(5)
	<create+?>: dup.x32 sp(1)
	<create+?>: mad.u32 8
	<create+?>: load.i64
	<create+?>: dup.x32 sp(3)
	<create+?>: inc.i32(+8)
	<create+?>: load.i32
	<create+?>: dup.x32 sp(3)
	<create+?>: mad.u32 8
	<create+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:69: (4 bytes): i := i + 1
	<create+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:69: (9 bytes): i < (values.length)
	<create+?>: dup.x32 sp(0)
	<create+?>: dup.x32 sp(7)
	<create+?>: clt.i32
	<create+?>: jnz -32
	<create+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:72: (38 bytes): for (i: int32 := values.length; i < capacity; i := i + 1)
	<create+?>: dup.x32 sp(5)
	<create+?>: jmp +23
	cmplStd/lib/math/Polynomial.ci:73: (15 bytes): result.coefficients[i] := c_zero;
	<create+?>: load.z64
	<create+?>: dup.x32 sp(3)
	<create+?>: inc.i32(+8)
	<create+?>: load.i32
	<create+?>: dup.x32 sp(3)
	<create+?>: mad.u32 8
	<create+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:72: (4 bytes): i := i + 1
	<create+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:72: (9 bytes): i < capacity
	<create+?>: dup.x32 sp(0)
	<create+?>: dup.x32 sp(4)
	<create+?>: clt.i32
	<create+?>: jnz -24
	<create+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:75: (8 bytes): return .result := result;
	<create+?>: mov.x32 sp(7, 0)
	<create+?>: inc.sp(-12)
	<create+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:178: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:174: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:164: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:155: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:135: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `create`
	cmplStd/lib/math/Polynomial.ci:106: referenced as `create`
}
Polynomial.degree(this: Polynomial): int32: function {
.kind: static function
.base: `function`
.size: 58
.name: 'degree'
.file: 'cmplStd/lib/math/Polynomial.ci:79'
.owner: Polynomial
.param .result: int32 (size: 4, cast: variable(i32))
.param this: Polynomial (size: 4, cast: variable(ref))
.doc: 'Compute the degree of the polynomial'
.value: {
	for (i: int32 := this.capacity - 1; i > 0; i := i - 1) {
		if (this.coefficients[i] != c_zero) {
			return .result := i;
		}
	}
	return .result := 0;
}
.instructions: (58 bytes)
	cmplStd/lib/math/Polynomial.ci:80: (54 bytes): for (i: int32 := this.capacity - 1; i > 0; i := i - 1)
	<degree>  : dup.x32 sp(1)
	<degree+?>: inc.i32(+12)
	<degree+?>: load.i32
	<degree+?>: inc.i32(-1)
	<degree+?>: jmp +31
	cmplStd/lib/math/Polynomial.ci:81: (23 bytes): if (this.coefficients[i] != c_zero)
	<degree+?>: dup.x32 sp(2)
	<degree+?>: inc.i32(+8)
	<degree+?>: load.i32
	<degree+?>: dup.x32 sp(1)
	<degree+?>: mad.u32 8
	<degree+?>: load.i64
	<degree+?>: load.z64
	<degree+?>: ceq.f64
	<degree+?>: jnz +7
	cmplStd/lib/math/Polynomial.ci:82: (3 bytes): return .result := i;
	<degree+?>: set.x32 sp(3)
	<degree+?>: ret
	cmplStd/lib/math/Polynomial.ci:80: (4 bytes): i := i - 1
	<degree+?>: inc.i32(-1)
	cmplStd/lib/math/Polynomial.ci:80: (8 bytes): i > 0
	<degree+?>: dup.x32 sp(0)
	<degree+?>: load.z32
	<degree+?>: cgt.i32
	<degree+?>: jnz -31
	<degree+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:85: (4 bytes): return .result := 0;
	<degree+?>: load.z32
	<degree+?>: set.x32 sp(3)
	<degree+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:174: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:164: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:155: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:147: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:134: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:133: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:124: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:115: referenced as `degree`
	cmplStd/lib/math/Polynomial.ci:106: referenced as `degree`
}
Polynomial.get(this: Polynomial, index: int32): float64: function {
.kind: static function
.base: `function`
.size: 100
.name: 'get'
.file: 'cmplStd/lib/math/Polynomial.ci:89'
.owner: Polynomial
.param .result: float64 (size: 8, cast: variable(f64))
.param this: Polynomial (size: 4, cast: const variable(ref))
.param index: int32 (size: 4, cast: variable(i32))
.doc: 'Get the nth coefficient of the polynomial'
.value: {
	assert(index >= 0, "negative index", index);
	if (index >= this.capacity) {
		return .result := c_zero;
	}
	return .result := this.coefficients[index];
}
.instructions: (100 bytes)
	cmplStd/lib/math/Polynomial.ci:90: (65 bytes): assert(index >= 0, "negative index", index);
	<get>  : load.ref <?> ;int32
	<get+?>: load.sp(+8)
	<get+?>: load.c32 1
	<get+?>: load.sp(+4)
	<get+?>: dup.x32 sp(5)
	<get+?>: load.z32
	<get+?>: clt.i32
	<get+?>: jnz +8
	<get+?>: jmp +35
	<get+?>: load.ref <?> ;"cmplStd/lib/math/Polynomial.ci"
	<get+?>: load.c32 90
	<get+?>: load.c32 -2
	<get+?>: load.c32 128
	<get+?>: load.ref <?> ;"negative index"
	<get+?>: dup.x64 sp(5)
	<get+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<get+?>: inc.sp(-16)
	cmplStd/lib/math/Polynomial.ci:91: (18 bytes): if (index >= this.capacity)
	<get+?>: dup.x32 sp(1)
	<get+?>: dup.x32 sp(3)
	<get+?>: inc.i32(+12)
	<get+?>: load.i32
	<get+?>: clt.i32
	<get+?>: jnz +8
	cmplStd/lib/math/Polynomial.ci:92: (4 bytes): return .result := c_zero;
	<get+?>: load.z64
	<get+?>: set.x64 sp(5)
	<get+?>: ret
	cmplStd/lib/math/Polynomial.ci:94: (17 bytes): return .result := this.coefficients[index];
	<get+?>: dup.x32 sp(2)
	<get+?>: inc.i32(+8)
	<get+?>: load.i32
	<get+?>: dup.x32 sp(2)
	<get+?>: mad.u32 8
	<get+?>: load.i64
	<get+?>: set.x64 sp(5)
	<get+?>: ret
.usages:
	cmplStd/lib/math/Polynomial.ci:138: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:138: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:126: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:126: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:117: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:117: referenced as `get`
	cmplStd/lib/math/Polynomial.ci:108: referenced as `get`
}
Polynomial.set(this: Polynomial, index: int32, value: float64): float64: function {
.kind: static function
.base: `function`
.size: 140
.name: 'set'
.file: 'cmplStd/lib/math/Polynomial.ci:98'
.owner: Polynomial
.param .result: float64 (size: 8, cast: variable(f64))
.param this: Polynomial (size: 4, cast: variable(ref))
.param index: int32 (size: 4, cast: variable(i32))
.param value: float64 (size: 8, cast: variable(f64))
.doc: 'Set the nth coefficient of the polynomial'
.value: {
	assert(index >= 0, "negative index", index);
	assert(index < this.capacity, "invalid index");
	return .result := this.coefficients[index];
}
.instructions: (140 bytes)
	cmplStd/lib/math/Polynomial.ci:99: (65 bytes): assert(index >= 0, "negative index", index);
	<set>  : load.ref <?> ;int32
	<set+?>: load.sp(+16)
	<set+?>: load.c32 1
	<set+?>: load.sp(+4)
	<set+?>: dup.x32 sp(7)
	<set+?>: load.z32
	<set+?>: clt.i32
	<set+?>: jnz +8
	<set+?>: jmp +35
	<set+?>: load.ref <?> ;"cmplStd/lib/math/Polynomial.ci"
	<set+?>: load.c32 99
	<set+?>: load.c32 -2
	<set+?>: load.c32 128
	<set+?>: load.ref <?> ;"negative index"
	<set+?>: dup.x64 sp(5)
	<set+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<set+?>: inc.sp(-16)
	cmplStd/lib/math/Polynomial.ci:100: (58 bytes): assert(index < this.capacity, "invalid index");
	<set+?>: load.z32
	<set+?>: load.sp(+4)
	<set+?>: dup.x32 sp(5)
	<set+?>: dup.x32 sp(7)
	<set+?>: inc.i32(+12)
	<set+?>: load.i32
	<set+?>: clt.i32
	<set+?>: jz +8
	<set+?>: jmp +35
	<set+?>: load.ref <?> ;"cmplStd/lib/math/Polynomial.ci"
	<set+?>: load.c32 100
	<set+?>: load.c32 -2
	<set+?>: load.c32 128
	<set+?>: load.ref <?> ;"invalid index"
	<set+?>: dup.x64 sp(5)
	<set+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<set+?>: inc.sp(-8)
	cmplStd/lib/math/Polynomial.ci:101: (17 bytes): return .result := this.coefficients[index];
	<set+?>: dup.x32 sp(4)
	<set+?>: inc.i32(+8)
	<set+?>: load.i32
	<set+?>: dup.x32 sp(4)
	<set+?>: mad.u32 8
	<set+?>: load.i64
	<set+?>: set.x64 sp(7)
	<set+?>: ret
.usages:
}
Polynomial.neg(a: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 93
.name: 'neg'
.file: 'cmplStd/lib/math/Polynomial.ci:105'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param a: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Negate the polynomial'
.value: {
	result: Polynomial := create(degree(a), null);
	for (i: int32 := 0; i < result.capacity; i := i + 1) {
		result.coefficients[i] := -get(a, i);
	}
	return .result := result;
}
.instructions: (93 bytes)
	cmplStd/lib/math/Polynomial.ci:106: (33 bytes): result: Polynomial := create(degree(a), null)
	<neg>  : inc.sp(+4)
	<neg+?>: load.z32
	<neg+?>: dup.x32 sp(3)
	<neg+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<neg+?>: call
	<neg+?>: inc.sp(-4)
	<neg+?>: load.z32
	<neg+?>: load.ref <?> ;null
	<neg+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<neg+?>: call
	<neg+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:107: (57 bytes): for (i: int32 := 0; i < result.capacity; i := i + 1)
	<neg+?>: load.z32
	<neg+?>: jmp +38
	cmplStd/lib/math/Polynomial.ci:108: (30 bytes): result.coefficients[i] := -get(a, i);
	<neg+?>: load.z64
	<neg+?>: dup.x32 sp(5)
	<neg+?>: dup.x32 sp(3)
	<neg+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<neg+?>: call
	<neg+?>: inc.sp(-8)
	<neg+?>: neg.f64
	<neg+?>: dup.x32 sp(3)
	<neg+?>: inc.i32(+8)
	<neg+?>: load.i32
	<neg+?>: dup.x32 sp(3)
	<neg+?>: mad.u32 8
	<neg+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:107: (4 bytes): i := i + 1
	<neg+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:107: (14 bytes): i < result.capacity
	<neg+?>: dup.x32 sp(0)
	<neg+?>: dup.x32 sp(2)
	<neg+?>: inc.i32(+12)
	<neg+?>: load.i32
	<neg+?>: clt.i32
	<neg+?>: jnz -44
	<neg+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:110: (3 bytes): return .result := result;
	<neg+?>: set.x32 sp(3)
	<neg+?>: ret
.usages:
}
Polynomial.add(a: Polynomial, b: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 145
.name: 'add'
.file: 'cmplStd/lib/math/Polynomial.ci:114'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param a: Polynomial (size: 4, cast: const variable(ref))
.param b: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Add two polynomials'
.value: {
	result: Polynomial := create(Math.max(degree(a), degree(b)), null);
	for (i: int32 := 0; i < result.capacity; i := i + 1) {
		result.coefficients[i] := get(a, i) + get(b, i);
	}
	return .result := result;
}
.instructions: (145 bytes)
	cmplStd/lib/math/Polynomial.ci:115: (70 bytes): result: Polynomial := create(Math.max(degree(a), degree(b)), null)
	<add>  : inc.sp(+4)
	<add+?>: load.z32
	<add+?>: dup.x32 sp(4)
	<add+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<add+?>: call
	<add+?>: inc.sp(-4)
	<add+?>: load.z32
	<add+?>: dup.x32 sp(4)
	<add+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<add+?>: call
	<add+?>: inc.sp(-4)
	<add+?>: dup.x32 sp(1)
	<add+?>: dup.x32 sp(1)
	<add+?>: cgt.i32
	<add+?>: jz +10
	<add+?>: dup.x32 sp(1)
	<add+?>: jmp +6
	<add+?>: dup.x32 sp(0)
	<add+?>: mov.x32 sp(2, 0)
	<add+?>: inc.sp(-8)
	<add+?>: load.z32
	<add+?>: load.ref <?> ;null
	<add+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<add+?>: call
	<add+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:116: (72 bytes): for (i: int32 := 0; i < result.capacity; i := i + 1)
	<add+?>: load.z32
	<add+?>: jmp +53
	cmplStd/lib/math/Polynomial.ci:117: (45 bytes): result.coefficients[i] := get(a, i) + get(b, i);
	<add+?>: load.z64
	<add+?>: dup.x32 sp(6)
	<add+?>: dup.x32 sp(3)
	<add+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<add+?>: call
	<add+?>: inc.sp(-8)
	<add+?>: load.z64
	<add+?>: dup.x32 sp(7)
	<add+?>: dup.x32 sp(5)
	<add+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<add+?>: call
	<add+?>: inc.sp(-8)
	<add+?>: add.f64
	<add+?>: dup.x32 sp(3)
	<add+?>: inc.i32(+8)
	<add+?>: load.i32
	<add+?>: dup.x32 sp(3)
	<add+?>: mad.u32 8
	<add+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:116: (4 bytes): i := i + 1
	<add+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:116: (14 bytes): i < result.capacity
	<add+?>: dup.x32 sp(0)
	<add+?>: dup.x32 sp(2)
	<add+?>: inc.i32(+12)
	<add+?>: load.i32
	<add+?>: clt.i32
	<add+?>: jnz -59
	<add+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:119: (3 bytes): return .result := result;
	<add+?>: set.x32 sp(4)
	<add+?>: ret
.usages:
}
Polynomial.sub(a: Polynomial, b: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 145
.name: 'sub'
.file: 'cmplStd/lib/math/Polynomial.ci:123'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param a: Polynomial (size: 4, cast: const variable(ref))
.param b: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Subtract two polynomials'
.value: {
	result: Polynomial := create(Math.max(degree(a), degree(b)), null);
	for (i: int32 := 0; i < result.capacity; i := i + 1) {
		result.coefficients[i] := get(a, i) - get(b, i);
	}
	return .result := result;
}
.instructions: (145 bytes)
	cmplStd/lib/math/Polynomial.ci:124: (70 bytes): result: Polynomial := create(Math.max(degree(a), degree(b)), null)
	<sub>  : inc.sp(+4)
	<sub+?>: load.z32
	<sub+?>: dup.x32 sp(4)
	<sub+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<sub+?>: call
	<sub+?>: inc.sp(-4)
	<sub+?>: load.z32
	<sub+?>: dup.x32 sp(4)
	<sub+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<sub+?>: call
	<sub+?>: inc.sp(-4)
	<sub+?>: dup.x32 sp(1)
	<sub+?>: dup.x32 sp(1)
	<sub+?>: cgt.i32
	<sub+?>: jz +10
	<sub+?>: dup.x32 sp(1)
	<sub+?>: jmp +6
	<sub+?>: dup.x32 sp(0)
	<sub+?>: mov.x32 sp(2, 0)
	<sub+?>: inc.sp(-8)
	<sub+?>: load.z32
	<sub+?>: load.ref <?> ;null
	<sub+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<sub+?>: call
	<sub+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:125: (72 bytes): for (i: int32 := 0; i < result.capacity; i := i + 1)
	<sub+?>: load.z32
	<sub+?>: jmp +53
	cmplStd/lib/math/Polynomial.ci:126: (45 bytes): result.coefficients[i] := get(a, i) - get(b, i);
	<sub+?>: load.z64
	<sub+?>: dup.x32 sp(6)
	<sub+?>: dup.x32 sp(3)
	<sub+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<sub+?>: call
	<sub+?>: inc.sp(-8)
	<sub+?>: load.z64
	<sub+?>: dup.x32 sp(7)
	<sub+?>: dup.x32 sp(5)
	<sub+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<sub+?>: call
	<sub+?>: inc.sp(-8)
	<sub+?>: sub.f64
	<sub+?>: dup.x32 sp(3)
	<sub+?>: inc.i32(+8)
	<sub+?>: load.i32
	<sub+?>: dup.x32 sp(3)
	<sub+?>: mad.u32 8
	<sub+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:125: (4 bytes): i := i + 1
	<sub+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:125: (14 bytes): i < result.capacity
	<sub+?>: dup.x32 sp(0)
	<sub+?>: dup.x32 sp(2)
	<sub+?>: inc.i32(+12)
	<sub+?>: load.i32
	<sub+?>: clt.i32
	<sub+?>: jnz -59
	<sub+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:128: (3 bytes): return .result := result;
	<sub+?>: set.x32 sp(4)
	<sub+?>: ret
.usages:
}
Polynomial.mul(a: Polynomial, b: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 169
.name: 'mul'
.file: 'cmplStd/lib/math/Polynomial.ci:132'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param a: Polynomial (size: 4, cast: const variable(ref))
.param b: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Multiply two polynomials'
.value: {
	degreeA: int32 := degree(a);
	degreeB: int32 := degree(b);
	result: Polynomial := create(degreeA + degreeB, null);
	for (i: int32 := 0; i <= degreeA; i := i + 1) {
		for (j: int32 := 0; j <= degreeB; j := j + 1) {
			result.coefficients[i + j] := result.coefficients[i + j] + get(a, i) * get(b, j);
		}
	}
	return .result := result;
}
.instructions: (169 bytes)
	cmplStd/lib/math/Polynomial.ci:133: (13 bytes): degreeA: int32 := degree(a)
	<mul>  : load.z32
	<mul+?>: dup.x32 sp(3)
	<mul+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<mul+?>: call
	<mul+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:134: (13 bytes): degreeB: int32 := degree(b)
	<mul+?>: load.z32
	<mul+?>: dup.x32 sp(3)
	<mul+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<mul+?>: call
	<mul+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:135: (25 bytes): result: Polynomial := create(degreeA + degreeB, null)
	<mul+?>: inc.sp(+4)
	<mul+?>: dup.x32 sp(2)
	<mul+?>: dup.x32 sp(2)
	<mul+?>: add.i32
	<mul+?>: load.z32
	<mul+?>: load.ref <?> ;null
	<mul+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<mul+?>: call
	<mul+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:136: (110 bytes): for (i: int32 := 0; i <= degreeA; i := i + 1)
	<mul+?>: load.z32
	<mul+?>: jmp +96
	cmplStd/lib/math/Polynomial.ci:137: (88 bytes): for (j: int32 := 0; j <= degreeB; j := j + 1)
	<mul+?>: load.z32
	<mul+?>: jmp +74
	cmplStd/lib/math/Polynomial.ci:138: (66 bytes): result.coefficients[i + j] := result.coefficients[i + j] + get(a, i) * get(b, j);
	<mul+?>: dup.x32 sp(2)
	<mul+?>: inc.i32(+8)
	<mul+?>: load.i32
	<mul+?>: dup.x32 sp(2)
	<mul+?>: dup.x32 sp(2)
	<mul+?>: add.i32
	<mul+?>: mad.u32 8
	<mul+?>: load.i64
	<mul+?>: load.z64
	<mul+?>: dup.x32 sp(11)
	<mul+?>: dup.x32 sp(6)
	<mul+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<mul+?>: call
	<mul+?>: inc.sp(-8)
	<mul+?>: load.z64
	<mul+?>: dup.x32 sp(12)
	<mul+?>: dup.x32 sp(7)
	<mul+?>: load.ref <?> ;Polynomial.get(this: Polynomial, index: int32): float64
	<mul+?>: call
	<mul+?>: inc.sp(-8)
	<mul+?>: mul.f64
	<mul+?>: add.f64
	<mul+?>: dup.x32 sp(4)
	<mul+?>: inc.i32(+8)
	<mul+?>: load.i32
	<mul+?>: dup.x32 sp(4)
	<mul+?>: dup.x32 sp(4)
	<mul+?>: add.i32
	<mul+?>: mad.u32 8
	<mul+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:137: (4 bytes): j := j + 1
	<mul+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:137: (9 bytes): j <= degreeB
	<mul+?>: dup.x32 sp(0)
	<mul+?>: dup.x32 sp(4)
	<mul+?>: cgt.i32
	<mul+?>: jz -75
	<mul+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:136: (4 bytes): i := i + 1
	<mul+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:136: (9 bytes): i <= degreeA
	<mul+?>: dup.x32 sp(0)
	<mul+?>: dup.x32 sp(4)
	<mul+?>: cgt.i32
	<mul+?>: jz -97
	<mul+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:141: (8 bytes): return .result := result;
	<mul+?>: mov.x32 sp(6, 0)
	<mul+?>: inc.sp(-12)
	<mul+?>: ret
.usages:
}
Polynomial.evaluate(this: Polynomial, value: float64): float64: function {
.kind: static function
.base: `function`
.size: 59
.name: 'evaluate'
.file: 'cmplStd/lib/math/Polynomial.ci:145'
.owner: Polynomial
.param .result: float64 (size: 8, cast: variable(f64))
.param this: Polynomial (size: 4, cast: const variable(ref))
.param value: float64 (size: 8, cast: variable(f64))
.doc: 'Evaluate the polynomial using Horner's method'
.value: {
	result: float64 := c_zero;
	for (i: int32 := degree(this); i >= 0; i := i - 1) {
		result := result * value + this.coefficients[i];
	}
	return .result := result;
}
.instructions: (59 bytes)
	cmplStd/lib/math/Polynomial.ci:146: (1 byte): result: float64 := c_zero
	<evaluate>  : load.z128
	cmplStd/lib/math/Polynomial.ci:147: (55 bytes): for (i: int32 := degree(this); i >= 0; i := i - 1)
	<evaluate+?>: i64.2i32
	<evaluate+?>: dup.x32 sp(6)
	<evaluate+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<evaluate+?>: call
	<evaluate+?>: inc.sp(-4)
	<evaluate+?>: jmp +30
	cmplStd/lib/math/Polynomial.ci:148: (22 bytes): result := result * value + this.coefficients[i];
	<evaluate+?>: dup.x64 sp(1)
	<evaluate+?>: dup.x64 sp(6)
	<evaluate+?>: mul.f64
	<evaluate+?>: dup.x32 sp(8)
	<evaluate+?>: inc.i32(+8)
	<evaluate+?>: load.i32
	<evaluate+?>: dup.x32 sp(3)
	<evaluate+?>: mad.u32 8
	<evaluate+?>: load.i64
	<evaluate+?>: add.f64
	<evaluate+?>: set.x64 sp(3)
	cmplStd/lib/math/Polynomial.ci:147: (4 bytes): i := i - 1
	<evaluate+?>: inc.i32(-1)
	cmplStd/lib/math/Polynomial.ci:147: (8 bytes): i >= 0
	<evaluate+?>: dup.x32 sp(0)
	<evaluate+?>: load.z32
	<evaluate+?>: clt.i32
	<evaluate+?>: jz -30
	<evaluate+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:150: (3 bytes): return .result := result;
	<evaluate+?>: set.x64 sp(6)
	<evaluate+?>: ret
.usages:
}
Polynomial.derivative(this: Polynomial): Polynomial: function {
.kind: static function
.base: `function`
.size: 107
.name: 'derivative'
.file: 'cmplStd/lib/math/Polynomial.ci:154'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param this: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Compute the derivative of the polynomial'
.value: {
	result: Polynomial := create(degree(this) - 1, null);
	for (i: int32 := 0; i < result.capacity; i := i + 1) {
		result.coefficients[i] := ((i + 1)) * this.coefficients[i + 1];
	}
	return .result := result;
}
.instructions: (107 bytes)
	cmplStd/lib/math/Polynomial.ci:155: (37 bytes): result: Polynomial := create(degree(this) - 1, null)
	<derivative>  : inc.sp(+4)
	<derivative+?>: load.z32
	<derivative+?>: dup.x32 sp(3)
	<derivative+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<derivative+?>: call
	<derivative+?>: inc.sp(-4)
	<derivative+?>: inc.i32(-1)
	<derivative+?>: load.z32
	<derivative+?>: load.ref <?> ;null
	<derivative+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<derivative+?>: call
	<derivative+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:156: (67 bytes): for (i: int32 := 0; i < result.capacity; i := i + 1)
	<derivative+?>: load.z32
	<derivative+?>: jmp +48
	cmplStd/lib/math/Polynomial.ci:157: (40 bytes): result.coefficients[i] := ((i + 1)) * this.coefficients[i + 1];
	<derivative+?>: dup.x32 sp(0)
	<derivative+?>: inc.i32(+1)
	<derivative+?>: i32.2f64
	<derivative+?>: dup.x32 sp(5)
	<derivative+?>: inc.i32(+8)
	<derivative+?>: load.i32
	<derivative+?>: dup.x32 sp(3)
	<derivative+?>: inc.i32(+1)
	<derivative+?>: mad.u32 8
	<derivative+?>: load.i64
	<derivative+?>: mul.f64
	<derivative+?>: dup.x32 sp(3)
	<derivative+?>: inc.i32(+8)
	<derivative+?>: load.i32
	<derivative+?>: dup.x32 sp(3)
	<derivative+?>: mad.u32 8
	<derivative+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:156: (4 bytes): i := i + 1
	<derivative+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:156: (14 bytes): i < result.capacity
	<derivative+?>: dup.x32 sp(0)
	<derivative+?>: dup.x32 sp(2)
	<derivative+?>: inc.i32(+12)
	<derivative+?>: load.i32
	<derivative+?>: clt.i32
	<derivative+?>: jnz -54
	<derivative+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:159: (3 bytes): return .result := result;
	<derivative+?>: set.x32 sp(3)
	<derivative+?>: ret
.usages:
}
Polynomial.integral(this: Polynomial, c: float64): Polynomial: function {
.kind: static function
.base: `function`
.size: 117
.name: 'integral'
.file: 'cmplStd/lib/math/Polynomial.ci:163'
.owner: Polynomial
.param .result: Polynomial (size: 4, cast: variable(ref))
.param this: Polynomial (size: 4, cast: const variable(ref))
.param c: float64 (size: 8, cast: variable(f64))
.doc: 'Compute the integral of the polynomial'
.value: {
	result: Polynomial := create(degree(this) + 1, null);
	result.coefficients[0] := c;
	for (i: int32 := 1; i < result.capacity; i := i + 1) {
		result.coefficients[i] := this.coefficients[i - 1] / (i);
	}
	return .result := result;
}
.instructions: (117 bytes)
	cmplStd/lib/math/Polynomial.ci:164: (37 bytes): result: Polynomial := create(degree(this) + 1, null)
	<integral>  : inc.sp(+4)
	<integral+?>: load.z32
	<integral+?>: dup.x32 sp(5)
	<integral+?>: load.ref <?> ;Polynomial.degree(this: Polynomial): int32
	<integral+?>: call
	<integral+?>: inc.sp(-4)
	<integral+?>: inc.i32(+1)
	<integral+?>: load.z32
	<integral+?>: load.ref <?> ;null
	<integral+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<integral+?>: call
	<integral+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:165: (10 bytes): result.coefficients[0] := c;
	<integral+?>: dup.x64 sp(2)
	<integral+?>: dup.x32 sp(2)
	<integral+?>: inc.i32(+8)
	<integral+?>: load.i32
	<integral+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:166: (67 bytes): for (i: int32 := 1; i < result.capacity; i := i + 1)
	<integral+?>: load.c32 1
	<integral+?>: jmp +44
	cmplStd/lib/math/Polynomial.ci:167: (36 bytes): result.coefficients[i] := this.coefficients[i - 1] / (i);
	<integral+?>: dup.x32 sp(5)
	<integral+?>: inc.i32(+8)
	<integral+?>: load.i32
	<integral+?>: dup.x32 sp(1)
	<integral+?>: inc.i32(-1)
	<integral+?>: mad.u32 8
	<integral+?>: load.i64
	<integral+?>: dup.x32 sp(2)
	<integral+?>: i32.2f64
	<integral+?>: div.f64
	<integral+?>: dup.x32 sp(3)
	<integral+?>: inc.i32(+8)
	<integral+?>: load.i32
	<integral+?>: dup.x32 sp(3)
	<integral+?>: mad.u32 8
	<integral+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:166: (4 bytes): i := i + 1
	<integral+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:166: (14 bytes): i < result.capacity
	<integral+?>: dup.x32 sp(0)
	<integral+?>: dup.x32 sp(2)
	<integral+?>: inc.i32(+12)
	<integral+?>: load.i32
	<integral+?>: clt.i32
	<integral+?>: jnz -50
	<integral+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:169: (3 bytes): return .result := result;
	<integral+?>: set.x32 sp(5)
	<integral+?>: ret
.usages:
}
Polynomial(copy: Polynomial): Polynomial: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Polynomial'
.file: 'cmplStd/lib/math/Polynomial.ci:174'
.param .result: Polynomial (size: 20, cast: ref)
.param copy: Polynomial (size: 4, cast: const variable(ref))
.doc: 'Create a new polynomial by copying the given one.'
.value: Polynomial.create(Polynomial.degree(copy), copy.coefficients)
.usages:
}
Polynomial(values: float64[]): Polynomial: function {
.kind: static function
.base: `function`
.size: 81
.name: 'Polynomial'
.file: 'cmplStd/lib/math/Polynomial.ci:177'
.param .result: Polynomial (size: 4, cast: variable(ref))
.param values: float64[] (size: 8, cast: variable(arr))
.doc: 'Create a new polynomial with the given values, coefficients are reversed(lowest index === highest degree)'
.value: {
	result: Polynomial := Polynomial.create(values.length - (1), null);
	for (i: int32 := 0; i < (values.length); i := i + 1) {
		result.coefficients[i] := values[values.length - (i) - (1)];
	}
	return .result := result;
}
.instructions: (81 bytes)
	cmplStd/lib/math/Polynomial.ci:178: (26 bytes): result: Polynomial := Polynomial.create(values.length - (1), null)
	<Polynomial>  : inc.sp(+4)
	<Polynomial+?>: dup.x32 sp(3)
	<Polynomial+?>: inc.i32(-1)
	<Polynomial+?>: load.z32
	<Polynomial+?>: load.ref <?> ;null
	<Polynomial+?>: load.ref <?> ;Polynomial.create(degree: int32, values: float64[]): Polynomial
	<Polynomial+?>: call
	<Polynomial+?>: inc.sp(-12)
	cmplStd/lib/math/Polynomial.ci:179: (52 bytes): for (i: int32 := 0; i < (values.length); i := i + 1)
	<Polynomial+?>: load.z32
	<Polynomial+?>: jmp +38
	cmplStd/lib/math/Polynomial.ci:180: (30 bytes): result.coefficients[i] := values[values.length - (i) - (1)];
	<Polynomial+?>: dup.x32 sp(3)
	<Polynomial+?>: dup.x32 sp(5)
	<Polynomial+?>: dup.x32 sp(2)
	<Polynomial+?>: sub.i32
	<Polynomial+?>: inc.i32(-1)
	<Polynomial+?>: mad.u32 8
	<Polynomial+?>: load.i64
	<Polynomial+?>: dup.x32 sp(3)
	<Polynomial+?>: inc.i32(+8)
	<Polynomial+?>: load.i32
	<Polynomial+?>: dup.x32 sp(3)
	<Polynomial+?>: mad.u32 8
	<Polynomial+?>: store.i64
	cmplStd/lib/math/Polynomial.ci:179: (4 bytes): i := i + 1
	<Polynomial+?>: inc.i32(+1)
	cmplStd/lib/math/Polynomial.ci:179: (9 bytes): i < (values.length)
	<Polynomial+?>: dup.x32 sp(0)
	<Polynomial+?>: dup.x32 sp(5)
	<Polynomial+?>: clt.i32
	<Polynomial+?>: jnz -39
	<Polynomial+?>: inc.sp(-4)
	cmplStd/lib/math/Polynomial.ci:182: (3 bytes): return .result := result;
	<Polynomial+?>: set.x32 sp(4)
	<Polynomial+?>: ret
.usages:
}
integer: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'integer'
.file: 'cmplStd/test/test.ci:5'
.value: int64
.usages:
}
emitldz32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitldz32'
.file: 'cmplStd/test/lang/emit.ci:3'
.value: emit(load.z32)
.usages:
}
emitldz64: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitldz64'
.file: 'cmplStd/test/lang/emit.ci:4'
.value: emit(load.z64)
.usages:
}
emitA: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitA'
.file: 'cmplStd/test/lang/emit.ci:6'
.value: 42
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitA`
}
emitB: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitB'
.file: 'cmplStd/test/lang/emit.ci:7'
.value: 96
.usages:
	cmplStd/test/lang/emit.ci:10: referenced as `emitB`
}
emitAddI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitAddI32'
.file: 'cmplStd/test/lang/emit.ci:10'
.doc: 'Emit the calculation of `emitA + emitB`'
.value: emit(int32(emitA), int32(emitB), add.i32)
.usages:
}
emitDivI32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitDivI32'
.file: 'cmplStd/test/lang/emit.ci:13'
.doc: 'Emit the calculation of `10 / 5`'
.value: emit(int32(10), int32(5), div.i32)
.usages:
}
emitNfcF32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'emitNfcF32'
.file: 'cmplStd/test/lang/emit.ci:16'
.doc: 'Emit the calculation of `float32.sin(3.14f / 2)`'
.value: emit(float32(3.140000), float32(2), div.f32, float32.sin)
.usages:
}
floatAsInt32(value: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'floatAsInt32'
.file: 'cmplStd/test/lang/emit.ci:19'
.param .result: int32 (size: 4, cast: i32)
.param value: float32 (size: 4, cast: f32)
.doc: 'interpret a 32 bit floating point number as an 32 bit integer'
.value: int32(emit(float32(value)))
.usages:
	cmplStd/test/lang/emit.ci:24: referenced as `floatAsInt32`
	cmplStd/test/lang/emit.ci:23: referenced as `floatAsInt32`
}
floatAsInt64(value: float64): int64: function {
.kind: inline
.base: `function`
.size: 0
.name: 'floatAsInt64'
.file: 'cmplStd/test/lang/emit.ci:21'
.param .result: int64 (size: 8, cast: i64)
.param value: float64 (size: 8, cast: f64)
.doc: 'interpret a 64 bit floating point number as an 64 bit integer'
.value: int64(emit(float64(value)))
.usages:
	cmplStd/test/lang/emit.ci:26: referenced as `floatAsInt64`
	cmplStd/test/lang/emit.ci:25: referenced as `floatAsInt64`
}
emitFloatAsInt1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitFloatAsInt1'
.file: 'cmplStd/test/lang/emit.ci:23'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitFloatAsInt2'
.file: 'cmplStd/test/lang/emit.ci:24'
.value: floatAsInt32(500)
.usages:
}
emitFloatAsInt3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'emitFloatAsInt3'
.file: 'cmplStd/test/lang/emit.ci:25'
.value: floatAsInt64(500)
.usages:
}
emitFloatAsInt4: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'emitFloatAsInt4'
.file: 'cmplStd/test/lang/emit.ci:26'
.value: floatAsInt64(500)
.usages:
}
emitSlice: char[] {
.kind: variable(arr)
.base: `char[]`
.size: 8
.name: 'emitSlice'
.file: 'cmplStd/test/lang/emit.ci:30'
.value: emit(int32(3), pointer("string"))
.usages:
}
zero(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'zero'
.file: 'cmplStd/test/lang/inlineMacros.ci:3'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: 0
.usages:
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `zero`
	cmplStd/test/lang/inlineMacros.ci:15: referenced as `zero`
}
last(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'last'
.file: 'cmplStd/test/lang/inlineMacros.ci:4'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: b
.usages:
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `last`
	cmplStd/test/lang/inlineMacros.ci:19: referenced as `last`
}
sum(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sum'
.file: 'cmplStd/test/lang/inlineMacros.ci:5'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: a + b
.usages:
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:40: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:39: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `sum`
	cmplStd/test/lang/inlineMacros.ci:23: referenced as `sum`
}
any(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'any'
.file: 'cmplStd/test/lang/inlineMacros.ci:6'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: i32)
.value: (a) ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:49: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:48: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `any`
	cmplStd/test/lang/inlineMacros.ci:27: referenced as `any`
}
min(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'min'
.file: 'cmplStd/test/lang/inlineMacros.ci:7'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.value: a < b ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:58: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:57: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `min`
	cmplStd/test/lang/inlineMacros.ci:31: referenced as `min`
}
max(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'max'
.file: 'cmplStd/test/lang/inlineMacros.ci:8'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: variable(i32))
.param b: int32 (size: 4, cast: variable(i32))
.value: a > b ? a : b
.usages:
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:67: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:66: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `max`
	cmplStd/test/lang/inlineMacros.ci:35: referenced as `max`
}
i3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i3'
.file: 'cmplStd/test/lang/inlineMacros.ci:10'
.value: 3
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i3`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i3`
}
i6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i6'
.file: 'cmplStd/test/lang/inlineMacros.ci:11'
.value: 6
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:37: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:36: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:33: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:32: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:29: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:28: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:25: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:24: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:21: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:20: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:17: referenced as `i6`
	cmplStd/test/lang/inlineMacros.ci:16: referenced as `i6`
}
i2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i2'
.file: 'cmplStd/test/lang/inlineMacros.ci:12'
.value: 2
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i2`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i2`
}
i8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i8'
.file: 'cmplStd/test/lang/inlineMacros.ci:13'
.value: 8
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `i8`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `i8`
}
zeroVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:15'
.value: zero(3, 6)
.usages:
}
zeroVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:16'
.value: zero(i3, i6)
.usages:
}
zeroXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zeroXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:17'
.value: zero(i3 + 1, i6 + 1)
.usages:
}
lastVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:19'
.value: last(3, 6)
.usages:
}
lastVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:20'
.value: last(i3, i6)
.usages:
}
lastXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lastXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:21'
.value: last(i3 + 1, i6 + 1) - 1
.usages:
}
sum2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:23'
.value: sum(3, 6)
.usages:
}
sum2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:24'
.value: sum(i3, i6)
.usages:
}
sum2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sum2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:25'
.value: sum(i3 + 1, i6 + 1) - 2
.usages:
}
any2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:27'
.value: any(3, 6)
.usages:
}
any2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:28'
.value: any(i3, i6)
.usages:
}
any2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'any2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:29'
.value: any(i3 + 1, i6 + 1) - 1
.usages:
}
min2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:31'
.value: min(3, 6)
.usages:
}
min2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:32'
.value: min(i3, i6)
.usages:
}
min2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'min2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:33'
.value: min(i3 + 1, i6 + 1) - 1
.usages:
}
max2Val: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'max2Val'
.file: 'cmplStd/test/lang/inlineMacros.ci:35'
.value: max(3, 6)
.usages:
}
max2Var: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'max2Var'
.file: 'cmplStd/test/lang/inlineMacros.ci:36'
.value: max(i3, i6)
.usages:
}
max2Xpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'max2Xpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:37'
.value: max(i3 + 1, i6 + 1) - 1
.usages:
}
sumLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sumLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:39'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: sum(a, sum(b, sum(c, d)))
.usages:
	cmplStd/test/lang/inlineMacros.ci:45: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:43: referenced as `sumLr`
	cmplStd/test/lang/inlineMacros.ci:41: referenced as `sumLr`
}
sumRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'sumRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:40'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: sum(sum(sum(a, b), c), d)
.usages:
	cmplStd/test/lang/inlineMacros.ci:46: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:44: referenced as `sumRl`
	cmplStd/test/lang/inlineMacros.ci:42: referenced as `sumRl`
}
sumRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:41'
.value: sumLr(3, 6, 2, 8)
.usages:
}
sumLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:42'
.value: sumRl(3, 6, 2, 8)
.usages:
}
sumRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:43'
.value: sumLr(i3, i6, i2, i8)
.usages:
}
sumLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:44'
.value: sumRl(i3, i6, i2, i8)
.usages:
}
sumRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:45'
.value: sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
.usages:
}
sumLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sumLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:46'
.value: sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
.usages:
}
anyLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'anyLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:48'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: any(a, any(b, any(c, d)))
.usages:
	cmplStd/test/lang/inlineMacros.ci:54: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:52: referenced as `anyLr`
	cmplStd/test/lang/inlineMacros.ci:50: referenced as `anyLr`
}
anyRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'anyRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:49'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: any(any(any(a, b), c), d)
.usages:
	cmplStd/test/lang/inlineMacros.ci:55: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:53: referenced as `anyRl`
	cmplStd/test/lang/inlineMacros.ci:51: referenced as `anyRl`
}
anyRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:50'
.value: anyLr(3, 6, 2, 8)
.usages:
}
anyLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:51'
.value: anyRl(3, 6, 2, 8)
.usages:
}
anyRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:52'
.value: anyLr(i3, i6, i2, i8)
.usages:
}
anyLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:53'
.value: anyRl(i3, i6, i2, i8)
.usages:
}
anyRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:54'
.value: anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
anyLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'anyLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:55'
.value: anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
minLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'minLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:57'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: min(a, min(b, min(c, d)))
.usages:
	cmplStd/test/lang/inlineMacros.ci:63: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:61: referenced as `minLr`
	cmplStd/test/lang/inlineMacros.ci:59: referenced as `minLr`
}
minRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'minRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:58'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: min(min(min(a, b), c), d)
.usages:
	cmplStd/test/lang/inlineMacros.ci:64: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:62: referenced as `minRl`
	cmplStd/test/lang/inlineMacros.ci:60: referenced as `minRl`
}
minRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:59'
.value: minLr(3, 6, 2, 8)
.usages:
}
minLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:60'
.value: minRl(3, 6, 2, 8)
.usages:
}
minRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:61'
.value: minLr(i3, i6, i2, i8)
.usages:
}
minLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:62'
.value: minRl(i3, i6, i2, i8)
.usages:
}
minRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:63'
.value: minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
minLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'minLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:64'
.value: minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
maxLr(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'maxLr'
.file: 'cmplStd/test/lang/inlineMacros.ci:66'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: max(a, max(b, max(c, d)))
.usages:
	cmplStd/test/lang/inlineMacros.ci:72: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:70: referenced as `maxLr`
	cmplStd/test/lang/inlineMacros.ci:68: referenced as `maxLr`
}
maxRl(a: int32, b: int32, c: int32, d: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'maxRl'
.file: 'cmplStd/test/lang/inlineMacros.ci:67'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.param c: int32 (size: 4, cast: i32)
.param d: int32 (size: 4, cast: i32)
.value: max(max(max(a, b), c), d)
.usages:
	cmplStd/test/lang/inlineMacros.ci:73: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:71: referenced as `maxRl`
	cmplStd/test/lang/inlineMacros.ci:69: referenced as `maxRl`
}
maxRlVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxRlVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:68'
.value: maxLr(3, 6, 2, 8)
.usages:
}
maxLrVal: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxLrVal'
.file: 'cmplStd/test/lang/inlineMacros.ci:69'
.value: maxRl(3, 6, 2, 8)
.usages:
}
maxRlVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxRlVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:70'
.value: maxLr(i3, i6, i2, i8)
.usages:
}
maxLrVar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxLrVar'
.file: 'cmplStd/test/lang/inlineMacros.ci:71'
.value: maxRl(i3, i6, i2, i8)
.usages:
}
maxRlXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxRlXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:72'
.value: maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
maxLrXpr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'maxLrXpr'
.file: 'cmplStd/test/lang/inlineMacros.ci:73'
.value: maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
.usages:
}
overload: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:3'
.value: 1
.usages:
	cmplStd/test/lang/overload.inline.ci:9: referenced as `overload`
}
overload(): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:4'
.param .result: int32 (size: 4, cast: i32)
.value: 2
.usages:
	cmplStd/test/lang/overload.inline.ci:10: referenced as `overload`
}
overload(a: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:5'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.value: 3
.usages:
	cmplStd/test/lang/overload.inline.ci:11: referenced as `overload`
}
overload(a: float32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:6'
.param .result: int32 (size: 4, cast: i32)
.param a: float32 (size: 4, cast: f32)
.value: 4
.usages:
	cmplStd/test/lang/overload.inline.ci:12: referenced as `overload`
}
overload(a: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'overload'
.file: 'cmplStd/test/lang/overload.inline.ci:7'
.param .result: int32 (size: 4, cast: i32)
.param a: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.value: 5
.usages:
	cmplStd/test/lang/overload.inline.ci:13: referenced as `overload`
}
overload1: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload1'
.file: 'cmplStd/test/lang/overload.inline.ci:9'
.value: overload
.usages:
}
overload2: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload2'
.file: 'cmplStd/test/lang/overload.inline.ci:10'
.value: overload()
.usages:
}
overload3: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload3'
.file: 'cmplStd/test/lang/overload.inline.ci:11'
.value: overload(0)
.usages:
}
overload4: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload4'
.file: 'cmplStd/test/lang/overload.inline.ci:12'
.value: overload(0.000000)
.usages:
}
overload5: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'overload5'
.file: 'cmplStd/test/lang/overload.inline.ci:13'
.value: overload(0, 0)
.usages:
}
Celsius: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.field degrees: float64 (size: 8, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:21: referenced as `Celsius`
}
Celsius.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:15'
.owner: Celsius
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `degrees`
}
Fahrenheit: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.field degrees: float64 (size: 8, cast: variable(f64))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Fahrenheit`
	cmplStd/test/lang/overload.inline.ci:22: referenced as `Fahrenheit`
}
Fahrenheit.degrees: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'degrees'
.file: 'cmplStd/test/lang/overload.inline.ci:16'
.owner: Fahrenheit
.usages:
	cmplStd/test/lang/overload.inline.ci:25: referenced as `degrees`
}
Celsius(value: float64): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:21'
.param .result: Celsius (size: 8, cast: val)
.param value: float64 (size: 8, cast: f64)
.value: Celsius(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:28: referenced as `Celsius`
	cmplStd/test/lang/overload.inline.ci:25: referenced as `Celsius`
}
Fahrenheit(value: float64): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:22'
.param .result: Fahrenheit (size: 8, cast: val)
.param value: float64 (size: 8, cast: f64)
.value: Fahrenheit(emit(float64(value)))
.usages:
	cmplStd/test/lang/overload.inline.ci:26: referenced as `Fahrenheit`
}
Celsius(value: Fahrenheit): Celsius: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Celsius'
.file: 'cmplStd/test/lang/overload.inline.ci:25'
.param .result: Celsius (size: 8, cast: val)
.param value: Fahrenheit (size: 8, cast: val)
.value: Celsius((value.degrees - (32)) / 1.800000)
.usages:
}
Fahrenheit(value: Celsius): Fahrenheit: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Fahrenheit'
.file: 'cmplStd/test/lang/overload.inline.ci:26'
.param .result: Fahrenheit (size: 8, cast: val)
.param value: Celsius (size: 8, cast: val)
.value: Fahrenheit(value.degrees * 1.800000 + (32))
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `Fahrenheit`
}
boilC: Celsius {
.kind: variable(val)
.base: `Celsius`
.size: 8
.name: 'boilC'
.file: 'cmplStd/test/lang/overload.inline.ci:28'
.value: Celsius(100.000000)
.usages:
	cmplStd/test/lang/overload.inline.ci:29: referenced as `boilC`
}
boilF: Fahrenheit {
.kind: variable(val)
.base: `Fahrenheit`
.size: 8
.name: 'boilF'
.file: 'cmplStd/test/lang/overload.inline.ci:29'
.value: Fahrenheit(boilC)
.usages:
}
realloc(data: pointer, size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'realloc'
.file: 'cmplStd/test/lang/memory.ci:3'
.param .result: pointer (size: 4, cast: ref)
.param data: pointer (size: 4, cast: ref)
.param size: int32 (size: 4, cast: i32)
.value: pointer.alloc(data, size)
.usages:
}
malloc(size: int32): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'malloc'
.file: 'cmplStd/test/lang/memory.ci:4'
.param .result: pointer (size: 4, cast: ref)
.param size: int32 (size: 4, cast: i32)
.value: pointer.alloc(null, size)
.usages:
	cmplStd/test/lang/memory.ci:10: referenced as `malloc`
	cmplStd/test/lang/memory.ci:9: referenced as `malloc`
	cmplStd/test/lang/memory.ci:8: referenced as `malloc`
	cmplStd/test/lang/memory.ci:7: referenced as `malloc`
}
free(data: pointer): pointer: function {
.kind: inline
.base: `function`
.size: 0
.name: 'free'
.file: 'cmplStd/test/lang/memory.ci:5'
.param .result: pointer (size: 4, cast: ref)
.param data: pointer (size: 4, cast: ref)
.value: pointer.alloc(data, 0)
.usages:
	cmplStd/test/lang/memory.ci:20: referenced as `free`
	cmplStd/test/lang/memory.ci:19: referenced as `free`
	cmplStd/test/lang/memory.ci:18: referenced as `free`
	cmplStd/test/lang/memory.ci:17: referenced as `free`
}
p1: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p1'
.file: 'cmplStd/test/lang/memory.ci:7'
.value: malloc(1024)
.usages:
	cmplStd/test/lang/memory.ci:17: referenced as `p1`
	cmplStd/test/lang/memory.ci:14: referenced as `p1`
	cmplStd/test/lang/memory.ci:13: referenced as `p1`
}
p2: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p2'
.file: 'cmplStd/test/lang/memory.ci:8'
.value: malloc(80)
.usages:
	cmplStd/test/lang/memory.ci:18: referenced as `p2`
}
p3: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p3'
.file: 'cmplStd/test/lang/memory.ci:9'
.value: malloc(160)
.usages:
	cmplStd/test/lang/memory.ci:19: referenced as `p3`
	cmplStd/test/lang/memory.ci:14: referenced as `p3`
}
p4: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'p4'
.file: 'cmplStd/test/lang/memory.ci:10'
.value: malloc(820)
.usages:
	cmplStd/test/lang/memory.ci:20: referenced as `p4`
}
val1: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'val1'
.file: 'cmplStd/test/lang/memory.ci:23'
.value: 42
.usages:
	cmplStd/test/lang/memory.ci:32: referenced as `val1`
	cmplStd/test/lang/memory.ci:30: referenced as `val1`
	cmplStd/test/lang/memory.ci:29: referenced as `val1`
	cmplStd/test/lang/memory.ci:26: referenced as `val1`
}
val2: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'val2'
.file: 'cmplStd/test/lang/memory.ci:24'
.value: 96
.usages:
	cmplStd/test/lang/memory.ci:33: referenced as `val2`
	cmplStd/test/lang/memory.ci:29: referenced as `val2`
	cmplStd/test/lang/memory.ci:27: referenced as `val2`
}
noError(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 1
.name: 'noError'
.file: 'cmplStd/test/lang/tryExec.ci:3'
.param .result: void (size: 0, cast: variable(void))
.param ptr: pointer (size: 4, cast: variable(ref))
.value: {
}
.instructions: (1 byte)
	<noError>  : ret
.usages:
	cmplStd/test/lang/tryExec.ci:39: referenced as `noError`
}
stackOverflow(ptr: pointer): void: function {
.kind: static function
.base: `function`
.size: 24
.name: 'stackOverflow'
.file: 'cmplStd/test/lang/tryExec.ci:6'
.param .result: void (size: 0, cast: variable(void))
.param ptr: pointer (size: 4, cast: variable(ref))
.value: {
	data: uint8[8192] := {
	};
	stackOverflow(ptr);
}
.instructions: (24 bytes)
	cmplStd/test/lang/tryExec.ci:8: (4 bytes): data: uint8[8192] := {...}
	<stackOverflow>  : inc.sp(+8192)
	cmplStd/test/lang/tryExec.ci:9: (15 bytes): stackOverflow(ptr);
	<stackOverflow+?>: load.sp(+8196)
	<stackOverflow+?>: load.i32
	<stackOverflow+?>: load.ref <?> ;stackOverflow(ptr: pointer): void
	<stackOverflow+?>: call
	<stackOverflow+?>: inc.sp(-4)
	<stackOverflow+?>: inc.sp(-8192)
	<stackOverflow+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:41: referenced as `stackOverflow`
	cmplStd/test/lang/tryExec.ci:9: referenced as `stackOverflow`
}
divisionByZero(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 12
.name: 'divisionByZero'
.file: 'cmplStd/test/lang/tryExec.ci:12'
.param .result: void (size: 0, cast: variable(void))
.param args: pointer (size: 4, cast: variable(ref))
.value: {
	value: int32 := 3 / 0;
}
.instructions: (12 bytes)
	cmplStd/test/lang/tryExec.ci:13: (7 bytes): value: int32 := 3 / 0
	<divisionByZero>  : load.c32 3
	<divisionByZero+?>: load.z32
	<divisionByZero+?>: div.i32
	<divisionByZero+?>: inc.sp(-4)
	<divisionByZero+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:42: referenced as `divisionByZero`
}
abortExecution(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 83
.name: 'abortExecution'
.file: 'cmplStd/test/lang/tryExec.ci:16'
.param .result: void (size: 0, cast: variable(void))
.param args: pointer (size: 4, cast: variable(ref))
.value: {
	static const NotEquals: struct {
		message: char[*];
		expected: int32;
		returned: int32;
	};
	details: NotEquals := {
		details.message := ("assertion failed");
		details.expected := 97;
		details.returned := 77;
	};
	abort("fatal error", details);
}
.instructions: (83 bytes)
	cmplStd/test/lang/tryExec.ci:22: (25 bytes): details: NotEquals := {...}
	<abortExecution>  : inc.sp(+16)
	cmplStd/test/lang/tryExec.ci:23: (7 bytes): details.message := ("assertion failed");
	<abortExecution+?>: load.ref <?> ;"assertion failed"
	<abortExecution+?>: set.x32 sp(1)
	cmplStd/test/lang/tryExec.ci:24: (7 bytes): details.expected := 97;
	<abortExecution+?>: load.c32 97
	<abortExecution+?>: set.x32 sp(2)
	cmplStd/test/lang/tryExec.ci:25: (7 bytes): details.returned := 77;
	<abortExecution+?>: load.c32 77
	<abortExecution+?>: set.x32 sp(3)
	cmplStd/test/lang/tryExec.ci:27: (53 bytes): abort("fatal error", details);
	<abortExecution+?>: load.ref <?> ;abortExecution.NotEquals
	<abortExecution+?>: load.sp(+4)
	<abortExecution+?>: load.c32 1
	<abortExecution+?>: load.sp(+4)
	<abortExecution+?>: load.ref <?> ;"cmplStd/test/lang/tryExec.ci"
	<abortExecution+?>: load.c32 27
	<abortExecution+?>: load.c32 -2
	<abortExecution+?>: load.c32 128
	<abortExecution+?>: load.ref <?> ;"fatal error"
	<abortExecution+?>: dup.x64 sp(5)
	<abortExecution+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<abortExecution+?>: inc.sp(-16)
	<abortExecution+?>: inc.sp(-16)
	<abortExecution+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:45: referenced as `abortExecution`
}
invalidMemoryAccess(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 13
.name: 'invalidMemoryAccess'
.file: 'cmplStd/test/lang/tryExec.ci:30'
.param .result: void (size: 0, cast: variable(void))
.param args: pointer (size: 4, cast: variable(ref))
.value: {
	i32Ref: int32 := null;
	i32Val: int32 := i32Ref;
}
.instructions: (13 bytes)
	cmplStd/test/lang/tryExec.ci:31: (5 bytes): i32Ref: int32 := null
	<invalidMemoryAccess>  : load.ref <?> ;null
	cmplStd/test/lang/tryExec.ci:32: (3 bytes): i32Val: int32 := i32Ref
	<invalidMemoryAccess+?>: dup.x32 sp(0)
	<invalidMemoryAccess+?>: load.i32
	<invalidMemoryAccess+?>: inc.sp(-8)
	<invalidMemoryAccess+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:44: referenced as `invalidMemoryAccess`
}
invalidInstruction(args: pointer): void: function {
.kind: static function
.base: `function`
.size: 2
.name: 'invalidInstruction'
.file: 'cmplStd/test/lang/tryExec.ci:35'
.param .result: void (size: 0, cast: variable(void))
.param args: pointer (size: 4, cast: variable(ref))
.value: {
	emit(load.z32, ret);
}
.instructions: (2 bytes)
	cmplStd/test/lang/tryExec.ci:36: (2 bytes): emit(load.z32, ret);
	<invalidInstruction>  : load.z32
	<invalidInstruction+?>: ret
.usages:
	cmplStd/test/lang/tryExec.ci:43: referenced as `invalidInstruction`
}
tryExecErr0: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr0'
.file: 'cmplStd/test/lang/tryExec.ci:39'
.value: tryExec(null, noError)
.usages:
}
tryExecErr1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr1'
.file: 'cmplStd/test/lang/tryExec.ci:40'
.value: tryExec(null, null)
.usages:
}
tryExecErr2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr2'
.file: 'cmplStd/test/lang/tryExec.ci:41'
.value: tryExec(null, stackOverflow)
.usages:
}
tryExecErr3: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr3'
.file: 'cmplStd/test/lang/tryExec.ci:42'
.value: tryExec(null, divisionByZero)
.usages:
}
tryExecErr4: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr4'
.file: 'cmplStd/test/lang/tryExec.ci:43'
.value: tryExec(null, invalidInstruction)
.usages:
}
tryExecErr5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr5'
.file: 'cmplStd/test/lang/tryExec.ci:44'
.value: tryExec(null, invalidMemoryAccess)
.usages:
}
tryExecErr6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'tryExecErr6'
.file: 'cmplStd/test/lang/tryExec.ci:45'
.value: tryExec(null, abortExecution)
.usages:
}
arr: int32[5] {
.kind: variable(val)
.base: `int32[5]`
.size: 20
.name: 'arr'
.file: 'cmplStd/test/lang/pointer.ci:1'
.value: {
	arr[0] := 1;
	arr[1] := 2;
	arr[2] := 3;
	arr[3] := 4;
	arr[4] := 5;
}
.usages:
	cmplStd/test/lang/pointer.ci:9: referenced as `arr`
	cmplStd/test/lang/pointer.ci:7: referenced as `arr`
	cmplStd/test/lang/pointer.ci:6: referenced as `arr`
	cmplStd/test/lang/pointer.ci:5: referenced as `arr`
	cmplStd/test/lang/pointer.ci:4: referenced as `arr`
	cmplStd/test/lang/pointer.ci:3: referenced as `arr`
	cmplStd/test/lang/pointer.ci:2: referenced as `arr`
}
ptr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptr'
.file: 'cmplStd/test/lang/pointer.ci:2'
.value: arr
.usages:
	cmplStd/test/lang/pointer.ci:14: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:13: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:12: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:11: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:10: referenced as `ptr`
	cmplStd/test/lang/pointer.ci:9: referenced as `ptr`
}
a0: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a0'
.file: 'cmplStd/test/lang/pointer.ci:3'
.value: arr[0]
.usages:
	cmplStd/test/lang/pointer.ci:10: referenced as `a0`
}
a1: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a1'
.file: 'cmplStd/test/lang/pointer.ci:4'
.value: arr[1]
.usages:
	cmplStd/test/lang/pointer.ci:11: referenced as `a1`
}
a2: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a2'
.file: 'cmplStd/test/lang/pointer.ci:5'
.value: arr[2]
.usages:
	cmplStd/test/lang/pointer.ci:12: referenced as `a2`
}
a3: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a3'
.file: 'cmplStd/test/lang/pointer.ci:6'
.value: arr[3]
.usages:
	cmplStd/test/lang/pointer.ci:13: referenced as `a3`
}
a4: int32 {
.kind: variable(ref)
.base: `int32`
.size: 4
.name: 'a4'
.file: 'cmplStd/test/lang/pointer.ci:7'
.value: arr[4]
.usages:
	cmplStd/test/lang/pointer.ci:14: referenced as `a4`
}
value: int64 {
.kind: static variable(i64)
.base: `int64`
.size: 8
.name: 'value'
.file: 'cmplStd/test/lang/init.reference.ci:7'
.value: 42
.usages:
	cmplStd/test/lang/init.reference.ci:99: referenced as `value`
	cmplStd/test/lang/init.reference.ci:97: referenced as `value`
	cmplStd/test/lang/init.reference.ci:96: referenced as `value`
	cmplStd/test/lang/init.reference.ci:95: referenced as `value`
	cmplStd/test/lang/init.reference.ci:27: referenced as `value`
	cmplStd/test/lang/init.reference.ci:10: referenced as `value`
	cmplStd/test/lang/init.reference.ci:9: referenced as `value`
	cmplStd/test/lang/init.reference.ci:8: referenced as `value`
}
valueRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'valueRef'
.file: 'cmplStd/test/lang/init.reference.ci:8'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:29: referenced as `valueRef`
	cmplStd/test/lang/init.reference.ci:12: referenced as `valueRef`
}
valuePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'valuePtr'
.file: 'cmplStd/test/lang/init.reference.ci:9'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:30: referenced as `valuePtr`
	cmplStd/test/lang/init.reference.ci:13: referenced as `valuePtr`
}
valueVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'valueVar'
.file: 'cmplStd/test/lang/init.reference.ci:10'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:31: referenced as `valueVar`
	cmplStd/test/lang/init.reference.ci:14: referenced as `valueVar`
}
fromRef: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'fromRef'
.file: 'cmplStd/test/lang/init.reference.ci:12'
.value: valueRef
.usages:
}
fromPtr: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'fromPtr'
.file: 'cmplStd/test/lang/init.reference.ci:13'
.value: valuePtr
.usages:
}
fromVar: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'fromVar'
.file: 'cmplStd/test/lang/init.reference.ci:14'
.value: valueVar
.usages:
}
nullRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'nullRef'
.file: 'cmplStd/test/lang/init.reference.ci:16'
.value: null
.usages:
}
nullPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'nullPtr'
.file: 'cmplStd/test/lang/init.reference.ci:17'
.value: null
.usages:
}
nullVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'nullVar'
.file: 'cmplStd/test/lang/init.reference.ci:18'
.value: null
.usages:
}
nullTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'nullTyp'
.file: 'cmplStd/test/lang/init.reference.ci:19'
.value: null
.usages:
}
nullFun: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'nullFun'
.file: 'cmplStd/test/lang/init.reference.ci:20'
.value: null
.usages:
}
nullObj: object {
.kind: variable(ref)
.base: `object`
.size: 4
.name: 'nullObj'
.file: 'cmplStd/test/lang/init.reference.ci:21'
.value: null
.usages:
}
typePtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'typePtr'
.file: 'cmplStd/test/lang/init.reference.ci:23'
.value: int64
.usages:
}
typeVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'typeVar'
.file: 'cmplStd/test/lang/init.reference.ci:24'
.value: int64
.usages:
}
typeTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeTyp'
.file: 'cmplStd/test/lang/init.reference.ci:25'
.value: int64
.usages:
	cmplStd/test/lang/init.reference.ci:32: referenced as `typeTyp`
}
local: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'local'
.file: 'cmplStd/test/lang/init.reference.ci:27'
.value: value
.usages:
	cmplStd/test/lang/init.reference.ci:28: referenced as `local`
}
copyVal: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'copyVal'
.file: 'cmplStd/test/lang/init.reference.ci:28'
.value: local
.usages:
}
copyRef: int64 {
.kind: variable(ref)
.base: `int64`
.size: 4
.name: 'copyRef'
.file: 'cmplStd/test/lang/init.reference.ci:29'
.value: valueRef
.usages:
}
copyPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'copyPtr'
.file: 'cmplStd/test/lang/init.reference.ci:30'
.value: valuePtr
.usages:
}
copyVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'copyVar'
.file: 'cmplStd/test/lang/init.reference.ci:31'
.value: valueVar
.usages:
}
copyTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'copyTyp'
.file: 'cmplStd/test/lang/init.reference.ci:32'
.value: typeTyp
.usages:
}
ptrVoid: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrVoid'
.file: 'cmplStd/test/lang/init.reference.ci:35'
.value: void
.usages:
}
ptrBool: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrBool'
.file: 'cmplStd/test/lang/init.reference.ci:36'
.value: bool
.usages:
}
ptrChar: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrChar'
.file: 'cmplStd/test/lang/init.reference.ci:37'
.value: char
.usages:
}
ptrInt8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt8'
.file: 'cmplStd/test/lang/init.reference.ci:38'
.value: int8
.usages:
}
ptrInt16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt16'
.file: 'cmplStd/test/lang/init.reference.ci:39'
.value: int16
.usages:
}
ptrInt32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt32'
.file: 'cmplStd/test/lang/init.reference.ci:40'
.value: int32
.usages:
}
ptrInt64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrInt64'
.file: 'cmplStd/test/lang/init.reference.ci:41'
.value: int64
.usages:
}
ptrUint8: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint8'
.file: 'cmplStd/test/lang/init.reference.ci:42'
.value: uint8
.usages:
}
ptrUint16: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint16'
.file: 'cmplStd/test/lang/init.reference.ci:43'
.value: uint16
.usages:
}
ptrUint32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint32'
.file: 'cmplStd/test/lang/init.reference.ci:44'
.value: uint32
.usages:
}
ptrUint64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrUint64'
.file: 'cmplStd/test/lang/init.reference.ci:45'
.value: uint64
.usages:
}
ptrFloat32: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:46'
.value: float32
.usages:
}
ptrFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:47'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:105: referenced as `ptrFloat64`
}
ptrTypename: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrTypename'
.file: 'cmplStd/test/lang/init.reference.ci:48'
.value: typename
.usages:
}
ptrFunction: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrFunction'
.file: 'cmplStd/test/lang/init.reference.ci:49'
.value: function
.usages:
}
ptrPointer: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrPointer'
.file: 'cmplStd/test/lang/init.reference.ci:50'
.value: pointer
.usages:
}
ptrVariant: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrVariant'
.file: 'cmplStd/test/lang/init.reference.ci:51'
.value: variant
.usages:
}
ptrObject: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrObject'
.file: 'cmplStd/test/lang/init.reference.ci:52'
.value: object
.usages:
}
varVoid: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varVoid'
.file: 'cmplStd/test/lang/init.reference.ci:55'
.value: void
.usages:
}
varBool: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varBool'
.file: 'cmplStd/test/lang/init.reference.ci:56'
.value: bool
.usages:
}
varChar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varChar'
.file: 'cmplStd/test/lang/init.reference.ci:57'
.value: char
.usages:
}
varInt8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt8'
.file: 'cmplStd/test/lang/init.reference.ci:58'
.value: int8
.usages:
}
varInt16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt16'
.file: 'cmplStd/test/lang/init.reference.ci:59'
.value: int16
.usages:
}
varInt32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt32'
.file: 'cmplStd/test/lang/init.reference.ci:60'
.value: int32
.usages:
}
varInt64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varInt64'
.file: 'cmplStd/test/lang/init.reference.ci:61'
.value: int64
.usages:
}
varUint8: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint8'
.file: 'cmplStd/test/lang/init.reference.ci:62'
.value: uint8
.usages:
}
varUint16: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint16'
.file: 'cmplStd/test/lang/init.reference.ci:63'
.value: uint16
.usages:
}
varUint32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint32'
.file: 'cmplStd/test/lang/init.reference.ci:64'
.value: uint32
.usages:
}
varUint64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varUint64'
.file: 'cmplStd/test/lang/init.reference.ci:65'
.value: uint64
.usages:
}
varFloat32: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:66'
.value: float32
.usages:
}
varFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:67'
.value: float64
.usages:
	cmplStd/test/lang/init.reference.ci:108: referenced as `varFloat64`
}
varTypename: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varTypename'
.file: 'cmplStd/test/lang/init.reference.ci:68'
.value: typename
.usages:
}
varFunction: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varFunction'
.file: 'cmplStd/test/lang/init.reference.ci:69'
.value: function
.usages:
}
varPointer: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varPointer'
.file: 'cmplStd/test/lang/init.reference.ci:70'
.value: pointer
.usages:
}
varVariant: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varVariant'
.file: 'cmplStd/test/lang/init.reference.ci:71'
.value: variant
.usages:
}
varObject: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'varObject'
.file: 'cmplStd/test/lang/init.reference.ci:72'
.value: object
.usages:
}
typVoid: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typVoid'
.file: 'cmplStd/test/lang/init.reference.ci:75'
.value: void
.usages:
}
typBool: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typBool'
.file: 'cmplStd/test/lang/init.reference.ci:76'
.value: bool
.usages:
}
typChar: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typChar'
.file: 'cmplStd/test/lang/init.reference.ci:77'
.value: char
.usages:
}
typInt8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt8'
.file: 'cmplStd/test/lang/init.reference.ci:78'
.value: int8
.usages:
}
typInt16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt16'
.file: 'cmplStd/test/lang/init.reference.ci:79'
.value: int16
.usages:
}
typInt32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt32'
.file: 'cmplStd/test/lang/init.reference.ci:80'
.value: int32
.usages:
}
typInt64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typInt64'
.file: 'cmplStd/test/lang/init.reference.ci:81'
.value: int64
.usages:
}
typUint8: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint8'
.file: 'cmplStd/test/lang/init.reference.ci:82'
.value: uint8
.usages:
}
typUint16: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint16'
.file: 'cmplStd/test/lang/init.reference.ci:83'
.value: uint16
.usages:
}
typUint32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint32'
.file: 'cmplStd/test/lang/init.reference.ci:84'
.value: uint32
.usages:
}
typUint64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typUint64'
.file: 'cmplStd/test/lang/init.reference.ci:85'
.value: uint64
.usages:
}
typFloat32: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFloat32'
.file: 'cmplStd/test/lang/init.reference.ci:86'
.value: float32
.usages:
}
typFloat64: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:87'
.value: float64
.usages:
}
typTypename: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typTypename'
.file: 'cmplStd/test/lang/init.reference.ci:88'
.value: typename
.usages:
}
typFunction: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typFunction'
.file: 'cmplStd/test/lang/init.reference.ci:89'
.value: function
.usages:
}
typPointer: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typPointer'
.file: 'cmplStd/test/lang/init.reference.ci:90'
.value: pointer
.usages:
}
typVariant: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typVariant'
.file: 'cmplStd/test/lang/init.reference.ci:91'
.value: variant
.usages:
}
typObject: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typObject'
.file: 'cmplStd/test/lang/init.reference.ci:92'
.value: object
.usages:
}
valueOfPtr: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'valueOfPtr'
.file: 'cmplStd/test/lang/init.reference.ci:95'
.value: pointer(value)
.usages:
}
valueOfVar: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'valueOfVar'
.file: 'cmplStd/test/lang/init.reference.ci:96'
.value: variant(value)
.usages:
}
valueOfTyp: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'valueOfTyp'
.file: 'cmplStd/test/lang/init.reference.ci:97'
.value: typename(value)
.usages:
}
typeOfValue: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeOfValue'
.file: 'cmplStd/test/lang/init.reference.ci:99'
.value: typename(value)
.usages:
}
copyPtrFloat64: variant {
.kind: variable(var)
.base: `variant`
.size: 8
.name: 'copyPtrFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:105'
.value: ptrFloat64
.usages:
}
copyVarFloat64: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'copyVarFloat64'
.file: 'cmplStd/test/lang/init.reference.ci:108'
.value: varFloat64
.usages:
}
variable: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'variable'
.file: 'cmplStd/test/lang/init.variable.ci:3'
.doc: 'Uninitialized variables will be initialized with default type initializer: 0'
.usages:
}
constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'cmplStd/test/lang/init.variable.ci:7'
.doc: 'Constant variables must be explicitly initialized'
.value: 42
.usages:
}
ComplexVal: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'ComplexVal'
.file: 'cmplStd/test/lang/init.variable.ci:9'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `ComplexVal`
}
ComplexVal.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:10'
.owner: ComplexVal
.usages:
	cmplStd/test/lang/init.variable.ci:24: referenced as `re`
}
ComplexVal.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:11'
.owner: ComplexVal
.value: 0
.usages:
	internal usages: 1
}
ComplexObj: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.name: 'ComplexObj'
.file: 'cmplStd/test/lang/init.variable.ci:13'
.field re: float64 (size: 8, cast: const variable(f64))
.field im: float64 (size: 8, cast: const variable(f64))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `ComplexObj`
	cmplStd/test/lang/init.variable.ci:33: referenced as `ComplexObj`
}
ComplexObj.re: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 're'
.file: 'cmplStd/test/lang/init.variable.ci:14'
.owner: ComplexObj
.usages:
	cmplStd/test/lang/init.variable.ci:41: referenced as `re`
	cmplStd/test/lang/init.variable.ci:33: referenced as `re`
}
ComplexObj.im: float64 {
.kind: const variable(f64)
.base: `float64`
.size: 8
.name: 'im'
.file: 'cmplStd/test/lang/init.variable.ci:15'
.owner: ComplexObj
.value: 0
.usages:
	internal usages: 2
}
valInitImplicit: ComplexVal {
.kind: variable(val)
.base: `ComplexVal`
.size: 16
.name: 'valInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:24'
.doc: 'Value types must be explicitly initialized
the initializer will be extended with implicit field initializers
{re: 8} => {
valInitImplicit.re := 8;
valInitImplicit.im := 0;
}'
.value: {
	valInitImplicit.re := (8);
	valInitImplicit.im := (0);
}
.usages:
}
objInitImplicit: ComplexObj {
.kind: variable(ref)
.base: `ComplexObj`
.size: 4
.name: 'objInitImplicit'
.file: 'cmplStd/test/lang/init.variable.ci:33'
.doc: 'Reference types must be explicitly initialized
the initializer will be extended with instance creation
{re: 8} => {
objInitImplicit := Object.create(ComplexObj);
objInitImplicit.re := 8;
objInitImplicit.im := 0;
}'
.value: {
	objInitImplicit := create(ComplexObj);
	objInitImplicit.re := (8);
	objInitImplicit.im := (0);
}
.usages:
}
objInitExplicit: object {
.kind: variable(ref)
.base: `object`
.size: 4
.name: 'objInitExplicit'
.file: 'cmplStd/test/lang/init.variable.ci:41'
.doc: 'variable type can be base type of the explicit initializer type
ComplexObj {re: 8} => {
objInitExplicit := Object.create(ComplexObj);
objInitExplicit.re := 8;
objInitExplicit.im := 0;
}'
.value: {
	objInitExplicit := create(ComplexObj);
	objInitExplicit.re := (8);
	objInitExplicit.im := (0);
}
.usages:
}
empty(): void: function {
.kind: static function
.base: `function`
.size: 1
.name: 'empty'
.file: 'cmplStd/test/lang/function.ci:4'
.param .result: void (size: 0, cast: variable(void))
.doc: 'function with empty implementation'
.value: {
}
.instructions: (1 byte)
	<empty>  : ret
.usages:
}
funAdd(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.name: 'funAdd'
.file: 'cmplStd/test/lang/function.ci:7'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'function with implementation'
.value: {
	return .result := x + y;
}
.instructions: (8 bytes)
	cmplStd/test/lang/function.ci:8: (8 bytes): return .result := x + y;
	<funAdd>  : dup.x32 sp(2)
	<funAdd+?>: dup.x32 sp(2)
	<funAdd+?>: add.i32
	<funAdd+?>: set.x32 sp(4)
	<funAdd+?>: ret
.usages:
	cmplStd/test/lang/function.ci:15: referenced as `funAdd`
	cmplStd/test/lang/function.ci:12: referenced as `funAdd`
}
funAddResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funAddResult'
.file: 'cmplStd/test/lang/function.ci:12'
.doc: 'function invocation'
.value: funAdd(2, 7)
.usages:
}
funAddRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funAddRef'
.file: 'cmplStd/test/lang/function.ci:15'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'initialized function reference'
.value: funAdd
.usages:
	cmplStd/test/lang/function.ci:18: referenced as `funAddRef`
}
funAddRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funAddRefResult'
.file: 'cmplStd/test/lang/function.ci:18'
.doc: 'function reference invocation'
.value: funAddRef(2, 8)
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:21'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'forward function reference (must be implemented somewhere)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:27: referenced as `funMul`
	cmplStd/test/lang/function.ci:24: referenced as `funMul`
}
funMulResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funMulResult'
.file: 'cmplStd/test/lang/function.ci:24'
.doc: 'forward function invocation'
.value: funMul(2, 6)
.usages:
}
funMulRef(x: int32, y: int32): int32: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'funMulRef'
.file: 'cmplStd/test/lang/function.ci:27'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'initialized function reference (copy address)'
.value: funMul
.usages:
	cmplStd/test/lang/function.ci:30: referenced as `funMulRef`
}
funMulRefResult: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'funMulRefResult'
.file: 'cmplStd/test/lang/function.ci:30'
.doc: 'function reference invocation'
.value: funMulRef(2, 7)
.usages:
}
funMul(x: int32, y: int32): int32: function {
.kind: static function
.base: `function`
.size: 8
.name: 'funMul'
.file: 'cmplStd/test/lang/function.ci:33'
.param .result: int32 (size: 4, cast: variable(i32))
.param x: int32 (size: 4, cast: variable(i32))
.param y: int32 (size: 4, cast: variable(i32))
.doc: 'forward function implementation'
.value: {
	return .result := x * y;
}
.instructions: (8 bytes)
	cmplStd/test/lang/function.ci:34: (8 bytes): return .result := x * y;
	<funMul>  : dup.x32 sp(2)
	<funMul+?>: dup.x32 sp(2)
	<funMul+?>: mul.i32
	<funMul+?>: set.x32 sp(4)
	<funMul+?>: ret
.usages:
}
fib(n: uint32): uint32: function {
.kind: static function
.base: `function`
.size: 54
.name: 'fib'
.file: 'cmplStd/test/lang/function.ci:38'
.param .result: uint32 (size: 4, cast: variable(u32))
.param n: uint32 (size: 4, cast: variable(u32))
.doc: 'recursive function implementation'
.value: {
	if (n <= (1)) {
		return .result := n;
	}
	return .result := fib(n - (1)) + fib(n - (2));
}
.instructions: (54 bytes)
	cmplStd/test/lang/function.ci:39: (16 bytes): if (n <= (1))
	<fib>  : dup.x32 sp(1)
	<fib+?>: load.c32 1
	<fib+?>: cgt.u32
	<fib+?>: jnz +8
	cmplStd/test/lang/function.ci:40: (4 bytes): return .result := n;
	<fib+?>: mov.x32 sp(2, 1)
	<fib+?>: ret
	cmplStd/test/lang/function.ci:42: (38 bytes): return .result := fib(n - (1)) + fib(n - (2));
	<fib+?>: load.z32
	<fib+?>: dup.x32 sp(2)
	<fib+?>: inc.i32(-1)
	<fib+?>: load.ref <?> ;fib(n: uint32): uint32
	<fib+?>: call
	<fib+?>: inc.sp(-4)
	<fib+?>: load.z32
	<fib+?>: dup.x32 sp(3)
	<fib+?>: inc.i32(-2)
	<fib+?>: load.ref <?> ;fib(n: uint32): uint32
	<fib+?>: call
	<fib+?>: inc.sp(-4)
	<fib+?>: add.i32
	<fib+?>: set.x32 sp(3)
	<fib+?>: ret
.usages:
	cmplStd/test/lang/function.ci:46: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
	cmplStd/test/lang/function.ci:42: referenced as `fib`
}
fibonacci_13: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'fibonacci_13'
.file: 'cmplStd/test/lang/function.ci:46'
.doc: 'recursive function invocation'
.value: fib(13)
.usages:
}
sizeofVoid: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofVoid'
.file: 'cmplStd/test/lang/reflect.ci:3'
.value: sizeof(void)
.usages:
}
sizeofBool: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofBool'
.file: 'cmplStd/test/lang/reflect.ci:4'
.value: sizeof(bool)
.usages:
}
sizeofChar: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofChar'
.file: 'cmplStd/test/lang/reflect.ci:5'
.value: sizeof(char)
.usages:
}
sizeofInt8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt8'
.file: 'cmplStd/test/lang/reflect.ci:6'
.value: sizeof(int8)
.usages:
}
sizeofInt16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt16'
.file: 'cmplStd/test/lang/reflect.ci:7'
.value: sizeof(int16)
.usages:
}
sizeofInt32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt32'
.file: 'cmplStd/test/lang/reflect.ci:8'
.value: sizeof(int32)
.usages:
}
sizeofInt64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofInt64'
.file: 'cmplStd/test/lang/reflect.ci:9'
.value: sizeof(int64)
.usages:
}
sizeofUint8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint8'
.file: 'cmplStd/test/lang/reflect.ci:10'
.value: sizeof(uint8)
.usages:
}
sizeofUint16: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint16'
.file: 'cmplStd/test/lang/reflect.ci:11'
.value: sizeof(uint16)
.usages:
}
sizeofUint32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint32'
.file: 'cmplStd/test/lang/reflect.ci:12'
.value: sizeof(uint32)
.usages:
}
sizeofUint64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofUint64'
.file: 'cmplStd/test/lang/reflect.ci:13'
.value: sizeof(uint64)
.usages:
}
sizeofFloat32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFloat32'
.file: 'cmplStd/test/lang/reflect.ci:14'
.value: sizeof(float32)
.usages:
}
sizeofFloat64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFloat64'
.file: 'cmplStd/test/lang/reflect.ci:15'
.value: sizeof(float64)
.usages:
}
sizeofPointer: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofPointer'
.file: 'cmplStd/test/lang/reflect.ci:16'
.value: sizeof(pointer)
.usages:
}
sizeofVariant: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofVariant'
.file: 'cmplStd/test/lang/reflect.ci:17'
.value: sizeof(variant)
.usages:
}
sizeofTypename: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofTypename'
.file: 'cmplStd/test/lang/reflect.ci:18'
.value: sizeof(typename)
.usages:
}
sizeofFunction: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofFunction'
.file: 'cmplStd/test/lang/reflect.ci:19'
.value: sizeof(function)
.usages:
}
sizeofObject: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeofObject'
.file: 'cmplStd/test/lang/reflect.ci:20'
.value: sizeof(object)
.usages:
}
RecordSizeof: object {
.kind: static const typename(ref)
.base: `object`
.size: 12
.name: 'RecordSizeof'
.file: 'cmplStd/test/lang/reflect.ci:22'
.field x: int64 (size: 8, cast: variable(i64))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:26: referenced as `RecordSizeof`
}
RecordSizeof.x: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'x'
.file: 'cmplStd/test/lang/reflect.ci:23'
.owner: RecordSizeof
.value: 0
.usages:
}
RecordSizeofExt: RecordSizeof {
.kind: static const typename(ref)
.base: `RecordSizeof`
.size: 16
.name: 'RecordSizeofExt'
.file: 'cmplStd/test/lang/reflect.ci:26'
.field y: int32 (size: 4, cast: variable(i32))
.field x: int64 (size: 8, cast: variable(i64))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
	cmplStd/test/lang/reflect.ci:30: referenced as `RecordSizeofExt`
}
RecordSizeofExt.y: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'y'
.file: 'cmplStd/test/lang/reflect.ci:27'
.owner: RecordSizeofExt
.value: 0
.usages:
}
typeofRecord: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofRecord'
.file: 'cmplStd/test/lang/reflect.ci:30'
.value: RecordSizeofExt
.usages:
	cmplStd/test/lang/reflect.ci:37: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:35: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:34: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:33: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:32: referenced as `typeofRecord`
	cmplStd/test/lang/reflect.ci:31: referenced as `typeofRecord`
}
nameOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'nameOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:31'
.value: typename.name(typeofRecord)
.usages:
}
offsetOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:32'
.value: typeofRecord.offset
.usages:
}
sizeOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:33'
.value: typeofRecord.size
.usages:
}
fileOfRecord: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'fileOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:34'
.value: typename.file(typeofRecord)
.usages:
}
lineOfRecord: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lineOfRecord'
.file: 'cmplStd/test/lang/reflect.ci:35'
.value: typename.line(typeofRecord)
.usages:
}
typeofBase: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase'
.file: 'cmplStd/test/lang/reflect.ci:37'
.value: typename.base(typeofRecord)
.usages:
	cmplStd/test/lang/reflect.ci:44: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:42: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:41: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:40: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:39: referenced as `typeofBase`
	cmplStd/test/lang/reflect.ci:38: referenced as `typeofBase`
}
nameOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'nameOfBase'
.file: 'cmplStd/test/lang/reflect.ci:38'
.value: typename.name(typeofBase)
.usages:
}
offsetOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase'
.file: 'cmplStd/test/lang/reflect.ci:39'
.value: typeofBase.offset
.usages:
}
sizeOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase'
.file: 'cmplStd/test/lang/reflect.ci:40'
.value: typeofBase.size
.usages:
}
fileOfBase: char[*] {
.kind: variable(ref)
.base: `char[*]`
.size: 4
.name: 'fileOfBase'
.file: 'cmplStd/test/lang/reflect.ci:41'
.value: typename.file(typeofBase)
.usages:
}
lineOfBase: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'lineOfBase'
.file: 'cmplStd/test/lang/reflect.ci:42'
.value: typename.line(typeofBase)
.usages:
}
typeofBase1: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase1'
.file: 'cmplStd/test/lang/reflect.ci:44'
.value: typename.base(typeofBase)
.usages:
	cmplStd/test/lang/reflect.ci:48: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:46: referenced as `typeofBase1`
	cmplStd/test/lang/reflect.ci:45: referenced as `typeofBase1`
}
offsetOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:45'
.value: typeofBase1.offset
.usages:
}
sizeOfBase1: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase1'
.file: 'cmplStd/test/lang/reflect.ci:46'
.value: typeofBase1.size
.usages:
}
typeofBase2: typename {
.kind: variable(ref)
.base: `typename`
.size: 4
.name: 'typeofBase2'
.file: 'cmplStd/test/lang/reflect.ci:48'
.value: typename.base(typeofBase1)
.usages:
	cmplStd/test/lang/reflect.ci:50: referenced as `typeofBase2`
	cmplStd/test/lang/reflect.ci:49: referenced as `typeofBase2`
}
offsetOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'offsetOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:49'
.value: typeofBase2.offset
.usages:
}
sizeOfBase2: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sizeOfBase2'
.file: 'cmplStd/test/lang/reflect.ci:50'
.value: typeofBase2.size
.usages:
}
RecordMemberTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'RecordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:2'
.field Inner: typename (size: 8, cast: static const typename(val))
.field member: int32 (size: 4, cast: variable(i32))
.field constant: int32 (size: 4, cast: const variable(i32))
.field memberInit: int32 (size: 4, cast: variable(i32))
.field constantInit: int32 (size: 4, cast: const variable(i32))
.field memberRec: RecordMemberTest.Inner (size: 8, cast: variable(val))
.field constantRec: RecordMemberTest.Inner (size: 8, cast: const variable(val))
.field global: int32 (size: 4, cast: static variable(i32))
.field globalInit: int32 (size: 4, cast: static variable(i32))
.field globalConstant: int32 (size: 4, cast: static const variable(i32))
.field globalRec: RecordMemberTest.Inner (size: 8, cast: static variable(val))
.field globalRecInit: RecordMemberTest.Inner (size: 8, cast: static variable(val))
.field globalConstantRec: RecordMemberTest.Inner (size: 8, cast: static const variable(val))
.doc: 'test and documentation of member initializations'
.usages:
	cmplStd/test/lang/init.member.ci:52: referenced as `RecordMemberTest`
}
RecordMemberTest.Inner: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'Inner'
.file: 'cmplStd/test/lang/init.member.ci:4'
.owner: RecordMemberTest
.field member: int32 (size: 4, cast: variable(i32))
.field constant: int32 (size: 4, cast: const variable(i32))
.usages:
	cmplStd/test/lang/init.member.ci:49: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:46: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:43: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:25: referenced as `Inner`
	cmplStd/test/lang/init.member.ci:22: referenced as `Inner`
}
RecordMemberTest.Inner.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:5'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:64: referenced as `member`
	cmplStd/test/lang/init.member.ci:59: referenced as `member`
	cmplStd/test/lang/init.member.ci:49: referenced as `member`
	cmplStd/test/lang/init.member.ci:46: referenced as `member`
	internal usages: 1
}
RecordMemberTest.Inner.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:6'
.owner: RecordMemberTest.Inner
.usages:
	cmplStd/test/lang/init.member.ci:65: referenced as `constant`
	cmplStd/test/lang/init.member.ci:60: referenced as `constant`
	cmplStd/test/lang/init.member.ci:49: referenced as `constant`
	cmplStd/test/lang/init.member.ci:46: referenced as `constant`
	cmplStd/test/lang/init.member.ci:43: referenced as `constant`
}
RecordMemberTest.member: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'member'
.file: 'cmplStd/test/lang/init.member.ci:10'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:53: referenced as `member`
}
RecordMemberTest.constant: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constant'
.file: 'cmplStd/test/lang/init.member.ci:13'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:54: referenced as `constant`
}
RecordMemberTest.memberInit: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'memberInit'
.file: 'cmplStd/test/lang/init.member.ci:16'
.owner: RecordMemberTest
.value: 2
.usages:
	cmplStd/test/lang/init.member.ci:55: referenced as `memberInit`
}
RecordMemberTest.constantInit: int32 {
.kind: const variable(i32)
.base: `int32`
.size: 4
.name: 'constantInit'
.file: 'cmplStd/test/lang/init.member.ci:19'
.owner: RecordMemberTest
.value: 3
.usages:
	cmplStd/test/lang/init.member.ci:56: referenced as `constantInit`
}
RecordMemberTest.memberRec: RecordMemberTest.Inner {
.kind: variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'memberRec'
.file: 'cmplStd/test/lang/init.member.ci:22'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:58: referenced as `memberRec`
}
RecordMemberTest.constantRec: RecordMemberTest.Inner {
.kind: const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'constantRec'
.file: 'cmplStd/test/lang/init.member.ci:25'
.owner: RecordMemberTest
.usages:
	cmplStd/test/lang/init.member.ci:63: referenced as `constantRec`
}
RecordMemberTest.global: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.name: 'global'
.file: 'cmplStd/test/lang/init.member.ci:34'
.owner: RecordMemberTest
.usages:
}
RecordMemberTest.globalInit: int32 {
.kind: static variable(i32)
.base: `int32`
.size: 4
.name: 'globalInit'
.file: 'cmplStd/test/lang/init.member.ci:37'
.owner: RecordMemberTest
.value: 1
.usages:
}
RecordMemberTest.globalConstant: int32 {
.kind: static const variable(i32)
.base: `int32`
.size: 4
.name: 'globalConstant'
.file: 'cmplStd/test/lang/init.member.ci:40'
.owner: RecordMemberTest
.value: 2
.usages:
}
RecordMemberTest.globalRec: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalRec'
.file: 'cmplStd/test/lang/init.member.ci:43'
.owner: RecordMemberTest
.value: {
	globalRec.constant := 4;
	globalRec.member := (0);
}
.usages:
}
RecordMemberTest.globalRecInit: RecordMemberTest.Inner {
.kind: static variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalRecInit'
.file: 'cmplStd/test/lang/init.member.ci:46'
.owner: RecordMemberTest
.value: {
	globalRecInit.member := 4;
	globalRecInit.constant := 5;
}
.usages:
}
RecordMemberTest.globalConstantRec: RecordMemberTest.Inner {
.kind: static const variable(val)
.base: `RecordMemberTest.Inner`
.size: 8
.name: 'globalConstantRec'
.file: 'cmplStd/test/lang/init.member.ci:49'
.owner: RecordMemberTest
.value: {
	globalConstantRec.member := 6;
	globalConstantRec.constant := 7;
}
.usages:
}
recordMemberTest: RecordMemberTest {
.kind: variable(val)
.base: `RecordMemberTest`
.size: 32
.name: 'recordMemberTest'
.file: 'cmplStd/test/lang/init.member.ci:52'
.value: {
	recordMemberTest.member := 10;
	recordMemberTest.constant := 11;
	recordMemberTest.memberInit := 12;
	recordMemberTest.constantInit := 13;
	recordMemberTest.memberRec.member := 14;
	recordMemberTest.memberRec.constant := 15;
	recordMemberTest.constantRec.member := 16;
	recordMemberTest.constantRec.constant := 17;
}
.usages:
}
RecordMethodTest: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'RecordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:4'
.field staticMethod: function (size: 54, cast: static function)
.field forwardMethod: function (size: 4, cast: static variable(ref))
.field abstractMethod: function (size: 4, cast: variable(ref))
.field delegateMethod: function (size: 4, cast: variable(ref))
.field virtualMethod: function (size: 54, cast: static function)
.field virtualMethod: function (size: 4, cast: const variable(ref))
.field forwardMethod: function (size: 54, cast: static function)
.doc: 'static, virtual and abstract methods'
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:90: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:87: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:84: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:62: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:57: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:47: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:40: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:32: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:25: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:18: referenced as `RecordMethodTest`
	cmplStd/test/lang/init.method.ci:10: referenced as `RecordMethodTest`
}
RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:10'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'static method is like a `global function` hidden in a record
@see lang/function.ci'
.value: {
	trace("staticMethod", x);
}
.instructions: (54 bytes)
	cmplStd/test/lang/init.method.ci:11: (53 bytes): trace("staticMethod", x);
	<staticMethod>  : load.ref <?> ;int32
	<staticMethod+?>: load.sp(+8)
	<staticMethod+?>: load.c32 1
	<staticMethod+?>: load.sp(+4)
	<staticMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+?>: load.c32 11
	<staticMethod+?>: load.c32 14
	<staticMethod+?>: load.c32 128
	<staticMethod+?>: load.ref <?> ;"staticMethod"
	<staticMethod+?>: dup.x64 sp(5)
	<staticMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<staticMethod+?>: inc.sp(-16)
	<staticMethod+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:101: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:87: referenced as `staticMethod`
	cmplStd/test/lang/init.method.ci:78: referenced as `staticMethod`
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static variable(ref)
.base: `function`
.size: 4
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:18'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 0, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'static forward method is like a `forward function reference` hidden in a record
@see lang/function.ci'
.value: forwardMethod
.usages:
	cmplStd/test/lang/init.method.ci:32: referenced as `forwardMethod`
}
RecordMethodTest.abstractMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'abstractMethod'
.file: 'cmplStd/test/lang/init.method.ci:25'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 0, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'abstract methods must be overridden when inheriting or instantiating
the compiler sees it as a `constant function reference` without `default type initializer`
@see lang/member.ci'
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `abstractMethod`
}
RecordMethodTest.delegateMethod(this: RecordMethodTest, x: int32): void: function {
.kind: variable(ref)
.base: `function`
.size: 4
.name: 'delegateMethod'
.file: 'cmplStd/test/lang/init.method.ci:32'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 0, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'virtual method (use to delegate)
the compiler sees it as a `constant function reference` with `default field initializer`
@see lang/member.ci'
.value: forwardMethod
.usages:
	internal usages: 1
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: {
	trace("virtualMethod", x);
}
.instructions: (54 bytes)
	cmplStd/test/lang/init.method.ci:41: (53 bytes): trace("virtualMethod", x);
	<virtualMethod>  : load.ref <?> ;int32
	<virtualMethod+?>: load.sp(+8)
	<virtualMethod+?>: load.c32 1
	<virtualMethod+?>: load.sp(+4)
	<virtualMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+?>: load.c32 41
	<virtualMethod+?>: load.c32 14
	<virtualMethod+?>: load.c32 128
	<virtualMethod+?>: load.ref <?> ;"virtualMethod"
	<virtualMethod+?>: dup.x64 sp(5)
	<virtualMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<virtualMethod+?>: inc.sp(-16)
	<virtualMethod+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:102: referenced as `virtualMethod`
}
RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: const variable(ref)
.base: `function`
.size: 4
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:40'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'virtual methods can be overridden when inheriting or instantiating
the compiler will generate a static function and an instance member initialized with the static method
  * static void virtualMethod(...) { ... }
  * void virtualMethod(...) = [static] virtualMethod;'
.value: virtualMethod
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:93: referenced as `virtualMethod`
	cmplStd/test/lang/init.method.ci:79: referenced as `virtualMethod`
	internal usages: 1
}
RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'forwardMethod'
.file: 'cmplStd/test/lang/init.method.ci:47'
.owner: RecordMethodTest
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'static forward method implementation'
.value: {
	trace("forwardMethod", x);
}
.instructions: (54 bytes)
	cmplStd/test/lang/init.method.ci:48: (53 bytes): trace("forwardMethod", x);
	<forwardMethod>  : load.ref <?> ;int32
	<forwardMethod+?>: load.sp(+8)
	<forwardMethod+?>: load.c32 1
	<forwardMethod+?>: load.sp(+4)
	<forwardMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<forwardMethod+?>: load.c32 48
	<forwardMethod+?>: load.c32 14
	<forwardMethod+?>: load.c32 128
	<forwardMethod+?>: load.ref <?> ;"forwardMethod"
	<forwardMethod+?>: dup.x64 sp(5)
	<forwardMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<forwardMethod+?>: inc.sp(-16)
	<forwardMethod+?>: ret
.usages:
}
globalFunction(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 54
.name: 'globalFunction'
.file: 'cmplStd/test/lang/init.method.ci:57'
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.value: {
	trace("globalFunction", x);
}
.instructions: (54 bytes)
	cmplStd/test/lang/init.method.ci:58: (53 bytes): trace("globalFunction", x);
	<globalFunction>  : load.ref <?> ;int32
	<globalFunction+?>: load.sp(+8)
	<globalFunction+?>: load.c32 1
	<globalFunction+?>: load.sp(+4)
	<globalFunction+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<globalFunction+?>: load.c32 58
	<globalFunction+?>: load.c32 14
	<globalFunction+?>: load.c32 128
	<globalFunction+?>: load.ref <?> ;"globalFunction"
	<globalFunction+?>: dup.x64 sp(5)
	<globalFunction+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<globalFunction+?>: inc.sp(-16)
	<globalFunction+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:64: referenced as `globalFunction`
}
recordMethodTest: RecordMethodTest {
.kind: variable(val)
.base: `RecordMethodTest`
.size: 16
.name: 'recordMethodTest'
.file: 'cmplStd/test/lang/init.method.ci:62'
.doc: 'create an instance of the type '
.value: {
	recordMethodTest.abstractMethod := globalFunction;
	recordMethodTest.delegateMethod := forwardMethod;
	recordMethodTest.virtualMethod := virtualMethod;
}
.usages:
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:103: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:102: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:101: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:98: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:97: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:79: referenced as `recordMethodTest`
	cmplStd/test/lang/init.method.ci:78: referenced as `recordMethodTest`
}
staticMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 65
.name: 'staticMethod'
.file: 'cmplStd/test/lang/init.method.ci:84'
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.doc: 'extension function is defined, it has the highest priority.'
.value: {
	debug("extension.staticMethod");
	if ((this) != null) {
		RecordMethodTest.staticMethod(this, x);
	}
}
.instructions: (65 bytes)
	cmplStd/test/lang/init.method.ci:85: (36 bytes): debug("extension.staticMethod");
	<staticMethod>  : load.z32
	<staticMethod+?>: load.sp(+4)
	<staticMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<staticMethod+?>: load.c32 85
	<staticMethod+?>: load.c32 14
	<staticMethod+?>: load.z32
	<staticMethod+?>: load.ref <?> ;"extension.staticMethod"
	<staticMethod+?>: dup.x64 sp(5)
	<staticMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<staticMethod+?>: inc.sp(-8)
	cmplStd/test/lang/init.method.ci:86: (28 bytes): if ((this) != null)
	<staticMethod+?>: load.sp(+8)
	<staticMethod+?>: load.ref <?> ;null
	<staticMethod+?>: ceq.i32
	<staticMethod+?>: jnz +18
	cmplStd/test/lang/init.method.ci:87: (14 bytes): RecordMethodTest.staticMethod(this, x);
	<staticMethod+?>: dup.x128 sp(2)
	<staticMethod+?>: dup.x32 sp(5)
	<staticMethod+?>: load.ref <?> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<staticMethod+?>: call
	<staticMethod+?>: inc.sp(-20)
	<staticMethod+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:97: referenced as `staticMethod`
}
virtualMethod(this: RecordMethodTest, x: int32): void: function {
.kind: static function
.base: `function`
.size: 62
.name: 'virtualMethod'
.file: 'cmplStd/test/lang/init.method.ci:90'
.param .result: void (size: 0, cast: variable(void))
.param this: RecordMethodTest (size: 16, cast: variable(val))
.param x: int32 (size: 4, cast: variable(i32))
.value: {
	debug("extension.virtualMethod");
	if ((this) != null) {
		this.virtualMethod(this, x);
	}
}
.instructions: (62 bytes)
	cmplStd/test/lang/init.method.ci:91: (36 bytes): debug("extension.virtualMethod");
	<virtualMethod>  : load.z32
	<virtualMethod+?>: load.sp(+4)
	<virtualMethod+?>: load.ref <?> ;"cmplStd/test/lang/init.method.ci"
	<virtualMethod+?>: load.c32 91
	<virtualMethod+?>: load.c32 14
	<virtualMethod+?>: load.z32
	<virtualMethod+?>: load.ref <?> ;"extension.virtualMethod"
	<virtualMethod+?>: dup.x64 sp(5)
	<virtualMethod+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<virtualMethod+?>: inc.sp(-8)
	cmplStd/test/lang/init.method.ci:92: (25 bytes): if ((this) != null)
	<virtualMethod+?>: load.sp(+8)
	<virtualMethod+?>: load.ref <?> ;null
	<virtualMethod+?>: ceq.i32
	<virtualMethod+?>: jnz +15
	cmplStd/test/lang/init.method.ci:93: (11 bytes): this.virtualMethod(this, x);
	<virtualMethod+?>: dup.x128 sp(2)
	<virtualMethod+?>: dup.x32 sp(5)
	<virtualMethod+?>: dup.x32 sp(9)
	<virtualMethod+?>: call
	<virtualMethod+?>: inc.sp(-20)
	<virtualMethod+?>: ret
.usages:
	cmplStd/test/lang/init.method.ci:98: referenced as `virtualMethod`
}
rgbF32: typename {
.kind: static const typename(val)
.base: `typename`
.size: 16
.name: 'rgbF32'
.file: 'cmplStd/test/lang/recUnion.ci:2'
.field r: float32 (size: 4, cast: variable(f32))
.field g: float32 (size: 4, cast: variable(f32))
.field b: float32 (size: 4, cast: variable(f32))
.usages:
	cmplStd/test/lang/recUnion.ci:23: referenced as `rgbF32`
}
rgbF32.r: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:3'
.owner: rgbF32
.usages:
}
rgbF32.g: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:4'
.owner: rgbF32
.usages:
}
rgbF32.b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:5'
.owner: rgbF32
.usages:
}
rgbU8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 3
.name: 'rgbU8'
.file: 'cmplStd/test/lang/recUnion.ci:9'
.field b: uint8 (size: 1, cast: variable(u32))
.field g: uint8 (size: 1, cast: variable(u32))
.field r: uint8 (size: 1, cast: variable(u32))
.usages:
	cmplStd/test/lang/recUnion.ci:28: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:27: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:26: referenced as `rgbU8`
	cmplStd/test/lang/recUnion.ci:18: referenced as `rgbU8`
}
rgbU8.b: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'b'
.file: 'cmplStd/test/lang/recUnion.ci:10'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `b`
	cmplStd/test/lang/recUnion.ci:28: referenced as `b`
	cmplStd/test/lang/recUnion.ci:27: referenced as `b`
	cmplStd/test/lang/recUnion.ci:26: referenced as `b`
}
rgbU8.g: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'g'
.file: 'cmplStd/test/lang/recUnion.ci:11'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `g`
	cmplStd/test/lang/recUnion.ci:28: referenced as `g`
	cmplStd/test/lang/recUnion.ci:27: referenced as `g`
	cmplStd/test/lang/recUnion.ci:26: referenced as `g`
}
rgbU8.r: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'r'
.file: 'cmplStd/test/lang/recUnion.ci:12'
.owner: rgbU8
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `r`
	cmplStd/test/lang/recUnion.ci:28: referenced as `r`
	cmplStd/test/lang/recUnion.ci:27: referenced as `r`
	cmplStd/test/lang/recUnion.ci:26: referenced as `r`
}
color: typename {
.kind: static const typename(val)
.base: `typename`
.size: 4
.name: 'color'
.file: 'cmplStd/test/lang/recUnion.ci:16'
.field col: uint32 (size: 4, cast: variable(u32))
.field rgb: rgbU8 (size: 3, cast: variable(val))
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `color`
	cmplStd/test/lang/recUnion.ci:30: referenced as `color`
}
color.col: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'col'
.file: 'cmplStd/test/lang/recUnion.ci:17'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:30: referenced as `col`
}
color.rgb: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'rgb'
.file: 'cmplStd/test/lang/recUnion.ci:18'
.owner: color
.usages:
	cmplStd/test/lang/recUnion.ci:31: referenced as `rgb`
}
Color: object {
.kind: static const typename(ref)
.base: `object`
.size: 20
.name: 'Color'
.file: 'cmplStd/test/lang/recUnion.ci:22'
.field value: rgbF32 (size: 16, cast: variable(val))
.field .type: typename (size: 4, cast: const variable(ref))
.field create: function (size: 0, cast: static const inline)
.field destroy: function (size: 0, cast: static const inline)
.field as: function (size: 0, cast: static const inline)
.field type: function (size: 0, cast: static const inline)
.usages:
}
Color.value: rgbF32 {
.kind: variable(val)
.base: `rgbF32`
.size: 16
.name: 'value'
.file: 'cmplStd/test/lang/recUnion.ci:23'
.owner: Color
.usages:
}
black: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'black'
.file: 'cmplStd/test/lang/recUnion.ci:26'
.value: {
	black.r := (0);
	black.g := (0);
	black.b := (0);
}
.usages:
}
green: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'green'
.file: 'cmplStd/test/lang/recUnion.ci:27'
.value: {
	green.r := (0);
	green.g := (255);
	green.b := (0);
}
.usages:
}
white: rgbU8 {
.kind: variable(val)
.base: `rgbU8`
.size: 3
.name: 'white'
.file: 'cmplStd/test/lang/recUnion.ci:28'
.value: {
	white.r := (255);
	white.g := (255);
	white.b := (255);
}
.usages:
}
cyan: color {
.kind: variable(val)
.base: `color`
.size: 4
.name: 'cyan'
.file: 'cmplStd/test/lang/recUnion.ci:30'
.value: {
	cyan.col := (65535);
}
.usages:
}
blue: color {
.kind: variable(val)
.base: `color`
.size: 4
.name: 'blue'
.file: 'cmplStd/test/lang/recUnion.ci:31'
.value: {
	blue.rgb.r := (0);
	blue.rgb.g := (0);
	blue.rgb.b := (255);
}
.usages:
}
record_pack0: typename {
.kind: static const typename(val)
.base: `typename`
.size: 8
.name: 'record_pack0'
.file: 'cmplStd/test/lang/recPacking.ci:2'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack0._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:3'
.owner: record_pack0
.usages:
}
record_pack0.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:4'
.owner: record_pack0
.usages:
}
record_pack0._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:5'
.owner: record_pack0
.usages:
}
record_pack0.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:6'
.owner: record_pack0
.usages:
}
record_pack0._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:7'
.owner: record_pack0
.usages:
}
record_pack0.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:8'
.owner: record_pack0
.usages:
}
record_pack1: typename {
.kind: static const typename(val)
.base: `typename`
.size: 17
.name: 'record_pack1'
.file: 'cmplStd/test/lang/recPacking.ci:12'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack1._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:13'
.owner: record_pack1
.usages:
}
record_pack1.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:14'
.owner: record_pack1
.usages:
}
record_pack1._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:15'
.owner: record_pack1
.usages:
}
record_pack1.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:16'
.owner: record_pack1
.usages:
}
record_pack1._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:17'
.owner: record_pack1
.usages:
}
record_pack1.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:18'
.owner: record_pack1
.usages:
}
record_pack2: typename {
.kind: static const typename(val)
.base: `typename`
.size: 20
.name: 'record_pack2'
.file: 'cmplStd/test/lang/recPacking.ci:22'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack2._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:23'
.owner: record_pack2
.usages:
}
record_pack2.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:24'
.owner: record_pack2
.usages:
}
record_pack2._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:25'
.owner: record_pack2
.usages:
}
record_pack2.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:26'
.owner: record_pack2
.usages:
}
record_pack2._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:27'
.owner: record_pack2
.usages:
}
record_pack2.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:28'
.owner: record_pack2
.usages:
}
record_pack4: typename {
.kind: static const typename(val)
.base: `typename`
.size: 24
.name: 'record_pack4'
.file: 'cmplStd/test/lang/recPacking.ci:32'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack4._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:33'
.owner: record_pack4
.usages:
}
record_pack4.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:34'
.owner: record_pack4
.usages:
}
record_pack4._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:35'
.owner: record_pack4
.usages:
}
record_pack4.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:36'
.owner: record_pack4
.usages:
}
record_pack4._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:37'
.owner: record_pack4
.usages:
}
record_pack4.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:38'
.owner: record_pack4
.usages:
}
record_pack8: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'record_pack8'
.file: 'cmplStd/test/lang/recPacking.ci:42'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_pack8._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:43'
.owner: record_pack8
.usages:
}
record_pack8.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:44'
.owner: record_pack8
.usages:
}
record_pack8._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:45'
.owner: record_pack8
.usages:
}
record_pack8.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:46'
.owner: record_pack8
.usages:
}
record_pack8._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:47'
.owner: record_pack8
.usages:
}
record_pack8.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:48'
.owner: record_pack8
.usages:
}
record_packDef: typename {
.kind: static const typename(val)
.base: `typename`
.size: 32
.name: 'record_packDef'
.file: 'cmplStd/test/lang/recPacking.ci:52'
.field _0: uint8 (size: 1, cast: variable(u32))
.field a: uint64 (size: 8, cast: variable(u64))
.field _1: uint8 (size: 1, cast: variable(u32))
.field b: uint32 (size: 4, cast: variable(u32))
.field _2: uint8 (size: 1, cast: variable(u32))
.field c: uint16 (size: 2, cast: variable(u32))
.usages:
}
record_packDef._0: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_0'
.file: 'cmplStd/test/lang/recPacking.ci:53'
.owner: record_packDef
.usages:
}
record_packDef.a: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'a'
.file: 'cmplStd/test/lang/recPacking.ci:54'
.owner: record_packDef
.usages:
}
record_packDef._1: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_1'
.file: 'cmplStd/test/lang/recPacking.ci:55'
.owner: record_packDef
.usages:
}
record_packDef.b: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'b'
.file: 'cmplStd/test/lang/recPacking.ci:56'
.owner: record_packDef
.usages:
}
record_packDef._2: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: '_2'
.file: 'cmplStd/test/lang/recPacking.ci:57'
.owner: record_packDef
.usages:
}
record_packDef.c: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'c'
.file: 'cmplStd/test/lang/recPacking.ci:58'
.owner: record_packDef
.usages:
}
a: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'a'
.file: 'cmplStd/test/lang/useOperator.ci:3'
.value: 96.300000
.usages:
	cmplStd/test/lang/useOperator.ci:260: referenced as `a`
	cmplStd/test/lang/useOperator.ci:237: referenced as `a`
	cmplStd/test/lang/useOperator.ci:214: referenced as `a`
	cmplStd/test/lang/useOperator.ci:191: referenced as `a`
	cmplStd/test/lang/useOperator.ci:168: referenced as `a`
	cmplStd/test/lang/useOperator.ci:145: referenced as `a`
	cmplStd/test/lang/useOperator.ci:122: referenced as `a`
	cmplStd/test/lang/useOperator.ci:99: referenced as `a`
	cmplStd/test/lang/useOperator.ci:76: referenced as `a`
	cmplStd/test/lang/useOperator.ci:53: referenced as `a`
}
b: typename {
.kind: inline
.base: `typename`
.size: 0
.name: 'b'
.file: 'cmplStd/test/lang/useOperator.ci:4'
.value: 42.140000
.usages:
	cmplStd/test/lang/useOperator.ci:261: referenced as `b`
	cmplStd/test/lang/useOperator.ci:238: referenced as `b`
	cmplStd/test/lang/useOperator.ci:215: referenced as `b`
	cmplStd/test/lang/useOperator.ci:192: referenced as `b`
	cmplStd/test/lang/useOperator.ci:169: referenced as `b`
	cmplStd/test/lang/useOperator.ci:146: referenced as `b`
	cmplStd/test/lang/useOperator.ci:123: referenced as `b`
	cmplStd/test/lang/useOperator.ci:100: referenced as `b`
	cmplStd/test/lang/useOperator.ci:77: referenced as `b`
	cmplStd/test/lang/useOperator.ci:54: referenced as `b`
}
shift: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'shift'
.file: 'cmplStd/test/lang/useOperator.ci:5'
.value: 2
.usages:
	cmplStd/test/lang/useOperator.ci:284: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:228: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:227: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:205: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:204: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:182: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:181: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:159: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:158: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:136: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:135: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:113: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:112: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:90: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:89: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:67: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:66: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:44: referenced as `shift`
	cmplStd/test/lang/useOperator.ci:43: referenced as `shift`
}
boolA: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolA'
.file: 'cmplStd/test/lang/useOperator.ci:7'
.value: true
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolA`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolA`
}
boolB: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolB'
.file: 'cmplStd/test/lang/useOperator.ci:8'
.value: !false
.usages:
	cmplStd/test/lang/useOperator.ci:28: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:27: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:26: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:25: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:24: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:23: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:22: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:19: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:18: referenced as `boolB`
	cmplStd/test/lang/useOperator.ci:17: referenced as `boolB`
}
boolAnd: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolAnd'
.file: 'cmplStd/test/lang/useOperator.ci:17'
.value: boolA & boolB
.usages:
}
boolIor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolIor'
.file: 'cmplStd/test/lang/useOperator.ci:18'
.value: boolA | boolB
.usages:
}
boolXor: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolXor'
.file: 'cmplStd/test/lang/useOperator.ci:19'
.value: boolA ^ boolB
.usages:
}
boolNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolNot'
.file: 'cmplStd/test/lang/useOperator.ci:22'
.value: !boolB
.usages:
}
boolCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCeq'
.file: 'cmplStd/test/lang/useOperator.ci:23'
.value: boolA == boolB
.usages:
}
boolCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCne'
.file: 'cmplStd/test/lang/useOperator.ci:24'
.value: boolA != boolB
.usages:
}
boolClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolClt'
.file: 'cmplStd/test/lang/useOperator.ci:25'
.value: boolA < boolB
.usages:
}
boolCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCle'
.file: 'cmplStd/test/lang/useOperator.ci:26'
.value: boolA <= boolB
.usages:
}
boolCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCgt'
.file: 'cmplStd/test/lang/useOperator.ci:27'
.value: boolA > boolB
.usages:
}
boolCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'boolCge'
.file: 'cmplStd/test/lang/useOperator.ci:28'
.value: boolA >= boolB
.usages:
}
chrA: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrA'
.file: 'cmplStd/test/lang/useOperator.ci:30'
.value: 'a'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:44: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:43: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrA`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrA`
}
chrB: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrB'
.file: 'cmplStd/test/lang/useOperator.ci:31'
.value: 'b'
.usages:
	cmplStd/test/lang/useOperator.ci:51: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:50: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:49: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:48: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:47: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:46: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:45: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:42: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:41: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:40: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:39: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:38: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:37: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:36: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:35: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:34: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:33: referenced as `chrB`
	cmplStd/test/lang/useOperator.ci:32: referenced as `chrB`
}
chrPls: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrPls'
.file: 'cmplStd/test/lang/useOperator.ci:32'
.value: +chrB
.usages:
}
chrNeg: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrNeg'
.file: 'cmplStd/test/lang/useOperator.ci:33'
.value: -chrB
.usages:
}
chrCmt: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrCmt'
.file: 'cmplStd/test/lang/useOperator.ci:34'
.value: ~chrB
.usages:
}
chrAdd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrAdd'
.file: 'cmplStd/test/lang/useOperator.ci:35'
.value: chrA + chrB
.usages:
}
chrSub: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrSub'
.file: 'cmplStd/test/lang/useOperator.ci:36'
.value: chrA - chrB
.usages:
}
chrMul: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrMul'
.file: 'cmplStd/test/lang/useOperator.ci:37'
.value: chrA * chrB
.usages:
}
chrDiv: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrDiv'
.file: 'cmplStd/test/lang/useOperator.ci:38'
.value: chrA / chrB
.usages:
}
chrMod: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrMod'
.file: 'cmplStd/test/lang/useOperator.ci:39'
.value: chrA % chrB
.usages:
}
chrAnd: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrAnd'
.file: 'cmplStd/test/lang/useOperator.ci:40'
.value: chrA & chrB
.usages:
}
chrIor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrIor'
.file: 'cmplStd/test/lang/useOperator.ci:41'
.value: chrA | chrB
.usages:
}
chrXor: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrXor'
.file: 'cmplStd/test/lang/useOperator.ci:42'
.value: chrA ^ chrB
.usages:
}
chrShl: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrShl'
.file: 'cmplStd/test/lang/useOperator.ci:43'
.value: (chrA) << shift
.usages:
}
chrShr: char {
.kind: variable(i32)
.base: `char`
.size: 1
.name: 'chrShr'
.file: 'cmplStd/test/lang/useOperator.ci:44'
.value: (chrA) >> shift
.usages:
}
chrNot: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrNot'
.file: 'cmplStd/test/lang/useOperator.ci:45'
.value: !(chrB)
.usages:
}
chrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:46'
.value: chrA == chrB
.usages:
}
chrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCne'
.file: 'cmplStd/test/lang/useOperator.ci:47'
.value: chrA != chrB
.usages:
}
chrClt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrClt'
.file: 'cmplStd/test/lang/useOperator.ci:48'
.value: chrA < chrB
.usages:
}
chrCle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCle'
.file: 'cmplStd/test/lang/useOperator.ci:49'
.value: chrA <= chrB
.usages:
}
chrCgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCgt'
.file: 'cmplStd/test/lang/useOperator.ci:50'
.value: chrA > chrB
.usages:
}
chrCge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'chrCge'
.file: 'cmplStd/test/lang/useOperator.ci:51'
.value: chrA >= chrB
.usages:
}
i8A: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8A'
.file: 'cmplStd/test/lang/useOperator.ci:53'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:67: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:66: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8A`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8A`
}
i8B: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8B'
.file: 'cmplStd/test/lang/useOperator.ci:54'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:74: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:73: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:72: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:71: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:70: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:69: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:68: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:65: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:64: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:63: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:62: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:61: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:60: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:59: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:58: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:57: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:56: referenced as `i8B`
	cmplStd/test/lang/useOperator.ci:55: referenced as `i8B`
}
i8Pls: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:55'
.value: +i8B
.usages:
}
i8Neg: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:56'
.value: -i8B
.usages:
}
i8Cmt: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:57'
.value: ~i8B
.usages:
}
i8Add: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Add'
.file: 'cmplStd/test/lang/useOperator.ci:58'
.value: i8A + i8B
.usages:
}
i8Sub: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:59'
.value: i8A - i8B
.usages:
}
i8Mul: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:60'
.value: i8A * i8B
.usages:
}
i8Div: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Div'
.file: 'cmplStd/test/lang/useOperator.ci:61'
.value: i8A / i8B
.usages:
}
i8Mod: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:62'
.value: i8A % i8B
.usages:
}
i8And: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8And'
.file: 'cmplStd/test/lang/useOperator.ci:63'
.value: i8A & i8B
.usages:
}
i8Ior: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:64'
.value: i8A | i8B
.usages:
}
i8Xor: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:65'
.value: i8A ^ i8B
.usages:
}
i8Shl: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:66'
.value: (i8A) << shift
.usages:
}
i8Shr: int8 {
.kind: variable(i32)
.base: `int8`
.size: 1
.name: 'i8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:67'
.value: (i8A) >> shift
.usages:
}
i8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Not'
.file: 'cmplStd/test/lang/useOperator.ci:68'
.value: !(i8B)
.usages:
}
i8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:69'
.value: i8A == i8B
.usages:
}
i8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:70'
.value: i8A != i8B
.usages:
}
i8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:71'
.value: i8A < i8B
.usages:
}
i8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:72'
.value: i8A <= i8B
.usages:
}
i8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:73'
.value: i8A > i8B
.usages:
}
i8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:74'
.value: i8A >= i8B
.usages:
}
u8A: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8A'
.file: 'cmplStd/test/lang/useOperator.ci:76'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:90: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:89: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8A`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8A`
}
u8B: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8B'
.file: 'cmplStd/test/lang/useOperator.ci:77'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:97: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:96: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:95: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:94: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:93: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:92: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:91: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:88: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:87: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:86: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:85: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:84: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:83: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:82: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:81: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:80: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:79: referenced as `u8B`
	cmplStd/test/lang/useOperator.ci:78: referenced as `u8B`
}
u8Pls: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Pls'
.file: 'cmplStd/test/lang/useOperator.ci:78'
.value: +u8B
.usages:
}
u8Neg: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Neg'
.file: 'cmplStd/test/lang/useOperator.ci:79'
.value: -u8B
.usages:
}
u8Cmt: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:80'
.value: ~u8B
.usages:
}
u8Add: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Add'
.file: 'cmplStd/test/lang/useOperator.ci:81'
.value: u8A + u8B
.usages:
}
u8Sub: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Sub'
.file: 'cmplStd/test/lang/useOperator.ci:82'
.value: u8A - u8B
.usages:
}
u8Mul: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Mul'
.file: 'cmplStd/test/lang/useOperator.ci:83'
.value: u8A * u8B
.usages:
}
u8Div: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Div'
.file: 'cmplStd/test/lang/useOperator.ci:84'
.value: u8A / u8B
.usages:
}
u8Mod: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Mod'
.file: 'cmplStd/test/lang/useOperator.ci:85'
.value: u8A % u8B
.usages:
}
u8And: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8And'
.file: 'cmplStd/test/lang/useOperator.ci:86'
.value: u8A & u8B
.usages:
}
u8Ior: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Ior'
.file: 'cmplStd/test/lang/useOperator.ci:87'
.value: u8A | u8B
.usages:
}
u8Xor: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Xor'
.file: 'cmplStd/test/lang/useOperator.ci:88'
.value: u8A ^ u8B
.usages:
}
u8Shl: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Shl'
.file: 'cmplStd/test/lang/useOperator.ci:89'
.value: (u8A) << shift
.usages:
}
u8Shr: uint8 {
.kind: variable(u32)
.base: `uint8`
.size: 1
.name: 'u8Shr'
.file: 'cmplStd/test/lang/useOperator.ci:90'
.value: (u8A) >> shift
.usages:
}
u8Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Not'
.file: 'cmplStd/test/lang/useOperator.ci:91'
.value: !(u8B)
.usages:
}
u8Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:92'
.value: u8A == u8B
.usages:
}
u8Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cne'
.file: 'cmplStd/test/lang/useOperator.ci:93'
.value: u8A != u8B
.usages:
}
u8Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Clt'
.file: 'cmplStd/test/lang/useOperator.ci:94'
.value: u8A < u8B
.usages:
}
u8Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cle'
.file: 'cmplStd/test/lang/useOperator.ci:95'
.value: u8A <= u8B
.usages:
}
u8Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:96'
.value: u8A > u8B
.usages:
}
u8Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u8Cge'
.file: 'cmplStd/test/lang/useOperator.ci:97'
.value: u8A >= u8B
.usages:
}
i16A: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16A'
.file: 'cmplStd/test/lang/useOperator.ci:99'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:113: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:112: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16A`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16A`
}
i16B: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16B'
.file: 'cmplStd/test/lang/useOperator.ci:100'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:120: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:119: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:118: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:117: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:116: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:115: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:114: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:111: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:110: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:109: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:108: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:107: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:106: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:105: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:104: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:103: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:102: referenced as `i16B`
	cmplStd/test/lang/useOperator.ci:101: referenced as `i16B`
}
i16Pls: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:101'
.value: +i16B
.usages:
}
i16Neg: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:102'
.value: -i16B
.usages:
}
i16Cmt: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:103'
.value: ~i16B
.usages:
}
i16Add: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Add'
.file: 'cmplStd/test/lang/useOperator.ci:104'
.value: i16A + i16B
.usages:
}
i16Sub: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:105'
.value: i16A - i16B
.usages:
}
i16Mul: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:106'
.value: i16A * i16B
.usages:
}
i16Div: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Div'
.file: 'cmplStd/test/lang/useOperator.ci:107'
.value: i16A / i16B
.usages:
}
i16Mod: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:108'
.value: i16A % i16B
.usages:
}
i16And: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16And'
.file: 'cmplStd/test/lang/useOperator.ci:109'
.value: i16A & i16B
.usages:
}
i16Ior: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:110'
.value: i16A | i16B
.usages:
}
i16Xor: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:111'
.value: i16A ^ i16B
.usages:
}
i16Shl: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:112'
.value: (i16A) << shift
.usages:
}
i16Shr: int16 {
.kind: variable(i32)
.base: `int16`
.size: 2
.name: 'i16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:113'
.value: (i16A) >> shift
.usages:
}
i16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Not'
.file: 'cmplStd/test/lang/useOperator.ci:114'
.value: !(i16B)
.usages:
}
i16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:115'
.value: i16A == i16B
.usages:
}
i16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:116'
.value: i16A != i16B
.usages:
}
i16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:117'
.value: i16A < i16B
.usages:
}
i16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:118'
.value: i16A <= i16B
.usages:
}
i16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:119'
.value: i16A > i16B
.usages:
}
i16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:120'
.value: i16A >= i16B
.usages:
}
u16A: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16A'
.file: 'cmplStd/test/lang/useOperator.ci:122'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:136: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:135: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16A`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16A`
}
u16B: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16B'
.file: 'cmplStd/test/lang/useOperator.ci:123'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:143: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:142: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:141: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:140: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:139: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:138: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:137: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:134: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:133: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:132: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:131: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:130: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:129: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:128: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:127: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:126: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:125: referenced as `u16B`
	cmplStd/test/lang/useOperator.ci:124: referenced as `u16B`
}
u16Pls: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Pls'
.file: 'cmplStd/test/lang/useOperator.ci:124'
.value: +u16B
.usages:
}
u16Neg: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Neg'
.file: 'cmplStd/test/lang/useOperator.ci:125'
.value: -u16B
.usages:
}
u16Cmt: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:126'
.value: ~u16B
.usages:
}
u16Add: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Add'
.file: 'cmplStd/test/lang/useOperator.ci:127'
.value: u16A + u16B
.usages:
}
u16Sub: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Sub'
.file: 'cmplStd/test/lang/useOperator.ci:128'
.value: u16A - u16B
.usages:
}
u16Mul: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Mul'
.file: 'cmplStd/test/lang/useOperator.ci:129'
.value: u16A * u16B
.usages:
}
u16Div: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Div'
.file: 'cmplStd/test/lang/useOperator.ci:130'
.value: u16A / u16B
.usages:
}
u16Mod: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Mod'
.file: 'cmplStd/test/lang/useOperator.ci:131'
.value: u16A % u16B
.usages:
}
u16And: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16And'
.file: 'cmplStd/test/lang/useOperator.ci:132'
.value: u16A & u16B
.usages:
}
u16Ior: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Ior'
.file: 'cmplStd/test/lang/useOperator.ci:133'
.value: u16A | u16B
.usages:
}
u16Xor: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Xor'
.file: 'cmplStd/test/lang/useOperator.ci:134'
.value: u16A ^ u16B
.usages:
}
u16Shl: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Shl'
.file: 'cmplStd/test/lang/useOperator.ci:135'
.value: (u16A) << shift
.usages:
}
u16Shr: uint16 {
.kind: variable(u32)
.base: `uint16`
.size: 2
.name: 'u16Shr'
.file: 'cmplStd/test/lang/useOperator.ci:136'
.value: (u16A) >> shift
.usages:
}
u16Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Not'
.file: 'cmplStd/test/lang/useOperator.ci:137'
.value: !(u16B)
.usages:
}
u16Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:138'
.value: u16A == u16B
.usages:
}
u16Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cne'
.file: 'cmplStd/test/lang/useOperator.ci:139'
.value: u16A != u16B
.usages:
}
u16Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Clt'
.file: 'cmplStd/test/lang/useOperator.ci:140'
.value: u16A < u16B
.usages:
}
u16Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cle'
.file: 'cmplStd/test/lang/useOperator.ci:141'
.value: u16A <= u16B
.usages:
}
u16Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:142'
.value: u16A > u16B
.usages:
}
u16Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u16Cge'
.file: 'cmplStd/test/lang/useOperator.ci:143'
.value: u16A >= u16B
.usages:
}
i32A: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32A'
.file: 'cmplStd/test/lang/useOperator.ci:145'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:159: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:158: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32A`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32A`
}
i32B: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32B'
.file: 'cmplStd/test/lang/useOperator.ci:146'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:166: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:165: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:164: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:163: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:162: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:161: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:160: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:157: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:156: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:155: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:154: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:153: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:152: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:151: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:150: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:149: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:148: referenced as `i32B`
	cmplStd/test/lang/useOperator.ci:147: referenced as `i32B`
}
i32Pls: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:147'
.value: +i32B
.usages:
}
i32Neg: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:148'
.value: -i32B
.usages:
}
i32Cmt: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:149'
.value: ~i32B
.usages:
}
i32Add: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Add'
.file: 'cmplStd/test/lang/useOperator.ci:150'
.value: i32A + i32B
.usages:
}
i32Sub: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:151'
.value: i32A - i32B
.usages:
}
i32Mul: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:152'
.value: i32A * i32B
.usages:
}
i32Div: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Div'
.file: 'cmplStd/test/lang/useOperator.ci:153'
.value: i32A / i32B
.usages:
}
i32Mod: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:154'
.value: i32A % i32B
.usages:
}
i32And: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32And'
.file: 'cmplStd/test/lang/useOperator.ci:155'
.value: i32A & i32B
.usages:
}
i32Ior: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:156'
.value: i32A | i32B
.usages:
}
i32Xor: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:157'
.value: i32A ^ i32B
.usages:
}
i32Shl: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:158'
.value: i32A << shift
.usages:
}
i32Shr: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'i32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:159'
.value: i32A >> shift
.usages:
}
i32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Not'
.file: 'cmplStd/test/lang/useOperator.ci:160'
.value: !(i32B)
.usages:
}
i32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:161'
.value: i32A == i32B
.usages:
}
i32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:162'
.value: i32A != i32B
.usages:
}
i32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:163'
.value: i32A < i32B
.usages:
}
i32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:164'
.value: i32A <= i32B
.usages:
}
i32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:165'
.value: i32A > i32B
.usages:
}
i32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:166'
.value: i32A >= i32B
.usages:
}
u32A: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32A'
.file: 'cmplStd/test/lang/useOperator.ci:168'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:182: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:181: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32A`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32A`
}
u32B: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32B'
.file: 'cmplStd/test/lang/useOperator.ci:169'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:189: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:188: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:187: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:186: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:185: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:184: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:183: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:180: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:179: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:178: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:177: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:176: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:175: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:174: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:173: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:172: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:171: referenced as `u32B`
	cmplStd/test/lang/useOperator.ci:170: referenced as `u32B`
}
u32Pls: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:170'
.value: +u32B
.usages:
}
u32Neg: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:171'
.value: -u32B
.usages:
}
u32Cmt: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:172'
.value: ~u32B
.usages:
}
u32Add: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Add'
.file: 'cmplStd/test/lang/useOperator.ci:173'
.value: u32A + u32B
.usages:
}
u32Sub: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:174'
.value: u32A - u32B
.usages:
}
u32Mul: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:175'
.value: u32A * u32B
.usages:
}
u32Div: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Div'
.file: 'cmplStd/test/lang/useOperator.ci:176'
.value: u32A / u32B
.usages:
}
u32Mod: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:177'
.value: u32A % u32B
.usages:
}
u32And: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32And'
.file: 'cmplStd/test/lang/useOperator.ci:178'
.value: u32A & u32B
.usages:
}
u32Ior: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Ior'
.file: 'cmplStd/test/lang/useOperator.ci:179'
.value: u32A | u32B
.usages:
}
u32Xor: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Xor'
.file: 'cmplStd/test/lang/useOperator.ci:180'
.value: u32A ^ u32B
.usages:
}
u32Shl: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Shl'
.file: 'cmplStd/test/lang/useOperator.ci:181'
.value: u32A << shift
.usages:
}
u32Shr: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'u32Shr'
.file: 'cmplStd/test/lang/useOperator.ci:182'
.value: u32A >> shift
.usages:
}
u32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Not'
.file: 'cmplStd/test/lang/useOperator.ci:183'
.value: !(u32B)
.usages:
}
u32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:184'
.value: u32A == u32B
.usages:
}
u32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:185'
.value: u32A != u32B
.usages:
}
u32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:186'
.value: u32A < u32B
.usages:
}
u32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:187'
.value: u32A <= u32B
.usages:
}
u32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:188'
.value: u32A > u32B
.usages:
}
u32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:189'
.value: u32A >= u32B
.usages:
}
i64A: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64A'
.file: 'cmplStd/test/lang/useOperator.ci:191'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:205: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:204: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64A`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64A`
}
i64B: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64B'
.file: 'cmplStd/test/lang/useOperator.ci:192'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:212: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:211: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:210: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:209: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:208: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:207: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:206: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:203: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:202: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:201: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:200: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:199: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:198: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:197: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:196: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:195: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:194: referenced as `i64B`
	cmplStd/test/lang/useOperator.ci:193: referenced as `i64B`
}
i64Pls: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:193'
.value: +i64B
.usages:
}
i64Neg: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:194'
.value: -i64B
.usages:
}
i64Cmt: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:195'
.value: ~i64B
.usages:
}
i64Add: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Add'
.file: 'cmplStd/test/lang/useOperator.ci:196'
.value: i64A + i64B
.usages:
}
i64Sub: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:197'
.value: i64A - i64B
.usages:
}
i64Mul: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:198'
.value: i64A * i64B
.usages:
}
i64Div: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Div'
.file: 'cmplStd/test/lang/useOperator.ci:199'
.value: i64A / i64B
.usages:
}
i64Mod: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:200'
.value: i64A % i64B
.usages:
}
i64And: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64And'
.file: 'cmplStd/test/lang/useOperator.ci:201'
.value: i64A & i64B
.usages:
}
i64Ior: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:202'
.value: i64A | i64B
.usages:
}
i64Xor: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:203'
.value: i64A ^ i64B
.usages:
}
i64Shl: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:204'
.value: i64A << shift
.usages:
}
i64Shr: int64 {
.kind: variable(i64)
.base: `int64`
.size: 8
.name: 'i64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:205'
.value: i64A >> shift
.usages:
}
i64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Not'
.file: 'cmplStd/test/lang/useOperator.ci:206'
.value: !(i64B)
.usages:
}
i64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:207'
.value: i64A == i64B
.usages:
}
i64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:208'
.value: i64A != i64B
.usages:
}
i64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:209'
.value: i64A < i64B
.usages:
}
i64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:210'
.value: i64A <= i64B
.usages:
}
i64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:211'
.value: i64A > i64B
.usages:
}
i64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'i64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:212'
.value: i64A >= i64B
.usages:
}
u64A: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64A'
.file: 'cmplStd/test/lang/useOperator.ci:214'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:228: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:227: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64A`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64A`
}
u64B: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64B'
.file: 'cmplStd/test/lang/useOperator.ci:215'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:235: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:234: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:233: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:232: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:231: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:230: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:229: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:226: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:225: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:224: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:223: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:222: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:221: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:220: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:219: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:218: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:217: referenced as `u64B`
	cmplStd/test/lang/useOperator.ci:216: referenced as `u64B`
}
u64Pls: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:216'
.value: +u64B
.usages:
}
u64Neg: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:217'
.value: -u64B
.usages:
}
u64Cmt: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Cmt'
.file: 'cmplStd/test/lang/useOperator.ci:218'
.value: ~u64B
.usages:
}
u64Add: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Add'
.file: 'cmplStd/test/lang/useOperator.ci:219'
.value: u64A + u64B
.usages:
}
u64Sub: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:220'
.value: u64A - u64B
.usages:
}
u64Mul: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:221'
.value: u64A * u64B
.usages:
}
u64Div: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Div'
.file: 'cmplStd/test/lang/useOperator.ci:222'
.value: u64A / u64B
.usages:
}
u64Mod: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:223'
.value: u64A % u64B
.usages:
}
u64And: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64And'
.file: 'cmplStd/test/lang/useOperator.ci:224'
.value: u64A & u64B
.usages:
}
u64Ior: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Ior'
.file: 'cmplStd/test/lang/useOperator.ci:225'
.value: u64A | u64B
.usages:
}
u64Xor: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Xor'
.file: 'cmplStd/test/lang/useOperator.ci:226'
.value: u64A ^ u64B
.usages:
}
u64Shl: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Shl'
.file: 'cmplStd/test/lang/useOperator.ci:227'
.value: u64A << shift
.usages:
}
u64Shr: uint64 {
.kind: variable(u64)
.base: `uint64`
.size: 8
.name: 'u64Shr'
.file: 'cmplStd/test/lang/useOperator.ci:228'
.value: u64A >> shift
.usages:
}
u64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Not'
.file: 'cmplStd/test/lang/useOperator.ci:229'
.value: !(u64B)
.usages:
}
u64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:230'
.value: u64A == u64B
.usages:
}
u64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:231'
.value: u64A != u64B
.usages:
}
u64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:232'
.value: u64A < u64B
.usages:
}
u64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:233'
.value: u64A <= u64B
.usages:
}
u64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:234'
.value: u64A > u64B
.usages:
}
u64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'u64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:235'
.value: u64A >= u64B
.usages:
}
f32A: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32A'
.file: 'cmplStd/test/lang/useOperator.ci:237'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32A`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32A`
}
f32B: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32B'
.file: 'cmplStd/test/lang/useOperator.ci:238'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:258: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:257: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:256: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:255: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:254: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:253: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:252: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:246: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:245: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:244: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:243: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:242: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:240: referenced as `f32B`
	cmplStd/test/lang/useOperator.ci:239: referenced as `f32B`
}
f32Pls: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Pls'
.file: 'cmplStd/test/lang/useOperator.ci:239'
.value: +f32B
.usages:
}
f32Neg: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Neg'
.file: 'cmplStd/test/lang/useOperator.ci:240'
.value: -f32B
.usages:
}
f32Add: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Add'
.file: 'cmplStd/test/lang/useOperator.ci:242'
.value: f32A + f32B
.usages:
}
f32Sub: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Sub'
.file: 'cmplStd/test/lang/useOperator.ci:243'
.value: f32A - f32B
.usages:
}
f32Mul: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Mul'
.file: 'cmplStd/test/lang/useOperator.ci:244'
.value: f32A * f32B
.usages:
}
f32Div: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Div'
.file: 'cmplStd/test/lang/useOperator.ci:245'
.value: f32A / f32B
.usages:
}
f32Mod: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'f32Mod'
.file: 'cmplStd/test/lang/useOperator.ci:246'
.value: f32A % f32B
.usages:
}
f32Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Not'
.file: 'cmplStd/test/lang/useOperator.ci:252'
.value: !(f32B)
.usages:
}
f32Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:253'
.value: f32A == f32B
.usages:
}
f32Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cne'
.file: 'cmplStd/test/lang/useOperator.ci:254'
.value: f32A != f32B
.usages:
}
f32Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Clt'
.file: 'cmplStd/test/lang/useOperator.ci:255'
.value: f32A < f32B
.usages:
}
f32Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cle'
.file: 'cmplStd/test/lang/useOperator.ci:256'
.value: f32A <= f32B
.usages:
}
f32Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:257'
.value: f32A > f32B
.usages:
}
f32Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f32Cge'
.file: 'cmplStd/test/lang/useOperator.ci:258'
.value: f32A >= f32B
.usages:
}
f64A: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64A'
.file: 'cmplStd/test/lang/useOperator.ci:260'
.value: a
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64A`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64A`
}
f64B: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64B'
.file: 'cmplStd/test/lang/useOperator.ci:261'
.value: b
.usages:
	cmplStd/test/lang/useOperator.ci:281: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:280: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:279: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:278: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:277: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:276: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:275: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:269: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:268: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:267: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:266: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:265: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:263: referenced as `f64B`
	cmplStd/test/lang/useOperator.ci:262: referenced as `f64B`
}
f64Pls: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Pls'
.file: 'cmplStd/test/lang/useOperator.ci:262'
.value: +f64B
.usages:
}
f64Neg: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Neg'
.file: 'cmplStd/test/lang/useOperator.ci:263'
.value: -f64B
.usages:
}
f64Add: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Add'
.file: 'cmplStd/test/lang/useOperator.ci:265'
.value: f64A + f64B
.usages:
}
f64Sub: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Sub'
.file: 'cmplStd/test/lang/useOperator.ci:266'
.value: f64A - f64B
.usages:
}
f64Mul: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Mul'
.file: 'cmplStd/test/lang/useOperator.ci:267'
.value: f64A * f64B
.usages:
}
f64Div: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Div'
.file: 'cmplStd/test/lang/useOperator.ci:268'
.value: f64A / f64B
.usages:
}
f64Mod: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'f64Mod'
.file: 'cmplStd/test/lang/useOperator.ci:269'
.value: f64A % f64B
.usages:
}
f64Not: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Not'
.file: 'cmplStd/test/lang/useOperator.ci:275'
.value: !(f64B)
.usages:
}
f64Ceq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Ceq'
.file: 'cmplStd/test/lang/useOperator.ci:276'
.value: f64A == f64B
.usages:
}
f64Cne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cne'
.file: 'cmplStd/test/lang/useOperator.ci:277'
.value: f64A != f64B
.usages:
}
f64Clt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Clt'
.file: 'cmplStd/test/lang/useOperator.ci:278'
.value: f64A < f64B
.usages:
}
f64Cle: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cle'
.file: 'cmplStd/test/lang/useOperator.ci:279'
.value: f64A <= f64B
.usages:
}
f64Cgt: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cgt'
.file: 'cmplStd/test/lang/useOperator.ci:280'
.value: f64A > f64B
.usages:
}
f64Cge: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'f64Cge'
.file: 'cmplStd/test/lang/useOperator.ci:281'
.value: f64A >= f64B
.usages:
}
ptrA: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrA'
.file: 'cmplStd/test/lang/useOperator.ci:283'
.value: null
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrA`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrA`
}
ptrB: pointer {
.kind: variable(ref)
.base: `pointer`
.size: 4
.name: 'ptrB'
.file: 'cmplStd/test/lang/useOperator.ci:284'
.value: pointer(shift)
.usages:
	cmplStd/test/lang/useOperator.ci:300: referenced as `ptrB`
	cmplStd/test/lang/useOperator.ci:299: referenced as `ptrB`
}
ptrCeq: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'ptrCeq'
.file: 'cmplStd/test/lang/useOperator.ci:299'
.value: ptrA == ptrB
.usages:
}
ptrCne: bool {
.kind: variable(bool)
.base: `bool`
.size: 1
.name: 'ptrCne'
.file: 'cmplStd/test/lang/useOperator.ci:300'
.value: ptrA != ptrB
.usages:
}
t: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 't'
.file: 'cmplStd/test/lang/stmt.if.ci:26'
.value: 0
.usages:
	cmplStd/test/lang/stmt.if.ci:69: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:66: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:65: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:63: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:62: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:60: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:59: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:57: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:56: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:54: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:53: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:51: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:50: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:47: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:44: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:43: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:40: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:37: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:36: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:33: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:32: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:29: referenced as `t`
	cmplStd/test/lang/stmt.if.ci:28: referenced as `t`
}
forIdx: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'forIdx'
.file: 'cmplStd/test/lang/stmt.for.ci:12'
.usages:
	cmplStd/test/lang/stmt.for.ci:14: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
	cmplStd/test/lang/stmt.for.ci:13: referenced as `forIdx`
}
pi64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'pi64'
.file: 'cmplStd/test/math/test.Bits.ci:3'
.value: 3.141593
.usages:
	cmplStd/test/math/test.Bits.ci:44: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:43: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:43: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:42: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:42: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:39: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:38: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:37: referenced as `pi64`
	cmplStd/test/math/test.Bits.ci:6: referenced as `pi64`
}
e64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'e64'
.file: 'cmplStd/test/math/test.Bits.ci:4'
.value: 2.718282
.usages:
	cmplStd/test/math/test.Bits.ci:40: referenced as `e64`
	cmplStd/test/math/test.Bits.ci:40: referenced as `e64`
	cmplStd/test/math/test.Bits.ci:40: referenced as `e64`
	cmplStd/test/math/test.Bits.ci:7: referenced as `e64`
}
pi32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'pi32'
.file: 'cmplStd/test/math/test.Bits.ci:6'
.value: pi64
.usages:
	cmplStd/test/math/test.Bits.ci:53: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:52: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:52: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:51: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:51: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:48: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:47: referenced as `pi32`
	cmplStd/test/math/test.Bits.ci:46: referenced as `pi32`
}
e32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'e32'
.file: 'cmplStd/test/math/test.Bits.ci:7'
.value: e64
.usages:
	cmplStd/test/math/test.Bits.ci:49: referenced as `e32`
	cmplStd/test/math/test.Bits.ci:49: referenced as `e32`
	cmplStd/test/math/test.Bits.ci:49: referenced as `e32`
}
rgb888(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb888'
.file: 'cmplStd/test/math/test.Bits.ci:10'
.param .result: int32 (size: 4, cast: i32)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R8G8B8 color format'
.value: r << 16 & 16711680 | g << 8 & 65280 | b & 255
.usages:
	cmplStd/test/math/test.Bits.ci:19: referenced as `rgb888`
}
rgb565(r: int32, g: int32, b: int32): int32: function {
.kind: inline
.base: `function`
.size: 0
.name: 'rgb565'
.file: 'cmplStd/test/math/test.Bits.ci:12'
.param .result: int32 (size: 4, cast: i32)
.param r: int32 (size: 4, cast: i32)
.param g: int32 (size: 4, cast: i32)
.param b: int32 (size: 4, cast: i32)
.doc: 'pack 8 bit color components (0 .. 255) to R5G6B5 color format'
.value: r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31
.usages:
	cmplStd/test/math/test.Bits.ci:18: referenced as `rgb565`
}
r_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r_comp'
.file: 'cmplStd/test/math/test.Bits.ci:14'
.value: 14 << 3
.usages:
	cmplStd/test/math/test.Bits.ci:19: referenced as `r_comp`
	cmplStd/test/math/test.Bits.ci:18: referenced as `r_comp`
}
g_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'g_comp'
.file: 'cmplStd/test/math/test.Bits.ci:15'
.value: 63 << 2
.usages:
	cmplStd/test/math/test.Bits.ci:19: referenced as `g_comp`
	cmplStd/test/math/test.Bits.ci:18: referenced as `g_comp`
}
b_comp: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'b_comp'
.file: 'cmplStd/test/math/test.Bits.ci:16'
.value: 31 << 3
.usages:
	cmplStd/test/math/test.Bits.ci:19: referenced as `b_comp`
	cmplStd/test/math/test.Bits.ci:18: referenced as `b_comp`
}
r5g6b5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r5g6b5'
.file: 'cmplStd/test/math/test.Bits.ci:18'
.value: rgb565(r_comp, g_comp, b_comp)
.usages:
	cmplStd/test/math/test.Bits.ci:66: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:65: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:63: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:62: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:60: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:59: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:58: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:57: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:56: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:55: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:27: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:26: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:25: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:23: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:22: referenced as `r5g6b5`
	cmplStd/test/math/test.Bits.ci:21: referenced as `r5g6b5`
}
r8g8b8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'r8g8b8'
.file: 'cmplStd/test/math/test.Bits.ci:19'
.value: rgb888(r_comp, g_comp, b_comp)
.usages:
	cmplStd/test/math/test.Bits.ci:35: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:34: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:33: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:31: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:30: referenced as `r8g8b8`
	cmplStd/test/math/test.Bits.ci:29: referenced as `r8g8b8`
}
zxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtR5'
.file: 'cmplStd/test/math/test.Bits.ci:21'
.value: Bits.zxt32(r5g6b5, 11, 5)
.usages:
}
zxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtG6'
.file: 'cmplStd/test/math/test.Bits.ci:22'
.value: Bits.zxt32(r5g6b5, 5, 6)
.usages:
}
zxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtB5'
.file: 'cmplStd/test/math/test.Bits.ci:23'
.value: Bits.zxt32(r5g6b5, 0, 5)
.usages:
}
sxtR5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtR5'
.file: 'cmplStd/test/math/test.Bits.ci:25'
.value: Bits.sxt32(r5g6b5, 11, 5)
.usages:
}
sxtG6: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtG6'
.file: 'cmplStd/test/math/test.Bits.ci:26'
.value: Bits.sxt32(r5g6b5, 5, 6)
.usages:
}
sxtB5: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtB5'
.file: 'cmplStd/test/math/test.Bits.ci:27'
.value: Bits.sxt32(r5g6b5, 0, 5)
.usages:
}
zxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtR8'
.file: 'cmplStd/test/math/test.Bits.ci:29'
.value: Bits.zxt32(r8g8b8, 16, 8)
.usages:
}
zxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtG8'
.file: 'cmplStd/test/math/test.Bits.ci:30'
.value: Bits.zxt32(r8g8b8, 8, 8)
.usages:
}
zxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'zxtB8'
.file: 'cmplStd/test/math/test.Bits.ci:31'
.value: Bits.zxt32(r8g8b8, 0, 8)
.usages:
}
sxtR8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtR8'
.file: 'cmplStd/test/math/test.Bits.ci:33'
.value: Bits.sxt32(r8g8b8, 16, 8)
.usages:
}
sxtG8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtG8'
.file: 'cmplStd/test/math/test.Bits.ci:34'
.value: Bits.sxt32(r8g8b8, 8, 8)
.usages:
}
sxtB8: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'sxtB8'
.file: 'cmplStd/test/math/test.Bits.ci:35'
.value: Bits.sxt32(r8g8b8, 0, 8)
.usages:
}
testSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testSin_f64'
.file: 'cmplStd/test/math/test.Bits.ci:37'
.value: Math.sin(pi64 / (2))
.usages:
}
testCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testCos_f64'
.file: 'cmplStd/test/math/test.Bits.ci:38'
.value: Math.cos(pi64 / (2))
.usages:
}
testTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testTan_f64'
.file: 'cmplStd/test/math/test.Bits.ci:39'
.value: Math.tan(pi64 / (4))
.usages:
}
testLog_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testLog_f64'
.file: 'cmplStd/test/math/test.Bits.ci:40'
.value: Math.log(e64 * e64 * e64)
.usages:
}
testExp_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testExp_f64'
.file: 'cmplStd/test/math/test.Bits.ci:41'
.value: Math.exp(1.000000)
.usages:
}
testPow_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testPow_f64'
.file: 'cmplStd/test/math/test.Bits.ci:42'
.value: Math.pow(pi64 * pi64, 0.500000)
.usages:
}
testSqrt_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testSqrt_f64'
.file: 'cmplStd/test/math/test.Bits.ci:43'
.value: Math.sqrt(pi64 * pi64)
.usages:
}
testAtan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testAtan_f64'
.file: 'cmplStd/test/math/test.Bits.ci:44'
.value: Math.atan2(pi64, 1.000000)
.usages:
}
testSin_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testSin_f32'
.file: 'cmplStd/test/math/test.Bits.ci:46'
.value: Math.sin(pi32 / (2))
.usages:
}
testCos_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testCos_f32'
.file: 'cmplStd/test/math/test.Bits.ci:47'
.value: Math.cos(pi32 / (2))
.usages:
}
testTan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testTan_f32'
.file: 'cmplStd/test/math/test.Bits.ci:48'
.value: Math.tan(pi32 / (4))
.usages:
}
testLog_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testLog_f32'
.file: 'cmplStd/test/math/test.Bits.ci:49'
.value: Math.log(e32 * e32 * e32)
.usages:
}
testExp_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testExp_f32'
.file: 'cmplStd/test/math/test.Bits.ci:50'
.value: Math.exp(1.000000)
.usages:
}
testPow_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testPow_f32'
.file: 'cmplStd/test/math/test.Bits.ci:51'
.value: Math.pow(pi32 * pi32, 0.500000)
.usages:
}
testSqrt_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testSqrt_f32'
.file: 'cmplStd/test/math/test.Bits.ci:52'
.value: Math.sqrt(pi32 * pi32)
.usages:
}
testAtan_f32: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testAtan_f32'
.file: 'cmplStd/test/math/test.Bits.ci:53'
.value: Math.atan2(pi32, 1.000000)
.usages:
}
testPopulation_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testPopulation_u32'
.file: 'cmplStd/test/math/test.Bits.ci:55'
.value: Bits.countOnes(r5g6b5)
.usages:
}
testSwapBits_u32: uint32 {
.kind: variable(u32)
.base: `uint32`
.size: 4
.name: 'testSwapBits_u32'
.file: 'cmplStd/test/math/test.Bits.ci:56'
.value: Bits.swapBits(r5g6b5)
.usages:
}
testBitScanReverse_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testBitScanReverse_u32'
.file: 'cmplStd/test/math/test.Bits.ci:57'
.value: Bits.scanReverse(r5g6b5)
.usages:
}
testBitScanForward_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testBitScanForward_u32'
.file: 'cmplStd/test/math/test.Bits.ci:58'
.value: Bits.scanForward(r5g6b5)
.usages:
}
testHighBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testHighBit_u32'
.file: 'cmplStd/test/math/test.Bits.ci:59'
.value: Bits.keepMsb(r5g6b5)
.usages:
}
testLowBit_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testLowBit_u32'
.file: 'cmplStd/test/math/test.Bits.ci:60'
.value: Bits.keepLsb(r5g6b5)
.usages:
}
testZeroExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testZeroExtend_u32'
.file: 'cmplStd/test/math/test.Bits.ci:62'
.value: Bits.zxt32(r5g6b5, 0, 5)
.usages:
}
testSignExtend_u32: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testSignExtend_u32'
.file: 'cmplStd/test/math/test.Bits.ci:63'
.value: Bits.sxt32(r5g6b5, 0, 5)
.usages:
}
testZeroExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testZeroExtend_u64'
.file: 'cmplStd/test/math/test.Bits.ci:65'
.value: Bits.zxt64(r5g6b5, 0, 5)
.usages:
}
testSignExtend_u64: int32 {
.kind: variable(i32)
.base: `int32`
.size: 4
.name: 'testSignExtend_u64'
.file: 'cmplStd/test/math/test.Bits.ci:66'
.value: Bits.sxt64(r5g6b5, 0, 5)
.usages:
}
testMathFloor_pos_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_0'
.file: 'cmplStd/test/math/test.Math.ci:3'
.value: Math.floor(3.000000)
.usages:
}
testMathFloor_pos_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_2'
.file: 'cmplStd/test/math/test.Math.ci:4'
.value: Math.floor(3.200000)
.usages:
}
testMathFloor_pos_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_5'
.file: 'cmplStd/test/math/test.Math.ci:5'
.value: Math.floor(3.500000)
.usages:
}
testMathFloor_pos_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_7'
.file: 'cmplStd/test/math/test.Math.ci:6'
.value: Math.floor(3.700000)
.usages:
}
testMathFloor_pos_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_pos_3_9'
.file: 'cmplStd/test/math/test.Math.ci:7'
.value: Math.floor(3.900000)
.usages:
}
testMathFloor_neg_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_0'
.file: 'cmplStd/test/math/test.Math.ci:8'
.value: Math.floor(-3.000000)
.usages:
}
testMathFloor_neg_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_2'
.file: 'cmplStd/test/math/test.Math.ci:9'
.value: Math.floor(-3.200000)
.usages:
}
testMathFloor_neg_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_5'
.file: 'cmplStd/test/math/test.Math.ci:10'
.value: Math.floor(-3.500000)
.usages:
}
testMathFloor_neg_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_7'
.file: 'cmplStd/test/math/test.Math.ci:11'
.value: Math.floor(-3.700000)
.usages:
}
testMathFloor_neg_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathFloor_neg_3_9'
.file: 'cmplStd/test/math/test.Math.ci:12'
.value: Math.floor(-3.900000)
.usages:
}
testMathRound_pos_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_0'
.file: 'cmplStd/test/math/test.Math.ci:14'
.value: Math.round(3.000000)
.usages:
}
testMathRound_pos_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_2'
.file: 'cmplStd/test/math/test.Math.ci:15'
.value: Math.round(3.200000)
.usages:
}
testMathRound_pos_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_5'
.file: 'cmplStd/test/math/test.Math.ci:16'
.value: Math.round(3.500000)
.usages:
}
testMathRound_pos_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_7'
.file: 'cmplStd/test/math/test.Math.ci:17'
.value: Math.round(3.700000)
.usages:
}
testMathRound_pos_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_pos_3_9'
.file: 'cmplStd/test/math/test.Math.ci:18'
.value: Math.round(3.900000)
.usages:
}
testMathRound_neg_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_0'
.file: 'cmplStd/test/math/test.Math.ci:19'
.value: Math.round(-3.000000)
.usages:
}
testMathRound_neg_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_2'
.file: 'cmplStd/test/math/test.Math.ci:20'
.value: Math.round(-3.200000)
.usages:
}
testMathRound_neg_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_5'
.file: 'cmplStd/test/math/test.Math.ci:21'
.value: Math.round(-3.500000)
.usages:
}
testMathRound_neg_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_7'
.file: 'cmplStd/test/math/test.Math.ci:22'
.value: Math.round(-3.700000)
.usages:
}
testMathRound_neg_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathRound_neg_3_9'
.file: 'cmplStd/test/math/test.Math.ci:23'
.value: Math.round(-3.900000)
.usages:
}
testMathCeil_pos_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_0'
.file: 'cmplStd/test/math/test.Math.ci:25'
.value: Math.ceil(3.000000)
.usages:
}
testMathCeil_pos_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_2'
.file: 'cmplStd/test/math/test.Math.ci:26'
.value: Math.ceil(3.200000)
.usages:
}
testMathCeil_pos_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_5'
.file: 'cmplStd/test/math/test.Math.ci:27'
.value: Math.ceil(3.500000)
.usages:
}
testMathCeil_pos_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_7'
.file: 'cmplStd/test/math/test.Math.ci:28'
.value: Math.ceil(3.700000)
.usages:
}
testMathCeil_pos_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_pos_3_9'
.file: 'cmplStd/test/math/test.Math.ci:29'
.value: Math.ceil(3.900000)
.usages:
}
testMathCeil_neg_3_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_0'
.file: 'cmplStd/test/math/test.Math.ci:30'
.value: Math.ceil(-3.000000)
.usages:
}
testMathCeil_neg_3_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_2'
.file: 'cmplStd/test/math/test.Math.ci:31'
.value: Math.ceil(-3.200000)
.usages:
}
testMathCeil_neg_3_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_5'
.file: 'cmplStd/test/math/test.Math.ci:32'
.value: Math.ceil(-3.500000)
.usages:
}
testMathCeil_neg_3_7: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_7'
.file: 'cmplStd/test/math/test.Math.ci:33'
.value: Math.ceil(-3.700000)
.usages:
}
testMathCeil_neg_3_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCeil_neg_3_9'
.file: 'cmplStd/test/math/test.Math.ci:34'
.value: Math.ceil(-3.900000)
.usages:
}
testMathSign_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_1F'
.file: 'cmplStd/test/math/test.Math.ci:36'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_2F'
.file: 'cmplStd/test/math/test.Math.ci:37'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_3F'
.file: 'cmplStd/test/math/test.Math.ci:38'
.value: Math.sign(-0.900000)
.usages:
}
testMathSign_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_1f'
.file: 'cmplStd/test/math/test.Math.ci:39'
.value: Math.sign(0.200000)
.usages:
}
testMathSign_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_2f'
.file: 'cmplStd/test/math/test.Math.ci:40'
.value: Math.sign(0.000000)
.usages:
}
testMathSign_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSign_3f'
.file: 'cmplStd/test/math/test.Math.ci:41'
.value: Math.sign(-0.900000)
.usages:
}
testMathAbs_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_1F'
.file: 'cmplStd/test/math/test.Math.ci:43'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_2F'
.file: 'cmplStd/test/math/test.Math.ci:44'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_3F'
.file: 'cmplStd/test/math/test.Math.ci:45'
.value: Math.abs(-0.900000)
.usages:
}
testMathAbs_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_1f'
.file: 'cmplStd/test/math/test.Math.ci:46'
.value: Math.abs(0.200000)
.usages:
}
testMathAbs_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_2f'
.file: 'cmplStd/test/math/test.Math.ci:47'
.value: Math.abs(0.000000)
.usages:
}
testMathAbs_3f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbs_3f'
.file: 'cmplStd/test/math/test.Math.ci:48'
.value: Math.abs(-0.900000)
.usages:
}
testMathMin_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMin_1f'
.file: 'cmplStd/test/math/test.Math.ci:50'
.value: Math.min(1.000000, 2.000000)
.usages:
}
testMathMax_2f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMax_2f'
.file: 'cmplStd/test/math/test.Math.ci:51'
.value: Math.max(1.000000, 2.000000)
.usages:
}
testMathMin_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMin_1F'
.file: 'cmplStd/test/math/test.Math.ci:52'
.value: Math.min(1.000000, 2.000000)
.usages:
}
testMathMax_2F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMax_2F'
.file: 'cmplStd/test/math/test.Math.ci:53'
.value: Math.max(1.000000, 2.000000)
.usages:
}
testMathClamp_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathClamp_1f'
.file: 'cmplStd/test/math/test.Math.ci:55'
.value: Math.clamp(10.000000, 0.000000, 1.000000)
.usages:
}
testMathClamp_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathClamp_1F'
.file: 'cmplStd/test/math/test.Math.ci:56'
.value: Math.clamp(10.000000, 0.000000, 1.000000)
.usages:
}
testMathMix_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMix_1f'
.file: 'cmplStd/test/math/test.Math.ci:58'
.value: Math.mix(0.000000, 2.000000, 0.500000)
.usages:
}
testMathMix_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMix_1F'
.file: 'cmplStd/test/math/test.Math.ci:59'
.value: Math.mix(0.000000, 2.000000, 0.500000)
.usages:
}
testMathSmooth_1f: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSmooth_1f'
.file: 'cmplStd/test/math/test.Math.ci:61'
.value: Math.smoothstep(0.000000, 1.000000, 1.000000)
.usages:
}
testMathSmooth_1F: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSmooth_1F'
.file: 'cmplStd/test/math/test.Math.ci:62'
.value: Math.smoothstep(0.000000, 1.000000, 1.000000)
.usages:
}
testMathMin_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMin_nan'
.file: 'cmplStd/test/math/test.Math.ci:64'
.value: Math.min()
.usages:
}
testMathMin_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMin_1'
.file: 'cmplStd/test/math/test.Math.ci:65'
.value: Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6)
.usages:
}
testMathMax_nan: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMax_nan'
.file: 'cmplStd/test/math/test.Math.ci:66'
.value: Math.max()
.usages:
}
testMathMax_9: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathMax_9'
.file: 'cmplStd/test/math/test.Math.ci:67'
.value: Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6)
.usages:
}
testMathSum_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSum_0'
.file: 'cmplStd/test/math/test.Math.ci:69'
.value: Math.sum()
.usages:
}
testMathSum_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSum_1'
.file: 'cmplStd/test/math/test.Math.ci:70'
.value: Math.sum(1)
.usages:
}
testMathSum_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSum_3'
.file: 'cmplStd/test/math/test.Math.ci:71'
.value: Math.sum(1, 2)
.usages:
}
testMathSum_55: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSum_55'
.file: 'cmplStd/test/math/test.Math.ci:72'
.value: Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
.usages:
}
testMathEval_x: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_x'
.file: 'cmplStd/test/math/test.Math.ci:74'
.value: 10
.usages:
	cmplStd/test/math/test.Math.ci:81: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:80: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:79: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:78: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:77: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:76: referenced as `testMathEval_x`
	cmplStd/test/math/test.Math.ci:75: referenced as `testMathEval_x`
}
testMathEval_0: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_0'
.file: 'cmplStd/test/math/test.Math.ci:75'
.value: Math.eval(testMathEval_x)
.usages:
}
testMathEval_1: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_1'
.file: 'cmplStd/test/math/test.Math.ci:76'
.value: Math.eval(testMathEval_x, 1.000000)
.usages:
}
testMathEval_2: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_2'
.file: 'cmplStd/test/math/test.Math.ci:77'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000)
.usages:
}
testMathEval_3: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_3'
.file: 'cmplStd/test/math/test.Math.ci:78'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000)
.usages:
}
testMathEval_4: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_4'
.file: 'cmplStd/test/math/test.Math.ci:79'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000)
.usages:
}
testMathEval_5: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_5'
.file: 'cmplStd/test/math/test.Math.ci:80'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
.usages:
}
testMathEval_6: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathEval_6'
.file: 'cmplStd/test/math/test.Math.ci:81'
.value: Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
.usages:
}
testMathSin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSin_f64'
.file: 'cmplStd/test/math/test.Math.ci:83'
.value: Math.sin(Math.pi / (2))
.usages:
}
testMathCos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCos_f64'
.file: 'cmplStd/test/math/test.Math.ci:84'
.value: Math.cos(Math.pi / (2))
.usages:
}
testMathTan_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathTan_f64'
.file: 'cmplStd/test/math/test.Math.ci:85'
.value: Math.tan(Math.pi / (4))
.usages:
}
testMathSinh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathSinh_f64'
.file: 'cmplStd/test/math/test.Math.ci:86'
.value: Math.sinh(Math.pi / (2))
.usages:
}
testMathCosh_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathCosh_f64'
.file: 'cmplStd/test/math/test.Math.ci:87'
.value: Math.cosh(Math.pi / (2))
.usages:
}
testMathAsin_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAsin_f64'
.file: 'cmplStd/test/math/test.Math.ci:89'
.value: Math.asin(0.200000)
.usages:
}
testMathAcos_f64: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAcos_f64'
.file: 'cmplStd/test/math/test.Math.ci:90'
.value: Math.acos(0.200000)
.usages:
}
testMathAbsMod_f64_0a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_0a'
.file: 'cmplStd/test/math/test.Math.ci:93'
.value: Math.absMod(10.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_0b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_0b'
.file: 'cmplStd/test/math/test.Math.ci:94'
.value: Math.absMod(0.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_0c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_0c'
.file: 'cmplStd/test/math/test.Math.ci:95'
.value: Math.absMod(-10.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_9a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_9a'
.file: 'cmplStd/test/math/test.Math.ci:97'
.value: Math.absMod(19.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_9b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_9b'
.file: 'cmplStd/test/math/test.Math.ci:98'
.value: Math.absMod(9.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_9c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_9c'
.file: 'cmplStd/test/math/test.Math.ci:99'
.value: Math.absMod(-1.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_9d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_9d'
.file: 'cmplStd/test/math/test.Math.ci:100'
.value: Math.absMod(-11.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_8a: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_8a'
.file: 'cmplStd/test/math/test.Math.ci:102'
.value: Math.absMod(18.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_8b: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_8b'
.file: 'cmplStd/test/math/test.Math.ci:103'
.value: Math.absMod(8.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_8c: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_8c'
.file: 'cmplStd/test/math/test.Math.ci:104'
.value: Math.absMod(-2.000000, 10.000000)
.usages:
}
testMathAbsMod_f64_8d: float64 {
.kind: variable(f64)
.base: `float64`
.size: 8
.name: 'testMathAbsMod_f64_8d'
.file: 'cmplStd/test/math/test.Math.ci:105'
.value: Math.absMod(-12.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_0a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_0a'
.file: 'cmplStd/test/math/test.Math.ci:107'
.value: Math.absMod(10.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_0b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_0b'
.file: 'cmplStd/test/math/test.Math.ci:108'
.value: Math.absMod(0.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_0c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_0c'
.file: 'cmplStd/test/math/test.Math.ci:109'
.value: Math.absMod(-10.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_9a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_9a'
.file: 'cmplStd/test/math/test.Math.ci:111'
.value: Math.absMod(19.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_9b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_9b'
.file: 'cmplStd/test/math/test.Math.ci:112'
.value: Math.absMod(9.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_9c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_9c'
.file: 'cmplStd/test/math/test.Math.ci:113'
.value: Math.absMod(-1.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_9d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_9d'
.file: 'cmplStd/test/math/test.Math.ci:114'
.value: Math.absMod(-11.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_8a: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_8a'
.file: 'cmplStd/test/math/test.Math.ci:116'
.value: Math.absMod(18.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_8b: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_8b'
.file: 'cmplStd/test/math/test.Math.ci:117'
.value: Math.absMod(8.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_8c: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_8c'
.file: 'cmplStd/test/math/test.Math.ci:118'
.value: Math.absMod(-2.000000, 10.000000)
.usages:
}
testMathAbsMod_f32_8d: float32 {
.kind: variable(f32)
.base: `float32`
.size: 4
.name: 'testMathAbsMod_f32_8d'
.file: 'cmplStd/test/math/test.Math.ci:119'
.value: Math.absMod(-12.000000, 10.000000)
.usages:
}
Neg(a: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Neg'
.file: 'cmplStd/test/math/test.Complex.ci:3'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.value: Complex(-a.re, -a.im)
.usages:
	cmplStd/test/math/test.Complex.ci:11: referenced as `Neg`
}
Add(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Add'
.file: 'cmplStd/test/math/test.Complex.ci:4'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a.re + b.re, a.im + b.im)
.usages:
	cmplStd/test/math/test.Complex.ci:14: referenced as `Add`
}
Sub(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Sub'
.file: 'cmplStd/test/math/test.Complex.ci:5'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a.re - b.re, a.im - b.im)
.usages:
	cmplStd/test/math/test.Complex.ci:17: referenced as `Sub`
}
Mul(a: Complex, b: Complex): Complex: function {
.kind: inline
.base: `function`
.size: 0
.name: 'Mul'
.file: 'cmplStd/test/math/test.Complex.ci:6'
.param .result: Complex (size: 16, cast: val)
.param a: Complex (size: 16, cast: variable(val))
.param b: Complex (size: 16, cast: variable(val))
.value: Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re)
.usages:
	cmplStd/test/math/test.Complex.ci:20: referenced as `Mul`
}
valA: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'valA'
.file: 'cmplStd/test/math/test.Complex.ci:8'
.value: {
	valA.re := (9);
	valA.im := (2);
}
.usages:
	cmplStd/test/math/test.Complex.ci:21: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:20: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:18: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:17: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:15: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:14: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:12: referenced as `valA`
	cmplStd/test/math/test.Complex.ci:11: referenced as `valA`
}
valB: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'valB'
.file: 'cmplStd/test/math/test.Complex.ci:9'
.value: {
	valB.re := (2);
	valB.im := (3);
}
.usages:
	cmplStd/test/math/test.Complex.ci:21: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:20: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:18: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:17: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:15: referenced as `valB`
	cmplStd/test/math/test.Complex.ci:14: referenced as `valB`
}
Neg: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'Neg'
.file: 'cmplStd/test/math/test.Complex.ci:11'
.value: Neg(valA)
.usages:
}
neg: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'neg'
.file: 'cmplStd/test/math/test.Complex.ci:12'
.value: neg(valA)
.usages:
}
Add: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'Add'
.file: 'cmplStd/test/math/test.Complex.ci:14'
.value: Add(valA, valB)
.usages:
}
add: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'add'
.file: 'cmplStd/test/math/test.Complex.ci:15'
.value: add(valA, valB)
.usages:
}
Sub: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'Sub'
.file: 'cmplStd/test/math/test.Complex.ci:17'
.value: Sub(valA, valB)
.usages:
}
sub: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'sub'
.file: 'cmplStd/test/math/test.Complex.ci:18'
.value: sub(valA, valB)
.usages:
}
Mul: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'Mul'
.file: 'cmplStd/test/math/test.Complex.ci:20'
.value: Mul(valA, valB)
.usages:
}
mul: Complex {
.kind: variable(val)
.base: `Complex`
.size: 16
.name: 'mul'
.file: 'cmplStd/test/math/test.Complex.ci:21'
.value: mul(valA, valB)
.usages:
}
.main: function {
.kind: static function
.base: `function`
.size: 19799
.name: '.main'
.print: '.main'
.field typename: typename (size: 160, cast: static const typename(ref))
.field void: typename (size: 0, cast: static const typename(void))
.field bool: typename (size: 1, cast: static const typename(bool))
.field char: typename (size: 1, cast: static const typename(i32))
.field int8: typename (size: 1, cast: static const typename(i32))
.field int16: typename (size: 2, cast: static const typename(i32))
.field int32: typename (size: 4, cast: static const typename(i32))
.field int64: typename (size: 8, cast: static const typename(i64))
.field uint8: typename (size: 1, cast: static const typename(u32))
.field uint16: typename (size: 2, cast: static const typename(u32))
.field uint32: typename (size: 4, cast: static const typename(u32))
.field uint64: typename (size: 8, cast: static const typename(u64))
.field float32: typename (size: 4, cast: static const typename(f32))
.field float64: typename (size: 8, cast: static const typename(f64))
.field pointer: typename (size: 4, cast: static const typename(ref))
.field variant: typename (size: 8, cast: static const typename(var))
.field function: typename (size: 4, cast: static const typename(ref))
.field object: typename (size: 4, cast: static const typename(ref))
.field null: pointer (size: 0, cast: static const inline)
.field int: typename (size: 0, cast: static const inline)
.field .cstr: char (size: 4, cast: static const typename(arr))
.field emit: function (size: 0, cast: static const typename(void))
.field halt: function (size: 0, cast: static const inline)
.field preferNativeCalls: int64 (size: 0, cast: static const i64)
.field raise: function (size: 0, cast: static const inline)
.field tryExec: function (size: 0, cast: static const inline)
.field System: typename (size: 0, cast: static const typename(void))
.field true: bool (size: 0, cast: static const val)
.field false: bool (size: 0, cast: static const val)
.field byte: typename (size: 0, cast: inline)
.field float: typename (size: 0, cast: inline)
.field double: typename (size: 0, cast: inline)
.field sizeof: function (size: 0, cast: inline)
.field verbose: function (size: 0, cast: inline)
.field debug: function (size: 0, cast: inline)
.field trace: function (size: 0, cast: inline)
.field info: function (size: 0, cast: inline)
.field warn: function (size: 0, cast: inline)
.field error: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field abort: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field NotEquals: typename (size: 24, cast: static const typename(val))
.field NotEquals: function (size: 15, cast: static function)
.field abort: function (size: 0, cast: inline)
.field assert: function (size: 0, cast: inline)
.field assertEq: function (size: 118, cast: static function)
.field assertEq: function (size: 0, cast: inline)
.field inc: function (size: 0, cast: inline)
.field Bits: typename (size: 0, cast: static const typename(void))
.field Math: typename (size: 0, cast: static const typename(void))
.field Fixed: typename (size: 8, cast: static const typename(val))
.field Fixed: function (size: 0, cast: inline)
.field int32: function (size: 0, cast: inline)
.field Fixed: function (size: 95, cast: static function)
.field float64: function (size: 87, cast: static function)
.field Complex: typename (size: 16, cast: static const typename(val))
.field Complex: function (size: 7, cast: static function)
.field Complex: function (size: 7, cast: static function)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 139, cast: static function)
.field div: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field abs: function (size: 0, cast: inline)
.field arg: function (size: 0, cast: inline)
.field inv: function (size: 31, cast: static function)
.field conj: function (size: 0, cast: inline)
.field exp: function (size: 0, cast: inline)
.field log: function (size: 0, cast: inline)
.field pow: function (size: 151, cast: static function)
.field pow: function (size: 0, cast: inline)
.field sin: function (size: 0, cast: inline)
.field cos: function (size: 0, cast: inline)
.field tan: function (size: 0, cast: inline)
.field cot: function (size: 0, cast: inline)
.field sec: function (size: 0, cast: inline)
.field csc: function (size: 0, cast: inline)
.field sinh: function (size: 0, cast: inline)
.field cosh: function (size: 0, cast: inline)
.field tanh: function (size: 0, cast: inline)
.field coth: function (size: 0, cast: inline)
.field sech: function (size: 0, cast: inline)
.field csch: function (size: 0, cast: inline)
.field toCartesian: function (size: 0, cast: inline)
.field toPolar: function (size: 0, cast: inline)
.field vec4f: typename (size: 16, cast: static const typename(val))
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field vec4f: function (size: 0, cast: inline)
.field neg: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field abs: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field clamp: function (size: 0, cast: inline)
.field clamp: function (size: 0, cast: inline)
.field mix: function (size: 0, cast: inline)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field cross: function (size: 0, cast: inline)
.field length: function (size: 0, cast: inline)
.field normalize: function (size: 0, cast: inline)
.field eval: function (size: 0, cast: inline)
.field mat4f: typename (size: 64, cast: static const typename(val))
.field mat4f: function (size: 49, cast: static function)
.field mat4f: function (size: 21, cast: static function)
.field dp3: function (size: 0, cast: inline)
.field dph: function (size: 0, cast: inline)
.field dp4: function (size: 0, cast: inline)
.field transpose: function (size: 49, cast: static function)
.field mul: function (size: 265, cast: static function)
.field rotation: function (size: 491, cast: static function)
.field rotation: function (size: 243, cast: static function)
.field translation: function (size: 88, cast: static function)
.field scale: function (size: 217, cast: static function)
.field inverse: function (size: 632, cast: static function)
.field vec2d: typename (size: 16, cast: static const typename(val))
.field vec2d: function (size: 7, cast: static function)
.field add: function (size: 0, cast: inline)
.field sub: function (size: 0, cast: inline)
.field mul: function (size: 0, cast: inline)
.field div: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field ceq: function (size: 0, cast: inline)
.field dot: function (size: 0, cast: inline)
.field Timeunit: int64 (size: 8, cast: static const typename(ERR))
.field convert: function (size: 31, cast: static function)
.field convert: function (size: 33, cast: static function)
.field Duration: typename (size: 8, cast: static const typename(val))
.field Duration: function (size: 22, cast: static function)
.field Timestamp: typename (size: 8, cast: static const typename(val))
.field Timestamp: function (size: 22, cast: static function)
.field Timezone: typename (size: 16, cast: static const typename(val))
.field Month: uint8 (size: 1, cast: static const typename(ERR))
.field Month: function (size: 0, cast: inline)
.field indexOf: function (size: 0, cast: inline)
.field Weekday: uint8 (size: 1, cast: static const typename(ERR))
.field Weekday: function (size: 0, cast: inline)
.field indexOf: function (size: 0, cast: inline)
.field Calendar: uint8 (size: 1, cast: static const typename(ERR))
.field Datetime: typename (size: 40, cast: static const typename(val))
.field Timestamp: function (size: 626, cast: static function)
.field Datetime: function (size: 630, cast: static function)
.field Datetime: function (size: 0, cast: inline)
.field Datetime: function (size: 97, cast: static function)
.field Datetime: function (size: 55, cast: static function)
.field Datetime: function (size: 46, cast: static function)
.field Datetime: function (size: 43, cast: static function)
.field Datetime: function (size: 51, cast: static function)
.field length: function (size: 38, cast: static function)
.field indexOf: function (size: 50, cast: static function)
.field lastIndexOf: function (size: 50, cast: static function)
.field startsWith: function (size: 73, cast: static function)
.field endsWith: function (size: 126, cast: static function)
.field compare: function (size: 63, cast: static function)
.field ignCaseCmp: function (size: 36, cast: static function)
.field caseCmp: function (size: 14, cast: static function)
.field toHex: function (size: 0, cast: inline)
.field startsWith: function (size: 0, cast: inline)
.field endsWith: function (size: 0, cast: inline)
.field compare: function (size: 0, cast: inline)
.field equals: function (size: 0, cast: inline)
.field contains: function (size: 0, cast: inline)
.field float64: function (size: 423, cast: static function)
.field FormatFlags: typename (size: 16, cast: static const typename(val))
.field append: function (size: 119, cast: static function)
.field append: function (size: 687, cast: static function)
.field append: function (size: 121, cast: static function)
.field append: function (size: 649, cast: static function)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field append: function (size: 0, cast: inline)
.field DatetimeFormat: typename (size: 80, cast: static const typename(val))
.field format: function (size: 25, cast: static function)
.field append: function (size: 31, cast: static function)
.field Closeable: object (size: 8, cast: static const typename(ref))
.field ByteReader: Closeable (size: 12, cast: static const typename(ref))
.field ByteWriter: Closeable (size: 16, cast: static const typename(ref))
.field CopyReader: ByteReader (size: 20, cast: static const typename(ref))
.field ByteBuffer: typename (size: 40, cast: static const typename(val))
.field unicode: typename (size: 0, cast: inline)
.field TextReader: Closeable (size: 16, cast: static const typename(ref))
.field TextWriter: Closeable (size: 36, cast: static const typename(ref))
.field Base64Encoder: ByteWriter (size: 1060, cast: static const typename(ref))
.field Base64Decoder: ByteReader (size: 24, cast: static const typename(ref))
.field AsciiReader: TextReader (size: 16, cast: static const typename(ref))
.field AsciiWriter: TextWriter (size: 36, cast: static const typename(ref))
.field Utf8Reader: TextReader (size: 16, cast: static const typename(ref))
.field Utf8Writer: TextWriter (size: 36, cast: static const typename(ref))
.field Easing: typename (size: 0, cast: static const typename(void))
.field in: function (size: 29, cast: static function)
.field out: function (size: 49, cast: static function)
.field inOut: function (size: 118, cast: static function)
.field outIn: function (size: 118, cast: static function)
.field scalar: typename (size: 0, cast: inline)
.field Polynomial: TextWriter.Writeable (size: 20, cast: static const typename(ref))
.field Polynomial: function (size: 0, cast: inline)
.field Polynomial: function (size: 81, cast: static function)
.field integer: typename (size: 0, cast: inline)
.field emitldz32: int32 (size: 4, cast: variable(i32))
.field emitldz64: int64 (size: 8, cast: variable(i64))
.field emitA: int32 (size: 4, cast: variable(i32))
.field emitB: int32 (size: 4, cast: variable(i32))
.field emitAddI32: int32 (size: 4, cast: variable(i32))
.field emitDivI32: int32 (size: 4, cast: variable(i32))
.field emitNfcF32: float32 (size: 4, cast: variable(f32))
.field floatAsInt32: function (size: 0, cast: inline)
.field floatAsInt64: function (size: 0, cast: inline)
.field emitFloatAsInt1: int32 (size: 4, cast: variable(i32))
.field emitFloatAsInt2: int64 (size: 8, cast: variable(i64))
.field emitFloatAsInt3: int32 (size: 4, cast: variable(i32))
.field emitFloatAsInt4: int64 (size: 8, cast: variable(i64))
.field emitSlice: char[] (size: 8, cast: variable(arr))
.field zero: function (size: 0, cast: inline)
.field last: function (size: 0, cast: inline)
.field sum: function (size: 0, cast: inline)
.field any: function (size: 0, cast: inline)
.field min: function (size: 0, cast: inline)
.field max: function (size: 0, cast: inline)
.field i3: int32 (size: 4, cast: variable(i32))
.field i6: int32 (size: 4, cast: variable(i32))
.field i2: int32 (size: 4, cast: variable(i32))
.field i8: int32 (size: 4, cast: variable(i32))
.field zeroVal: int32 (size: 4, cast: variable(i32))
.field zeroVar: int32 (size: 4, cast: variable(i32))
.field zeroXpr: int32 (size: 4, cast: variable(i32))
.field lastVal: int32 (size: 4, cast: variable(i32))
.field lastVar: int32 (size: 4, cast: variable(i32))
.field lastXpr: int32 (size: 4, cast: variable(i32))
.field sum2Val: int32 (size: 4, cast: variable(i32))
.field sum2Var: int32 (size: 4, cast: variable(i32))
.field sum2Xpr: int32 (size: 4, cast: variable(i32))
.field any2Val: int32 (size: 4, cast: variable(i32))
.field any2Var: int32 (size: 4, cast: variable(i32))
.field any2Xpr: int32 (size: 4, cast: variable(i32))
.field min2Val: int32 (size: 4, cast: variable(i32))
.field min2Var: int32 (size: 4, cast: variable(i32))
.field min2Xpr: int32 (size: 4, cast: variable(i32))
.field max2Val: int32 (size: 4, cast: variable(i32))
.field max2Var: int32 (size: 4, cast: variable(i32))
.field max2Xpr: int32 (size: 4, cast: variable(i32))
.field sumLr: function (size: 0, cast: inline)
.field sumRl: function (size: 0, cast: inline)
.field sumRlVal: int32 (size: 4, cast: variable(i32))
.field sumLrVal: int32 (size: 4, cast: variable(i32))
.field sumRlVar: int32 (size: 4, cast: variable(i32))
.field sumLrVar: int32 (size: 4, cast: variable(i32))
.field sumRlXpr: int32 (size: 4, cast: variable(i32))
.field sumLrXpr: int32 (size: 4, cast: variable(i32))
.field anyLr: function (size: 0, cast: inline)
.field anyRl: function (size: 0, cast: inline)
.field anyRlVal: int32 (size: 4, cast: variable(i32))
.field anyLrVal: int32 (size: 4, cast: variable(i32))
.field anyRlVar: int32 (size: 4, cast: variable(i32))
.field anyLrVar: int32 (size: 4, cast: variable(i32))
.field anyRlXpr: int32 (size: 4, cast: variable(i32))
.field anyLrXpr: int32 (size: 4, cast: variable(i32))
.field minLr: function (size: 0, cast: inline)
.field minRl: function (size: 0, cast: inline)
.field minRlVal: int32 (size: 4, cast: variable(i32))
.field minLrVal: int32 (size: 4, cast: variable(i32))
.field minRlVar: int32 (size: 4, cast: variable(i32))
.field minLrVar: int32 (size: 4, cast: variable(i32))
.field minRlXpr: int32 (size: 4, cast: variable(i32))
.field minLrXpr: int32 (size: 4, cast: variable(i32))
.field maxLr: function (size: 0, cast: inline)
.field maxRl: function (size: 0, cast: inline)
.field maxRlVal: int32 (size: 4, cast: variable(i32))
.field maxLrVal: int32 (size: 4, cast: variable(i32))
.field maxRlVar: int32 (size: 4, cast: variable(i32))
.field maxLrVar: int32 (size: 4, cast: variable(i32))
.field maxRlXpr: int32 (size: 4, cast: variable(i32))
.field maxLrXpr: int32 (size: 4, cast: variable(i32))
.field overload: typename (size: 0, cast: inline)
.field overload: function (size: 0, cast: inline)
.field overload: function (size: 0, cast: inline)
.field overload: function (size: 0, cast: inline)
.field overload: function (size: 0, cast: inline)
.field overload1: float32 (size: 4, cast: variable(f32))
.field overload2: float32 (size: 4, cast: variable(f32))
.field overload3: float32 (size: 4, cast: variable(f32))
.field overload4: float32 (size: 4, cast: variable(f32))
.field overload5: float32 (size: 4, cast: variable(f32))
.field Celsius: typename (size: 8, cast: static const typename(val))
.field Fahrenheit: typename (size: 8, cast: static const typename(val))
.field Celsius: function (size: 0, cast: inline)
.field Fahrenheit: function (size: 0, cast: inline)
.field Celsius: function (size: 0, cast: inline)
.field Fahrenheit: function (size: 0, cast: inline)
.field boilC: Celsius (size: 8, cast: variable(val))
.field boilF: Fahrenheit (size: 8, cast: variable(val))
.field realloc: function (size: 0, cast: inline)
.field malloc: function (size: 0, cast: inline)
.field free: function (size: 0, cast: inline)
.field p1: pointer (size: 4, cast: variable(ref))
.field p2: pointer (size: 4, cast: variable(ref))
.field p3: pointer (size: 4, cast: variable(ref))
.field p4: pointer (size: 4, cast: variable(ref))
.field val1: int64 (size: 8, cast: variable(i64))
.field val2: int64 (size: 8, cast: variable(i64))
.field noError: function (size: 1, cast: static function)
.field stackOverflow: function (size: 24, cast: static function)
.field divisionByZero: function (size: 12, cast: static function)
.field abortExecution: function (size: 83, cast: static function)
.field invalidMemoryAccess: function (size: 13, cast: static function)
.field invalidInstruction: function (size: 2, cast: static function)
.field tryExecErr0: int32 (size: 4, cast: variable(i32))
.field tryExecErr1: int32 (size: 4, cast: variable(i32))
.field tryExecErr2: int32 (size: 4, cast: variable(i32))
.field tryExecErr3: int32 (size: 4, cast: variable(i32))
.field tryExecErr4: int32 (size: 4, cast: variable(i32))
.field tryExecErr5: int32 (size: 4, cast: variable(i32))
.field tryExecErr6: int32 (size: 4, cast: variable(i32))
.field arr: int32[5] (size: 20, cast: variable(val))
.field ptr: pointer (size: 4, cast: variable(ref))
.field a0: int32 (size: 4, cast: variable(ref))
.field a1: int32 (size: 4, cast: variable(ref))
.field a2: int32 (size: 4, cast: variable(ref))
.field a3: int32 (size: 4, cast: variable(ref))
.field a4: int32 (size: 4, cast: variable(ref))
.field value: int64 (size: 8, cast: static variable(i64))
.field valueRef: int64 (size: 4, cast: variable(ref))
.field valuePtr: pointer (size: 4, cast: variable(ref))
.field valueVar: variant (size: 8, cast: variable(var))
.field fromRef: int64 (size: 8, cast: variable(i64))
.field fromPtr: int64 (size: 4, cast: variable(ref))
.field fromVar: int64 (size: 4, cast: variable(ref))
.field nullRef: int64 (size: 4, cast: variable(ref))
.field nullPtr: pointer (size: 4, cast: variable(ref))
.field nullVar: variant (size: 8, cast: variable(var))
.field nullTyp: typename (size: 4, cast: variable(ref))
.field nullFun: function (size: 4, cast: variable(ref))
.field nullObj: object (size: 4, cast: variable(ref))
.field typePtr: pointer (size: 4, cast: variable(ref))
.field typeVar: variant (size: 8, cast: variable(var))
.field typeTyp: typename (size: 4, cast: variable(ref))
.field local: int64 (size: 8, cast: variable(i64))
.field copyVal: int64 (size: 8, cast: variable(i64))
.field copyRef: int64 (size: 4, cast: variable(ref))
.field copyPtr: pointer (size: 4, cast: variable(ref))
.field copyVar: variant (size: 8, cast: variable(var))
.field copyTyp: typename (size: 4, cast: variable(ref))
.field ptrVoid: pointer (size: 4, cast: variable(ref))
.field ptrBool: pointer (size: 4, cast: variable(ref))
.field ptrChar: pointer (size: 4, cast: variable(ref))
.field ptrInt8: pointer (size: 4, cast: variable(ref))
.field ptrInt16: pointer (size: 4, cast: variable(ref))
.field ptrInt32: pointer (size: 4, cast: variable(ref))
.field ptrInt64: pointer (size: 4, cast: variable(ref))
.field ptrUint8: pointer (size: 4, cast: variable(ref))
.field ptrUint16: pointer (size: 4, cast: variable(ref))
.field ptrUint32: pointer (size: 4, cast: variable(ref))
.field ptrUint64: pointer (size: 4, cast: variable(ref))
.field ptrFloat32: pointer (size: 4, cast: variable(ref))
.field ptrFloat64: pointer (size: 4, cast: variable(ref))
.field ptrTypename: pointer (size: 4, cast: variable(ref))
.field ptrFunction: pointer (size: 4, cast: variable(ref))
.field ptrPointer: pointer (size: 4, cast: variable(ref))
.field ptrVariant: pointer (size: 4, cast: variable(ref))
.field ptrObject: pointer (size: 4, cast: variable(ref))
.field varVoid: variant (size: 8, cast: variable(var))
.field varBool: variant (size: 8, cast: variable(var))
.field varChar: variant (size: 8, cast: variable(var))
.field varInt8: variant (size: 8, cast: variable(var))
.field varInt16: variant (size: 8, cast: variable(var))
.field varInt32: variant (size: 8, cast: variable(var))
.field varInt64: variant (size: 8, cast: variable(var))
.field varUint8: variant (size: 8, cast: variable(var))
.field varUint16: variant (size: 8, cast: variable(var))
.field varUint32: variant (size: 8, cast: variable(var))
.field varUint64: variant (size: 8, cast: variable(var))
.field varFloat32: variant (size: 8, cast: variable(var))
.field varFloat64: variant (size: 8, cast: variable(var))
.field varTypename: variant (size: 8, cast: variable(var))
.field varFunction: variant (size: 8, cast: variable(var))
.field varPointer: variant (size: 8, cast: variable(var))
.field varVariant: variant (size: 8, cast: variable(var))
.field varObject: variant (size: 8, cast: variable(var))
.field typVoid: typename (size: 4, cast: variable(ref))
.field typBool: typename (size: 4, cast: variable(ref))
.field typChar: typename (size: 4, cast: variable(ref))
.field typInt8: typename (size: 4, cast: variable(ref))
.field typInt16: typename (size: 4, cast: variable(ref))
.field typInt32: typename (size: 4, cast: variable(ref))
.field typInt64: typename (size: 4, cast: variable(ref))
.field typUint8: typename (size: 4, cast: variable(ref))
.field typUint16: typename (size: 4, cast: variable(ref))
.field typUint32: typename (size: 4, cast: variable(ref))
.field typUint64: typename (size: 4, cast: variable(ref))
.field typFloat32: typename (size: 4, cast: variable(ref))
.field typFloat64: typename (size: 4, cast: variable(ref))
.field typTypename: typename (size: 4, cast: variable(ref))
.field typFunction: typename (size: 4, cast: variable(ref))
.field typPointer: typename (size: 4, cast: variable(ref))
.field typVariant: typename (size: 4, cast: variable(ref))
.field typObject: typename (size: 4, cast: variable(ref))
.field valueOfPtr: pointer (size: 4, cast: variable(ref))
.field valueOfVar: variant (size: 8, cast: variable(var))
.field valueOfTyp: typename (size: 4, cast: variable(ref))
.field typeOfValue: typename (size: 4, cast: variable(ref))
.field copyPtrFloat64: variant (size: 8, cast: variable(var))
.field copyVarFloat64: pointer (size: 4, cast: variable(ref))
.field variable: int32 (size: 4, cast: variable(i32))
.field constant: int32 (size: 4, cast: const variable(i32))
.field ComplexVal: typename (size: 16, cast: static const typename(val))
.field ComplexObj: object (size: 20, cast: static const typename(ref))
.field valInitImplicit: ComplexVal (size: 16, cast: variable(val))
.field objInitImplicit: ComplexObj (size: 4, cast: variable(ref))
.field objInitExplicit: object (size: 4, cast: variable(ref))
.field empty: function (size: 1, cast: static function)
.field funAdd: function (size: 8, cast: static function)
.field funAddResult: int32 (size: 4, cast: variable(i32))
.field funAddRef: function (size: 4, cast: variable(ref))
.field funAddRefResult: int32 (size: 4, cast: variable(i32))
.field funMul: function (size: 4, cast: variable(ref))
.field funMulResult: int32 (size: 4, cast: variable(i32))
.field funMulRef: function (size: 4, cast: variable(ref))
.field funMulRefResult: int32 (size: 4, cast: variable(i32))
.field funMul: function (size: 8, cast: static function)
.field fib: function (size: 54, cast: static function)
.field fibonacci_13: uint32 (size: 4, cast: variable(u32))
.field sizeofVoid: int32 (size: 4, cast: variable(i32))
.field sizeofBool: int32 (size: 4, cast: variable(i32))
.field sizeofChar: int32 (size: 4, cast: variable(i32))
.field sizeofInt8: int32 (size: 4, cast: variable(i32))
.field sizeofInt16: int32 (size: 4, cast: variable(i32))
.field sizeofInt32: int32 (size: 4, cast: variable(i32))
.field sizeofInt64: int32 (size: 4, cast: variable(i32))
.field sizeofUint8: int32 (size: 4, cast: variable(i32))
.field sizeofUint16: int32 (size: 4, cast: variable(i32))
.field sizeofUint32: int32 (size: 4, cast: variable(i32))
.field sizeofUint64: int32 (size: 4, cast: variable(i32))
.field sizeofFloat32: int32 (size: 4, cast: variable(i32))
.field sizeofFloat64: int32 (size: 4, cast: variable(i32))
.field sizeofPointer: int32 (size: 4, cast: variable(i32))
.field sizeofVariant: int32 (size: 4, cast: variable(i32))
.field sizeofTypename: int32 (size: 4, cast: variable(i32))
.field sizeofFunction: int32 (size: 4, cast: variable(i32))
.field sizeofObject: int32 (size: 4, cast: variable(i32))
.field RecordSizeof: object (size: 12, cast: static const typename(ref))
.field RecordSizeofExt: RecordSizeof (size: 16, cast: static const typename(ref))
.field typeofRecord: typename (size: 4, cast: variable(ref))
.field nameOfRecord: char[*] (size: 4, cast: variable(ref))
.field offsetOfRecord: int32 (size: 4, cast: variable(i32))
.field sizeOfRecord: int32 (size: 4, cast: variable(i32))
.field fileOfRecord: char[*] (size: 4, cast: variable(ref))
.field lineOfRecord: int32 (size: 4, cast: variable(i32))
.field typeofBase: typename (size: 4, cast: variable(ref))
.field nameOfBase: char[*] (size: 4, cast: variable(ref))
.field offsetOfBase: int32 (size: 4, cast: variable(i32))
.field sizeOfBase: int32 (size: 4, cast: variable(i32))
.field fileOfBase: char[*] (size: 4, cast: variable(ref))
.field lineOfBase: int32 (size: 4, cast: variable(i32))
.field typeofBase1: typename (size: 4, cast: variable(ref))
.field offsetOfBase1: int32 (size: 4, cast: variable(i32))
.field sizeOfBase1: int32 (size: 4, cast: variable(i32))
.field typeofBase2: typename (size: 4, cast: variable(ref))
.field offsetOfBase2: int32 (size: 4, cast: variable(i32))
.field sizeOfBase2: int32 (size: 4, cast: variable(i32))
.field RecordMemberTest: typename (size: 32, cast: static const typename(val))
.field recordMemberTest: RecordMemberTest (size: 32, cast: variable(val))
.field RecordMethodTest: typename (size: 16, cast: static const typename(val))
.field globalFunction: function (size: 54, cast: static function)
.field recordMethodTest: RecordMethodTest (size: 16, cast: variable(val))
.field staticMethod: function (size: 65, cast: static function)
.field virtualMethod: function (size: 62, cast: static function)
.field rgbF32: typename (size: 16, cast: static const typename(val))
.field rgbU8: typename (size: 3, cast: static const typename(val))
.field color: typename (size: 4, cast: static const typename(val))
.field Color: object (size: 20, cast: static const typename(ref))
.field black: rgbU8 (size: 3, cast: variable(val))
.field green: rgbU8 (size: 3, cast: variable(val))
.field white: rgbU8 (size: 3, cast: variable(val))
.field cyan: color (size: 4, cast: variable(val))
.field blue: color (size: 4, cast: variable(val))
.field record_pack0: typename (size: 8, cast: static const typename(val))
.field record_pack1: typename (size: 17, cast: static const typename(val))
.field record_pack2: typename (size: 20, cast: static const typename(val))
.field record_pack4: typename (size: 24, cast: static const typename(val))
.field record_pack8: typename (size: 32, cast: static const typename(val))
.field record_packDef: typename (size: 32, cast: static const typename(val))
.field a: typename (size: 0, cast: inline)
.field b: typename (size: 0, cast: inline)
.field shift: int32 (size: 4, cast: variable(i32))
.field boolA: bool (size: 1, cast: variable(bool))
.field boolB: bool (size: 1, cast: variable(bool))
.field boolAnd: bool (size: 1, cast: variable(bool))
.field boolIor: bool (size: 1, cast: variable(bool))
.field boolXor: bool (size: 1, cast: variable(bool))
.field boolNot: bool (size: 1, cast: variable(bool))
.field boolCeq: bool (size: 1, cast: variable(bool))
.field boolCne: bool (size: 1, cast: variable(bool))
.field boolClt: bool (size: 1, cast: variable(bool))
.field boolCle: bool (size: 1, cast: variable(bool))
.field boolCgt: bool (size: 1, cast: variable(bool))
.field boolCge: bool (size: 1, cast: variable(bool))
.field chrA: char (size: 1, cast: variable(i32))
.field chrB: char (size: 1, cast: variable(i32))
.field chrPls: char (size: 1, cast: variable(i32))
.field chrNeg: char (size: 1, cast: variable(i32))
.field chrCmt: char (size: 1, cast: variable(i32))
.field chrAdd: char (size: 1, cast: variable(i32))
.field chrSub: char (size: 1, cast: variable(i32))
.field chrMul: char (size: 1, cast: variable(i32))
.field chrDiv: char (size: 1, cast: variable(i32))
.field chrMod: char (size: 1, cast: variable(i32))
.field chrAnd: char (size: 1, cast: variable(i32))
.field chrIor: char (size: 1, cast: variable(i32))
.field chrXor: char (size: 1, cast: variable(i32))
.field chrShl: char (size: 1, cast: variable(i32))
.field chrShr: char (size: 1, cast: variable(i32))
.field chrNot: bool (size: 1, cast: variable(bool))
.field chrCeq: bool (size: 1, cast: variable(bool))
.field chrCne: bool (size: 1, cast: variable(bool))
.field chrClt: bool (size: 1, cast: variable(bool))
.field chrCle: bool (size: 1, cast: variable(bool))
.field chrCgt: bool (size: 1, cast: variable(bool))
.field chrCge: bool (size: 1, cast: variable(bool))
.field i8A: int8 (size: 1, cast: variable(i32))
.field i8B: int8 (size: 1, cast: variable(i32))
.field i8Pls: int8 (size: 1, cast: variable(i32))
.field i8Neg: int8 (size: 1, cast: variable(i32))
.field i8Cmt: int8 (size: 1, cast: variable(i32))
.field i8Add: int8 (size: 1, cast: variable(i32))
.field i8Sub: int8 (size: 1, cast: variable(i32))
.field i8Mul: int8 (size: 1, cast: variable(i32))
.field i8Div: int8 (size: 1, cast: variable(i32))
.field i8Mod: int8 (size: 1, cast: variable(i32))
.field i8And: int8 (size: 1, cast: variable(i32))
.field i8Ior: int8 (size: 1, cast: variable(i32))
.field i8Xor: int8 (size: 1, cast: variable(i32))
.field i8Shl: int8 (size: 1, cast: variable(i32))
.field i8Shr: int8 (size: 1, cast: variable(i32))
.field i8Not: bool (size: 1, cast: variable(bool))
.field i8Ceq: bool (size: 1, cast: variable(bool))
.field i8Cne: bool (size: 1, cast: variable(bool))
.field i8Clt: bool (size: 1, cast: variable(bool))
.field i8Cle: bool (size: 1, cast: variable(bool))
.field i8Cgt: bool (size: 1, cast: variable(bool))
.field i8Cge: bool (size: 1, cast: variable(bool))
.field u8A: uint8 (size: 1, cast: variable(u32))
.field u8B: uint8 (size: 1, cast: variable(u32))
.field u8Pls: uint8 (size: 1, cast: variable(u32))
.field u8Neg: uint8 (size: 1, cast: variable(u32))
.field u8Cmt: uint8 (size: 1, cast: variable(u32))
.field u8Add: uint8 (size: 1, cast: variable(u32))
.field u8Sub: uint8 (size: 1, cast: variable(u32))
.field u8Mul: uint8 (size: 1, cast: variable(u32))
.field u8Div: uint8 (size: 1, cast: variable(u32))
.field u8Mod: uint8 (size: 1, cast: variable(u32))
.field u8And: uint8 (size: 1, cast: variable(u32))
.field u8Ior: uint8 (size: 1, cast: variable(u32))
.field u8Xor: uint8 (size: 1, cast: variable(u32))
.field u8Shl: uint8 (size: 1, cast: variable(u32))
.field u8Shr: uint8 (size: 1, cast: variable(u32))
.field u8Not: bool (size: 1, cast: variable(bool))
.field u8Ceq: bool (size: 1, cast: variable(bool))
.field u8Cne: bool (size: 1, cast: variable(bool))
.field u8Clt: bool (size: 1, cast: variable(bool))
.field u8Cle: bool (size: 1, cast: variable(bool))
.field u8Cgt: bool (size: 1, cast: variable(bool))
.field u8Cge: bool (size: 1, cast: variable(bool))
.field i16A: int16 (size: 2, cast: variable(i32))
.field i16B: int16 (size: 2, cast: variable(i32))
.field i16Pls: int16 (size: 2, cast: variable(i32))
.field i16Neg: int16 (size: 2, cast: variable(i32))
.field i16Cmt: int16 (size: 2, cast: variable(i32))
.field i16Add: int16 (size: 2, cast: variable(i32))
.field i16Sub: int16 (size: 2, cast: variable(i32))
.field i16Mul: int16 (size: 2, cast: variable(i32))
.field i16Div: int16 (size: 2, cast: variable(i32))
.field i16Mod: int16 (size: 2, cast: variable(i32))
.field i16And: int16 (size: 2, cast: variable(i32))
.field i16Ior: int16 (size: 2, cast: variable(i32))
.field i16Xor: int16 (size: 2, cast: variable(i32))
.field i16Shl: int16 (size: 2, cast: variable(i32))
.field i16Shr: int16 (size: 2, cast: variable(i32))
.field i16Not: bool (size: 1, cast: variable(bool))
.field i16Ceq: bool (size: 1, cast: variable(bool))
.field i16Cne: bool (size: 1, cast: variable(bool))
.field i16Clt: bool (size: 1, cast: variable(bool))
.field i16Cle: bool (size: 1, cast: variable(bool))
.field i16Cgt: bool (size: 1, cast: variable(bool))
.field i16Cge: bool (size: 1, cast: variable(bool))
.field u16A: uint16 (size: 2, cast: variable(u32))
.field u16B: uint16 (size: 2, cast: variable(u32))
.field u16Pls: uint16 (size: 2, cast: variable(u32))
.field u16Neg: uint16 (size: 2, cast: variable(u32))
.field u16Cmt: uint16 (size: 2, cast: variable(u32))
.field u16Add: uint16 (size: 2, cast: variable(u32))
.field u16Sub: uint16 (size: 2, cast: variable(u32))
.field u16Mul: uint16 (size: 2, cast: variable(u32))
.field u16Div: uint16 (size: 2, cast: variable(u32))
.field u16Mod: uint16 (size: 2, cast: variable(u32))
.field u16And: uint16 (size: 2, cast: variable(u32))
.field u16Ior: uint16 (size: 2, cast: variable(u32))
.field u16Xor: uint16 (size: 2, cast: variable(u32))
.field u16Shl: uint16 (size: 2, cast: variable(u32))
.field u16Shr: uint16 (size: 2, cast: variable(u32))
.field u16Not: bool (size: 1, cast: variable(bool))
.field u16Ceq: bool (size: 1, cast: variable(bool))
.field u16Cne: bool (size: 1, cast: variable(bool))
.field u16Clt: bool (size: 1, cast: variable(bool))
.field u16Cle: bool (size: 1, cast: variable(bool))
.field u16Cgt: bool (size: 1, cast: variable(bool))
.field u16Cge: bool (size: 1, cast: variable(bool))
.field i32A: int32 (size: 4, cast: variable(i32))
.field i32B: int32 (size: 4, cast: variable(i32))
.field i32Pls: int32 (size: 4, cast: variable(i32))
.field i32Neg: int32 (size: 4, cast: variable(i32))
.field i32Cmt: int32 (size: 4, cast: variable(i32))
.field i32Add: int32 (size: 4, cast: variable(i32))
.field i32Sub: int32 (size: 4, cast: variable(i32))
.field i32Mul: int32 (size: 4, cast: variable(i32))
.field i32Div: int32 (size: 4, cast: variable(i32))
.field i32Mod: int32 (size: 4, cast: variable(i32))
.field i32And: int32 (size: 4, cast: variable(i32))
.field i32Ior: int32 (size: 4, cast: variable(i32))
.field i32Xor: int32 (size: 4, cast: variable(i32))
.field i32Shl: int32 (size: 4, cast: variable(i32))
.field i32Shr: int32 (size: 4, cast: variable(i32))
.field i32Not: bool (size: 1, cast: variable(bool))
.field i32Ceq: bool (size: 1, cast: variable(bool))
.field i32Cne: bool (size: 1, cast: variable(bool))
.field i32Clt: bool (size: 1, cast: variable(bool))
.field i32Cle: bool (size: 1, cast: variable(bool))
.field i32Cgt: bool (size: 1, cast: variable(bool))
.field i32Cge: bool (size: 1, cast: variable(bool))
.field u32A: uint32 (size: 4, cast: variable(u32))
.field u32B: uint32 (size: 4, cast: variable(u32))
.field u32Pls: uint32 (size: 4, cast: variable(u32))
.field u32Neg: uint32 (size: 4, cast: variable(u32))
.field u32Cmt: uint32 (size: 4, cast: variable(u32))
.field u32Add: uint32 (size: 4, cast: variable(u32))
.field u32Sub: uint32 (size: 4, cast: variable(u32))
.field u32Mul: uint32 (size: 4, cast: variable(u32))
.field u32Div: uint32 (size: 4, cast: variable(u32))
.field u32Mod: uint32 (size: 4, cast: variable(u32))
.field u32And: uint32 (size: 4, cast: variable(u32))
.field u32Ior: uint32 (size: 4, cast: variable(u32))
.field u32Xor: uint32 (size: 4, cast: variable(u32))
.field u32Shl: uint32 (size: 4, cast: variable(u32))
.field u32Shr: uint32 (size: 4, cast: variable(u32))
.field u32Not: bool (size: 1, cast: variable(bool))
.field u32Ceq: bool (size: 1, cast: variable(bool))
.field u32Cne: bool (size: 1, cast: variable(bool))
.field u32Clt: bool (size: 1, cast: variable(bool))
.field u32Cle: bool (size: 1, cast: variable(bool))
.field u32Cgt: bool (size: 1, cast: variable(bool))
.field u32Cge: bool (size: 1, cast: variable(bool))
.field i64A: int64 (size: 8, cast: variable(i64))
.field i64B: int64 (size: 8, cast: variable(i64))
.field i64Pls: int64 (size: 8, cast: variable(i64))
.field i64Neg: int64 (size: 8, cast: variable(i64))
.field i64Cmt: int64 (size: 8, cast: variable(i64))
.field i64Add: int64 (size: 8, cast: variable(i64))
.field i64Sub: int64 (size: 8, cast: variable(i64))
.field i64Mul: int64 (size: 8, cast: variable(i64))
.field i64Div: int64 (size: 8, cast: variable(i64))
.field i64Mod: int64 (size: 8, cast: variable(i64))
.field i64And: int64 (size: 8, cast: variable(i64))
.field i64Ior: int64 (size: 8, cast: variable(i64))
.field i64Xor: int64 (size: 8, cast: variable(i64))
.field i64Shl: int64 (size: 8, cast: variable(i64))
.field i64Shr: int64 (size: 8, cast: variable(i64))
.field i64Not: bool (size: 1, cast: variable(bool))
.field i64Ceq: bool (size: 1, cast: variable(bool))
.field i64Cne: bool (size: 1, cast: variable(bool))
.field i64Clt: bool (size: 1, cast: variable(bool))
.field i64Cle: bool (size: 1, cast: variable(bool))
.field i64Cgt: bool (size: 1, cast: variable(bool))
.field i64Cge: bool (size: 1, cast: variable(bool))
.field u64A: uint64 (size: 8, cast: variable(u64))
.field u64B: uint64 (size: 8, cast: variable(u64))
.field u64Pls: uint64 (size: 8, cast: variable(u64))
.field u64Neg: uint64 (size: 8, cast: variable(u64))
.field u64Cmt: uint64 (size: 8, cast: variable(u64))
.field u64Add: uint64 (size: 8, cast: variable(u64))
.field u64Sub: uint64 (size: 8, cast: variable(u64))
.field u64Mul: uint64 (size: 8, cast: variable(u64))
.field u64Div: uint64 (size: 8, cast: variable(u64))
.field u64Mod: uint64 (size: 8, cast: variable(u64))
.field u64And: uint64 (size: 8, cast: variable(u64))
.field u64Ior: uint64 (size: 8, cast: variable(u64))
.field u64Xor: uint64 (size: 8, cast: variable(u64))
.field u64Shl: uint64 (size: 8, cast: variable(u64))
.field u64Shr: uint64 (size: 8, cast: variable(u64))
.field u64Not: bool (size: 1, cast: variable(bool))
.field u64Ceq: bool (size: 1, cast: variable(bool))
.field u64Cne: bool (size: 1, cast: variable(bool))
.field u64Clt: bool (size: 1, cast: variable(bool))
.field u64Cle: bool (size: 1, cast: variable(bool))
.field u64Cgt: bool (size: 1, cast: variable(bool))
.field u64Cge: bool (size: 1, cast: variable(bool))
.field f32A: float32 (size: 4, cast: variable(f32))
.field f32B: float32 (size: 4, cast: variable(f32))
.field f32Pls: float32 (size: 4, cast: variable(f32))
.field f32Neg: float32 (size: 4, cast: variable(f32))
.field f32Add: float32 (size: 4, cast: variable(f32))
.field f32Sub: float32 (size: 4, cast: variable(f32))
.field f32Mul: float32 (size: 4, cast: variable(f32))
.field f32Div: float32 (size: 4, cast: variable(f32))
.field f32Mod: float32 (size: 4, cast: variable(f32))
.field f32Not: bool (size: 1, cast: variable(bool))
.field f32Ceq: bool (size: 1, cast: variable(bool))
.field f32Cne: bool (size: 1, cast: variable(bool))
.field f32Clt: bool (size: 1, cast: variable(bool))
.field f32Cle: bool (size: 1, cast: variable(bool))
.field f32Cgt: bool (size: 1, cast: variable(bool))
.field f32Cge: bool (size: 1, cast: variable(bool))
.field f64A: float64 (size: 8, cast: variable(f64))
.field f64B: float64 (size: 8, cast: variable(f64))
.field f64Pls: float64 (size: 8, cast: variable(f64))
.field f64Neg: float64 (size: 8, cast: variable(f64))
.field f64Add: float64 (size: 8, cast: variable(f64))
.field f64Sub: float64 (size: 8, cast: variable(f64))
.field f64Mul: float64 (size: 8, cast: variable(f64))
.field f64Div: float64 (size: 8, cast: variable(f64))
.field f64Mod: float64 (size: 8, cast: variable(f64))
.field f64Not: bool (size: 1, cast: variable(bool))
.field f64Ceq: bool (size: 1, cast: variable(bool))
.field f64Cne: bool (size: 1, cast: variable(bool))
.field f64Clt: bool (size: 1, cast: variable(bool))
.field f64Cle: bool (size: 1, cast: variable(bool))
.field f64Cgt: bool (size: 1, cast: variable(bool))
.field f64Cge: bool (size: 1, cast: variable(bool))
.field ptrA: pointer (size: 4, cast: variable(ref))
.field ptrB: pointer (size: 4, cast: variable(ref))
.field ptrCeq: bool (size: 1, cast: variable(bool))
.field ptrCne: bool (size: 1, cast: variable(bool))
.field t: int32 (size: 4, cast: variable(i32))
.field forIdx: int32 (size: 4, cast: variable(i32))
.field pi64: float64 (size: 8, cast: variable(f64))
.field e64: float64 (size: 8, cast: variable(f64))
.field pi32: float32 (size: 4, cast: variable(f32))
.field e32: float32 (size: 4, cast: variable(f32))
.field rgb888: function (size: 0, cast: inline)
.field rgb565: function (size: 0, cast: inline)
.field r_comp: int32 (size: 4, cast: variable(i32))
.field g_comp: int32 (size: 4, cast: variable(i32))
.field b_comp: int32 (size: 4, cast: variable(i32))
.field r5g6b5: int32 (size: 4, cast: variable(i32))
.field r8g8b8: int32 (size: 4, cast: variable(i32))
.field zxtR5: int32 (size: 4, cast: variable(i32))
.field zxtG6: int32 (size: 4, cast: variable(i32))
.field zxtB5: int32 (size: 4, cast: variable(i32))
.field sxtR5: int32 (size: 4, cast: variable(i32))
.field sxtG6: int32 (size: 4, cast: variable(i32))
.field sxtB5: int32 (size: 4, cast: variable(i32))
.field zxtR8: int32 (size: 4, cast: variable(i32))
.field zxtG8: int32 (size: 4, cast: variable(i32))
.field zxtB8: int32 (size: 4, cast: variable(i32))
.field sxtR8: int32 (size: 4, cast: variable(i32))
.field sxtG8: int32 (size: 4, cast: variable(i32))
.field sxtB8: int32 (size: 4, cast: variable(i32))
.field testSin_f64: float64 (size: 8, cast: variable(f64))
.field testCos_f64: float64 (size: 8, cast: variable(f64))
.field testTan_f64: float64 (size: 8, cast: variable(f64))
.field testLog_f64: float64 (size: 8, cast: variable(f64))
.field testExp_f64: float64 (size: 8, cast: variable(f64))
.field testPow_f64: float64 (size: 8, cast: variable(f64))
.field testSqrt_f64: float64 (size: 8, cast: variable(f64))
.field testAtan_f64: float64 (size: 8, cast: variable(f64))
.field testSin_f32: float32 (size: 4, cast: variable(f32))
.field testCos_f32: float32 (size: 4, cast: variable(f32))
.field testTan_f32: float32 (size: 4, cast: variable(f32))
.field testLog_f32: float32 (size: 4, cast: variable(f32))
.field testExp_f32: float32 (size: 4, cast: variable(f32))
.field testPow_f32: float32 (size: 4, cast: variable(f32))
.field testSqrt_f32: float32 (size: 4, cast: variable(f32))
.field testAtan_f32: float32 (size: 4, cast: variable(f32))
.field testPopulation_u32: int32 (size: 4, cast: variable(i32))
.field testSwapBits_u32: uint32 (size: 4, cast: variable(u32))
.field testBitScanReverse_u32: int32 (size: 4, cast: variable(i32))
.field testBitScanForward_u32: int32 (size: 4, cast: variable(i32))
.field testHighBit_u32: int32 (size: 4, cast: variable(i32))
.field testLowBit_u32: int32 (size: 4, cast: variable(i32))
.field testZeroExtend_u32: int32 (size: 4, cast: variable(i32))
.field testSignExtend_u32: int32 (size: 4, cast: variable(i32))
.field testZeroExtend_u64: int32 (size: 4, cast: variable(i32))
.field testSignExtend_u64: int32 (size: 4, cast: variable(i32))
.field testMathFloor_pos_3_0: float64 (size: 8, cast: variable(f64))
.field testMathFloor_pos_3_2: float64 (size: 8, cast: variable(f64))
.field testMathFloor_pos_3_5: float64 (size: 8, cast: variable(f64))
.field testMathFloor_pos_3_7: float64 (size: 8, cast: variable(f64))
.field testMathFloor_pos_3_9: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_0: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_2: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_5: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_7: float64 (size: 8, cast: variable(f64))
.field testMathFloor_neg_3_9: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_0: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_2: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_5: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_7: float64 (size: 8, cast: variable(f64))
.field testMathRound_pos_3_9: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_0: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_2: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_5: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_7: float64 (size: 8, cast: variable(f64))
.field testMathRound_neg_3_9: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_0: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_2: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_5: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_7: float64 (size: 8, cast: variable(f64))
.field testMathCeil_pos_3_9: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_0: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_2: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_5: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_7: float64 (size: 8, cast: variable(f64))
.field testMathCeil_neg_3_9: float64 (size: 8, cast: variable(f64))
.field testMathSign_1F: float64 (size: 8, cast: variable(f64))
.field testMathSign_2F: float64 (size: 8, cast: variable(f64))
.field testMathSign_3F: float64 (size: 8, cast: variable(f64))
.field testMathSign_1f: float64 (size: 8, cast: variable(f64))
.field testMathSign_2f: float64 (size: 8, cast: variable(f64))
.field testMathSign_3f: float64 (size: 8, cast: variable(f64))
.field testMathAbs_1F: float64 (size: 8, cast: variable(f64))
.field testMathAbs_2F: float64 (size: 8, cast: variable(f64))
.field testMathAbs_3F: float64 (size: 8, cast: variable(f64))
.field testMathAbs_1f: float64 (size: 8, cast: variable(f64))
.field testMathAbs_2f: float64 (size: 8, cast: variable(f64))
.field testMathAbs_3f: float64 (size: 8, cast: variable(f64))
.field testMathMin_1f: float64 (size: 8, cast: variable(f64))
.field testMathMax_2f: float64 (size: 8, cast: variable(f64))
.field testMathMin_1F: float64 (size: 8, cast: variable(f64))
.field testMathMax_2F: float64 (size: 8, cast: variable(f64))
.field testMathClamp_1f: float64 (size: 8, cast: variable(f64))
.field testMathClamp_1F: float64 (size: 8, cast: variable(f64))
.field testMathMix_1f: float64 (size: 8, cast: variable(f64))
.field testMathMix_1F: float64 (size: 8, cast: variable(f64))
.field testMathSmooth_1f: float64 (size: 8, cast: variable(f64))
.field testMathSmooth_1F: float64 (size: 8, cast: variable(f64))
.field testMathMin_nan: float64 (size: 8, cast: variable(f64))
.field testMathMin_1: float64 (size: 8, cast: variable(f64))
.field testMathMax_nan: float64 (size: 8, cast: variable(f64))
.field testMathMax_9: float64 (size: 8, cast: variable(f64))
.field testMathSum_0: float64 (size: 8, cast: variable(f64))
.field testMathSum_1: float64 (size: 8, cast: variable(f64))
.field testMathSum_3: float64 (size: 8, cast: variable(f64))
.field testMathSum_55: float64 (size: 8, cast: variable(f64))
.field testMathEval_x: float64 (size: 8, cast: variable(f64))
.field testMathEval_0: float64 (size: 8, cast: variable(f64))
.field testMathEval_1: float64 (size: 8, cast: variable(f64))
.field testMathEval_2: float64 (size: 8, cast: variable(f64))
.field testMathEval_3: float64 (size: 8, cast: variable(f64))
.field testMathEval_4: float64 (size: 8, cast: variable(f64))
.field testMathEval_5: float64 (size: 8, cast: variable(f64))
.field testMathEval_6: float64 (size: 8, cast: variable(f64))
.field testMathSin_f64: float64 (size: 8, cast: variable(f64))
.field testMathCos_f64: float64 (size: 8, cast: variable(f64))
.field testMathTan_f64: float64 (size: 8, cast: variable(f64))
.field testMathSinh_f64: float64 (size: 8, cast: variable(f64))
.field testMathCosh_f64: float64 (size: 8, cast: variable(f64))
.field testMathAsin_f64: float64 (size: 8, cast: variable(f64))
.field testMathAcos_f64: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_0a: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_0b: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_0c: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_9a: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_9b: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_9c: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_9d: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_8a: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_8b: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_8c: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f64_8d: float64 (size: 8, cast: variable(f64))
.field testMathAbsMod_f32_0a: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_0b: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_0c: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_9a: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_9b: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_9c: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_9d: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_8a: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_8b: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_8c: float32 (size: 4, cast: variable(f32))
.field testMathAbsMod_f32_8d: float32 (size: 4, cast: variable(f32))
.field Neg: function (size: 0, cast: inline)
.field Add: function (size: 0, cast: inline)
.field Sub: function (size: 0, cast: inline)
.field Mul: function (size: 0, cast: inline)
.field valA: Complex (size: 16, cast: variable(val))
.field valB: Complex (size: 16, cast: variable(val))
.field Neg: Complex (size: 16, cast: variable(val))
.field neg: Complex (size: 16, cast: variable(val))
.field Add: Complex (size: 16, cast: variable(val))
.field add: Complex (size: 16, cast: variable(val))
.field Sub: Complex (size: 16, cast: variable(val))
.field sub: Complex (size: 16, cast: variable(val))
.field Mul: Complex (size: 16, cast: variable(val))
.field mul: Complex (size: 16, cast: variable(val))
.field .main: function (size: 19799, cast: static function)
.value: {
	{
		byte: typename := uint8;
		float: typename := float32;
		double: typename := float64;
		sizeof(type: typename): int32 := typename.size(type);
		static if (typename(raise) == function) {
			verbose(const message: char[*], const details: variant[]): void := raise(raise.verbose, raise.noTrace, message, ...details);
			debug(const message: char[*], const details: variant[]): void := raise(raise.debug, raise.noTrace, message, ...details);
			trace(const message: char[*], const details: variant[]): void := raise(raise.debug, raise.defTrace, message, ...details);
			info(const message: char[*], const details: variant[]): void := raise(raise.info, raise.noTrace, message, ...details);
			warn(const message: char[*], const details: variant[]): void := raise(raise.warn, raise.noTrace, message, ...details);
			error(const message: char[*], const details: variant[]): void := raise(raise.error, raise.defTrace, message, ...details);
			abort(const message: char[*], const details: variant[]): void := raise(raise.abort, raise.defTrace, message, ...details);
			abort(): void := raise(raise.abort, raise.defTrace, "execution aborted!");
			assert(condition: bool, const message: char[*], const details: variant[]): void := void(condition ? void(0) : raise(raise.abort, raise.defTrace, message, ...details));
			assert(condition: bool, const details: variant[]): void := void(condition ? void(0) : raise(raise.abort, raise.defTrace, "assertion failed!", ...details));
			static const NotEquals: struct {
				const expected: variant;
				const returned: variant;
				const extras: variant[];
			};
			static NotEquals(const expected: variant, const returned: variant): NotEquals := {
				return .result := {
			.result.expected := expected;
			.result.returned := returned;
			.result.extras := (null);
		};
			};
			abort(const message: char[*], const detail: NotEquals): void := raise(raise.abort, raise.defTrace, message, detail);
			assert(condition: bool, const message: char[*], const detail: NotEquals): void := void(condition ? void(0) : abort(message, detail));
			static assertEq(expected: int32, returned: int32, const message: char[*]): void := {
				if (returned == expected) {
					return;
				}
				extras: variant[1] := {
					extras[0] := (message);
				};
				detail: NotEquals := {
					detail.expected := (expected);
					detail.returned := (returned);
					detail.extras := (extras);
				};
				raise(raise.abort, raise.defTrace, "assertion failed", detail);
			};
			assertEq(expected: int32, returned: int32): void := assertEq(expected, returned, null);
		}
		static if (int32 == int32) {
			inc(ptr: pointer, val: int32): pointer := pointer(emit(pointer(ptr), int32(val), add.i32));
		}
		static if (int32 == int64) {
			inc(ptr: pointer, val: int32): pointer := pointer(emit(pointer(ptr), int32(val), add.i64));
		}
		static const Bits: struct {
			static signed(value: uint8): int8 := int8(value);
			static signed(value: uint16): int16 := int16(value);
			static signed(value: uint32): int32 := int32(value);
			static signed(value: uint64): int64 := int64(value);
			static unsigned(value: int8): uint8 := uint8(value);
			static unsigned(value: int16): uint16 := uint16(value);
			static unsigned(value: int32): uint32 := uint32(value);
			static unsigned(value: int64): uint64 := uint64(value);
			static fromFloat32(value: float32): uint32 := uint32(emit(float32(value)));
			static fromFloat64(value: float64): uint64 := uint64(emit(float64(value)));
			static asFloat32(value: uint32): float32 := float32(emit(uint32(value)));
			static asFloat64(value: uint64): float64 := float64(emit(uint64(value)));
			static asFloat64(hi: uint32, lo: uint32): float64 := float64(emit(uint64(uint64(hi) << 32 | (lo))));
			static zxt32(value: int32, offs: int32, count: int32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.zxt)) != null) {
					return .result := uint32.zxt(value, offs, count);
				}
				return .result := uint32(value << (32 - (offs + count))) >> (32 - count);
			};
			static sxt32(value: int32, offs: int32, count: int32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.sxt)) != null) {
					return .result := uint32.sxt(value, offs, count);
				}
				return .result := int32(value << (32 - (offs + count))) >> (32 - count);
			};
			static zxt64(value: int64, offs: int32, count: int32): int64 := {
				static if ((preferNativeCalls) && (typename(uint64.zxt)) != null) {
					return .result := uint64.zxt(value, offs, count);
				}
				return .result := uint64(value << (64 - (offs + count))) >> (64 - count);
			};
			static sxt64(value: int64, offs: int32, count: int32): int64 := {
				static if ((preferNativeCalls) && (typename(uint64.sxt)) != null) {
					return .result := uint64.sxt(value, offs, count);
				}
				return .result := int64(value << (64 - (offs + count))) >> (64 - count);
			};
			static swapBytes(x: uint64): uint64 := {
				x := (x & (4294967295)) << 32 | (x & (-4294967296)) >> 32;
				x := (x & (281470681808895)) << 16 | (x & (-281470681808896)) >> 16;
				x := (x & (71777214294589695)) << 8 | (x & (-71777214294589696)) >> 8;
				return .result := x;
			};
			static swapBytes(x: uint32): uint32 := {
				x := (((x & (65535)) << 16) | ((x) & 4294901760) >> 16);
				x := (((x & (16711935)) << 8) | ((x) & 4278255360) >> 8);
				return .result := x;
			};
			static swapBytes(x: uint16): uint16 := {
				return .result := ((x) & 255) << 8 | ((x) & 65280) >> 8;
			};
			static swapBytes(x: int64): int64 := int64(swapBytes(uint64(x)));
			static swapBytes(x: int32): int32 := int32(swapBytes(uint32(x)));
			static swapBytes(x: int16): int16 := int16(swapBytes(uint16(x)));
			static scanReverse(x: uint64): int32 := {
				static if ((preferNativeCalls) && (typename(uint64.bsr)) != null) {
					return .result := uint64.bsr(x);
				}
				if (x == (0)) {
					return .result := -1;
				}
				result: int32 := 0;
				if (x & (-4294967296)) {
					result := result + 32;
					x := x >> 32;
				}
				if (x & (4294901760)) {
					result := result + 16;
					x := x >> 16;
				}
				if (x & (65280)) {
					result := result + 8;
					x := x >> 8;
				}
				if (x & (240)) {
					result := result + 4;
					x := x >> 4;
				}
				if (x & (12)) {
					result := result + 2;
					x := x >> 2;
				}
				if (x & (2)) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanReverse(x: int64): int32 := scanReverse(uint64(x));
			static scanReverse(x: uint32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.bsr)) != null) {
					return .result := uint32.bsr(x);
				}
				if (x == (0)) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x) & 4294901760) {
					result := result + 16;
					x := x >> 16;
				}
				if (x & (65280)) {
					result := result + 8;
					x := x >> 8;
				}
				if (x & (240)) {
					result := result + 4;
					x := x >> 4;
				}
				if (x & (12)) {
					result := result + 2;
					x := x >> 2;
				}
				if (x & (2)) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanReverse(x: int32): int32 := scanReverse(uint32(x));
			static scanReverse(x: uint16): int32 := {
				if ((x) == 0) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x) & 65280) {
					result := result + 8;
					x := ((x) >> 8);
				}
				if ((x) & 240) {
					result := result + 4;
					x := ((x) >> 4);
				}
				if ((x) & 12) {
					result := result + 2;
					x := ((x) >> 2);
				}
				if ((x) & 2) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanReverse(x: int16): int32 := scanReverse(uint16(x));
			static scanReverse(x: uint8): int32 := {
				if ((x) == 0) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x) & 240) {
					result := result + 4;
					x := ((x) >> 4);
				}
				if ((x) & 12) {
					result := result + 2;
					x := ((x) >> 2);
				}
				if ((x) & 2) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanReverse(x: int8): int32 := scanReverse(uint8(x));
			static scanForward(x: uint64): int32 := {
				static if ((preferNativeCalls) && (typename(uint64.bsf)) != null) {
					return .result := uint64.bsf(x);
				}
				if (x == (0)) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x & (4294967295)) == (0)) {
					result := result + 32;
					x := x >> 32;
				}
				if ((x & (65535)) == (0)) {
					result := result + 16;
					x := x >> 16;
				}
				if ((x & (255)) == (0)) {
					result := result + 8;
					x := x >> 8;
				}
				if ((x & (15)) == (0)) {
					result := result + 4;
					x := x >> 4;
				}
				if ((x & (3)) == (0)) {
					result := result + 2;
					x := x >> 2;
				}
				if ((x & (1)) == (0)) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanForward(x: int64): int32 := scanForward(uint64(x));
			static scanForward(x: uint32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.bsf)) != null) {
					return .result := uint32.bsf(x);
				}
				if (x == (0)) {
					return .result := -1;
				}
				result: int32 := 0;
				if ((x & (65535)) == (0)) {
					result := result + 16;
					x := x >> 16;
				}
				if ((x & (255)) == (0)) {
					result := result + 8;
					x := x >> 8;
				}
				if ((x & (15)) == (0)) {
					result := result + 4;
					x := x >> 4;
				}
				if ((x & (3)) == (0)) {
					result := result + 2;
					x := x >> 2;
				}
				if ((x & (1)) == (0)) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanForward(x: int32): int32 := scanForward(uint32(x));
			static scanForward(x: uint16): int32 := {
				if ((x) == 0) {
					return .result := -1;
				}
				result: int32 := 0;
				if (((x) & 255) == 0) {
					result := result + 8;
					x := ((x) >> 8);
				}
				if (((x) & 15) == 0) {
					result := result + 4;
					x := ((x) >> 4);
				}
				if (((x) & 3) == 0) {
					result := result + 2;
					x := ((x) >> 2);
				}
				if (((x) & 1) == 0) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanForward(x: int16): int32 := scanForward(uint16(x));
			static scanForward(x: uint8): int32 := {
				if ((x) == 0) {
					return .result := -1;
				}
				result: int32 := 0;
				if (((x) & 15) == 0) {
					result := result + 4;
					x := ((x) >> 4);
				}
				if (((x) & 3) == 0) {
					result := result + 2;
					x := ((x) >> 2);
				}
				if (((x) & 1) == 0) {
					result := result + 1;
				}
				return .result := result;
			};
			static scanForward(x: int8): int32 := scanForward(uint8(x));
			static keepMsb(x: uint64): uint64 := {
				static if ((preferNativeCalls) && (typename(uint64.hib)) != null) {
					return .result := uint64.hib(x);
				}
				x := x | x >> 1;
				x := x | x >> 2;
				x := x | x >> 4;
				x := x | x >> 8;
				x := x | x >> 16;
				x := x | x >> 32;
				return .result := x - (x >> 1);
			};
			static keepMsb(x: int64): uint64 := keepMsb(uint64(x));
			static keepMsb(x: uint32): uint32 := {
				static if ((preferNativeCalls) && (typename(uint32.hib)) != null) {
					return .result := uint32.hib(x);
				}
				x := x | x >> 1;
				x := x | x >> 2;
				x := x | x >> 4;
				x := x | x >> 8;
				x := x | x >> 16;
				return .result := x - (x >> 1);
			};
			static keepMsb(x: int32): uint32 := keepMsb(uint32(x));
			static keepLsb(x: uint64): uint64 := uint64(x & -x);
			static keepLsb(x: int64): uint64 := keepLsb(uint64(x));
			static keepLsb(x: uint32): uint32 := uint32(x & -x);
			static keepLsb(x: int32): uint32 := keepLsb(uint32(x));
			static keepLsb(x: uint16): uint16 := uint16(x & -x);
			static keepLsb(x: int16): uint16 := keepLsb(uint16(x));
			static keepLsb(x: uint8): uint8 := uint8(x & -x);
			static keepLsb(x: int8): uint8 := keepLsb(uint8(x));
			static countOnes(x: uint64): int32 := {
				static if ((preferNativeCalls) && (typename(uint64.pop)) != null) {
					return .result := uint64.pop(x);
				}
				x := x - ((x >> 1) & (6148914691236517205));
				x := (x & (3689348814741910323)) + ((x >> 2) & (3689348814741910323));
				x := (x + (x >> 4)) & (1085102592571150095);
				x := x + (x >> 8);
				x := x + (x >> 16);
				x := x + (x >> 32);
				return .result := x & (63);
			};
			static countOnes(x: int64): int32 := countOnes(uint64(x));
			static countOnes(x: uint32): int32 := {
				static if ((preferNativeCalls) && (typename(uint32.pop)) != null) {
					return .result := uint32.pop(x);
				}
				x := x - ((x >> 1) & (1431655765));
				x := (x & (858993459)) + ((x >> 2) & (858993459));
				x := (x + (x >> 4)) & (252645135);
				x := x + (x >> 8);
				x := x + (x >> 16);
				return .result := x & (63);
			};
			static countOnes(x: int32): int32 := countOnes(uint32(x));
			static swapBits(x: uint64): uint64 := {
				static if ((preferNativeCalls) && (typename(uint64.swap)) != null) {
					return .result := uint64.swap(x);
				}
				x := ((x >> 1) & (6148914691236517205)) | ((x & (6148914691236517205)) << 1);
				x := ((x >> 2) & (3689348814741910323)) | ((x & (3689348814741910323)) << 2);
				x := ((x >> 4) & (1085102592571150095)) | ((x & (1085102592571150095)) << 4);
				x := ((x >> 8) & (71777214294589695)) | ((x & (71777214294589695)) << 8);
				x := ((x >> 16) & (281470681808895)) | ((x & (281470681808895)) << 16);
				return .result := (x >> 32) | (x << 32);
			};
			static swapBits(x: int64): uint64 := swapBits(uint64(x));
			static swapBits(x: uint32): uint32 := {
				static if ((preferNativeCalls) && (typename(uint32.swap)) != null) {
					return .result := uint32.swap(x);
				}
				x := ((x >> 1) & (1431655765)) | ((x & (1431655765)) << 1);
				x := ((x >> 2) & (858993459)) | ((x & (858993459)) << 2);
				x := ((x >> 4) & (252645135)) | ((x & (252645135)) << 4);
				x := ((x >> 8) & (16711935)) | ((x & (16711935)) << 8);
				return .result := (x >> 16) | (x << 16);
			};
			static swapBits(x: int32): uint32 := swapBits(uint32(x));
			static swapBits(x: uint16): uint16 := {
				x := ((((x) >> 1) & 21845) | (((x) & 21845) << 1));
				x := ((((x) >> 2) & 13107) | (((x) & 13107) << 2));
				x := ((((x) >> 4) & 3855) | (((x) & 3855) << 4));
				return .result := ((x) >> 8) | ((x) << 8);
			};
			static swapBits(x: int16): uint16 := swapBits(uint16(x));
			static swapBits(x: uint8): uint8 := {
				x := ((((x) >> 1) & 85) | (((x) & 85) << 1));
				x := ((((x) >> 2) & 51) | (((x) & 51) << 2));
				return .result := ((x) >> 4) | ((x) << 4);
			};
			static swapBits(x: int8): uint8 := swapBits(uint8(x));
			static clamp(value: int32, max: int32): int32 := {
				value := value & ~(value >> 31);
				value := value - max;
				value := value & (value >> 31);
				value := value + max;
				return .result := value;
			};
			static clamp(value: int32, min: int32, max: int32): int32 := {
				return .result := clamp(value - min, max - min) + min;
			};
		};
		static const Math: struct {
			static const pi: float64 := 3.141593;
			static const e: float64 := 2.718282;
			static const ln2: float64 := 0.693147;
			static const log2E: float64 := 1.442695;
			static const ln10: float64 := 2.302585;
			static const log10E: float64 := 0.434294;
			static const phi: float64 := 1.618034;
			static const sqrt2: float64 := 1.414214;
			static const sqrtE: float64 := 1.648721;
			static const sqrtPi: float64 := 1.772454;
			static const sqrtPhi: float64 := 1.272020;
			static const nan: float64 := -nan;
			static const inf: float64 := inf;
			static const smallestNormal: float64 := 0.000000;
			static isNan(x: float64): bool := {
				return .result := x != x;
			};
			static isInf(x: float64): bool := {
				return .result := x != (0) && x == (2) * x;
			};
			static isFinite(x: float64): bool := {
				return .result := x - x == (0);
			};
			static isInf(x: float64, sign: int32): bool := {
				if (isFinite(x)) {
					return .result := false;
				}
				if (sign == 0) {
					return .result := true;
				}
				return .result := sign < 0 ? x < (0) : x > (0);
			};
			static floor(x: float64): float64 := {
				mod: float64 := x % (1);
				if (mod < (0)) {
					mod := mod + (1);
				}
				return .result := x - mod;
			};
			static floor(x: float32): float32 := {
				mod: float32 := x % (1);
				if (mod < (0)) {
					mod := mod + (1);
				}
				return .result := x - mod;
			};
			static ceil(x: float64): float64 := -floor(-x);
			static ceil(x: float32): float32 := -floor(-x);
			static round(x: float64): float64 := floor(x + 0.500000);
			static round(x: float32): float32 := floor(x + 0.500000);
			static sign(x: int32): int32 := int32(x > 0) - int32(x < 0);
			static sign(x: int64): int32 := int32(x > (0)) - int32(x < (0));
			static sign(x: uint32): int32 := int32(x > (0));
			static sign(x: uint64): int32 := int32(x > (0));
			static sign(x: float32): int32 := int32(x > (0)) - int32(x < (0));
			static sign(x: float64): int32 := int32(x > (0)) - int32(x < (0));
			static absMod(val: float32, mod: float32): float32 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static absMod(val: float64, mod: float64): float64 := {
				if ((val := val % mod) < (0)) {
					return .result := val + mod;
				}
				return .result := val;
			};
			static abs(x: int32): int32 := x < 0 ? -x : x;
			static abs(x: int64): int64 := x < (0) ? -x : x;
			static abs(x: uint32): uint32 := x;
			static abs(x: uint64): uint64 := x;
			static abs(x: float32): float32 := x < (0) ? -x : x;
			static abs(x: float64): float64 := x < (0) ? -x : x;
			static min(a: int32, b: int32): int32 := a < b ? a : b;
			static min(a: int64, b: int64): int64 := a < b ? a : b;
			static min(a: uint32, b: uint32): uint32 := a < b ? a : b;
			static min(a: uint64, b: uint64): uint64 := a < b ? a : b;
			static min(a: float32, b: float32): float32 := a < b ? a : b;
			static min(a: float64, b: float64): float64 := a < b ? a : b;
			static max(a: int32, b: int32): int32 := a > b ? a : b;
			static max(a: int64, b: int64): int64 := a > b ? a : b;
			static max(a: uint32, b: uint32): uint32 := a > b ? a : b;
			static max(a: uint64, b: uint64): uint64 := a > b ? a : b;
			static max(a: float32, b: float32): float32 := a > b ? a : b;
			static max(a: float64, b: float64): float64 := a > b ? a : b;
			static clamp(value: int32, min: int32, max: int32): int32 := min(max(value, min), max);
			static clamp(value: int64, min: int64, max: int64): int64 := min(max(value, min), max);
			static clamp(value: uint32, min: uint32, max: uint32): uint32 := min(max(value, min), max);
			static clamp(value: uint64, min: uint64, max: uint64): uint64 := min(max(value, min), max);
			static clamp(value: float32, min: float32, max: float32): float32 := min(max(value, min), max);
			static clamp(value: float64, min: float64, max: float64): float64 := min(max(value, min), max);
			static mix(a: float32, b: float32, t: float32): float32 := a + t * (b - a);
			static mix(a: float64, b: float64, t: float64): float64 := a + t * (b - a);
			static smoothstep(t: float32): float32 := t * t * ((3) - (2) * t);
			static smoothstep(min: float32, max: float32, t: float32): float32 := smoothstep(clamp((t - min) / (max - min), 0.000000, 1.000000));
			static smoothstep(t: float64): float64 := t * t * ((3) - (2) * t);
			static smoothstep(min: float64, max: float64, t: float64): float64 := smoothstep(clamp((t - min) / (max - min), 0.000000, 1.000000));
			static min(values: float64[]): float64 := {
				if (values.length == (0)) {
					return .result := nan;
				}
				result: float64 := values[0];
				for (i: int32 := 1; i < (values.length); i := i + 1) {
					if (result > values[i]) {
						result := values[i];
					}
				}
				return .result := result;
			};
			static max(values: float64[]): float64 := {
				if (values.length == (0)) {
					return .result := nan;
				}
				result: float64 := values[0];
				for (i: int32 := 1; i < (values.length); i := i + 1) {
					if (result < values[i]) {
						result := values[i];
					}
				}
				return .result := result;
			};
			static sum(values: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := 0; i < (values.length); i := i + 1) {
					result := result + values[i];
				}
				return .result := result;
			};
			static mean(values: float64[]): float64 := {
				return .result := sum(...values) / (Bits.signed(values.length));
			};
			static eval(x: float64, a0: float64): float64 := a0;
			static eval(x: float64, a0: float64, a1: float64): float64 := a0 + x * a1;
			static eval(x: float64, a0: float64, a1: float64, a2: float64): float64 := a0 + x * eval(x, a1, a2);
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64): float64 := a0 + x * eval(x, a1, a2, a3);
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64, a4: float64): float64 := a0 + x * eval(x, a1, a2, a3, a4);
			static eval(x: float64, a0: float64, a1: float64, a2: float64, a3: float64, a4: float64, a5: float64): float64 := a0 + x * eval(x, a1, a2, a3, a4, a5);
			static eval(x: float64, polynomial: float64[]): float64 := {
				result: float64 := 0;
				for (i: int32 := polynomial.length - (1); i >= 0; i := i - 1) {
					result := result * x + polynomial[i];
				}
				return .result := result;
			};
			static modf(x: float64, intPart: float64): float64 := {
				if (x < (1)) {
					if (x < (0)) {
						result: float64 := modf(-x, &intPart);
						intPart := -intPart;
						return .result := -result;
					}
					intPart := (0);
					return .result := x;
				}
				result: float64 := x % (1);
				intPart := x - result;
				return .result := result;
			};
			static copysign(x: float64, y: float64): float64 := {
				sign: uint64 := Bits.fromFloat64(y) & (1 << 63);
				val: uint64 := Bits.fromFloat64(x) & ~(1 << 63);
				return .result := Bits.asFloat64(sign | val);
			};
			static frexp(f: float64, exp: int32): float64 := {
				mask: typename := 2047;
				shift: typename := 64 - 11 - 1;
				bias: typename := 1023;
				signMask: typename := 1 << 63;
				fracMask: typename := 1 << shift - 1;
				if (f == (0)) {
					exp := 0;
					return .result := f;
				}
				if (isInf(f) || isNan(f)) {
					exp := 0;
					return .result := f;
				}
				if (abs(f) < smallestNormal) {
					f := f * (1 << 52);
					exp := exp - 52;
				}
				else {
					exp := 0;
				}
				x: uint64 := Bits.fromFloat64(f);
				exp := exp + int32((x >> shift) & mask) - bias + 1;
				x := x & ~(mask << shift);
				x := x | (-1 + (bias)) << shift;
				return .result := Bits.asFloat64(x);
			};
			static ldexp(f: float64, exp: int32): float64 := {
				mask: typename := 2047;
				shift: typename := 64 - 11 - 1;
				bias: typename := 1023;
				signMask: typename := 1 << 63;
				fracMask: typename := 1 << shift - 1;
				if (f == (0)) {
					return .result := f;
				}
				if (f != f || f - f != (0)) {
					return .result := f;
				}
				if (abs(f) < smallestNormal) {
					f := f * (1 << 52);
					exp := exp - 52;
				}
				x: uint64 := Bits.fromFloat64(f);
				exp := ((exp) + ((int32(x >> shift)) & mask) - (bias));
				if (exp < -1075) {
					return .result := copysign(0.000000, f);
				}
				if (exp > 1023) {
					return .result := copysign(inf, f);
				}
				m: float64 := 1;
				if (exp < -1022) {
					exp := exp + 53;
					m := (1) / float64(1 << 53);
				}
				x := x & ~(mask << shift);
				x := x | uint64(exp + bias) << shift;
				return .result := m * Bits.asFloat64(x);
			};
			static log(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.log)) != null) {
					return .result := float64.log(x);
				}
				if (x <= (0)) {
					if (x == (0)) {
						return .result := -inf;
					}
					return .result := nan;
				}
				exp: int32;
				x := frexp(x, &exp);
				for ( ; x < 0.500000; ) {
					x := x * (2);
					exp := exp - 1;
				}
				if (x < sqrto2) {
					x := x * (2);
					exp := exp - 1;
				}
				z: float64 := (x - (1)) / (x + (1));
				zsq: float64 := z * z;
				p: float64 := eval(zsq, p0, p1, p2, p3);
				q: float64 := eval(zsq, q0, q1, q2 + zsq);
				return .result := p / q * z + (exp) * log2;
			};
			static log(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.log)) != null) {
					return .result := float32.log(x);
				}
				return .result := float32(log(float64(x)));
			};
			static log2(x: float64): float64 := log(x) / ln2;
			static log10(x: float64): float64 := log(x) / ln10;
			static log(x: float64, base: float64): float64 := log(x) / log(base);
			static exp(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.exp)) != null) {
					return .result := float64.exp(x);
				}
				if (isNan(x)) {
					return .result := x;
				}
				if (x > MAXLOG) {
					return .result := inf;
				}
				if (x < MINLOG) {
					return .result := 0;
				}
				px: float64 := floor(LOG2E * x + 0.500000);
				x := x - px * c1;
				x := x - px * c2;
				xx: float64 := x * x;
				p: float64 := x * eval(xx, p2, p1, p0);
				q: float64 := eval(xx, q3, q2, q1, q0);
				return .result := ldexp((1) + (2) * p / (q - p), px);
			};
			static exp(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.exp)) != null) {
					return .result := float32.exp(x);
				}
				return .result := float32(exp(float64(x)));
			};
			static sqrt(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.sqrt)) != null) {
					return .result := float64.sqrt(x);
				}
				if (x == (0) || isNan(x) || isInf(x, 1)) {
					return .result := x;
				}
				if (x < (0)) {
					return .result := nan;
				}
				mask: typename := 2047;
				shift: typename := 64 - 11 - 1;
				bias: typename := 1023;
				ix: uint64 := Bits.fromFloat64(x);
				exp: int32 := int32((ix >> shift) & mask);
				if (exp == 0) {
					for ( ; (ix & (1 << shift)) == (0); ) {
						ix := ix << 1;
						exp := exp - 1;
					}
					exp := exp + 1;
				}
				exp := exp - bias;
				ix := ix & ~(mask << shift);
				ix := ix | 1 << shift;
				if ((exp & 1) == 1) {
					ix := ix << 1;
				}
				exp := exp >> 1;
				ix := ix << 1;
				s: uint64 := 0;
				q: uint64 := 0;
				r: uint64 := 1 << (shift + 1);
				for ( ; r != (0); ) {
					t: uint64 := s + r;
					if (t <= ix) {
						s := t + r;
						ix := ix - t;
						q := q + r;
					}
					ix := ix << 1;
					r := r >> 1;
				}
				if (ix != (0)) {
					q := q + (q & (1));
				}
				ix := (q >> 1) + (uint64(exp - 1 + bias) << shift);
				return .result := Bits.asFloat64(ix);
			};
			static sqrt(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.sqrt)) != null) {
					return .result := float32.sqrt(x);
				}
				return .result := float32(sqrt(float64(x)));
			};
			static pow(x: float64, y: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.pow)) != null) {
					return .result := float64.pow(x, y);
				}
				if (y == (0)) {
					return .result := 1;
				}
				flip: int32 := 0;
				if (y < (0)) {
					y := -y;
					flip := 1;
				}
				ye: float64;
				xy: float64 := 1;
				y1: float64 := modf(y, &ye);
				if (y1 != 0.000000) {
					if (x <= 0.000000) {
						if (x == (0) && !(flip)) {
							return .result := 0;
						}
						return .result := nan;
					}
					if (y1 > 0.500000) {
						y1 := y1 - (1);
						ye := ye + (1);
					}
					xy := exp(y1 * log(x));
				}
				if (ye > (2147483647)) {
					if (x <= (0)) {
						if (x == (0) && !(flip)) {
							return .result := 0;
						}
						return .result := nan;
					}
					if (flip) {
						if (y == 0.500000) {
							return .result := (1) / sqrt(x);
						}
						y := -y;
					}
					else if (y == 0.500000) {
						return .result := sqrt(x);
					}
					return .result := exp(y * log(x));
				}
				ex: int32;
				x := frexp(x, &ex);
				ey: int32 := 0;
				i: int64 := ye;
				if (i) {
					for ( ; ; ) {
						if (i & (1)) {
							xy := xy * x;
							ey := ey + ex;
						}
						i := i >> 1;
						if (i == (0)) {
							break;
						}
						x := x * x;
						ex := ex << 1;
						if (x < 0.500000) {
							x := x + x;
							ex := ex - 1;
						}
					}
				}
				if (flip) {
					xy := 1.000000 / xy;
					ey := -ey;
				}
				return .result := ldexp(xy, ey);
			};
			static pow(x: float32, y: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.pow)) != null) {
					return .result := float32.pow(x, y);
				}
				return .result := float32(pow(float64(x), float64(y)));
			};
			static sincos(x: float64, quad: int32): float64 := {
				if (x < (0)) {
					x := -x;
					quad := quad + 2;
				}
				y: float64;
				x := x * (2) / pi;
				if (x > (32764)) {
					e: float64;
					y := modf(x, &e);
					e := e + (quad);
					f: float64;
					modf(0.250000 * e, &f);
					quad := (e - (4) * f);
				}
				else {
					k: int32 := x;
					y := x - (k);
					quad := quad + k;
					quad := quad & 3;
				}
				if (quad & 1) {
					y := (1) - y;
				}
				if (quad > 1) {
					y := -y;
				}
				ysq: float64 := y * y;
				p: float64 := y * eval(ysq, p0, p1, p2, p3, p4);
				q: float64 := eval(ysq, q0, q1, q2, q3 + ysq);
				return .result := p / q;
			};
			static tancot(x: float64, flag: int32): float64 := {
				sign: float64 := 1;
				if (x < (0)) {
					x := -x;
					sign := (-1);
				}
				if (x > lossth) {
					return .result := 0;
				}
				y: float64 := floor(x / (pi / (4)));
				z: float64 := ldexp(y, -3);
				z := floor(z);
				z := y - ldexp(z, 3);
				j: int32 := z;
				if (j & 1) {
					j := j + 1;
					y := y + 1.000000;
				}
				z := ((x - y * dp1) - y * dp2) - y * dp3;
				zz: float64 := z * z;
				if (zz > 0.000000) {
					y := z + z * (zz * eval(zz, p2, p1, p0) / eval(zz, q4, q3, q2, q1, q0));
				}
				else {
					y := z;
				}
				if (j & 2) {
					if (flag) {
						y := -y;
					}
					else {
						y := (-1) / y;
					}
				}
				else if (flag) {
					y := (1) / y;
				}
				return .result := sign * y;
			};
			static atan(x: float64): float64 := {
				static xatan(x: float64): float64 := {
					z: float64 := x * x;
					p: float64 := eval(z, p0, p1, p2, p3, p4);
					q: float64 := eval(z, q0, q1, q2, q3, q4 + z);
					return .result := p / q * x;
				};
				static satan(x: float64): float64 := {
					if (x < sq2m1) {
						return .result := xatan(x);
					}
					if (x > sq2p1) {
						return .result := pi / (2) - xatan((1) / x);
					}
					return .result := pi / (4) + xatan((x - (1)) / (x + (1)));
				};
				if (x > (0)) {
					return .result := satan(x);
				}
				return .result := -satan(-x);
			};
			static atan2(arg1: float64, arg2: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.atan2)) != null) {
					return .result := float64.atan2(arg1, arg2);
				}
				if (arg1 + arg2 == arg1) {
					if (arg1 >= (0)) {
						return .result := pi / (2);
					}
					return .result := -pi / (2);
				}
				arg1 := atan(arg1 / arg2);
				if (arg2 < (0)) {
					if (arg1 <= (0)) {
						return .result := arg1 + pi;
					}
					return .result := arg1 - pi;
				}
				return .result := arg1;
			};
			static atan2(y: float32, x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.atan2)) != null) {
					return .result := float32.atan2(y, x);
				}
				return .result := float32(atan2(float64(y), float64(x)));
			};
			static sin(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.sin)) != null) {
					return .result := float64.sin(x);
				}
				return .result := sincos(x, 0);
			};
			static sin(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.sin)) != null) {
					return .result := float32.sin(x);
				}
				return .result := float32(sin(float64(x)));
			};
			static sinh(x: float64): float64 := x == (0) ? (0) : (exp(x) - exp(-x)) / (2);
			static asin(x: float64): float64 := atan2(x, sqrt(((1) + x) * ((1) - x)));
			static asinh(x: float64): float64 := log(x + sqrt((x * x) + (1)));
			static cos(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.cos)) != null) {
					return .result := float64.cos(x);
				}
				if (x < (0)) {
					x := -x;
				}
				return .result := sincos(x, 1);
			};
			static cos(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.cos)) != null) {
					return .result := float32.cos(x);
				}
				return .result := float32(cos(float64(x)));
			};
			static cosh(x: float64): float64 := x == (0) ? (1) : (exp(x) + exp(-x)) / (2);
			static acos(x: float64): float64 := atan2(sqrt(((1) + x) * ((1) - x)), x);
			static acosh(x: float64): float64 := log(x + sqrt(x * x - (1)));
			static tan(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.tan)) != null) {
					return .result := float64.tan(x);
				}
				if (x == (0)) {
					return .result := x;
				}
				if (x != x) {
					return .result := x;
				}
				if (x == (2) * x) {
					return .result := nan;
				}
				return .result := tancot(x, 0);
			};
			static tan(x: float32): float32 := {
				static if ((preferNativeCalls) && (typename(float32.tan)) != null) {
					return .result := float32.tan(x);
				}
				return .result := float32(tan(float64(x)));
			};
			static tanh(x: float64): float64 := (1) - (2) / (exp((2) * x) + (1));
			static atanh(x: float64): float64 := x >= (1) ? inf : x <= (-1) ? -inf : 0.500000 * log(((1) + x) / ((1) - x));
			static cot(x: float64): float64 := {
				static if ((preferNativeCalls) && (typename(float64.cot)) != null) {
					return .result := float64.cot(x);
				}
				if (x == (0)) {
					return .result := inf;
				}
				return .result := tancot(x, 1);
			};
			static coth(x: float64): float64 := (1) / tanh(x);
			static acot(x: float64): float64 := x == (0) ? pi / (2) : atan((1) / x);
			static acoth(x: float64): float64 := x == (1) ? inf : x == (-1) ? -inf : 0.500000 * log((x + (1)) / (x - (1)));
			static sec(x: float64): float64 := (1) / cos(x);
			static sech(x: float64): float64 := (1) / cosh(x);
			static asec(x: float64): float64 := x == (0) ? inf : acos((1) / x);
			static asech(x: float64): float64 := x == (0) ? inf : x == (1) ? (0) : log((sqrt((1) - x * x) + (1)) / x);
			static csc(x: float64): float64 := (1) / sin(x);
			static csch(x: float64): float64 := (1) / sinh(x);
			static acsc(x: float64): float64 := x == (0) ? inf : asin((1) / x);
			static acsch(x: float64): float64 := x == (0) ? inf : x < (0) ? log(((1) - sqrt((1) + x * x)) / x) : log(((1) + sqrt((1) + x * x)) / x);
			static radians(degrees: float64): float64 := float64(degrees * pi / (180));
			static degrees(radians: float64): float64 := float64(radians * (180) / pi);
		};
		static const Fixed: struct {
			value: int32 := 0;
			static const precision: int32 := 20;
			static const one: int32 := 1048576;
			static const nan: int32 := (2147483648);
			static const inf: int32 := 2147483647;
			static const half: int32 := 524288;
			static const mask: int32 := 1048575;
			static const pow2max: int32 := 11534336;
			static const mpi_28: int32 := 843314856;
			static const ln2_28: int32 := 186065279;
			static const lg2_28: int32 := 80807124;
			static const l2e_28: int32 := 387270501;
			static const l2t_28: int32 := 891723282;
			static const d2r_28: int32 := 4685082;
			static const r2d_24: int32 := 961263668;
			static const piMul2: int32 := 6588397;
			static const piDiv2: int32 := 1647099;
			static const pi: int32 := 3294198;
			static const ln2: int32 := 726817;
			static const lg2: int32 := 315652;
			static const l2e: int32 := 1512775;
			static const l2t: int32 := 3483294;
			static as(value: int32): Fixed := {
				return .result := {
			.result.value := value;
		};
			};
			static neg(a: Fixed): Fixed := {
				return .result := {
			.result.value := -a.value;
		};
			};
			static add(a: Fixed, b: Fixed): Fixed := {
				return .result := {
			.result.value := a.value + b.value;
		};
			};
			static sub(a: Fixed, b: Fixed): Fixed := {
				return .result := {
			.result.value := a.value - b.value;
		};
			};
			static mul(a: Fixed, b: Fixed): Fixed := {
				return .result := {
			.result.value := ((int64(a.value) * (b.value)) >> precision);
		};
			};
			static mul(a: Fixed, b: int32): Fixed := {
				return .result := {
			.result.value := a.value * b;
		};
			};
			static mul_28(a: Fixed, b: int32): Fixed := {
				return .result := {
			.result.value := (int64(a.value) * (b) >> 28);
		};
			};
			static div(a: Fixed, b: Fixed): Fixed := {
				if (b.value == 0) {
					if (a.value == 0) {
						return .result := as(nan);
					}
					return .result := as(a.value < 0 ? -inf : inf);
				}
				return .result := {
			.result.value := ((int64(a.value) << precision) / (b.value));
		};
			};
			static div(a: Fixed, b: int32): Fixed := {
				return .result := {
			.result.value := a.value / b;
		};
			};
			static mod(a: Fixed, b: Fixed): Fixed := {
				return .result := {
			.result.value := a.value % b.value;
		};
			};
			static inv(x: Fixed): Fixed := {
				if (x.value == 0) {
					return .result := {
			.result.value := inf;
		};
				}
				value: int64 := (int64(one) << precision) / (x.value);
				if (value >> 31 != value >> 63) {
					return .result := {
			.result.value := value < (0) ? -inf : inf;
		};
				}
				return .result := {
			.result.value := (value);
		};
			};
			static fract(x: Fixed): Fixed := {
				if (x.value < 0) {
					return .result := {
			.result.value := -(-x.value & mask);
		};
				}
				return .result := {
			.result.value := x.value & (nan | mask);
		};
			};
			static floor(x: Fixed): Fixed := {
				return .result := {
			.result.value := x.value & ~mask;
		};
			};
			static ceil(x: Fixed): Fixed := {
				return .result := neg(floor(neg(x)));
			};
			static round(x: Fixed): Fixed := {
				return .result := floor(as(x.value + half));
			};
			static isFinite(x: Fixed): bool := {
				if (x.value == nan) {
					return .result := false;
				}
				if (x.value == inf) {
					return .result := false;
				}
				if (x.value == -inf) {
					return .result := false;
				}
				return .result := true;
			};
			static isNan(x: Fixed): bool := {
				return .result := x.value == nan;
			};
			static compare(a: Fixed, b: Fixed): int32 := {
				return .result := int32(a.value < b.value) - int32(a.value > b.value);
			};
			static log2(x: Fixed): Fixed := {
				static const tbl_log2: uint32[257] := {
					tbl_log2[0] := (0);
					tbl_log2[1] := (6039313);
					tbl_log2[2] := (12055173);
					tbl_log2[3] := (18047761);
					tbl_log2[4] := (24017256);
					tbl_log2[5] := (29963835);
					tbl_log2[6] := (35887674);
					tbl_log2[7] := (41788946);
					tbl_log2[8] := (47667822);
					tbl_log2[9] := (53524472);
					tbl_log2[10] := (59359063);
					tbl_log2[11] := (65171760);
					tbl_log2[12] := (70962727);
					tbl_log2[13] := (76732127);
					tbl_log2[14] := (82480119);
					tbl_log2[15] := (88206861);
					tbl_log2[16] := (93912510);
					tbl_log2[17] := (99597221);
					tbl_log2[18] := (105261147);
					tbl_log2[19] := (110904439);
					tbl_log2[20] := (116527248);
					tbl_log2[21] := (122129720);
					tbl_log2[22] := (127712004);
					tbl_log2[23] := (133274243);
					tbl_log2[24] := (138816582);
					tbl_log2[25] := (144339162);
					tbl_log2[26] := (149842123);
					tbl_log2[27] := (155325605);
					tbl_log2[28] := (160789745);
					tbl_log2[29] := (166234678);
					tbl_log2[30] := (171660540);
					tbl_log2[31] := (177067464);
					tbl_log2[32] := (182455580);
					tbl_log2[33] := (187825021);
					tbl_log2[34] := (193175914);
					tbl_log2[35] := (198508387);
					tbl_log2[36] := (203822568);
					tbl_log2[37] := (209118580);
					tbl_log2[38] := (214396547);
					tbl_log2[39] := (219656593);
					tbl_log2[40] := (224898838);
					tbl_log2[41] := (230123403);
					tbl_log2[42] := (235330406);
					tbl_log2[43] := (240519966);
					tbl_log2[44] := (245692198);
					tbl_log2[45] := (250847217);
					tbl_log2[46] := (255985139);
					tbl_log2[47] := (261106076);
					tbl_log2[48] := (266210140);
					tbl_log2[49] := (271297442);
					tbl_log2[50] := (276368091);
					tbl_log2[51] := (281422197);
					tbl_log2[52] := (286459866);
					tbl_log2[53] := (291481206);
					tbl_log2[54] := (296486322);
					tbl_log2[55] := (301475318);
					tbl_log2[56] := (306448299);
					tbl_log2[57] := (311405365);
					tbl_log2[58] := (316346620);
					tbl_log2[59] := (321272163);
					tbl_log2[60] := (326182094);
					tbl_log2[61] := (331076512);
					tbl_log2[62] := (335955515);
					tbl_log2[63] := (340819198);
					tbl_log2[64] := (345667659);
					tbl_log2[65] := (350500992);
					tbl_log2[66] := (355319292);
					tbl_log2[67] := (360122651);
					tbl_log2[68] := (364911161);
					tbl_log2[69] := (369684916);
					tbl_log2[70] := (374444004);
					tbl_log2[71] := (379188516);
					tbl_log2[72] := (383918541);
					tbl_log2[73] := (388634167);
					tbl_log2[74] := (393335482);
					tbl_log2[75] := (398022572);
					tbl_log2[76] := (402695523);
					tbl_log2[77] := (407354419);
					tbl_log2[78] := (411999346);
					tbl_log2[79] := (416630387);
					tbl_log2[80] := (421247625);
					tbl_log2[81] := (425851141);
					tbl_log2[82] := (430441017);
					tbl_log2[83] := (435017333);
					tbl_log2[84] := (439580170);
					tbl_log2[85] := (444129606);
					tbl_log2[86] := (448665721);
					tbl_log2[87] := (453188591);
					tbl_log2[88] := (457698295);
					tbl_log2[89] := (462194907);
					tbl_log2[90] := (466678505);
					tbl_log2[91] := (471149164);
					tbl_log2[92] := (475606957);
					tbl_log2[93] := (480051958);
					tbl_log2[94] := (484484242);
					tbl_log2[95] := (488903880);
					tbl_log2[96] := (493310944);
					tbl_log2[97] := (497705506);
					tbl_log2[98] := (502087636);
					tbl_log2[99] := (506457405);
					tbl_log2[100] := (510814881);
					tbl_log2[101] := (515160135);
					tbl_log2[102] := (519493235);
					tbl_log2[103] := (523814247);
					tbl_log2[104] := (528123240);
					tbl_log2[105] := (532420281);
					tbl_log2[106] := (536705434);
					tbl_log2[107] := (540978766);
					tbl_log2[108] := (545240343);
					tbl_log2[109] := (549490227);
					tbl_log2[110] := (553728484);
					tbl_log2[111] := (557955177);
					tbl_log2[112] := (562170369);
					tbl_log2[113] := (566374122);
					tbl_log2[114] := (570566498);
					tbl_log2[115] := (574747559);
					tbl_log2[116] := (578917365);
					tbl_log2[117] := (583075977);
					tbl_log2[118] := (587223454);
					tbl_log2[119] := (591359857);
					tbl_log2[120] := (595485245);
					tbl_log2[121] := (599599675);
					tbl_log2[122] := (603703206);
					tbl_log2[123] := (607795895);
					tbl_log2[124] := (611877800);
					tbl_log2[125] := (615948977);
					tbl_log2[126] := (620009483);
					tbl_log2[127] := (624059372);
					tbl_log2[128] := (628098702);
					tbl_log2[129] := (632127526);
					tbl_log2[130] := (636145899);
					tbl_log2[131] := (640153876);
					tbl_log2[132] := (644151509);
					tbl_log2[133] := (648138852);
					tbl_log2[134] := (652115958);
					tbl_log2[135] := (656082880);
					tbl_log2[136] := (660039669);
					tbl_log2[137] := (663986377);
					tbl_log2[138] := (667923055);
					tbl_log2[139] := (671849754);
					tbl_log2[140] := (675766525);
					tbl_log2[141] := (679673417);
					tbl_log2[142] := (683570481);
					tbl_log2[143] := (687457765);
					tbl_log2[144] := (691335319);
					tbl_log2[145] := (695203191);
					tbl_log2[146] := (699061430);
					tbl_log2[147] := (702910083);
					tbl_log2[148] := (706749198);
					tbl_log2[149] := (710578821);
					tbl_log2[150] := (714399001);
					tbl_log2[151] := (718209783);
					tbl_log2[152] := (722011213);
					tbl_log2[153] := (725803337);
					tbl_log2[154] := (729586201);
					tbl_log2[155] := (733359850);
					tbl_log2[156] := (737124328);
					tbl_log2[157] := (740879680);
					tbl_log2[158] := (744625950);
					tbl_log2[159] := (748363182);
					tbl_log2[160] := (752091420);
					tbl_log2[161] := (755810706);
					tbl_log2[162] := (759521084);
					tbl_log2[163] := (763222596);
					tbl_log2[164] := (766915284);
					tbl_log2[165] := (770599191);
					tbl_log2[166] := (774274358);
					tbl_log2[167] := (777940826);
					tbl_log2[168] := (781598636);
					tbl_log2[169] := (785247830);
					tbl_log2[170] := (788888447);
					tbl_log2[171] := (792520529);
					tbl_log2[172] := (796144114);
					tbl_log2[173] := (799759243);
					tbl_log2[174] := (803365955);
					tbl_log2[175] := (806964288);
					tbl_log2[176] := (810554283);
					tbl_log2[177] := (814135977);
					tbl_log2[178] := (817709409);
					tbl_log2[179] := (821274616);
					tbl_log2[180] := (824831638);
					tbl_log2[181] := (828380510);
					tbl_log2[182] := (831921270);
					tbl_log2[183] := (835453956);
					tbl_log2[184] := (838978604);
					tbl_log2[185] := (842495250);
					tbl_log2[186] := (846003931);
					tbl_log2[187] := (849504683);
					tbl_log2[188] := (852997541);
					tbl_log2[189] := (856482541);
					tbl_log2[190] := (859959719);
					tbl_log2[191] := (863429109);
					tbl_log2[192] := (866890746);
					tbl_log2[193] := (870344665);
					tbl_log2[194] := (873790900);
					tbl_log2[195] := (877229485);
					tbl_log2[196] := (880660455);
					tbl_log2[197] := (884083842);
					tbl_log2[198] := (887499680);
					tbl_log2[199] := (890908002);
					tbl_log2[200] := (894308843);
					tbl_log2[201] := (897702233);
					tbl_log2[202] := (901088206);
					tbl_log2[203] := (904466794);
					tbl_log2[204] := (907838029);
					tbl_log2[205] := (911201943);
					tbl_log2[206] := (914558569);
					tbl_log2[207] := (917907937);
					tbl_log2[208] := (921250078);
					tbl_log2[209] := (924585025);
					tbl_log2[210] := (927912807);
					tbl_log2[211] := (931233455);
					tbl_log2[212] := (934547001);
					tbl_log2[213] := (937853474);
					tbl_log2[214] := (941152904);
					tbl_log2[215] := (944445322);
					tbl_log2[216] := (947730757);
					tbl_log2[217] := (951009239);
					tbl_log2[218] := (954280797);
					tbl_log2[219] := (957545460);
					tbl_log2[220] := (960803257);
					tbl_log2[221] := (964054217);
					tbl_log2[222] := (967298369);
					tbl_log2[223] := (970535741);
					tbl_log2[224] := (973766362);
					tbl_log2[225] := (976990259);
					tbl_log2[226] := (980207460);
					tbl_log2[227] := (983417994);
					tbl_log2[228] := (986621888);
					tbl_log2[229] := (989819169);
					tbl_log2[230] := (993009864);
					tbl_log2[231] := (996194001);
					tbl_log2[232] := (999371606);
					tbl_log2[233] := (1002542706);
					tbl_log2[234] := (1005707329);
					tbl_log2[235] := (1008865499);
					tbl_log2[236] := (1012017244);
					tbl_log2[237] := (1015162589);
					tbl_log2[238] := (1018301561);
					tbl_log2[239] := (1021434184);
					tbl_log2[240] := (1024560486);
					tbl_log2[241] := (1027680491);
					tbl_log2[242] := (1030794225);
					tbl_log2[243] := (1033901713);
					tbl_log2[244] := (1037002979);
					tbl_log2[245] := (1040098049);
					tbl_log2[246] := (1043186947);
					tbl_log2[247] := (1046269698);
					tbl_log2[248] := (1049346327);
					tbl_log2[249] := (1052416857);
					tbl_log2[250] := (1055481313);
					tbl_log2[251] := (1058539719);
					tbl_log2[252] := (1061592098);
					tbl_log2[253] := (1064638475);
					tbl_log2[254] := (1067678872);
					tbl_log2[255] := (1070713314);
					tbl_log2[256] := (1073741824);
				};
				if (x.value <= 0) {
					if (x.value == 0) {
						return .result := {
			.result.value := -inf;
		};
					}
					return .result := {
			.result.value := nan;
		};
				}
				n: int32 := Bits.scanReverse(x.value);
				static if (precision < 8) {
					error_not_implemented_yet
				}
				idx: uint32 := (n > 8 ? x.value >> n - 8 : x.value << 8 - n) & 255;
				value: int32 := tbl_log2[idx];
				static if (precision > 8) {
					mix: uint32 := (n > 16 ? x.value >> n - 16 : x.value << 16 - n) & 255;
					value := value + (mix * (tbl_log2[idx + (1)] - (value)) >> 8);
				}
				return .result := {
			.result.value := (n - precision << precision) + (value >> 30 - precision);
		};
			};
			static log(x: Fixed): Fixed := {
				x := log2(x);
				if (!isFinite(x)) {
					return .result := x;
				}
				return .result := mul_28(x, ln2_28);
			};
			static log10(x: Fixed): Fixed := {
				x := log2(x);
				if (!isFinite(x)) {
					return .result := x;
				}
				return .result := mul_28(x, lg2_28);
			};
			static log(x: Fixed, base: Fixed): Fixed := {
				x := log2(x);
				if (!isFinite(x)) {
					return .result := x;
				}
				base := log2(base);
				if (!isFinite(base)) {
					return .result := base;
				}
				return .result := div(x, base);
			};
			static pow2(x: Fixed): Fixed := {
				static const tbl_pow2: uint32[257] := {
					tbl_pow2[0] := (1073741824);
					tbl_pow2[1] := (1076653033);
					tbl_pow2[2] := (1079572135);
					tbl_pow2[3] := (1082499152);
					tbl_pow2[4] := (1085434105);
					tbl_pow2[5] := (1088377016);
					tbl_pow2[6] := (1091327905);
					tbl_pow2[7] := (1094286795);
					tbl_pow2[8] := (1097253708);
					tbl_pow2[9] := (1100228664);
					tbl_pow2[10] := (1103211687);
					tbl_pow2[11] := (1106202797);
					tbl_pow2[12] := (1109202017);
					tbl_pow2[13] := (1112209369);
					tbl_pow2[14] := (1115224875);
					tbl_pow2[15] := (1118248556);
					tbl_pow2[16] := (1121280435);
					tbl_pow2[17] := (1124320535);
					tbl_pow2[18] := (1127368877);
					tbl_pow2[19] := (1130425484);
					tbl_pow2[20] := (1133490379);
					tbl_pow2[21] := (1136563583);
					tbl_pow2[22] := (1139645119);
					tbl_pow2[23] := (1142735011);
					tbl_pow2[24] := (1145833280);
					tbl_pow2[25] := (1148939949);
					tbl_pow2[26] := (1152055041);
					tbl_pow2[27] := (1155178579);
					tbl_pow2[28] := (1158310586);
					tbl_pow2[29] := (1161451085);
					tbl_pow2[30] := (1164600098);
					tbl_pow2[31] := (1167757649);
					tbl_pow2[32] := (1170923761);
					tbl_pow2[33] := (1174098458);
					tbl_pow2[34] := (1177281762);
					tbl_pow2[35] := (1180473696);
					tbl_pow2[36] := (1183674285);
					tbl_pow2[37] := (1186883552);
					tbl_pow2[38] := (1190101520);
					tbl_pow2[39] := (1193328212);
					tbl_pow2[40] := (1196563653);
					tbl_pow2[41] := (1199807866);
					tbl_pow2[42] := (1203060875);
					tbl_pow2[43] := (1206322704);
					tbl_pow2[44] := (1209593377);
					tbl_pow2[45] := (1212872917);
					tbl_pow2[46] := (1216161349);
					tbl_pow2[47] := (1219458697);
					tbl_pow2[48] := (1222764985);
					tbl_pow2[49] := (1226080238);
					tbl_pow2[50] := (1229404478);
					tbl_pow2[51] := (1232737732);
					tbl_pow2[52] := (1236080023);
					tbl_pow2[53] := (1239431376);
					tbl_pow2[54] := (1242791815);
					tbl_pow2[55] := (1246161366);
					tbl_pow2[56] := (1249540052);
					tbl_pow2[57] := (1252927899);
					tbl_pow2[58] := (1256324931);
					tbl_pow2[59] := (1259731173);
					tbl_pow2[60] := (1263146651);
					tbl_pow2[61] := (1266571389);
					tbl_pow2[62] := (1270005412);
					tbl_pow2[63] := (1273448746);
					tbl_pow2[64] := (1276901416);
					tbl_pow2[65] := (1280363447);
					tbl_pow2[66] := (1283834865);
					tbl_pow2[67] := (1287315694);
					tbl_pow2[68] := (1290805961);
					tbl_pow2[69] := (1294305691);
					tbl_pow2[70] := (1297814910);
					tbl_pow2[71] := (1301333643);
					tbl_pow2[72] := (1304861916);
					tbl_pow2[73] := (1308399756);
					tbl_pow2[74] := (1311947188);
					tbl_pow2[75] := (1315504237);
					tbl_pow2[76] := (1319070931);
					tbl_pow2[77] := (1322647295);
					tbl_pow2[78] := (1326233356);
					tbl_pow2[79] := (1329829139);
					tbl_pow2[80] := (1333434672);
					tbl_pow2[81] := (1337049980);
					tbl_pow2[82] := (1340675090);
					tbl_pow2[83] := (1344310029);
					tbl_pow2[84] := (1347954823);
					tbl_pow2[85] := (1351609500);
					tbl_pow2[86] := (1355274085);
					tbl_pow2[87] := (1358948606);
					tbl_pow2[88] := (1362633089);
					tbl_pow2[89] := (1366327562);
					tbl_pow2[90] := (1370032052);
					tbl_pow2[91] := (1373746586);
					tbl_pow2[92] := (1377471191);
					tbl_pow2[93] := (1381205894);
					tbl_pow2[94] := (1384950723);
					tbl_pow2[95] := (1388705705);
					tbl_pow2[96] := (1392470868);
					tbl_pow2[97] := (1396246240);
					tbl_pow2[98] := (1400031847);
					tbl_pow2[99] := (1403827719);
					tbl_pow2[100] := (1407633882);
					tbl_pow2[101] := (1411450365);
					tbl_pow2[102] := (1415277195);
					tbl_pow2[103] := (1419114400);
					tbl_pow2[104] := (1422962010);
					tbl_pow2[105] := (1426820051);
					tbl_pow2[106] := (1430688553);
					tbl_pow2[107] := (1434567543);
					tbl_pow2[108] := (1438457050);
					tbl_pow2[109] := (1442357103);
					tbl_pow2[110] := (1446267730);
					tbl_pow2[111] := (1450188959);
					tbl_pow2[112] := (1454120821);
					tbl_pow2[113] := (1458063342);
					tbl_pow2[114] := (1462016553);
					tbl_pow2[115] := (1465980482);
					tbl_pow2[116] := (1469955158);
					tbl_pow2[117] := (1473940611);
					tbl_pow2[118] := (1477936869);
					tbl_pow2[119] := (1481943963);
					tbl_pow2[120] := (1485961920);
					tbl_pow2[121] := (1489990772);
					tbl_pow2[122] := (1494030547);
					tbl_pow2[123] := (1498081274);
					tbl_pow2[124] := (1502142985);
					tbl_pow2[125] := (1506215708);
					tbl_pow2[126] := (1510299473);
					tbl_pow2[127] := (1514394310);
					tbl_pow2[128] := (1518500249);
					tbl_pow2[129] := (1522617321);
					tbl_pow2[130] := (1526745556);
					tbl_pow2[131] := (1530884983);
					tbl_pow2[132] := (1535035633);
					tbl_pow2[133] := (1539197537);
					tbl_pow2[134] := (1543370725);
					tbl_pow2[135] := (1547555227);
					tbl_pow2[136] := (1551751075);
					tbl_pow2[137] := (1555958299);
					tbl_pow2[138] := (1560176930);
					tbl_pow2[139] := (1564406999);
					tbl_pow2[140] := (1568648537);
					tbl_pow2[141] := (1572901574);
					tbl_pow2[142] := (1577166143);
					tbl_pow2[143] := (1581442274);
					tbl_pow2[144] := (1585729999);
					tbl_pow2[145] := (1590029349);
					tbl_pow2[146] := (1594340356);
					tbl_pow2[147] := (1598663051);
					tbl_pow2[148] := (1602997467);
					tbl_pow2[149] := (1607343634);
					tbl_pow2[150] := (1611701584);
					tbl_pow2[151] := (1616071351);
					tbl_pow2[152] := (1620452965);
					tbl_pow2[153] := (1624846458);
					tbl_pow2[154] := (1629251864);
					tbl_pow2[155] := (1633669214);
					tbl_pow2[156] := (1638098541);
					tbl_pow2[157] := (1642539876);
					tbl_pow2[158] := (1646993254);
					tbl_pow2[159] := (1651458705);
					tbl_pow2[160] := (1655936264);
					tbl_pow2[161] := (1660425963);
					tbl_pow2[162] := (1664927834);
					tbl_pow2[163] := (1669441912);
					tbl_pow2[164] := (1673968228);
					tbl_pow2[165] := (1678506816);
					tbl_pow2[166] := (1683057710);
					tbl_pow2[167] := (1687620942);
					tbl_pow2[168] := (1692196547);
					tbl_pow2[169] := (1696784557);
					tbl_pow2[170] := (1701385007);
					tbl_pow2[171] := (1705997929);
					tbl_pow2[172] := (1710623359);
					tbl_pow2[173] := (1715261329);
					tbl_pow2[174] := (1719911875);
					tbl_pow2[175] := (1724575029);
					tbl_pow2[176] := (1729250826);
					tbl_pow2[177] := (1733939301);
					tbl_pow2[178] := (1738640487);
					tbl_pow2[179] := (1743354420);
					tbl_pow2[180] := (1748081133);
					tbl_pow2[181] := (1752820662);
					tbl_pow2[182] := (1757573041);
					tbl_pow2[183] := (1762338305);
					tbl_pow2[184] := (1767116488);
					tbl_pow2[185] := (1771907627);
					tbl_pow2[186] := (1776711756);
					tbl_pow2[187] := (1781528911);
					tbl_pow2[188] := (1786359125);
					tbl_pow2[189] := (1791202436);
					tbl_pow2[190] := (1796058879);
					tbl_pow2[191] := (1800928488);
					tbl_pow2[192] := (1805811301);
					tbl_pow2[193] := (1810707352);
					tbl_pow2[194] := (1815616678);
					tbl_pow2[195] := (1820539314);
					tbl_pow2[196] := (1825475297);
					tbl_pow2[197] := (1830424662);
					tbl_pow2[198] := (1835387447);
					tbl_pow2[199] := (1840363687);
					tbl_pow2[200] := (1845353419);
					tbl_pow2[201] := (1850356680);
					tbl_pow2[202] := (1855373506);
					tbl_pow2[203] := (1860403934);
					tbl_pow2[204] := (1865448001);
					tbl_pow2[205] := (1870505743);
					tbl_pow2[206] := (1875577199);
					tbl_pow2[207] := (1880662405);
					tbl_pow2[208] := (1885761398);
					tbl_pow2[209] := (1890874215);
					tbl_pow2[210] := (1896000895);
					tbl_pow2[211] := (1901141475);
					tbl_pow2[212] := (1906295993);
					tbl_pow2[213] := (1911464486);
					tbl_pow2[214] := (1916646992);
					tbl_pow2[215] := (1921843549);
					tbl_pow2[216] := (1927054195);
					tbl_pow2[217] := (1932278969);
					tbl_pow2[218] := (1937517909);
					tbl_pow2[219] := (1942771053);
					tbl_pow2[220] := (1948038440);
					tbl_pow2[221] := (1953320108);
					tbl_pow2[222] := (1958616096);
					tbl_pow2[223] := (1963926443);
					tbl_pow2[224] := (1969251187);
					tbl_pow2[225] := (1974590369);
					tbl_pow2[226] := (1979944027);
					tbl_pow2[227] := (1985312199);
					tbl_pow2[228] := (1990694927);
					tbl_pow2[229] := (1996092248);
					tbl_pow2[230] := (2001504204);
					tbl_pow2[231] := (2006930832);
					tbl_pow2[232] := (2012372173);
					tbl_pow2[233] := (2017828268);
					tbl_pow2[234] := (2023299155);
					tbl_pow2[235] := (2028784876);
					tbl_pow2[236] := (2034285470);
					tbl_pow2[237] := (2039800977);
					tbl_pow2[238] := (2045331439);
					tbl_pow2[239] := (2050876895);
					tbl_pow2[240] := (2056437386);
					tbl_pow2[241] := (2062012953);
					tbl_pow2[242] := (2067603638);
					tbl_pow2[243] := (2073209480);
					tbl_pow2[244] := (2078830521);
					tbl_pow2[245] := (2084466802);
					tbl_pow2[246] := (2090118365);
					tbl_pow2[247] := (2095785251);
					tbl_pow2[248] := (2101467501);
					tbl_pow2[249] := (2107165158);
					tbl_pow2[250] := (2112878262);
					tbl_pow2[251] := (2118606856);
					tbl_pow2[252] := (2124350982);
					tbl_pow2[253] := (2130110682);
					tbl_pow2[254] := (2135885998);
					tbl_pow2[255] := (2141676972);
					tbl_pow2[256] := (2147483648);
				};
				if (x.value > pow2max) {
					return .result := as(inf);
				}
				if (x.value <= -pow2max) {
					if (isNan(x)) {
						return .result := x;
					}
					return .result := as(0);
				}
				idx: uint32 := (x.value >> (precision - 8)) & 255;
				static if (precision < 8) {
					error_not_implemented_yet
				}
				q: uint32 := tbl_pow2[idx];
				static if (precision > 8) {
					mix: uint32 := (precision > 16 ? x.value >> (precision - 16) : x.value << (16 - precision)) & 255;
					q := q + (mix * (tbl_pow2[idx + (1)] - q) >> 8);
				}
				n: int32 := (x.value >> precision) - (30 - precision);
				return .result := as(n < 0 ? q >> -n : q << n);
			};
			static exp(x: Fixed): Fixed := {
				return .result := pow2(mul_28(x, l2e_28));
			};
			static exp10(x: Fixed): Fixed := {
				return .result := pow2(mul_28(x, l2t_28));
			};
			static sqrt(x: Fixed): Fixed := {
				if (x.value <= 0) {
					if (x.value < 0) {
						return .result := as(nan);
					}
					return .result := as(0);
				}
				static if ((precision & 1) != 0) {
					return .result := pow2(div(log2(x), 2));
				}
				root: uint32 := 0;
				remHi: uint32 := 0;
				remLo: uint32 := x.value;
				for (count: uint32 := 16 + (precision >> 1); count != (0); count := count - (1)) {
					remHi := (remHi << 2) | (remLo >> 30);
					remLo := remLo << 2;
					root := root << 1;
					testDiv: uint32 := (root << 1) + (1);
					if (remHi >= testDiv) {
						remHi := remHi - testDiv;
						root := root + (1);
					}
				}
				return .result := as(root);
			};
			static pow(x: Fixed, y: Fixed): Fixed := {
				if (y.value == 0 || x.value == one) {
					return .result := as(one);
				}
				if (y.value == one) {
					return .result := x;
				}
				if (y.value == half) {
					return .result := sqrt(x);
				}
				if (x.value == nan || y.value == nan) {
					return .result := as(nan);
				}
				if (x.value == 0) {
					if (y.value < 0) {
						return .result := as(inf);
					}
					return .result := as(0);
				}
				if ((y.value & mask) == 0) {
					res: int32 := one;
					sqr: int64 := x.value;
					pow: int32 := (y.value < 0 ? -y.value : y.value) >> precision;
					for ( ; pow != 0; ) {
						if ((pow & 1) != 0) {
							res := ((res) * sqr >> precision);
						}
						sqr := sqr * sqr >> precision;
						pow := pow >> 1;
					}
					return .result := y.value < 0 ? inv(as(res)) : as(res);
				}
				return .result := pow2(mul(y, log2(x)));
			};
			static horner(x: int32, a0: int32, a1: int32): int32 := a0 + int32((a1) * int64(x) >> precision);
			static horner(x: int32, a0: int32, a1: int32, a2: int32): int32 := horner(x, a0, horner(x, a1, a2));
			static horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32): int32 := horner(x, a0, horner(x, a1, a2, a3));
			static horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32, a4: int32): int32 := horner(x, a0, horner(x, a1, a2, a3, a4));
			static horner(x: int32, a0: int32, a1: int32, a2: int32, a3: int32, a4: int32, a5: int32): int32 := horner(x, a0, horner(x, a1, a2, a3, a4, a5));
			static sin(x: Fixed): Fixed := {
				x.value := x.value % piMul2;
				if (x.value < 0) {
					x.value := x.value + piMul2;
				}
				sign: int32 := 1;
				if (x.value >= pi) {
					x.value := x.value - pi;
					sign := -1;
				}
				if (x.value >= piDiv2) {
					x.value := pi - x.value;
				}
				xsq: int32 := int64(x.value) * (x.value) >> precision;
				res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5);
				return .result := mul(x, as(sign * res));
			};
			static sinh(x: Fixed): Fixed := {
				if (x.value == 0) {
					return .result := as(0);
				}
				if (!isFinite(x)) {
					return .result := x;
				}
				return .result := div(sub(exp(x), exp(neg(x))), 2);
			};
			static cos(x: Fixed): Fixed := {
				x.value := x.value % piMul2;
				if (x.value < 0) {
					x.value := x.value + piMul2;
				}
				if (x.value > pi) {
					x.value := piMul2 - x.value;
				}
				sign: int32 := 1;
				if (x.value >= piDiv2) {
					x.value := x.value - pi;
					sign := -1;
				}
				xsq: int32 := int64(x.value) * (x.value) >> precision;
				res: int32 := horner(xsq, p0, p1, p2, p3, p4, p5);
				return .result := as(sign * res);
			};
			static tan(x: Fixed): Fixed := {
				return .result := div(sin(x), cos(x));
			};
			static degrees(radians: Fixed): Fixed := {
				return .result := as((radians.value) * int64(r2d_24) >> 24);
			};
			static radians(degrees: Fixed): Fixed := {
				return .result := mul_28(degrees, d2r_28);
			};
		};
		Fixed(value: int32): Fixed := Fixed.as(value << Fixed.precision);
		int32(const value: Fixed): int32 := value.value >> Fixed.precision;
		static Fixed(value: float64): Fixed := {
			result: Fixed := Fixed.as(value * ((1 << Fixed.precision)));
			if (result.value == Fixed.nan) {
				if (value != value) {
					result.value := Fixed.nan;
				}
				else if (value > (0)) {
					result.value := Fixed.inf;
				}
				else if (value < (0)) {
					result.value := -Fixed.inf;
				}
			}
			return .result := result;
		};
		static float64(value: Fixed): float64 := {
			if (value.value == Fixed.nan) {
				return .result := Math.nan;
			}
			if (value.value == Fixed.inf) {
				return .result := Math.inf;
			}
			if (value.value == -Fixed.inf) {
				return .result := -Math.inf;
			}
			return .result := (value.value) / float64(1 << Fixed.precision);
		};
		static const Complex: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static Complex(value: float64): Complex := {
			return .result := {
			.result.re := value;
			.result.im := (0);
		};
		};
		static Complex(real: float64, imaginary: float64): Complex := {
			return .result := {
			.result.re := real;
			.result.im := imaginary;
		};
		};
		neg(a: Complex): Complex := Complex(emit(struct(a), neg.p2d));
		add(a: Complex, b: Complex): Complex := Complex(emit(struct(a), struct(b), add.p2d));
		add(a: Complex, b: float64): Complex := Complex(a.re + b, a.im);
		add(a: float64, b: Complex): Complex := Complex(a + b.re, b.im);
		sub(a: Complex, b: Complex): Complex := Complex(emit(struct(a), struct(b), sub.p2d));
		sub(a: Complex, b: float64): Complex := Complex(a.re - b, a.im);
		sub(a: float64, b: Complex): Complex := Complex(a - b.re, b.im);
		mul(a: Complex, b: Complex): Complex := Complex(emit(struct(a), struct(b), swz.x2, mul.p2d, add.f64, struct(a), struct(b), mul.p2d, swz.x2, sub.f64));
		mul(a: Complex, b: float64): Complex := Complex(a.re * b, a.im * b);
		mul(a: float64, b: Complex): Complex := Complex(a * b.re, a * b.im);
		static div(a: Complex, b: Complex): Complex := {
			if (Math.abs(b.re) >= Math.abs(b.im)) {
				r: float64 := b.im / b.re;
				den: float64 := b.re + r * b.im;
				return .result := {
			.result.re := (a.re + r * a.im) / den;
			.result.im := (a.im - r * a.re) / den;
		};
			}
			r: float64 := b.re / b.im;
			den: float64 := b.im + r * b.re;
			return .result := {
			.result.re := (a.re * r + a.im) / den;
			.result.im := (a.im * r - a.re) / den;
		};
		};
		div(a: Complex, b: float64): Complex := div(a, Complex(b));
		div(a: float64, b: Complex): Complex := div(Complex(a), b);
		abs(a: Complex): float64 := Math.sqrt(a.re * a.re + a.im * a.im);
		arg(a: Complex): float64 := Math.atan2(a.re, a.im);
		static inv(a: Complex): Complex := {
			d: float64 := a.re * a.re + a.im * a.im;
			return .result := {
			.result.re := +a.re / d;
			.result.im := -a.im / d;
		};
		};
		conj(a: Complex): Complex := Complex(a.re, -a.im);
		exp(a: Complex): Complex := Complex(Math.exp(a.re) * Math.cos(a.im), Math.exp(a.re) * Math.sin(a.im));
		log(a: Complex): Complex := Complex(Math.log(abs(a)), arg(a));
		static pow(a: Complex, b: Complex): Complex := {
			r: float64 := abs(a);
			t: float64 := arg(a);
			u: float64 := b.re * t + b.im * Math.log(r);
			v: float64 := Math.pow(r, b.re) * Math.exp(-b.im * t);
			return .result := {
			.result.re := v * Math.cos(u);
			.result.im := v * Math.sin(u);
		};
		};
		pow(a: Complex, b: float64): Complex := pow(a, Complex(b));
		sin(a: Complex): Complex := Complex(Math.sin(a.re) * Math.cosh(a.im), +Math.cos(a.re) * Math.sinh(a.im));
		cos(a: Complex): Complex := Complex(Math.cos(a.re) * Math.cosh(a.im), -Math.sin(a.re) * Math.sinh(a.im));
		tan(a: Complex): Complex := div(sin(a), cos(a));
		cot(a: Complex): Complex := div(cos(a), sin(a));
		sec(a: Complex): Complex := inv(cos(a));
		csc(a: Complex): Complex := inv(sin(a));
		sinh(a: Complex): Complex := div(sub(exp(a), exp(neg(a))), 2);
		cosh(a: Complex): Complex := div(add(exp(a), exp(neg(a))), 2);
		tanh(a: Complex): Complex := div(sub(exp(mul(2, a)), 1), add(exp(mul(2, a)), 1));
		coth(a: Complex): Complex := div(add(exp(mul(2, a)), 1), sub(exp(mul(2, a)), 1));
		sech(a: Complex): Complex := inv(cosh(a));
		csch(a: Complex): Complex := inv(sinh(a));
		toCartesian(x: Complex): Complex := Complex(x.re * Math.cos(x.im), x.re * Math.sin(x.im));
		toPolar(x: Complex): Complex := Complex(abs(x), arg(x));
		static const vec4f: struct {
			<?>: <?>;
			x: float32 := x: float32;
			y: float32 := y: float32;
			z: float32 := z: float32;
			w: float32 := w: float32;
			data: float32[4];
		};
		vec4f(x: float32, y: float32, z: float32, w: float32): vec4f := vec4f(emit(struct(w), struct(z), struct(y), struct(x)));
		vec4f(x: float32, y: float32, z: float32): vec4f := vec4f(x, y, z, 1.000000);
		vec4f(x: float32, y: float32): vec4f := vec4f(x, y, 0.000000, 1.000000);
		vec4f(xyz: vec4f, w: float32): vec4f := vec4f(xyz.x, xyz.y, xyz.z, w);
		vec4f(val: float32): vec4f := vec4f(val, val, val, val);
		neg(rhs: vec4f): vec4f := vec4f(emit(struct(rhs), neg.p4f));
		add(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), add.p4f));
		sub(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), sub.p4f));
		mul(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), mul.p4f));
		div(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), div.p4f));
		add(a: float32, b: vec4f): vec4f := add(vec4f(a), b);
		add(a: vec4f, b: float32): vec4f := add(a, vec4f(b));
		sub(a: float32, b: vec4f): vec4f := sub(vec4f(a), b);
		sub(a: vec4f, b: float32): vec4f := sub(a, vec4f(b));
		mul(a: float32, b: vec4f): vec4f := mul(vec4f(a), b);
		mul(a: vec4f, b: float32): vec4f := mul(a, vec4f(b));
		div(a: float32, b: vec4f): vec4f := div(vec4f(a), b);
		div(a: vec4f, b: float32): vec4f := div(a, vec4f(b));
		abs(a: vec4f): vec4f := vec4f(Math.abs(a.x), Math.abs(a.y), Math.abs(a.z), Math.abs(a.w));
		min(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), min.p4f));
		max(lhs: vec4f, rhs: vec4f): vec4f := vec4f(emit(struct(lhs), struct(rhs), max.p4f));
		clamp(vec: vec4f, min: vec4f, max: vec4f): vec4f := min(max(vec, min), max);
		clamp(vec: vec4f, min: float32, max: float32): vec4f := clamp(vec, vec4f(min), vec4f(max));
		mix(a: vec4f, b: vec4f, t: float32): vec4f := vec4f(Math.mix(a.x, b.x, t), Math.mix(a.y, b.y, t), Math.mix(a.z, b.z, t), Math.mix(a.w, b.w, t));
		dp3(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dp3));
		dph(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dph));
		dp4(lhs: vec4f, rhs: vec4f): float32 := float32(emit(struct(lhs), struct(rhs), p4x.dp4));
		cross(const a: vec4f, const b: vec4f): vec4f := vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
		length(v: vec4f): float32 := Math.sqrt(dp3(v, v));
		normalize(const v: vec4f): vec4f := div(v, vec4f(length(v)));
		eval(const v: vec4f, x: float32): float32 := float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
		static const mat4f: struct {
			m: float32[4][4];
			data: float32[16];
			v: vec4f[4];
			<?>: <?>;
			x: vec4f := x: vec4f;
			y: vec4f := y: vec4f;
			z: vec4f := z: vec4f;
			w: vec4f := w: vec4f;
			<?>: <?>;
			xx: float32 := xx: float32;
			xy: float32 := xy: float32;
			xz: float32 := xz: float32;
			xw: float32 := xw: float32;
			yx: float32 := yx: float32;
			yy: float32 := yy: float32;
			yz: float32 := yz: float32;
			yw: float32 := yw: float32;
			zx: float32 := zx: float32;
			zy: float32 := zy: float32;
			zz: float32 := zz: float32;
			zw: float32 := zw: float32;
			wx: float32 := wx: float32;
			wy: float32 := wy: float32;
			wz: float32 := wz: float32;
			ww: float32 := ww: float32;
		};
		static mat4f(xx: float32, xy: float32, xz: float32, xw: float32, yx: float32, yy: float32, yz: float32, yw: float32, zx: float32, zy: float32, zz: float32, zw: float32, wx: float32, wy: float32, wz: float32, ww: float32): mat4f := {
			return .result := {
			.result.xx := xx;
			.result.xy := xy;
			.result.xz := xz;
			.result.xw := xw;
			.result.yx := yx;
			.result.yy := yy;
			.result.yz := yz;
			.result.yw := yw;
			.result.zx := zx;
			.result.zy := zy;
			.result.zz := zz;
			.result.zw := zw;
			.result.wx := wx;
			.result.wy := wy;
			.result.wz := wz;
			.result.ww := ww;
		};
		};
		static mat4f(const x: vec4f, const y: vec4f, const z: vec4f, const w: vec4f): mat4f := {
			return .result := {
			.result.x := x;
			.result.y := y;
			.result.z := z;
			.result.w := w;
		};
		};
		dp3(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), 1.000000);
		dph(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));
		dp4(const mat: mat4f, const vec: vec4f): vec4f := vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));
		static transpose(const mat: mat4f): mat4f := {
			return .result := {
			.result.xx := mat.xx;
			.result.xy := mat.yx;
			.result.xz := mat.zx;
			.result.xw := mat.wx;
			.result.yx := mat.xy;
			.result.yy := mat.yy;
			.result.yz := mat.zy;
			.result.yw := mat.wy;
			.result.zx := mat.xz;
			.result.zy := mat.yz;
			.result.zz := mat.zz;
			.result.zw := mat.wz;
			.result.wx := mat.xw;
			.result.wy := mat.yw;
			.result.wz := mat.zw;
			.result.ww := mat.ww;
		};
		};
		static mul(const lhs: mat4f, const rhs: mat4f): mat4f := {
			transposed: mat4f := transpose(rhs);
			return .result := {
			.result.x := dp4(transposed, lhs.x);
			.result.y := dp4(transposed, lhs.y);
			.result.z := dp4(transposed, lhs.z);
			.result.w := dp4(transposed, lhs.w);
		};
		};
		static rotation(const center: vec4f, const direction: vec4f, angle: float32): mat4f := {
			len: float32 := length(direction);
			if ((len) < 0.000000) {
				trace("invalid direction of rotation", direction);
				return .result := {
			.result.x := vec4f(0, 0, 0, 0);
			.result.y := vec4f(0, 0, 0, 0);
			.result.z := vec4f(0, 0, 0, 0);
			.result.w := vec4f(0, 0, 0, 0);
		};
			}
			x: float32 := direction.x / len;
			y: float32 := direction.y / len;
			z: float32 := direction.z / len;
			cx: float32 := center.x;
			cy: float32 := center.y;
			cz: float32 := center.z;
			xx: float32 := x * x;
			xy: float32 := x * y;
			xz: float32 := x * z;
			yy: float32 := y * y;
			yz: float32 := y * z;
			zz: float32 := z * z;
			s: float32 := Math.sin(angle);
			c: float32 := Math.cos(angle);
			k: float32 := (1) - c;
			return .result := {
			.result.xx := xx + (yy + zz) * c;
			.result.xy := xy * k - z * s;
			.result.xz := xz * k + y * s;
			.result.xw := (cx * (yy + zz) - x * (cy * y + cz * z)) * k + (cy * z - cz * y) * s;
			.result.yx := xy * k + z * s;
			.result.yy := yy + (xx + zz) * c;
			.result.yz := yz * k - x * s;
			.result.yw := (cy * (xx + zz) - y * (cx * x + cz * z)) * k + (cz * x - cx * z) * s;
			.result.zx := xz * k - y * s;
			.result.zy := yz * k + x * s;
			.result.zz := zz + (xx + yy) * c;
			.result.zw := (cz * (xx + yy) - z * (cx * x + cy * y)) * k + (cx * y - cy * x) * s;
			.result.w := vec4f(0, 0, 0, 1);
		};
		};
		static rotation(const direction: vec4f, angle: float32): mat4f := {
			xx: float32 := direction.x * direction.x;
			yy: float32 := direction.y * direction.y;
			zz: float32 := direction.z * direction.z;
			xy: float32 := direction.x * direction.y;
			xz: float32 := direction.x * direction.z;
			yz: float32 := direction.y * direction.z;
			s: float32 := Math.sin(angle);
			c: float32 := Math.cos(angle);
			k: float32 := (1) - c;
			tmp: vec4f := mul(direction, s);
			return .result := {
			.result.xx := k * xx + c;
			.result.xy := k * xy - tmp.z;
			.result.xz := k * xz + tmp.y;
			.result.xw := (0);
			.result.yx := k * xy + tmp.z;
			.result.yy := k * yy + c;
			.result.yz := k * yz - tmp.x;
			.result.yw := (0);
			.result.zx := k * xz - tmp.y;
			.result.zy := k * yz + tmp.x;
			.result.zz := k * zz + c;
			.result.zw := (0);
			.result.w := vec4f(0, 0, 0, 1);
		};
		};
		static translation(const direction: vec4f, amount: float32): mat4f := {
			return .result := {
			.result.xx := (1);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := direction.x * amount;
			.result.yx := (0);
			.result.yy := (1);
			.result.yz := (0);
			.result.yw := direction.y * amount;
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := (1);
			.result.zw := direction.z * amount;
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
		};
		static scale(const direction: vec4f, amount: float32): mat4f := {
			rcp(val: float32): float32 := ((val < (0) ? -val : val)) < 0.000000 ? (0) : (1) / val;
			return .result := {
			.result.xx := rcp(direction.x * amount);
			.result.xy := (0);
			.result.xz := (0);
			.result.xw := (0);
			.result.yx := (0);
			.result.yy := rcp(direction.y * amount);
			.result.yz := (0);
			.result.yw := (0);
			.result.zx := (0);
			.result.zy := (0);
			.result.zz := rcp(direction.z * amount);
			.result.zw := (0);
			.result.wx := (0);
			.result.wy := (0);
			.result.wz := (0);
			.result.ww := (1);
		};
		};
		static inverse(const mat: mat4f): mat4f := {
			a00: float32 := mat.xx;
			a01: float32 := mat.xy;
			a02: float32 := mat.xz;
			a03: float32 := mat.xw;
			a10: float32 := mat.yx;
			a11: float32 := mat.yy;
			a12: float32 := mat.yz;
			a13: float32 := mat.yw;
			a20: float32 := mat.zx;
			a21: float32 := mat.zy;
			a22: float32 := mat.zz;
			a23: float32 := mat.zw;
			a30: float32 := mat.wx;
			a31: float32 := mat.wy;
			a32: float32 := mat.wz;
			a33: float32 := mat.ww;
			b00: float32 := a00 * a11 - a01 * a10;
			b01: float32 := a00 * a12 - a02 * a10;
			b02: float32 := a00 * a13 - a03 * a10;
			b03: float32 := a01 * a12 - a02 * a11;
			b04: float32 := a01 * a13 - a03 * a11;
			b05: float32 := a02 * a13 - a03 * a12;
			b06: float32 := a20 * a31 - a21 * a30;
			b07: float32 := a20 * a32 - a22 * a30;
			b08: float32 := a20 * a33 - a23 * a30;
			b09: float32 := a21 * a32 - a22 * a31;
			b10: float32 := a21 * a33 - a23 * a31;
			b11: float32 := a22 * a33 - a23 * a32;
			det: float32 := b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
			return .result := {
			.result.xx := (a11 * b11 - a12 * b10 + a13 * b09) / det;
			.result.xy := (a02 * b10 - a01 * b11 - a03 * b09) / det;
			.result.xz := (a31 * b05 - a32 * b04 + a33 * b03) / det;
			.result.xw := (a22 * b04 - a21 * b05 - a23 * b03) / det;
			.result.yx := (a12 * b08 - a10 * b11 - a13 * b07) / det;
			.result.yy := (a00 * b11 - a02 * b08 + a03 * b07) / det;
			.result.yz := (a32 * b02 - a30 * b05 - a33 * b01) / det;
			.result.yw := (a20 * b05 - a22 * b02 + a23 * b01) / det;
			.result.zx := (a10 * b10 - a11 * b08 + a13 * b06) / det;
			.result.zy := (a01 * b08 - a00 * b10 - a03 * b06) / det;
			.result.zz := (a30 * b04 - a31 * b02 + a33 * b00) / det;
			.result.zw := (a21 * b02 - a20 * b04 - a23 * b00) / det;
			.result.wx := (a11 * b07 - a10 * b09 - a12 * b06) / det;
			.result.wy := (a00 * b09 - a01 * b07 + a02 * b06) / det;
			.result.wz := (a31 * b01 - a30 * b03 - a32 * b00) / det;
			.result.ww := (a20 * b03 - a21 * b01 + a22 * b00) / det;
		};
		};
		static const vec2d: struct {
			<?>: <?>;
			x: float64 := x: float64;
			y: float64 := y: float64;
			data: float64[2];
		};
		static vec2d(x: float64, y: float64): vec2d := {
			return .result := {
			.result.x := x;
			.result.y := y;
		};
		};
		add(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), add.p2d));
		sub(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), sub.p2d));
		mul(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), mul.p2d));
		div(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), div.p2d));
		min(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), min.p2d));
		max(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), max.p2d));
		ceq(a: vec2d, b: vec2d): vec2d := vec2d(emit(struct(a), struct(b), ceq.p2d));
		dot(const a: vec2d, const b: vec2d): float64 := a.x * b.x + a.y * b.y;
		static const Timeunit: struct {
			static const Nanos: int64 := (1);
			static const Micros: int64 := (1000);
			static const Millis: int64 := (1000000);
			static const Seconds: int64 := (1000000000);
			static const Minutes: int64 := (60000000000);
			static const Hours: int64 := (3600000000000);
			static const Days: int64 := (86400000000000);
		};
		static convert(value: int64, from: Timeunit, to: Timeunit): int64 := {
			if (from > to) {
				return .result := value * (from / to);
			}
			return .result := value / (to / from);
		};
		static convert(value: float64, from: Timeunit, to: Timeunit): float64 := {
			if (from > to) {
				return .result := value * ((from / to));
			}
			return .result := value / ((to / from));
		};
		static const Duration: struct {
			const value: int64 := 0;
			static const precision: Timeunit := Timeunit.(Millis);
			static value(duration: Duration, precision: Timeunit): int64 := {
				return .result := convert(duration.value, Duration.precision, precision);
			};
			static add(lhs: Duration, rhs: Duration): Duration := {
				return .result := {
			.result.value := lhs.value + rhs.value;
		};
			};
		};
		static Duration(value: int64, precision: Timeunit): Duration := {
			return .result := {
			.result.value := convert(value, precision, Duration.precision);
		};
		};
		static const Timestamp: struct {
			value: int64 := 0;
			static const precision: Timeunit := Timeunit.(Millis);
			static value(timestamp: Timestamp, precision: Timeunit): int64 := {
				return .result := convert(timestamp.value, Timestamp.precision, precision);
			};
			static diff(a: Timestamp, b: Timestamp, precision: Timeunit): int64 := {
				return .result := convert(a.value - b.value, Timestamp.precision, precision);
			};
			static diff(a: Timestamp, b: Timestamp): Duration := {
				return .result := Duration(a.value - b.value, Timestamp.precision);
			};
			static compare(a: Timestamp, b: Timestamp): int32 := {
				return .result := int32(a.value > b.value) - int32(a.value < b.value);
			};
			static equal(a: Timestamp, b: Timestamp, precision: Timeunit): bool := {
				return .result := value(a, precision) == value(b, precision);
			};
			static equal(a: Timestamp, b: Timestamp): bool := {
				return .result := a.value == b.value;
			};
			static add(lhs: Timestamp, value: int64, precision: Timeunit): Timestamp := {
				return .result := {
			.result.value := lhs.value + convert(value, precision, Timestamp.precision);
		};
			};
			static floor(value: Timestamp, precision: Timeunit): Timestamp := {
				if (precision <= (Timestamp.precision)) {
					trace("small precision", precision);
					return .result := value;
				}
				one: int64 := convert(1, precision, Timestamp.precision);
				return .result := {
			.result.value := value.value - value.value % one;
		};
			};
			static ceil(value: Timestamp, precision: Timeunit): Timestamp := {
				if (precision <= (Timestamp.precision)) {
					trace("small precision", precision);
					return .result := value;
				}
				one: int64 := convert(1, precision, Timestamp.precision);
				part: int64 := value.value % one;
				if (part == (0)) {
					return .result := value;
				}
				return .result := {
			.result.value := value.value - part + one;
		};
			};
			static distribute(this: Timestamp, unit: Timeunit, duration: uint64): Timestamp := {
				abort("not implemented");
				return .result := {
			.result.value := (0);
		};
			};
			static distribute(this: Timestamp, unit: Timeunit, start: int32, end: int32): Timestamp := {
				return .result := distribute(this, unit, end - start);
			};
			static now(): Timestamp := {
				return .result := {
			.result.value := convert(System.millis(), Timeunit.(Millis), Timestamp.precision);
		};
			};
		};
		static Timestamp(value: int64, precision: Timeunit): Timestamp := {
			return .result := {
			.result.value := convert(value, precision, Timestamp.precision);
		};
		};
		static const Timezone: struct {
			const name: char[];
			offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration;
			static offset(const zone: Timezone, timestamp: Timestamp): Duration := {
				isDaylightSaving: bool;
				return .result := zone.offset(zone, timestamp, &isDaylightSaving);
			};
			static utc(): Timezone := {
				static offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration := {
					isDaylightSaving := false;
					return .result := {
			.result.value := (0);
		};
				};
				return .result := {
			.result.offset := offset;
			.result.name := ("UTC");
		};
			};
			static lookup(const name: char[]): Timezone := {
				abort("todo");
			};
			static local(): Timezone := {
				warn("using fake timezone");
				static offset(const zone: Timezone, timestamp: Timestamp, isDaylightSaving: bool): Duration := {
					isDaylightSaving := false;
					return .result := Duration(3, Timeunit.(Hours));
				};
				return .result := {
			.result.offset := offset;
			.result.name := ("GMT+3");
		};
			};
		};
		static const Month: struct {
			static const January: uint8 := (1);
			static const February: uint8 := (2);
			static const March: uint8 := (3);
			static const April: uint8 := (4);
			static const May: uint8 := (5);
			static const June: uint8 := (6);
			static const July: uint8 := (7);
			static const August: uint8 := (8);
			static const September: uint8 := (9);
			static const October: uint8 := (10);
			static const November: uint8 := (11);
			static const December: uint8 := (12);
		};
		Month(index: int32): Month := Month(emit(int32(index + (Month.(January)))));
		indexOf(value: Month): int32 := int32(value - (Month.(January)));
		static const Weekday: struct {
			static const Monday: uint8 := (1);
			static const Tuesday: uint8 := (2);
			static const Wednesday: uint8 := (3);
			static const Thursday: uint8 := (4);
			static const Friday: uint8 := (5);
			static const Saturday: uint8 := (6);
			static const Sunday: uint8 := (7);
		};
		Weekday(index: int32): Weekday := Weekday(emit(int32(index + (Weekday.(Monday)))));
		indexOf(value: Weekday): int32 := int32(value - (Weekday.(Monday)));
		static const Calendar: struct {
			static const Gregorian: uint8 := (0);
		};
		static const Datetime: struct {
			const year: int32;
			const month: Month;
			const day: uint8;
			const hour: uint8 := 0;
			const minute: uint8 := 0;
			const second: uint8 := 0;
			const millis: uint16 := 0;
			const timezone: Timezone;
			const weekOfYear: uint8;
			const dayOfYear: uint16;
			const dayOfWeek: Weekday;
			const leapYear: bool;
			static const DaysToMonth365: int32[13] := {
				DaysToMonth365[0] := 0;
				DaysToMonth365[1] := 31;
				DaysToMonth365[2] := 59;
				DaysToMonth365[3] := 90;
				DaysToMonth365[4] := 120;
				DaysToMonth365[5] := 151;
				DaysToMonth365[6] := 181;
				DaysToMonth365[7] := 212;
				DaysToMonth365[8] := 243;
				DaysToMonth365[9] := 273;
				DaysToMonth365[10] := 304;
				DaysToMonth365[11] := 334;
				DaysToMonth365[12] := 365;
			};
			static const DaysToMonth366: int32[13] := {
				DaysToMonth366[0] := 0;
				DaysToMonth366[1] := 31;
				DaysToMonth366[2] := 60;
				DaysToMonth366[3] := 91;
				DaysToMonth366[4] := 121;
				DaysToMonth366[5] := 152;
				DaysToMonth366[6] := 182;
				DaysToMonth366[7] := 213;
				DaysToMonth366[8] := 244;
				DaysToMonth366[9] := 274;
				DaysToMonth366[10] := 305;
				DaysToMonth366[11] := 335;
				DaysToMonth366[12] := 366;
			};
			static const DaysTil1970: int32 := 719162;
			static isLeapYear(year: int32): bool := {
				if (year % 4 != 0) {
					return .result := false;
				}
				if (year % 100 != 0) {
					return .result := true;
				}
				if (year % 400 != 0) {
					return .result := false;
				}
				return .result := true;
			};
			static add(cal: Datetime, years: int32, months: int32, days: int32): Datetime := {
				year: int32 := cal.year + years;
				month: int32 := indexOf(cal.month) + months;
				if (month >= 12) {
					year := year + month / 12;
					month := month % 12;
				}
				else if (month < 0) {
					year := year + month / 12 - 1;
					month := 12 - (-month % 12);
				}
				assert(days == 0);
				return .result := {
			.result.year := year;
			.result.month := Month(month % 12);
			.result.day := cal.day;
			.result.hour := cal.hour;
			.result.minute := cal.minute;
			.result.second := cal.second;
			.result.millis := cal.millis;
			.result.timezone := cal.timezone;
			.result.weekOfYear := cal.weekOfYear;
			.result.dayOfYear := cal.dayOfYear;
			.result.dayOfWeek := cal.dayOfWeek;
			.result.leapYear := isLeapYear(year);
		};
			};
		};
		static Timestamp(value: Datetime): Timestamp := {
			year: int32 := value.year;
			if (year < 0 || year > 9999) {
				trace("invalid year", year);
				return .result := Timestamp(1 << 63, Timestamp.precision);
			}
			month: int32 := value.month;
			if (month < (Month.(January)) || month > (Month.(December))) {
				trace("invalid month", month);
				month := Math.clamp(month, int32(Month.(January)), int32(Month.(December)));
			}
			const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365;
			day: int32 := value.day;
			daysInYear: int32 := DaysToMonth[month - 1];
			daysInMonth: int32 := DaysToMonth[month] - daysInYear;
			if (day < 1 || day > daysInMonth) {
				trace("invalid day of month", day);
				day := Math.clamp(day, 1, daysInMonth);
			}
			y: int32 := year - 1;
			d: int64 := y * 365 + y / 4 - y / 100 + y / 400 + daysInYear + day - 1 - Datetime.DaysTil1970;
			t: int64 := (((d * (24) + (value.hour)) * (60) + (value.minute)) * (60) + (value.second)) * (1000) + (value.millis);
			return .result := Timestamp(t, Timeunit.(Millis));
		};
		static Datetime(timestamp: Timestamp, calendar: Calendar, timezone: Timezone): Datetime := {
			assert(calendar == (Calendar.(Gregorian)));
			offset: Duration := Timezone.offset(timezone, timestamp);
			timestamp := Timestamp.add(timestamp, offset.value, Duration.precision);
			n: int32 := (Datetime.DaysTil1970) + Timestamp.value(timestamp, Timeunit.(Days));
			dayOfWeek: int32 := n % 7;
			y400: int32 := n / DaysPer400Years;
			n := n - y400 * DaysPer400Years;
			y100: int32 := n / DaysPer100Years;
			if (y100 == 4) {
				y100 := 3;
			}
			n := n - y100 * DaysPer100Years;
			y4: int32 := n / DaysPer4Years;
			n := n - y4 * DaysPer4Years;
			y1: int32 := n / DaysPerYear;
			if (y1 == 4) {
				y1 := 3;
			}
			year: int32 := y400 * 400 + y100 * 100 + y4 * 4 + y1 + 1;
			n := n - y1 * DaysPerYear;
			m: int32 := n >> 5 + 1;
			const DaysToMonth: int32[*] := Datetime.isLeapYear(year) ? (Datetime.DaysToMonth366) : Datetime.DaysToMonth365;
			for ( ; n >= DaysToMonth[m]; ) {
				m := m + 1;
			}
			return .result := {
			.result.year := year;
			.result.month := Month(m - 1);
			.result.day := (n - DaysToMonth[m - 1] + 1);
			.result.hour := (Timestamp.value(timestamp, Timeunit.(Hours)) % (24));
			.result.minute := (Timestamp.value(timestamp, Timeunit.(Minutes)) % (60));
			.result.second := (Timestamp.value(timestamp, Timeunit.(Seconds)) % (60));
			.result.millis := (Timestamp.value(timestamp, Timeunit.(Millis)) % (1000));
			.result.timezone := timezone;
			.result.dayOfYear := (n + 1);
			.result.dayOfWeek := Weekday(dayOfWeek);
			.result.weekOfYear := ((n - dayOfWeek + indexOf(Weekday.(Thursday))) / 7 + 1);
			.result.leapYear := (DaysToMonth) == Datetime.DaysToMonth366;
		};
		};
		Datetime(timestamp: Timestamp): Datetime := Datetime(timestamp, Calendar.(Gregorian), Timezone.utc());
		static Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32, zone: Timezone): Datetime := {
			return .result := {
			.result.year := year;
			.result.month := Month(month - 1);
			.result.day := (day);
			.result.hour := (hour);
			.result.minute := (minute);
			.result.second := (second);
			.result.millis := (millis);
			.result.timezone := zone;
			.result.weekOfYear := (0);
			.result.dayOfYear := (0);
			.result.dayOfWeek := Weekday.(Monday);
			.result.leapYear := Datetime.isLeapYear(year);
		};
		};
		static Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, millis: int32): Datetime := {
			return .result := Datetime(year, month, day, hour, minute, second, millis, Timezone.utc());
		};
		static Datetime(year: int32, month: int32, day: int32, hour: int32, minute: int32, second: int32, zone: Timezone): Datetime := {
			return .result := Datetime(year, month, day, hour, minute, second, 0, zone);
		};
		static Datetime(year: int32, month: int32, day: int32, zone: Timezone): Datetime := {
			return .result := Datetime(year, month, day, 0, 0, 0, 0, zone);
		};
		static Datetime(year: int32, month: int32, day: int32): Datetime := {
			return .result := Datetime(year, month, day, 0, 0, 0, 0, Timezone.utc());
		};
		static length(const str: char[*]): int32 := {
			if ((str) == null) {
				return .result := 0;
			}
			result: int32 := 0;
			for ( ; str[result]; result := result + 1) ;
			return .result := result;
		};
		static indexOf(const str: char[*], chr: char): int32 := {
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					return .result := i;
				}
			}
			return .result := -1;
		};
		static lastIndexOf(const str: char[*], chr: char): int32 := {
			result: int32 := -1;
			for (i: int32 := 0; str[i]; i := i + 1) {
				if (str[i] == chr) {
					result := i;
				}
			}
			return .result := result;
		};
		static startsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			for (i: int32 := 0; (with[i]) != 0; i := i + 1) {
				if (cmp(str[i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static endsWith(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): bool := {
			withLen: int32 := length(with);
			strLen: int32 := length(str);
			if (strLen < withLen) {
				return .result := false;
			}
			for (i: int32 := 0; i < withLen; i := i + 1) {
				if (cmp(str[strLen - withLen + i], with[i]) != 0) {
					return .result := false;
				}
			}
			return .result := true;
		};
		static compare(const str: char[*], const with: char[*], cmp(chr: char, with: char): int32): int32 := {
			result: int32 := 0;
			for (i: int32 := 0; result == 0; i := i + 1) {
				result := cmp(str[i], with[i]);
				if ((str[i]) == 0) {
					break;
				}
			}
			return .result := result;
		};
		static ignCaseCmp(chr: char, with: char): int32 := {
			static ignCase(chr: char): char := {
				if (chr < 'A') {
					return .result := chr;
				}
				if (chr > 'Z') {
					return .result := chr;
				}
				return .result := chr - 'A' + 'a';
			};
			return .result := ignCase(chr) - ignCase(with);
		};
		static caseCmp(chr: char, with: char): int32 := {
			return .result := chr - with;
		};
		toHex(value: int32): int32 := int32("0123456789abcdef"[value & 15]);
		startsWith(const str: char[*], const with: char[*]): bool := startsWith(str, with, caseCmp);
		endsWith(const str: char[*], const with: char[*]): bool := endsWith(str, with, caseCmp);
		compare(const str: char[*], const with: char[*]): int32 := compare(str, with, caseCmp);
		equals(const str: char[*], const with: char[*]): bool := compare(str, with, caseCmp) == 0;
		contains(const str: char[*], chr: char): bool := indexOf(str, chr) >= 0;
		static float64(const value: char[]): float64 := {
			result: float64 := 0;
			static if ((preferNativeCalls) && (typename(float64.parse)) != null) {
				len: int32 := float64.parse(value, &result);
				if (len > 0 && len < (value.length) && (value[len]) == 0) {
					return .result := result;
				}
				return .result := Math.nan;
			}
			sign: float64 := 1;
			decimal: float64 := 0;
			for (i: int32 := 0; i < (value.length) && (value[i]) != 0; i := i + 1) {
				chr: char := value[i];
				if (chr >= '0' && chr <= '9') {
					result := result * (10) + ((chr - '0'));
					decimal := decimal * (10);
				}
				else if (chr == '.') {
					if (decimal != (0)) {
						return .result := Math.nan;
					}
					decimal := (1);
				}
				else if (chr == '-' && i == 0) {
					sign := (-1);
				}
				else if (chr == '+' && i == 0) {
					sign := (1);
				}
				else {
					return .result := Math.nan;
				}
			}
			if (decimal == (0)) {
				if (value.length > (0)) {
					return .result := sign * result;
				}
			}
			return .result := sign * result / decimal;
		};
		static const FormatFlags: struct {
			const sign: char := 0;
			const padChr: char := 0;
			const width: int32 := 0;
			const precision: int32 := 10;
			const trimDecimal: bool := true;
			static read(const format: char[], pos: int32): FormatFlags := {
				chr: int32 := format[pos];
				if (chr != ('%')) {
					return .result := {
			.result.trimDecimal := true;
			.result.precision := 10;
			.result.width := 0;
			.result.padChr := (0);
			.result.sign := (0);
		};
				}
				pos := pos + 1;
				chr := (format[pos]);
				if (chr == ('%')) {
					return .result := {
			.result.trimDecimal := true;
			.result.precision := 10;
			.result.width := 0;
			.result.padChr := (0);
			.result.sign := (0);
		};
				}
				sgnChr: int32 := 0;
				if (chr == ('-') || chr == ('+')) {
					pos := pos + 1;
					sgnChr := chr;
					chr := (format[pos]);
				}
				padChr: int32 := ' ';
				if (chr == ('0')) {
					pos := pos + 1;
					padChr := chr;
					chr := (format[pos]);
				}
				padLen: int32 := 0;
				for ( ; chr >= ('0') && chr <= ('9'); ) {
					pos := pos + 1;
					padLen := padLen * 10 + chr - ('0');
					chr := (format[pos]);
				}
				precision: int32 := 0;
				if (chr == ('.')) {
					pos := pos + 1;
					chr := (format[pos]);
					for ( ; chr >= ('0') && chr <= ('9'); ) {
						pos := pos + 1;
						precision := precision * 10 + chr - ('0');
						chr := (format[pos]);
					}
				}
				return .result := {
			.result.sign := (sgnChr);
			.result.width := padLen;
			.result.padChr := (padChr);
			.result.precision := precision;
			.result.trimDecimal := true;
		};
			};
			static defPad(const this: FormatFlags, width: int32, padChr: char): FormatFlags := {
				if (this.width == 0) {
					return .result := {
			.result.sign := this.sign;
			.result.precision := this.precision;
			.result.padChr := padChr;
			.result.width := width;
			.result.trimDecimal := true;
		};
				}
				return .result := this;
			};
		};
		static append(output: char[], pos: int32, const value: char[*]): int32 := {
			if ((value) == null) {
				return .result := append(output, pos, "NULL");
			}
			for (i: int32 := 0; value[i]; i := i + 1) {
				if (pos >= (output.length)) {
					break;
				}
				output[pos] := value[i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static append(output: char[], pos: int32, radix: int32, value: uint64, const format: FormatFlags): int32 := {
			static const whiteSpace: char[] := " \t\n\r";
			static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz";
			len: int32 := 0;
			digits: char[80] := {
			};
			assert(radix > 1, "radix is too small", radix);
			assert(radix < (radixDigits.length), "radix is too big", radix);
			for ( ; value > (0); value := value / (radix)) {
				digits[len := len + 1] := radixDigits[value % (radix)];
			}
			if (len == 0) {
				digits[len := len + 1] := '0';
			}
			maxLen: int32 := format.width - len;
			padChr: char := format.padChr;
			if (padChr == '') {
				padChr := ' ';
			}
			if ((format.sign) != 0) {
				maxLen := maxLen - 1;
				if (contains(whiteSpace, padChr)) {
					for ( ; maxLen > 0; maxLen := maxLen - 1) {
						assert(pos < (output.length));
						output[pos] := padChr;
						pos := pos + 1;
					}
				}
				assert(pos < (output.length));
				output[pos] := format.sign;
				pos := pos + 1;
			}
			for ( ; maxLen > 0; maxLen := maxLen - 1) {
				assert(pos < (output.length));
				output[pos] := padChr;
				pos := pos + 1;
			}
			for (i: int32 := 0; i < len; i := i + 1) {
				assert(i < (output.length));
				output[pos] := digits[len - i];
				pos := pos + 1;
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			output[pos] := (0);
			return .result := pos;
		};
		static append(output: char[], pos: int32, radix: int32, value: int64, const format: FormatFlags): int32 := {
			if (value < (0)) {
				signedFormat: FormatFlags := {
					signedFormat.sign := '-';
					signedFormat.padChr := format.padChr;
					signedFormat.width := format.width;
					signedFormat.precision := format.precision;
					signedFormat.trimDecimal := true;
				};
				return .result := append(output, pos, radix, uint64(-value), signedFormat);
			}
			return .result := append(output, pos, radix, uint64(value), format);
		};
		static append(output: char[], pos: int32, value: float64, const format: FormatFlags): int32 := {
			formatInt: FormatFlags := {
				formatInt.sign := value < (0) ? '-' : format.sign;
				formatInt.padChr := format.padChr;
				formatInt.width := format.width - format.precision - 1;
				formatInt.precision := 10;
				formatInt.trimDecimal := true;
			};
			end: int32 := pos + format.width;
			if (end >= (output.length)) {
				end := (output.length - (1));
			}
			const beg: int32 := pos;
			fraction: float64 := Math.modf(Math.abs(value), &value);
			pos := append(output, pos, 10, uint64(int64(value)), formatInt);
			dotIndex: int32 := pos;
			pos := append(output, pos, ".");
			end := Math.max(end, pos + format.precision);
			if (end >= (output.length)) {
				end := (output.length - (1));
			}
			fraction := fraction + Math.pow(10.000000, float64(pos - end)) / (2);
			if (fraction >= (1)) {
				fraction := fraction % (1);
				pos := append(output, beg, 10, uint64(int64(value + (1))), formatInt);
				dotIndex := pos;
				pos := append(output, pos, ".");
				end := Math.max(end, pos + format.precision);
				if (end >= (output.length)) {
					end := (output.length - (1));
				}
			}
			for ( ; pos < end; pos := pos + 1) {
				fraction := Math.modf(fraction * (10), &value);
				output[pos] := (('0') + int32(value));
			}
			if (pos >= (output.length)) {
				pos := (output.length - (1));
			}
			if (!format.trimDecimal) {
				output[pos] := (0);
				return .result := pos;
			}
			for (i: int32 := pos - 1; i >= dotIndex; i := i - 1) {
				if (output[i] != '0') {
					if (i == dotIndex) {
						output[i] := (0);
						return .result := i;
					}
					output[i + 1] := (0);
					return .result := i + 1;
				}
			}
			return .result := pos;
		};
		append(output: char[], pos: int32, value: uint64, const format: FormatFlags): int32 := append(output, pos, 10, uint64(value), format);
		append(output: char[], pos: int32, value: uint32, const format: FormatFlags): int32 := append(output, pos, 10, uint64(value), format);
		append(output: char[], pos: int32, value: uint16, const format: FormatFlags): int32 := append(output, pos, 10, uint64(value), format);
		append(output: char[], pos: int32, value: uint8, const format: FormatFlags): int32 := append(output, pos, 10, uint64(value), format);
		append(output: char[], pos: int32, value: int64, const format: FormatFlags): int32 := append(output, pos, 10, int64(value), format);
		append(output: char[], pos: int32, value: int32, const format: FormatFlags): int32 := append(output, pos, 10, int64(value), format);
		append(output: char[], pos: int32, value: int16, const format: FormatFlags): int32 := append(output, pos, 10, int64(value), format);
		append(output: char[], pos: int32, value: int8, const format: FormatFlags): int32 := append(output, pos, 10, int64(value), format);
		append(output: char[], pos: int32, value: float32, const format: FormatFlags): int32 := append(output, pos, float64(value), format);
		static const DatetimeFormat: struct {
			const monthsLong: char[][];
			const monthsShort: char[][];
			const weeksLong: char[][];
			const weeksShort: char[][];
			const amPmUpper: char[][];
			const amPmLower: char[][];
			const dateLong: char[] := "%A %d %B %Y";
			const timeLong: char[] := "%r";
			const dateShort: char[] := "%x";
			const timeShort: char[] := "%I:%M %p";
			static format(const formatter: DatetimeFormat, output: char[], end: int32, const value: Datetime, const format: char[]): int32 := {
				hours24to12(hour: int32): int32 := hour > 12 ? hour - 12 : hour == 0 ? 12 : hour;
				if (pointer(format) == null) {
					return .result := format(formatter, output, end, value, "%Y.%m.%d");
				}
				chr: char := 0;
				for (pos: int32 := 0; pos < (format.length); pos := pos + 1) {
					if (end >= (output.length)) {
						output[output.length - (1)] := (0);
						return .result := output.length - (1);
					}
					chr := format[pos];
					if (chr != '%') {
						output[end] := chr;
						end := end + 1;
						continue;
					}
					flags: FormatFlags := FormatFlags.read(format, &pos);
					chr := format[pos];
					if (chr == '%') {
						end := append(output, end, "%");
					}
					else if (chr == 'a') {
						end := append(output, end, formatter.weeksShort[indexOf(value.dayOfWeek)]);
					}
					else if (chr == 'A') {
						end := append(output, end, formatter.weeksLong[indexOf(value.dayOfWeek)]);
					}
					else if (chr == 'b') {
						end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
					}
					else if (chr == 'B') {
						end := append(output, end, formatter.monthsLong[indexOf(value.month)]);
					}
					else if (chr == 'C') {
						end := append(output, end, value.year / 100, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'd') {
						end := append(output, end, value.day, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'D') {
						end := format(formatter, output, end, value, "%m/%d/%y");
					}
					else if (chr == 'e') {
						end := append(output, end, value.day, FormatFlags.defPad(flags, 2, ' '));
					}
					else if (chr == 'F') {
						end := format(formatter, output, end, value, "%04Y-%m-%d");
					}
					else if (chr == 'h') {
						end := append(output, end, formatter.monthsShort[indexOf(value.month)]);
					}
					else if (chr == 'H') {
						end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'I') {
						end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'j') {
						end := append(output, end, value.dayOfYear, FormatFlags.defPad(flags, 3, '0'));
					}
					else if (chr == 'k') {
						end := append(output, end, value.hour, FormatFlags.defPad(flags, 2, ' '));
					}
					else if (chr == 'l') {
						end := append(output, end, hours24to12(value.hour), FormatFlags.defPad(flags, 2, ' '));
					}
					else if (chr == 'm') {
						end := append(output, end, indexOf(value.month) + 1, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'M') {
						end := append(output, end, value.minute, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'n') {
						end := append(output, end, "\n");
					}
					else if (chr == 'N') {
						end := append(output, end, (value.millis) * 1000000, FormatFlags.defPad(flags, 9, '0'));
					}
					else if (chr == 'p') {
						end := append(output, end, formatter.amPmUpper[int32((value.hour) < 12)]);
					}
					else if (chr == 'P') {
						end := append(output, end, formatter.amPmLower[int32((value.hour) < 12)]);
					}
					else if (chr == 'R') {
						end := format(formatter, output, end, value, "%H:%M");
					}
					else if (chr == 's') {
						end := append(output, end, typename.value(Timestamp(value), Timeunit.(Seconds)), flags);
					}
					else if (chr == 'S') {
						end := append(output, end, value.second, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 't') {
						end := append(output, end, "\t");
					}
					else if (chr == 'T') {
						end := format(formatter, output, end, value, "%H:%M:%S");
					}
					else if (chr == 'u') {
						end := append(output, end, indexOf(value.dayOfWeek) + 1, flags);
					}
					else if (chr == 'W') {
						end := append(output, end, value.weekOfYear, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'x') {
						end := format(formatter, output, end, value, formatter.dateShort);
					}
					else if (chr == 'X') {
						end := format(formatter, output, end, value, formatter.timeShort);
					}
					else if (chr == 'y') {
						end := append(output, end, value.year % 100, FormatFlags.defPad(flags, 2, '0'));
					}
					else if (chr == 'Y') {
						end := append(output, end, value.year, flags);
					}
					else {
						abort("unimplemented or invalid format character", chr);
					}
				}
				if (end >= (output.length)) {
					end := (output.length - (1));
				}
				output[end] := (0);
				return .result := end;
			};
			static format(const formatter: DatetimeFormat, output: char[], const value: Datetime, const format: char[]): int32 := {
				return .result := format(formatter, output, 0, value, format);
			};
		};
		static format(const value: Datetime, output: char[], const format: char[]): int32 := {
			static const monthsLongEn: char[][] := {
				monthsLongEn := monthsLongEn.init;
				monthsLongEn.init[0] := ("January");
				monthsLongEn.init[1] := ("February");
				monthsLongEn.init[2] := ("March");
				monthsLongEn.init[3] := ("April");
				monthsLongEn.init[4] := ("May");
				monthsLongEn.init[5] := ("June");
				monthsLongEn.init[6] := ("July");
				monthsLongEn.init[7] := ("August");
				monthsLongEn.init[8] := ("September");
				monthsLongEn.init[9] := ("October");
				monthsLongEn.init[10] := ("November");
				monthsLongEn.init[11] := ("December");
			};
			static const monthsShortEn: char[][] := {
				monthsShortEn := monthsShortEn.init;
				monthsShortEn.init[0] := ("Jan");
				monthsShortEn.init[1] := ("Feb");
				monthsShortEn.init[2] := ("Mar");
				monthsShortEn.init[3] := ("Apr");
				monthsShortEn.init[4] := ("May");
				monthsShortEn.init[5] := ("Jun");
				monthsShortEn.init[6] := ("Jul");
				monthsShortEn.init[7] := ("Aug");
				monthsShortEn.init[8] := ("Sep");
				monthsShortEn.init[9] := ("Oct");
				monthsShortEn.init[10] := ("Nov");
				monthsShortEn.init[11] := ("Dec");
			};
			static const weeksLongEn: char[][] := {
				weeksLongEn := weeksLongEn.init;
				weeksLongEn.init[0] := ("Monday");
				weeksLongEn.init[1] := ("Tuesday");
				weeksLongEn.init[2] := ("Wednesday");
				weeksLongEn.init[3] := ("Thursday");
				weeksLongEn.init[4] := ("Friday");
				weeksLongEn.init[5] := ("Saturday");
				weeksLongEn.init[6] := ("Sunday");
			};
			static const weeksShortEn: char[][] := {
				weeksShortEn := weeksShortEn.init;
				weeksShortEn.init[0] := ("Mon");
				weeksShortEn.init[1] := ("Tue");
				weeksShortEn.init[2] := ("Wed");
				weeksShortEn.init[3] := ("Thu");
				weeksShortEn.init[4] := ("Fri");
				weeksShortEn.init[5] := ("Sat");
				weeksShortEn.init[6] := ("Sun");
			};
			static const amPmUpperEn: char[][] := {
				amPmUpperEn := amPmUpperEn.init;
				amPmUpperEn.init[0] := ("AM");
				amPmUpperEn.init[1] := ("PM");
			};
			static const amPmLowerEn: char[][] := {
				amPmLowerEn := amPmLowerEn.init;
				amPmLowerEn.init[0] := ("am");
				amPmLowerEn.init[1] := ("pm");
			};
			static const fmtEN: DatetimeFormat := {
				fmtEN.monthsLong := (monthsLongEn);
				fmtEN.monthsShort := (monthsShortEn);
				fmtEN.weeksLong := (weeksLongEn);
				fmtEN.weeksShort := (weeksShortEn);
				fmtEN.amPmUpper := (amPmUpperEn);
				fmtEN.amPmLower := (amPmLowerEn);
				fmtEN.dateLong := ("%A %d %B %Y");
				fmtEN.timeLong := ("%r");
				fmtEN.dateShort := ("%x");
				fmtEN.timeShort := ("%I:%M %p");
			};
			return .result := DatetimeFormat.format(fmtEN, output, value, format);
		};
		static append(output: char[], pos: int32, value: int32): int32 := {
			static const format: FormatFlags := {
				format.sign := (0);
				format.padChr := (0);
				format.width := 0;
				format.precision := 10;
				format.trimDecimal := true;
			};
			return .result := append(output, pos, value, format);
		};
		static const Closeable: struct {
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const ByteReader: struct {
			read(this: ByteReader, bytes: uint8[]): int32;
			static read(this: ByteReader): int32 := {
				bytes: uint8[1] := {
					bytes[0] := (0);
				};
				if (read(this, bytes) <= 0) {
					return .result := -1;
				}
				return .result := bytes[0];
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const ByteWriter: struct {
			write(this: ByteWriter, bytes: uint8[]): void;
			flush(this: ByteWriter): void;
			static write(this: ByteWriter, oneByte: uint8): void := {
				bytes: uint8[1] := {
					bytes[0] := oneByte;
				};
				return .result := this.write(this, bytes);
			};
			static copy(this: ByteWriter, reader: ByteReader): int32 := {
				buffer: uint8[4096] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					read: int32 := reader.read(reader, buffer);
					if (read <= 0) {
						return .result := result;
					}
					this.write(this, buffer[...read]);
					result := result + read;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const CopyReader: struct {
			const source: ByteReader;
			const clone: ByteWriter;
			static read(this: CopyReader, bytes: uint8[]): int32 := {
				result: int32 := read(this.source, bytes);
				if (result > 0) {
					this.clone.write(this.clone, bytes[...result]);
				}
				return .result := result;
			};
			static close(this: CopyReader): void := {
				Closeable.closeSafe(this.source);
				Closeable.closeSafe(this.clone);
			};
			read(this: ByteReader, bytes: uint8[]): int32;
			static read(this: ByteReader): int32 := {
				bytes: uint8[1] := {
					bytes[0] := (0);
				};
				if (read(this, bytes) <= 0) {
					return .result := -1;
				}
				return .result := bytes[0];
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const ByteBuffer: struct {
			position: int32 := 0;
			capacity: int32 := 32;
			length: int32 := 0;
			buffer: uint8[*] := pointer.alloc(null, capacity);
			static read(this: ByteBuffer, bytes: uint8[]): int32 := {
				if (this.position >= this.length) {
					return .result := -1;
				}
				for (i: int32 := 0; i < (bytes.length); i := i + 1) {
					if (this.position >= this.length) {
						return .result := i;
					}
					bytes[i] := this.buffer[this.position];
					this.position := this.position + 1;
				}
				return .result := bytes.length;
			};
			const read(this: ByteBuffer, bytes: uint8[]): int32 := read;
			static read(this: ByteBuffer): int32 := {
				if (this.position >= this.length) {
					return .result := -1;
				}
				result: int32 := this.buffer[this.position];
				this.position := this.position + 1;
				return .result := result;
			};
			const read(this: ByteBuffer): int32 := read;
			static write(this: ByteBuffer, bytes: uint8[]): void := {
				size: int32 := this.position + (bytes.length);
				if (size >= this.capacity) {
					this.capacity := this.capacity * 2;
					if (size > 2 * this.capacity) {
						this.capacity := size * 2;
					}
					new: uint8[*] := pointer.alloc(null, this.capacity);
					for (i: int32 := 0; i < this.position; i := i + 1) {
						new[i] := this.buffer[i];
					}
					pointer.alloc(this.buffer, 0);
					this.buffer := (new);
				}
				for (i: int32 := 0; i < (bytes.length); i := i + 1) {
					this.buffer[this.position] := bytes[i];
					this.position := this.position + 1;
				}
			};
			const write(this: ByteBuffer, bytes: uint8[]): void := write;
			static flush(this: ByteBuffer): void := {
			};
			const flush(this: ByteBuffer): void := flush;
			static close(this: ByteBuffer): void := {
				pointer.alloc(this.buffer, 0);
				this.buffer := (null);
				this.position := 0;
				this.capacity := 0;
				this.length := 0;
			};
			const close(this: ByteBuffer): void := close;
		};
		unicode: typename := uint32;
		static const TextReader: struct {
			const reader: ByteReader;
			decode(this: TextReader, chars: uint32[]): int32;
			static close(this: TextReader): void := {
				Closeable.closeSafe(this.reader);
			};
			static decode(this: TextReader): int32 := {
				chars: uint32[1] := {
					chars[0] := (0);
				};
				if (decode(this, chars) <= 0) {
					return .result := -1;
				}
				return .result := chars[0] & (16777215);
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const TextWriter: struct {
			static const Writeable: struct {
				write(this: Writeable, writer: TextWriter): void;
				const .type: typename;
				static const create(type: typename): pointer := nfc(7);
				static const destroy(this: object): void := nfc(8);
				static const as(this: object, type: typename): pointer := nfc(9);
				static const type(this: object): typename := nfc(10);
			};
			const writer: ByteWriter;
			const format: FormatFlags;
			encode(this: TextWriter, chars: uint32[]): void;
			static flush(this: TextWriter): void := {
				this.writer.flush(this.writer);
			};
			const flush(this: TextWriter): void := flush;
			static close(this: TextWriter): void := {
				Closeable.closeSafe(this.writer);
			};
			static write(this: TextWriter, value: char[]): TextWriter := {
				this.writer.write(this.writer, value);
				return .result := this;
			};
			static write(this: TextWriter, value: char): TextWriter := {
				buffer: char[1] := {
					buffer[0] := value;
				};
				return .result := write(this, buffer);
			};
			static write(this: TextWriter, value: bool): TextWriter := {
				if (value) {
					return .result := write(this, "true");
				}
				return .result := write(this, "false");
			};
			static write(this: TextWriter, value: int32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: int64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: Writeable): TextWriter := {
				value.write(value, this);
				return .result := this;
			};
			static writeln(this: TextWriter): TextWriter := {
				return .result := write(this, "\n");
			};
			static writeln(this: TextWriter, value: Writeable): TextWriter := {
				return .result := writeln(write(this, value));
			};
			static copy(writer: TextWriter, reader: TextReader): int32 := {
				buffer: uint32[1024] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					n: int32 := reader.decode(reader, buffer);
					if (n <= 0) {
						return .result := result;
					}
					encode(writer, buffer[...n]);
					result := result + n;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Base64Encoder: struct {
			static const lookup: uint8[] := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
			const writer: ByteWriter;
			buffer: uint8[1024];
			bufferSize: int32 := 0;
			padding: int32 := 0;
			const wrap: int32 := 80;
			wrapSize: int32 := 0;
			static flushBuffer(this: Base64Encoder): void := {
				writer: ByteWriter := this.writer;
				size: int32 := this.bufferSize;
				wrap: int32 := this.wrap - this.wrapSize;
				if (wrap > size || this.wrap == 0) {
					wrap := size;
				}
				writer.write(writer, this.buffer[...wrap]);
				this.wrapSize := this.wrapSize + wrap;
				for ( ; wrap < size; ) {
					writer.write(writer, "\n");
					len: int32 := Math.min(size - wrap, this.wrap);
					buffer: uint8[*] := inc(this.buffer, wrap);
					writer.write(writer, buffer[...len]);
					this.wrapSize := len;
					wrap := wrap + len;
				}
				this.bufferSize := 0;
			};
			static write(this: Base64Encoder, data: uint8[]): void := {
				assert(buffer.(length) > 3);
				writer: ByteWriter := this.writer;
				buffer: uint8[] := this.buffer;
				size: int32 := this.bufferSize;
				i: int32 := 0;
				if (size > 3 && buffer[size - 1] == ('=') && data.length > (0)) {
					if (buffer[size - 2] == ('=')) {
						if (data.length < (2)) {
							b: int32 := ((this.padding << 6) | (((data[i]) & 255) << 2));
							buffer[size - 3] := lookup[b >> 6 & 63];
							buffer[size - 2] := lookup[b & 63];
							this.padding := b;
							return;
						}
						b: int32 := (this.padding << 12) | (((data[i]) & 255) << 8) | ((data[i + 1]) & 255);
						buffer[size - 3] := lookup[b >> 12 & 63];
						buffer[size - 2] := lookup[b >> 6 & 63];
						buffer[size - 1] := lookup[b & 63];
						i := i + 2;
					}
					else {
						b: int32 := (this.padding << 6) | ((data[i]) & 255);
						buffer[size - 2] := lookup[b >> 6 & 63];
						buffer[size - 1] := lookup[b & 63];
						i := i + 1;
					}
				}
				for (n: int32 := data.length - (2); i < n; i := i + 3) {
					if (size + 4 > (buffer.length)) {
						flushBuffer(this);
					}
					b: int32 := (((data[i + 0]) & 255) << 16) | (((data[i + 1]) & 255) << 8) | (((data[i + 2]) & 255) << 0);
					buffer[size + 0] := lookup[b >> 18 & 63];
					buffer[size + 1] := lookup[b >> 12 & 63];
					buffer[size + 2] := lookup[b >> 6 & 63];
					buffer[size + 3] := lookup[b & 63];
					size := size + 4;
				}
				if (left) {
					if (size + 4 > (buffer.length)) {
						flushBuffer(this);
					}
					if (left == 2) {
						b: int32 := (((data[i + 0]) & 255) << 10) | (((data[i + 1]) & 255) << 2);
						buffer[size + 0] := lookup[b >> 12 & 63];
						buffer[size + 1] := lookup[b >> 6 & 63];
						buffer[size + 2] := lookup[b & 63];
						buffer[size + 3] := ('=');
						this.padding := b;
						size := size + 4;
					}
					else {
						b: int32 := ((data[i]) & 255) << 4;
						buffer[size + 0] := lookup[(b >> 6) & 63];
						buffer[size + 1] := lookup[(b >> 0) & 63];
						buffer[size + 2] := ('=');
						buffer[size + 3] := ('=');
						this.padding := b;
						size := size + 4;
					}
				}
			};
			static flush(this: Base64Encoder): void := {
				flushBuffer(this);
				flush(this.writer);
			};
			static close(this: Base64Encoder): void := {
				flushBuffer(this);
			};
			write(this: ByteWriter, bytes: uint8[]): void;
			flush(this: ByteWriter): void;
			static write(this: ByteWriter, oneByte: uint8): void := {
				bytes: uint8[1] := {
					bytes[0] := oneByte;
				};
				return .result := this.write(this, bytes);
			};
			static copy(this: ByteWriter, reader: ByteReader): int32 := {
				buffer: uint8[4096] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					read: int32 := reader.read(reader, buffer);
					if (read <= 0) {
						return .result := result;
					}
					this.write(this, buffer[...read]);
					result := result + read;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Base64Decoder: struct {
			static const lookup: int32[256] := {
				lookup[0] := -1;
				lookup[1] := -1;
				lookup[2] := -1;
				lookup[3] := -1;
				lookup[4] := -1;
				lookup[5] := -1;
				lookup[6] := -1;
				lookup[7] := -1;
				lookup[8] := -1;
				lookup[9] := -1;
				lookup[10] := -1;
				lookup[11] := -1;
				lookup[12] := -1;
				lookup[13] := -1;
				lookup[14] := -1;
				lookup[15] := -1;
				lookup[16] := -1;
				lookup[17] := -1;
				lookup[18] := -1;
				lookup[19] := -1;
				lookup[20] := -1;
				lookup[21] := -1;
				lookup[22] := -1;
				lookup[23] := -1;
				lookup[24] := -1;
				lookup[25] := -1;
				lookup[26] := -1;
				lookup[27] := -1;
				lookup[28] := -1;
				lookup[29] := -1;
				lookup[30] := -1;
				lookup[31] := -1;
				lookup[32] := -1;
				lookup[33] := -1;
				lookup[34] := -1;
				lookup[35] := -1;
				lookup[36] := -1;
				lookup[37] := -1;
				lookup[38] := -1;
				lookup[39] := -1;
				lookup[40] := -1;
				lookup[41] := -1;
				lookup[42] := -1;
				lookup[43] := 62;
				lookup[44] := -1;
				lookup[45] := -1;
				lookup[46] := -1;
				lookup[47] := 63;
				lookup[48] := 52;
				lookup[49] := 53;
				lookup[50] := 54;
				lookup[51] := 55;
				lookup[52] := 56;
				lookup[53] := 57;
				lookup[54] := 58;
				lookup[55] := 59;
				lookup[56] := 60;
				lookup[57] := 61;
				lookup[58] := -1;
				lookup[59] := -1;
				lookup[60] := -1;
				lookup[61] := -2;
				lookup[62] := -1;
				lookup[63] := -1;
				lookup[64] := -1;
				lookup[65] := 0;
				lookup[66] := 1;
				lookup[67] := 2;
				lookup[68] := 3;
				lookup[69] := 4;
				lookup[70] := 5;
				lookup[71] := 6;
				lookup[72] := 7;
				lookup[73] := 8;
				lookup[74] := 9;
				lookup[75] := 10;
				lookup[76] := 11;
				lookup[77] := 12;
				lookup[78] := 13;
				lookup[79] := 14;
				lookup[80] := 15;
				lookup[81] := 16;
				lookup[82] := 17;
				lookup[83] := 18;
				lookup[84] := 19;
				lookup[85] := 20;
				lookup[86] := 21;
				lookup[87] := 22;
				lookup[88] := 23;
				lookup[89] := 24;
				lookup[90] := 25;
				lookup[91] := -1;
				lookup[92] := -1;
				lookup[93] := -1;
				lookup[94] := -1;
				lookup[95] := -1;
				lookup[96] := -1;
				lookup[97] := 26;
				lookup[98] := 27;
				lookup[99] := 28;
				lookup[100] := 29;
				lookup[101] := 30;
				lookup[102] := 31;
				lookup[103] := 32;
				lookup[104] := 33;
				lookup[105] := 34;
				lookup[106] := 35;
				lookup[107] := 36;
				lookup[108] := 37;
				lookup[109] := 38;
				lookup[110] := 39;
				lookup[111] := 40;
				lookup[112] := 41;
				lookup[113] := 42;
				lookup[114] := 43;
				lookup[115] := 44;
				lookup[116] := 45;
				lookup[117] := 46;
				lookup[118] := 47;
				lookup[119] := 48;
				lookup[120] := 49;
				lookup[121] := 50;
				lookup[122] := 51;
				lookup[123] := -1;
				lookup[124] := -1;
				lookup[125] := -1;
				lookup[126] := -1;
				lookup[127] := -1;
				lookup[128] := -1;
				lookup[129] := -1;
				lookup[130] := -1;
				lookup[131] := -1;
				lookup[132] := -1;
				lookup[133] := -1;
				lookup[134] := -1;
				lookup[135] := -1;
				lookup[136] := -1;
				lookup[137] := -1;
				lookup[138] := -1;
				lookup[139] := -1;
				lookup[140] := -1;
				lookup[141] := -1;
				lookup[142] := -1;
				lookup[143] := -1;
				lookup[144] := -1;
				lookup[145] := -1;
				lookup[146] := -1;
				lookup[147] := -1;
				lookup[148] := -1;
				lookup[149] := -1;
				lookup[150] := -1;
				lookup[151] := -1;
				lookup[152] := -1;
				lookup[153] := -1;
				lookup[154] := -1;
				lookup[155] := -1;
				lookup[156] := -1;
				lookup[157] := -1;
				lookup[158] := -1;
				lookup[159] := -1;
				lookup[160] := -1;
				lookup[161] := -1;
				lookup[162] := -1;
				lookup[163] := -1;
				lookup[164] := -1;
				lookup[165] := -1;
				lookup[166] := -1;
				lookup[167] := -1;
				lookup[168] := -1;
				lookup[169] := -1;
				lookup[170] := -1;
				lookup[171] := -1;
				lookup[172] := -1;
				lookup[173] := -1;
				lookup[174] := -1;
				lookup[175] := -1;
				lookup[176] := -1;
				lookup[177] := -1;
				lookup[178] := -1;
				lookup[179] := -1;
				lookup[180] := -1;
				lookup[181] := -1;
				lookup[182] := -1;
				lookup[183] := -1;
				lookup[184] := -1;
				lookup[185] := -1;
				lookup[186] := -1;
				lookup[187] := -1;
				lookup[188] := -1;
				lookup[189] := -1;
				lookup[190] := -1;
				lookup[191] := -1;
				lookup[192] := -1;
				lookup[193] := -1;
				lookup[194] := -1;
				lookup[195] := -1;
				lookup[196] := -1;
				lookup[197] := -1;
				lookup[198] := -1;
				lookup[199] := -1;
				lookup[200] := -1;
				lookup[201] := -1;
				lookup[202] := -1;
				lookup[203] := -1;
				lookup[204] := -1;
				lookup[205] := -1;
				lookup[206] := -1;
				lookup[207] := -1;
				lookup[208] := -1;
				lookup[209] := -1;
				lookup[210] := -1;
				lookup[211] := -1;
				lookup[212] := -1;
				lookup[213] := -1;
				lookup[214] := -1;
				lookup[215] := -1;
				lookup[216] := -1;
				lookup[217] := -1;
				lookup[218] := -1;
				lookup[219] := -1;
				lookup[220] := -1;
				lookup[221] := -1;
				lookup[222] := -1;
				lookup[223] := -1;
				lookup[224] := -1;
				lookup[225] := -1;
				lookup[226] := -1;
				lookup[227] := -1;
				lookup[228] := -1;
				lookup[229] := -1;
				lookup[230] := -1;
				lookup[231] := -1;
				lookup[232] := -1;
				lookup[233] := -1;
				lookup[234] := -1;
				lookup[235] := -1;
				lookup[236] := -1;
				lookup[237] := -1;
				lookup[238] := -1;
				lookup[239] := -1;
				lookup[240] := -1;
				lookup[241] := -1;
				lookup[242] := -1;
				lookup[243] := -1;
				lookup[244] := -1;
				lookup[245] := -1;
				lookup[246] := -1;
				lookup[247] := -1;
				lookup[248] := -1;
				lookup[249] := -1;
				lookup[250] := -1;
				lookup[251] := -1;
				lookup[252] := -1;
				lookup[253] := -1;
				lookup[254] := -1;
				lookup[255] := -1;
			};
			const reader: ByteReader;
			bitsDecoded: int32 := 0;
			charDecoded: int32 := 0;
			static read(this: Base64Decoder, data: uint8[]): int32 := {
				isWhite(c: char): bool := c == ' ' || c == '\t' || c == '\n' || c == '\r';
				in: uint8[1] := {
					in[0] := (0);
				};
				reader: ByteReader := this.reader;
				bitsDecoded: typename := this.bitsDecoded;
				charDecoded: typename := this.charDecoded;
				for (i: int32 := 0; i < (data.length); ) {
					if (reader.read(reader, in) <= 0) {
						return .result := i;
					}
					else if (in[0] == ('=')) {
						bitsDecoded := bitsDecoded - 2;
					}
					else if (!isWhite(in[0])) {
						bitsDecoded := bitsDecoded + 6;
						charDecoded := charDecoded << 6;
						charDecoded := charDecoded | lookup[in[0]] & 63;
						if (bitsDecoded >= 8) {
							bitsDecoded := bitsDecoded - 8;
							data[i] := uint8(charDecoded >> bitsDecoded);
							i := i + 1;
						}
					}
				}
				return .result := data.length;
			};
			static close(this: Base64Decoder): void := {
				assert(this.bitsDecoded == 0, "unprocessed bits remaining.", this.bitsDecoded);
			};
			read(this: ByteReader, bytes: uint8[]): int32;
			static read(this: ByteReader): int32 := {
				bytes: uint8[1] := {
					bytes[0] := (0);
				};
				if (read(this, bytes) <= 0) {
					return .result := -1;
				}
				return .result := bytes[0];
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const AsciiReader: struct {
			static decode(this: AsciiReader, chars: uint32[]): int32 := {
				reader: ByteReader := this.reader;
				for (i: int32 := 0; i < (chars.length); i := i + 1) {
					value: uint8[1] := {
					};
					if (reader.read(reader, value) <= 0) {
						return .result := i;
					}
					chars[i] := (value[0]);
				}
				return .result := chars.length;
			};
			const reader: ByteReader;
			decode(this: TextReader, chars: uint32[]): int32;
			static close(this: TextReader): void := {
				Closeable.closeSafe(this.reader);
			};
			static decode(this: TextReader): int32 := {
				chars: uint32[1] := {
					chars[0] := (0);
				};
				if (decode(this, chars) <= 0) {
					return .result := -1;
				}
				return .result := chars[0] & (16777215);
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const AsciiWriter: struct {
			static encode(this: TextWriter, chars: uint32[]): void := {
				writer: ByteWriter := this.writer;
				for (i: int32 := 0; i < (chars.length); i := i + 1) {
					value: uint8[1] := {
						value[0] := (chars[i]);
					};
					writer.write(writer, value);
				}
			};
			static const Writeable: struct {
				write(this: Writeable, writer: TextWriter): void;
				const .type: typename;
				static const create(type: typename): pointer := nfc(7);
				static const destroy(this: object): void := nfc(8);
				static const as(this: object, type: typename): pointer := nfc(9);
				static const type(this: object): typename := nfc(10);
			};
			const writer: ByteWriter;
			const format: FormatFlags;
			encode(this: TextWriter, chars: uint32[]): void;
			static flush(this: TextWriter): void := {
				this.writer.flush(this.writer);
			};
			const flush(this: TextWriter): void := flush;
			static close(this: TextWriter): void := {
				Closeable.closeSafe(this.writer);
			};
			static write(this: TextWriter, value: char[]): TextWriter := {
				this.writer.write(this.writer, value);
				return .result := this;
			};
			static write(this: TextWriter, value: char): TextWriter := {
				buffer: char[1] := {
					buffer[0] := value;
				};
				return .result := write(this, buffer);
			};
			static write(this: TextWriter, value: bool): TextWriter := {
				if (value) {
					return .result := write(this, "true");
				}
				return .result := write(this, "false");
			};
			static write(this: TextWriter, value: int32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: int64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: Writeable): TextWriter := {
				value.write(value, this);
				return .result := this;
			};
			static writeln(this: TextWriter): TextWriter := {
				return .result := write(this, "\n");
			};
			static writeln(this: TextWriter, value: Writeable): TextWriter := {
				return .result := writeln(write(this, value));
			};
			static copy(writer: TextWriter, reader: TextReader): int32 := {
				buffer: uint32[1024] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					n: int32 := reader.decode(reader, buffer);
					if (n <= 0) {
						return .result := result;
					}
					encode(writer, buffer[...n]);
					result := result + n;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Utf8Reader: struct {
			static decode(this: Utf8Reader, chars: uint32[]): int32 := {
				buff: uint8[1] := {
					buff[0] := (0);
				};
				ext: uint8[3] := {
					ext[0] := (0);
				};
				reader: ByteReader := this.reader;
				for (i: int32 := 0; i < (chars.length); i := i + 1) {
					if (reader.read(reader, buff) <= 0) {
						return .result := i;
					}
					if (((buff[0]) & 128) == 0) {
						chars[i] := (buff[0]);
					}
					else if (((buff[0]) & 224) == 192) {
						if (reader.read(reader, ext[...1]) != 1) {
							error("invalid codepoint");
							return .result := i;
						}
						assert(((ext[0]) & 192) == 128, "10xxxxxx");
						chars[i] := (((buff[0]) & 31) << 6 | ((ext[0]) & 63));
					}
					else if (((buff[0]) & 240) == 224) {
						if (reader.read(reader, ext[...2]) != 2) {
							error("invalid codepoint");
							return .result := i;
						}
						assert(((ext[0]) & 192) == 128, "10xxxxxx");
						assert(((ext[1]) & 192) == 128, "10xxxxxx");
						chars[i] := (((buff[0]) & 15) << 12 | ((ext[0]) & 63) << 6 | ((ext[1]) & 63));
					}
					else if (((buff[0]) & 248) == 240) {
						if (reader.read(reader, ext[...3]) != 3) {
							error("invalid codepoint");
							return .result := i;
						}
						assert(((ext[0]) & 192) == 128, "10xxxxxx");
						assert(((ext[1]) & 192) == 128, "10xxxxxx");
						assert(((ext[2]) & 192) == 128, "10xxxxxx");
						chars[i] := (((buff[0]) & 7) << 18 | ((ext[0]) & 63) << 12 | ((ext[1]) & 63) << 6 | ((ext[2]) & 63));
					}
				}
				return .result := chars.length;
			};
			const reader: ByteReader;
			decode(this: TextReader, chars: uint32[]): int32;
			static close(this: TextReader): void := {
				Closeable.closeSafe(this.reader);
			};
			static decode(this: TextReader): int32 := {
				chars: uint32[1] := {
					chars[0] := (0);
				};
				if (decode(this, chars) <= 0) {
					return .result := -1;
				}
				return .result := chars[0] & (16777215);
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Utf8Writer: struct {
			static encode(this: Utf8Writer, chars: uint32[]): void := {
				writer: ByteWriter := this.writer;
				for (i: int32 := 0; i < (chars.length); i := i + 1) {
					cp: uint32 := chars[i];
					if (cp < (128)) {
						bytes: uint8[1] := {
							bytes[0] := (cp);
						};
						writer.write(writer, bytes[...1]);
					}
					else if (cp < (2048)) {
						bytes: uint8[2] := {
							bytes[0] := (192 | ((cp >> 6)));
							bytes[1] := (128 | ((cp & (63))));
						};
						writer.write(writer, bytes[...2]);
					}
					else if (cp < (65536)) {
						bytes: uint8[3] := {
							bytes[0] := (224 | ((cp >> 12)));
							bytes[1] := (128 | (((cp >> 6) & (63))));
							bytes[2] := (128 | ((cp & (63))));
						};
						writer.write(writer, bytes[...3]);
					}
					else {
						bytes: uint8[4] := {
							bytes[0] := (240 | ((cp >> 18)));
							bytes[1] := (128 | (((cp >> 12) & (63))));
							bytes[2] := (128 | (((cp >> 6) & (63))));
							bytes[3] := (128 | ((cp & (63))));
						};
						writer.write(writer, bytes[...4]);
					}
				}
			};
			static const Writeable: struct {
				write(this: Writeable, writer: TextWriter): void;
				const .type: typename;
				static const create(type: typename): pointer := nfc(7);
				static const destroy(this: object): void := nfc(8);
				static const as(this: object, type: typename): pointer := nfc(9);
				static const type(this: object): typename := nfc(10);
			};
			const writer: ByteWriter;
			const format: FormatFlags;
			encode(this: TextWriter, chars: uint32[]): void;
			static flush(this: TextWriter): void := {
				this.writer.flush(this.writer);
			};
			const flush(this: TextWriter): void := flush;
			static close(this: TextWriter): void := {
				Closeable.closeSafe(this.writer);
			};
			static write(this: TextWriter, value: char[]): TextWriter := {
				this.writer.write(this.writer, value);
				return .result := this;
			};
			static write(this: TextWriter, value: char): TextWriter := {
				buffer: char[1] := {
					buffer[0] := value;
				};
				return .result := write(this, buffer);
			};
			static write(this: TextWriter, value: bool): TextWriter := {
				if (value) {
					return .result := write(this, "true");
				}
				return .result := write(this, "false");
			};
			static write(this: TextWriter, value: int32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: int64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: uint64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float32, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: float64, const flags: FormatFlags): TextWriter := {
				buff: char[1024] := {
				};
				n: int32 := append(buff, 0, value, flags);
				return .result := write(this, buff[...n]);
			};
			static write(this: TextWriter, value: Writeable): TextWriter := {
				value.write(value, this);
				return .result := this;
			};
			static writeln(this: TextWriter): TextWriter := {
				return .result := write(this, "\n");
			};
			static writeln(this: TextWriter, value: Writeable): TextWriter := {
				return .result := writeln(write(this, value));
			};
			static copy(writer: TextWriter, reader: TextReader): int32 := {
				buffer: uint32[1024] := {
				};
				result: int32 := 0;
				for ( ; ; ) {
					n: int32 := reader.decode(reader, buffer);
					if (n <= 0) {
						return .result := result;
					}
					encode(writer, buffer[...n]);
					result := result + n;
				}
				return .result := result;
			};
			close(this: Closeable): void;
			static closeSafe(this: Closeable): void := {
				if ((this.close) == null) {
					return;
				}
				this.close(this);
			};
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const Easing: struct {
			static linear(t: float64): float64 := {
				return .result := t;
			};
			static quad(t: float64): float64 := {
				return .result := t * t;
			};
			static cubic(t: float64): float64 := {
				return .result := t * t * t;
			};
			static quart(t: float64): float64 := {
				return .result := t * t * t * t;
			};
			static quint(t: float64): float64 := {
				return .result := t * t * t * t * t;
			};
			static expo(t: float64): float64 := {
				return .result := t == (0) ? (0) : Math.pow(2.000000, (10) * (t - (1)));
			};
			static sine(t: float64): float64 := {
				return .result := -Math.cos(t * Math.pi / (2)) + (1);
			};
			static circle(t: float64): float64 := {
				return .result := -(Math.sqrt((1) - t * t) - (1));
			};
			static elastic(t: float64): float64 := {
				if (t == 0.000000 || t == 1.000000) {
					return .result := t;
				}
				t := t - 1.000000;
				return .result := -Math.pow(2.000000, 10.000000 * t) * Math.sin((t - 0.300000 / 4.000000) * (2.000000 * Math.pi) / 0.300000);
			};
			static back(t: float64): float64 := {
				s: typename := 1.701580;
				return .result := t * t * ((s + (1)) * t - s);
			};
			static bounce(t: float64): float64 := {
				static Helper(t: float64, c: float64, a: float64): float64 := {
					if (t == (1)) {
						return .result := c;
					}
					if (t < ((4) / 11.000000)) {
						return .result := c * (7.562500 * t * t);
					}
					if (t < ((8) / 11.000000)) {
						t := t - ((6) / 11.000000);
						return .result := -a * ((1) - (7.562500 * t * t + 0.750000)) + c;
					}
					if (t < ((10) / 11.000000)) {
						t := t - (((9) / 11.000000));
						return .result := -a * ((1) - (7.562500 * t * t + 0.937500)) + c;
					}
					t := t - ((21) / 22.000000);
					return .result := -a * ((1) - (7.562500 * t * t + 0.984375)) + c;
				};
				a: typename := 1.701580;
				return .result := (1) - Helper((1) - t, 1, a);
			};
		};
		static in(ease(ratio: float64): float64, ratio: float64): float64 := {
			if ((ease) == null) {
				return .result := ratio;
			}
			return .result := ease(ratio);
		};
		static out(ease(ratio: float64): float64, ratio: float64): float64 := {
			if ((ease) == null) {
				return .result := ratio;
			}
			return .result := 1.000000 - ease((1) - ratio);
		};
		static inOut(ease(ratio: float64): float64, ratio: float64): float64 := {
			if ((ease) == null) {
				return .result := ratio;
			}
			ratio := ratio * (2);
			return .result := (ratio < (1)) ? 0.500000 * ease(ratio) : 0.500000 * out(ease, ratio - (1)) + 0.500000;
		};
		static outIn(ease(ratio: float64): float64, ratio: float64): float64 := {
			if ((ease) == null) {
				return .result := ratio;
			}
			ratio := ratio * (2);
			return .result := (ratio < (1)) ? 0.500000 * out(ease, ratio) : 0.500000 * ease(ratio - (1)) + 0.500000;
		};
		scalar: typename := float64;
		static const Polynomial: struct {
			coefficients: float64[*];
			capacity: int32;
			static const c_zero: float64 := (0);
			static const c_unit: float64 := (1);
			static write(this: Polynomial, writer: TextWriter): void := {
				first: bool := true;
				for (i: int32 := this.capacity - 1; i >= 0; i := i - 1) {
					if (this.coefficients[i] == c_zero && !(first && i == 0)) {
						continue;
					}
					value: float64 := this.coefficients[i];
					if (value < c_zero) {
						value := -value;
						if (!first) {
							TextWriter.write(writer, " - ");
						}
						else {
							TextWriter.write(writer, "-");
						}
					}
					else if (!first) {
						TextWriter.write(writer, " + ");
					}
					if (value != c_unit || i == 0) {
						TextWriter.write(writer, value, writer.format);
					}
					if (i > 0) {
						TextWriter.write(writer, "x");
						if (i > 1) {
							TextWriter.write(writer, "^");
							TextWriter.write(writer, i, writer.format);
						}
					}
					first := false;
				}
			};
			static destroy(this: Polynomial): void := {
				pointer.alloc(this.coefficients, 0);
			};
			const destroy(this: Polynomial): void := destroy;
			static create(degree: int32, values: float64[]): Polynomial := {
				capacity: int32 := Math.max(0, degree) + 1;
				assert(capacity >= (values.length));
				coefficients: float64[*] := pointer.alloc(null, capacity * sizeof(float64));
				result: Polynomial := {
					result := create(Polynomial);
					result.coefficients := (coefficients);
					result.capacity := capacity;
					result.destroy := destroy;
					result.write := write;
				};
				for (i: int32 := 0; i < (values.length); i := i + 1) {
					result.coefficients[i] := values[i];
				}
				for (i: int32 := values.length; i < capacity; i := i + 1) {
					result.coefficients[i] := c_zero;
				}
				return .result := result;
			};
			static degree(this: Polynomial): int32 := {
				for (i: int32 := this.capacity - 1; i > 0; i := i - 1) {
					if (this.coefficients[i] != c_zero) {
						return .result := i;
					}
				}
				return .result := 0;
			};
			static get(const this: Polynomial, index: int32): float64 := {
				assert(index >= 0, "negative index", index);
				if (index >= this.capacity) {
					return .result := c_zero;
				}
				return .result := this.coefficients[index];
			};
			static set(this: Polynomial, index: int32, value: float64): float64 := {
				assert(index >= 0, "negative index", index);
				assert(index < this.capacity, "invalid index");
				return .result := this.coefficients[index];
			};
			static neg(const a: Polynomial): Polynomial := {
				result: Polynomial := create(degree(a), null);
				for (i: int32 := 0; i < result.capacity; i := i + 1) {
					result.coefficients[i] := -get(a, i);
				}
				return .result := result;
			};
			static add(const a: Polynomial, const b: Polynomial): Polynomial := {
				result: Polynomial := create(Math.max(degree(a), degree(b)), null);
				for (i: int32 := 0; i < result.capacity; i := i + 1) {
					result.coefficients[i] := get(a, i) + get(b, i);
				}
				return .result := result;
			};
			static sub(const a: Polynomial, const b: Polynomial): Polynomial := {
				result: Polynomial := create(Math.max(degree(a), degree(b)), null);
				for (i: int32 := 0; i < result.capacity; i := i + 1) {
					result.coefficients[i] := get(a, i) - get(b, i);
				}
				return .result := result;
			};
			static mul(const a: Polynomial, const b: Polynomial): Polynomial := {
				degreeA: int32 := degree(a);
				degreeB: int32 := degree(b);
				result: Polynomial := create(degreeA + degreeB, null);
				for (i: int32 := 0; i <= degreeA; i := i + 1) {
					for (j: int32 := 0; j <= degreeB; j := j + 1) {
						result.coefficients[i + j] := result.coefficients[i + j] + get(a, i) * get(b, j);
					}
				}
				return .result := result;
			};
			static evaluate(const this: Polynomial, value: float64): float64 := {
				result: float64 := c_zero;
				for (i: int32 := degree(this); i >= 0; i := i - 1) {
					result := result * value + this.coefficients[i];
				}
				return .result := result;
			};
			static derivative(const this: Polynomial): Polynomial := {
				result: Polynomial := create(degree(this) - 1, null);
				for (i: int32 := 0; i < result.capacity; i := i + 1) {
					result.coefficients[i] := ((i + 1)) * this.coefficients[i + 1];
				}
				return .result := result;
			};
			static integral(const this: Polynomial, c: float64): Polynomial := {
				result: Polynomial := create(degree(this) + 1, null);
				result.coefficients[0] := c;
				for (i: int32 := 1; i < result.capacity; i := i + 1) {
					result.coefficients[i] := this.coefficients[i - 1] / (i);
				}
				return .result := result;
			};
			write(this: Writeable, writer: TextWriter): void;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		Polynomial(const copy: Polynomial): Polynomial := Polynomial.create(Polynomial.degree(copy), copy.coefficients);
		static Polynomial(values: float64[]): Polynomial := {
			result: Polynomial := Polynomial.create(values.length - (1), null);
			for (i: int32 := 0; i < (values.length); i := i + 1) {
				result.coefficients[i] := values[values.length - (i) - (1)];
			}
			return .result := result;
		};
	}
	{
		integer: typename := int64;
		emitldz32: int32 := emit(load.z32);
		emitldz64: int64 := emit(load.z64);
		emitA: int32 := 42;
		emitB: int32 := 96;
		emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32);
		emitDivI32: int32 := emit(int32(10), int32(5), div.i32);
		emitNfcF32: float32 := emit(float32(3.140000), float32(2), div.f32, float32.sin);
		floatAsInt32(value: float32): int32 := int32(emit(float32(value)));
		floatAsInt64(value: float64): int64 := int64(emit(float64(value)));
		emitFloatAsInt1: int32 := floatAsInt32(500);
		emitFloatAsInt2: int64 := floatAsInt32(500);
		emitFloatAsInt3: int32 := floatAsInt64(500);
		emitFloatAsInt4: int64 := floatAsInt64(500);
		emitSlice: char[] := emit(int32(3), pointer("string"));
		zero(a: int32, b: int32): int32 := 0;
		last(a: int32, b: int32): int32 := b;
		sum(a: int32, b: int32): int32 := a + b;
		any(a: int32, b: int32): int32 := (a) ? a : b;
		min(a: int32, b: int32): int32 := a < b ? a : b;
		max(a: int32, b: int32): int32 := a > b ? a : b;
		i3: int32 := 3;
		i6: int32 := 6;
		i2: int32 := 2;
		i8: int32 := 8;
		zeroVal: int32 := zero(3, 6);
		zeroVar: int32 := zero(i3, i6);
		zeroXpr: int32 := zero(i3 + 1, i6 + 1);
		lastVal: int32 := last(3, 6);
		lastVar: int32 := last(i3, i6);
		lastXpr: int32 := last(i3 + 1, i6 + 1) - 1;
		sum2Val: int32 := sum(3, 6);
		sum2Var: int32 := sum(i3, i6);
		sum2Xpr: int32 := sum(i3 + 1, i6 + 1) - 2;
		any2Val: int32 := any(3, 6);
		any2Var: int32 := any(i3, i6);
		any2Xpr: int32 := any(i3 + 1, i6 + 1) - 1;
		min2Val: int32 := min(3, 6);
		min2Var: int32 := min(i3, i6);
		min2Xpr: int32 := min(i3 + 1, i6 + 1) - 1;
		max2Val: int32 := max(3, 6);
		max2Var: int32 := max(i3, i6);
		max2Xpr: int32 := max(i3 + 1, i6 + 1) - 1;
		sumLr(a: int32, b: int32, c: int32, d: int32): int32 := sum(a, sum(b, sum(c, d)));
		sumRl(a: int32, b: int32, c: int32, d: int32): int32 := sum(sum(sum(a, b), c), d);
		sumRlVal: int32 := sumLr(3, 6, 2, 8);
		sumLrVal: int32 := sumRl(3, 6, 2, 8);
		sumRlVar: int32 := sumLr(i3, i6, i2, i8);
		sumLrVar: int32 := sumRl(i3, i6, i2, i8);
		sumRlXpr: int32 := sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4;
		sumLrXpr: int32 := sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4;
		anyLr(a: int32, b: int32, c: int32, d: int32): int32 := any(a, any(b, any(c, d)));
		anyRl(a: int32, b: int32, c: int32, d: int32): int32 := any(any(any(a, b), c), d);
		anyRlVal: int32 := anyLr(3, 6, 2, 8);
		anyLrVal: int32 := anyRl(3, 6, 2, 8);
		anyRlVar: int32 := anyLr(i3, i6, i2, i8);
		anyLrVar: int32 := anyRl(i3, i6, i2, i8);
		anyRlXpr: int32 := anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		anyLrXpr: int32 := anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		minLr(a: int32, b: int32, c: int32, d: int32): int32 := min(a, min(b, min(c, d)));
		minRl(a: int32, b: int32, c: int32, d: int32): int32 := min(min(min(a, b), c), d);
		minRlVal: int32 := minLr(3, 6, 2, 8);
		minLrVal: int32 := minRl(3, 6, 2, 8);
		minRlVar: int32 := minLr(i3, i6, i2, i8);
		minLrVar: int32 := minRl(i3, i6, i2, i8);
		minRlXpr: int32 := minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		minLrXpr: int32 := minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		maxLr(a: int32, b: int32, c: int32, d: int32): int32 := max(a, max(b, max(c, d)));
		maxRl(a: int32, b: int32, c: int32, d: int32): int32 := max(max(max(a, b), c), d);
		maxRlVal: int32 := maxLr(3, 6, 2, 8);
		maxLrVal: int32 := maxRl(3, 6, 2, 8);
		maxRlVar: int32 := maxLr(i3, i6, i2, i8);
		maxLrVar: int32 := maxRl(i3, i6, i2, i8);
		maxRlXpr: int32 := maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		maxLrXpr: int32 := maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1;
		overload: typename := 1;
		overload(): int32 := 2;
		overload(a: int32): int32 := 3;
		overload(a: float32): int32 := 4;
		overload(a: int32, b: int32): int32 := 5;
		overload1: float32 := overload;
		overload2: float32 := overload();
		overload3: float32 := overload(0);
		overload4: float32 := overload(0.000000);
		overload5: float32 := overload(0, 0);
		static const Celsius: struct {
			degrees: float64;
		};
		static const Fahrenheit: struct {
			degrees: float64;
		};
		Celsius(value: float64): Celsius := Celsius(emit(float64(value)));
		Fahrenheit(value: float64): Fahrenheit := Fahrenheit(emit(float64(value)));
		Celsius(value: Fahrenheit): Celsius := Celsius((value.degrees - (32)) / 1.800000);
		Fahrenheit(value: Celsius): Fahrenheit := Fahrenheit(value.degrees * 1.800000 + (32));
		boilC: Celsius := Celsius(100.000000);
		boilF: Fahrenheit := Fahrenheit(boilC);
		realloc(data: pointer, size: int32): pointer := pointer.alloc(data, size);
		malloc(size: int32): pointer := pointer.alloc(null, size);
		free(data: pointer): pointer := pointer.alloc(data, 0);
		p1: pointer := malloc(1024);
		p2: pointer := malloc(80);
		p3: pointer := malloc(160);
		p4: pointer := malloc(820);
		pointer.fill(p1, 0, 1024);
		pointer.copy(p1, p3, 160);
		free(p1);
		free(p2);
		free(p3);
		free(p4);
		val1: int64 := 42;
		val2: int64 := 96;
		debug("val1", val1);
		debug("val2", val2);
		pointer.move(pointer(val2), pointer(val1), sizeof(int64));
		pointer.fill(pointer(val1), 0, sizeof(int64));
		debug("val1", val1);
		debug("val2", val2);
		static noError(ptr: pointer): void := {
		};
		static stackOverflow(ptr: pointer): void := {
			data: uint8[8192] := {
			};
			stackOverflow(ptr);
		};
		static divisionByZero(args: pointer): void := {
			value: int32 := 3 / 0;
		};
		static abortExecution(args: pointer): void := {
			static const NotEquals: struct {
				message: char[*];
				expected: int32;
				returned: int32;
			};
			details: NotEquals := {
				details.message := ("assertion failed");
				details.expected := 97;
				details.returned := 77;
			};
			abort("fatal error", details);
		};
		static invalidMemoryAccess(args: pointer): void := {
			i32Ref: int32 := null;
			i32Val: int32 := i32Ref;
		};
		static invalidInstruction(args: pointer): void := {
			emit(load.z32, ret);
		};
		tryExecErr0: int32 := tryExec(null, noError);
		tryExecErr1: int32 := tryExec(null, null);
		tryExecErr2: int32 := tryExec(null, stackOverflow);
		tryExecErr3: int32 := tryExec(null, divisionByZero);
		tryExecErr4: int32 := tryExec(null, invalidInstruction);
		tryExecErr5: int32 := tryExec(null, invalidMemoryAccess);
		tryExecErr6: int32 := tryExec(null, abortExecution);
		arr: int32[5] := {
			arr[0] := 1;
			arr[1] := 2;
			arr[2] := 3;
			arr[3] := 4;
			arr[4] := 5;
		};
		ptr: pointer := arr;
		a0: int32 := arr[0];
		a1: int32 := arr[1];
		a2: int32 := arr[2];
		a3: int32 := arr[3];
		a4: int32 := arr[4];
		assert((ptr) == arr);
		assert(pointer(a0) == inc(ptr, 0 * sizeof(int32)));
		assert(pointer(a1) == inc(ptr, 1 * sizeof(int32)));
		assert(pointer(a2) == inc(ptr, 2 * sizeof(int32)));
		assert(pointer(a3) == inc(ptr, 3 * sizeof(int32)));
		assert(pointer(a4) == inc(ptr, 4 * sizeof(int32)));
		static if ((typename(int64)) == null) {
			integer: typename := int32;
		}
		static value: int64 := 42;
		valueRef: int64 := value;
		valuePtr: pointer := value;
		valueVar: variant := value;
		fromRef: int64 := valueRef;
		fromPtr: int64 := valuePtr;
		fromVar: int64 := valueVar;
		nullRef: int64 := null;
		nullPtr: pointer := null;
		nullVar: variant := null;
		nullTyp: typename := null;
		nullFun: function := null;
		nullObj: object := null;
		typePtr: pointer := int64;
		typeVar: variant := int64;
		typeTyp: typename := int64;
		local: int64 := value;
		copyVal: int64 := local;
		copyRef: int64 := valueRef;
		copyPtr: pointer := valuePtr;
		copyVar: variant := valueVar;
		copyTyp: typename := typeTyp;
		ptrVoid: pointer := void;
		ptrBool: pointer := bool;
		ptrChar: pointer := char;
		ptrInt8: pointer := int8;
		ptrInt16: pointer := int16;
		ptrInt32: pointer := int32;
		ptrInt64: pointer := int64;
		ptrUint8: pointer := uint8;
		ptrUint16: pointer := uint16;
		ptrUint32: pointer := uint32;
		ptrUint64: pointer := uint64;
		ptrFloat32: pointer := float32;
		ptrFloat64: pointer := float64;
		ptrTypename: pointer := typename;
		ptrFunction: pointer := function;
		ptrPointer: pointer := pointer;
		ptrVariant: pointer := variant;
		ptrObject: pointer := object;
		varVoid: variant := void;
		varBool: variant := bool;
		varChar: variant := char;
		varInt8: variant := int8;
		varInt16: variant := int16;
		varInt32: variant := int32;
		varInt64: variant := int64;
		varUint8: variant := uint8;
		varUint16: variant := uint16;
		varUint32: variant := uint32;
		varUint64: variant := uint64;
		varFloat32: variant := float32;
		varFloat64: variant := float64;
		varTypename: variant := typename;
		varFunction: variant := function;
		varPointer: variant := pointer;
		varVariant: variant := variant;
		varObject: variant := object;
		typVoid: typename := void;
		typBool: typename := bool;
		typChar: typename := char;
		typInt8: typename := int8;
		typInt16: typename := int16;
		typInt32: typename := int32;
		typInt64: typename := int64;
		typUint8: typename := uint8;
		typUint16: typename := uint16;
		typUint32: typename := uint32;
		typUint64: typename := uint64;
		typFloat32: typename := float32;
		typFloat64: typename := float64;
		typTypename: typename := typename;
		typFunction: typename := function;
		typPointer: typename := pointer;
		typVariant: typename := variant;
		typObject: typename := object;
		valueOfPtr: pointer := pointer(value);
		valueOfVar: variant := variant(value);
		valueOfTyp: typename := typename(value);
		typeOfValue: typename := typename(value);
		copyPtrFloat64: variant := ptrFloat64;
		copyVarFloat64: pointer := varFloat64;
		variable: int32;
		const constant: int32 := 42;
		static const ComplexVal: struct {
			const re: float64;
			const im: float64 := 0;
		};
		static const ComplexObj: struct {
			const re: float64;
			const im: float64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		valInitImplicit: ComplexVal := {
			valInitImplicit.re := (8);
			valInitImplicit.im := (0);
		};
		objInitImplicit: ComplexObj := {
			objInitImplicit := create(ComplexObj);
			objInitImplicit.re := (8);
			objInitImplicit.im := (0);
		};
		objInitExplicit: object := {
			objInitExplicit := create(ComplexObj);
			objInitExplicit.re := (8);
			objInitExplicit.im := (0);
		};
		static empty(): void := {
		};
		static funAdd(x: int32, y: int32): int32 := {
			return .result := x + y;
		};
		funAddResult: int32 := funAdd(2, 7);
		funAddRef(x: int32, y: int32): int32 := funAdd;
		funAddRefResult: int32 := funAddRef(2, 8);
		funMul(x: int32, y: int32): int32 := funMul;
		funMulResult: int32 := funMul(2, 6);
		funMulRef(x: int32, y: int32): int32 := funMul;
		funMulRefResult: int32 := funMulRef(2, 7);
		static funMul(x: int32, y: int32): int32 := {
			return .result := x * y;
		};
		static fib(n: uint32): uint32 := {
			if (n <= (1)) {
				return .result := n;
			}
			return .result := fib(n - (1)) + fib(n - (2));
		};
		fibonacci_13: uint32 := fib(13);
		sizeofVoid: int32 := sizeof(void);
		sizeofBool: int32 := sizeof(bool);
		sizeofChar: int32 := sizeof(char);
		sizeofInt8: int32 := sizeof(int8);
		sizeofInt16: int32 := sizeof(int16);
		sizeofInt32: int32 := sizeof(int32);
		sizeofInt64: int32 := sizeof(int64);
		sizeofUint8: int32 := sizeof(uint8);
		sizeofUint16: int32 := sizeof(uint16);
		sizeofUint32: int32 := sizeof(uint32);
		sizeofUint64: int32 := sizeof(uint64);
		sizeofFloat32: int32 := sizeof(float32);
		sizeofFloat64: int32 := sizeof(float64);
		sizeofPointer: int32 := sizeof(pointer);
		sizeofVariant: int32 := sizeof(variant);
		sizeofTypename: int32 := sizeof(typename);
		sizeofFunction: int32 := sizeof(function);
		sizeofObject: int32 := sizeof(object);
		static const RecordSizeof: struct {
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		static const RecordSizeofExt: struct {
			y: int32 := 0;
			x: int64 := 0;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		typeofRecord: typename := RecordSizeofExt;
		nameOfRecord: char[*] := typename.name(typeofRecord);
		offsetOfRecord: int32 := typeofRecord.offset;
		sizeOfRecord: int32 := typeofRecord.size;
		fileOfRecord: char[*] := typename.file(typeofRecord);
		lineOfRecord: int32 := typename.line(typeofRecord);
		typeofBase: typename := typename.base(typeofRecord);
		nameOfBase: char[*] := typename.name(typeofBase);
		offsetOfBase: int32 := typeofBase.offset;
		sizeOfBase: int32 := typeofBase.size;
		fileOfBase: char[*] := typename.file(typeofBase);
		lineOfBase: int32 := typename.line(typeofBase);
		typeofBase1: typename := typename.base(typeofBase);
		offsetOfBase1: int32 := typeofBase1.offset;
		sizeOfBase1: int32 := typeofBase1.size;
		typeofBase2: typename := typename.base(typeofBase1);
		offsetOfBase2: int32 := typeofBase2.offset;
		sizeOfBase2: int32 := typeofBase2.size;
		static const RecordMemberTest: struct {
			static const Inner: struct {
				member: int32;
				const constant: int32;
			};
			member: int32;
			const constant: int32;
			memberInit: int32 := 2;
			const constantInit: int32 := 3;
			memberRec: Inner;
			const constantRec: Inner;
			static global: int32;
			static globalInit: int32 := 1;
			static const globalConstant: int32 := 2;
			static globalRec: Inner := {
				globalRec.constant := 4;
				globalRec.member := (0);
			};
			static globalRecInit: Inner := {
				globalRecInit.member := 4;
				globalRecInit.constant := 5;
			};
			static const globalConstantRec: Inner := {
				globalConstantRec.member := 6;
				globalConstantRec.constant := 7;
			};
		};
		recordMemberTest: RecordMemberTest := {
			recordMemberTest.member := 10;
			recordMemberTest.constant := 11;
			recordMemberTest.memberInit := 12;
			recordMemberTest.constantInit := 13;
			recordMemberTest.memberRec.member := 14;
			recordMemberTest.memberRec.constant := 15;
			recordMemberTest.constantRec.member := 16;
			recordMemberTest.constantRec.constant := 17;
		};
		static const RecordMethodTest: struct {
			static staticMethod(this: RecordMethodTest, x: int32): void := {
				trace("staticMethod", x);
			};
			static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			abstractMethod(this: RecordMethodTest, x: int32): void;
			delegateMethod(this: RecordMethodTest, x: int32): void := forwardMethod;
			static virtualMethod(this: RecordMethodTest, x: int32): void := {
				trace("virtualMethod", x);
			};
			const virtualMethod(this: RecordMethodTest, x: int32): void := virtualMethod;
			static forwardMethod(this: RecordMethodTest, x: int32): void := {
				trace("forwardMethod", x);
			};
		};
		static globalFunction(this: RecordMethodTest, x: int32): void := {
			trace("globalFunction", x);
		};
		recordMethodTest: RecordMethodTest := {
			recordMethodTest.abstractMethod := globalFunction;
			recordMethodTest.delegateMethod := forwardMethod;
			recordMethodTest.virtualMethod := virtualMethod;
		};
		RecordMethodTest.staticMethod(recordMethodTest, 1);
		recordMethodTest.virtualMethod(recordMethodTest, 1);
		static staticMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.staticMethod");
			if ((this) != null) {
				RecordMethodTest.staticMethod(this, x);
			}
		};
		static virtualMethod(this: RecordMethodTest, x: int32): void := {
			debug("extension.virtualMethod");
			if ((this) != null) {
				this.virtualMethod(this, x);
			}
		};
		staticMethod(recordMethodTest, 2);
		virtualMethod(recordMethodTest, 2);
		RecordMethodTest.staticMethod(recordMethodTest, 3);
		RecordMethodTest.virtualMethod(recordMethodTest, 3);
		recordMethodTest.virtualMethod(recordMethodTest, 3);
		static const rgbF32: struct {
			r: float32;
			g: float32;
			b: float32;
		};
		static const rgbU8: struct {
			b: uint8;
			g: uint8;
			r: uint8;
		};
		static const color: struct {
			col: uint32;
			rgb: rgbU8;
		};
		static const Color: struct {
			value: rgbF32;
			const .type: typename;
			static const create(type: typename): pointer := nfc(7);
			static const destroy(this: object): void := nfc(8);
			static const as(this: object, type: typename): pointer := nfc(9);
			static const type(this: object): typename := nfc(10);
		};
		black: rgbU8 := {
			black.r := (0);
			black.g := (0);
			black.b := (0);
		};
		green: rgbU8 := {
			green.r := (0);
			green.g := (255);
			green.b := (0);
		};
		white: rgbU8 := {
			white.r := (255);
			white.g := (255);
			white.b := (255);
		};
		cyan: color := {
			cyan.col := (65535);
		};
		blue: color := {
			blue.rgb.r := (0);
			blue.rgb.g := (0);
			blue.rgb.b := (255);
		};
		static const record_pack0: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack1: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack2: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack4: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_pack8: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		static const record_packDef: struct {
			_0: uint8;
			a: uint64;
			_1: uint8;
			b: uint32;
			_2: uint8;
			c: uint16;
		};
		a: typename := 96.300000;
		b: typename := 42.140000;
		shift: int32 := 2;
		boolA: bool := true;
		boolB: bool := !false;
		boolAnd: bool := boolA & boolB;
		boolIor: bool := boolA | boolB;
		boolXor: bool := boolA ^ boolB;
		boolNot: bool := !boolB;
		boolCeq: bool := boolA == boolB;
		boolCne: bool := boolA != boolB;
		boolClt: bool := boolA < boolB;
		boolCle: bool := boolA <= boolB;
		boolCgt: bool := boolA > boolB;
		boolCge: bool := boolA >= boolB;
		chrA: char := 'a';
		chrB: char := 'b';
		chrPls: char := +chrB;
		chrNeg: char := -chrB;
		chrCmt: char := ~chrB;
		chrAdd: char := chrA + chrB;
		chrSub: char := chrA - chrB;
		chrMul: char := chrA * chrB;
		chrDiv: char := chrA / chrB;
		chrMod: char := chrA % chrB;
		chrAnd: char := chrA & chrB;
		chrIor: char := chrA | chrB;
		chrXor: char := chrA ^ chrB;
		chrShl: char := (chrA) << shift;
		chrShr: char := (chrA) >> shift;
		chrNot: bool := !(chrB);
		chrCeq: bool := chrA == chrB;
		chrCne: bool := chrA != chrB;
		chrClt: bool := chrA < chrB;
		chrCle: bool := chrA <= chrB;
		chrCgt: bool := chrA > chrB;
		chrCge: bool := chrA >= chrB;
		i8A: int8 := a;
		i8B: int8 := b;
		i8Pls: int8 := +i8B;
		i8Neg: int8 := -i8B;
		i8Cmt: int8 := ~i8B;
		i8Add: int8 := i8A + i8B;
		i8Sub: int8 := i8A - i8B;
		i8Mul: int8 := i8A * i8B;
		i8Div: int8 := i8A / i8B;
		i8Mod: int8 := i8A % i8B;
		i8And: int8 := i8A & i8B;
		i8Ior: int8 := i8A | i8B;
		i8Xor: int8 := i8A ^ i8B;
		i8Shl: int8 := (i8A) << shift;
		i8Shr: int8 := (i8A) >> shift;
		i8Not: bool := !(i8B);
		i8Ceq: bool := i8A == i8B;
		i8Cne: bool := i8A != i8B;
		i8Clt: bool := i8A < i8B;
		i8Cle: bool := i8A <= i8B;
		i8Cgt: bool := i8A > i8B;
		i8Cge: bool := i8A >= i8B;
		u8A: uint8 := a;
		u8B: uint8 := b;
		u8Pls: uint8 := +u8B;
		u8Neg: uint8 := -u8B;
		u8Cmt: uint8 := ~u8B;
		u8Add: uint8 := u8A + u8B;
		u8Sub: uint8 := u8A - u8B;
		u8Mul: uint8 := u8A * u8B;
		u8Div: uint8 := u8A / u8B;
		u8Mod: uint8 := u8A % u8B;
		u8And: uint8 := u8A & u8B;
		u8Ior: uint8 := u8A | u8B;
		u8Xor: uint8 := u8A ^ u8B;
		u8Shl: uint8 := (u8A) << shift;
		u8Shr: uint8 := (u8A) >> shift;
		u8Not: bool := !(u8B);
		u8Ceq: bool := u8A == u8B;
		u8Cne: bool := u8A != u8B;
		u8Clt: bool := u8A < u8B;
		u8Cle: bool := u8A <= u8B;
		u8Cgt: bool := u8A > u8B;
		u8Cge: bool := u8A >= u8B;
		i16A: int16 := a;
		i16B: int16 := b;
		i16Pls: int16 := +i16B;
		i16Neg: int16 := -i16B;
		i16Cmt: int16 := ~i16B;
		i16Add: int16 := i16A + i16B;
		i16Sub: int16 := i16A - i16B;
		i16Mul: int16 := i16A * i16B;
		i16Div: int16 := i16A / i16B;
		i16Mod: int16 := i16A % i16B;
		i16And: int16 := i16A & i16B;
		i16Ior: int16 := i16A | i16B;
		i16Xor: int16 := i16A ^ i16B;
		i16Shl: int16 := (i16A) << shift;
		i16Shr: int16 := (i16A) >> shift;
		i16Not: bool := !(i16B);
		i16Ceq: bool := i16A == i16B;
		i16Cne: bool := i16A != i16B;
		i16Clt: bool := i16A < i16B;
		i16Cle: bool := i16A <= i16B;
		i16Cgt: bool := i16A > i16B;
		i16Cge: bool := i16A >= i16B;
		u16A: uint16 := a;
		u16B: uint16 := b;
		u16Pls: uint16 := +u16B;
		u16Neg: uint16 := -u16B;
		u16Cmt: uint16 := ~u16B;
		u16Add: uint16 := u16A + u16B;
		u16Sub: uint16 := u16A - u16B;
		u16Mul: uint16 := u16A * u16B;
		u16Div: uint16 := u16A / u16B;
		u16Mod: uint16 := u16A % u16B;
		u16And: uint16 := u16A & u16B;
		u16Ior: uint16 := u16A | u16B;
		u16Xor: uint16 := u16A ^ u16B;
		u16Shl: uint16 := (u16A) << shift;
		u16Shr: uint16 := (u16A) >> shift;
		u16Not: bool := !(u16B);
		u16Ceq: bool := u16A == u16B;
		u16Cne: bool := u16A != u16B;
		u16Clt: bool := u16A < u16B;
		u16Cle: bool := u16A <= u16B;
		u16Cgt: bool := u16A > u16B;
		u16Cge: bool := u16A >= u16B;
		i32A: int32 := a;
		i32B: int32 := b;
		i32Pls: int32 := +i32B;
		i32Neg: int32 := -i32B;
		i32Cmt: int32 := ~i32B;
		i32Add: int32 := i32A + i32B;
		i32Sub: int32 := i32A - i32B;
		i32Mul: int32 := i32A * i32B;
		i32Div: int32 := i32A / i32B;
		i32Mod: int32 := i32A % i32B;
		i32And: int32 := i32A & i32B;
		i32Ior: int32 := i32A | i32B;
		i32Xor: int32 := i32A ^ i32B;
		i32Shl: int32 := i32A << shift;
		i32Shr: int32 := i32A >> shift;
		i32Not: bool := !(i32B);
		i32Ceq: bool := i32A == i32B;
		i32Cne: bool := i32A != i32B;
		i32Clt: bool := i32A < i32B;
		i32Cle: bool := i32A <= i32B;
		i32Cgt: bool := i32A > i32B;
		i32Cge: bool := i32A >= i32B;
		u32A: uint32 := a;
		u32B: uint32 := b;
		u32Pls: uint32 := +u32B;
		u32Neg: uint32 := -u32B;
		u32Cmt: uint32 := ~u32B;
		u32Add: uint32 := u32A + u32B;
		u32Sub: uint32 := u32A - u32B;
		u32Mul: uint32 := u32A * u32B;
		u32Div: uint32 := u32A / u32B;
		u32Mod: uint32 := u32A % u32B;
		u32And: uint32 := u32A & u32B;
		u32Ior: uint32 := u32A | u32B;
		u32Xor: uint32 := u32A ^ u32B;
		u32Shl: uint32 := u32A << shift;
		u32Shr: uint32 := u32A >> shift;
		u32Not: bool := !(u32B);
		u32Ceq: bool := u32A == u32B;
		u32Cne: bool := u32A != u32B;
		u32Clt: bool := u32A < u32B;
		u32Cle: bool := u32A <= u32B;
		u32Cgt: bool := u32A > u32B;
		u32Cge: bool := u32A >= u32B;
		i64A: int64 := a;
		i64B: int64 := b;
		i64Pls: int64 := +i64B;
		i64Neg: int64 := -i64B;
		i64Cmt: int64 := ~i64B;
		i64Add: int64 := i64A + i64B;
		i64Sub: int64 := i64A - i64B;
		i64Mul: int64 := i64A * i64B;
		i64Div: int64 := i64A / i64B;
		i64Mod: int64 := i64A % i64B;
		i64And: int64 := i64A & i64B;
		i64Ior: int64 := i64A | i64B;
		i64Xor: int64 := i64A ^ i64B;
		i64Shl: int64 := i64A << shift;
		i64Shr: int64 := i64A >> shift;
		i64Not: bool := !(i64B);
		i64Ceq: bool := i64A == i64B;
		i64Cne: bool := i64A != i64B;
		i64Clt: bool := i64A < i64B;
		i64Cle: bool := i64A <= i64B;
		i64Cgt: bool := i64A > i64B;
		i64Cge: bool := i64A >= i64B;
		u64A: uint64 := a;
		u64B: uint64 := b;
		u64Pls: uint64 := +u64B;
		u64Neg: uint64 := -u64B;
		u64Cmt: uint64 := ~u64B;
		u64Add: uint64 := u64A + u64B;
		u64Sub: uint64 := u64A - u64B;
		u64Mul: uint64 := u64A * u64B;
		u64Div: uint64 := u64A / u64B;
		u64Mod: uint64 := u64A % u64B;
		u64And: uint64 := u64A & u64B;
		u64Ior: uint64 := u64A | u64B;
		u64Xor: uint64 := u64A ^ u64B;
		u64Shl: uint64 := u64A << shift;
		u64Shr: uint64 := u64A >> shift;
		u64Not: bool := !(u64B);
		u64Ceq: bool := u64A == u64B;
		u64Cne: bool := u64A != u64B;
		u64Clt: bool := u64A < u64B;
		u64Cle: bool := u64A <= u64B;
		u64Cgt: bool := u64A > u64B;
		u64Cge: bool := u64A >= u64B;
		f32A: float32 := a;
		f32B: float32 := b;
		f32Pls: float32 := +f32B;
		f32Neg: float32 := -f32B;
		f32Add: float32 := f32A + f32B;
		f32Sub: float32 := f32A - f32B;
		f32Mul: float32 := f32A * f32B;
		f32Div: float32 := f32A / f32B;
		f32Mod: float32 := f32A % f32B;
		f32Not: bool := !(f32B);
		f32Ceq: bool := f32A == f32B;
		f32Cne: bool := f32A != f32B;
		f32Clt: bool := f32A < f32B;
		f32Cle: bool := f32A <= f32B;
		f32Cgt: bool := f32A > f32B;
		f32Cge: bool := f32A >= f32B;
		f64A: float64 := a;
		f64B: float64 := b;
		f64Pls: float64 := +f64B;
		f64Neg: float64 := -f64B;
		f64Add: float64 := f64A + f64B;
		f64Sub: float64 := f64A - f64B;
		f64Mul: float64 := f64A * f64B;
		f64Div: float64 := f64A / f64B;
		f64Mod: float64 := f64A % f64B;
		f64Not: bool := !(f64B);
		f64Ceq: bool := f64A == f64B;
		f64Cne: bool := f64A != f64B;
		f64Clt: bool := f64A < f64B;
		f64Cle: bool := f64A <= f64B;
		f64Cgt: bool := f64A > f64B;
		f64Cge: bool := f64A >= f64B;
		ptrA: pointer := null;
		ptrB: pointer := pointer(shift);
		ptrCeq: bool := ptrA == ptrB;
		ptrCne: bool := ptrA != ptrB;
		static if (0 == 0) {
			raise(raise.debug, 1, "0 == 0");
		}
		static if (0 != 0) {
			raise(raise.debug, 2, "0 != 0");
		}
		static if (0 == 0) {
			raise(raise.debug, 3, "0 == 0");
		}
		else {
			raise(raise.debug, 4, "0 != 0");
		}
		static if (0 != 0) {
			raise(raise.debug, 5, "0 != 0");
		}
		else {
			raise(raise.debug, 6, "0 == 0");
		}
		{
			t: int32 := 0;
			if (t == 0) {
				raise(raise.debug, 7, "t == 0", t);
			}
			if (t != 0) {
				raise(raise.debug, 8, "t != 0", t);
			}
			if (t == 0) {
				raise(raise.debug, 9, "t == 0", t);
			}
			else {
				raise(raise.debug, 10, "t != 0", t);
			}
			if (t != 0) {
				raise(raise.debug, 11, "t != 0", t);
			}
			else {
				raise(raise.debug, 12, "t == 0", t);
			}
			if (t == 0) {
				raise(raise.debug, 9, "t == 0", t);
			}
			else if (t == 1) {
				raise(raise.debug, 10, "t == 1", t);
			}
			else if (t == 2) {
				raise(raise.debug, 10, "t == 2", t);
			}
			else if (t == 3) {
				raise(raise.debug, 10, "t == 3", t);
			}
			else if (t == 4) {
				raise(raise.debug, 10, "t == 4", t);
			}
			else if (t == 5) {
				raise(raise.debug, 10, "t == 5", t);
			}
			else {
				raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
			}
		}
		static if ((typename(int64)) == null) {
			error("integer is not declared");
		}
		static if (typename(int64) != typename) {
			error("integer is not a type");
		}
		for ( ; ; ) {
			debug("for ( ; ; )");
			break;
		}
		for (i: int32 := 0; i < 2; i := i + 1) {
			debug("for (int i = 0; i < 2; i += 1)", i);
		}
		forIdx: int32;
		for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1) {
			debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
		}
		for (i: int32 := 0; i < 7; i := i + 1) {
			if (i < 2) {
				continue;
			}
			debug("for with continue", i);
		}
		for (i: int32 := 0; i < 7; i := i + 1) {
			if (i > 2) {
				break;
			}
			debug("for with break", i);
		}
		pi64: float64 := 3.141593;
		e64: float64 := 2.718282;
		pi32: float32 := pi64;
		e32: float32 := e64;
		rgb888(r: int32, g: int32, b: int32): int32 := r << 16 & 16711680 | g << 8 & 65280 | b & 255;
		rgb565(r: int32, g: int32, b: int32): int32 := r << 8 & 63488 | g << 3 & 2016 | b >> 3 & 31;
		r_comp: int32 := 14 << 3;
		g_comp: int32 := 63 << 2;
		b_comp: int32 := 31 << 3;
		r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp);
		r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp);
		zxtR5: int32 := Bits.zxt32(r5g6b5, 11, 5);
		zxtG6: int32 := Bits.zxt32(r5g6b5, 5, 6);
		zxtB5: int32 := Bits.zxt32(r5g6b5, 0, 5);
		sxtR5: int32 := Bits.sxt32(r5g6b5, 11, 5);
		sxtG6: int32 := Bits.sxt32(r5g6b5, 5, 6);
		sxtB5: int32 := Bits.sxt32(r5g6b5, 0, 5);
		zxtR8: int32 := Bits.zxt32(r8g8b8, 16, 8);
		zxtG8: int32 := Bits.zxt32(r8g8b8, 8, 8);
		zxtB8: int32 := Bits.zxt32(r8g8b8, 0, 8);
		sxtR8: int32 := Bits.sxt32(r8g8b8, 16, 8);
		sxtG8: int32 := Bits.sxt32(r8g8b8, 8, 8);
		sxtB8: int32 := Bits.sxt32(r8g8b8, 0, 8);
		testSin_f64: float64 := Math.sin(pi64 / (2));
		testCos_f64: float64 := Math.cos(pi64 / (2));
		testTan_f64: float64 := Math.tan(pi64 / (4));
		testLog_f64: float64 := Math.log(e64 * e64 * e64);
		testExp_f64: float64 := Math.exp(1.000000);
		testPow_f64: float64 := Math.pow(pi64 * pi64, 0.500000);
		testSqrt_f64: float64 := Math.sqrt(pi64 * pi64);
		testAtan_f64: float64 := Math.atan2(pi64, 1.000000);
		testSin_f32: float32 := Math.sin(pi32 / (2));
		testCos_f32: float32 := Math.cos(pi32 / (2));
		testTan_f32: float32 := Math.tan(pi32 / (4));
		testLog_f32: float32 := Math.log(e32 * e32 * e32);
		testExp_f32: float32 := Math.exp(1.000000);
		testPow_f32: float32 := Math.pow(pi32 * pi32, 0.500000);
		testSqrt_f32: float32 := Math.sqrt(pi32 * pi32);
		testAtan_f32: float32 := Math.atan2(pi32, 1.000000);
		testPopulation_u32: int32 := Bits.countOnes(r5g6b5);
		testSwapBits_u32: uint32 := Bits.swapBits(r5g6b5);
		testBitScanReverse_u32: int32 := Bits.scanReverse(r5g6b5);
		testBitScanForward_u32: int32 := Bits.scanForward(r5g6b5);
		testHighBit_u32: int32 := Bits.keepMsb(r5g6b5);
		testLowBit_u32: int32 := Bits.keepLsb(r5g6b5);
		testZeroExtend_u32: int32 := Bits.zxt32(r5g6b5, 0, 5);
		testSignExtend_u32: int32 := Bits.sxt32(r5g6b5, 0, 5);
		testZeroExtend_u64: int32 := Bits.zxt64(r5g6b5, 0, 5);
		testSignExtend_u64: int32 := Bits.sxt64(r5g6b5, 0, 5);
		testMathFloor_pos_3_0: float64 := Math.floor(3.000000);
		testMathFloor_pos_3_2: float64 := Math.floor(3.200000);
		testMathFloor_pos_3_5: float64 := Math.floor(3.500000);
		testMathFloor_pos_3_7: float64 := Math.floor(3.700000);
		testMathFloor_pos_3_9: float64 := Math.floor(3.900000);
		testMathFloor_neg_3_0: float64 := Math.floor(-3.000000);
		testMathFloor_neg_3_2: float64 := Math.floor(-3.200000);
		testMathFloor_neg_3_5: float64 := Math.floor(-3.500000);
		testMathFloor_neg_3_7: float64 := Math.floor(-3.700000);
		testMathFloor_neg_3_9: float64 := Math.floor(-3.900000);
		testMathRound_pos_3_0: float64 := Math.round(3.000000);
		testMathRound_pos_3_2: float64 := Math.round(3.200000);
		testMathRound_pos_3_5: float64 := Math.round(3.500000);
		testMathRound_pos_3_7: float64 := Math.round(3.700000);
		testMathRound_pos_3_9: float64 := Math.round(3.900000);
		testMathRound_neg_3_0: float64 := Math.round(-3.000000);
		testMathRound_neg_3_2: float64 := Math.round(-3.200000);
		testMathRound_neg_3_5: float64 := Math.round(-3.500000);
		testMathRound_neg_3_7: float64 := Math.round(-3.700000);
		testMathRound_neg_3_9: float64 := Math.round(-3.900000);
		testMathCeil_pos_3_0: float64 := Math.ceil(3.000000);
		testMathCeil_pos_3_2: float64 := Math.ceil(3.200000);
		testMathCeil_pos_3_5: float64 := Math.ceil(3.500000);
		testMathCeil_pos_3_7: float64 := Math.ceil(3.700000);
		testMathCeil_pos_3_9: float64 := Math.ceil(3.900000);
		testMathCeil_neg_3_0: float64 := Math.ceil(-3.000000);
		testMathCeil_neg_3_2: float64 := Math.ceil(-3.200000);
		testMathCeil_neg_3_5: float64 := Math.ceil(-3.500000);
		testMathCeil_neg_3_7: float64 := Math.ceil(-3.700000);
		testMathCeil_neg_3_9: float64 := Math.ceil(-3.900000);
		testMathSign_1F: float64 := Math.sign(0.200000);
		testMathSign_2F: float64 := Math.sign(0.000000);
		testMathSign_3F: float64 := Math.sign(-0.900000);
		testMathSign_1f: float64 := Math.sign(0.200000);
		testMathSign_2f: float64 := Math.sign(0.000000);
		testMathSign_3f: float64 := Math.sign(-0.900000);
		testMathAbs_1F: float64 := Math.abs(0.200000);
		testMathAbs_2F: float64 := Math.abs(0.000000);
		testMathAbs_3F: float64 := Math.abs(-0.900000);
		testMathAbs_1f: float64 := Math.abs(0.200000);
		testMathAbs_2f: float64 := Math.abs(0.000000);
		testMathAbs_3f: float64 := Math.abs(-0.900000);
		testMathMin_1f: float64 := Math.min(1.000000, 2.000000);
		testMathMax_2f: float64 := Math.max(1.000000, 2.000000);
		testMathMin_1F: float64 := Math.min(1.000000, 2.000000);
		testMathMax_2F: float64 := Math.max(1.000000, 2.000000);
		testMathClamp_1f: float64 := Math.clamp(10.000000, 0.000000, 1.000000);
		testMathClamp_1F: float64 := Math.clamp(10.000000, 0.000000, 1.000000);
		testMathMix_1f: float64 := Math.mix(0.000000, 2.000000, 0.500000);
		testMathMix_1F: float64 := Math.mix(0.000000, 2.000000, 0.500000);
		testMathSmooth_1f: float64 := Math.smoothstep(0.000000, 1.000000, 1.000000);
		testMathSmooth_1F: float64 := Math.smoothstep(0.000000, 1.000000, 1.000000);
		testMathMin_nan: float64 := Math.min();
		testMathMin_1: float64 := Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6);
		testMathMax_nan: float64 := Math.max();
		testMathMax_9: float64 := Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6);
		testMathSum_0: float64 := Math.sum();
		testMathSum_1: float64 := Math.sum(1);
		testMathSum_3: float64 := Math.sum(1, 2);
		testMathSum_55: float64 := Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		testMathEval_x: float64 := 10;
		testMathEval_0: float64 := Math.eval(testMathEval_x);
		testMathEval_1: float64 := Math.eval(testMathEval_x, 1.000000);
		testMathEval_2: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000);
		testMathEval_3: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000);
		testMathEval_4: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000);
		testMathEval_5: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000);
		testMathEval_6: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000);
		testMathSin_f64: float64 := Math.sin(Math.pi / (2));
		testMathCos_f64: float64 := Math.cos(Math.pi / (2));
		testMathTan_f64: float64 := Math.tan(Math.pi / (4));
		testMathSinh_f64: float64 := Math.sinh(Math.pi / (2));
		testMathCosh_f64: float64 := Math.cosh(Math.pi / (2));
		testMathAsin_f64: float64 := Math.asin(0.200000);
		testMathAcos_f64: float64 := Math.acos(0.200000);
		testMathAbsMod_f64_0a: float64 := Math.absMod(10.000000, 10.000000);
		testMathAbsMod_f64_0b: float64 := Math.absMod(0.000000, 10.000000);
		testMathAbsMod_f64_0c: float64 := Math.absMod(-10.000000, 10.000000);
		testMathAbsMod_f64_9a: float64 := Math.absMod(19.000000, 10.000000);
		testMathAbsMod_f64_9b: float64 := Math.absMod(9.000000, 10.000000);
		testMathAbsMod_f64_9c: float64 := Math.absMod(-1.000000, 10.000000);
		testMathAbsMod_f64_9d: float64 := Math.absMod(-11.000000, 10.000000);
		testMathAbsMod_f64_8a: float64 := Math.absMod(18.000000, 10.000000);
		testMathAbsMod_f64_8b: float64 := Math.absMod(8.000000, 10.000000);
		testMathAbsMod_f64_8c: float64 := Math.absMod(-2.000000, 10.000000);
		testMathAbsMod_f64_8d: float64 := Math.absMod(-12.000000, 10.000000);
		testMathAbsMod_f32_0a: float32 := Math.absMod(10.000000, 10.000000);
		testMathAbsMod_f32_0b: float32 := Math.absMod(0.000000, 10.000000);
		testMathAbsMod_f32_0c: float32 := Math.absMod(-10.000000, 10.000000);
		testMathAbsMod_f32_9a: float32 := Math.absMod(19.000000, 10.000000);
		testMathAbsMod_f32_9b: float32 := Math.absMod(9.000000, 10.000000);
		testMathAbsMod_f32_9c: float32 := Math.absMod(-1.000000, 10.000000);
		testMathAbsMod_f32_9d: float32 := Math.absMod(-11.000000, 10.000000);
		testMathAbsMod_f32_8a: float32 := Math.absMod(18.000000, 10.000000);
		testMathAbsMod_f32_8b: float32 := Math.absMod(8.000000, 10.000000);
		testMathAbsMod_f32_8c: float32 := Math.absMod(-2.000000, 10.000000);
		testMathAbsMod_f32_8d: float32 := Math.absMod(-12.000000, 10.000000);
		Neg(a: Complex): Complex := Complex(-a.re, -a.im);
		Add(a: Complex, b: Complex): Complex := Complex(a.re + b.re, a.im + b.im);
		Sub(a: Complex, b: Complex): Complex := Complex(a.re - b.re, a.im - b.im);
		Mul(a: Complex, b: Complex): Complex := Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
		valA: Complex := {
			valA.re := (9);
			valA.im := (2);
		};
		valB: Complex := {
			valB.re := (2);
			valB.im := (3);
		};
		Neg: Complex := Neg(valA);
		neg: Complex := neg(valA);
		Add: Complex := Add(valA, valB);
		add: Complex := add(valA, valB);
		Sub: Complex := Sub(valA, valB);
		sub: Complex := sub(valA, valB);
		Mul: Complex := Mul(valA, valB);
		mul: Complex := mul(valA, valB);
	}
}
.instructions: (19799 bytes)
	cmplStd/lib/math/Fixed.ci:135: (2309 bytes): static const tbl_log2: uint32[257] := {...}
	cmplStd/lib/math/Fixed.ci:137: (5 bytes): tbl_log2[0] := (0);
	<.main>  : load.z32
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[1] := (6039313);
	<.main+?>: load.c32 6039313
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+4
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[2] := (12055173);
	<.main+?>: load.c32 12055173
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+8
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[3] := (18047761);
	<.main+?>: load.c32 18047761
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+12
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[4] := (24017256);
	<.main+?>: load.c32 24017256
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+16
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[5] := (29963835);
	<.main+?>: load.c32 29963835
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+20
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[6] := (35887674);
	<.main+?>: load.c32 35887674
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+24
	cmplStd/lib/math/Fixed.ci:137: (9 bytes): tbl_log2[7] := (41788946);
	<.main+?>: load.c32 41788946
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+28
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[8] := (47667822);
	<.main+?>: load.c32 47667822
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+32
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[9] := (53524472);
	<.main+?>: load.c32 53524472
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+36
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[10] := (59359063);
	<.main+?>: load.c32 59359063
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+40
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[11] := (65171760);
	<.main+?>: load.c32 65171760
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+44
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[12] := (70962727);
	<.main+?>: load.c32 70962727
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+48
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[13] := (76732127);
	<.main+?>: load.c32 76732127
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+52
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[14] := (82480119);
	<.main+?>: load.c32 82480119
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+56
	cmplStd/lib/math/Fixed.ci:138: (9 bytes): tbl_log2[15] := (88206861);
	<.main+?>: load.c32 88206861
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+60
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[16] := (93912510);
	<.main+?>: load.c32 93912510
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+64
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[17] := (99597221);
	<.main+?>: load.c32 99597221
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+68
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[18] := (105261147);
	<.main+?>: load.c32 105261147
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+72
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[19] := (110904439);
	<.main+?>: load.c32 110904439
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+76
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[20] := (116527248);
	<.main+?>: load.c32 116527248
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+80
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[21] := (122129720);
	<.main+?>: load.c32 122129720
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+84
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[22] := (127712004);
	<.main+?>: load.c32 127712004
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+88
	cmplStd/lib/math/Fixed.ci:139: (9 bytes): tbl_log2[23] := (133274243);
	<.main+?>: load.c32 133274243
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+92
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[24] := (138816582);
	<.main+?>: load.c32 138816582
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+96
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[25] := (144339162);
	<.main+?>: load.c32 144339162
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+100
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[26] := (149842123);
	<.main+?>: load.c32 149842123
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+104
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[27] := (155325605);
	<.main+?>: load.c32 155325605
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+108
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[28] := (160789745);
	<.main+?>: load.c32 160789745
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+112
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[29] := (166234678);
	<.main+?>: load.c32 166234678
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+116
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[30] := (171660540);
	<.main+?>: load.c32 171660540
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+120
	cmplStd/lib/math/Fixed.ci:140: (9 bytes): tbl_log2[31] := (177067464);
	<.main+?>: load.c32 177067464
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+124
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[32] := (182455580);
	<.main+?>: load.c32 182455580
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+128
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[33] := (187825021);
	<.main+?>: load.c32 187825021
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+132
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[34] := (193175914);
	<.main+?>: load.c32 193175914
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+136
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[35] := (198508387);
	<.main+?>: load.c32 198508387
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+140
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[36] := (203822568);
	<.main+?>: load.c32 203822568
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+144
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[37] := (209118580);
	<.main+?>: load.c32 209118580
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+148
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[38] := (214396547);
	<.main+?>: load.c32 214396547
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+152
	cmplStd/lib/math/Fixed.ci:141: (9 bytes): tbl_log2[39] := (219656593);
	<.main+?>: load.c32 219656593
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+156
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[40] := (224898838);
	<.main+?>: load.c32 224898838
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+160
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[41] := (230123403);
	<.main+?>: load.c32 230123403
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+164
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[42] := (235330406);
	<.main+?>: load.c32 235330406
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+168
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[43] := (240519966);
	<.main+?>: load.c32 240519966
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+172
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[44] := (245692198);
	<.main+?>: load.c32 245692198
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+176
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[45] := (250847217);
	<.main+?>: load.c32 250847217
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+180
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[46] := (255985139);
	<.main+?>: load.c32 255985139
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+184
	cmplStd/lib/math/Fixed.ci:142: (9 bytes): tbl_log2[47] := (261106076);
	<.main+?>: load.c32 261106076
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+188
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[48] := (266210140);
	<.main+?>: load.c32 266210140
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+192
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[49] := (271297442);
	<.main+?>: load.c32 271297442
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+196
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[50] := (276368091);
	<.main+?>: load.c32 276368091
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+200
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[51] := (281422197);
	<.main+?>: load.c32 281422197
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+204
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[52] := (286459866);
	<.main+?>: load.c32 286459866
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+208
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[53] := (291481206);
	<.main+?>: load.c32 291481206
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+212
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[54] := (296486322);
	<.main+?>: load.c32 296486322
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+216
	cmplStd/lib/math/Fixed.ci:143: (9 bytes): tbl_log2[55] := (301475318);
	<.main+?>: load.c32 301475318
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+220
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[56] := (306448299);
	<.main+?>: load.c32 306448299
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+224
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[57] := (311405365);
	<.main+?>: load.c32 311405365
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+228
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[58] := (316346620);
	<.main+?>: load.c32 316346620
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+232
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[59] := (321272163);
	<.main+?>: load.c32 321272163
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+236
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[60] := (326182094);
	<.main+?>: load.c32 326182094
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+240
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[61] := (331076512);
	<.main+?>: load.c32 331076512
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+244
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[62] := (335955515);
	<.main+?>: load.c32 335955515
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+248
	cmplStd/lib/math/Fixed.ci:144: (9 bytes): tbl_log2[63] := (340819198);
	<.main+?>: load.c32 340819198
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+252
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[64] := (345667659);
	<.main+?>: load.c32 345667659
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+256
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[65] := (350500992);
	<.main+?>: load.c32 350500992
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+260
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[66] := (355319292);
	<.main+?>: load.c32 355319292
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+264
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[67] := (360122651);
	<.main+?>: load.c32 360122651
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+268
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[68] := (364911161);
	<.main+?>: load.c32 364911161
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+272
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[69] := (369684916);
	<.main+?>: load.c32 369684916
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+276
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[70] := (374444004);
	<.main+?>: load.c32 374444004
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+280
	cmplStd/lib/math/Fixed.ci:145: (9 bytes): tbl_log2[71] := (379188516);
	<.main+?>: load.c32 379188516
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+284
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[72] := (383918541);
	<.main+?>: load.c32 383918541
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+288
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[73] := (388634167);
	<.main+?>: load.c32 388634167
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+292
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[74] := (393335482);
	<.main+?>: load.c32 393335482
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+296
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[75] := (398022572);
	<.main+?>: load.c32 398022572
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+300
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[76] := (402695523);
	<.main+?>: load.c32 402695523
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+304
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[77] := (407354419);
	<.main+?>: load.c32 407354419
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+308
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[78] := (411999346);
	<.main+?>: load.c32 411999346
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+312
	cmplStd/lib/math/Fixed.ci:146: (9 bytes): tbl_log2[79] := (416630387);
	<.main+?>: load.c32 416630387
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+316
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[80] := (421247625);
	<.main+?>: load.c32 421247625
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+320
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[81] := (425851141);
	<.main+?>: load.c32 425851141
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+324
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[82] := (430441017);
	<.main+?>: load.c32 430441017
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+328
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[83] := (435017333);
	<.main+?>: load.c32 435017333
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+332
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[84] := (439580170);
	<.main+?>: load.c32 439580170
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+336
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[85] := (444129606);
	<.main+?>: load.c32 444129606
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+340
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[86] := (448665721);
	<.main+?>: load.c32 448665721
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+344
	cmplStd/lib/math/Fixed.ci:147: (9 bytes): tbl_log2[87] := (453188591);
	<.main+?>: load.c32 453188591
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+348
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[88] := (457698295);
	<.main+?>: load.c32 457698295
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+352
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[89] := (462194907);
	<.main+?>: load.c32 462194907
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+356
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[90] := (466678505);
	<.main+?>: load.c32 466678505
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+360
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[91] := (471149164);
	<.main+?>: load.c32 471149164
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+364
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[92] := (475606957);
	<.main+?>: load.c32 475606957
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+368
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[93] := (480051958);
	<.main+?>: load.c32 480051958
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+372
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[94] := (484484242);
	<.main+?>: load.c32 484484242
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+376
	cmplStd/lib/math/Fixed.ci:148: (9 bytes): tbl_log2[95] := (488903880);
	<.main+?>: load.c32 488903880
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+380
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[96] := (493310944);
	<.main+?>: load.c32 493310944
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+384
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[97] := (497705506);
	<.main+?>: load.c32 497705506
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+388
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[98] := (502087636);
	<.main+?>: load.c32 502087636
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+392
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[99] := (506457405);
	<.main+?>: load.c32 506457405
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+396
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[100] := (510814881);
	<.main+?>: load.c32 510814881
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+400
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[101] := (515160135);
	<.main+?>: load.c32 515160135
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+404
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[102] := (519493235);
	<.main+?>: load.c32 519493235
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+408
	cmplStd/lib/math/Fixed.ci:149: (9 bytes): tbl_log2[103] := (523814247);
	<.main+?>: load.c32 523814247
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+412
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[104] := (528123240);
	<.main+?>: load.c32 528123240
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+416
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[105] := (532420281);
	<.main+?>: load.c32 532420281
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+420
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[106] := (536705434);
	<.main+?>: load.c32 536705434
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+424
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[107] := (540978766);
	<.main+?>: load.c32 540978766
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+428
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[108] := (545240343);
	<.main+?>: load.c32 545240343
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+432
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[109] := (549490227);
	<.main+?>: load.c32 549490227
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+436
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[110] := (553728484);
	<.main+?>: load.c32 553728484
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+440
	cmplStd/lib/math/Fixed.ci:150: (9 bytes): tbl_log2[111] := (557955177);
	<.main+?>: load.c32 557955177
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+444
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[112] := (562170369);
	<.main+?>: load.c32 562170369
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+448
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[113] := (566374122);
	<.main+?>: load.c32 566374122
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+452
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[114] := (570566498);
	<.main+?>: load.c32 570566498
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+456
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[115] := (574747559);
	<.main+?>: load.c32 574747559
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+460
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[116] := (578917365);
	<.main+?>: load.c32 578917365
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+464
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[117] := (583075977);
	<.main+?>: load.c32 583075977
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+468
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[118] := (587223454);
	<.main+?>: load.c32 587223454
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+472
	cmplStd/lib/math/Fixed.ci:151: (9 bytes): tbl_log2[119] := (591359857);
	<.main+?>: load.c32 591359857
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+476
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[120] := (595485245);
	<.main+?>: load.c32 595485245
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+480
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[121] := (599599675);
	<.main+?>: load.c32 599599675
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+484
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[122] := (603703206);
	<.main+?>: load.c32 603703206
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+488
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[123] := (607795895);
	<.main+?>: load.c32 607795895
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+492
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[124] := (611877800);
	<.main+?>: load.c32 611877800
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+496
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[125] := (615948977);
	<.main+?>: load.c32 615948977
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+500
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[126] := (620009483);
	<.main+?>: load.c32 620009483
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+504
	cmplStd/lib/math/Fixed.ci:152: (9 bytes): tbl_log2[127] := (624059372);
	<.main+?>: load.c32 624059372
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+508
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[128] := (628098702);
	<.main+?>: load.c32 628098702
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+512
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[129] := (632127526);
	<.main+?>: load.c32 632127526
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+516
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[130] := (636145899);
	<.main+?>: load.c32 636145899
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+520
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[131] := (640153876);
	<.main+?>: load.c32 640153876
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+524
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[132] := (644151509);
	<.main+?>: load.c32 644151509
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+528
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[133] := (648138852);
	<.main+?>: load.c32 648138852
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+532
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[134] := (652115958);
	<.main+?>: load.c32 652115958
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+536
	cmplStd/lib/math/Fixed.ci:153: (9 bytes): tbl_log2[135] := (656082880);
	<.main+?>: load.c32 656082880
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+540
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[136] := (660039669);
	<.main+?>: load.c32 660039669
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+544
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[137] := (663986377);
	<.main+?>: load.c32 663986377
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+548
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[138] := (667923055);
	<.main+?>: load.c32 667923055
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+552
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[139] := (671849754);
	<.main+?>: load.c32 671849754
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+556
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[140] := (675766525);
	<.main+?>: load.c32 675766525
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+560
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[141] := (679673417);
	<.main+?>: load.c32 679673417
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+564
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[142] := (683570481);
	<.main+?>: load.c32 683570481
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+568
	cmplStd/lib/math/Fixed.ci:154: (9 bytes): tbl_log2[143] := (687457765);
	<.main+?>: load.c32 687457765
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+572
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[144] := (691335319);
	<.main+?>: load.c32 691335319
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+576
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[145] := (695203191);
	<.main+?>: load.c32 695203191
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+580
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[146] := (699061430);
	<.main+?>: load.c32 699061430
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+584
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[147] := (702910083);
	<.main+?>: load.c32 702910083
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+588
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[148] := (706749198);
	<.main+?>: load.c32 706749198
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+592
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[149] := (710578821);
	<.main+?>: load.c32 710578821
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+596
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[150] := (714399001);
	<.main+?>: load.c32 714399001
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+600
	cmplStd/lib/math/Fixed.ci:155: (9 bytes): tbl_log2[151] := (718209783);
	<.main+?>: load.c32 718209783
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+604
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[152] := (722011213);
	<.main+?>: load.c32 722011213
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+608
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[153] := (725803337);
	<.main+?>: load.c32 725803337
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+612
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[154] := (729586201);
	<.main+?>: load.c32 729586201
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+616
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[155] := (733359850);
	<.main+?>: load.c32 733359850
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+620
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[156] := (737124328);
	<.main+?>: load.c32 737124328
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+624
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[157] := (740879680);
	<.main+?>: load.c32 740879680
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+628
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[158] := (744625950);
	<.main+?>: load.c32 744625950
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+632
	cmplStd/lib/math/Fixed.ci:156: (9 bytes): tbl_log2[159] := (748363182);
	<.main+?>: load.c32 748363182
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+636
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[160] := (752091420);
	<.main+?>: load.c32 752091420
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+640
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[161] := (755810706);
	<.main+?>: load.c32 755810706
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+644
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[162] := (759521084);
	<.main+?>: load.c32 759521084
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+648
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[163] := (763222596);
	<.main+?>: load.c32 763222596
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+652
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[164] := (766915284);
	<.main+?>: load.c32 766915284
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+656
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[165] := (770599191);
	<.main+?>: load.c32 770599191
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+660
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[166] := (774274358);
	<.main+?>: load.c32 774274358
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+664
	cmplStd/lib/math/Fixed.ci:157: (9 bytes): tbl_log2[167] := (777940826);
	<.main+?>: load.c32 777940826
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+668
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[168] := (781598636);
	<.main+?>: load.c32 781598636
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+672
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[169] := (785247830);
	<.main+?>: load.c32 785247830
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+676
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[170] := (788888447);
	<.main+?>: load.c32 788888447
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+680
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[171] := (792520529);
	<.main+?>: load.c32 792520529
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+684
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[172] := (796144114);
	<.main+?>: load.c32 796144114
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+688
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[173] := (799759243);
	<.main+?>: load.c32 799759243
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+692
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[174] := (803365955);
	<.main+?>: load.c32 803365955
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+696
	cmplStd/lib/math/Fixed.ci:158: (9 bytes): tbl_log2[175] := (806964288);
	<.main+?>: load.c32 806964288
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+700
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[176] := (810554283);
	<.main+?>: load.c32 810554283
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+704
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[177] := (814135977);
	<.main+?>: load.c32 814135977
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+708
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[178] := (817709409);
	<.main+?>: load.c32 817709409
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+712
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[179] := (821274616);
	<.main+?>: load.c32 821274616
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+716
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[180] := (824831638);
	<.main+?>: load.c32 824831638
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+720
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[181] := (828380510);
	<.main+?>: load.c32 828380510
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+724
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[182] := (831921270);
	<.main+?>: load.c32 831921270
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+728
	cmplStd/lib/math/Fixed.ci:159: (9 bytes): tbl_log2[183] := (835453956);
	<.main+?>: load.c32 835453956
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+732
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[184] := (838978604);
	<.main+?>: load.c32 838978604
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+736
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[185] := (842495250);
	<.main+?>: load.c32 842495250
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+740
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[186] := (846003931);
	<.main+?>: load.c32 846003931
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+744
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[187] := (849504683);
	<.main+?>: load.c32 849504683
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+748
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[188] := (852997541);
	<.main+?>: load.c32 852997541
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+752
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[189] := (856482541);
	<.main+?>: load.c32 856482541
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+756
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[190] := (859959719);
	<.main+?>: load.c32 859959719
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+760
	cmplStd/lib/math/Fixed.ci:160: (9 bytes): tbl_log2[191] := (863429109);
	<.main+?>: load.c32 863429109
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+764
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[192] := (866890746);
	<.main+?>: load.c32 866890746
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+768
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[193] := (870344665);
	<.main+?>: load.c32 870344665
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+772
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[194] := (873790900);
	<.main+?>: load.c32 873790900
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+776
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[195] := (877229485);
	<.main+?>: load.c32 877229485
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+780
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[196] := (880660455);
	<.main+?>: load.c32 880660455
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+784
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[197] := (884083842);
	<.main+?>: load.c32 884083842
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+788
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[198] := (887499680);
	<.main+?>: load.c32 887499680
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+792
	cmplStd/lib/math/Fixed.ci:161: (9 bytes): tbl_log2[199] := (890908002);
	<.main+?>: load.c32 890908002
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+796
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[200] := (894308843);
	<.main+?>: load.c32 894308843
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+800
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[201] := (897702233);
	<.main+?>: load.c32 897702233
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+804
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[202] := (901088206);
	<.main+?>: load.c32 901088206
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+808
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[203] := (904466794);
	<.main+?>: load.c32 904466794
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+812
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[204] := (907838029);
	<.main+?>: load.c32 907838029
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+816
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[205] := (911201943);
	<.main+?>: load.c32 911201943
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+820
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[206] := (914558569);
	<.main+?>: load.c32 914558569
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+824
	cmplStd/lib/math/Fixed.ci:162: (9 bytes): tbl_log2[207] := (917907937);
	<.main+?>: load.c32 917907937
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+828
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[208] := (921250078);
	<.main+?>: load.c32 921250078
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+832
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[209] := (924585025);
	<.main+?>: load.c32 924585025
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+836
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[210] := (927912807);
	<.main+?>: load.c32 927912807
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+840
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[211] := (931233455);
	<.main+?>: load.c32 931233455
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+844
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[212] := (934547001);
	<.main+?>: load.c32 934547001
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+848
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[213] := (937853474);
	<.main+?>: load.c32 937853474
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+852
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[214] := (941152904);
	<.main+?>: load.c32 941152904
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+856
	cmplStd/lib/math/Fixed.ci:163: (9 bytes): tbl_log2[215] := (944445322);
	<.main+?>: load.c32 944445322
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+860
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[216] := (947730757);
	<.main+?>: load.c32 947730757
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+864
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[217] := (951009239);
	<.main+?>: load.c32 951009239
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+868
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[218] := (954280797);
	<.main+?>: load.c32 954280797
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+872
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[219] := (957545460);
	<.main+?>: load.c32 957545460
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+876
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[220] := (960803257);
	<.main+?>: load.c32 960803257
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+880
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[221] := (964054217);
	<.main+?>: load.c32 964054217
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+884
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[222] := (967298369);
	<.main+?>: load.c32 967298369
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+888
	cmplStd/lib/math/Fixed.ci:164: (9 bytes): tbl_log2[223] := (970535741);
	<.main+?>: load.c32 970535741
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+892
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[224] := (973766362);
	<.main+?>: load.c32 973766362
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+896
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[225] := (976990259);
	<.main+?>: load.c32 976990259
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+900
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[226] := (980207460);
	<.main+?>: load.c32 980207460
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+904
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[227] := (983417994);
	<.main+?>: load.c32 983417994
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+908
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[228] := (986621888);
	<.main+?>: load.c32 986621888
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+912
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[229] := (989819169);
	<.main+?>: load.c32 989819169
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+916
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[230] := (993009864);
	<.main+?>: load.c32 993009864
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+920
	cmplStd/lib/math/Fixed.ci:165: (9 bytes): tbl_log2[231] := (996194001);
	<.main+?>: load.c32 996194001
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+924
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[232] := (999371606);
	<.main+?>: load.c32 999371606
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+928
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[233] := (1002542706);
	<.main+?>: load.c32 1002542706
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+932
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[234] := (1005707329);
	<.main+?>: load.c32 1005707329
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+936
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[235] := (1008865499);
	<.main+?>: load.c32 1008865499
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+940
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[236] := (1012017244);
	<.main+?>: load.c32 1012017244
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+944
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[237] := (1015162589);
	<.main+?>: load.c32 1015162589
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+948
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[238] := (1018301561);
	<.main+?>: load.c32 1018301561
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+952
	cmplStd/lib/math/Fixed.ci:166: (9 bytes): tbl_log2[239] := (1021434184);
	<.main+?>: load.c32 1021434184
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+956
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[240] := (1024560486);
	<.main+?>: load.c32 1024560486
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+960
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[241] := (1027680491);
	<.main+?>: load.c32 1027680491
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+964
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[242] := (1030794225);
	<.main+?>: load.c32 1030794225
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+968
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[243] := (1033901713);
	<.main+?>: load.c32 1033901713
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+972
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[244] := (1037002979);
	<.main+?>: load.c32 1037002979
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+976
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[245] := (1040098049);
	<.main+?>: load.c32 1040098049
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+980
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[246] := (1043186947);
	<.main+?>: load.c32 1043186947
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+984
	cmplStd/lib/math/Fixed.ci:167: (9 bytes): tbl_log2[247] := (1046269698);
	<.main+?>: load.c32 1046269698
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+988
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[248] := (1049346327);
	<.main+?>: load.c32 1049346327
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+992
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[249] := (1052416857);
	<.main+?>: load.c32 1052416857
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+996
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[250] := (1055481313);
	<.main+?>: load.c32 1055481313
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1000
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[251] := (1058539719);
	<.main+?>: load.c32 1058539719
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1004
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[252] := (1061592098);
	<.main+?>: load.c32 1061592098
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1008
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[253] := (1064638475);
	<.main+?>: load.c32 1064638475
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1012
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[254] := (1067678872);
	<.main+?>: load.c32 1067678872
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1016
	cmplStd/lib/math/Fixed.ci:168: (9 bytes): tbl_log2[255] := (1070713314);
	<.main+?>: load.c32 1070713314
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1020
	cmplStd/lib/math/Fixed.ci:169: (9 bytes): tbl_log2[256] := (1073741824);
	<.main+?>: load.c32 1073741824
	<.main+?>: store.m32 <?> ;Fixed.log2.tbl_log2+1024
	cmplStd/lib/math/Fixed.ci:255: (2313 bytes): static const tbl_pow2: uint32[257] := {...}
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[0] := (1073741824);
	<.main+?>: load.c32 1073741824
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[1] := (1076653033);
	<.main+?>: load.c32 1076653033
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+4
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[2] := (1079572135);
	<.main+?>: load.c32 1079572135
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+8
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[3] := (1082499152);
	<.main+?>: load.c32 1082499152
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+12
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[4] := (1085434105);
	<.main+?>: load.c32 1085434105
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+16
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[5] := (1088377016);
	<.main+?>: load.c32 1088377016
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+20
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[6] := (1091327905);
	<.main+?>: load.c32 1091327905
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+24
	cmplStd/lib/math/Fixed.ci:257: (9 bytes): tbl_pow2[7] := (1094286795);
	<.main+?>: load.c32 1094286795
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+28
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[8] := (1097253708);
	<.main+?>: load.c32 1097253708
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+32
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[9] := (1100228664);
	<.main+?>: load.c32 1100228664
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+36
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[10] := (1103211687);
	<.main+?>: load.c32 1103211687
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+40
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[11] := (1106202797);
	<.main+?>: load.c32 1106202797
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+44
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[12] := (1109202017);
	<.main+?>: load.c32 1109202017
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+48
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[13] := (1112209369);
	<.main+?>: load.c32 1112209369
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+52
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[14] := (1115224875);
	<.main+?>: load.c32 1115224875
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+56
	cmplStd/lib/math/Fixed.ci:258: (9 bytes): tbl_pow2[15] := (1118248556);
	<.main+?>: load.c32 1118248556
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+60
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[16] := (1121280435);
	<.main+?>: load.c32 1121280435
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+64
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[17] := (1124320535);
	<.main+?>: load.c32 1124320535
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+68
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[18] := (1127368877);
	<.main+?>: load.c32 1127368877
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+72
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[19] := (1130425484);
	<.main+?>: load.c32 1130425484
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+76
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[20] := (1133490379);
	<.main+?>: load.c32 1133490379
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+80
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[21] := (1136563583);
	<.main+?>: load.c32 1136563583
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+84
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[22] := (1139645119);
	<.main+?>: load.c32 1139645119
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+88
	cmplStd/lib/math/Fixed.ci:259: (9 bytes): tbl_pow2[23] := (1142735011);
	<.main+?>: load.c32 1142735011
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+92
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[24] := (1145833280);
	<.main+?>: load.c32 1145833280
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+96
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[25] := (1148939949);
	<.main+?>: load.c32 1148939949
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+100
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[26] := (1152055041);
	<.main+?>: load.c32 1152055041
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+104
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[27] := (1155178579);
	<.main+?>: load.c32 1155178579
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+108
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[28] := (1158310586);
	<.main+?>: load.c32 1158310586
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+112
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[29] := (1161451085);
	<.main+?>: load.c32 1161451085
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+116
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[30] := (1164600098);
	<.main+?>: load.c32 1164600098
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+120
	cmplStd/lib/math/Fixed.ci:260: (9 bytes): tbl_pow2[31] := (1167757649);
	<.main+?>: load.c32 1167757649
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+124
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[32] := (1170923761);
	<.main+?>: load.c32 1170923761
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+128
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[33] := (1174098458);
	<.main+?>: load.c32 1174098458
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+132
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[34] := (1177281762);
	<.main+?>: load.c32 1177281762
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+136
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[35] := (1180473696);
	<.main+?>: load.c32 1180473696
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+140
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[36] := (1183674285);
	<.main+?>: load.c32 1183674285
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+144
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[37] := (1186883552);
	<.main+?>: load.c32 1186883552
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+148
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[38] := (1190101520);
	<.main+?>: load.c32 1190101520
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+152
	cmplStd/lib/math/Fixed.ci:261: (9 bytes): tbl_pow2[39] := (1193328212);
	<.main+?>: load.c32 1193328212
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+156
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[40] := (1196563653);
	<.main+?>: load.c32 1196563653
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+160
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[41] := (1199807866);
	<.main+?>: load.c32 1199807866
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+164
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[42] := (1203060875);
	<.main+?>: load.c32 1203060875
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+168
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[43] := (1206322704);
	<.main+?>: load.c32 1206322704
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+172
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[44] := (1209593377);
	<.main+?>: load.c32 1209593377
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+176
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[45] := (1212872917);
	<.main+?>: load.c32 1212872917
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+180
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[46] := (1216161349);
	<.main+?>: load.c32 1216161349
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+184
	cmplStd/lib/math/Fixed.ci:262: (9 bytes): tbl_pow2[47] := (1219458697);
	<.main+?>: load.c32 1219458697
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+188
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[48] := (1222764985);
	<.main+?>: load.c32 1222764985
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+192
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[49] := (1226080238);
	<.main+?>: load.c32 1226080238
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+196
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[50] := (1229404478);
	<.main+?>: load.c32 1229404478
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+200
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[51] := (1232737732);
	<.main+?>: load.c32 1232737732
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+204
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[52] := (1236080023);
	<.main+?>: load.c32 1236080023
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+208
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[53] := (1239431376);
	<.main+?>: load.c32 1239431376
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+212
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[54] := (1242791815);
	<.main+?>: load.c32 1242791815
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+216
	cmplStd/lib/math/Fixed.ci:263: (9 bytes): tbl_pow2[55] := (1246161366);
	<.main+?>: load.c32 1246161366
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+220
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[56] := (1249540052);
	<.main+?>: load.c32 1249540052
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+224
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[57] := (1252927899);
	<.main+?>: load.c32 1252927899
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+228
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[58] := (1256324931);
	<.main+?>: load.c32 1256324931
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+232
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[59] := (1259731173);
	<.main+?>: load.c32 1259731173
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+236
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[60] := (1263146651);
	<.main+?>: load.c32 1263146651
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+240
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[61] := (1266571389);
	<.main+?>: load.c32 1266571389
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+244
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[62] := (1270005412);
	<.main+?>: load.c32 1270005412
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+248
	cmplStd/lib/math/Fixed.ci:264: (9 bytes): tbl_pow2[63] := (1273448746);
	<.main+?>: load.c32 1273448746
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+252
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[64] := (1276901416);
	<.main+?>: load.c32 1276901416
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+256
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[65] := (1280363447);
	<.main+?>: load.c32 1280363447
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+260
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[66] := (1283834865);
	<.main+?>: load.c32 1283834865
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+264
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[67] := (1287315694);
	<.main+?>: load.c32 1287315694
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+268
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[68] := (1290805961);
	<.main+?>: load.c32 1290805961
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+272
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[69] := (1294305691);
	<.main+?>: load.c32 1294305691
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+276
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[70] := (1297814910);
	<.main+?>: load.c32 1297814910
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+280
	cmplStd/lib/math/Fixed.ci:265: (9 bytes): tbl_pow2[71] := (1301333643);
	<.main+?>: load.c32 1301333643
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+284
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[72] := (1304861916);
	<.main+?>: load.c32 1304861916
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+288
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[73] := (1308399756);
	<.main+?>: load.c32 1308399756
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+292
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[74] := (1311947188);
	<.main+?>: load.c32 1311947188
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+296
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[75] := (1315504237);
	<.main+?>: load.c32 1315504237
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+300
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[76] := (1319070931);
	<.main+?>: load.c32 1319070931
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+304
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[77] := (1322647295);
	<.main+?>: load.c32 1322647295
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+308
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[78] := (1326233356);
	<.main+?>: load.c32 1326233356
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+312
	cmplStd/lib/math/Fixed.ci:266: (9 bytes): tbl_pow2[79] := (1329829139);
	<.main+?>: load.c32 1329829139
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+316
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[80] := (1333434672);
	<.main+?>: load.c32 1333434672
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+320
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[81] := (1337049980);
	<.main+?>: load.c32 1337049980
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+324
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[82] := (1340675090);
	<.main+?>: load.c32 1340675090
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+328
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[83] := (1344310029);
	<.main+?>: load.c32 1344310029
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+332
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[84] := (1347954823);
	<.main+?>: load.c32 1347954823
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+336
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[85] := (1351609500);
	<.main+?>: load.c32 1351609500
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+340
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[86] := (1355274085);
	<.main+?>: load.c32 1355274085
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+344
	cmplStd/lib/math/Fixed.ci:267: (9 bytes): tbl_pow2[87] := (1358948606);
	<.main+?>: load.c32 1358948606
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+348
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[88] := (1362633089);
	<.main+?>: load.c32 1362633089
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+352
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[89] := (1366327562);
	<.main+?>: load.c32 1366327562
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+356
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[90] := (1370032052);
	<.main+?>: load.c32 1370032052
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+360
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[91] := (1373746586);
	<.main+?>: load.c32 1373746586
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+364
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[92] := (1377471191);
	<.main+?>: load.c32 1377471191
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+368
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[93] := (1381205894);
	<.main+?>: load.c32 1381205894
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+372
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[94] := (1384950723);
	<.main+?>: load.c32 1384950723
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+376
	cmplStd/lib/math/Fixed.ci:268: (9 bytes): tbl_pow2[95] := (1388705705);
	<.main+?>: load.c32 1388705705
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+380
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[96] := (1392470868);
	<.main+?>: load.c32 1392470868
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+384
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[97] := (1396246240);
	<.main+?>: load.c32 1396246240
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+388
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[98] := (1400031847);
	<.main+?>: load.c32 1400031847
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+392
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[99] := (1403827719);
	<.main+?>: load.c32 1403827719
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+396
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[100] := (1407633882);
	<.main+?>: load.c32 1407633882
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+400
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[101] := (1411450365);
	<.main+?>: load.c32 1411450365
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+404
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[102] := (1415277195);
	<.main+?>: load.c32 1415277195
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+408
	cmplStd/lib/math/Fixed.ci:269: (9 bytes): tbl_pow2[103] := (1419114400);
	<.main+?>: load.c32 1419114400
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+412
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[104] := (1422962010);
	<.main+?>: load.c32 1422962010
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+416
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[105] := (1426820051);
	<.main+?>: load.c32 1426820051
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+420
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[106] := (1430688553);
	<.main+?>: load.c32 1430688553
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+424
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[107] := (1434567543);
	<.main+?>: load.c32 1434567543
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+428
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[108] := (1438457050);
	<.main+?>: load.c32 1438457050
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+432
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[109] := (1442357103);
	<.main+?>: load.c32 1442357103
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+436
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[110] := (1446267730);
	<.main+?>: load.c32 1446267730
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+440
	cmplStd/lib/math/Fixed.ci:270: (9 bytes): tbl_pow2[111] := (1450188959);
	<.main+?>: load.c32 1450188959
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+444
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[112] := (1454120821);
	<.main+?>: load.c32 1454120821
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+448
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[113] := (1458063342);
	<.main+?>: load.c32 1458063342
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+452
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[114] := (1462016553);
	<.main+?>: load.c32 1462016553
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+456
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[115] := (1465980482);
	<.main+?>: load.c32 1465980482
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+460
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[116] := (1469955158);
	<.main+?>: load.c32 1469955158
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+464
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[117] := (1473940611);
	<.main+?>: load.c32 1473940611
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+468
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[118] := (1477936869);
	<.main+?>: load.c32 1477936869
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+472
	cmplStd/lib/math/Fixed.ci:271: (9 bytes): tbl_pow2[119] := (1481943963);
	<.main+?>: load.c32 1481943963
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+476
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[120] := (1485961920);
	<.main+?>: load.c32 1485961920
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+480
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[121] := (1489990772);
	<.main+?>: load.c32 1489990772
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+484
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[122] := (1494030547);
	<.main+?>: load.c32 1494030547
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+488
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[123] := (1498081274);
	<.main+?>: load.c32 1498081274
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+492
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[124] := (1502142985);
	<.main+?>: load.c32 1502142985
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+496
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[125] := (1506215708);
	<.main+?>: load.c32 1506215708
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+500
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[126] := (1510299473);
	<.main+?>: load.c32 1510299473
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+504
	cmplStd/lib/math/Fixed.ci:272: (9 bytes): tbl_pow2[127] := (1514394310);
	<.main+?>: load.c32 1514394310
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+508
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[128] := (1518500249);
	<.main+?>: load.c32 1518500249
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+512
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[129] := (1522617321);
	<.main+?>: load.c32 1522617321
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+516
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[130] := (1526745556);
	<.main+?>: load.c32 1526745556
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+520
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[131] := (1530884983);
	<.main+?>: load.c32 1530884983
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+524
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[132] := (1535035633);
	<.main+?>: load.c32 1535035633
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+528
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[133] := (1539197537);
	<.main+?>: load.c32 1539197537
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+532
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[134] := (1543370725);
	<.main+?>: load.c32 1543370725
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+536
	cmplStd/lib/math/Fixed.ci:273: (9 bytes): tbl_pow2[135] := (1547555227);
	<.main+?>: load.c32 1547555227
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+540
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[136] := (1551751075);
	<.main+?>: load.c32 1551751075
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+544
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[137] := (1555958299);
	<.main+?>: load.c32 1555958299
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+548
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[138] := (1560176930);
	<.main+?>: load.c32 1560176930
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+552
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[139] := (1564406999);
	<.main+?>: load.c32 1564406999
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+556
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[140] := (1568648537);
	<.main+?>: load.c32 1568648537
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+560
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[141] := (1572901574);
	<.main+?>: load.c32 1572901574
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+564
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[142] := (1577166143);
	<.main+?>: load.c32 1577166143
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+568
	cmplStd/lib/math/Fixed.ci:274: (9 bytes): tbl_pow2[143] := (1581442274);
	<.main+?>: load.c32 1581442274
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+572
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[144] := (1585729999);
	<.main+?>: load.c32 1585729999
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+576
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[145] := (1590029349);
	<.main+?>: load.c32 1590029349
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+580
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[146] := (1594340356);
	<.main+?>: load.c32 1594340356
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+584
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[147] := (1598663051);
	<.main+?>: load.c32 1598663051
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+588
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[148] := (1602997467);
	<.main+?>: load.c32 1602997467
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+592
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[149] := (1607343634);
	<.main+?>: load.c32 1607343634
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+596
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[150] := (1611701584);
	<.main+?>: load.c32 1611701584
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+600
	cmplStd/lib/math/Fixed.ci:275: (9 bytes): tbl_pow2[151] := (1616071351);
	<.main+?>: load.c32 1616071351
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+604
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[152] := (1620452965);
	<.main+?>: load.c32 1620452965
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+608
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[153] := (1624846458);
	<.main+?>: load.c32 1624846458
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+612
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[154] := (1629251864);
	<.main+?>: load.c32 1629251864
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+616
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[155] := (1633669214);
	<.main+?>: load.c32 1633669214
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+620
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[156] := (1638098541);
	<.main+?>: load.c32 1638098541
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+624
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[157] := (1642539876);
	<.main+?>: load.c32 1642539876
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+628
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[158] := (1646993254);
	<.main+?>: load.c32 1646993254
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+632
	cmplStd/lib/math/Fixed.ci:276: (9 bytes): tbl_pow2[159] := (1651458705);
	<.main+?>: load.c32 1651458705
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+636
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[160] := (1655936264);
	<.main+?>: load.c32 1655936264
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+640
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[161] := (1660425963);
	<.main+?>: load.c32 1660425963
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+644
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[162] := (1664927834);
	<.main+?>: load.c32 1664927834
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+648
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[163] := (1669441912);
	<.main+?>: load.c32 1669441912
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+652
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[164] := (1673968228);
	<.main+?>: load.c32 1673968228
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+656
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[165] := (1678506816);
	<.main+?>: load.c32 1678506816
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+660
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[166] := (1683057710);
	<.main+?>: load.c32 1683057710
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+664
	cmplStd/lib/math/Fixed.ci:277: (9 bytes): tbl_pow2[167] := (1687620942);
	<.main+?>: load.c32 1687620942
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+668
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[168] := (1692196547);
	<.main+?>: load.c32 1692196547
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+672
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[169] := (1696784557);
	<.main+?>: load.c32 1696784557
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+676
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[170] := (1701385007);
	<.main+?>: load.c32 1701385007
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+680
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[171] := (1705997929);
	<.main+?>: load.c32 1705997929
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+684
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[172] := (1710623359);
	<.main+?>: load.c32 1710623359
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+688
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[173] := (1715261329);
	<.main+?>: load.c32 1715261329
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+692
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[174] := (1719911875);
	<.main+?>: load.c32 1719911875
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+696
	cmplStd/lib/math/Fixed.ci:278: (9 bytes): tbl_pow2[175] := (1724575029);
	<.main+?>: load.c32 1724575029
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+700
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[176] := (1729250826);
	<.main+?>: load.c32 1729250826
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+704
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[177] := (1733939301);
	<.main+?>: load.c32 1733939301
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+708
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[178] := (1738640487);
	<.main+?>: load.c32 1738640487
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+712
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[179] := (1743354420);
	<.main+?>: load.c32 1743354420
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+716
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[180] := (1748081133);
	<.main+?>: load.c32 1748081133
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+720
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[181] := (1752820662);
	<.main+?>: load.c32 1752820662
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+724
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[182] := (1757573041);
	<.main+?>: load.c32 1757573041
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+728
	cmplStd/lib/math/Fixed.ci:279: (9 bytes): tbl_pow2[183] := (1762338305);
	<.main+?>: load.c32 1762338305
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+732
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[184] := (1767116488);
	<.main+?>: load.c32 1767116488
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+736
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[185] := (1771907627);
	<.main+?>: load.c32 1771907627
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+740
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[186] := (1776711756);
	<.main+?>: load.c32 1776711756
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+744
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[187] := (1781528911);
	<.main+?>: load.c32 1781528911
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+748
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[188] := (1786359125);
	<.main+?>: load.c32 1786359125
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+752
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[189] := (1791202436);
	<.main+?>: load.c32 1791202436
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+756
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[190] := (1796058879);
	<.main+?>: load.c32 1796058879
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+760
	cmplStd/lib/math/Fixed.ci:280: (9 bytes): tbl_pow2[191] := (1800928488);
	<.main+?>: load.c32 1800928488
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+764
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[192] := (1805811301);
	<.main+?>: load.c32 1805811301
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+768
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[193] := (1810707352);
	<.main+?>: load.c32 1810707352
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+772
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[194] := (1815616678);
	<.main+?>: load.c32 1815616678
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+776
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[195] := (1820539314);
	<.main+?>: load.c32 1820539314
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+780
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[196] := (1825475297);
	<.main+?>: load.c32 1825475297
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+784
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[197] := (1830424662);
	<.main+?>: load.c32 1830424662
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+788
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[198] := (1835387447);
	<.main+?>: load.c32 1835387447
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+792
	cmplStd/lib/math/Fixed.ci:281: (9 bytes): tbl_pow2[199] := (1840363687);
	<.main+?>: load.c32 1840363687
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+796
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[200] := (1845353419);
	<.main+?>: load.c32 1845353419
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+800
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[201] := (1850356680);
	<.main+?>: load.c32 1850356680
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+804
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[202] := (1855373506);
	<.main+?>: load.c32 1855373506
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+808
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[203] := (1860403934);
	<.main+?>: load.c32 1860403934
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+812
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[204] := (1865448001);
	<.main+?>: load.c32 1865448001
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+816
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[205] := (1870505743);
	<.main+?>: load.c32 1870505743
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+820
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[206] := (1875577199);
	<.main+?>: load.c32 1875577199
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+824
	cmplStd/lib/math/Fixed.ci:282: (9 bytes): tbl_pow2[207] := (1880662405);
	<.main+?>: load.c32 1880662405
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+828
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[208] := (1885761398);
	<.main+?>: load.c32 1885761398
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+832
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[209] := (1890874215);
	<.main+?>: load.c32 1890874215
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+836
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[210] := (1896000895);
	<.main+?>: load.c32 1896000895
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+840
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[211] := (1901141475);
	<.main+?>: load.c32 1901141475
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+844
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[212] := (1906295993);
	<.main+?>: load.c32 1906295993
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+848
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[213] := (1911464486);
	<.main+?>: load.c32 1911464486
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+852
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[214] := (1916646992);
	<.main+?>: load.c32 1916646992
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+856
	cmplStd/lib/math/Fixed.ci:283: (9 bytes): tbl_pow2[215] := (1921843549);
	<.main+?>: load.c32 1921843549
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+860
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[216] := (1927054195);
	<.main+?>: load.c32 1927054195
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+864
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[217] := (1932278969);
	<.main+?>: load.c32 1932278969
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+868
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[218] := (1937517909);
	<.main+?>: load.c32 1937517909
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+872
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[219] := (1942771053);
	<.main+?>: load.c32 1942771053
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+876
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[220] := (1948038440);
	<.main+?>: load.c32 1948038440
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+880
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[221] := (1953320108);
	<.main+?>: load.c32 1953320108
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+884
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[222] := (1958616096);
	<.main+?>: load.c32 1958616096
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+888
	cmplStd/lib/math/Fixed.ci:284: (9 bytes): tbl_pow2[223] := (1963926443);
	<.main+?>: load.c32 1963926443
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+892
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[224] := (1969251187);
	<.main+?>: load.c32 1969251187
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+896
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[225] := (1974590369);
	<.main+?>: load.c32 1974590369
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+900
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[226] := (1979944027);
	<.main+?>: load.c32 1979944027
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+904
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[227] := (1985312199);
	<.main+?>: load.c32 1985312199
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+908
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[228] := (1990694927);
	<.main+?>: load.c32 1990694927
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+912
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[229] := (1996092248);
	<.main+?>: load.c32 1996092248
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+916
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[230] := (2001504204);
	<.main+?>: load.c32 2001504204
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+920
	cmplStd/lib/math/Fixed.ci:285: (9 bytes): tbl_pow2[231] := (2006930832);
	<.main+?>: load.c32 2006930832
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+924
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[232] := (2012372173);
	<.main+?>: load.c32 2012372173
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+928
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[233] := (2017828268);
	<.main+?>: load.c32 2017828268
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+932
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[234] := (2023299155);
	<.main+?>: load.c32 2023299155
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+936
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[235] := (2028784876);
	<.main+?>: load.c32 2028784876
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+940
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[236] := (2034285470);
	<.main+?>: load.c32 2034285470
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+944
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[237] := (2039800977);
	<.main+?>: load.c32 2039800977
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+948
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[238] := (2045331439);
	<.main+?>: load.c32 2045331439
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+952
	cmplStd/lib/math/Fixed.ci:286: (9 bytes): tbl_pow2[239] := (2050876895);
	<.main+?>: load.c32 2050876895
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+956
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[240] := (2056437386);
	<.main+?>: load.c32 2056437386
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+960
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[241] := (2062012953);
	<.main+?>: load.c32 2062012953
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+964
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[242] := (2067603638);
	<.main+?>: load.c32 2067603638
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+968
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[243] := (2073209480);
	<.main+?>: load.c32 2073209480
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+972
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[244] := (2078830521);
	<.main+?>: load.c32 2078830521
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+976
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[245] := (2084466802);
	<.main+?>: load.c32 2084466802
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+980
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[246] := (2090118365);
	<.main+?>: load.c32 2090118365
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+984
	cmplStd/lib/math/Fixed.ci:287: (9 bytes): tbl_pow2[247] := (2095785251);
	<.main+?>: load.c32 2095785251
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+988
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[248] := (2101467501);
	<.main+?>: load.c32 2101467501
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+992
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[249] := (2107165158);
	<.main+?>: load.c32 2107165158
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+996
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[250] := (2112878262);
	<.main+?>: load.c32 2112878262
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1000
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[251] := (2118606856);
	<.main+?>: load.c32 2118606856
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1004
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[252] := (2124350982);
	<.main+?>: load.c32 2124350982
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1008
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[253] := (2130110682);
	<.main+?>: load.c32 2130110682
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1012
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[254] := (2135885998);
	<.main+?>: load.c32 2135885998
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1016
	cmplStd/lib/math/Fixed.ci:288: (9 bytes): tbl_pow2[255] := (2141676972);
	<.main+?>: load.c32 2141676972
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1020
	cmplStd/lib/math/Fixed.ci:289: (9 bytes): tbl_pow2[256] := (2147483648);
	<.main+?>: load.c32 -2147483648
	<.main+?>: store.m32 <?> ;Fixed.pow2.tbl_pow2+1024
	cmplStd/lib/time/Duration.ci:8: (13 bytes): static const precision: Timeunit := Timeunit.(Millis)
	<.main+?>: load.c64 1000000
	<.main+?>: store.m64 <?> ;Duration.precision
	cmplStd/lib/time/Timestamp.ci:9: (13 bytes): static const precision: Timeunit := Timeunit.(Millis)
	<.main+?>: load.c64 1000000
	<.main+?>: store.m64 <?> ;Timestamp.precision
	cmplStd/lib/time/Datetime.ci:97: (113 bytes): static const DaysToMonth365: int32[13] := {...}
	cmplStd/lib/time/Datetime.ci:97: (5 bytes): DaysToMonth365[0] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[1] := 31;
	<.main+?>: load.c32 31
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+4
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[2] := 59;
	<.main+?>: load.c32 59
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+8
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[3] := 90;
	<.main+?>: load.c32 90
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+12
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[4] := 120;
	<.main+?>: load.c32 120
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+16
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[5] := 151;
	<.main+?>: load.c32 151
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+20
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[6] := 181;
	<.main+?>: load.c32 181
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+24
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[7] := 212;
	<.main+?>: load.c32 212
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+28
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[8] := 243;
	<.main+?>: load.c32 243
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+32
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[9] := 273;
	<.main+?>: load.c32 273
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+36
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[10] := 304;
	<.main+?>: load.c32 304
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+40
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[11] := 334;
	<.main+?>: load.c32 334
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+44
	cmplStd/lib/time/Datetime.ci:97: (9 bytes): DaysToMonth365[12] := 365;
	<.main+?>: load.c32 365
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth365+48
	cmplStd/lib/time/Datetime.ci:98: (113 bytes): static const DaysToMonth366: int32[13] := {...}
	cmplStd/lib/time/Datetime.ci:98: (5 bytes): DaysToMonth366[0] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[1] := 31;
	<.main+?>: load.c32 31
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+4
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[2] := 60;
	<.main+?>: load.c32 60
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+8
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[3] := 91;
	<.main+?>: load.c32 91
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+12
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[4] := 121;
	<.main+?>: load.c32 121
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+16
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[5] := 152;
	<.main+?>: load.c32 152
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+20
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[6] := 182;
	<.main+?>: load.c32 182
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+24
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[7] := 213;
	<.main+?>: load.c32 213
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+28
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[8] := 244;
	<.main+?>: load.c32 244
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+32
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[9] := 274;
	<.main+?>: load.c32 274
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+36
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[10] := 305;
	<.main+?>: load.c32 305
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+40
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[11] := 335;
	<.main+?>: load.c32 335
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+44
	cmplStd/lib/time/Datetime.ci:98: (9 bytes): DaysToMonth366[12] := 366;
	<.main+?>: load.c32 366
	<.main+?>: store.m32 <?> ;Datetime.DaysToMonth366+48
	cmplStd/lib/time/Datetime.ci:99: (9 bytes): static const DaysTil1970: int32 := 719162
	<.main+?>: load.c32 719162
	<.main+?>: store.m32 <?> ;Datetime.DaysTil1970
	cmplStd/lib/text/Format.ci:108: (14 bytes): static const whiteSpace: char[] := " \t\n\r"
	<.main+?>: load.c32 4
	<.main+?>: load.ref <?> ;" \t\n\r"
	<.main+?>: store.m64 <?> ;append.whiteSpace
	cmplStd/lib/text/Format.ci:109: (14 bytes): static const radixDigits: char[] := "0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: load.c32 36
	<.main+?>: load.ref <?> ;"0123456789abcdefghijklmnopqrstuvwxyz"
	<.main+?>: store.m64 <?> ;append.radixDigits
	cmplStd/lib/text/Format.ci:508: (182 bytes): static const monthsLongEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:508: (14 bytes): monthsLongEn := monthsLongEn.init
	<.main+?>: load.c32 12
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.monthsLongEn
	cmplStd/lib/text/Format.ci:509: (14 bytes): monthsLongEn.init[0] := ("January");
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;"January"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:510: (14 bytes): monthsLongEn.init[1] := ("February");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"February"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:511: (14 bytes): monthsLongEn.init[2] := ("March");
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;"March"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:512: (14 bytes): monthsLongEn.init[3] := ("April");
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;"April"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:513: (14 bytes): monthsLongEn.init[4] := ("May");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"May"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:514: (14 bytes): monthsLongEn.init[5] := ("June");
	<.main+?>: load.c32 4
	<.main+?>: load.ref <?> ;"June"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:515: (14 bytes): monthsLongEn.init[6] := ("July");
	<.main+?>: load.c32 4
	<.main+?>: load.ref <?> ;"July"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:516: (14 bytes): monthsLongEn.init[7] := ("August");
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"August"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:517: (14 bytes): monthsLongEn.init[8] := ("September");
	<.main+?>: load.c32 9
	<.main+?>: load.ref <?> ;"September"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:518: (14 bytes): monthsLongEn.init[9] := ("October");
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;"October"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:519: (14 bytes): monthsLongEn.init[10] := ("November");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"November"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:520: (14 bytes): monthsLongEn.init[11] := ("December");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"December"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:522: (182 bytes): static const monthsShortEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:522: (14 bytes): monthsShortEn := monthsShortEn.init
	<.main+?>: load.c32 12
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.monthsShortEn
	cmplStd/lib/text/Format.ci:523: (14 bytes): monthsShortEn.init[0] := ("Jan");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Jan"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:523: (14 bytes): monthsShortEn.init[1] := ("Feb");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Feb"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:523: (14 bytes): monthsShortEn.init[2] := ("Mar");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Mar"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:523: (14 bytes): monthsShortEn.init[3] := ("Apr");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Apr"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:524: (14 bytes): monthsShortEn.init[4] := ("May");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"May"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:524: (14 bytes): monthsShortEn.init[5] := ("Jun");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Jun"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:524: (14 bytes): monthsShortEn.init[6] := ("Jul");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Jul"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:524: (14 bytes): monthsShortEn.init[7] := ("Aug");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Aug"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:525: (14 bytes): monthsShortEn.init[8] := ("Sep");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Sep"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:525: (14 bytes): monthsShortEn.init[9] := ("Oct");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Oct"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:525: (14 bytes): monthsShortEn.init[10] := ("Nov");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Nov"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:525: (14 bytes): monthsShortEn.init[11] := ("Dec");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Dec"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:527: (112 bytes): static const weeksLongEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:527: (14 bytes): weeksLongEn := weeksLongEn.init
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.weeksLongEn
	cmplStd/lib/text/Format.ci:528: (14 bytes): weeksLongEn.init[0] := ("Monday");
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"Monday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:529: (14 bytes): weeksLongEn.init[1] := ("Tuesday");
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;"Tuesday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:530: (14 bytes): weeksLongEn.init[2] := ("Wednesday");
	<.main+?>: load.c32 9
	<.main+?>: load.ref <?> ;"Wednesday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:531: (14 bytes): weeksLongEn.init[3] := ("Thursday");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"Thursday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:532: (14 bytes): weeksLongEn.init[4] := ("Friday");
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"Friday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:533: (14 bytes): weeksLongEn.init[5] := ("Saturday");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"Saturday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:534: (14 bytes): weeksLongEn.init[6] := ("Sunday");
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"Sunday"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:536: (112 bytes): static const weeksShortEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:536: (14 bytes): weeksShortEn := weeksShortEn.init
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.weeksShortEn
	cmplStd/lib/text/Format.ci:537: (14 bytes): weeksShortEn.init[0] := ("Mon");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Mon"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:537: (14 bytes): weeksShortEn.init[1] := ("Tue");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Tue"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:537: (14 bytes): weeksShortEn.init[2] := ("Wed");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Wed"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:538: (14 bytes): weeksShortEn.init[3] := ("Thu");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Thu"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:538: (14 bytes): weeksShortEn.init[4] := ("Fri");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Fri"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:538: (14 bytes): weeksShortEn.init[5] := ("Sat");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Sat"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:539: (14 bytes): weeksShortEn.init[6] := ("Sun");
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"Sun"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:541: (42 bytes): static const amPmUpperEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:541: (14 bytes): amPmUpperEn := amPmUpperEn.init
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.amPmUpperEn
	cmplStd/lib/text/Format.ci:542: (14 bytes): amPmUpperEn.init[0] := ("AM");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"AM"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:543: (14 bytes): amPmUpperEn.init[1] := ("PM");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"PM"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:545: (42 bytes): static const amPmLowerEn: char[][] := {...}
	cmplStd/lib/text/Format.ci:545: (14 bytes): amPmLowerEn := amPmLowerEn.init
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?>
	<.main+?>: store.m64 <?> ;format.amPmLowerEn
	cmplStd/lib/text/Format.ci:546: (14 bytes): amPmLowerEn.init[0] := ("am");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"am"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:547: (14 bytes): amPmLowerEn.init[1] := ("pm");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"pm"
	<.main+?>: store.m64 <?>
	cmplStd/lib/text/Format.ci:550: (104 bytes): static const fmtEN: DatetimeFormat := {...}
	cmplStd/lib/text/Format.ci:551: (8 bytes): fmtEN.monthsLong := (monthsLongEn);
	<.main+?>: load.m64 <?> ;format.monthsLongEn
	<.main+?>: store.m64 <?> ;format.fmtEN
	cmplStd/lib/text/Format.ci:552: (8 bytes): fmtEN.monthsShort := (monthsShortEn);
	<.main+?>: load.m64 <?> ;format.monthsShortEn
	<.main+?>: store.m64 <?> ;format.fmtEN+8
	cmplStd/lib/text/Format.ci:553: (8 bytes): fmtEN.weeksLong := (weeksLongEn);
	<.main+?>: load.m64 <?> ;format.weeksLongEn
	<.main+?>: store.m64 <?> ;format.fmtEN+16
	cmplStd/lib/text/Format.ci:554: (8 bytes): fmtEN.weeksShort := (weeksShortEn);
	<.main+?>: load.m64 <?> ;format.weeksShortEn
	<.main+?>: store.m64 <?> ;format.fmtEN+24
	cmplStd/lib/text/Format.ci:555: (8 bytes): fmtEN.amPmUpper := (amPmUpperEn);
	<.main+?>: load.m64 <?> ;format.amPmUpperEn
	<.main+?>: store.m64 <?> ;format.fmtEN+32
	cmplStd/lib/text/Format.ci:556: (8 bytes): fmtEN.amPmLower := (amPmLowerEn);
	<.main+?>: load.m64 <?> ;format.amPmLowerEn
	<.main+?>: store.m64 <?> ;format.fmtEN+40
	:: (14 bytes): fmtEN.dateLong := ("%A %d %B %Y");
	<.main+?>: load.c32 11
	<.main+?>: load.ref <?> ;"%A %d %B %Y"
	<.main+?>: store.m64 <?> ;format.fmtEN+48
	:: (14 bytes): fmtEN.timeLong := ("%r");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"%r"
	<.main+?>: store.m64 <?> ;format.fmtEN+56
	:: (14 bytes): fmtEN.dateShort := ("%x");
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;"%x"
	<.main+?>: store.m64 <?> ;format.fmtEN+64
	:: (14 bytes): fmtEN.timeShort := ("%I:%M %p");
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"%I:%M %p"
	<.main+?>: store.m64 <?> ;format.fmtEN+72
	cmplStd/lib/text/Format.ci:564: (39 bytes): static const format: FormatFlags := {...}
	:: (7 bytes): format.sign := (0);
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format
	<.main+?>: store.i8
	:: (7 bytes): format.padChr := (0);
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;append.format+1
	<.main+?>: store.i8
	:: (5 bytes): format.width := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;append.format+4
	:: (9 bytes): format.precision := 10;
	<.main+?>: load.c32 10
	<.main+?>: store.m32 <?> ;append.format+8
	:: (11 bytes): format.trimDecimal := true;
	<.main+?>: load.c32 1
	<.main+?>: load.ref <?> ;append.format+12
	<.main+?>: store.i8
	cmplStd/lib/text/encoding/binary/Base64.ci:3: (14 bytes): static const lookup: uint8[] := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	<.main+?>: load.c32 64
	<.main+?>: load.ref <?> ;"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	<.main+?>: store.m64 <?> ;Base64Encoder.lookup
	cmplStd/lib/text/encoding/binary/Base64.ci:136: (2300 bytes): static const lookup: int32[256] := {...}
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[0] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[1] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+4
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[2] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+8
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[3] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+12
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[4] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+16
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[5] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+20
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[6] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+24
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[7] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+28
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[8] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+32
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[9] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+36
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[10] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+40
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[11] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+44
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[12] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+48
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[13] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+52
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[14] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+56
	cmplStd/lib/text/encoding/binary/Base64.ci:137: (9 bytes): lookup[15] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+60
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[16] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+64
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[17] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+68
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[18] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+72
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[19] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+76
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[20] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+80
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[21] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+84
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[22] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+88
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[23] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+92
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[24] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+96
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[25] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+100
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[26] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+104
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[27] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+108
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[28] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+112
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[29] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+116
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[30] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+120
	cmplStd/lib/text/encoding/binary/Base64.ci:138: (9 bytes): lookup[31] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+124
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[32] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+128
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[33] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+132
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[34] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+136
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[35] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+140
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[36] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+144
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[37] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+148
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[38] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+152
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[39] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+156
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[40] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+160
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[41] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+164
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[42] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+168
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[43] := 62;
	<.main+?>: load.c32 62
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+172
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[44] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+176
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[45] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+180
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[46] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+184
	cmplStd/lib/text/encoding/binary/Base64.ci:139: (9 bytes): lookup[47] := 63;
	<.main+?>: load.c32 63
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+188
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[48] := 52;
	<.main+?>: load.c32 52
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+192
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[49] := 53;
	<.main+?>: load.c32 53
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+196
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[50] := 54;
	<.main+?>: load.c32 54
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+200
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[51] := 55;
	<.main+?>: load.c32 55
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+204
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[52] := 56;
	<.main+?>: load.c32 56
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+208
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[53] := 57;
	<.main+?>: load.c32 57
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+212
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[54] := 58;
	<.main+?>: load.c32 58
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+216
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[55] := 59;
	<.main+?>: load.c32 59
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+220
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[56] := 60;
	<.main+?>: load.c32 60
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+224
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[57] := 61;
	<.main+?>: load.c32 61
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+228
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[58] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+232
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[59] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+236
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[60] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+240
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[61] := -2;
	<.main+?>: load.c32 -2
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+244
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[62] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+248
	cmplStd/lib/text/encoding/binary/Base64.ci:140: (9 bytes): lookup[63] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+252
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[64] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+256
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (5 bytes): lookup[65] := 0;
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+260
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[66] := 1;
	<.main+?>: load.c32 1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+264
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[67] := 2;
	<.main+?>: load.c32 2
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+268
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[68] := 3;
	<.main+?>: load.c32 3
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+272
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[69] := 4;
	<.main+?>: load.c32 4
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+276
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[70] := 5;
	<.main+?>: load.c32 5
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+280
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[71] := 6;
	<.main+?>: load.c32 6
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+284
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[72] := 7;
	<.main+?>: load.c32 7
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+288
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[73] := 8;
	<.main+?>: load.c32 8
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+292
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[74] := 9;
	<.main+?>: load.c32 9
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+296
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[75] := 10;
	<.main+?>: load.c32 10
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+300
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[76] := 11;
	<.main+?>: load.c32 11
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+304
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[77] := 12;
	<.main+?>: load.c32 12
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+308
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[78] := 13;
	<.main+?>: load.c32 13
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+312
	cmplStd/lib/text/encoding/binary/Base64.ci:141: (9 bytes): lookup[79] := 14;
	<.main+?>: load.c32 14
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+316
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[80] := 15;
	<.main+?>: load.c32 15
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+320
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[81] := 16;
	<.main+?>: load.c32 16
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+324
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[82] := 17;
	<.main+?>: load.c32 17
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+328
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[83] := 18;
	<.main+?>: load.c32 18
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+332
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[84] := 19;
	<.main+?>: load.c32 19
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+336
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[85] := 20;
	<.main+?>: load.c32 20
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+340
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[86] := 21;
	<.main+?>: load.c32 21
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+344
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[87] := 22;
	<.main+?>: load.c32 22
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+348
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[88] := 23;
	<.main+?>: load.c32 23
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+352
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[89] := 24;
	<.main+?>: load.c32 24
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+356
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[90] := 25;
	<.main+?>: load.c32 25
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+360
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[91] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+364
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[92] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+368
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[93] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+372
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[94] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+376
	cmplStd/lib/text/encoding/binary/Base64.ci:142: (9 bytes): lookup[95] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+380
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[96] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+384
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[97] := 26;
	<.main+?>: load.c32 26
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+388
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[98] := 27;
	<.main+?>: load.c32 27
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+392
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[99] := 28;
	<.main+?>: load.c32 28
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+396
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[100] := 29;
	<.main+?>: load.c32 29
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+400
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[101] := 30;
	<.main+?>: load.c32 30
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+404
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[102] := 31;
	<.main+?>: load.c32 31
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+408
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[103] := 32;
	<.main+?>: load.c32 32
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+412
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[104] := 33;
	<.main+?>: load.c32 33
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+416
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[105] := 34;
	<.main+?>: load.c32 34
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+420
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[106] := 35;
	<.main+?>: load.c32 35
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+424
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[107] := 36;
	<.main+?>: load.c32 36
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+428
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[108] := 37;
	<.main+?>: load.c32 37
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+432
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[109] := 38;
	<.main+?>: load.c32 38
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+436
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[110] := 39;
	<.main+?>: load.c32 39
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+440
	cmplStd/lib/text/encoding/binary/Base64.ci:143: (9 bytes): lookup[111] := 40;
	<.main+?>: load.c32 40
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+444
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[112] := 41;
	<.main+?>: load.c32 41
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+448
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[113] := 42;
	<.main+?>: load.c32 42
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+452
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[114] := 43;
	<.main+?>: load.c32 43
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+456
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[115] := 44;
	<.main+?>: load.c32 44
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+460
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[116] := 45;
	<.main+?>: load.c32 45
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+464
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[117] := 46;
	<.main+?>: load.c32 46
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+468
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[118] := 47;
	<.main+?>: load.c32 47
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+472
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[119] := 48;
	<.main+?>: load.c32 48
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+476
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[120] := 49;
	<.main+?>: load.c32 49
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+480
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[121] := 50;
	<.main+?>: load.c32 50
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+484
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[122] := 51;
	<.main+?>: load.c32 51
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+488
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[123] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+492
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[124] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+496
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[125] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+500
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[126] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+504
	cmplStd/lib/text/encoding/binary/Base64.ci:144: (9 bytes): lookup[127] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+508
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[128] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+512
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[129] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+516
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[130] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+520
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[131] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+524
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[132] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+528
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[133] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+532
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[134] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+536
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[135] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+540
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[136] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+544
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[137] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+548
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[138] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+552
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[139] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+556
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[140] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+560
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[141] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+564
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[142] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+568
	cmplStd/lib/text/encoding/binary/Base64.ci:145: (9 bytes): lookup[143] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+572
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[144] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+576
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[145] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+580
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[146] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+584
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[147] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+588
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[148] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+592
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[149] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+596
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[150] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+600
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[151] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+604
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[152] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+608
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[153] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+612
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[154] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+616
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[155] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+620
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[156] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+624
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[157] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+628
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[158] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+632
	cmplStd/lib/text/encoding/binary/Base64.ci:146: (9 bytes): lookup[159] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+636
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[160] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+640
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[161] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+644
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[162] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+648
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[163] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+652
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[164] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+656
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[165] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+660
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[166] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+664
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[167] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+668
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[168] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+672
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[169] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+676
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[170] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+680
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[171] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+684
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[172] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+688
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[173] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+692
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[174] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+696
	cmplStd/lib/text/encoding/binary/Base64.ci:147: (9 bytes): lookup[175] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+700
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[176] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+704
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[177] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+708
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[178] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+712
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[179] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+716
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[180] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+720
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[181] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+724
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[182] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+728
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[183] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+732
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[184] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+736
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[185] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+740
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[186] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+744
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[187] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+748
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[188] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+752
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[189] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+756
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[190] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+760
	cmplStd/lib/text/encoding/binary/Base64.ci:148: (9 bytes): lookup[191] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+764
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[192] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+768
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[193] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+772
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[194] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+776
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[195] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+780
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[196] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+784
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[197] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+788
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[198] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+792
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[199] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+796
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[200] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+800
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[201] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+804
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[202] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+808
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[203] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+812
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[204] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+816
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[205] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+820
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[206] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+824
	cmplStd/lib/text/encoding/binary/Base64.ci:149: (9 bytes): lookup[207] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+828
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[208] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+832
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[209] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+836
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[210] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+840
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[211] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+844
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[212] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+848
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[213] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+852
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[214] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+856
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[215] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+860
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[216] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+864
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[217] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+868
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[218] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+872
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[219] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+876
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[220] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+880
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[221] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+884
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[222] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+888
	cmplStd/lib/text/encoding/binary/Base64.ci:150: (9 bytes): lookup[223] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+892
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[224] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+896
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[225] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+900
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[226] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+904
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[227] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+908
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[228] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+912
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[229] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+916
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[230] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+920
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[231] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+924
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[232] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+928
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[233] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+932
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[234] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+936
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[235] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+940
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[236] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+944
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[237] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+948
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[238] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+952
	cmplStd/lib/text/encoding/binary/Base64.ci:151: (9 bytes): lookup[239] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+956
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[240] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+960
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[241] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+964
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[242] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+968
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[243] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+972
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[244] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+976
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[245] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+980
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[246] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+984
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[247] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+988
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[248] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+992
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[249] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+996
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[250] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1000
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[251] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1004
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[252] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1008
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[253] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1012
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[254] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1016
	cmplStd/lib/text/encoding/binary/Base64.ci:152: (9 bytes): lookup[255] := -1;
	<.main+?>: load.c32 -1
	<.main+?>: store.m32 <?> ;Base64Decoder.lookup+1020
	cmplStd/test/lang/init.reference.ci:7: (13 bytes): static value: int64 := 42
	<.main+?>: load.c64 42
	<.main+?>: store.m64 <?> ;value
	cmplStd/test/lang/init.member.ci:34: (5 bytes): static global: int32
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;RecordMemberTest.global
	cmplStd/test/lang/init.member.ci:37: (9 bytes): static globalInit: int32 := 1
	<.main+?>: load.c32 1
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalInit
	cmplStd/test/lang/init.member.ci:40: (9 bytes): static const globalConstant: int32 := 2
	<.main+?>: load.c32 2
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalConstant
	cmplStd/test/lang/init.member.ci:43: (14 bytes): static globalRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:43: (9 bytes): globalRec.constant := 4;
	<.main+?>: load.c32 4
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalRec+4
	:: (5 bytes): globalRec.member := (0);
	<.main+?>: load.z32
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalRec
	cmplStd/test/lang/init.member.ci:46: (18 bytes): static globalRecInit: Inner := {...}
	cmplStd/test/lang/init.member.ci:46: (9 bytes): globalRecInit.member := 4;
	<.main+?>: load.c32 4
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalRecInit
	cmplStd/test/lang/init.member.ci:46: (9 bytes): globalRecInit.constant := 5;
	<.main+?>: load.c32 5
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalRecInit+4
	cmplStd/test/lang/init.member.ci:49: (18 bytes): static const globalConstantRec: Inner := {...}
	cmplStd/test/lang/init.member.ci:49: (9 bytes): globalConstantRec.member := 6;
	<.main+?>: load.c32 6
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalConstantRec
	cmplStd/test/lang/init.member.ci:49: (9 bytes): globalConstantRec.constant := 7;
	<.main+?>: load.c32 7
	<.main+?>: store.m32 <?> ;RecordMemberTest.globalConstantRec+4
	cmplStd/test/lang/init.method.ci:18: (9 bytes): static forwardMethod(this: RecordMethodTest, x: int32): void := forwardMethod
	<.main+?>: load.ref <?> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: store.m32 <?> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	cmplStd/test/lang/emit.ci:3: (1 byte): emitldz32: int32 := emit(load.z32)
	<.main+?>: load.z32
	cmplStd/test/lang/emit.ci:4: (1 byte): emitldz64: int64 := emit(load.z64)
	<.main+?>: load.z64
	cmplStd/test/lang/emit.ci:6: (5 bytes): emitA: int32 := 42
	<.main+?>: load.c32 42
	cmplStd/test/lang/emit.ci:7: (5 bytes): emitB: int32 := 96
	<.main+?>: load.c32 96
	cmplStd/test/lang/emit.ci:10: (5 bytes): emitAddI32: int32 := emit(int32(emitA), int32(emitB), add.i32)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: add.i32
	cmplStd/test/lang/emit.ci:13: (11 bytes): emitDivI32: int32 := emit(int32(10), int32(5), div.i32)
	<.main+?>: load.c32 10
	<.main+?>: load.c32 5
	<.main+?>: div.i32
	cmplStd/test/lang/emit.ci:16: (15 bytes): emitNfcF32: float32 := emit(float32(3.140000), float32(2), div.f32, float32.sin)
	<.main+?>: load.f32 3.140000
	<.main+?>: load.f32 2.000000
	<.main+?>: div.f32
	<.main+?>: nfc(34) ;float32.sin(x: float32): float32
	cmplStd/test/lang/emit.ci:23: (5 bytes): emitFloatAsInt1: int32 := floatAsInt32(500)
	<.main+?>: load.f32 500.000000
	cmplStd/test/lang/emit.ci:24: (6 bytes): emitFloatAsInt2: int64 := floatAsInt32(500)
	<.main+?>: load.f32 500.000000
	<.main+?>: i32.2i64
	cmplStd/test/lang/emit.ci:25: (10 bytes): emitFloatAsInt3: int32 := floatAsInt64(500)
	<.main+?>: load.f64 500.000000
	<.main+?>: i64.2i32
	cmplStd/test/lang/emit.ci:26: (9 bytes): emitFloatAsInt4: int64 := floatAsInt64(500)
	<.main+?>: load.f64 500.000000
	cmplStd/test/lang/emit.ci:30: (10 bytes): emitSlice: char[] := emit(int32(3), pointer("string"))
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"string"
	cmplStd/test/lang/inlineMacros.ci:10: (5 bytes): i3: int32 := 3
	<.main+?>: load.c32 3
	cmplStd/test/lang/inlineMacros.ci:11: (5 bytes): i6: int32 := 6
	<.main+?>: load.c32 6
	cmplStd/test/lang/inlineMacros.ci:12: (5 bytes): i2: int32 := 2
	<.main+?>: load.c32 2
	cmplStd/test/lang/inlineMacros.ci:13: (5 bytes): i8: int32 := 8
	<.main+?>: load.c32 8
	cmplStd/test/lang/inlineMacros.ci:15: (1 byte): zeroVal: int32 := zero(3, 6)
	<.main+?>: load.z32
	cmplStd/test/lang/inlineMacros.ci:16: (1 byte): zeroVar: int32 := zero(i3, i6)
	<.main+?>: load.z32
	cmplStd/test/lang/inlineMacros.ci:17: (1 byte): zeroXpr: int32 := zero(i3 + 1, i6 + 1)
	<.main+?>: load.z32
	cmplStd/test/lang/inlineMacros.ci:19: (5 bytes): lastVal: int32 := last(3, 6)
	<.main+?>: load.c32 6
	cmplStd/test/lang/inlineMacros.ci:20: (2 bytes): lastVar: int32 := last(i3, i6)
	<.main+?>: dup.x32 sp(6)
	cmplStd/test/lang/inlineMacros.ci:21: (10 bytes): lastXpr: int32 := last(i3 + 1, i6 + 1) - 1
	<.main+?>: dup.x32 sp(7)
	<.main+?>: inc.i32(+1)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:23: (9 bytes): sum2Val: int32 := sum(3, 6)
	<.main+?>: load.c32 3
	<.main+?>: inc.i32(+6)
	cmplStd/test/lang/inlineMacros.ci:24: (5 bytes): sum2Var: int32 := sum(i3, i6)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: add.i32
	cmplStd/test/lang/inlineMacros.ci:25: (17 bytes): sum2Xpr: int32 := sum(i3 + 1, i6 + 1) - 2
	<.main+?>: dup.x32 sp(11)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(11)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: inc.i32(-2)
	cmplStd/test/lang/inlineMacros.ci:27: (24 bytes): any2Val: int32 := any(3, 6)
	<.main+?>: load.c32 3
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 6
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:28: (18 bytes): any2Var: int32 := any(i3, i6)
	<.main+?>: dup.x32 sp(13)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(13)
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:29: (30 bytes): any2Xpr: int32 := any(i3 + 1, i6 + 1) - 1
	<.main+?>: dup.x32 sp(14)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(14)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:31: (34 bytes): min2Val: int32 := min(3, 6)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:32: (28 bytes): min2Var: int32 := min(i3, i6)
	<.main+?>: dup.x32 sp(16)
	<.main+?>: dup.x32 sp(16)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:33: (40 bytes): min2Xpr: int32 := min(i3 + 1, i6 + 1) - 1
	<.main+?>: dup.x32 sp(17)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(17)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:35: (34 bytes): max2Val: int32 := max(3, 6)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:36: (28 bytes): max2Var: int32 := max(i3, i6)
	<.main+?>: dup.x32 sp(19)
	<.main+?>: dup.x32 sp(19)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:37: (40 bytes): max2Xpr: int32 := max(i3 + 1, i6 + 1) - 1
	<.main+?>: dup.x32 sp(20)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(20)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:41: (21 bytes): sumRlVal: int32 := sumLr(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: load.c32 2
	<.main+?>: inc.i32(+8)
	<.main+?>: add.i32
	<.main+?>: add.i32
	cmplStd/test/lang/inlineMacros.ci:42: (17 bytes): sumLrVal: int32 := sumRl(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: inc.i32(+6)
	<.main+?>: inc.i32(+2)
	<.main+?>: inc.i32(+8)
	cmplStd/test/lang/inlineMacros.ci:43: (11 bytes): sumRlVar: int32 := sumLr(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(23)
	<.main+?>: dup.x32 sp(23)
	<.main+?>: dup.x32 sp(23)
	<.main+?>: dup.x32 sp(23)
	<.main+?>: add.i32
	<.main+?>: add.i32
	<.main+?>: add.i32
	cmplStd/test/lang/inlineMacros.ci:44: (11 bytes): sumLrVar: int32 := sumRl(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(24)
	<.main+?>: dup.x32 sp(24)
	<.main+?>: add.i32
	<.main+?>: dup.x32 sp(23)
	<.main+?>: add.i32
	<.main+?>: dup.x32 sp(22)
	<.main+?>: add.i32
	cmplStd/test/lang/inlineMacros.ci:45: (31 bytes): sumRlXpr: int32 := sumLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: add.i32
	<.main+?>: add.i32
	<.main+?>: inc.i32(-4)
	cmplStd/test/lang/inlineMacros.ci:46: (31 bytes): sumLrXpr: int32 := sumRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 4
	<.main+?>: dup.x32 sp(26)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(26)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: dup.x32 sp(25)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: dup.x32 sp(24)
	<.main+?>: inc.i32(+1)
	<.main+?>: add.i32
	<.main+?>: inc.i32(-4)
	cmplStd/test/lang/inlineMacros.ci:50: (62 bytes): anyRlVal: int32 := anyLr(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +47
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +28
	<.main+?>: load.c32 2
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 8
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:51: (62 bytes): anyLrVal: int32 := anyRl(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 6
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 2
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +9
	<.main+?>: load.c32 8
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:52: (50 bytes): anyRlVar: int32 := anyLr(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(29)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +38
	<.main+?>: dup.x32 sp(29)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +22
	<.main+?>: dup.x32 sp(29)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(29)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:53: (50 bytes): anyLrVar: int32 := anyRl(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(30)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(30)
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(29)
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(28)
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/inlineMacros.ci:54: (70 bytes): anyRlXpr: int32 := anyLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +50
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +30
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:55: (70 bytes): anyLrXpr: int32 := anyRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(32)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(32)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(31)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(0)
	<.main+?>: jmp +10
	<.main+?>: dup.x32 sp(30)
	<.main+?>: inc.i32(+1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:59: (92 bytes): minRlVal: int32 := minLr(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: load.c32 2
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:60: (92 bytes): minLrVal: int32 := minRl(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.c32 2
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:61: (80 bytes): minRlVar: int32 := minLr(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:62: (80 bytes): minLrVar: int32 := minRl(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(36)
	<.main+?>: dup.x32 sp(36)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(35)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(34)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:63: (100 bytes): minRlXpr: int32 := minLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:64: (100 bytes): minLrXpr: int32 := minRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(38)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(38)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(37)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(36)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:68: (92 bytes): maxRlVal: int32 := maxLr(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: load.c32 2
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:69: (92 bytes): maxLrVal: int32 := maxRl(3, 6, 2, 8)
	<.main+?>: load.c32 3
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.c32 2
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:70: (80 bytes): maxRlVar: int32 := maxLr(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:71: (80 bytes): maxLrVar: int32 := maxRl(i3, i6, i2, i8)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(40)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/inlineMacros.ci:72: (100 bytes): maxRlXpr: int32 := maxLr(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/inlineMacros.ci:73: (100 bytes): maxLrXpr: int32 := maxRl(i3 + 1, i6 + 1, i2 + 1, i8 + 1) - 1
	<.main+?>: dup.x32 sp(44)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(44)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(43)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: inc.i32(+1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.i32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: inc.i32(-1)
	cmplStd/test/lang/overload.inline.ci:9: (5 bytes): overload1: float32 := overload
	<.main+?>: load.f32 1.000000
	cmplStd/test/lang/overload.inline.ci:10: (5 bytes): overload2: float32 := overload()
	<.main+?>: load.f32 2.000000
	cmplStd/test/lang/overload.inline.ci:11: (5 bytes): overload3: float32 := overload(0)
	<.main+?>: load.f32 3.000000
	cmplStd/test/lang/overload.inline.ci:12: (5 bytes): overload4: float32 := overload(0.000000)
	<.main+?>: load.f32 4.000000
	cmplStd/test/lang/overload.inline.ci:13: (5 bytes): overload5: float32 := overload(0, 0)
	<.main+?>: load.f32 5.000000
	cmplStd/test/lang/overload.inline.ci:28: (9 bytes): boilC: Celsius := Celsius(100.000000)
	<.main+?>: load.f64 100.000000
	cmplStd/test/lang/overload.inline.ci:29: (22 bytes): boilF: Fahrenheit := Fahrenheit(boilC)
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.f64 1.800000
	<.main+?>: mul.f64
	<.main+?>: load.f64 32.000000
	<.main+?>: add.f64
	cmplStd/test/lang/memory.ci:7: (14 bytes): p1: pointer := malloc(1024)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.c32 1024
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/test/lang/memory.ci:8: (14 bytes): p2: pointer := malloc(80)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.c32 80
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/test/lang/memory.ci:9: (14 bytes): p3: pointer := malloc(160)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.c32 160
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/test/lang/memory.ci:10: (14 bytes): p4: pointer := malloc(820)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.c32 820
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	cmplStd/test/lang/memory.ci:13: (16 bytes): pointer.fill(p1, 0, 1024);
	<.main+?>: dup.x32 sp(3)
	<.main+?>: load.z32
	<.main+?>: load.c32 1024
	<.main+?>: nfc(14) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:14: (17 bytes): pointer.copy(p1, p3, 160);
	<.main+?>: dup.x32 sp(3)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: load.c32 160
	<.main+?>: nfc(15) ;pointer.copy(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:17: (11 bytes): free(p1);
	<.main+?>: dup.x32 sp(3)
	<.main+?>: load.z32
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:18: (11 bytes): free(p2);
	<.main+?>: dup.x32 sp(2)
	<.main+?>: load.z32
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:19: (11 bytes): free(p3);
	<.main+?>: dup.x32 sp(1)
	<.main+?>: load.z32
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:20: (11 bytes): free(p4);
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: nfc(13) ;pointer.alloc(ptr: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:23: (9 bytes): val1: int64 := 42
	<.main+?>: load.c64 42
	cmplStd/test/lang/memory.ci:24: (9 bytes): val2: int64 := 96
	<.main+?>: load.c64 96
	cmplStd/test/lang/memory.ci:26: (49 bytes): debug("val1", val1);
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.sp(+12)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/memory.ci"
	<.main+?>: load.c32 26
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"val1"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/memory.ci:27: (49 bytes): debug("val2", val2);
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/memory.ci"
	<.main+?>: load.c32 27
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"val2"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/memory.ci:29: (25 bytes): pointer.move(pointer(val2), pointer(val1), sizeof(int64));
	<.main+?>: load.sp(+0)
	<.main+?>: load.sp(+12)
	<.main+?>: load.ref <?> ;int64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: nfc(16) ;pointer.move(dst: pointer, src: pointer, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:30: (22 bytes): pointer.fill(pointer(val1), 0, sizeof(int64));
	<.main+?>: load.sp(+8)
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;int64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: nfc(14) ;pointer.fill(dst: pointer, value: uint8, size: int32): pointer
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/memory.ci:32: (49 bytes): debug("val1", val1);
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.sp(+12)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/memory.ci"
	<.main+?>: load.c32 32
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"val1"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/memory.ci:33: (49 bytes): debug("val2", val2);
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/memory.ci"
	<.main+?>: load.c32 33
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"val2"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/tryExec.ci:39: (14 bytes): tryExecErr0: int32 := tryExec(null, noError)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;noError(ptr: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:40: (14 bytes): tryExecErr1: int32 := tryExec(null, null)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;null
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:41: (14 bytes): tryExecErr2: int32 := tryExec(null, stackOverflow)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;stackOverflow(ptr: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:42: (14 bytes): tryExecErr3: int32 := tryExec(null, divisionByZero)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;divisionByZero(args: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:43: (14 bytes): tryExecErr4: int32 := tryExec(null, invalidInstruction)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;invalidInstruction(args: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:44: (14 bytes): tryExecErr5: int32 := tryExec(null, invalidMemoryAccess)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;invalidMemoryAccess(args: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/tryExec.ci:45: (14 bytes): tryExecErr6: int32 := tryExec(null, abortExecution)
	<.main+?>: load.ref <?> ;null
	<.main+?>: load.ref <?> ;abortExecution(args: pointer): void
	<.main+?>: nfc(12) ;tryExec(args: pointer, action(args: pointer): void): int32
	cmplStd/test/lang/pointer.ci:1: (39 bytes): arr: int32[5] := {...}
	<.main+?>: inc.sp(+20)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[0] := 1;
	<.main+?>: load.c32 1
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[1] := 2;
	<.main+?>: load.c32 2
	<.main+?>: set.x32 sp(2)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[2] := 3;
	<.main+?>: load.c32 3
	<.main+?>: set.x32 sp(3)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[3] := 4;
	<.main+?>: load.c32 4
	<.main+?>: set.x32 sp(4)
	cmplStd/test/lang/pointer.ci:1: (7 bytes): arr[4] := 5;
	<.main+?>: load.c32 5
	<.main+?>: set.x32 sp(5)
	cmplStd/test/lang/pointer.ci:2: (4 bytes): ptr: pointer := arr
	<.main+?>: load.sp(+0)
	cmplStd/test/lang/pointer.ci:3: (4 bytes): a0: int32 := arr[0]
	<.main+?>: load.sp(+4)
	cmplStd/test/lang/pointer.ci:4: (4 bytes): a1: int32 := arr[1]
	<.main+?>: load.sp(+12)
	cmplStd/test/lang/pointer.ci:5: (4 bytes): a2: int32 := arr[2]
	<.main+?>: load.sp(+20)
	cmplStd/test/lang/pointer.ci:6: (4 bytes): a3: int32 := arr[3]
	<.main+?>: load.sp(+28)
	cmplStd/test/lang/pointer.ci:7: (4 bytes): a4: int32 := arr[4]
	<.main+?>: load.sp(+36)
	cmplStd/test/lang/pointer.ci:9: (55 bytes): assert((ptr) == arr);
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: load.sp(+36)
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 9
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:10: (65 bytes): assert(pointer(a0) == inc(ptr, 0 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(6)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 10
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:11: (69 bytes): assert(pointer(a1) == inc(ptr, 1 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 1
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 11
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:12: (69 bytes): assert(pointer(a2) == inc(ptr, 2 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 12
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:13: (69 bytes): assert(pointer(a3) == inc(ptr, 3 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 13
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/pointer.ci:14: (69 bytes): assert(pointer(a4) == inc(ptr, 4 * sizeof(int32)));
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 4
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	<.main+?>: mul.i32
	<.main+?>: add.i32
	<.main+?>: ceq.i32
	<.main+?>: jz +8
	<.main+?>: jmp +35
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/pointer.ci"
	<.main+?>: load.c32 14
	<.main+?>: load.c32 -2
	<.main+?>: load.c32 128
	<.main+?>: load.ref <?> ;"assertion failed!"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/init.reference.ci:8: (5 bytes): valueRef: int64 := value
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:9: (5 bytes): valuePtr: pointer := value
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:10: (10 bytes): valueVar: variant := value
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:12: (3 bytes): fromRef: int64 := valueRef
	<.main+?>: dup.x32 sp(3)
	<.main+?>: load.i64
	cmplStd/test/lang/init.reference.ci:13: (2 bytes): fromPtr: int64 := valuePtr
	<.main+?>: dup.x32 sp(4)
	cmplStd/test/lang/init.reference.ci:14: (2 bytes): fromVar: int64 := valueVar
	<.main+?>: dup.x32 sp(3)
	cmplStd/test/lang/init.reference.ci:16: (5 bytes): nullRef: int64 := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:17: (5 bytes): nullPtr: pointer := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:18: (10 bytes): nullVar: variant := null
	<.main+?>: load.ref <?> ;pointer
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:19: (5 bytes): nullTyp: typename := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:20: (5 bytes): nullFun: function := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:21: (5 bytes): nullObj: object := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/init.reference.ci:23: (5 bytes): typePtr: pointer := int64
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:24: (10 bytes): typeVar: variant := int64
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:25: (5 bytes): typeTyp: typename := int64
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:27: (4 bytes): local: int64 := value
	<.main+?>: load.m64 <?> ;value
	cmplStd/test/lang/init.reference.ci:28: (2 bytes): copyVal: int64 := local
	<.main+?>: dup.x64 sp(0)
	cmplStd/test/lang/init.reference.ci:29: (2 bytes): copyRef: int64 := valueRef
	<.main+?>: dup.x32 sp(22)
	cmplStd/test/lang/init.reference.ci:30: (2 bytes): copyPtr: pointer := valuePtr
	<.main+?>: dup.x32 sp(22)
	cmplStd/test/lang/init.reference.ci:31: (2 bytes): copyVar: variant := valueVar
	<.main+?>: dup.x64 sp(21)
	cmplStd/test/lang/init.reference.ci:32: (2 bytes): copyTyp: typename := typeTyp
	<.main+?>: dup.x32 sp(8)
	cmplStd/test/lang/init.reference.ci:35: (5 bytes): ptrVoid: pointer := void
	<.main+?>: load.ref <?> ;void
	cmplStd/test/lang/init.reference.ci:36: (5 bytes): ptrBool: pointer := bool
	<.main+?>: load.ref <?> ;bool
	cmplStd/test/lang/init.reference.ci:37: (5 bytes): ptrChar: pointer := char
	<.main+?>: load.ref <?> ;char
	cmplStd/test/lang/init.reference.ci:38: (5 bytes): ptrInt8: pointer := int8
	<.main+?>: load.ref <?> ;int8
	cmplStd/test/lang/init.reference.ci:39: (5 bytes): ptrInt16: pointer := int16
	<.main+?>: load.ref <?> ;int16
	cmplStd/test/lang/init.reference.ci:40: (5 bytes): ptrInt32: pointer := int32
	<.main+?>: load.ref <?> ;int32
	cmplStd/test/lang/init.reference.ci:41: (5 bytes): ptrInt64: pointer := int64
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:42: (5 bytes): ptrUint8: pointer := uint8
	<.main+?>: load.ref <?> ;uint8
	cmplStd/test/lang/init.reference.ci:43: (5 bytes): ptrUint16: pointer := uint16
	<.main+?>: load.ref <?> ;uint16
	cmplStd/test/lang/init.reference.ci:44: (5 bytes): ptrUint32: pointer := uint32
	<.main+?>: load.ref <?> ;uint32
	cmplStd/test/lang/init.reference.ci:45: (5 bytes): ptrUint64: pointer := uint64
	<.main+?>: load.ref <?> ;uint64
	cmplStd/test/lang/init.reference.ci:46: (5 bytes): ptrFloat32: pointer := float32
	<.main+?>: load.ref <?> ;float32
	cmplStd/test/lang/init.reference.ci:47: (5 bytes): ptrFloat64: pointer := float64
	<.main+?>: load.ref <?> ;float64
	cmplStd/test/lang/init.reference.ci:48: (5 bytes): ptrTypename: pointer := typename
	<.main+?>: load.ref <?> ;typename
	cmplStd/test/lang/init.reference.ci:49: (5 bytes): ptrFunction: pointer := function
	<.main+?>: load.ref <?> ;function
	cmplStd/test/lang/init.reference.ci:50: (5 bytes): ptrPointer: pointer := pointer
	<.main+?>: load.ref <?> ;pointer
	cmplStd/test/lang/init.reference.ci:51: (5 bytes): ptrVariant: pointer := variant
	<.main+?>: load.ref <?> ;variant
	cmplStd/test/lang/init.reference.ci:52: (5 bytes): ptrObject: pointer := object
	<.main+?>: load.ref <?> ;object
	cmplStd/test/lang/init.reference.ci:55: (10 bytes): varVoid: variant := void
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;void
	cmplStd/test/lang/init.reference.ci:56: (10 bytes): varBool: variant := bool
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;bool
	cmplStd/test/lang/init.reference.ci:57: (10 bytes): varChar: variant := char
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;char
	cmplStd/test/lang/init.reference.ci:58: (10 bytes): varInt8: variant := int8
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int8
	cmplStd/test/lang/init.reference.ci:59: (10 bytes): varInt16: variant := int16
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int16
	cmplStd/test/lang/init.reference.ci:60: (10 bytes): varInt32: variant := int32
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int32
	cmplStd/test/lang/init.reference.ci:61: (10 bytes): varInt64: variant := int64
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:62: (10 bytes): varUint8: variant := uint8
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;uint8
	cmplStd/test/lang/init.reference.ci:63: (10 bytes): varUint16: variant := uint16
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;uint16
	cmplStd/test/lang/init.reference.ci:64: (10 bytes): varUint32: variant := uint32
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;uint32
	cmplStd/test/lang/init.reference.ci:65: (10 bytes): varUint64: variant := uint64
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;uint64
	cmplStd/test/lang/init.reference.ci:66: (10 bytes): varFloat32: variant := float32
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;float32
	cmplStd/test/lang/init.reference.ci:67: (10 bytes): varFloat64: variant := float64
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;float64
	cmplStd/test/lang/init.reference.ci:68: (10 bytes): varTypename: variant := typename
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;typename
	cmplStd/test/lang/init.reference.ci:69: (10 bytes): varFunction: variant := function
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;function
	cmplStd/test/lang/init.reference.ci:70: (10 bytes): varPointer: variant := pointer
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;pointer
	cmplStd/test/lang/init.reference.ci:71: (10 bytes): varVariant: variant := variant
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;variant
	cmplStd/test/lang/init.reference.ci:72: (10 bytes): varObject: variant := object
	<.main+?>: load.ref <?> ;typename
	<.main+?>: load.ref <?> ;object
	cmplStd/test/lang/init.reference.ci:75: (5 bytes): typVoid: typename := void
	<.main+?>: load.ref <?> ;void
	cmplStd/test/lang/init.reference.ci:76: (5 bytes): typBool: typename := bool
	<.main+?>: load.ref <?> ;bool
	cmplStd/test/lang/init.reference.ci:77: (5 bytes): typChar: typename := char
	<.main+?>: load.ref <?> ;char
	cmplStd/test/lang/init.reference.ci:78: (5 bytes): typInt8: typename := int8
	<.main+?>: load.ref <?> ;int8
	cmplStd/test/lang/init.reference.ci:79: (5 bytes): typInt16: typename := int16
	<.main+?>: load.ref <?> ;int16
	cmplStd/test/lang/init.reference.ci:80: (5 bytes): typInt32: typename := int32
	<.main+?>: load.ref <?> ;int32
	cmplStd/test/lang/init.reference.ci:81: (5 bytes): typInt64: typename := int64
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:82: (5 bytes): typUint8: typename := uint8
	<.main+?>: load.ref <?> ;uint8
	cmplStd/test/lang/init.reference.ci:83: (5 bytes): typUint16: typename := uint16
	<.main+?>: load.ref <?> ;uint16
	cmplStd/test/lang/init.reference.ci:84: (5 bytes): typUint32: typename := uint32
	<.main+?>: load.ref <?> ;uint32
	cmplStd/test/lang/init.reference.ci:85: (5 bytes): typUint64: typename := uint64
	<.main+?>: load.ref <?> ;uint64
	cmplStd/test/lang/init.reference.ci:86: (5 bytes): typFloat32: typename := float32
	<.main+?>: load.ref <?> ;float32
	cmplStd/test/lang/init.reference.ci:87: (5 bytes): typFloat64: typename := float64
	<.main+?>: load.ref <?> ;float64
	cmplStd/test/lang/init.reference.ci:88: (5 bytes): typTypename: typename := typename
	<.main+?>: load.ref <?> ;typename
	cmplStd/test/lang/init.reference.ci:89: (5 bytes): typFunction: typename := function
	<.main+?>: load.ref <?> ;function
	cmplStd/test/lang/init.reference.ci:90: (5 bytes): typPointer: typename := pointer
	<.main+?>: load.ref <?> ;pointer
	cmplStd/test/lang/init.reference.ci:91: (5 bytes): typVariant: typename := variant
	<.main+?>: load.ref <?> ;variant
	cmplStd/test/lang/init.reference.ci:92: (5 bytes): typObject: typename := object
	<.main+?>: load.ref <?> ;object
	cmplStd/test/lang/init.reference.ci:95: (5 bytes): valueOfPtr: pointer := pointer(value)
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:96: (10 bytes): valueOfVar: variant := variant(value)
	<.main+?>: load.ref <?> ;int64
	<.main+?>: load.ref <?> ;value
	cmplStd/test/lang/init.reference.ci:97: (5 bytes): valueOfTyp: typename := typename(value)
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:99: (5 bytes): typeOfValue: typename := typename(value)
	<.main+?>: load.ref <?> ;int64
	cmplStd/test/lang/init.reference.ci:105: (7 bytes): copyPtrFloat64: variant := ptrFloat64
	<.main+?>: load.ref <?> ;pointer
	<.main+?>: dup.x32 sp(65)
	cmplStd/test/lang/init.reference.ci:108: (2 bytes): copyVarFloat64: pointer := varFloat64
	<.main+?>: dup.x32 sp(35)
	cmplStd/test/lang/init.variable.ci:3: (1 byte): variable: int32
	<.main+?>: load.z32
	cmplStd/test/lang/init.variable.ci:7: (5 bytes): const constant: int32 := 42
	<.main+?>: load.c32 42
	cmplStd/test/lang/init.variable.ci:24: (18 bytes): valInitImplicit: ComplexVal := {...}
	<.main+?>: inc.sp(+16)
	cmplStd/test/lang/init.variable.ci:24: (11 bytes): valInitImplicit.re := (8);
	<.main+?>: load.f64 8.000000
	<.main+?>: set.x64 sp(2)
	:: (3 bytes): valInitImplicit.im := (0);
	<.main+?>: load.z64
	<.main+?>: set.x64 sp(4)
	cmplStd/test/lang/init.variable.ci:33: (39 bytes): objInitImplicit: ComplexObj := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/init.variable.ci:33: (11 bytes): objInitImplicit := create(ComplexObj);
	<.main+?>: load.ref <?> ;ComplexObj
	<.main+?>: nfc(7) ;object.create(type: typename): pointer
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/init.variable.ci:33: (16 bytes): objInitImplicit.re := (8);
	<.main+?>: load.f64 8.000000
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+4)
	<.main+?>: store.i64
	:: (8 bytes): objInitImplicit.im := (0);
	<.main+?>: load.z64
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+12)
	<.main+?>: store.i64
	cmplStd/test/lang/init.variable.ci:41: (39 bytes): objInitExplicit: object := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/init.variable.ci:41: (11 bytes): objInitExplicit := create(ComplexObj);
	<.main+?>: load.ref <?> ;ComplexObj
	<.main+?>: nfc(7) ;object.create(type: typename): pointer
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/init.variable.ci:41: (16 bytes): objInitExplicit.re := (8);
	<.main+?>: load.f64 8.000000
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+4)
	<.main+?>: store.i64
	:: (8 bytes): objInitExplicit.im := (0);
	<.main+?>: load.z64
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+12)
	<.main+?>: store.i64
	cmplStd/test/lang/function.ci:12: (21 bytes): funAddResult: int32 := funAdd(2, 7)
	<.main+?>: load.z32
	<.main+?>: load.c32 2
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;funAdd(x: int32, y: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/function.ci:15: (5 bytes): funAddRef(x: int32, y: int32): int32 := funAdd
	<.main+?>: load.ref <?> ;funAdd(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:18: (18 bytes): funAddRefResult: int32 := funAddRef(2, 8)
	<.main+?>: load.z32
	<.main+?>: load.c32 2
	<.main+?>: load.c32 8
	<.main+?>: dup.x32 sp(3)
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/function.ci:21: (5 bytes): funMul(x: int32, y: int32): int32 := funMul
	<.main+?>: load.ref <?> ;funMul(x: int32, y: int32): int32
	cmplStd/test/lang/function.ci:24: (18 bytes): funMulResult: int32 := funMul(2, 6)
	<.main+?>: load.z32
	<.main+?>: load.c32 2
	<.main+?>: load.c32 6
	<.main+?>: dup.x32 sp(3)
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/function.ci:27: (2 bytes): funMulRef(x: int32, y: int32): int32 := funMul
	<.main+?>: dup.x32 sp(1)
	cmplStd/test/lang/function.ci:30: (18 bytes): funMulRefResult: int32 := funMulRef(2, 7)
	<.main+?>: load.z32
	<.main+?>: load.c32 2
	<.main+?>: load.c32 7
	<.main+?>: dup.x32 sp(3)
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/function.ci:46: (16 bytes): fibonacci_13: uint32 := fib(13)
	<.main+?>: load.z32
	<.main+?>: load.c32 13
	<.main+?>: load.ref <?> ;fib(n: uint32): uint32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/reflect.ci:3: (9 bytes): sizeofVoid: int32 := sizeof(void)
	<.main+?>: load.ref <?> ;void
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:4: (9 bytes): sizeofBool: int32 := sizeof(bool)
	<.main+?>: load.ref <?> ;bool
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:5: (9 bytes): sizeofChar: int32 := sizeof(char)
	<.main+?>: load.ref <?> ;char
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:6: (9 bytes): sizeofInt8: int32 := sizeof(int8)
	<.main+?>: load.ref <?> ;int8
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:7: (9 bytes): sizeofInt16: int32 := sizeof(int16)
	<.main+?>: load.ref <?> ;int16
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:8: (9 bytes): sizeofInt32: int32 := sizeof(int32)
	<.main+?>: load.ref <?> ;int32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:9: (9 bytes): sizeofInt64: int32 := sizeof(int64)
	<.main+?>: load.ref <?> ;int64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:10: (9 bytes): sizeofUint8: int32 := sizeof(uint8)
	<.main+?>: load.ref <?> ;uint8
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:11: (9 bytes): sizeofUint16: int32 := sizeof(uint16)
	<.main+?>: load.ref <?> ;uint16
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:12: (9 bytes): sizeofUint32: int32 := sizeof(uint32)
	<.main+?>: load.ref <?> ;uint32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:13: (9 bytes): sizeofUint64: int32 := sizeof(uint64)
	<.main+?>: load.ref <?> ;uint64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:14: (9 bytes): sizeofFloat32: int32 := sizeof(float32)
	<.main+?>: load.ref <?> ;float32
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:15: (9 bytes): sizeofFloat64: int32 := sizeof(float64)
	<.main+?>: load.ref <?> ;float64
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:16: (9 bytes): sizeofPointer: int32 := sizeof(pointer)
	<.main+?>: load.ref <?> ;pointer
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:17: (9 bytes): sizeofVariant: int32 := sizeof(variant)
	<.main+?>: load.ref <?> ;variant
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:18: (9 bytes): sizeofTypename: int32 := sizeof(typename)
	<.main+?>: load.ref <?> ;typename
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:19: (9 bytes): sizeofFunction: int32 := sizeof(function)
	<.main+?>: load.ref <?> ;function
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:20: (9 bytes): sizeofObject: int32 := sizeof(object)
	<.main+?>: load.ref <?> ;object
	<.main+?>: nfc(6) ;typename.size(type: typename): int32
	cmplStd/test/lang/reflect.ci:30: (5 bytes): typeofRecord: typename := RecordSizeofExt
	<.main+?>: load.ref <?> ;RecordSizeofExt
	cmplStd/test/lang/reflect.ci:31: (6 bytes): nameOfRecord: char[*] := typename.name(typeofRecord)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: nfc(5) ;typename.name(type: typename): .cstr
	cmplStd/test/lang/reflect.ci:32: (7 bytes): offsetOfRecord: int32 := typeofRecord.offset
	<.main+?>: dup.x32 sp(1)
	<.main+?>: inc.i32(+56)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:33: (7 bytes): sizeOfRecord: int32 := typeofRecord.size
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+48)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:34: (6 bytes): fileOfRecord: char[*] := typename.file(typeofRecord)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: nfc(3) ;typename.file(type: typename): .cstr
	cmplStd/test/lang/reflect.ci:35: (6 bytes): lineOfRecord: int32 := typename.line(typeofRecord)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: nfc(4) ;typename.line(type: typename): int32
	cmplStd/test/lang/reflect.ci:37: (6 bytes): typeofBase: typename := typename.base(typeofRecord)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: nfc(2) ;typename.base(type: typename): typename
	cmplStd/test/lang/reflect.ci:38: (6 bytes): nameOfBase: char[*] := typename.name(typeofBase)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: nfc(5) ;typename.name(type: typename): .cstr
	cmplStd/test/lang/reflect.ci:39: (7 bytes): offsetOfBase: int32 := typeofBase.offset
	<.main+?>: dup.x32 sp(1)
	<.main+?>: inc.i32(+56)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:40: (7 bytes): sizeOfBase: int32 := typeofBase.size
	<.main+?>: dup.x32 sp(2)
	<.main+?>: inc.i32(+48)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:41: (6 bytes): fileOfBase: char[*] := typename.file(typeofBase)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: nfc(3) ;typename.file(type: typename): .cstr
	cmplStd/test/lang/reflect.ci:42: (6 bytes): lineOfBase: int32 := typename.line(typeofBase)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: nfc(4) ;typename.line(type: typename): int32
	cmplStd/test/lang/reflect.ci:44: (6 bytes): typeofBase1: typename := typename.base(typeofBase)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: nfc(2) ;typename.base(type: typename): typename
	cmplStd/test/lang/reflect.ci:45: (7 bytes): offsetOfBase1: int32 := typeofBase1.offset
	<.main+?>: dup.x32 sp(0)
	<.main+?>: inc.i32(+56)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:46: (7 bytes): sizeOfBase1: int32 := typeofBase1.size
	<.main+?>: dup.x32 sp(1)
	<.main+?>: inc.i32(+48)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:48: (6 bytes): typeofBase2: typename := typename.base(typeofBase1)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: nfc(2) ;typename.base(type: typename): typename
	cmplStd/test/lang/reflect.ci:49: (7 bytes): offsetOfBase2: int32 := typeofBase2.offset
	<.main+?>: dup.x32 sp(0)
	<.main+?>: inc.i32(+56)
	<.main+?>: load.i32
	cmplStd/test/lang/reflect.ci:50: (7 bytes): sizeOfBase2: int32 := typeofBase2.size
	<.main+?>: dup.x32 sp(1)
	<.main+?>: inc.i32(+48)
	<.main+?>: load.i32
	cmplStd/test/lang/init.member.ci:52: (60 bytes): recordMemberTest: RecordMemberTest := {...}
	<.main+?>: inc.sp(+32)
	cmplStd/test/lang/init.member.ci:53: (7 bytes): recordMemberTest.member := 10;
	<.main+?>: load.c32 10
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/init.member.ci:54: (7 bytes): recordMemberTest.constant := 11;
	<.main+?>: load.c32 11
	<.main+?>: set.x32 sp(2)
	cmplStd/test/lang/init.member.ci:55: (7 bytes): recordMemberTest.memberInit := 12;
	<.main+?>: load.c32 12
	<.main+?>: set.x32 sp(3)
	cmplStd/test/lang/init.member.ci:56: (7 bytes): recordMemberTest.constantInit := 13;
	<.main+?>: load.c32 13
	<.main+?>: set.x32 sp(4)
	cmplStd/test/lang/init.member.ci:59: (7 bytes): recordMemberTest.memberRec.member := 14;
	<.main+?>: load.c32 14
	<.main+?>: set.x32 sp(5)
	cmplStd/test/lang/init.member.ci:60: (7 bytes): recordMemberTest.memberRec.constant := 15;
	<.main+?>: load.c32 15
	<.main+?>: set.x32 sp(6)
	cmplStd/test/lang/init.member.ci:64: (7 bytes): recordMemberTest.constantRec.member := 16;
	<.main+?>: load.c32 16
	<.main+?>: set.x32 sp(7)
	cmplStd/test/lang/init.member.ci:65: (7 bytes): recordMemberTest.constantRec.constant := 17;
	<.main+?>: load.c32 17
	<.main+?>: set.x32 sp(8)
	cmplStd/test/lang/init.method.ci:62: (24 bytes): recordMethodTest: RecordMethodTest := {...}
	<.main+?>: inc.sp(+16)
	cmplStd/test/lang/init.method.ci:64: (7 bytes): recordMethodTest.abstractMethod := globalFunction;
	<.main+?>: load.ref <?> ;globalFunction(this: RecordMethodTest, x: int32): void
	<.main+?>: set.x32 sp(1)
	:: (6 bytes): recordMethodTest.delegateMethod := forwardMethod;
	<.main+?>: load.m32 <?> ;RecordMethodTest.forwardMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: set.x32 sp(2)
	:: (7 bytes): recordMethodTest.virtualMethod := virtualMethod;
	<.main+?>: load.ref <?> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: set.x32 sp(3)
	cmplStd/test/lang/init.method.ci:78: (17 bytes): RecordMethodTest.staticMethod(recordMethodTest, 1);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 1
	<.main+?>: load.ref <?> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:79: (14 bytes): recordMethodTest.virtualMethod(recordMethodTest, 1);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 1
	<.main+?>: dup.x32 sp(7)
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:97: (17 bytes): staticMethod(recordMethodTest, 2);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;staticMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:98: (17 bytes): virtualMethod(recordMethodTest, 2);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: load.ref <?> ;virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:101: (17 bytes): RecordMethodTest.staticMethod(recordMethodTest, 3);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;RecordMethodTest.staticMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:102: (17 bytes): RecordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;RecordMethodTest.virtualMethod(this: RecordMethodTest, x: int32): void
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/init.method.ci:103: (14 bytes): recordMethodTest.virtualMethod(recordMethodTest, 3);
	<.main+?>: dup.x128 sp(0)
	<.main+?>: load.c32 3
	<.main+?>: dup.x32 sp(7)
	<.main+?>: call
	<.main+?>: inc.sp(-20)
	cmplStd/test/lang/recUnion.ci:26: (22 bytes): black: rgbU8 := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:26: (6 bytes): black.r := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+6)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:26: (6 bytes): black.g := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+5)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:26: (6 bytes): black.b := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:27: (26 bytes): green: rgbU8 := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:27: (6 bytes): green.r := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+6)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:27: (10 bytes): green.g := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+5)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:27: (6 bytes): green.b := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:28: (34 bytes): white: rgbU8 := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:28: (10 bytes): white.r := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+6)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:28: (10 bytes): white.g := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+5)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:28: (10 bytes): white.b := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+4)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:30: (11 bytes): cyan: color := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:30: (7 bytes): cyan.col := (65535);
	<.main+?>: load.c32 65535
	<.main+?>: set.x32 sp(1)
	cmplStd/test/lang/recUnion.ci:31: (26 bytes): blue: color := {...}
	<.main+?>: inc.sp(+4)
	cmplStd/test/lang/recUnion.ci:31: (6 bytes): blue.rgb.r := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+6)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:31: (6 bytes): blue.rgb.g := (0);
	<.main+?>: load.z32
	<.main+?>: load.sp(+5)
	<.main+?>: store.i8
	cmplStd/test/lang/recUnion.ci:31: (10 bytes): blue.rgb.b := (255);
	<.main+?>: load.c32 255
	<.main+?>: load.sp(+4)
	<.main+?>: store.i8
	cmplStd/test/lang/useOperator.ci:5: (5 bytes): shift: int32 := 2
	<.main+?>: load.c32 2
	cmplStd/test/lang/useOperator.ci:7: (5 bytes): boolA: bool := true
	<.main+?>: load.c32 1
	cmplStd/test/lang/useOperator.ci:8: (5 bytes): boolB: bool := !false
	<.main+?>: load.c32 1
	cmplStd/test/lang/useOperator.ci:17: (11 bytes): boolAnd: bool := boolA & boolB
	<.main+?>: load.sp(+4)
	<.main+?>: load.is8
	<.main+?>: load.sp(+4)
	<.main+?>: load.is8
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:18: (11 bytes): boolIor: bool := boolA | boolB
	<.main+?>: load.sp(+8)
	<.main+?>: load.is8
	<.main+?>: load.sp(+8)
	<.main+?>: load.is8
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:19: (11 bytes): boolXor: bool := boolA ^ boolB
	<.main+?>: load.sp(+12)
	<.main+?>: load.is8
	<.main+?>: load.sp(+12)
	<.main+?>: load.is8
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:22: (6 bytes): boolNot: bool := !boolB
	<.main+?>: load.sp(+12)
	<.main+?>: load.is8
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:23: (11 bytes): boolCeq: bool := boolA == boolB
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:24: (12 bytes): boolCne: bool := boolA != boolB
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:25: (11 bytes): boolClt: bool := boolA < boolB
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:26: (12 bytes): boolCle: bool := boolA <= boolB
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:27: (11 bytes): boolCgt: bool := boolA > boolB
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:28: (12 bytes): boolCge: bool := boolA >= boolB
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:30: (5 bytes): chrA: char := 'a'
	<.main+?>: load.c32 97
	cmplStd/test/lang/useOperator.ci:31: (5 bytes): chrB: char := 'b'
	<.main+?>: load.c32 98
	cmplStd/test/lang/useOperator.ci:32: (5 bytes): chrPls: char := +chrB
	<.main+?>: load.sp(+0)
	<.main+?>: load.is8
	cmplStd/test/lang/useOperator.ci:33: (6 bytes): chrNeg: char := -chrB
	<.main+?>: load.sp(+4)
	<.main+?>: load.is8
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:34: (6 bytes): chrCmt: char := ~chrB
	<.main+?>: load.sp(+8)
	<.main+?>: load.is8
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:35: (11 bytes): chrAdd: char := chrA + chrB
	<.main+?>: load.sp(+16)
	<.main+?>: load.is8
	<.main+?>: load.sp(+16)
	<.main+?>: load.is8
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:36: (11 bytes): chrSub: char := chrA - chrB
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:37: (11 bytes): chrMul: char := chrA * chrB
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: mul.i32
	cmplStd/test/lang/useOperator.ci:38: (11 bytes): chrDiv: char := chrA / chrB
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: div.i32
	cmplStd/test/lang/useOperator.ci:39: (11 bytes): chrMod: char := chrA % chrB
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: mod.i32
	cmplStd/test/lang/useOperator.ci:40: (11 bytes): chrAnd: char := chrA & chrB
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:41: (11 bytes): chrIor: char := chrA | chrB
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:42: (11 bytes): chrXor: char := chrA ^ chrB
	<.main+?>: load.sp(+44)
	<.main+?>: load.is8
	<.main+?>: load.sp(+44)
	<.main+?>: load.is8
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:43: (8 bytes): chrShl: char := (chrA) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.is8
	<.main+?>: dup.x32 sp(26)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:44: (8 bytes): chrShr: char := (chrA) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.is8
	<.main+?>: dup.x32 sp(27)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:45: (7 bytes): chrNot: bool := !(chrB)
	<.main+?>: load.sp(+52)
	<.main+?>: load.is8
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:46: (11 bytes): chrCeq: bool := chrA == chrB
	<.main+?>: load.sp(+60)
	<.main+?>: load.is8
	<.main+?>: load.sp(+60)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:47: (12 bytes): chrCne: bool := chrA != chrB
	<.main+?>: load.sp(+64)
	<.main+?>: load.is8
	<.main+?>: load.sp(+64)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:48: (11 bytes): chrClt: bool := chrA < chrB
	<.main+?>: load.sp(+68)
	<.main+?>: load.is8
	<.main+?>: load.sp(+68)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:49: (12 bytes): chrCle: bool := chrA <= chrB
	<.main+?>: load.sp(+72)
	<.main+?>: load.is8
	<.main+?>: load.sp(+72)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:50: (11 bytes): chrCgt: bool := chrA > chrB
	<.main+?>: load.sp(+76)
	<.main+?>: load.is8
	<.main+?>: load.sp(+76)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:51: (12 bytes): chrCge: bool := chrA >= chrB
	<.main+?>: load.sp(+80)
	<.main+?>: load.is8
	<.main+?>: load.sp(+80)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:53: (5 bytes): i8A: int8 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:54: (5 bytes): i8B: int8 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:55: (5 bytes): i8Pls: int8 := +i8B
	<.main+?>: load.sp(+0)
	<.main+?>: load.is8
	cmplStd/test/lang/useOperator.ci:56: (6 bytes): i8Neg: int8 := -i8B
	<.main+?>: load.sp(+4)
	<.main+?>: load.is8
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:57: (6 bytes): i8Cmt: int8 := ~i8B
	<.main+?>: load.sp(+8)
	<.main+?>: load.is8
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:58: (11 bytes): i8Add: int8 := i8A + i8B
	<.main+?>: load.sp(+16)
	<.main+?>: load.is8
	<.main+?>: load.sp(+16)
	<.main+?>: load.is8
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:59: (11 bytes): i8Sub: int8 := i8A - i8B
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: load.sp(+20)
	<.main+?>: load.is8
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:60: (11 bytes): i8Mul: int8 := i8A * i8B
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: load.sp(+24)
	<.main+?>: load.is8
	<.main+?>: mul.i32
	cmplStd/test/lang/useOperator.ci:61: (11 bytes): i8Div: int8 := i8A / i8B
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: load.sp(+28)
	<.main+?>: load.is8
	<.main+?>: div.i32
	cmplStd/test/lang/useOperator.ci:62: (11 bytes): i8Mod: int8 := i8A % i8B
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: load.sp(+32)
	<.main+?>: load.is8
	<.main+?>: mod.i32
	cmplStd/test/lang/useOperator.ci:63: (11 bytes): i8And: int8 := i8A & i8B
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: load.sp(+36)
	<.main+?>: load.is8
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:64: (11 bytes): i8Ior: int8 := i8A | i8B
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: load.sp(+40)
	<.main+?>: load.is8
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:65: (11 bytes): i8Xor: int8 := i8A ^ i8B
	<.main+?>: load.sp(+44)
	<.main+?>: load.is8
	<.main+?>: load.sp(+44)
	<.main+?>: load.is8
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:66: (8 bytes): i8Shl: int8 := (i8A) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.is8
	<.main+?>: dup.x32 sp(48)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:67: (8 bytes): i8Shr: int8 := (i8A) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.is8
	<.main+?>: dup.x32 sp(49)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:68: (7 bytes): i8Not: bool := !(i8B)
	<.main+?>: load.sp(+52)
	<.main+?>: load.is8
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:69: (11 bytes): i8Ceq: bool := i8A == i8B
	<.main+?>: load.sp(+60)
	<.main+?>: load.is8
	<.main+?>: load.sp(+60)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:70: (12 bytes): i8Cne: bool := i8A != i8B
	<.main+?>: load.sp(+64)
	<.main+?>: load.is8
	<.main+?>: load.sp(+64)
	<.main+?>: load.is8
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:71: (11 bytes): i8Clt: bool := i8A < i8B
	<.main+?>: load.sp(+68)
	<.main+?>: load.is8
	<.main+?>: load.sp(+68)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:72: (12 bytes): i8Cle: bool := i8A <= i8B
	<.main+?>: load.sp(+72)
	<.main+?>: load.is8
	<.main+?>: load.sp(+72)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:73: (11 bytes): i8Cgt: bool := i8A > i8B
	<.main+?>: load.sp(+76)
	<.main+?>: load.is8
	<.main+?>: load.sp(+76)
	<.main+?>: load.is8
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:74: (12 bytes): i8Cge: bool := i8A >= i8B
	<.main+?>: load.sp(+80)
	<.main+?>: load.is8
	<.main+?>: load.sp(+80)
	<.main+?>: load.is8
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:76: (5 bytes): u8A: uint8 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:77: (5 bytes): u8B: uint8 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:78: (5 bytes): u8Pls: uint8 := +u8B
	<.main+?>: load.sp(+0)
	<.main+?>: load.iu8
	cmplStd/test/lang/useOperator.ci:79: (6 bytes): u8Neg: uint8 := -u8B
	<.main+?>: load.sp(+4)
	<.main+?>: load.iu8
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:80: (6 bytes): u8Cmt: uint8 := ~u8B
	<.main+?>: load.sp(+8)
	<.main+?>: load.iu8
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:81: (11 bytes): u8Add: uint8 := u8A + u8B
	<.main+?>: load.sp(+16)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+16)
	<.main+?>: load.iu8
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:82: (11 bytes): u8Sub: uint8 := u8A - u8B
	<.main+?>: load.sp(+20)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+20)
	<.main+?>: load.iu8
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:83: (11 bytes): u8Mul: uint8 := u8A * u8B
	<.main+?>: load.sp(+24)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+24)
	<.main+?>: load.iu8
	<.main+?>: mul.u32
	cmplStd/test/lang/useOperator.ci:84: (11 bytes): u8Div: uint8 := u8A / u8B
	<.main+?>: load.sp(+28)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+28)
	<.main+?>: load.iu8
	<.main+?>: div.u32
	cmplStd/test/lang/useOperator.ci:85: (11 bytes): u8Mod: uint8 := u8A % u8B
	<.main+?>: load.sp(+32)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+32)
	<.main+?>: load.iu8
	<.main+?>: mod.u32
	cmplStd/test/lang/useOperator.ci:86: (11 bytes): u8And: uint8 := u8A & u8B
	<.main+?>: load.sp(+36)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+36)
	<.main+?>: load.iu8
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:87: (11 bytes): u8Ior: uint8 := u8A | u8B
	<.main+?>: load.sp(+40)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+40)
	<.main+?>: load.iu8
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:88: (11 bytes): u8Xor: uint8 := u8A ^ u8B
	<.main+?>: load.sp(+44)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+44)
	<.main+?>: load.iu8
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:89: (8 bytes): u8Shl: uint8 := (u8A) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.iu8
	<.main+?>: dup.x32 sp(70)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:90: (8 bytes): u8Shr: uint8 := (u8A) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.iu8
	<.main+?>: dup.x32 sp(71)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:91: (7 bytes): u8Not: bool := !(u8B)
	<.main+?>: load.sp(+52)
	<.main+?>: load.iu8
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:92: (11 bytes): u8Ceq: bool := u8A == u8B
	<.main+?>: load.sp(+60)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+60)
	<.main+?>: load.iu8
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:93: (12 bytes): u8Cne: bool := u8A != u8B
	<.main+?>: load.sp(+64)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+64)
	<.main+?>: load.iu8
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:94: (11 bytes): u8Clt: bool := u8A < u8B
	<.main+?>: load.sp(+68)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+68)
	<.main+?>: load.iu8
	<.main+?>: clt.u32
	cmplStd/test/lang/useOperator.ci:95: (12 bytes): u8Cle: bool := u8A <= u8B
	<.main+?>: load.sp(+72)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+72)
	<.main+?>: load.iu8
	<.main+?>: cgt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:96: (11 bytes): u8Cgt: bool := u8A > u8B
	<.main+?>: load.sp(+76)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+76)
	<.main+?>: load.iu8
	<.main+?>: cgt.u32
	cmplStd/test/lang/useOperator.ci:97: (12 bytes): u8Cge: bool := u8A >= u8B
	<.main+?>: load.sp(+80)
	<.main+?>: load.iu8
	<.main+?>: load.sp(+80)
	<.main+?>: load.iu8
	<.main+?>: clt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:99: (5 bytes): i16A: int16 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:100: (5 bytes): i16B: int16 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:101: (5 bytes): i16Pls: int16 := +i16B
	<.main+?>: load.sp(+0)
	<.main+?>: load.is16
	cmplStd/test/lang/useOperator.ci:102: (6 bytes): i16Neg: int16 := -i16B
	<.main+?>: load.sp(+4)
	<.main+?>: load.is16
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:103: (6 bytes): i16Cmt: int16 := ~i16B
	<.main+?>: load.sp(+8)
	<.main+?>: load.is16
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:104: (11 bytes): i16Add: int16 := i16A + i16B
	<.main+?>: load.sp(+16)
	<.main+?>: load.is16
	<.main+?>: load.sp(+16)
	<.main+?>: load.is16
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:105: (11 bytes): i16Sub: int16 := i16A - i16B
	<.main+?>: load.sp(+20)
	<.main+?>: load.is16
	<.main+?>: load.sp(+20)
	<.main+?>: load.is16
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:106: (11 bytes): i16Mul: int16 := i16A * i16B
	<.main+?>: load.sp(+24)
	<.main+?>: load.is16
	<.main+?>: load.sp(+24)
	<.main+?>: load.is16
	<.main+?>: mul.i32
	cmplStd/test/lang/useOperator.ci:107: (11 bytes): i16Div: int16 := i16A / i16B
	<.main+?>: load.sp(+28)
	<.main+?>: load.is16
	<.main+?>: load.sp(+28)
	<.main+?>: load.is16
	<.main+?>: div.i32
	cmplStd/test/lang/useOperator.ci:108: (11 bytes): i16Mod: int16 := i16A % i16B
	<.main+?>: load.sp(+32)
	<.main+?>: load.is16
	<.main+?>: load.sp(+32)
	<.main+?>: load.is16
	<.main+?>: mod.i32
	cmplStd/test/lang/useOperator.ci:109: (11 bytes): i16And: int16 := i16A & i16B
	<.main+?>: load.sp(+36)
	<.main+?>: load.is16
	<.main+?>: load.sp(+36)
	<.main+?>: load.is16
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:110: (11 bytes): i16Ior: int16 := i16A | i16B
	<.main+?>: load.sp(+40)
	<.main+?>: load.is16
	<.main+?>: load.sp(+40)
	<.main+?>: load.is16
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:111: (11 bytes): i16Xor: int16 := i16A ^ i16B
	<.main+?>: load.sp(+44)
	<.main+?>: load.is16
	<.main+?>: load.sp(+44)
	<.main+?>: load.is16
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:112: (8 bytes): i16Shl: int16 := (i16A) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.is16
	<.main+?>: dup.x32 sp(92)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:113: (8 bytes): i16Shr: int16 := (i16A) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.is16
	<.main+?>: dup.x32 sp(93)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:114: (7 bytes): i16Not: bool := !(i16B)
	<.main+?>: load.sp(+52)
	<.main+?>: load.is16
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:115: (11 bytes): i16Ceq: bool := i16A == i16B
	<.main+?>: load.sp(+60)
	<.main+?>: load.is16
	<.main+?>: load.sp(+60)
	<.main+?>: load.is16
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:116: (12 bytes): i16Cne: bool := i16A != i16B
	<.main+?>: load.sp(+64)
	<.main+?>: load.is16
	<.main+?>: load.sp(+64)
	<.main+?>: load.is16
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:117: (11 bytes): i16Clt: bool := i16A < i16B
	<.main+?>: load.sp(+68)
	<.main+?>: load.is16
	<.main+?>: load.sp(+68)
	<.main+?>: load.is16
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:118: (12 bytes): i16Cle: bool := i16A <= i16B
	<.main+?>: load.sp(+72)
	<.main+?>: load.is16
	<.main+?>: load.sp(+72)
	<.main+?>: load.is16
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:119: (11 bytes): i16Cgt: bool := i16A > i16B
	<.main+?>: load.sp(+76)
	<.main+?>: load.is16
	<.main+?>: load.sp(+76)
	<.main+?>: load.is16
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:120: (12 bytes): i16Cge: bool := i16A >= i16B
	<.main+?>: load.sp(+80)
	<.main+?>: load.is16
	<.main+?>: load.sp(+80)
	<.main+?>: load.is16
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:122: (5 bytes): u16A: uint16 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:123: (5 bytes): u16B: uint16 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:124: (5 bytes): u16Pls: uint16 := +u16B
	<.main+?>: load.sp(+0)
	<.main+?>: load.iu16
	cmplStd/test/lang/useOperator.ci:125: (6 bytes): u16Neg: uint16 := -u16B
	<.main+?>: load.sp(+4)
	<.main+?>: load.iu16
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:126: (6 bytes): u16Cmt: uint16 := ~u16B
	<.main+?>: load.sp(+8)
	<.main+?>: load.iu16
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:127: (11 bytes): u16Add: uint16 := u16A + u16B
	<.main+?>: load.sp(+16)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+16)
	<.main+?>: load.iu16
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:128: (11 bytes): u16Sub: uint16 := u16A - u16B
	<.main+?>: load.sp(+20)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+20)
	<.main+?>: load.iu16
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:129: (11 bytes): u16Mul: uint16 := u16A * u16B
	<.main+?>: load.sp(+24)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+24)
	<.main+?>: load.iu16
	<.main+?>: mul.u32
	cmplStd/test/lang/useOperator.ci:130: (11 bytes): u16Div: uint16 := u16A / u16B
	<.main+?>: load.sp(+28)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+28)
	<.main+?>: load.iu16
	<.main+?>: div.u32
	cmplStd/test/lang/useOperator.ci:131: (11 bytes): u16Mod: uint16 := u16A % u16B
	<.main+?>: load.sp(+32)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+32)
	<.main+?>: load.iu16
	<.main+?>: mod.u32
	cmplStd/test/lang/useOperator.ci:132: (11 bytes): u16And: uint16 := u16A & u16B
	<.main+?>: load.sp(+36)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+36)
	<.main+?>: load.iu16
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:133: (11 bytes): u16Ior: uint16 := u16A | u16B
	<.main+?>: load.sp(+40)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+40)
	<.main+?>: load.iu16
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:134: (11 bytes): u16Xor: uint16 := u16A ^ u16B
	<.main+?>: load.sp(+44)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+44)
	<.main+?>: load.iu16
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:135: (8 bytes): u16Shl: uint16 := (u16A) << shift
	<.main+?>: load.sp(+48)
	<.main+?>: load.iu16
	<.main+?>: dup.x32 sp(114)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:136: (8 bytes): u16Shr: uint16 := (u16A) >> shift
	<.main+?>: load.sp(+52)
	<.main+?>: load.iu16
	<.main+?>: dup.x32 sp(115)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:137: (7 bytes): u16Not: bool := !(u16B)
	<.main+?>: load.sp(+52)
	<.main+?>: load.iu16
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:138: (11 bytes): u16Ceq: bool := u16A == u16B
	<.main+?>: load.sp(+60)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+60)
	<.main+?>: load.iu16
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:139: (12 bytes): u16Cne: bool := u16A != u16B
	<.main+?>: load.sp(+64)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+64)
	<.main+?>: load.iu16
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:140: (11 bytes): u16Clt: bool := u16A < u16B
	<.main+?>: load.sp(+68)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+68)
	<.main+?>: load.iu16
	<.main+?>: clt.u32
	cmplStd/test/lang/useOperator.ci:141: (12 bytes): u16Cle: bool := u16A <= u16B
	<.main+?>: load.sp(+72)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+72)
	<.main+?>: load.iu16
	<.main+?>: cgt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:142: (11 bytes): u16Cgt: bool := u16A > u16B
	<.main+?>: load.sp(+76)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+76)
	<.main+?>: load.iu16
	<.main+?>: cgt.u32
	cmplStd/test/lang/useOperator.ci:143: (12 bytes): u16Cge: bool := u16A >= u16B
	<.main+?>: load.sp(+80)
	<.main+?>: load.iu16
	<.main+?>: load.sp(+80)
	<.main+?>: load.iu16
	<.main+?>: clt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:145: (5 bytes): i32A: int32 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:146: (5 bytes): i32B: int32 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:147: (2 bytes): i32Pls: int32 := +i32B
	<.main+?>: dup.x32 sp(0)
	cmplStd/test/lang/useOperator.ci:148: (3 bytes): i32Neg: int32 := -i32B
	<.main+?>: dup.x32 sp(1)
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:149: (3 bytes): i32Cmt: int32 := ~i32B
	<.main+?>: dup.x32 sp(2)
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:150: (5 bytes): i32Add: int32 := i32A + i32B
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:151: (5 bytes): i32Sub: int32 := i32A - i32B
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:152: (5 bytes): i32Mul: int32 := i32A * i32B
	<.main+?>: dup.x32 sp(6)
	<.main+?>: dup.x32 sp(6)
	<.main+?>: mul.i32
	cmplStd/test/lang/useOperator.ci:153: (5 bytes): i32Div: int32 := i32A / i32B
	<.main+?>: dup.x32 sp(7)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: div.i32
	cmplStd/test/lang/useOperator.ci:154: (5 bytes): i32Mod: int32 := i32A % i32B
	<.main+?>: dup.x32 sp(8)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: mod.i32
	cmplStd/test/lang/useOperator.ci:155: (5 bytes): i32And: int32 := i32A & i32B
	<.main+?>: dup.x32 sp(9)
	<.main+?>: dup.x32 sp(9)
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:156: (5 bytes): i32Ior: int32 := i32A | i32B
	<.main+?>: dup.x32 sp(10)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:157: (5 bytes): i32Xor: int32 := i32A ^ i32B
	<.main+?>: dup.x32 sp(11)
	<.main+?>: dup.x32 sp(11)
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:158: (5 bytes): i32Shl: int32 := i32A << shift
	<.main+?>: dup.x32 sp(12)
	<.main+?>: dup.x32 sp(136)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:159: (5 bytes): i32Shr: int32 := i32A >> shift
	<.main+?>: dup.x32 sp(13)
	<.main+?>: dup.x32 sp(137)
	<.main+?>: sar.b32
	cmplStd/test/lang/useOperator.ci:160: (4 bytes): i32Not: bool := !(i32B)
	<.main+?>: dup.x32 sp(13)
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:161: (5 bytes): i32Ceq: bool := i32A == i32B
	<.main+?>: dup.x32 sp(15)
	<.main+?>: dup.x32 sp(15)
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:162: (6 bytes): i32Cne: bool := i32A != i32B
	<.main+?>: dup.x32 sp(16)
	<.main+?>: dup.x32 sp(16)
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:163: (5 bytes): i32Clt: bool := i32A < i32B
	<.main+?>: dup.x32 sp(17)
	<.main+?>: dup.x32 sp(17)
	<.main+?>: clt.i32
	cmplStd/test/lang/useOperator.ci:164: (6 bytes): i32Cle: bool := i32A <= i32B
	<.main+?>: dup.x32 sp(18)
	<.main+?>: dup.x32 sp(18)
	<.main+?>: cgt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:165: (5 bytes): i32Cgt: bool := i32A > i32B
	<.main+?>: dup.x32 sp(19)
	<.main+?>: dup.x32 sp(19)
	<.main+?>: cgt.i32
	cmplStd/test/lang/useOperator.ci:166: (6 bytes): i32Cge: bool := i32A >= i32B
	<.main+?>: dup.x32 sp(20)
	<.main+?>: dup.x32 sp(20)
	<.main+?>: clt.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:168: (5 bytes): u32A: uint32 := a
	<.main+?>: load.c32 96
	cmplStd/test/lang/useOperator.ci:169: (5 bytes): u32B: uint32 := b
	<.main+?>: load.c32 42
	cmplStd/test/lang/useOperator.ci:170: (2 bytes): u32Pls: uint32 := +u32B
	<.main+?>: dup.x32 sp(0)
	cmplStd/test/lang/useOperator.ci:171: (3 bytes): u32Neg: uint32 := -u32B
	<.main+?>: dup.x32 sp(1)
	<.main+?>: neg.i32
	cmplStd/test/lang/useOperator.ci:172: (3 bytes): u32Cmt: uint32 := ~u32B
	<.main+?>: dup.x32 sp(2)
	<.main+?>: cmt.b32
	cmplStd/test/lang/useOperator.ci:173: (5 bytes): u32Add: uint32 := u32A + u32B
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: add.i32
	cmplStd/test/lang/useOperator.ci:174: (5 bytes): u32Sub: uint32 := u32A - u32B
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: sub.i32
	cmplStd/test/lang/useOperator.ci:175: (5 bytes): u32Mul: uint32 := u32A * u32B
	<.main+?>: dup.x32 sp(6)
	<.main+?>: dup.x32 sp(6)
	<.main+?>: mul.u32
	cmplStd/test/lang/useOperator.ci:176: (5 bytes): u32Div: uint32 := u32A / u32B
	<.main+?>: dup.x32 sp(7)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: div.u32
	cmplStd/test/lang/useOperator.ci:177: (5 bytes): u32Mod: uint32 := u32A % u32B
	<.main+?>: dup.x32 sp(8)
	<.main+?>: dup.x32 sp(8)
	<.main+?>: mod.u32
	cmplStd/test/lang/useOperator.ci:178: (5 bytes): u32And: uint32 := u32A & u32B
	<.main+?>: dup.x32 sp(9)
	<.main+?>: dup.x32 sp(9)
	<.main+?>: and.b32
	cmplStd/test/lang/useOperator.ci:179: (5 bytes): u32Ior: uint32 := u32A | u32B
	<.main+?>: dup.x32 sp(10)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: or.b32
	cmplStd/test/lang/useOperator.ci:180: (5 bytes): u32Xor: uint32 := u32A ^ u32B
	<.main+?>: dup.x32 sp(11)
	<.main+?>: dup.x32 sp(11)
	<.main+?>: xor.b32
	cmplStd/test/lang/useOperator.ci:181: (5 bytes): u32Shl: uint32 := u32A << shift
	<.main+?>: dup.x32 sp(12)
	<.main+?>: dup.x32 sp(158)
	<.main+?>: shl.b32
	cmplStd/test/lang/useOperator.ci:182: (5 bytes): u32Shr: uint32 := u32A >> shift
	<.main+?>: dup.x32 sp(13)
	<.main+?>: dup.x32 sp(159)
	<.main+?>: shr.b32
	cmplStd/test/lang/useOperator.ci:183: (4 bytes): u32Not: bool := !(u32B)
	<.main+?>: dup.x32 sp(13)
	<.main+?>: i32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:184: (5 bytes): u32Ceq: bool := u32A == u32B
	<.main+?>: dup.x32 sp(15)
	<.main+?>: dup.x32 sp(15)
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:185: (6 bytes): u32Cne: bool := u32A != u32B
	<.main+?>: dup.x32 sp(16)
	<.main+?>: dup.x32 sp(16)
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:186: (5 bytes): u32Clt: bool := u32A < u32B
	<.main+?>: dup.x32 sp(17)
	<.main+?>: dup.x32 sp(17)
	<.main+?>: clt.u32
	cmplStd/test/lang/useOperator.ci:187: (6 bytes): u32Cle: bool := u32A <= u32B
	<.main+?>: dup.x32 sp(18)
	<.main+?>: dup.x32 sp(18)
	<.main+?>: cgt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:188: (5 bytes): u32Cgt: bool := u32A > u32B
	<.main+?>: dup.x32 sp(19)
	<.main+?>: dup.x32 sp(19)
	<.main+?>: cgt.u32
	cmplStd/test/lang/useOperator.ci:189: (6 bytes): u32Cge: bool := u32A >= u32B
	<.main+?>: dup.x32 sp(20)
	<.main+?>: dup.x32 sp(20)
	<.main+?>: clt.u32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:191: (9 bytes): i64A: int64 := a
	<.main+?>: load.c64 96
	cmplStd/test/lang/useOperator.ci:192: (9 bytes): i64B: int64 := b
	<.main+?>: load.c64 42
	cmplStd/test/lang/useOperator.ci:193: (2 bytes): i64Pls: int64 := +i64B
	<.main+?>: dup.x64 sp(0)
	cmplStd/test/lang/useOperator.ci:194: (3 bytes): i64Neg: int64 := -i64B
	<.main+?>: dup.x64 sp(2)
	<.main+?>: neg.i64
	cmplStd/test/lang/useOperator.ci:195: (3 bytes): i64Cmt: int64 := ~i64B
	<.main+?>: dup.x64 sp(4)
	<.main+?>: cmt.b64
	cmplStd/test/lang/useOperator.ci:196: (5 bytes): i64Add: int64 := i64A + i64B
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: add.i64
	cmplStd/test/lang/useOperator.ci:197: (5 bytes): i64Sub: int64 := i64A - i64B
	<.main+?>: dup.x64 sp(10)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: sub.i64
	cmplStd/test/lang/useOperator.ci:198: (5 bytes): i64Mul: int64 := i64A * i64B
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(12)
	<.main+?>: mul.i64
	cmplStd/test/lang/useOperator.ci:199: (5 bytes): i64Div: int64 := i64A / i64B
	<.main+?>: dup.x64 sp(14)
	<.main+?>: dup.x64 sp(14)
	<.main+?>: div.i64
	cmplStd/test/lang/useOperator.ci:200: (5 bytes): i64Mod: int64 := i64A % i64B
	<.main+?>: dup.x64 sp(16)
	<.main+?>: dup.x64 sp(16)
	<.main+?>: mod.i64
	cmplStd/test/lang/useOperator.ci:201: (5 bytes): i64And: int64 := i64A & i64B
	<.main+?>: dup.x64 sp(18)
	<.main+?>: dup.x64 sp(18)
	<.main+?>: and.b64
	cmplStd/test/lang/useOperator.ci:202: (5 bytes): i64Ior: int64 := i64A | i64B
	<.main+?>: dup.x64 sp(20)
	<.main+?>: dup.x64 sp(20)
	<.main+?>: or.b64
	cmplStd/test/lang/useOperator.ci:203: (5 bytes): i64Xor: int64 := i64A ^ i64B
	<.main+?>: dup.x64 sp(22)
	<.main+?>: dup.x64 sp(22)
	<.main+?>: xor.b64
	cmplStd/test/lang/useOperator.ci:204: (5 bytes): i64Shl: int64 := i64A << shift
	<.main+?>: dup.x64 sp(24)
	<.main+?>: dup.x32 sp(194)
	<.main+?>: shl.b64
	cmplStd/test/lang/useOperator.ci:205: (5 bytes): i64Shr: int64 := i64A >> shift
	<.main+?>: dup.x64 sp(26)
	<.main+?>: dup.x32 sp(196)
	<.main+?>: sar.b64
	cmplStd/test/lang/useOperator.ci:206: (4 bytes): i64Not: bool := !(i64B)
	<.main+?>: dup.x64 sp(26)
	<.main+?>: i64.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:207: (5 bytes): i64Ceq: bool := i64A == i64B
	<.main+?>: dup.x64 sp(29)
	<.main+?>: dup.x64 sp(29)
	<.main+?>: ceq.i64
	cmplStd/test/lang/useOperator.ci:208: (6 bytes): i64Cne: bool := i64A != i64B
	<.main+?>: dup.x64 sp(30)
	<.main+?>: dup.x64 sp(30)
	<.main+?>: ceq.i64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:209: (5 bytes): i64Clt: bool := i64A < i64B
	<.main+?>: dup.x64 sp(31)
	<.main+?>: dup.x64 sp(31)
	<.main+?>: clt.i64
	cmplStd/test/lang/useOperator.ci:210: (6 bytes): i64Cle: bool := i64A <= i64B
	<.main+?>: dup.x64 sp(32)
	<.main+?>: dup.x64 sp(32)
	<.main+?>: cgt.i64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:211: (5 bytes): i64Cgt: bool := i64A > i64B
	<.main+?>: dup.x64 sp(33)
	<.main+?>: dup.x64 sp(33)
	<.main+?>: cgt.i64
	cmplStd/test/lang/useOperator.ci:212: (6 bytes): i64Cge: bool := i64A >= i64B
	<.main+?>: dup.x64 sp(34)
	<.main+?>: dup.x64 sp(34)
	<.main+?>: clt.i64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:214: (9 bytes): u64A: uint64 := a
	<.main+?>: load.c64 96
	cmplStd/test/lang/useOperator.ci:215: (9 bytes): u64B: uint64 := b
	<.main+?>: load.c64 42
	cmplStd/test/lang/useOperator.ci:216: (2 bytes): u64Pls: uint64 := +u64B
	<.main+?>: dup.x64 sp(0)
	cmplStd/test/lang/useOperator.ci:217: (3 bytes): u64Neg: uint64 := -u64B
	<.main+?>: dup.x64 sp(2)
	<.main+?>: neg.i64
	cmplStd/test/lang/useOperator.ci:218: (3 bytes): u64Cmt: uint64 := ~u64B
	<.main+?>: dup.x64 sp(4)
	<.main+?>: cmt.b64
	cmplStd/test/lang/useOperator.ci:219: (5 bytes): u64Add: uint64 := u64A + u64B
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: add.i64
	cmplStd/test/lang/useOperator.ci:220: (5 bytes): u64Sub: uint64 := u64A - u64B
	<.main+?>: dup.x64 sp(10)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: sub.i64
	cmplStd/test/lang/useOperator.ci:221: (5 bytes): u64Mul: uint64 := u64A * u64B
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(12)
	<.main+?>: mul.u64
	cmplStd/test/lang/useOperator.ci:222: (5 bytes): u64Div: uint64 := u64A / u64B
	<.main+?>: dup.x64 sp(14)
	<.main+?>: dup.x64 sp(14)
	<.main+?>: div.u64
	cmplStd/test/lang/useOperator.ci:223: (5 bytes): u64Mod: uint64 := u64A % u64B
	<.main+?>: dup.x64 sp(16)
	<.main+?>: dup.x64 sp(16)
	<.main+?>: mod.u64
	cmplStd/test/lang/useOperator.ci:224: (5 bytes): u64And: uint64 := u64A & u64B
	<.main+?>: dup.x64 sp(18)
	<.main+?>: dup.x64 sp(18)
	<.main+?>: and.b64
	cmplStd/test/lang/useOperator.ci:225: (5 bytes): u64Ior: uint64 := u64A | u64B
	<.main+?>: dup.x64 sp(20)
	<.main+?>: dup.x64 sp(20)
	<.main+?>: or.b64
	cmplStd/test/lang/useOperator.ci:226: (5 bytes): u64Xor: uint64 := u64A ^ u64B
	<.main+?>: dup.x64 sp(22)
	<.main+?>: dup.x64 sp(22)
	<.main+?>: xor.b64
	cmplStd/test/lang/useOperator.ci:227: (5 bytes): u64Shl: uint64 := u64A << shift
	<.main+?>: dup.x64 sp(24)
	<.main+?>: dup.x32 sp(231)
	<.main+?>: shl.b64
	cmplStd/test/lang/useOperator.ci:228: (5 bytes): u64Shr: uint64 := u64A >> shift
	<.main+?>: dup.x64 sp(26)
	<.main+?>: dup.x32 sp(233)
	<.main+?>: shr.b64
	cmplStd/test/lang/useOperator.ci:229: (4 bytes): u64Not: bool := !(u64B)
	<.main+?>: dup.x64 sp(26)
	<.main+?>: i64.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:230: (5 bytes): u64Ceq: bool := u64A == u64B
	<.main+?>: dup.x64 sp(29)
	<.main+?>: dup.x64 sp(29)
	<.main+?>: ceq.i64
	cmplStd/test/lang/useOperator.ci:231: (6 bytes): u64Cne: bool := u64A != u64B
	<.main+?>: dup.x64 sp(30)
	<.main+?>: dup.x64 sp(30)
	<.main+?>: ceq.i64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:232: (5 bytes): u64Clt: bool := u64A < u64B
	<.main+?>: dup.x64 sp(31)
	<.main+?>: dup.x64 sp(31)
	<.main+?>: clt.u64
	cmplStd/test/lang/useOperator.ci:233: (6 bytes): u64Cle: bool := u64A <= u64B
	<.main+?>: dup.x64 sp(32)
	<.main+?>: dup.x64 sp(32)
	<.main+?>: cgt.u64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:234: (5 bytes): u64Cgt: bool := u64A > u64B
	<.main+?>: dup.x64 sp(33)
	<.main+?>: dup.x64 sp(33)
	<.main+?>: cgt.u64
	cmplStd/test/lang/useOperator.ci:235: (6 bytes): u64Cge: bool := u64A >= u64B
	<.main+?>: dup.x64 sp(34)
	<.main+?>: dup.x64 sp(34)
	<.main+?>: clt.u64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:237: (5 bytes): f32A: float32 := a
	<.main+?>: load.f32 96.300003
	cmplStd/test/lang/useOperator.ci:238: (5 bytes): f32B: float32 := b
	<.main+?>: load.f32 42.139999
	cmplStd/test/lang/useOperator.ci:239: (2 bytes): f32Pls: float32 := +f32B
	<.main+?>: dup.x32 sp(0)
	cmplStd/test/lang/useOperator.ci:240: (3 bytes): f32Neg: float32 := -f32B
	<.main+?>: dup.x32 sp(1)
	<.main+?>: neg.f32
	cmplStd/test/lang/useOperator.ci:242: (5 bytes): f32Add: float32 := f32A + f32B
	<.main+?>: dup.x32 sp(3)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: add.f32
	cmplStd/test/lang/useOperator.ci:243: (5 bytes): f32Sub: float32 := f32A - f32B
	<.main+?>: dup.x32 sp(4)
	<.main+?>: dup.x32 sp(4)
	<.main+?>: sub.f32
	cmplStd/test/lang/useOperator.ci:244: (5 bytes): f32Mul: float32 := f32A * f32B
	<.main+?>: dup.x32 sp(5)
	<.main+?>: dup.x32 sp(5)
	<.main+?>: mul.f32
	cmplStd/test/lang/useOperator.ci:245: (5 bytes): f32Div: float32 := f32A / f32B
	<.main+?>: dup.x32 sp(6)
	<.main+?>: dup.x32 sp(6)
	<.main+?>: div.f32
	cmplStd/test/lang/useOperator.ci:246: (5 bytes): f32Mod: float32 := f32A % f32B
	<.main+?>: dup.x32 sp(7)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: mod.f32
	cmplStd/test/lang/useOperator.ci:252: (4 bytes): f32Not: bool := !(f32B)
	<.main+?>: dup.x32 sp(7)
	<.main+?>: f32.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:253: (5 bytes): f32Ceq: bool := f32A == f32B
	<.main+?>: dup.x32 sp(9)
	<.main+?>: dup.x32 sp(9)
	<.main+?>: ceq.f32
	cmplStd/test/lang/useOperator.ci:254: (6 bytes): f32Cne: bool := f32A != f32B
	<.main+?>: dup.x32 sp(10)
	<.main+?>: dup.x32 sp(10)
	<.main+?>: ceq.f32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:255: (5 bytes): f32Clt: bool := f32A < f32B
	<.main+?>: dup.x32 sp(11)
	<.main+?>: dup.x32 sp(11)
	<.main+?>: clt.f32
	cmplStd/test/lang/useOperator.ci:256: (6 bytes): f32Cle: bool := f32A <= f32B
	<.main+?>: dup.x32 sp(12)
	<.main+?>: dup.x32 sp(12)
	<.main+?>: cgt.f32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:257: (5 bytes): f32Cgt: bool := f32A > f32B
	<.main+?>: dup.x32 sp(13)
	<.main+?>: dup.x32 sp(13)
	<.main+?>: cgt.f32
	cmplStd/test/lang/useOperator.ci:258: (6 bytes): f32Cge: bool := f32A >= f32B
	<.main+?>: dup.x32 sp(14)
	<.main+?>: dup.x32 sp(14)
	<.main+?>: clt.f32
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:260: (9 bytes): f64A: float64 := a
	<.main+?>: load.f64 96.300000
	cmplStd/test/lang/useOperator.ci:261: (9 bytes): f64B: float64 := b
	<.main+?>: load.f64 42.140000
	cmplStd/test/lang/useOperator.ci:262: (2 bytes): f64Pls: float64 := +f64B
	<.main+?>: dup.x64 sp(0)
	cmplStd/test/lang/useOperator.ci:263: (3 bytes): f64Neg: float64 := -f64B
	<.main+?>: dup.x64 sp(2)
	<.main+?>: neg.f64
	cmplStd/test/lang/useOperator.ci:265: (5 bytes): f64Add: float64 := f64A + f64B
	<.main+?>: dup.x64 sp(6)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: add.f64
	cmplStd/test/lang/useOperator.ci:266: (5 bytes): f64Sub: float64 := f64A - f64B
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: sub.f64
	cmplStd/test/lang/useOperator.ci:267: (5 bytes): f64Mul: float64 := f64A * f64B
	<.main+?>: dup.x64 sp(10)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: mul.f64
	cmplStd/test/lang/useOperator.ci:268: (5 bytes): f64Div: float64 := f64A / f64B
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(12)
	<.main+?>: div.f64
	cmplStd/test/lang/useOperator.ci:269: (5 bytes): f64Mod: float64 := f64A % f64B
	<.main+?>: dup.x64 sp(14)
	<.main+?>: dup.x64 sp(14)
	<.main+?>: mod.f64
	cmplStd/test/lang/useOperator.ci:275: (4 bytes): f64Not: bool := !(f64B)
	<.main+?>: dup.x64 sp(14)
	<.main+?>: f64.2bool
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:276: (5 bytes): f64Ceq: bool := f64A == f64B
	<.main+?>: dup.x64 sp(17)
	<.main+?>: dup.x64 sp(17)
	<.main+?>: ceq.f64
	cmplStd/test/lang/useOperator.ci:277: (6 bytes): f64Cne: bool := f64A != f64B
	<.main+?>: dup.x64 sp(18)
	<.main+?>: dup.x64 sp(18)
	<.main+?>: ceq.f64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:278: (5 bytes): f64Clt: bool := f64A < f64B
	<.main+?>: dup.x64 sp(19)
	<.main+?>: dup.x64 sp(19)
	<.main+?>: clt.f64
	cmplStd/test/lang/useOperator.ci:279: (6 bytes): f64Cle: bool := f64A <= f64B
	<.main+?>: dup.x64 sp(20)
	<.main+?>: dup.x64 sp(20)
	<.main+?>: cgt.f64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:280: (5 bytes): f64Cgt: bool := f64A > f64B
	<.main+?>: dup.x64 sp(21)
	<.main+?>: dup.x64 sp(21)
	<.main+?>: cgt.f64
	cmplStd/test/lang/useOperator.ci:281: (6 bytes): f64Cge: bool := f64A >= f64B
	<.main+?>: dup.x64 sp(22)
	<.main+?>: dup.x64 sp(22)
	<.main+?>: clt.f64
	<.main+?>: not.b32
	cmplStd/test/lang/useOperator.ci:283: (5 bytes): ptrA: pointer := null
	<.main+?>: load.ref <?> ;null
	cmplStd/test/lang/useOperator.ci:284: (4 bytes): ptrB: pointer := pointer(shift)
	<.main+?>: load.sp(+1128)
	cmplStd/test/lang/useOperator.ci:299: (5 bytes): ptrCeq: bool := ptrA == ptrB
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: ceq.i32
	cmplStd/test/lang/useOperator.ci:300: (6 bytes): ptrCne: bool := ptrA != ptrB
	<.main+?>: dup.x32 sp(2)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: ceq.i32
	<.main+?>: not.b32
	cmplStd/test/lang/stmt.if.ci:4: (40 bytes): raise(raise.debug, 1, "0 == 0");
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 4
	<.main+?>: load.c32 14
	<.main+?>: load.c32 1
	<.main+?>: load.ref <?> ;"0 == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/stmt.if.ci:12: (40 bytes): raise(raise.debug, 3, "0 == 0");
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 12
	<.main+?>: load.c32 14
	<.main+?>: load.c32 3
	<.main+?>: load.ref <?> ;"0 == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/stmt.if.ci:22: (40 bytes): raise(raise.debug, 6, "0 == 0");
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 22
	<.main+?>: load.c32 14
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;"0 == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/stmt.if.ci:26: (1 byte): t: int32 := 0
	<.main+?>: load.z32
	cmplStd/test/lang/stmt.if.ci:28: (61 bytes): if (t == 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jz +57
	cmplStd/test/lang/stmt.if.ci:29: (53 bytes): raise(raise.debug, 7, "t == 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 29
	<.main+?>: load.c32 14
	<.main+?>: load.c32 7
	<.main+?>: load.ref <?> ;"t == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:32: (61 bytes): if (t != 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jnz +57
	cmplStd/test/lang/stmt.if.ci:33: (53 bytes): raise(raise.debug, 8, "t != 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 33
	<.main+?>: load.c32 14
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;"t != 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:36: (118 bytes): if (t == 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:37: (53 bytes): raise(raise.debug, 9, "t == 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 37
	<.main+?>: load.c32 14
	<.main+?>: load.c32 9
	<.main+?>: load.ref <?> ;"t == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.if.ci:40: (53 bytes): raise(raise.debug, 10, "t != 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 40
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t != 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:43: (118 bytes): if (t != 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jnz +61
	cmplStd/test/lang/stmt.if.ci:44: (53 bytes): raise(raise.debug, 11, "t != 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 44
	<.main+?>: load.c32 14
	<.main+?>: load.c32 11
	<.main+?>: load.ref <?> ;"t != 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.if.ci:47: (53 bytes): raise(raise.debug, 12, "t == 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 47
	<.main+?>: load.c32 14
	<.main+?>: load.c32 12
	<.main+?>: load.ref <?> ;"t == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.if.ci:50: (463 bytes): if (t == 0)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:51: (53 bytes): raise(raise.debug, 9, "t == 0", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 51
	<.main+?>: load.c32 14
	<.main+?>: load.c32 9
	<.main+?>: load.ref <?> ;"t == 0"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +402
	cmplStd/test/lang/stmt.if.ci:53: (398 bytes): if (t == 1)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 1
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:54: (53 bytes): raise(raise.debug, 10, "t == 1", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 54
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 1"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +333
	cmplStd/test/lang/stmt.if.ci:56: (329 bytes): if (t == 2)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:57: (53 bytes): raise(raise.debug, 10, "t == 2", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 57
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 2"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +264
	cmplStd/test/lang/stmt.if.ci:59: (260 bytes): if (t == 3)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 3
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:60: (53 bytes): raise(raise.debug, 10, "t == 3", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 60
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 3"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +195
	cmplStd/test/lang/stmt.if.ci:62: (191 bytes): if (t == 4)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 4
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:63: (53 bytes): raise(raise.debug, 10, "t == 4", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 63
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 4"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +126
	cmplStd/test/lang/stmt.if.ci:65: (122 bytes): if (t == 5)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 5
	<.main+?>: ceq.i32
	<.main+?>: jz +61
	cmplStd/test/lang/stmt.if.ci:66: (53 bytes): raise(raise.debug, 10, "t == 5", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 66
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t == 5"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.if.ci:69: (53 bytes): raise(raise.debug, 10, "t not in (0, 1, 2, 3, 4, 5)", t);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.if.ci"
	<.main+?>: load.c32 69
	<.main+?>: load.c32 14
	<.main+?>: load.c32 10
	<.main+?>: load.ref <?> ;"t not in (0, 1, 2, 3, 4, 5)"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:3: (48 bytes): for ( ; ; )
	<.main+?>: jmp +44
	cmplStd/test/lang/stmt.for.ci:4: (36 bytes): debug("for ( ; ; )");
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 4
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for ( ; ; )"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-8)
	cmplStd/test/lang/stmt.for.ci:5: (4 bytes): break;
	<.main+?>: jmp +8
	:: (4 bytes)
	<.main+?>: jmp -40
	cmplStd/test/lang/stmt.for.ci:8: (74 bytes): for (i: int32 := 0; i < 2; i := i + 1)
	<.main+?>: load.z32
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.for.ci:9: (49 bytes): debug("for (int i = 0; i < 2; i += 1)", i);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 9
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for (int i = 0; i < 2; i += 1)"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:8: (4 bytes): i := i + 1
	<.main+?>: inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:8: (12 bytes): i < 2
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: clt.i32
	<.main+?>: jnz -61
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:12: (1 byte): forIdx: int32
	<.main+?>: load.z32
	cmplStd/test/lang/stmt.for.ci:13: (72 bytes): for (forIdx := 0; forIdx < 2; forIdx := forIdx + 1)
	<.main+?>: load.z32
	<.main+?>: set.x32 sp(1)
	<.main+?>: jmp +57
	cmplStd/test/lang/stmt.for.ci:14: (49 bytes): debug("for (forIdx = 0; forIdx < 2; forIdx += 1)", forIdx);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 14
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for (forIdx = 0; forIdx < 2; forIdx += 1)"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:13: (4 bytes): forIdx := forIdx + 1
	<.main+?>: inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:13: (12 bytes): forIdx < 2
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: clt.i32
	<.main+?>: jnz -61
	cmplStd/test/lang/stmt.for.ci:17: (90 bytes): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+?>: load.z32
	<.main+?>: jmp +73
	cmplStd/test/lang/stmt.for.ci:18: (16 bytes): if (i < 2)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: clt.i32
	<.main+?>: jz +8
	cmplStd/test/lang/stmt.for.ci:19: (4 bytes): continue;
	<.main+?>: jmp +53
	cmplStd/test/lang/stmt.for.ci:21: (49 bytes): debug("for with continue", i);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 21
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for with continue"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:17: (4 bytes): i := i + 1
	<.main+?>: inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:17: (12 bytes): i < 7
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 7
	<.main+?>: clt.i32
	<.main+?>: jnz -77
	<.main+?>: inc.sp(-4)
	cmplStd/test/lang/stmt.for.ci:24: (90 bytes): for (i: int32 := 0; i < 7; i := i + 1)
	<.main+?>: load.z32
	<.main+?>: jmp +73
	cmplStd/test/lang/stmt.for.ci:25: (16 bytes): if (i > 2)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 2
	<.main+?>: cgt.i32
	<.main+?>: jz +8
	cmplStd/test/lang/stmt.for.ci:26: (4 bytes): break;
	<.main+?>: jmp +69
	cmplStd/test/lang/stmt.for.ci:28: (49 bytes): debug("for with break", i);
	<.main+?>: load.ref <?> ;int32
	<.main+?>: load.sp(+4)
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.ref <?> ;"cmplStd/test/lang/stmt.for.ci"
	<.main+?>: load.c32 28
	<.main+?>: load.c32 14
	<.main+?>: load.z32
	<.main+?>: load.ref <?> ;"for with break"
	<.main+?>: dup.x64 sp(5)
	<.main+?>: nfc(11) ;raise(file: char[*], line: int32, level: int32, trace: int32, message: char[*], details: variant[]): void
	<.main+?>: inc.sp(-16)
	cmplStd/test/lang/stmt.for.ci:24: (4 bytes): i := i + 1
	<.main+?>: inc.i32(+1)
	cmplStd/test/lang/stmt.for.ci:24: (12 bytes): i < 7
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.c32 7
	<.main+?>: clt.i32
	<.main+?>: jnz -77
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:3: (9 bytes): pi64: float64 := 3.141593
	<.main+?>: load.f64 3.141593
	cmplStd/test/math/test.Bits.ci:4: (9 bytes): e64: float64 := 2.718282
	<.main+?>: load.f64 2.718282
	cmplStd/test/math/test.Bits.ci:6: (3 bytes): pi32: float32 := pi64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: f64.2f32
	cmplStd/test/math/test.Bits.ci:7: (3 bytes): e32: float32 := e64
	<.main+?>: dup.x64 sp(1)
	<.main+?>: f64.2f32
	cmplStd/test/math/test.Bits.ci:14: (7 bytes): r_comp: int32 := 14 << 3
	<.main+?>: load.c32 14
	<.main+?>: b32.shl 0x03
	cmplStd/test/math/test.Bits.ci:15: (7 bytes): g_comp: int32 := 63 << 2
	<.main+?>: load.c32 63
	<.main+?>: b32.shl 0x02
	cmplStd/test/math/test.Bits.ci:16: (7 bytes): b_comp: int32 := 31 << 3
	<.main+?>: load.c32 31
	<.main+?>: b32.shl 0x03
	cmplStd/test/math/test.Bits.ci:18: (28 bytes): r5g6b5: int32 := rgb565(r_comp, g_comp, b_comp)
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 63488
	<.main+?>: and.b32
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.shl 0x03
	<.main+?>: load.c32 2016
	<.main+?>: and.b32
	<.main+?>: or.b32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: b32.sar 0x03
	<.main+?>: b32.and 0x1f
	<.main+?>: or.b32
	cmplStd/test/math/test.Bits.ci:19: (26 bytes): r8g8b8: int32 := rgb888(r_comp, g_comp, b_comp)
	<.main+?>: dup.x32 sp(3)
	<.main+?>: b32.shl 0x10
	<.main+?>: load.c32 16711680
	<.main+?>: and.b32
	<.main+?>: dup.x32 sp(3)
	<.main+?>: b32.shl 0x08
	<.main+?>: load.c32 65280
	<.main+?>: and.b32
	<.main+?>: or.b32
	<.main+?>: dup.x32 sp(2)
	<.main+?>: b32.and 0xff
	<.main+?>: or.b32
	cmplStd/test/math/test.Bits.ci:21: (23 bytes): zxtR5: int32 := Bits.zxt32(r5g6b5, 11, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(2)
	<.main+?>: load.c32 11
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:22: (23 bytes): zxtG6: int32 := Bits.zxt32(r5g6b5, 5, 6)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(3)
	<.main+?>: load.c32 5
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:23: (19 bytes): zxtB5: int32 := Bits.zxt32(r5g6b5, 0, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(4)
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:25: (23 bytes): sxtR5: int32 := Bits.sxt32(r5g6b5, 11, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(5)
	<.main+?>: load.c32 11
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:26: (23 bytes): sxtG6: int32 := Bits.sxt32(r5g6b5, 5, 6)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(6)
	<.main+?>: load.c32 5
	<.main+?>: load.c32 6
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:27: (19 bytes): sxtB5: int32 := Bits.sxt32(r5g6b5, 0, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(7)
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:29: (23 bytes): zxtR8: int32 := Bits.zxt32(r8g8b8, 16, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(7)
	<.main+?>: load.c32 16
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:30: (23 bytes): zxtG8: int32 := Bits.zxt32(r8g8b8, 8, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(8)
	<.main+?>: load.c32 8
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:31: (19 bytes): zxtB8: int32 := Bits.zxt32(r8g8b8, 0, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(9)
	<.main+?>: load.z32
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:33: (23 bytes): sxtR8: int32 := Bits.sxt32(r8g8b8, 16, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(10)
	<.main+?>: load.c32 16
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:34: (23 bytes): sxtG8: int32 := Bits.sxt32(r8g8b8, 8, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(11)
	<.main+?>: load.c32 8
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:35: (19 bytes): sxtB8: int32 := Bits.sxt32(r8g8b8, 0, 8)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(12)
	<.main+?>: load.z32
	<.main+?>: load.c32 8
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:37: (23 bytes): testSin_f64: float64 := Math.sin(pi64 / (2))
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(23)
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.sin(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:38: (23 bytes): testCos_f64: float64 := Math.cos(pi64 / (2))
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(25)
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.cos(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:39: (23 bytes): testTan_f64: float64 := Math.tan(pi64 / (4))
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(27)
	<.main+?>: load.f64 4.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.tan(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:40: (19 bytes): testLog_f64: float64 := Math.log(e64 * e64 * e64)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(27)
	<.main+?>: dup.x64 sp(29)
	<.main+?>: mul.f64
	<.main+?>: dup.x64 sp(29)
	<.main+?>: mul.f64
	<.main+?>: load.ref <?> ;Math.log(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:41: (20 bytes): testExp_f64: float64 := Math.exp(1.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 1.000000
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:42: (25 bytes): testPow_f64: float64 := Math.pow(pi64 * pi64, 0.500000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(33)
	<.main+?>: dup.x64 sp(35)
	<.main+?>: mul.f64
	<.main+?>: load.f64 0.500000
	<.main+?>: load.ref <?> ;Math.pow(x: float64, y: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Bits.ci:43: (16 bytes): testSqrt_f64: float64 := Math.sqrt(pi64 * pi64)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(35)
	<.main+?>: dup.x64 sp(37)
	<.main+?>: mul.f64
	<.main+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:44: (22 bytes): testAtan_f64: float64 := Math.atan2(pi64, 1.000000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(37)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Bits.ci:46: (19 bytes): testSin_f32: float32 := Math.sin(pi32 / (2))
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(35)
	<.main+?>: load.f32 2.000000
	<.main+?>: div.f32
	<.main+?>: load.ref <?> ;Math.sin(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:47: (19 bytes): testCos_f32: float32 := Math.cos(pi32 / (2))
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(36)
	<.main+?>: load.f32 2.000000
	<.main+?>: div.f32
	<.main+?>: load.ref <?> ;Math.cos(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:48: (19 bytes): testTan_f32: float32 := Math.tan(pi32 / (4))
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(37)
	<.main+?>: load.f32 4.000000
	<.main+?>: div.f32
	<.main+?>: load.ref <?> ;Math.tan(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:49: (19 bytes): testLog_f32: float32 := Math.log(e32 * e32 * e32)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(37)
	<.main+?>: dup.x32 sp(38)
	<.main+?>: mul.f32
	<.main+?>: dup.x32 sp(38)
	<.main+?>: mul.f32
	<.main+?>: load.ref <?> ;Math.log(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:50: (16 bytes): testExp_f32: float32 := Math.exp(1.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 1.000000
	<.main+?>: load.ref <?> ;Math.exp(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:51: (21 bytes): testPow_f32: float32 := Math.pow(pi32 * pi32, 0.500000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(40)
	<.main+?>: dup.x32 sp(41)
	<.main+?>: mul.f32
	<.main+?>: load.f32 0.500000
	<.main+?>: load.ref <?> ;Math.pow(x: float32, y: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:52: (16 bytes): testSqrt_f32: float32 := Math.sqrt(pi32 * pi32)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(41)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: mul.f32
	<.main+?>: load.ref <?> ;Math.sqrt(x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:53: (18 bytes): testAtan_f32: float32 := Math.atan2(pi32, 1.000000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(42)
	<.main+?>: load.f32 1.000000
	<.main+?>: load.ref <?> ;Math.atan2(y: float32, x: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Bits.ci:55: (13 bytes): testPopulation_u32: int32 := Bits.countOnes(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(38)
	<.main+?>: load.ref <?> ;Bits.countOnes(x: uint32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:56: (13 bytes): testSwapBits_u32: uint32 := Bits.swapBits(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(39)
	<.main+?>: load.ref <?> ;Bits.swapBits(x: uint32): uint32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:57: (13 bytes): testBitScanReverse_u32: int32 := Bits.scanReverse(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(40)
	<.main+?>: load.ref <?> ;Bits.scanReverse(x: uint32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:58: (13 bytes): testBitScanForward_u32: int32 := Bits.scanForward(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(41)
	<.main+?>: load.ref <?> ;Bits.scanForward(x: uint32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:59: (13 bytes): testHighBit_u32: int32 := Bits.keepMsb(r5g6b5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(42)
	<.main+?>: load.ref <?> ;Bits.keepMsb(x: uint32): uint32
	<.main+?>: call
	<.main+?>: inc.sp(-4)
	cmplStd/test/math/test.Bits.ci:60: (10 bytes): testLowBit_u32: int32 := Bits.keepLsb(r5g6b5)
	<.main+?>: dup.x32 sp(42)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: neg.i32
	<.main+?>: and.b32
	<.main+?>: set.x32 sp(1)
	cmplStd/test/math/test.Bits.ci:62: (19 bytes): testZeroExtend_u32: int32 := Bits.zxt32(r5g6b5, 0, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(44)
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.zxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:63: (19 bytes): testSignExtend_u32: int32 := Bits.sxt32(r5g6b5, 0, 5)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(45)
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.sxt32(value: int32, offs: int32, count: int32): int32
	<.main+?>: call
	<.main+?>: inc.sp(-12)
	cmplStd/test/math/test.Bits.ci:65: (21 bytes): testZeroExtend_u64: int32 := Bits.zxt64(r5g6b5, 0, 5)
	<.main+?>: load.z64
	<.main+?>: dup.x32 sp(47)
	<.main+?>: i32.2i64
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.zxt64(value: int64, offs: int32, count: int32): int64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: i64.2i32
	cmplStd/test/math/test.Bits.ci:66: (21 bytes): testSignExtend_u64: int32 := Bits.sxt64(r5g6b5, 0, 5)
	<.main+?>: load.z64
	<.main+?>: dup.x32 sp(48)
	<.main+?>: i32.2i64
	<.main+?>: load.z32
	<.main+?>: load.c32 5
	<.main+?>: load.ref <?> ;Bits.sxt64(value: int64, offs: int32, count: int32): int64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: i64.2i32
	cmplStd/test/math/test.Math.ci:3: (20 bytes): testMathFloor_pos_3_0: float64 := Math.floor(3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.000000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:4: (20 bytes): testMathFloor_pos_3_2: float64 := Math.floor(3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.200000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:5: (20 bytes): testMathFloor_pos_3_5: float64 := Math.floor(3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.500000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:6: (20 bytes): testMathFloor_pos_3_7: float64 := Math.floor(3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.700000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:7: (20 bytes): testMathFloor_pos_3_9: float64 := Math.floor(3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.900000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:8: (20 bytes): testMathFloor_neg_3_0: float64 := Math.floor(-3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.000000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:9: (20 bytes): testMathFloor_neg_3_2: float64 := Math.floor(-3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.200000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:10: (20 bytes): testMathFloor_neg_3_5: float64 := Math.floor(-3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.500000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:11: (20 bytes): testMathFloor_neg_3_7: float64 := Math.floor(-3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.700000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:12: (20 bytes): testMathFloor_neg_3_9: float64 := Math.floor(-3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.900000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:14: (30 bytes): testMathRound_pos_3_0: float64 := Math.round(3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.000000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:15: (30 bytes): testMathRound_pos_3_2: float64 := Math.round(3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.200000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:16: (30 bytes): testMathRound_pos_3_5: float64 := Math.round(3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.500000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:17: (30 bytes): testMathRound_pos_3_7: float64 := Math.round(3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.700000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:18: (30 bytes): testMathRound_pos_3_9: float64 := Math.round(3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.900000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:19: (30 bytes): testMathRound_neg_3_0: float64 := Math.round(-3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.000000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:20: (30 bytes): testMathRound_neg_3_2: float64 := Math.round(-3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.200000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:21: (30 bytes): testMathRound_neg_3_5: float64 := Math.round(-3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.500000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:22: (30 bytes): testMathRound_neg_3_7: float64 := Math.round(-3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.700000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:23: (30 bytes): testMathRound_neg_3_9: float64 := Math.round(-3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.900000
	<.main+?>: load.f64 0.500000
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:25: (21 bytes): testMathCeil_pos_3_0: float64 := Math.ceil(3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.000000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:26: (21 bytes): testMathCeil_pos_3_2: float64 := Math.ceil(3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.200000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:27: (21 bytes): testMathCeil_pos_3_5: float64 := Math.ceil(3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.500000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:28: (21 bytes): testMathCeil_pos_3_7: float64 := Math.ceil(3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.700000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:29: (21 bytes): testMathCeil_pos_3_9: float64 := Math.ceil(3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -3.900000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:30: (21 bytes): testMathCeil_neg_3_0: float64 := Math.ceil(-3.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.000000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:31: (21 bytes): testMathCeil_neg_3_2: float64 := Math.ceil(-3.200000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.200000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:32: (21 bytes): testMathCeil_neg_3_5: float64 := Math.ceil(-3.500000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.500000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:33: (21 bytes): testMathCeil_neg_3_7: float64 := Math.ceil(-3.700000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.700000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:34: (21 bytes): testMathCeil_neg_3_9: float64 := Math.ceil(-3.900000)
	<.main+?>: load.z64
	<.main+?>: load.f64 3.900000
	<.main+?>: load.ref <?> ;Math.floor(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: neg.f64
	cmplStd/test/math/test.Math.ci:36: (26 bytes): testMathSign_1F: float64 := Math.sign(0.200000)
	<.main+?>: load.f64 0.200000
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: cgt.f64
	<.main+?>: dup.x64 sp(1)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: sub.i32
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:37: (18 bytes): testMathSign_2F: float64 := Math.sign(0.000000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: cgt.f64
	<.main+?>: dup.x64 sp(1)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: sub.i32
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:38: (26 bytes): testMathSign_3F: float64 := Math.sign(-0.900000)
	<.main+?>: load.f64 -0.900000
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: cgt.f64
	<.main+?>: dup.x64 sp(1)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: sub.i32
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:39: (17 bytes): testMathSign_1f: float64 := Math.sign(0.200000)
	<.main+?>: load.f32 0.200000
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: cgt.f32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: sub.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:40: (13 bytes): testMathSign_2f: float64 := Math.sign(0.000000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: cgt.f32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: sub.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:41: (17 bytes): testMathSign_3f: float64 := Math.sign(-0.900000)
	<.main+?>: load.f32 -0.900000
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: cgt.f32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: sub.i32
	<.main+?>: set.x32 sp(1)
	<.main+?>: i32.2f64
	cmplStd/test/math/test.Math.ci:43: (28 bytes): testMathAbs_1F: float64 := Math.abs(0.200000)
	<.main+?>: load.f64 0.200000
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: jz +11
	<.main+?>: dup.x64 sp(0)
	<.main+?>: neg.f64
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:44: (20 bytes): testMathAbs_2F: float64 := Math.abs(0.000000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: jz +11
	<.main+?>: dup.x64 sp(0)
	<.main+?>: neg.f64
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:45: (28 bytes): testMathAbs_3F: float64 := Math.abs(-0.900000)
	<.main+?>: load.f64 -0.900000
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: clt.f64
	<.main+?>: jz +11
	<.main+?>: dup.x64 sp(0)
	<.main+?>: neg.f64
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:46: (25 bytes): testMathAbs_1f: float64 := Math.abs(0.200000)
	<.main+?>: load.f32 0.200000
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: jz +11
	<.main+?>: dup.x32 sp(0)
	<.main+?>: neg.f32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:47: (21 bytes): testMathAbs_2f: float64 := Math.abs(0.000000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: jz +11
	<.main+?>: dup.x32 sp(0)
	<.main+?>: neg.f32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:48: (25 bytes): testMathAbs_3f: float64 := Math.abs(-0.900000)
	<.main+?>: load.f32 -0.900000
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.z32
	<.main+?>: clt.f32
	<.main+?>: jz +11
	<.main+?>: dup.x32 sp(0)
	<.main+?>: neg.f32
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:50: (35 bytes): testMathMin_1f: float64 := Math.min(1.000000, 2.000000)
	<.main+?>: load.f32 1.000000
	<.main+?>: load.f32 2.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:51: (35 bytes): testMathMax_2f: float64 := Math.max(1.000000, 2.000000)
	<.main+?>: load.f32 1.000000
	<.main+?>: load.f32 2.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:52: (42 bytes): testMathMin_1F: float64 := Math.min(1.000000, 2.000000)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: clt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:53: (42 bytes): testMathMax_2F: float64 := Math.max(1.000000, 2.000000)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: cgt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:55: (60 bytes): testMathClamp_1f: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+?>: load.f32 10.000000
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.f32 1.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:56: (67 bytes): testMathClamp_1F: float64 := Math.clamp(10.000000, 0.000000, 1.000000)
	<.main+?>: load.f64 10.000000
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: cgt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: clt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:58: (21 bytes): testMathMix_1f: float64 := Math.mix(0.000000, 2.000000, 0.500000)
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(0)
	<.main+?>: load.f32 0.500000
	<.main+?>: load.f32 2.000000
	<.main+?>: dup.x32 sp(3)
	<.main+?>: sub.f32
	<.main+?>: mul.f32
	<.main+?>: add.f32
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:59: (28 bytes): testMathMix_1F: float64 := Math.mix(0.000000, 2.000000, 0.500000)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.f64 0.500000
	<.main+?>: load.f64 2.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: sub.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:61: (97 bytes): testMathSmooth_1f: float64 := Math.smoothstep(0.000000, 1.000000, 1.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 1.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: sub.f32
	<.main+?>: load.f32 1.000000
	<.main+?>: dup.x32 sp(2)
	<.main+?>: sub.f32
	<.main+?>: div.f32
	<.main+?>: load.z32
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: cgt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: load.f32 1.000000
	<.main+?>: dup.x32 sp(1)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: clt.f32
	<.main+?>: jz +10
	<.main+?>: dup.x32 sp(1)
	<.main+?>: jmp +6
	<.main+?>: dup.x32 sp(0)
	<.main+?>: mov.x32 sp(2, 0)
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x32 sp(0)
	<.main+?>: dup.x32 sp(1)
	<.main+?>: mul.f32
	<.main+?>: load.f32 3.000000
	<.main+?>: load.f32 2.000000
	<.main+?>: dup.x32 sp(3)
	<.main+?>: mul.f32
	<.main+?>: sub.f32
	<.main+?>: mul.f32
	<.main+?>: set.x32 sp(1)
	<.main+?>: set.x32 sp(1)
	<.main+?>: f32.2f64
	cmplStd/test/math/test.Math.ci:62: (116 bytes): testMathSmooth_1F: float64 := Math.smoothstep(0.000000, 1.000000, 1.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: sub.f64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(4)
	<.main+?>: sub.f64
	<.main+?>: div.f64
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: cgt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: clt.f64
	<.main+?>: jz +10
	<.main+?>: dup.x64 sp(2)
	<.main+?>: jmp +6
	<.main+?>: dup.x64 sp(0)
	<.main+?>: mov.x64 sp(4, 0)
	<.main+?>: inc.sp(-16)
	<.main+?>: dup.x64 sp(0)
	<.main+?>: dup.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: load.f64 3.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: mul.f64
	<.main+?>: sub.f64
	<.main+?>: mul.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:64: (21 bytes): testMathMin_nan: float64 := Math.min()
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.min(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(4, 2)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:65: (106 bytes): testMathMin_1: float64 := Math.min(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+?>: load.f64 6.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 9.000000
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 8.000000
	<.main+?>: load.f64 5.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 6.000000
	<.main+?>: load.c32 9
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.min(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(22, 2)
	<.main+?>: inc.sp(-88)
	cmplStd/test/math/test.Math.ci:66: (21 bytes): testMathMax_nan: float64 := Math.max()
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.max(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(4, 2)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:67: (106 bytes): testMathMax_9: float64 := Math.max(6, 2, 5, 8, 2, 1, 9, 2, 6)
	<.main+?>: load.f64 6.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 9.000000
	<.main+?>: load.f64 1.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 8.000000
	<.main+?>: load.f64 5.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 6.000000
	<.main+?>: load.c32 9
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.max(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(22, 2)
	<.main+?>: inc.sp(-88)
	cmplStd/test/math/test.Math.ci:69: (21 bytes): testMathSum_0: float64 := Math.sum()
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(4, 2)
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:70: (34 bytes): testMathSum_1: float64 := Math.sum(1)
	<.main+?>: load.f64 1.000000
	<.main+?>: load.c32 1
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(6, 2)
	<.main+?>: inc.sp(-24)
	cmplStd/test/math/test.Math.ci:71: (43 bytes): testMathSum_3: float64 := Math.sum(1, 2)
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 1.000000
	<.main+?>: load.c32 2
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(8, 2)
	<.main+?>: inc.sp(-32)
	cmplStd/test/math/test.Math.ci:72: (115 bytes): testMathSum_55: float64 := Math.sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
	<.main+?>: load.f64 10.000000
	<.main+?>: load.f64 9.000000
	<.main+?>: load.f64 8.000000
	<.main+?>: load.f64 7.000000
	<.main+?>: load.f64 6.000000
	<.main+?>: load.f64 5.000000
	<.main+?>: load.f64 4.000000
	<.main+?>: load.f64 3.000000
	<.main+?>: load.f64 2.000000
	<.main+?>: load.f64 1.000000
	<.main+?>: load.c32 10
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.sum(values: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(24, 2)
	<.main+?>: inc.sp(-96)
	cmplStd/test/math/test.Math.ci:74: (9 bytes): testMathEval_x: float64 := 10
	<.main+?>: load.f64 10.000000
	cmplStd/test/math/test.Math.ci:75: (23 bytes): testMathEval_0: float64 := Math.eval(testMathEval_x)
	<.main+?>: load.z32
	<.main+?>: load.sp(+4)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(4)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.ref <?> ;Math.eval(x: float64, polynomial: float64[]): float64
	<.main+?>: call
	<.main+?>: mov.x64 sp(6, 4)
	<.main+?>: inc.sp(-24)
	cmplStd/test/math/test.Math.ci:76: (9 bytes): testMathEval_1: float64 := Math.eval(testMathEval_x, 1.000000)
	<.main+?>: load.f64 1.000000
	cmplStd/test/math/test.Math.ci:77: (22 bytes): testMathEval_2: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	cmplStd/test/math/test.Math.ci:78: (39 bytes): testMathEval_3: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:79: (56 bytes): testMathEval_4: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:80: (73 bytes): testMathEval_5: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:81: (90 bytes): testMathEval_6: float64 := Math.eval(testMathEval_x, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000)
	<.main+?>: dup.x64 sp(12)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: load.f64 1.000000
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:83: (30 bytes): testMathSin_f64: float64 := Math.sin(Math.pi / (2))
	<.main+?>: load.z64
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.sin(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:84: (30 bytes): testMathCos_f64: float64 := Math.cos(Math.pi / (2))
	<.main+?>: load.z64
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.cos(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:85: (30 bytes): testMathTan_f64: float64 := Math.tan(Math.pi / (4))
	<.main+?>: load.z64
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 4.000000
	<.main+?>: div.f64
	<.main+?>: load.ref <?> ;Math.tan(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:86: (72 bytes): testMathSinh_f64: float64 := Math.sinh(Math.pi / (2))
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: ceq.f64
	<.main+?>: jz +9
	<.main+?>: load.z64
	<.main+?>: jmp +42
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(4)
	<.main+?>: neg.f64
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: sub.f64
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:87: (80 bytes): testMathCosh_f64: float64 := Math.cosh(Math.pi / (2))
	<.main+?>: load.f64 3.141593
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: dup.x64 sp(0)
	<.main+?>: load.z64
	<.main+?>: ceq.f64
	<.main+?>: jz +17
	<.main+?>: load.f64 1.000000
	<.main+?>: jmp +42
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(4)
	<.main+?>: neg.f64
	<.main+?>: load.ref <?> ;Math.exp(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: add.f64
	<.main+?>: load.f64 2.000000
	<.main+?>: div.f64
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:89: (60 bytes): testMathAsin_f64: float64 := Math.asin(0.200000)
	<.main+?>: load.f64 0.200000
	<.main+?>: load.z64
	<.main+?>: dup.x64 sp(2)
	<.main+?>: load.z64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(8)
	<.main+?>: add.f64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(10)
	<.main+?>: sub.f64
	<.main+?>: mul.f64
	<.main+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:90: (59 bytes): testMathAcos_f64: float64 := Math.acos(0.200000)
	<.main+?>: load.f64 0.200000
	<.main+?>: load.z128
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(6)
	<.main+?>: add.f64
	<.main+?>: load.f64 1.000000
	<.main+?>: dup.x64 sp(8)
	<.main+?>: sub.f64
	<.main+?>: mul.f64
	<.main+?>: load.ref <?> ;Math.sqrt(x: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: load.ref <?> ;Math.atan2(arg1: float64, arg2: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Math.ci:93: (29 bytes): testMathAbsMod_f64_0a: float64 := Math.absMod(10.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 10.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:94: (20 bytes): testMathAbsMod_f64_0b: float64 := Math.absMod(0.000000, 10.000000)
	<.main+?>: load.z128
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:95: (29 bytes): testMathAbsMod_f64_0c: float64 := Math.absMod(-10.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -10.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:97: (29 bytes): testMathAbsMod_f64_9a: float64 := Math.absMod(19.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 19.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:98: (29 bytes): testMathAbsMod_f64_9b: float64 := Math.absMod(9.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 9.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:99: (29 bytes): testMathAbsMod_f64_9c: float64 := Math.absMod(-1.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -1.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:100: (29 bytes): testMathAbsMod_f64_9d: float64 := Math.absMod(-11.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -11.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:102: (29 bytes): testMathAbsMod_f64_8a: float64 := Math.absMod(18.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 18.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:103: (29 bytes): testMathAbsMod_f64_8b: float64 := Math.absMod(8.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 8.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:104: (29 bytes): testMathAbsMod_f64_8c: float64 := Math.absMod(-2.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -2.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:105: (29 bytes): testMathAbsMod_f64_8d: float64 := Math.absMod(-12.000000, 10.000000)
	<.main+?>: load.z64
	<.main+?>: load.f64 -12.000000
	<.main+?>: load.f64 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float64, mod: float64): float64
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	cmplStd/test/math/test.Math.ci:107: (21 bytes): testMathAbsMod_f32_0a: float32 := Math.absMod(10.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 10.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:108: (17 bytes): testMathAbsMod_f32_0b: float32 := Math.absMod(0.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.z32
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:109: (21 bytes): testMathAbsMod_f32_0c: float32 := Math.absMod(-10.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -10.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:111: (21 bytes): testMathAbsMod_f32_9a: float32 := Math.absMod(19.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 19.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:112: (21 bytes): testMathAbsMod_f32_9b: float32 := Math.absMod(9.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 9.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:113: (21 bytes): testMathAbsMod_f32_9c: float32 := Math.absMod(-1.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -1.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:114: (21 bytes): testMathAbsMod_f32_9d: float32 := Math.absMod(-11.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -11.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:116: (21 bytes): testMathAbsMod_f32_8a: float32 := Math.absMod(18.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 18.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:117: (21 bytes): testMathAbsMod_f32_8b: float32 := Math.absMod(8.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 8.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:118: (21 bytes): testMathAbsMod_f32_8c: float32 := Math.absMod(-2.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -2.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Math.ci:119: (21 bytes): testMathAbsMod_f32_8d: float32 := Math.absMod(-12.000000, 10.000000)
	<.main+?>: load.z32
	<.main+?>: load.f32 -12.000000
	<.main+?>: load.f32 10.000000
	<.main+?>: load.ref <?> ;Math.absMod(val: float32, mod: float32): float32
	<.main+?>: call
	<.main+?>: inc.sp(-8)
	cmplStd/test/math/test.Complex.ci:8: (26 bytes): valA: Complex := {...}
	<.main+?>: inc.sp(+16)
	cmplStd/test/math/test.Complex.ci:8: (11 bytes): valA.re := (9);
	<.main+?>: load.f64 9.000000
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Complex.ci:8: (11 bytes): valA.im := (2);
	<.main+?>: load.f64 2.000000
	<.main+?>: set.x64 sp(4)
	cmplStd/test/math/test.Complex.ci:9: (26 bytes): valB: Complex := {...}
	<.main+?>: inc.sp(+16)
	cmplStd/test/math/test.Complex.ci:9: (11 bytes): valB.re := (2);
	<.main+?>: load.f64 2.000000
	<.main+?>: set.x64 sp(2)
	cmplStd/test/math/test.Complex.ci:9: (11 bytes): valB.im := (3);
	<.main+?>: load.f64 3.000000
	<.main+?>: set.x64 sp(4)
	cmplStd/test/math/test.Complex.ci:11: (24 bytes): Neg: Complex := Neg(valA)
	<.main+?>: dup.x128 sp(4)
	<.main+?>: inc.sp(+16)
	<.main+?>: dup.x64 sp(4)
	<.main+?>: neg.f64
	<.main+?>: dup.x64 sp(8)
	<.main+?>: neg.f64
	<.main+?>: load.ref <?> ;Complex(real: float64, imaginary: float64): Complex
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: set.x128 sp(4)
	cmplStd/test/math/test.Complex.ci:12: (3 bytes): neg: Complex := neg(valA)
	<.main+?>: dup.x128 sp(8)
	<.main+?>: neg.v2d
	cmplStd/test/math/test.Complex.ci:14: (35 bytes): Add: Complex := Add(valA, valB)
	<.main+?>: dup.x128 sp(12)
	<.main+?>: dup.x128 sp(12)
	<.main+?>: inc.sp(+16)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: add.f64
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Complex(real: float64, imaginary: float64): Complex
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: mov.x128 sp(8, 0)
	<.main+?>: inc.sp(-32)
	cmplStd/test/math/test.Complex.ci:15: (5 bytes): add: Complex := add(valA, valB)
	<.main+?>: dup.x128 sp(16)
	<.main+?>: dup.x128 sp(16)
	<.main+?>: add.v2d
	cmplStd/test/math/test.Complex.ci:17: (35 bytes): Sub: Complex := Sub(valA, valB)
	<.main+?>: dup.x128 sp(20)
	<.main+?>: dup.x128 sp(20)
	<.main+?>: inc.sp(+16)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: sub.f64
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: sub.f64
	<.main+?>: load.ref <?> ;Complex(real: float64, imaginary: float64): Complex
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: mov.x128 sp(8, 0)
	<.main+?>: inc.sp(-32)
	cmplStd/test/math/test.Complex.ci:18: (5 bytes): sub: Complex := sub(valA, valB)
	<.main+?>: dup.x128 sp(24)
	<.main+?>: dup.x128 sp(24)
	<.main+?>: sub.v2d
	cmplStd/test/math/test.Complex.ci:20: (47 bytes): Mul: Complex := Mul(valA, valB)
	<.main+?>: dup.x128 sp(28)
	<.main+?>: dup.x128 sp(28)
	<.main+?>: inc.sp(+16)
	<.main+?>: dup.x64 sp(8)
	<.main+?>: dup.x64 sp(6)
	<.main+?>: mul.f64
	<.main+?>: dup.x64 sp(12)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: mul.f64
	<.main+?>: sub.f64
	<.main+?>: dup.x64 sp(10)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: mul.f64
	<.main+?>: dup.x64 sp(14)
	<.main+?>: dup.x64 sp(10)
	<.main+?>: mul.f64
	<.main+?>: add.f64
	<.main+?>: load.ref <?> ;Complex(real: float64, imaginary: float64): Complex
	<.main+?>: call
	<.main+?>: inc.sp(-16)
	<.main+?>: mov.x128 sp(8, 0)
	<.main+?>: inc.sp(-32)
	cmplStd/test/math/test.Complex.ci:21: (27 bytes): mul: Complex := mul(valA, valB)
	<.main+?>: dup.x128 sp(32)
	<.main+?>: dup.x128 sp(32)
	<.main+?>: dup.x128 sp(4)
	<.main+?>: dup.x128 sp(4)
	<.main+?>: swz.p4x zwxy(4e)
	<.main+?>: mul.v2d
	<.main+?>: add.f64
	<.main+?>: dup.x128 sp(6)
	<.main+?>: dup.x128 sp(6)
	<.main+?>: mul.v2d
	<.main+?>: swz.p4x zwxy(4e)
	<.main+?>: sub.f64
	<.main+?>: mov.x128 sp(8, 0)
	<.main+?>: inc.sp(-32)
	<.main+?>: nfc(0) ;halt(): void
}

---------- Execute: byte-code
cmplStd/test/lang/memory.ci:26: debug: val1: int64(42)
cmplStd/test/lang/memory.ci:27: debug: val2: int64(96)
cmplStd/test/lang/memory.ci:32: debug: val1: int64(0)
cmplStd/test/lang/memory.ci:33: debug: val2: int64(42)
cmplStd/test/lang/tryExec.ci:27: fatal: fatal error: NotEquals({
	message: char[*]("assertion failed"),
	expected: int32(97),
	returned: int32(77)
})
	native.code:: abortExecution(args: null)
	cmplStd/test/lang/tryExec.ci:45: tryExec(args: null, action: <abortExecution>)
	native.code:: .main
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(1)
	cmplStd/test/lang/init.method.ci:78: staticMethod(this: <?>, x: 1)
	native.code:: .main
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(1)
	cmplStd/test/lang/init.method.ci:79: virtualMethod(this: <?>, x: 1)
	native.code:: .main
cmplStd/test/lang/init.method.ci:85: debug: extension.staticMethod
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(2)
	cmplStd/test/lang/init.method.ci:87: staticMethod(this: <?>, x: 2)
	cmplStd/test/lang/init.method.ci:97: staticMethod(this: <?>, x: 2)
	native.code:: .main
cmplStd/test/lang/init.method.ci:91: debug: extension.virtualMethod
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(2)
	cmplStd/test/lang/init.method.ci:93: virtualMethod(this: <?>, x: 2)
	cmplStd/test/lang/init.method.ci:98: virtualMethod(this: <?>, x: 2)
	native.code:: .main
cmplStd/test/lang/init.method.ci:11: debug: staticMethod: int32(3)
	cmplStd/test/lang/init.method.ci:101: staticMethod(this: <?>, x: 3)
	native.code:: .main
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:102: virtualMethod(this: <?>, x: 3)
	native.code:: .main
cmplStd/test/lang/init.method.ci:41: debug: virtualMethod: int32(3)
	cmplStd/test/lang/init.method.ci:103: virtualMethod(this: <?>, x: 3)
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:4: debug: 0 == 0
	... 1 more
cmplStd/test/lang/stmt.if.ci:12: debug: 0 == 0
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:22: debug: 0 == 0
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:29: debug: t == 0: int32(0)
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:37: debug: t == 0: int32(0)
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:47: debug: t == 0: int32(0)
	native.code:: .main
cmplStd/test/lang/stmt.if.ci:51: debug: t == 0: int32(0)
	native.code:: .main
cmplStd/test/lang/stmt.for.ci:4: debug: for ( ; ; )
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(0)
cmplStd/test/lang/stmt.for.ci:9: debug: for (int i = 0; i < 2; i += 1): int32(1)
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(0)
cmplStd/test/lang/stmt.for.ci:14: debug: for (forIdx = 0; forIdx < 2; forIdx += 1): int32(1)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(2)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(3)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(4)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(5)
cmplStd/test/lang/stmt.for.ci:21: debug: for with continue: int32(6)
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(0)
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(1)
cmplStd/test/lang/stmt.for.ci:28: debug: for with break: int32(2)

---------- Globals:
typename: typename(<typename>)
void: typename(<void>)
bool: typename(<bool>)
char: typename(<char>)
int8: typename(<int8>)
int16: typename(<int16>)
int32: typename(<int32>)
int64: typename(<int64>)
uint8: typename(<uint8>)
uint16: typename(<uint16>)
uint32: typename(<uint32>)
uint64: typename(<uint64>)
float32: typename(<float32>)
float64: typename(<float64>)
pointer: typename(<pointer>)
variant: typename(<variant>)
function: typename(<function>)
object: typename(<object>)
.cstr: typename(<.cstr>)
emit.p4x: typename(<emit.p4x>)
emit.dup: typename(<emit.dup>)
emit.load: typename(<emit.load>)
emit.store: typename(<emit.store>)
emit.cmt: typename(<emit.cmt>)
emit.and: typename(<emit.and>)
emit.or: typename(<emit.or>)
emit.xor: typename(<emit.xor>)
emit.shl: typename(<emit.shl>)
emit.shr: typename(<emit.shr>)
emit.neg: typename(<emit.neg>)
emit.add: typename(<emit.add>)
emit.sub: typename(<emit.sub>)
emit.mul: typename(<emit.mul>)
emit.div: typename(<emit.div>)
emit.mod: typename(<emit.mod>)
emit.ceq: typename(<emit.ceq>)
emit.clt: typename(<emit.clt>)
emit.cgt: typename(<emit.cgt>)
emit.min: typename(<emit.min>)
emit.max: typename(<emit.max>)
emit.swz: typename(<emit.swz>)
emit: typename(<emit>)
System.Platform: typename(<System.Platform>)
System: typename(<System>)
cmplStd/lib/lang/Debug.ci:32: NotEquals: typename(<NotEquals>)
cmplStd/lib/lang/Debug.ci:44: NotEquals: function(<NotEquals>)
cmplStd/lib/lang/Debug.ci:59: assertEq: function(<assertEq>)
cmplStd/lib/math/Bits.ci:40: Bits.zxt32: function(<Bits.zxt32>)
cmplStd/lib/math/Bits.ci:50: Bits.sxt32: function(<Bits.sxt32>)
cmplStd/lib/math/Bits.ci:60: Bits.zxt64: function(<Bits.zxt64>)
cmplStd/lib/math/Bits.ci:70: Bits.sxt64: function(<Bits.sxt64>)
cmplStd/lib/math/Bits.ci:80: Bits.swapBytes: function(<Bits.swapBytes>)
cmplStd/lib/math/Bits.ci:88: Bits.swapBytes: function(<Bits.swapBytes>)
cmplStd/lib/math/Bits.ci:95: Bits.swapBytes: function(<Bits.swapBytes>)
cmplStd/lib/math/Bits.ci:110: Bits.scanReverse: function(<Bits.scanReverse>)
cmplStd/lib/math/Bits.ci:150: Bits.scanReverse: function(<Bits.scanReverse>)
cmplStd/lib/math/Bits.ci:186: Bits.scanReverse: function(<Bits.scanReverse>)
cmplStd/lib/math/Bits.ci:214: Bits.scanReverse: function(<Bits.scanReverse>)
cmplStd/lib/math/Bits.ci:239: Bits.scanForward: function(<Bits.scanForward>)
cmplStd/lib/math/Bits.ci:280: Bits.scanForward: function(<Bits.scanForward>)
cmplStd/lib/math/Bits.ci:317: Bits.scanForward: function(<Bits.scanForward>)
cmplStd/lib/math/Bits.ci:345: Bits.scanForward: function(<Bits.scanForward>)
cmplStd/lib/math/Bits.ci:370: Bits.keepMsb: function(<Bits.keepMsb>)
cmplStd/lib/math/Bits.ci:389: Bits.keepMsb: function(<Bits.keepMsb>)
cmplStd/lib/math/Bits.ci:433: Bits.countOnes: function(<Bits.countOnes>)
cmplStd/lib/math/Bits.ci:452: Bits.countOnes: function(<Bits.countOnes>)
cmplStd/lib/math/Bits.ci:471: Bits.swapBits: function(<Bits.swapBits>)
cmplStd/lib/math/Bits.ci:489: Bits.swapBits: function(<Bits.swapBits>)
cmplStd/lib/math/Bits.ci:506: Bits.swapBits: function(<Bits.swapBits>)
cmplStd/lib/math/Bits.ci:517: Bits.swapBits: function(<Bits.swapBits>)
cmplStd/lib/math/Bits.ci:528: Bits.clamp: function(<Bits.clamp>)
cmplStd/lib/math/Bits.ci:537: Bits.clamp: function(<Bits.clamp>)
cmplStd/lib/math/Bits.ci:2: Bits: typename(<Bits>)
cmplStd/lib/math/Math.ci:23: Math.isNan: function(<Math.isNan>)
cmplStd/lib/math/Math.ci:29: Math.isInf: function(<Math.isInf>)
cmplStd/lib/math/Math.ci:34: Math.isFinite: function(<Math.isFinite>)
cmplStd/lib/math/Math.ci:40: Math.isInf: function(<Math.isInf>)
cmplStd/lib/math/Math.ci:52: Math.floor: function(<Math.floor>)
cmplStd/lib/math/Math.ci:61: Math.floor: function(<Math.floor>)
cmplStd/lib/math/Math.ci:102: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math/Math.ci:110: Math.absMod: function(<Math.absMod>)
cmplStd/lib/math/Math.ci:209: Math.min: function(<Math.min>)
cmplStd/lib/math/Math.ci:223: Math.max: function(<Math.max>)
cmplStd/lib/math/Math.ci:237: Math.sum: function(<Math.sum>)
cmplStd/lib/math/Math.ci:246: Math.mean: function(<Math.mean>)
cmplStd/lib/math/Math.ci:269: Math.eval: function(<Math.eval>)
cmplStd/lib/math/Math.ci:278: Math.modf: function(<Math.modf>)
cmplStd/lib/math/Math.ci:293: Math.copysign: function(<Math.copysign>)
cmplStd/lib/math/Math.ci:309: Math.frexp: function(<Math.frexp>)
cmplStd/lib/math/Math.ci:350: Math.ldexp: function(<Math.ldexp>)
cmplStd/lib/math/Math.ci:397: Math.log: function(<Math.log>)
cmplStd/lib/math/Math.ci:444: Math.log: function(<Math.log>)
cmplStd/lib/math/Math.ci:465: Math.exp: function(<Math.exp>)
cmplStd/lib/math/Math.ci:521: Math.exp: function(<Math.exp>)
cmplStd/lib/math/Math.ci:532: Math.sqrt: function(<Math.sqrt>)
cmplStd/lib/math/Math.ci:596: Math.sqrt: function(<Math.sqrt>)
cmplStd/lib/math/Math.ci:607: Math.pow: function(<Math.pow>)
cmplStd/lib/math/Math.ci:687: Math.pow: function(<Math.pow>)
cmplStd/lib/math/Math.ci:698: Math.sincos: function(<Math.sincos>)
cmplStd/lib/math/Math.ci:746: Math.tancot: function(<Math.tancot>)
cmplStd/lib/math/Math.ci:820: Math.atan: function(<Math.atan>)
cmplStd/lib/math/Math.ci:865: Math.atan2: function(<Math.atan2>)
cmplStd/lib/math/Math.ci:889: Math.atan2: function(<Math.atan2>)
cmplStd/lib/math/Math.ci:900: Math.sin: function(<Math.sin>)
cmplStd/lib/math/Math.ci:910: Math.sin: function(<Math.sin>)
cmplStd/lib/math/Math.ci:930: Math.cos: function(<Math.cos>)
cmplStd/lib/math/Math.ci:943: Math.cos: function(<Math.cos>)
cmplStd/lib/math/Math.ci:963: Math.tan: function(<Math.tan>)
cmplStd/lib/math/Math.ci:985: Math.tan: function(<Math.tan>)
cmplStd/lib/math/Math.ci:1002: Math.cot: function(<Math.cot>)
cmplStd/lib/math/Math.ci:2: Math: typename(<Math>)
cmplStd/lib/math/Fixed.ci:35: Fixed.as: function(<Fixed.as>)
cmplStd/lib/math/Fixed.ci:38: Fixed.neg: function(<Fixed.neg>)
cmplStd/lib/math/Fixed.ci:41: Fixed.add: function(<Fixed.add>)
cmplStd/lib/math/Fixed.ci:44: Fixed.sub: function(<Fixed.sub>)
cmplStd/lib/math/Fixed.ci:47: Fixed.mul: function(<Fixed.mul>)
cmplStd/lib/math/Fixed.ci:48: Fixed.mul: function(<Fixed.mul>)
cmplStd/lib/math/Fixed.ci:49: Fixed.mul_28: function(<Fixed.mul_28>)
cmplStd/lib/math/Fixed.ci:52: Fixed.div: function(<Fixed.div>)
cmplStd/lib/math/Fixed.ci:61: Fixed.div: function(<Fixed.div>)
cmplStd/lib/math/Fixed.ci:64: Fixed.mod: function(<Fixed.mod>)
cmplStd/lib/math/Fixed.ci:67: Fixed.inv: function(<Fixed.inv>)
cmplStd/lib/math/Fixed.ci:80: Fixed.fract: function(<Fixed.fract>)
cmplStd/lib/math/Fixed.ci:88: Fixed.floor: function(<Fixed.floor>)
cmplStd/lib/math/Fixed.ci:93: Fixed.ceil: function(<Fixed.ceil>)
cmplStd/lib/math/Fixed.ci:98: Fixed.round: function(<Fixed.round>)
cmplStd/lib/math/Fixed.ci:103: Fixed.isFinite: function(<Fixed.isFinite>)
cmplStd/lib/math/Fixed.ci:116: Fixed.isNan: function(<Fixed.isNan>)
cmplStd/lib/math/Fixed.ci:121: Fixed.compare: function(<Fixed.compare>)
cmplStd/lib/math/Fixed.ci:134: Fixed.log2: function(<Fixed.log2>)
cmplStd/lib/math/Fixed.ci:198: Fixed.log: function(<Fixed.log>)
cmplStd/lib/math/Fixed.ci:215: Fixed.log10: function(<Fixed.log10>)
cmplStd/lib/math/Fixed.ci:231: Fixed.log: function(<Fixed.log>)
cmplStd/lib/math/Fixed.ci:254: Fixed.pow2: function(<Fixed.pow2>)
cmplStd/lib/math/Fixed.ci:322: Fixed.exp: function(<Fixed.exp>)
cmplStd/lib/math/Fixed.ci:334: Fixed.exp10: function(<Fixed.exp10>)
cmplStd/lib/math/Fixed.ci:346: Fixed.sqrt: function(<Fixed.sqrt>)
cmplStd/lib/math/Fixed.ci:382: Fixed.pow: function(<Fixed.pow>)
cmplStd/lib/math/Fixed.ci:451: Fixed.sin: function(<Fixed.sin>)
cmplStd/lib/math/Fixed.ci:490: Fixed.sinh: function(<Fixed.sinh>)
cmplStd/lib/math/Fixed.ci:530: Fixed.cos: function(<Fixed.cos>)
cmplStd/lib/math/Fixed.ci:605: Fixed.tan: function(<Fixed.tan>)
cmplStd/lib/math/Fixed.ci:714: Fixed.degrees: function(<Fixed.degrees>)
cmplStd/lib/math/Fixed.ci:719: Fixed.radians: function(<Fixed.radians>)
cmplStd/lib/math/Fixed.ci:2: Fixed: typename(<Fixed>)
cmplStd/lib/math/Fixed.ci:732: Fixed: function(<Fixed>)
cmplStd/lib/math/Fixed.ci:750: float64: function(<float64>)
cmplStd/lib/math/Complex.ci:2: Complex: typename(<Complex>)
cmplStd/lib/math/Complex.ci:12: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:19: Complex: function(<Complex>)
cmplStd/lib/math/Complex.ci:54: div: function(<div>)
cmplStd/lib/math/Complex.ci:84: inv: function(<inv>)
cmplStd/lib/math/Complex.ci:102: pow: function(<pow>)
cmplStd/lib/math/Vector4f.ci:2: vec4f: typename(<vec4f>)
cmplStd/lib/math/Matrix4f.ci:2: mat4f: typename(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:62: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:75: mat4f: function(<mat4f>)
cmplStd/lib/math/Matrix4f.ci:87: transpose: function(<transpose>)
cmplStd/lib/math/Matrix4f.ci:97: mul: function(<mul>)
cmplStd/lib/math/Matrix4f.ci:109: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:158: rotation: function(<rotation>)
cmplStd/lib/math/Matrix4f.ci:191: translation: function(<translation>)
cmplStd/lib/math/Matrix4f.ci:201: scale: function(<scale>)
cmplStd/lib/math/Matrix4f.ci:213: inverse: function(<inverse>)
cmplStd/lib/math/Vector2d.ci:2: vec2d: typename(<vec2d>)
cmplStd/lib/math/Vector2d.ci:14: vec2d: function(<vec2d>)
cmplStd/lib/time/Timeunit.ci:2: Timeunit: typename(<Timeunit>)
cmplStd/lib/time/Timeunit.ci:14: convert: function(<convert>)
cmplStd/lib/time/Timeunit.ci:24: convert: function(<convert>)
cmplStd/lib/time/Duration.ci:8: Duration.precision: Timeunit(1000000)
cmplStd/lib/time/Duration.ci:11: Duration.value: function(<Duration.value>)
cmplStd/lib/time/Duration.ci:16: Duration.add: function(<Duration.add>)
cmplStd/lib/time/Duration.ci:5: Duration: typename(<Duration>)
cmplStd/lib/time/Duration.ci:22: Duration: function(<Duration>)
cmplStd/lib/time/Timestamp.ci:9: Timestamp.precision: Timeunit(1000000)
cmplStd/lib/time/Timestamp.ci:12: Timestamp.value: function(<Timestamp.value>)
cmplStd/lib/time/Timestamp.ci:17: Timestamp.diff: function(<Timestamp.diff>)
cmplStd/lib/time/Timestamp.ci:22: Timestamp.diff: function(<Timestamp.diff>)
cmplStd/lib/time/Timestamp.ci:27: Timestamp.compare: function(<Timestamp.compare>)
cmplStd/lib/time/Timestamp.ci:32: Timestamp.equal: function(<Timestamp.equal>)
cmplStd/lib/time/Timestamp.ci:37: Timestamp.equal: function(<Timestamp.equal>)
cmplStd/lib/time/Timestamp.ci:42: Timestamp.add: function(<Timestamp.add>)
cmplStd/lib/time/Timestamp.ci:55: Timestamp.floor: function(<Timestamp.floor>)
cmplStd/lib/time/Timestamp.ci:73: Timestamp.ceil: function(<Timestamp.ceil>)
cmplStd/lib/time/Timestamp.ci:94: Timestamp.distribute: function(<Timestamp.distribute>)
cmplStd/lib/time/Timestamp.ci:109: Timestamp.distribute: function(<Timestamp.distribute>)
cmplStd/lib/time/Timestamp.ci:114: Timestamp.now: function(<Timestamp.now>)
cmplStd/lib/time/Timestamp.ci:5: Timestamp: typename(<Timestamp>)
cmplStd/lib/time/Timestamp.ci:120: Timestamp: function(<Timestamp>)
cmplStd/lib/time/Timezone.ci:6: Timezone.offset: function(<Timezone.offset>)
cmplStd/lib/time/Timezone.ci:11: Timezone.utc: function(<Timezone.utc>)
cmplStd/lib/time/Timezone.ci:22: Timezone.lookup: function(<Timezone.lookup>)
cmplStd/lib/time/Timezone.ci:24: Timezone.local: function(<Timezone.local>)
cmplStd/lib/time/Timezone.ci:2: Timezone: typename(<Timezone>)
cmplStd/lib/time/Datetime.ci:2: Month: typename(<Month>)
cmplStd/lib/time/Datetime.ci:22: Weekday: typename(<Weekday>)
cmplStd/lib/time/Datetime.ci:37: Calendar: typename(<Calendar>)
cmplStd/lib/time/Datetime.ci:97: Datetime.DaysToMonth365: int32[13]([13] {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365})
cmplStd/lib/time/Datetime.ci:98: Datetime.DaysToMonth366: int32[13]([13] {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366})
cmplStd/lib/time/Datetime.ci:99: Datetime.DaysTil1970: int32(719162)
cmplStd/lib/time/Datetime.ci:102: Datetime.isLeapYear: function(<Datetime.isLeapYear>)
cmplStd/lib/time/Datetime.ci:116: Datetime.add: function(<Datetime.add>)
cmplStd/lib/time/Datetime.ci:57: Datetime: typename(<Datetime>)
cmplStd/lib/time/Datetime.ci:149: Timestamp: function(<Timestamp>)
cmplStd/lib/time/Datetime.ci:179: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:273: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:291: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:296: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:301: Datetime: function(<Datetime>)
cmplStd/lib/time/Datetime.ci:306: Datetime: function(<Datetime>)
cmplStd/lib/text/cstr.ci:4: length: function(<length>)
cmplStd/lib/text/cstr.ci:15: indexOf: function(<indexOf>)
cmplStd/lib/text/cstr.ci:25: lastIndexOf: function(<lastIndexOf>)
cmplStd/lib/text/cstr.ci:36: startsWith: function(<startsWith>)
cmplStd/lib/text/cstr.ci:46: endsWith: function(<endsWith>)
cmplStd/lib/text/cstr.ci:61: compare: function(<compare>)
cmplStd/lib/text/cstr.ci:73: ignCaseCmp: function(<ignCaseCmp>)
cmplStd/lib/text/cstr.ci:88: caseCmp: function(<caseCmp>)
cmplStd/lib/text/cstr.ci:117: float64: function(<float64>)
cmplStd/lib/text/Format.ci:19: FormatFlags.read: function(<FormatFlags.read>)
cmplStd/lib/text/Format.ci:73: FormatFlags.defPad: function(<FormatFlags.defPad>)
cmplStd/lib/text/Format.ci:2: FormatFlags: typename(<FormatFlags>)
cmplStd/lib/text/Format.ci:87: append: function(<append>)
cmplStd/lib/text/Format.ci:107: append: function(<append>)
cmplStd/lib/text/Format.ci:170: append: function(<append>)
cmplStd/lib/text/Format.ci:184: append: function(<append>)
cmplStd/lib/text/Format.ci:313: DatetimeFormat.format: function(<DatetimeFormat.format>)
cmplStd/lib/text/Format.ci:501: DatetimeFormat.format: function(<DatetimeFormat.format>)
cmplStd/lib/text/Format.ci:298: DatetimeFormat: typename(<DatetimeFormat>)
cmplStd/lib/text/Format.ci:507: format: function(<format>)
cmplStd/lib/text/Format.ci:563: append: function(<append>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/ByteStream.ci:2: Closeable: typename(<Closeable>)
cmplStd/lib/text/stream/ByteStream.ci:26: ByteReader.read: function(<ByteReader.read>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/ByteStream.ci:17: ByteReader: typename(<ByteReader>)
cmplStd/lib/text/stream/ByteStream.ci:56: ByteWriter.write: function(<ByteWriter.write>)
cmplStd/lib/text/stream/ByteStream.ci:76: ByteWriter.copy: function(<ByteWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/ByteStream.ci:44: ByteWriter: typename(<ByteWriter>)
cmplStd/lib/text/stream/ByteStream.ci:104: CopyReader.read: function(<CopyReader.read>)
cmplStd/lib/text/stream/ByteStream.ci:113: CopyReader.close: function(<CopyReader.close>)
cmplStd/lib/text/stream/ByteStream.ci:26: ByteReader.read: function(<ByteReader.read>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/ByteStream.ci:99: CopyReader: typename(<CopyReader>)
cmplStd/lib/text/stream/ByteStream.ci:126: ByteBuffer.read: function(<ByteBuffer.read>)
cmplStd/lib/text/stream/ByteStream.ci:140: ByteBuffer.read: function(<ByteBuffer.read>)
cmplStd/lib/text/stream/ByteStream.ci:149: ByteBuffer.write: function(<ByteBuffer.write>)
cmplStd/lib/text/stream/ByteStream.ci:175: ByteBuffer.flush: function(<ByteBuffer.flush>)
cmplStd/lib/text/stream/ByteStream.ci:179: ByteBuffer.close: function(<ByteBuffer.close>)
cmplStd/lib/text/stream/ByteStream.ci:120: ByteBuffer: typename(<ByteBuffer>)
cmplStd/lib/text/stream/TextStream.ci:19: TextReader.close: function(<TextReader.close>)
cmplStd/lib/text/stream/TextStream.ci:25: TextReader.decode: function(<TextReader.decode>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/TextStream.ci:7: TextReader: typename(<TextReader>)
cmplStd/lib/text/stream/TextStream.ci:50: TextWriter.Writeable: typename(<TextWriter.Writeable>)
cmplStd/lib/text/stream/TextStream.ci:67: TextWriter.flush: function(<TextWriter.flush>)
cmplStd/lib/text/stream/TextStream.ci:72: TextWriter.close: function(<TextWriter.close>)
cmplStd/lib/text/stream/TextStream.ci:78: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:84: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:90: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:98: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:105: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:112: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:119: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:126: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:133: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:140: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:146: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:151: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:168: TextWriter.copy: function(<TextWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/stream/TextStream.ci:48: TextWriter: typename(<TextWriter>)
cmplStd/lib/text/encoding/binary/Base64.ci:3: Base64Encoder.lookup: uint8[]([64] {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, ...})
cmplStd/lib/text/encoding/binary/Base64.ci:16: Base64Encoder.flushBuffer: function(<Base64Encoder.flushBuffer>)
cmplStd/lib/text/encoding/binary/Base64.ci:41: Base64Encoder.write: function(<Base64Encoder.write>)
cmplStd/lib/text/encoding/binary/Base64.ci:124: Base64Encoder.flush: function(<Base64Encoder.flush>)
cmplStd/lib/text/encoding/binary/Base64.ci:129: Base64Encoder.close: function(<Base64Encoder.close>)
cmplStd/lib/text/stream/ByteStream.ci:56: ByteWriter.write: function(<ByteWriter.write>)
cmplStd/lib/text/stream/ByteStream.ci:76: ByteWriter.copy: function(<ByteWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/binary/Base64.ci:2: Base64Encoder: typename(<Base64Encoder>)
cmplStd/lib/text/encoding/binary/Base64.ci:136: Base64Decoder.lookup: int32[256]([256] {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, ...})
cmplStd/lib/text/encoding/binary/Base64.ci:162: Base64Decoder.read: function(<Base64Decoder.read>)
cmplStd/lib/text/encoding/binary/Base64.ci:190: Base64Decoder.close: function(<Base64Decoder.close>)
cmplStd/lib/text/stream/ByteStream.ci:26: ByteReader.read: function(<ByteReader.read>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/binary/Base64.ci:135: Base64Decoder: typename(<Base64Decoder>)
cmplStd/lib/text/encoding/Ascii.ci:4: AsciiReader.decode: function(<AsciiReader.decode>)
cmplStd/lib/text/stream/TextStream.ci:19: TextReader.close: function(<TextReader.close>)
cmplStd/lib/text/stream/TextStream.ci:25: TextReader.decode: function(<TextReader.decode>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/Ascii.ci:2: AsciiReader: typename(<AsciiReader>)
cmplStd/lib/text/encoding/Ascii.ci:21: AsciiWriter.encode: function(<AsciiWriter.encode>)
cmplStd/lib/text/stream/TextStream.ci:50: TextWriter.Writeable: typename(<TextWriter.Writeable>)
cmplStd/lib/text/stream/TextStream.ci:67: TextWriter.flush: function(<TextWriter.flush>)
cmplStd/lib/text/stream/TextStream.ci:72: TextWriter.close: function(<TextWriter.close>)
cmplStd/lib/text/stream/TextStream.ci:78: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:84: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:90: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:98: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:105: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:112: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:119: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:126: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:133: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:140: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:146: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:151: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:168: TextWriter.copy: function(<TextWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/Ascii.ci:19: AsciiWriter: typename(<AsciiWriter>)
cmplStd/lib/text/encoding/Utf8.ci:4: Utf8Reader.decode: function(<Utf8Reader.decode>)
cmplStd/lib/text/stream/TextStream.ci:19: TextReader.close: function(<TextReader.close>)
cmplStd/lib/text/stream/TextStream.ci:25: TextReader.decode: function(<TextReader.decode>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/Utf8.ci:2: Utf8Reader: typename(<Utf8Reader>)
cmplStd/lib/text/encoding/Utf8.ci:53: Utf8Writer.encode: function(<Utf8Writer.encode>)
cmplStd/lib/text/stream/TextStream.ci:50: TextWriter.Writeable: typename(<TextWriter.Writeable>)
cmplStd/lib/text/stream/TextStream.ci:67: TextWriter.flush: function(<TextWriter.flush>)
cmplStd/lib/text/stream/TextStream.ci:72: TextWriter.close: function(<TextWriter.close>)
cmplStd/lib/text/stream/TextStream.ci:78: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:84: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:90: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:98: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:105: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:112: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:119: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:126: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:133: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:140: TextWriter.write: function(<TextWriter.write>)
cmplStd/lib/text/stream/TextStream.ci:146: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:151: TextWriter.writeln: function(<TextWriter.writeln>)
cmplStd/lib/text/stream/TextStream.ci:168: TextWriter.copy: function(<TextWriter.copy>)
cmplStd/lib/text/stream/ByteStream.ci:7: Closeable.closeSafe: function(<Closeable.closeSafe>)
cmplStd/lib/text/encoding/Utf8.ci:51: Utf8Writer: typename(<Utf8Writer>)
cmplStd/lib/math/Easing.ci:6: Easing.linear: function(<Easing.linear>)
cmplStd/lib/math/Easing.ci:11: Easing.quad: function(<Easing.quad>)
cmplStd/lib/math/Easing.ci:16: Easing.cubic: function(<Easing.cubic>)
cmplStd/lib/math/Easing.ci:21: Easing.quart: function(<Easing.quart>)
cmplStd/lib/math/Easing.ci:26: Easing.quint: function(<Easing.quint>)
cmplStd/lib/math/Easing.ci:31: Easing.expo: function(<Easing.expo>)
cmplStd/lib/math/Easing.ci:36: Easing.sine: function(<Easing.sine>)
cmplStd/lib/math/Easing.ci:41: Easing.circle: function(<Easing.circle>)
cmplStd/lib/math/Easing.ci:46: Easing.elastic: function(<Easing.elastic>)
cmplStd/lib/math/Easing.ci:53: Easing.back: function(<Easing.back>)
cmplStd/lib/math/Easing.ci:59: Easing.bounce: function(<Easing.bounce>)
cmplStd/lib/math/Easing.ci:4: Easing: typename(<Easing>)
cmplStd/lib/math/Easing.ci:84: in: function(<in>)
cmplStd/lib/math/Easing.ci:92: out: function(<out>)
cmplStd/lib/math/Easing.ci:100: inOut: function(<inOut>)
cmplStd/lib/math/Easing.ci:109: outIn: function(<outIn>)
cmplStd/lib/math/Polynomial.ci:14: Polynomial.write: function(<Polynomial.write>)
cmplStd/lib/math/Polynomial.ci:54: Polynomial.destroy: function(<Polynomial.destroy>)
cmplStd/lib/math/Polynomial.ci:59: Polynomial.create: function(<Polynomial.create>)
cmplStd/lib/math/Polynomial.ci:79: Polynomial.degree: function(<Polynomial.degree>)
cmplStd/lib/math/Polynomial.ci:89: Polynomial.get: function(<Polynomial.get>)
cmplStd/lib/math/Polynomial.ci:98: Polynomial.set: function(<Polynomial.set>)
cmplStd/lib/math/Polynomial.ci:105: Polynomial.neg: function(<Polynomial.neg>)
cmplStd/lib/math/Polynomial.ci:114: Polynomial.add: function(<Polynomial.add>)
cmplStd/lib/math/Polynomial.ci:123: Polynomial.sub: function(<Polynomial.sub>)
cmplStd/lib/math/Polynomial.ci:132: Polynomial.mul: function(<Polynomial.mul>)
cmplStd/lib/math/Polynomial.ci:145: Polynomial.evaluate: function(<Polynomial.evaluate>)
cmplStd/lib/math/Polynomial.ci:154: Polynomial.derivative: function(<Polynomial.derivative>)
cmplStd/lib/math/Polynomial.ci:163: Polynomial.integral: function(<Polynomial.integral>)
cmplStd/lib/math/Polynomial.ci:4: Polynomial: typename(<Polynomial>)
cmplStd/lib/math/Polynomial.ci:177: Polynomial: function(<Polynomial>)
cmplStd/test/lang/emit.ci:3: emitldz32: int32(0)
cmplStd/test/lang/emit.ci:4: emitldz64: int64(0)
cmplStd/test/lang/emit.ci:6: emitA: int32(42)
cmplStd/test/lang/emit.ci:7: emitB: int32(96)
cmplStd/test/lang/emit.ci:10: emitAddI32: int32(138)
cmplStd/test/lang/emit.ci:13: emitDivI32: int32(2)
cmplStd/test/lang/emit.ci:16: emitNfcF32: float32(1.000000)
cmplStd/test/lang/emit.ci:23: emitFloatAsInt1: int32(1140457472)
cmplStd/test/lang/emit.ci:24: emitFloatAsInt2: int64(1140457472)
cmplStd/test/lang/emit.ci:25: emitFloatAsInt3: int32(0)
cmplStd/test/lang/emit.ci:26: emitFloatAsInt4: int64(4647503709213818880)
cmplStd/test/lang/emit.ci:30: emitSlice: char[]([3] {'s', 't', 'r'})
cmplStd/test/lang/inlineMacros.ci:10: i3: int32(3)
cmplStd/test/lang/inlineMacros.ci:11: i6: int32(6)
cmplStd/test/lang/inlineMacros.ci:12: i2: int32(2)
cmplStd/test/lang/inlineMacros.ci:13: i8: int32(8)
cmplStd/test/lang/inlineMacros.ci:15: zeroVal: int32(0)
cmplStd/test/lang/inlineMacros.ci:16: zeroVar: int32(0)
cmplStd/test/lang/inlineMacros.ci:17: zeroXpr: int32(0)
cmplStd/test/lang/inlineMacros.ci:19: lastVal: int32(6)
cmplStd/test/lang/inlineMacros.ci:20: lastVar: int32(6)
cmplStd/test/lang/inlineMacros.ci:21: lastXpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:23: sum2Val: int32(9)
cmplStd/test/lang/inlineMacros.ci:24: sum2Var: int32(9)
cmplStd/test/lang/inlineMacros.ci:25: sum2Xpr: int32(9)
cmplStd/test/lang/inlineMacros.ci:27: any2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:28: any2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:29: any2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:31: min2Val: int32(3)
cmplStd/test/lang/inlineMacros.ci:32: min2Var: int32(3)
cmplStd/test/lang/inlineMacros.ci:33: min2Xpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:35: max2Val: int32(6)
cmplStd/test/lang/inlineMacros.ci:36: max2Var: int32(6)
cmplStd/test/lang/inlineMacros.ci:37: max2Xpr: int32(6)
cmplStd/test/lang/inlineMacros.ci:41: sumRlVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:42: sumLrVal: int32(19)
cmplStd/test/lang/inlineMacros.ci:43: sumRlVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:44: sumLrVar: int32(19)
cmplStd/test/lang/inlineMacros.ci:45: sumRlXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:46: sumLrXpr: int32(19)
cmplStd/test/lang/inlineMacros.ci:50: anyRlVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:51: anyLrVal: int32(3)
cmplStd/test/lang/inlineMacros.ci:52: anyRlVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:53: anyLrVar: int32(3)
cmplStd/test/lang/inlineMacros.ci:54: anyRlXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:55: anyLrXpr: int32(3)
cmplStd/test/lang/inlineMacros.ci:59: minRlVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:60: minLrVal: int32(2)
cmplStd/test/lang/inlineMacros.ci:61: minRlVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:62: minLrVar: int32(2)
cmplStd/test/lang/inlineMacros.ci:63: minRlXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:64: minLrXpr: int32(2)
cmplStd/test/lang/inlineMacros.ci:68: maxRlVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:69: maxLrVal: int32(8)
cmplStd/test/lang/inlineMacros.ci:70: maxRlVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:71: maxLrVar: int32(8)
cmplStd/test/lang/inlineMacros.ci:72: maxRlXpr: int32(8)
cmplStd/test/lang/inlineMacros.ci:73: maxLrXpr: int32(8)
cmplStd/test/lang/overload.inline.ci:9: overload1: float32(1.000000)
cmplStd/test/lang/overload.inline.ci:10: overload2: float32(2.000000)
cmplStd/test/lang/overload.inline.ci:11: overload3: float32(3.000000)
cmplStd/test/lang/overload.inline.ci:12: overload4: float32(4.000000)
cmplStd/test/lang/overload.inline.ci:13: overload5: float32(5.000000)
cmplStd/test/lang/overload.inline.ci:15: Celsius: typename(<Celsius>)
cmplStd/test/lang/overload.inline.ci:16: Fahrenheit: typename(<Fahrenheit>)
cmplStd/test/lang/overload.inline.ci:28: boilC: Celsius({
	degrees: float64(100.000000)
})
cmplStd/test/lang/overload.inline.ci:29: boilF: Fahrenheit({
	degrees: float64(212.000000)
})
cmplStd/test/lang/memory.ci:7: p1: pointer(<?>)
cmplStd/test/lang/memory.ci:8: p2: pointer(<?>)
cmplStd/test/lang/memory.ci:9: p3: pointer(<?>)
cmplStd/test/lang/memory.ci:10: p4: pointer(<?>)
cmplStd/test/lang/memory.ci:23: val1: int64(0)
cmplStd/test/lang/memory.ci:24: val2: int64(42)
cmplStd/test/lang/tryExec.ci:3: noError: function(<noError>)
cmplStd/test/lang/tryExec.ci:6: stackOverflow: function(<stackOverflow>)
cmplStd/test/lang/tryExec.ci:12: divisionByZero: function(<divisionByZero>)
cmplStd/test/lang/tryExec.ci:16: abortExecution: function(<abortExecution>)
cmplStd/test/lang/tryExec.ci:30: invalidMemoryAccess: function(<invalidMemoryAccess>)
cmplStd/test/lang/tryExec.ci:35: invalidInstruction: function(<invalidInstruction>)
cmplStd/test/lang/tryExec.ci:39: tryExecErr0: int32(0)
cmplStd/test/lang/tryExec.ci:40: tryExecErr1: int32(1)
cmplStd/test/lang/tryExec.ci:41: tryExecErr2: int32(2)
cmplStd/test/lang/tryExec.ci:42: tryExecErr3: int32(3)
cmplStd/test/lang/tryExec.ci:43: tryExecErr4: int32(4)
cmplStd/test/lang/tryExec.ci:44: tryExecErr5: int32(5)
cmplStd/test/lang/tryExec.ci:45: tryExecErr6: int32(6)
cmplStd/test/lang/pointer.ci:1: arr: int32[5]([5] {1, 2, 3, 4, 5})
cmplStd/test/lang/pointer.ci:2: ptr: pointer(<?>)
cmplStd/test/lang/pointer.ci:3: a0: int32(1)
cmplStd/test/lang/pointer.ci:4: a1: int32(2)
cmplStd/test/lang/pointer.ci:5: a2: int32(3)
cmplStd/test/lang/pointer.ci:6: a3: int32(4)
cmplStd/test/lang/pointer.ci:7: a4: int32(5)
cmplStd/test/lang/init.reference.ci:7: value: int64(42)
cmplStd/test/lang/init.reference.ci:8: valueRef: int64(42)
cmplStd/test/lang/init.reference.ci:9: valuePtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:10: valueVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:12: fromRef: int64(42)
cmplStd/test/lang/init.reference.ci:13: fromPtr: int64(42)
cmplStd/test/lang/init.reference.ci:14: fromVar: int64(42)
cmplStd/test/lang/init.reference.ci:16: nullRef: int64(null)
cmplStd/test/lang/init.reference.ci:17: nullPtr: pointer(null)
cmplStd/test/lang/init.reference.ci:18: nullVar: variant(null)
cmplStd/test/lang/init.reference.ci:19: nullTyp: typename(null)
cmplStd/test/lang/init.reference.ci:20: nullFun: function(null)
cmplStd/test/lang/init.reference.ci:21: nullObj: object(null)
cmplStd/test/lang/init.reference.ci:23: typePtr: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:24: typeVar: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:25: typeTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:27: local: int64(42)
cmplStd/test/lang/init.reference.ci:28: copyVal: int64(42)
cmplStd/test/lang/init.reference.ci:29: copyRef: int64(42)
cmplStd/test/lang/init.reference.ci:30: copyPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:31: copyVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:32: copyTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:35: ptrVoid: pointer(<void>)
cmplStd/test/lang/init.reference.ci:36: ptrBool: pointer(<bool>)
cmplStd/test/lang/init.reference.ci:37: ptrChar: pointer(<char>)
cmplStd/test/lang/init.reference.ci:38: ptrInt8: pointer(<int8>)
cmplStd/test/lang/init.reference.ci:39: ptrInt16: pointer(<int16>)
cmplStd/test/lang/init.reference.ci:40: ptrInt32: pointer(<int32>)
cmplStd/test/lang/init.reference.ci:41: ptrInt64: pointer(<int64>)
cmplStd/test/lang/init.reference.ci:42: ptrUint8: pointer(<uint8>)
cmplStd/test/lang/init.reference.ci:43: ptrUint16: pointer(<uint16>)
cmplStd/test/lang/init.reference.ci:44: ptrUint32: pointer(<uint32>)
cmplStd/test/lang/init.reference.ci:45: ptrUint64: pointer(<uint64>)
cmplStd/test/lang/init.reference.ci:46: ptrFloat32: pointer(<float32>)
cmplStd/test/lang/init.reference.ci:47: ptrFloat64: pointer(<float64>)
cmplStd/test/lang/init.reference.ci:48: ptrTypename: pointer(<typename>)
cmplStd/test/lang/init.reference.ci:49: ptrFunction: pointer(<function>)
cmplStd/test/lang/init.reference.ci:50: ptrPointer: pointer(<pointer>)
cmplStd/test/lang/init.reference.ci:51: ptrVariant: pointer(<variant>)
cmplStd/test/lang/init.reference.ci:52: ptrObject: pointer(<object>)
cmplStd/test/lang/init.reference.ci:55: varVoid: variant(typename: <void>)
cmplStd/test/lang/init.reference.ci:56: varBool: variant(typename: <bool>)
cmplStd/test/lang/init.reference.ci:57: varChar: variant(typename: <char>)
cmplStd/test/lang/init.reference.ci:58: varInt8: variant(typename: <int8>)
cmplStd/test/lang/init.reference.ci:59: varInt16: variant(typename: <int16>)
cmplStd/test/lang/init.reference.ci:60: varInt32: variant(typename: <int32>)
cmplStd/test/lang/init.reference.ci:61: varInt64: variant(typename: <int64>)
cmplStd/test/lang/init.reference.ci:62: varUint8: variant(typename: <uint8>)
cmplStd/test/lang/init.reference.ci:63: varUint16: variant(typename: <uint16>)
cmplStd/test/lang/init.reference.ci:64: varUint32: variant(typename: <uint32>)
cmplStd/test/lang/init.reference.ci:65: varUint64: variant(typename: <uint64>)
cmplStd/test/lang/init.reference.ci:66: varFloat32: variant(typename: <float32>)
cmplStd/test/lang/init.reference.ci:67: varFloat64: variant(typename: <float64>)
cmplStd/test/lang/init.reference.ci:68: varTypename: variant(typename: <typename>)
cmplStd/test/lang/init.reference.ci:69: varFunction: variant(typename: <function>)
cmplStd/test/lang/init.reference.ci:70: varPointer: variant(typename: <pointer>)
cmplStd/test/lang/init.reference.ci:71: varVariant: variant(typename: <variant>)
cmplStd/test/lang/init.reference.ci:72: varObject: variant(typename: <object>)
cmplStd/test/lang/init.reference.ci:75: typVoid: typename(<void>)
cmplStd/test/lang/init.reference.ci:76: typBool: typename(<bool>)
cmplStd/test/lang/init.reference.ci:77: typChar: typename(<char>)
cmplStd/test/lang/init.reference.ci:78: typInt8: typename(<int8>)
cmplStd/test/lang/init.reference.ci:79: typInt16: typename(<int16>)
cmplStd/test/lang/init.reference.ci:80: typInt32: typename(<int32>)
cmplStd/test/lang/init.reference.ci:81: typInt64: typename(<int64>)
cmplStd/test/lang/init.reference.ci:82: typUint8: typename(<uint8>)
cmplStd/test/lang/init.reference.ci:83: typUint16: typename(<uint16>)
cmplStd/test/lang/init.reference.ci:84: typUint32: typename(<uint32>)
cmplStd/test/lang/init.reference.ci:85: typUint64: typename(<uint64>)
cmplStd/test/lang/init.reference.ci:86: typFloat32: typename(<float32>)
cmplStd/test/lang/init.reference.ci:87: typFloat64: typename(<float64>)
cmplStd/test/lang/init.reference.ci:88: typTypename: typename(<typename>)
cmplStd/test/lang/init.reference.ci:89: typFunction: typename(<function>)
cmplStd/test/lang/init.reference.ci:90: typPointer: typename(<pointer>)
cmplStd/test/lang/init.reference.ci:91: typVariant: typename(<variant>)
cmplStd/test/lang/init.reference.ci:92: typObject: typename(<object>)
cmplStd/test/lang/init.reference.ci:95: valueOfPtr: pointer(<value>)
cmplStd/test/lang/init.reference.ci:96: valueOfVar: variant(int64: 42)
cmplStd/test/lang/init.reference.ci:97: valueOfTyp: typename(<int64>)
cmplStd/test/lang/init.reference.ci:99: typeOfValue: typename(<int64>)
cmplStd/test/lang/init.reference.ci:105: copyPtrFloat64: variant(pointer: <float64>)
cmplStd/test/lang/init.reference.ci:108: copyVarFloat64: pointer(<float64>)
cmplStd/test/lang/init.variable.ci:3: variable: int32(0)
cmplStd/test/lang/init.variable.ci:7: constant: int32(42)
cmplStd/test/lang/init.variable.ci:9: ComplexVal: typename(<ComplexVal>)
cmplStd/test/lang/init.variable.ci:13: ComplexObj: typename(<ComplexObj>)
cmplStd/test/lang/init.variable.ci:24: valInitImplicit: ComplexVal({
	re: float64(8.000000),
	im: float64(0.000000)
})
cmplStd/test/lang/init.variable.ci:33: objInitImplicit: ComplexObj({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/init.variable.ci:41: objInitExplicit: object({
	re: float64(8.000000),
	im: float64(0.000000),
	.type: typename(<ComplexObj>)
})
cmplStd/test/lang/function.ci:4: empty: function(<empty>)
cmplStd/test/lang/function.ci:7: funAdd: function(<funAdd>)
cmplStd/test/lang/function.ci:12: funAddResult: int32(9)
cmplStd/test/lang/function.ci:15: funAddRef: function(<funAdd>)
cmplStd/test/lang/function.ci:18: funAddRefResult: int32(10)
cmplStd/test/lang/function.ci:21: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:24: funMulResult: int32(12)
cmplStd/test/lang/function.ci:27: funMulRef: function(<funMul>)
cmplStd/test/lang/function.ci:30: funMulRefResult: int32(14)
cmplStd/test/lang/function.ci:33: funMul: function(<funMul>)
cmplStd/test/lang/function.ci:38: fib: function(<fib>)
cmplStd/test/lang/function.ci:46: fibonacci_13: uint32(233)
cmplStd/test/lang/reflect.ci:3: sizeofVoid: int32(0)
cmplStd/test/lang/reflect.ci:4: sizeofBool: int32(1)
cmplStd/test/lang/reflect.ci:5: sizeofChar: int32(1)
cmplStd/test/lang/reflect.ci:6: sizeofInt8: int32(1)
cmplStd/test/lang/reflect.ci:7: sizeofInt16: int32(2)
cmplStd/test/lang/reflect.ci:8: sizeofInt32: int32(4)
cmplStd/test/lang/reflect.ci:9: sizeofInt64: int32(8)
cmplStd/test/lang/reflect.ci:10: sizeofUint8: int32(1)
cmplStd/test/lang/reflect.ci:11: sizeofUint16: int32(2)
cmplStd/test/lang/reflect.ci:12: sizeofUint32: int32(4)
cmplStd/test/lang/reflect.ci:13: sizeofUint64: int32(8)
cmplStd/test/lang/reflect.ci:14: sizeofFloat32: int32(4)
cmplStd/test/lang/reflect.ci:15: sizeofFloat64: int32(8)
cmplStd/test/lang/reflect.ci:16: sizeofPointer: int32(4)
cmplStd/test/lang/reflect.ci:17: sizeofVariant: int32(8)
cmplStd/test/lang/reflect.ci:18: sizeofTypename: int32(4)
cmplStd/test/lang/reflect.ci:19: sizeofFunction: int32(4)
cmplStd/test/lang/reflect.ci:20: sizeofObject: int32(4)
cmplStd/test/lang/reflect.ci:22: RecordSizeof: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:26: RecordSizeofExt: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:30: typeofRecord: typename(<RecordSizeofExt>)
cmplStd/test/lang/reflect.ci:31: nameOfRecord: char[*]("RecordSizeofExt")
cmplStd/test/lang/reflect.ci:32: offsetOfRecord: int32(585288)
cmplStd/test/lang/reflect.ci:33: sizeOfRecord: int32(16)
cmplStd/test/lang/reflect.ci:34: fileOfRecord: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:35: lineOfRecord: int32(26)
cmplStd/test/lang/reflect.ci:37: typeofBase: typename(<RecordSizeof>)
cmplStd/test/lang/reflect.ci:38: nameOfBase: char[*]("RecordSizeof")
cmplStd/test/lang/reflect.ci:39: offsetOfBase: int32(584968)
cmplStd/test/lang/reflect.ci:40: sizeOfBase: int32(12)
cmplStd/test/lang/reflect.ci:41: fileOfBase: char[*]("cmplStd/test/lang/reflect.ci")
cmplStd/test/lang/reflect.ci:42: lineOfBase: int32(22)
cmplStd/test/lang/reflect.ci:44: typeofBase1: typename(<object>)
cmplStd/test/lang/reflect.ci:45: offsetOfBase1: int32(2880)
cmplStd/test/lang/reflect.ci:46: sizeOfBase1: int32(4)
cmplStd/test/lang/reflect.ci:48: typeofBase2: typename(<typename>)
cmplStd/test/lang/reflect.ci:49: offsetOfBase2: int32(8)
cmplStd/test/lang/reflect.ci:50: sizeOfBase2: int32(160)
cmplStd/test/lang/init.member.ci:4: RecordMemberTest.Inner: typename(<RecordMemberTest.Inner>)
cmplStd/test/lang/init.member.ci:34: RecordMemberTest.global: int32(0)
cmplStd/test/lang/init.member.ci:37: RecordMemberTest.globalInit: int32(1)
cmplStd/test/lang/init.member.ci:40: RecordMemberTest.globalConstant: int32(2)
cmplStd/test/lang/init.member.ci:43: RecordMemberTest.globalRec: Inner({
	member: int32(0),
	constant: int32(4)
})
cmplStd/test/lang/init.member.ci:46: RecordMemberTest.globalRecInit: Inner({
	member: int32(4),
	constant: int32(5)
})
cmplStd/test/lang/init.member.ci:49: RecordMemberTest.globalConstantRec: Inner({
	member: int32(6),
	constant: int32(7)
})
cmplStd/test/lang/init.member.ci:2: RecordMemberTest: typename(<RecordMemberTest>)
cmplStd/test/lang/init.member.ci:52: recordMemberTest: RecordMemberTest({
	member: int32(10),
	constant: int32(11),
	memberInit: int32(12),
	constantInit: int32(13),
	memberRec: Inner({
		member: int32(14),
		constant: int32(15)
	}),
	constantRec: Inner({
		member: int32(16),
		constant: int32(17)
	})
})
cmplStd/test/lang/init.method.ci:10: RecordMethodTest.staticMethod: function(<RecordMethodTest.staticMethod>)
cmplStd/test/lang/init.method.ci:18: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:40: RecordMethodTest.virtualMethod: function(<RecordMethodTest.virtualMethod>)
cmplStd/test/lang/init.method.ci:47: RecordMethodTest.forwardMethod: function(<RecordMethodTest.forwardMethod>)
cmplStd/test/lang/init.method.ci:4: RecordMethodTest: typename(<RecordMethodTest>)
cmplStd/test/lang/init.method.ci:57: globalFunction: function(<globalFunction>)
cmplStd/test/lang/init.method.ci:62: recordMethodTest: RecordMethodTest({
	abstractMethod: function(<globalFunction>),
	delegateMethod: function(<RecordMethodTest.forwardMethod>),
	virtualMethod: function(<RecordMethodTest.virtualMethod>)
})
cmplStd/test/lang/init.method.ci:84: staticMethod: function(<staticMethod>)
cmplStd/test/lang/init.method.ci:90: virtualMethod: function(<virtualMethod>)
cmplStd/test/lang/recUnion.ci:2: rgbF32: typename(<rgbF32>)
cmplStd/test/lang/recUnion.ci:9: rgbU8: typename(<rgbU8>)
cmplStd/test/lang/recUnion.ci:16: color: typename(<color>)
cmplStd/test/lang/recUnion.ci:22: Color: typename(<Color>)
cmplStd/test/lang/recUnion.ci:26: black: rgbU8({
	b: uint8(0),
	g: uint8(0),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:27: green: rgbU8({
	b: uint8(0),
	g: uint8(255),
	r: uint8(0)
})
cmplStd/test/lang/recUnion.ci:28: white: rgbU8({
	b: uint8(255),
	g: uint8(255),
	r: uint8(255)
})
cmplStd/test/lang/recUnion.ci:30: cyan: color({
	col: uint32(65535)
})
cmplStd/test/lang/recUnion.ci:31: blue: color({
	col: uint32(255)
})
cmplStd/test/lang/recPacking.ci:2: record_pack0: typename(<record_pack0>)
cmplStd/test/lang/recPacking.ci:12: record_pack1: typename(<record_pack1>)
cmplStd/test/lang/recPacking.ci:22: record_pack2: typename(<record_pack2>)
cmplStd/test/lang/recPacking.ci:32: record_pack4: typename(<record_pack4>)
cmplStd/test/lang/recPacking.ci:42: record_pack8: typename(<record_pack8>)
cmplStd/test/lang/recPacking.ci:52: record_packDef: typename(<record_packDef>)
cmplStd/test/lang/useOperator.ci:5: shift: int32(2)
cmplStd/test/lang/useOperator.ci:7: boolA: bool(1)
cmplStd/test/lang/useOperator.ci:8: boolB: bool(1)
cmplStd/test/lang/useOperator.ci:17: boolAnd: bool(1)
cmplStd/test/lang/useOperator.ci:18: boolIor: bool(1)
cmplStd/test/lang/useOperator.ci:19: boolXor: bool(0)
cmplStd/test/lang/useOperator.ci:22: boolNot: bool(0)
cmplStd/test/lang/useOperator.ci:23: boolCeq: bool(1)
cmplStd/test/lang/useOperator.ci:24: boolCne: bool(0)
cmplStd/test/lang/useOperator.ci:25: boolClt: bool(0)
cmplStd/test/lang/useOperator.ci:26: boolCle: bool(1)
cmplStd/test/lang/useOperator.ci:27: boolCgt: bool(0)
cmplStd/test/lang/useOperator.ci:28: boolCge: bool(1)
cmplStd/test/lang/useOperator.ci:30: chrA: char('a')
cmplStd/test/lang/useOperator.ci:31: chrB: char('b')
cmplStd/test/lang/useOperator.ci:32: chrPls: char('b')
cmplStd/test/lang/useOperator.ci:33: chrNeg: char('')
cmplStd/test/lang/useOperator.ci:34: chrCmt: char('')
cmplStd/test/lang/useOperator.ci:35: chrAdd: char('')
cmplStd/test/lang/useOperator.ci:36: chrSub: char('')
cmplStd/test/lang/useOperator.ci:37: chrMul: char('\"')
cmplStd/test/lang/useOperator.ci:38: chrDiv: char('')
cmplStd/test/lang/useOperator.ci:39: chrMod: char('a')
cmplStd/test/lang/useOperator.ci:40: chrAnd: char('`')
cmplStd/test/lang/useOperator.ci:41: chrIor: char('c')
cmplStd/test/lang/useOperator.ci:42: chrXor: char('')
cmplStd/test/lang/useOperator.ci:43: chrShl: char('')
cmplStd/test/lang/useOperator.ci:44: chrShr: char('')
cmplStd/test/lang/useOperator.ci:45: chrNot: bool(0)
cmplStd/test/lang/useOperator.ci:46: chrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:47: chrCne: bool(1)
cmplStd/test/lang/useOperator.ci:48: chrClt: bool(1)
cmplStd/test/lang/useOperator.ci:49: chrCle: bool(1)
cmplStd/test/lang/useOperator.ci:50: chrCgt: bool(0)
cmplStd/test/lang/useOperator.ci:51: chrCge: bool(0)
cmplStd/test/lang/useOperator.ci:53: i8A: int8(96)
cmplStd/test/lang/useOperator.ci:54: i8B: int8(42)
cmplStd/test/lang/useOperator.ci:55: i8Pls: int8(42)
cmplStd/test/lang/useOperator.ci:56: i8Neg: int8(-42)
cmplStd/test/lang/useOperator.ci:57: i8Cmt: int8(-43)
cmplStd/test/lang/useOperator.ci:58: i8Add: int8(-118)
cmplStd/test/lang/useOperator.ci:59: i8Sub: int8(54)
cmplStd/test/lang/useOperator.ci:60: i8Mul: int8(-64)
cmplStd/test/lang/useOperator.ci:61: i8Div: int8(2)
cmplStd/test/lang/useOperator.ci:62: i8Mod: int8(12)
cmplStd/test/lang/useOperator.ci:63: i8And: int8(32)
cmplStd/test/lang/useOperator.ci:64: i8Ior: int8(106)
cmplStd/test/lang/useOperator.ci:65: i8Xor: int8(74)
cmplStd/test/lang/useOperator.ci:66: i8Shl: int8(-128)
cmplStd/test/lang/useOperator.ci:67: i8Shr: int8(24)
cmplStd/test/lang/useOperator.ci:68: i8Not: bool(0)
cmplStd/test/lang/useOperator.ci:69: i8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:70: i8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:71: i8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:72: i8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:73: i8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:74: i8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:76: u8A: uint8(96)
cmplStd/test/lang/useOperator.ci:77: u8B: uint8(42)
cmplStd/test/lang/useOperator.ci:78: u8Pls: uint8(42)
cmplStd/test/lang/useOperator.ci:79: u8Neg: uint8(214)
cmplStd/test/lang/useOperator.ci:80: u8Cmt: uint8(213)
cmplStd/test/lang/useOperator.ci:81: u8Add: uint8(138)
cmplStd/test/lang/useOperator.ci:82: u8Sub: uint8(54)
cmplStd/test/lang/useOperator.ci:83: u8Mul: uint8(192)
cmplStd/test/lang/useOperator.ci:84: u8Div: uint8(2)
cmplStd/test/lang/useOperator.ci:85: u8Mod: uint8(12)
cmplStd/test/lang/useOperator.ci:86: u8And: uint8(32)
cmplStd/test/lang/useOperator.ci:87: u8Ior: uint8(106)
cmplStd/test/lang/useOperator.ci:88: u8Xor: uint8(74)
cmplStd/test/lang/useOperator.ci:89: u8Shl: uint8(128)
cmplStd/test/lang/useOperator.ci:90: u8Shr: uint8(24)
cmplStd/test/lang/useOperator.ci:91: u8Not: bool(0)
cmplStd/test/lang/useOperator.ci:92: u8Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:93: u8Cne: bool(1)
cmplStd/test/lang/useOperator.ci:94: u8Clt: bool(0)
cmplStd/test/lang/useOperator.ci:95: u8Cle: bool(0)
cmplStd/test/lang/useOperator.ci:96: u8Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:97: u8Cge: bool(1)
cmplStd/test/lang/useOperator.ci:99: i16A: int16(96)
cmplStd/test/lang/useOperator.ci:100: i16B: int16(42)
cmplStd/test/lang/useOperator.ci:101: i16Pls: int16(42)
cmplStd/test/lang/useOperator.ci:102: i16Neg: int16(-42)
cmplStd/test/lang/useOperator.ci:103: i16Cmt: int16(-43)
cmplStd/test/lang/useOperator.ci:104: i16Add: int16(138)
cmplStd/test/lang/useOperator.ci:105: i16Sub: int16(54)
cmplStd/test/lang/useOperator.ci:106: i16Mul: int16(4032)
cmplStd/test/lang/useOperator.ci:107: i16Div: int16(2)
cmplStd/test/lang/useOperator.ci:108: i16Mod: int16(12)
cmplStd/test/lang/useOperator.ci:109: i16And: int16(32)
cmplStd/test/lang/useOperator.ci:110: i16Ior: int16(106)
cmplStd/test/lang/useOperator.ci:111: i16Xor: int16(74)
cmplStd/test/lang/useOperator.ci:112: i16Shl: int16(384)
cmplStd/test/lang/useOperator.ci:113: i16Shr: int16(24)
cmplStd/test/lang/useOperator.ci:114: i16Not: bool(0)
cmplStd/test/lang/useOperator.ci:115: i16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:116: i16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:117: i16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:118: i16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:119: i16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:120: i16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:122: u16A: uint16(96)
cmplStd/test/lang/useOperator.ci:123: u16B: uint16(42)
cmplStd/test/lang/useOperator.ci:124: u16Pls: uint16(42)
cmplStd/test/lang/useOperator.ci:125: u16Neg: uint16(65494)
cmplStd/test/lang/useOperator.ci:126: u16Cmt: uint16(65493)
cmplStd/test/lang/useOperator.ci:127: u16Add: uint16(138)
cmplStd/test/lang/useOperator.ci:128: u16Sub: uint16(54)
cmplStd/test/lang/useOperator.ci:129: u16Mul: uint16(4032)
cmplStd/test/lang/useOperator.ci:130: u16Div: uint16(2)
cmplStd/test/lang/useOperator.ci:131: u16Mod: uint16(12)
cmplStd/test/lang/useOperator.ci:132: u16And: uint16(32)
cmplStd/test/lang/useOperator.ci:133: u16Ior: uint16(106)
cmplStd/test/lang/useOperator.ci:134: u16Xor: uint16(74)
cmplStd/test/lang/useOperator.ci:135: u16Shl: uint16(384)
cmplStd/test/lang/useOperator.ci:136: u16Shr: uint16(24)
cmplStd/test/lang/useOperator.ci:137: u16Not: bool(0)
cmplStd/test/lang/useOperator.ci:138: u16Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:139: u16Cne: bool(1)
cmplStd/test/lang/useOperator.ci:140: u16Clt: bool(0)
cmplStd/test/lang/useOperator.ci:141: u16Cle: bool(0)
cmplStd/test/lang/useOperator.ci:142: u16Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:143: u16Cge: bool(1)
cmplStd/test/lang/useOperator.ci:145: i32A: int32(96)
cmplStd/test/lang/useOperator.ci:146: i32B: int32(42)
cmplStd/test/lang/useOperator.ci:147: i32Pls: int32(42)
cmplStd/test/lang/useOperator.ci:148: i32Neg: int32(-42)
cmplStd/test/lang/useOperator.ci:149: i32Cmt: int32(-43)
cmplStd/test/lang/useOperator.ci:150: i32Add: int32(138)
cmplStd/test/lang/useOperator.ci:151: i32Sub: int32(54)
cmplStd/test/lang/useOperator.ci:152: i32Mul: int32(4032)
cmplStd/test/lang/useOperator.ci:153: i32Div: int32(2)
cmplStd/test/lang/useOperator.ci:154: i32Mod: int32(12)
cmplStd/test/lang/useOperator.ci:155: i32And: int32(32)
cmplStd/test/lang/useOperator.ci:156: i32Ior: int32(106)
cmplStd/test/lang/useOperator.ci:157: i32Xor: int32(74)
cmplStd/test/lang/useOperator.ci:158: i32Shl: int32(384)
cmplStd/test/lang/useOperator.ci:159: i32Shr: int32(24)
cmplStd/test/lang/useOperator.ci:160: i32Not: bool(0)
cmplStd/test/lang/useOperator.ci:161: i32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:162: i32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:163: i32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:164: i32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:165: i32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:166: i32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:168: u32A: uint32(96)
cmplStd/test/lang/useOperator.ci:169: u32B: uint32(42)
cmplStd/test/lang/useOperator.ci:170: u32Pls: uint32(42)
cmplStd/test/lang/useOperator.ci:171: u32Neg: uint32(4294967254)
cmplStd/test/lang/useOperator.ci:172: u32Cmt: uint32(4294967253)
cmplStd/test/lang/useOperator.ci:173: u32Add: uint32(138)
cmplStd/test/lang/useOperator.ci:174: u32Sub: uint32(54)
cmplStd/test/lang/useOperator.ci:175: u32Mul: uint32(4032)
cmplStd/test/lang/useOperator.ci:176: u32Div: uint32(2)
cmplStd/test/lang/useOperator.ci:177: u32Mod: uint32(12)
cmplStd/test/lang/useOperator.ci:178: u32And: uint32(32)
cmplStd/test/lang/useOperator.ci:179: u32Ior: uint32(106)
cmplStd/test/lang/useOperator.ci:180: u32Xor: uint32(74)
cmplStd/test/lang/useOperator.ci:181: u32Shl: uint32(384)
cmplStd/test/lang/useOperator.ci:182: u32Shr: uint32(24)
cmplStd/test/lang/useOperator.ci:183: u32Not: bool(0)
cmplStd/test/lang/useOperator.ci:184: u32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:185: u32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:186: u32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:187: u32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:188: u32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:189: u32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:191: i64A: int64(96)
cmplStd/test/lang/useOperator.ci:192: i64B: int64(42)
cmplStd/test/lang/useOperator.ci:193: i64Pls: int64(42)
cmplStd/test/lang/useOperator.ci:194: i64Neg: int64(-42)
cmplStd/test/lang/useOperator.ci:195: i64Cmt: int64(-43)
cmplStd/test/lang/useOperator.ci:196: i64Add: int64(138)
cmplStd/test/lang/useOperator.ci:197: i64Sub: int64(54)
cmplStd/test/lang/useOperator.ci:198: i64Mul: int64(4032)
cmplStd/test/lang/useOperator.ci:199: i64Div: int64(2)
cmplStd/test/lang/useOperator.ci:200: i64Mod: int64(12)
cmplStd/test/lang/useOperator.ci:201: i64And: int64(32)
cmplStd/test/lang/useOperator.ci:202: i64Ior: int64(106)
cmplStd/test/lang/useOperator.ci:203: i64Xor: int64(74)
cmplStd/test/lang/useOperator.ci:204: i64Shl: int64(384)
cmplStd/test/lang/useOperator.ci:205: i64Shr: int64(24)
cmplStd/test/lang/useOperator.ci:206: i64Not: bool(0)
cmplStd/test/lang/useOperator.ci:207: i64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:208: i64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:209: i64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:210: i64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:211: i64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:212: i64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:214: u64A: uint64(96)
cmplStd/test/lang/useOperator.ci:215: u64B: uint64(42)
cmplStd/test/lang/useOperator.ci:216: u64Pls: uint64(42)
cmplStd/test/lang/useOperator.ci:217: u64Neg: uint64(18446744073709551574)
cmplStd/test/lang/useOperator.ci:218: u64Cmt: uint64(18446744073709551573)
cmplStd/test/lang/useOperator.ci:219: u64Add: uint64(138)
cmplStd/test/lang/useOperator.ci:220: u64Sub: uint64(54)
cmplStd/test/lang/useOperator.ci:221: u64Mul: uint64(4032)
cmplStd/test/lang/useOperator.ci:222: u64Div: uint64(2)
cmplStd/test/lang/useOperator.ci:223: u64Mod: uint64(12)
cmplStd/test/lang/useOperator.ci:224: u64And: uint64(32)
cmplStd/test/lang/useOperator.ci:225: u64Ior: uint64(106)
cmplStd/test/lang/useOperator.ci:226: u64Xor: uint64(74)
cmplStd/test/lang/useOperator.ci:227: u64Shl: uint64(384)
cmplStd/test/lang/useOperator.ci:228: u64Shr: uint64(24)
cmplStd/test/lang/useOperator.ci:229: u64Not: bool(0)
cmplStd/test/lang/useOperator.ci:230: u64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:231: u64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:232: u64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:233: u64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:234: u64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:235: u64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:237: f32A: float32(96.300003)
cmplStd/test/lang/useOperator.ci:238: f32B: float32(42.139999)
cmplStd/test/lang/useOperator.ci:239: f32Pls: float32(42.139999)
cmplStd/test/lang/useOperator.ci:240: f32Neg: float32(-42.139999)
cmplStd/test/lang/useOperator.ci:242: f32Add: float32(138.440002)
cmplStd/test/lang/useOperator.ci:243: f32Sub: float32(54.160004)
cmplStd/test/lang/useOperator.ci:244: f32Mul: float32(4058.082031)
cmplStd/test/lang/useOperator.ci:245: f32Div: float32(2.285240)
cmplStd/test/lang/useOperator.ci:246: f32Mod: float32(12.020004)
cmplStd/test/lang/useOperator.ci:252: f32Not: bool(0)
cmplStd/test/lang/useOperator.ci:253: f32Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:254: f32Cne: bool(1)
cmplStd/test/lang/useOperator.ci:255: f32Clt: bool(0)
cmplStd/test/lang/useOperator.ci:256: f32Cle: bool(0)
cmplStd/test/lang/useOperator.ci:257: f32Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:258: f32Cge: bool(1)
cmplStd/test/lang/useOperator.ci:260: f64A: float64(96.300000)
cmplStd/test/lang/useOperator.ci:261: f64B: float64(42.140000)
cmplStd/test/lang/useOperator.ci:262: f64Pls: float64(42.140000)
cmplStd/test/lang/useOperator.ci:263: f64Neg: float64(-42.140000)
cmplStd/test/lang/useOperator.ci:265: f64Add: float64(138.440000)
cmplStd/test/lang/useOperator.ci:266: f64Sub: float64(54.160000)
cmplStd/test/lang/useOperator.ci:267: f64Mul: float64(4058.082000)
cmplStd/test/lang/useOperator.ci:268: f64Div: float64(2.285240)
cmplStd/test/lang/useOperator.ci:269: f64Mod: float64(12.020000)
cmplStd/test/lang/useOperator.ci:275: f64Not: bool(0)
cmplStd/test/lang/useOperator.ci:276: f64Ceq: bool(0)
cmplStd/test/lang/useOperator.ci:277: f64Cne: bool(1)
cmplStd/test/lang/useOperator.ci:278: f64Clt: bool(0)
cmplStd/test/lang/useOperator.ci:279: f64Cle: bool(0)
cmplStd/test/lang/useOperator.ci:280: f64Cgt: bool(1)
cmplStd/test/lang/useOperator.ci:281: f64Cge: bool(1)
cmplStd/test/lang/useOperator.ci:283: ptrA: pointer(null)
cmplStd/test/lang/useOperator.ci:284: ptrB: pointer(<?>)
cmplStd/test/lang/useOperator.ci:299: ptrCeq: bool(0)
cmplStd/test/lang/useOperator.ci:300: ptrCne: bool(1)
cmplStd/test/lang/stmt.if.ci:26: t: int32(0)
cmplStd/test/lang/stmt.for.ci:12: forIdx: int32(2)
cmplStd/test/math/test.Bits.ci:3: pi64: float64(3.141593)
cmplStd/test/math/test.Bits.ci:4: e64: float64(2.718282)
cmplStd/test/math/test.Bits.ci:6: pi32: float32(3.141593)
cmplStd/test/math/test.Bits.ci:7: e32: float32(2.718282)
cmplStd/test/math/test.Bits.ci:14: r_comp: int32(112)
cmplStd/test/math/test.Bits.ci:15: g_comp: int32(252)
cmplStd/test/math/test.Bits.ci:16: b_comp: int32(248)
cmplStd/test/math/test.Bits.ci:18: r5g6b5: int32(30719)
cmplStd/test/math/test.Bits.ci:19: r8g8b8: int32(7404792)
cmplStd/test/math/test.Bits.ci:21: zxtR5: int32(14)
cmplStd/test/math/test.Bits.ci:22: zxtG6: int32(63)
cmplStd/test/math/test.Bits.ci:23: zxtB5: int32(31)
cmplStd/test/math/test.Bits.ci:25: sxtR5: int32(14)
cmplStd/test/math/test.Bits.ci:26: sxtG6: int32(-1)
cmplStd/test/math/test.Bits.ci:27: sxtB5: int32(-1)
cmplStd/test/math/test.Bits.ci:29: zxtR8: int32(112)
cmplStd/test/math/test.Bits.ci:30: zxtG8: int32(252)
cmplStd/test/math/test.Bits.ci:31: zxtB8: int32(248)
cmplStd/test/math/test.Bits.ci:33: sxtR8: int32(112)
cmplStd/test/math/test.Bits.ci:34: sxtG8: int32(-4)
cmplStd/test/math/test.Bits.ci:35: sxtB8: int32(-8)
cmplStd/test/math/test.Bits.ci:37: testSin_f64: float64(1.000000)
cmplStd/test/math/test.Bits.ci:38: testCos_f64: float64(0.000000)
cmplStd/test/math/test.Bits.ci:39: testTan_f64: float64(1.000000)
cmplStd/test/math/test.Bits.ci:40: testLog_f64: float64(3.000000)
cmplStd/test/math/test.Bits.ci:41: testExp_f64: float64(2.718282)
cmplStd/test/math/test.Bits.ci:42: testPow_f64: float64(3.141593)
cmplStd/test/math/test.Bits.ci:43: testSqrt_f64: float64(3.141593)
cmplStd/test/math/test.Bits.ci:44: testAtan_f64: float64(1.262627)
cmplStd/test/math/test.Bits.ci:46: testSin_f32: float32(1.000000)
cmplStd/test/math/test.Bits.ci:47: testCos_f32: float32(-0.000000)
cmplStd/test/math/test.Bits.ci:48: testTan_f32: float32(1.000000)
cmplStd/test/math/test.Bits.ci:49: testLog_f32: float32(3.000000)
cmplStd/test/math/test.Bits.ci:50: testExp_f32: float32(2.718282)
cmplStd/test/math/test.Bits.ci:51: testPow_f32: float32(3.141593)
cmplStd/test/math/test.Bits.ci:52: testSqrt_f32: float32(3.141593)
cmplStd/test/math/test.Bits.ci:53: testAtan_f32: float32(1.262627)
cmplStd/test/math/test.Bits.ci:55: testPopulation_u32: int32(14)
cmplStd/test/math/test.Bits.ci:56: testSwapBits_u32: uint32(4293787648)
cmplStd/test/math/test.Bits.ci:57: testBitScanReverse_u32: int32(14)
cmplStd/test/math/test.Bits.ci:58: testBitScanForward_u32: int32(0)
cmplStd/test/math/test.Bits.ci:59: testHighBit_u32: int32(16384)
cmplStd/test/math/test.Bits.ci:60: testLowBit_u32: int32(1)
cmplStd/test/math/test.Bits.ci:62: testZeroExtend_u32: int32(31)
cmplStd/test/math/test.Bits.ci:63: testSignExtend_u32: int32(-1)
cmplStd/test/math/test.Bits.ci:65: testZeroExtend_u64: int32(31)
cmplStd/test/math/test.Bits.ci:66: testSignExtend_u64: int32(-1)
cmplStd/test/math/test.Math.ci:3: testMathFloor_pos_3_0: float64(3.000000)
cmplStd/test/math/test.Math.ci:4: testMathFloor_pos_3_2: float64(3.000000)
cmplStd/test/math/test.Math.ci:5: testMathFloor_pos_3_5: float64(3.000000)
cmplStd/test/math/test.Math.ci:6: testMathFloor_pos_3_7: float64(3.000000)
cmplStd/test/math/test.Math.ci:7: testMathFloor_pos_3_9: float64(3.000000)
cmplStd/test/math/test.Math.ci:8: testMathFloor_neg_3_0: float64(-3.000000)
cmplStd/test/math/test.Math.ci:9: testMathFloor_neg_3_2: float64(-4.000000)
cmplStd/test/math/test.Math.ci:10: testMathFloor_neg_3_5: float64(-4.000000)
cmplStd/test/math/test.Math.ci:11: testMathFloor_neg_3_7: float64(-4.000000)
cmplStd/test/math/test.Math.ci:12: testMathFloor_neg_3_9: float64(-4.000000)
cmplStd/test/math/test.Math.ci:14: testMathRound_pos_3_0: float64(3.000000)
cmplStd/test/math/test.Math.ci:15: testMathRound_pos_3_2: float64(3.000000)
cmplStd/test/math/test.Math.ci:16: testMathRound_pos_3_5: float64(4.000000)
cmplStd/test/math/test.Math.ci:17: testMathRound_pos_3_7: float64(4.000000)
cmplStd/test/math/test.Math.ci:18: testMathRound_pos_3_9: float64(4.000000)
cmplStd/test/math/test.Math.ci:19: testMathRound_neg_3_0: float64(-3.000000)
cmplStd/test/math/test.Math.ci:20: testMathRound_neg_3_2: float64(-3.000000)
cmplStd/test/math/test.Math.ci:21: testMathRound_neg_3_5: float64(-3.000000)
cmplStd/test/math/test.Math.ci:22: testMathRound_neg_3_7: float64(-4.000000)
cmplStd/test/math/test.Math.ci:23: testMathRound_neg_3_9: float64(-4.000000)
cmplStd/test/math/test.Math.ci:25: testMathCeil_pos_3_0: float64(3.000000)
cmplStd/test/math/test.Math.ci:26: testMathCeil_pos_3_2: float64(4.000000)
cmplStd/test/math/test.Math.ci:27: testMathCeil_pos_3_5: float64(4.000000)
cmplStd/test/math/test.Math.ci:28: testMathCeil_pos_3_7: float64(4.000000)
cmplStd/test/math/test.Math.ci:29: testMathCeil_pos_3_9: float64(4.000000)
cmplStd/test/math/test.Math.ci:30: testMathCeil_neg_3_0: float64(-3.000000)
cmplStd/test/math/test.Math.ci:31: testMathCeil_neg_3_2: float64(-3.000000)
cmplStd/test/math/test.Math.ci:32: testMathCeil_neg_3_5: float64(-3.000000)
cmplStd/test/math/test.Math.ci:33: testMathCeil_neg_3_7: float64(-3.000000)
cmplStd/test/math/test.Math.ci:34: testMathCeil_neg_3_9: float64(-3.000000)
cmplStd/test/math/test.Math.ci:36: testMathSign_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:37: testMathSign_2F: float64(0.000000)
cmplStd/test/math/test.Math.ci:38: testMathSign_3F: float64(-1.000000)
cmplStd/test/math/test.Math.ci:39: testMathSign_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:40: testMathSign_2f: float64(0.000000)
cmplStd/test/math/test.Math.ci:41: testMathSign_3f: float64(-1.000000)
cmplStd/test/math/test.Math.ci:43: testMathAbs_1F: float64(0.200000)
cmplStd/test/math/test.Math.ci:44: testMathAbs_2F: float64(0.000000)
cmplStd/test/math/test.Math.ci:45: testMathAbs_3F: float64(0.900000)
cmplStd/test/math/test.Math.ci:46: testMathAbs_1f: float64(0.200000)
cmplStd/test/math/test.Math.ci:47: testMathAbs_2f: float64(0.000000)
cmplStd/test/math/test.Math.ci:48: testMathAbs_3f: float64(0.900000)
cmplStd/test/math/test.Math.ci:50: testMathMin_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:51: testMathMax_2f: float64(2.000000)
cmplStd/test/math/test.Math.ci:52: testMathMin_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:53: testMathMax_2F: float64(2.000000)
cmplStd/test/math/test.Math.ci:55: testMathClamp_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:56: testMathClamp_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:58: testMathMix_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:59: testMathMix_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:61: testMathSmooth_1f: float64(1.000000)
cmplStd/test/math/test.Math.ci:62: testMathSmooth_1F: float64(1.000000)
cmplStd/test/math/test.Math.ci:64: testMathMin_nan: float64(-nan)
cmplStd/test/math/test.Math.ci:65: testMathMin_1: float64(1.000000)
cmplStd/test/math/test.Math.ci:66: testMathMax_nan: float64(-nan)
cmplStd/test/math/test.Math.ci:67: testMathMax_9: float64(9.000000)
cmplStd/test/math/test.Math.ci:69: testMathSum_0: float64(0.000000)
cmplStd/test/math/test.Math.ci:70: testMathSum_1: float64(1.000000)
cmplStd/test/math/test.Math.ci:71: testMathSum_3: float64(3.000000)
cmplStd/test/math/test.Math.ci:72: testMathSum_55: float64(55.000000)
cmplStd/test/math/test.Math.ci:74: testMathEval_x: float64(10.000000)
cmplStd/test/math/test.Math.ci:75: testMathEval_0: float64(0.000000)
cmplStd/test/math/test.Math.ci:76: testMathEval_1: float64(1.000000)
cmplStd/test/math/test.Math.ci:77: testMathEval_2: float64(11.000000)
cmplStd/test/math/test.Math.ci:78: testMathEval_3: float64(111.000000)
cmplStd/test/math/test.Math.ci:79: testMathEval_4: float64(1111.000000)
cmplStd/test/math/test.Math.ci:80: testMathEval_5: float64(11111.000000)
cmplStd/test/math/test.Math.ci:81: testMathEval_6: float64(111111.000000)
cmplStd/test/math/test.Math.ci:83: testMathSin_f64: float64(1.000000)
cmplStd/test/math/test.Math.ci:84: testMathCos_f64: float64(0.000000)
cmplStd/test/math/test.Math.ci:85: testMathTan_f64: float64(1.000000)
cmplStd/test/math/test.Math.ci:86: testMathSinh_f64: float64(2.301299)
cmplStd/test/math/test.Math.ci:87: testMathCosh_f64: float64(2.509178)
cmplStd/test/math/test.Math.ci:89: testMathAsin_f64: float64(0.201358)
cmplStd/test/math/test.Math.ci:90: testMathAcos_f64: float64(1.369438)
cmplStd/test/math/test.Math.ci:93: testMathAbsMod_f64_0a: float64(0.000000)
cmplStd/test/math/test.Math.ci:94: testMathAbsMod_f64_0b: float64(0.000000)
cmplStd/test/math/test.Math.ci:95: testMathAbsMod_f64_0c: float64(-0.000000)
cmplStd/test/math/test.Math.ci:97: testMathAbsMod_f64_9a: float64(9.000000)
cmplStd/test/math/test.Math.ci:98: testMathAbsMod_f64_9b: float64(9.000000)
cmplStd/test/math/test.Math.ci:99: testMathAbsMod_f64_9c: float64(9.000000)
cmplStd/test/math/test.Math.ci:100: testMathAbsMod_f64_9d: float64(9.000000)
cmplStd/test/math/test.Math.ci:102: testMathAbsMod_f64_8a: float64(8.000000)
cmplStd/test/math/test.Math.ci:103: testMathAbsMod_f64_8b: float64(8.000000)
cmplStd/test/math/test.Math.ci:104: testMathAbsMod_f64_8c: float64(8.000000)
cmplStd/test/math/test.Math.ci:105: testMathAbsMod_f64_8d: float64(8.000000)
cmplStd/test/math/test.Math.ci:107: testMathAbsMod_f32_0a: float32(0.000000)
cmplStd/test/math/test.Math.ci:108: testMathAbsMod_f32_0b: float32(0.000000)
cmplStd/test/math/test.Math.ci:109: testMathAbsMod_f32_0c: float32(-0.000000)
cmplStd/test/math/test.Math.ci:111: testMathAbsMod_f32_9a: float32(9.000000)
cmplStd/test/math/test.Math.ci:112: testMathAbsMod_f32_9b: float32(9.000000)
cmplStd/test/math/test.Math.ci:113: testMathAbsMod_f32_9c: float32(9.000000)
cmplStd/test/math/test.Math.ci:114: testMathAbsMod_f32_9d: float32(9.000000)
cmplStd/test/math/test.Math.ci:116: testMathAbsMod_f32_8a: float32(8.000000)
cmplStd/test/math/test.Math.ci:117: testMathAbsMod_f32_8b: float32(8.000000)
cmplStd/test/math/test.Math.ci:118: testMathAbsMod_f32_8c: float32(8.000000)
cmplStd/test/math/test.Math.ci:119: testMathAbsMod_f32_8d: float32(8.000000)
cmplStd/test/math/test.Complex.ci:8: valA: Complex({
	re: float64(9.000000),
	im: float64(2.000000)
})
cmplStd/test/math/test.Complex.ci:9: valB: Complex({
	re: float64(2.000000),
	im: float64(3.000000)
})
cmplStd/test/math/test.Complex.ci:11: Neg: Complex({
	re: float64(-9.000000),
	im: float64(-2.000000)
})
cmplStd/test/math/test.Complex.ci:12: neg: Complex({
	re: float64(-9.000000),
	im: float64(-2.000000)
})
cmplStd/test/math/test.Complex.ci:14: Add: Complex({
	re: float64(11.000000),
	im: float64(5.000000)
})
cmplStd/test/math/test.Complex.ci:15: add: Complex({
	re: float64(11.000000),
	im: float64(5.000000)
})
cmplStd/test/math/test.Complex.ci:17: Sub: Complex({
	re: float64(7.000000),
	im: float64(-1.000000)
})
cmplStd/test/math/test.Complex.ci:18: sub: Complex({
	re: float64(7.000000),
	im: float64(-1.000000)
})
cmplStd/test/math/test.Complex.ci:20: Mul: Complex({
	re: float64(12.000000),
	im: float64(31.000000)
})
cmplStd/test/math/test.Complex.ci:21: mul: Complex({
	re: float64(12.000000),
	im: float64(31.000000)
})

---------- Memory usage:
memory[all] @000000; size: 134217448(128.0 Mb)
memory[used] @000000; size: 737245(720.0 Kb)
memory[heap] @0b3fdd; size: 99925801(95.3 Mb)
memory[stack] @3ffff4c; size: 33554362(32.0 Mb)

---------- Used memory:
memory[meta] @000000; size: 683904(667.9 Kb)
memory[code] @000000; size: 48661(47.5 Kb)
memory[data] @000000; size: 3756(3.7 Kb)

---------- Heap memory:
memory[used] @0b3ff8; size: 32(32.0 bytes)
memory[used] @0b4028; size: 32(32.0 bytes)
memory[free] @0b4058; size: 99925648(95.3 Mb)

---------- Exitcode: 0, time: 0.000 ms
