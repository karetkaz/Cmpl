// graphics library extension

bool empty(const Rect roi&) {
// fixme: inline empty(const Rect roi&) = roi.x0 >= roi.x1 || roi.y0 >= roi.y1;
	return roi.x0 >= roi.x1 || roi.y0 >= roi.y1;
}

inline width(const Rect roi&) = roi.x1 - roi.x0;
void width(Rect rect&, int width) {
	rect.x1 = rect.x0 + width;
}

inline height(const Rect roi&) = roi.y1 - roi.y0;
void height(Rect rect&, int height) {
	rect.y1 = rect.y0 + height;
}

void setSize(Rect rect&, int width, int height) {
	rect.x1 = rect.x0 + width;
	rect.y1 = rect.y0 + height;
}

void positionX(Rect rect&, int x) {
	rect.x1 = x + rect.x1 - rect.x0;
	rect.x0 = x;
}
void positionY(Rect rect&, int y) {
	rect.y1 = y + rect.y1 - rect.y0;
	rect.y0 = y;
}

void position(Rect rect&, int x, int y) {
	rect.positionX(x);
	rect.positionY(y);
}

void adjust(Rect rect&, int dx0, int dy0, int dx1, int dy1) {
	rect.x0 += dx0;
	rect.y0 += dy0;
	rect.x1 += dx1;
	rect.y1 += dy1;
}
inline translate(Rect rect&, int dx, int dy) = rect.adjust(dx, dy, dx, dy);
void translateX(Rect rect&, int dx) {
	rect.x0 += dx;
	rect.x1 += dx;
}
void translateY(Rect rect&, int dy) {
	rect.y0 += dy;
	rect.y1 += dy;
}

bool contains(const Rect rect&, int x, int y) {
	return x >= rect.x0 && x < rect.x1 && y >= rect.y0 && y < rect.y1;
}

inline "lib/color.ci";
inline "lib/image.ci";
inline "lib/image.draw.ci";
inline "lib/image.blend.ci";
inline "lib/image.transform.ci";

inline "lib/image.blur.ci";

inline "lib/color.lookup.ci";
inline "lib/color.matrix.ci";

inline "lib/micro.ui.ci";

inline "lib/mesh.ci";
inline "lib/camera.ci";

static struct Gui {
/// Show the surface in a window
void showWindow(Image surf) {
	Gui.showWindow(surf, null, null);
}

/// Show the surface in a window
void showWindow(Image image, int onEvent(int action, int button, int ex, int ey)) {
	if (onEvent == null) {
		return Gui.showWindow(image, null, null);
	}
	static int delegate(int onEvent(int action, int button, int ex, int ey), int action, int button, int ex, int ey) {
		return onEvent(action, button, ex, ey);
	}
	Gui.showWindow(image, onEvent, delegate);
}

/// Show the surfaces in a window clicking on the window toggles the shown surface
void showWindow(int width, int height, Image image0, Image image1, Image image2) {
	struct Data {
		Image offs;
		Image image0;
		Image image1;
		Image image2;
	}

	static int onEvent(const Data data&, int action, int button, int ex, int ey) {
		if (action == Gui.KEY_RELEASE && button == Gui.KEY_CODE_ESC) {
			// exit when releasing escape key
			return -1;
		}
		if (action == Gui.MOUSE_PRESS || action == Gui.MOUSE_RELEASE) {
			Image show = data.image0;
			if (action == Gui.MOUSE_RELEASE) {
				show = data.image0;
			}
			else if (button == 1) {
				show = data.image1;
			}
			else {
				show = data.image2;
			}
			data.offs.transform(null, show, null, 1, null);
			return 0;
		}
		return 0;
	}

	Image offs = Image(width, height, image0.depth());
	Data data = {
		offs: offs;
		image0: image0;
		image1: image1;
		image2: image2;
	};
	onEvent(data, Gui.MOUSE_RELEASE, 0, 0, 0);
	Gui.showWindow(offs, data, onEvent);
	offs.destroy();
}

void showWindow(Image image0, Image image1, Image image2) {
	int width = image0.width();
	int height = image0.height();
	return showWindow(width, height, image0, image1, image1);
}

void showWindow(Image image0, Image image1) {
	return showWindow(image0, image1, image1);
}

/// Show or animate the the procedural image generated by the `eval` function
void showWindow(int width, int height, int animationResolution, vec4f eval(vec4f in)) {
	static const int64 start = System.millis();
	struct Data {
		bool lerp = true;
		const Image offs;
		const Image thumb;
		const float32 aspect;
		int32 fpsCount = 0;	// frames drawn
		float32 fpsTime = 0;	// frame per sec shot time
		const vec4f eval(vec4f in);
	}

	static int onEvent(Data data&, int action, int button, int ex, int ey) {
		if (action == Gui.KEY_RELEASE && button == Gui.KEY_CODE_ESC) {
			// exit when releasing escape key
			return -1;
		}
		if (action == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return 0;
		}
		if (action == Gui.KEY_RELEASE) {
			if (button == ' ') {
				char text[256] = {};
				int64 now = System.millis();
				float32 time = (now - start) / 1000f;
				data.offs.eval(null, data.aspect, time, data.eval);
				text.append(text.append(0, "Millis: "), System.millis() - now);
				Gui.setTitle(text);
				return 0;
			}
			if (button == Gui.KEY_CODE_TAB) {
				data.lerp = !data.lerp;
			}
			if (button == 'S') {
				trace("dumping screen");
				data.offs.saveBmp("out/offs.bmp", 0);
				data.thumb.saveBmp("out/thumb.bmp", 0);
			}
		}

		float32 time = (System.millis() - start) / 1000f;
		data.thumb.eval(null, data.aspect, time, data.eval);
		data.offs.resize(null, data.thumb, null, int(data.lerp));
		if (time > data.fpsTime) {
			char text[256] = {};
			text.append(text.append(0, "Fps: "), data.fpsCount);
			Gui.setTitle(text);
			data.fpsTime = time + 1;
			data.fpsCount = 0;
		}
		data.fpsCount += 1;

		// do not block for any input
		return 1;
	}

	if (animationResolution == 0) {
		float32 aspect = width / float32(height);
		Image image = Image(width, height, 32);
		image.eval(null, aspect, 0f, eval);
		Gui.showWindow(image);
		image.destroy();
		return;
	}

	Data data = {
		offs: Image(width, height, 32);
		thumb: Image(animationResolution, animationResolution, 32);
		aspect: width / float32(height);
		eval: eval;
	};
	Gui.showWindow(data.offs, data, onEvent);
	data.thumb.destroy();
	data.offs.destroy();
}

void showWindow(int width, int height, vec4f eval(vec4f in)) {
	return showWindow(width, height, 0, eval);
}

/// Show the mesh in a window
void showWindow(int w, int h, float32 fovy, Mesh mesh) {

	struct Data {
		int32 fpsCount = 0;	// frames drawn
		int32 fpsShow = 0;	// frames drawn
		int64 fpsTime = 0;	// frame per sec shot time
		int mode;
		Image offs;
		mat4f proj;
		Camera cam;
		Mesh mesh;

		static void updateCamera(const Data this&) {
			Camera camera& = this.cam;
			camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
		}
	}

	int next(int32 x, int mask) {
		int next = x & mask;

		// add lowest bit of mask
		next += mask & -mask;

		// avoid overflow
		next &= mask;

		return next | (x & ~mask);
	}

	static int onEvent(Data data&, int action, int button, int ex, int ey) {
		static int ox = 0;
		static int oy = 0;
		static const float32 slow = 1 / 100f;
		static const float32 fast = 5 / 100f;
		if (action == Gui.FINGER_MOTION) {
			action = Gui.MOUSE_MOTION;
		}
		if (action == Gui.KEY_RELEASE && button == Gui.KEY_CODE_ESC) {
			// exit when releasing escape key
			return -1;
		}
		if (action == Gui.KEY_PRESS) {
			if (button == Gui.KEY_CODE_ENTER) {
				vec4f eye = {x: 0, y: 0, z: 2, w: 1};
				vec4f at = {x: 0, y: 0, z: 0, w: 1};
				vec4f up = {x: 0, y: 1, z: 0, w: 1};
				data.cam = Camera.lookAt(eye, at, up);
				data.updateCamera();
			}

			else if (button == 'w') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Gui.KEY_MASK_SHIFT);
				camera.move(camera.forward, +(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 's') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Gui.KEY_MASK_SHIFT);
				camera.move(camera.forward, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 'a') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Gui.KEY_MASK_SHIFT);
				camera.move(camera.right, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 'd') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Gui.KEY_MASK_SHIFT);
				camera.move(camera.right, +(shift ? fast : slow));
				data.updateCamera();
			}

			else if (button == Gui.KEY_CODE_UP) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Gui.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.right, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Gui.KEY_CODE_DOWN) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Gui.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.right, +(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Gui.KEY_CODE_LEFT) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Gui.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.up, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Gui.KEY_CODE_RIGHT) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Gui.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.up, +(shift ? fast : slow));
				data.updateCamera();
			}

			else if (button == 'l') {
				data.mode ^= Mesh.useLights;
			}
			else if (button == 'b') {
				data.mode ^= Mesh.drawBounds;
			}
			else if (button == '0') {
				lights.enable(0, !lights.enabled(0));
			}
			else if (button == '1') {
				lights.enable(1, !lights.enabled(1));
			}
			else if (button == '2') {
				lights.enable(2, !lights.enabled(2));
			}
			else if (button == '3') {
				lights.enable(3, !lights.enabled(3));
			}
			else if (button == 't') {
				data.mode ^= Mesh.useTexture;
			}
			else if (button == '/') {
				data.mode = next(data.mode, Mesh.cullBack | Mesh.cullFront);
			}
			else if (button == Gui.KEY_CODE_TAB) {
				data.mode = next(data.mode, Mesh.drawMode);
			}
		}
		else if (action == Gui.MOUSE_PRESS) {
			ox = ex;
			oy = ey;
			return 0;
		}
		else if (action == Gui.MOUSE_MOTION) {
			Camera camera& = data.cam;
			int dx = ex - ox;
			int dy = ey - oy;

			if (button == 1) {
				// orbit around the origin: (x: 0, y: 0, z: 0)
				vec4f orbit = vec4f(0, 0, 0);
				camera.rotate(orbit, camera.up, dx * slow);
				camera.rotate(orbit, camera.right, dy * slow);
				data.updateCamera();
			}
			else if (button == 2) {
				// rotate
				vec4f orbit = camera.position;
				camera.rotate(orbit, camera.up, -dx * slow);
				camera.rotate(orbit, camera.right, -dy * slow);
				data.updateCamera();
			}
			else if (button == 3) {
				// move the camera back and forward
				camera.move(camera.forward, dy * slow);
				data.updateCamera();
			}
			else if (button == 4) {
				// pan the camera
				camera.move(camera.right, -dx * slow);
				camera.move(camera.up, dy * slow);
				data.updateCamera();
			}
			ox = ex;
			oy = ey;
		}
		else if (action == Gui.MOUSE_WHEEL) {
			Camera camera& = data.cam;
			camera.move(camera.forward, ey * fast);
			data.updateCamera();
		}

		int rendered = data.offs.drawMesh(data.mesh, data.mode);

		char text[256] = {};
		int pos = text.append(0, "Vertices: ");
		pos = text.append(pos, data.mesh.vertices);
		pos = text.append(pos, ", Triangles: ");
		pos = text.append(pos, data.mesh.triangles);
		pos = text.append(pos, "/");
		pos = text.append(pos, rendered);
		pos = text.append(pos, ", Fps: ");
		pos = text.append(pos, data.fpsShow);
		Gui.setTitle(text);

		int64 time = System.millis();
		if (time > data.fpsTime) {
			data.fpsTime = time + 1000;
			data.fpsShow = data.fpsCount;
			data.fpsCount = 0;
		}
		data.fpsCount += 1;
		return 0;
	}

	Data data = {
		mode: Mesh.clearDepth | Mesh.clearColor | Mesh.useLights | Mesh.cullBack | Mesh.drawFill;
		offs: Image.create3d(w, h);
		proj: Camera.projection(fovy, w / float32(h), 1, 100);
		cam: Camera.lookAt(vec4f(0,0,2), vec4f(0), vec4f(0,1,0));
		mesh: mesh;
	};
	data.updateCamera();
	Gui.showWindow(data.offs, data, onEvent);
	data.offs.destroy();
}
}
