// graphics library extension
inline "lib/color.ci";
inline "lib/image.ci";
inline "lib/mesh.ci";

static if (typename(Image.blur) == null) {
raise(raise.debug, raise.noTrace, "emulated/blur.ci", null);
inline "lib/emulated/blur.ci";
}

static if (typename(Image.blend) == null) {
raise(raise.debug, raise.noTrace, "emulated/blend.ci", null);
inline "lib/emulated/blend.ci";
}

static if (typename(Image.transform) == null) {
raise(raise.debug, raise.noTrace, "emulated/transform.ci", null);
inline "lib/emulated/transform.ci";
}

/// Show the surface in a window
inline show(Image surf) = Gui.showWindow(surf, null, null);

/// Show the surface in a window
void show(Image image, int onEvent(int action, int button, int ex, int ey)) {
	if (onEvent == null) {
		return Gui.showWindow(image, null, null);
	}
	static int delegate(int onEvent(int action, int button, int ex, int ey), int action, int button, int ex, int ey) {
		return onEvent(action, button, ex, ey);
	}
	Gui.showWindow(image, onEvent, delegate);
}

/// Show the surfaces in a window clicking on the window toggles the shown surface
void showDiff(Image image1, Image image2) {
	struct Closure {
		Image offs;
		Image image1;
		Image image2;
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
		}
		if (action == Gui.MOUSE_PRESS) {
			closure.offs.copy(0, 0, closure.image2, null);
			return 0;
		}
		if (action == Gui.MOUSE_RELEASE) {
			closure.offs.copy(0, 0, closure.image1, null);
			return 0;
		}
		return 0;
	}

	Closure closure = {
		offs: Image(image1);
		image1: image1;
		image2: image2;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
}

/// Show or animate the the procedural image generated by the `eval` function
void show(int width, int height, int animationResolution, vec4f eval(vec4f in)) {
	static const int64 start = System.millis();
	struct Closure {
		bool lerp = true;
		const Image offs;
		const Image thumb;
		const float32 aspect;
		const vec4f eval(vec4f in);
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		if (action == Gui.WINDOW_CLOSE) {
			trace("closing ...");
			return 0;
		}
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
		}
		if (action == Gui.KEY_RELEASE) {
			if (button == ' ') {
				float32 time = (System.millis() - start) / 1000f;
				closure.offs.eval(null, closure.aspect, time, closure.eval);
				return 0;
			}
			if (button == '\t') {
				closure.lerp = !closure.lerp;
			}
			if (button == 'S') {
				trace("dumping screen");
				closure.offs.saveBmp("out/offs.bmp", 0);
				closure.thumb.saveBmp("out/thumb.bmp", 0);
			}
		}

		float32 time = (System.millis() - start) / 1000f;
		closure.thumb.eval(null, closure.aspect, time, closure.eval);
		closure.offs.resize(null, closure.thumb, null, closure.lerp ? 1 : 0);

		// do not block for any input
		return 1;
	}

	if (animationResolution == 0) {
		float32 aspect = width / float32(height);
		Image image = Image(width, height, 32);
		image.eval(null, aspect, 0f, eval);
		image.show(null);
		image.destroy();
		return;
	}

	Closure closure = {
		offs: Image(width, height, 32);
		thumb: Image(animationResolution, animationResolution, 32);
		aspect: width / float32(height);
		eval: eval;
	};
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.thumb.destroy();
	closure.offs.destroy();
}

/// Show the mesh in a window
void show(Mesh mesh, int w, int h, float32 fovy) {

	struct Closure {
		int mode;
		Image offs;
		Mesh mesh;
	}

	int next(int32 x, int mask) {
		int next = x & mask;

		// add lowest bit of mask
		next += mask & -mask;

		// avoid overflow
		next &= mask;

		return next | (x & ~mask);
	}

	static int onEvent(Closure closure&, int action, int button, int ex, int ey) {
		static int ox = 0;
		static int oy = 0;
		static const float32 speed = 1 / 100f;
		if (action == Gui.FINGER_MOTION) {
			action = Gui.MOUSE_MOTION;
		}
		if (action == Gui.KEY_PRESS) {
			if (button == 27) {
				return -1;
			}
			else if (button == 'l') {
				closure.mode ^= Mesh.useLights;
			}
			else if (button == '0') {
				lights.enable(0, !lights.enabled(0));
			}
			else if (button == '1') {
				lights.enable(1, !lights.enabled(1));
			}
			else if (button == '2') {
				lights.enable(2, !lights.enabled(2));
			}
			else if (button == '3') {
				lights.enable(3, !lights.enabled(3));
			}
			else if (button == 't') {
				closure.mode ^= Mesh.useTexture;
			}
			else if (button == '/') {
				closure.mode = next(closure.mode, Mesh.cullBack | Mesh.cullFront);
			}
			else if (button == '\t') {
				closure.mode = next(closure.mode, Mesh.drawMode);
			}
			else if (button == '\r') {
				vec4f eye = {x: 0, y: 0, z: 2, w: 1};
				vec4f at = {x: 0, y: 0, z: 0, w: 1};
				vec4f up = {x: 0, y: 1, z: 0, w: 1};
				camera.lookAt(eye.data, at.data, up.data);
			}
		}
		else if (action == Gui.MOUSE_PRESS) {
			ox = ex;
			oy = ey;
			return 0;
		}
		else if (action == Gui.MOUSE_MOTION) {
			float32 dir[3] = {0, 0, 0};
			int dx = ex - ox;
			int dy = ey - oy;

			if (button == 1) {
				// orbit
				float32 orig[3] = {0, 0, 0};

				camera.readUp(&dir);
				camera.rotate(dir, orig, dx * speed);
				camera.readRight(&dir);
				camera.rotate(dir, orig, dy * speed);
			}
			else if (button == 2) {
				// rotate
				camera.readUp(&dir);
				camera.rotate(dir, null, -dx * speed);
				camera.readRight(&dir);
				camera.rotate(dir, null, -dy * speed);
			}
			else if (button == 3) {
				// move
				camera.readForward(&dir);
				camera.move(dir, dy * speed);
			}
			else if (button == 4) {
				// pan
				camera.readRight(&dir);
				camera.move(dir, -dx * speed);
				camera.readUp(&dir);
				camera.move(dir, dy * speed);
			}
			ox = ex;
			oy = ey;
		}

		int rendered = closure.offs.drawMesh(closure.mesh, closure.mode);

		char text[256] = {};
		int pos = text.append(0, "Vertices: ");
		pos = text.append(pos, closure.mesh.vertices);
		pos = text.append(pos, ", Triangles: ");
		pos = text.append(pos, closure.mesh.triangles);
		pos = text.append(pos, "/");
		pos = text.append(pos, rendered);
		Gui.setTitle(text);
		return 0;
	}

	Closure closure = {
		mode: Mesh.clearDepth | Mesh.clearColor | Mesh.useLights | Mesh.cullBack | Mesh.drawFill;
		offs: Image.create3d(w, h);
		mesh: mesh;
	};
	camera.projection(fovy, w / float32(h), 1, 100);
	Gui.showWindow(closure.offs, closure, onEvent);
	closure.offs.destroy();
}
