/* Manual color lookup editing
 *
 * use 'tab' / 'shift' + 'tab' to select next control
 * use 'enter' / 'shift' + 'enter' to select next control
 * use '+' / '-' to adjust value of selected control (use shift for more precision)
 * use 'backspace' / 'shift' + 'backspace' to reset selected / every control value
 * use 'space' to press a button, toggle switch or reset slider value
 * use '[' or ']' to show and hide the controls
 *
 * drag the mouse left or right in the window to adjust selected slider value
 */

Image back = Image("../asset/image/forest.jpg", 32);
Image offs = Image(back);

bool onButtonClick(Button this);
bool onCurveUpdate(Histogram this, int32 idx, argb value);

Histogram histogram = {
	enabled: false;
};
Histogram curves = {
	height: 256;
	lines: true;
	focusable: false;
	onUpdate: onCurveUpdate;
};

Button btnLuminosity = {
	onReset: onButtonClick;
	text: "luminosity";
};
Button btnRgb = {
	onReset: onButtonClick;
	text: "rgb";
};
Button btnRed = {
	onReset: onButtonClick;
	text: "red";
};
Button btnGreen = {
	onReset: onButtonClick;
	text: "green";
};
Button btnBlue = {
	onReset: onButtonClick;
	text: "blue";
};

Button btnDump = {
	onClick: onButtonClick;
	text: "dump";
	focusable: false;
};

DebugView debug = {
	focusable: false;
	measures: -1;
	draws: -1;
};

int32 onEvent(int32 action, int32 button, int32 x, int32 y) {
	if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
		// exit when releasing escape key
		return Window.quit();
	}
	if (action < Window.EVENT_PROCESSED) {
		// action was not processed by the widget, do not redraw
		return Window.timeoutMax;
	}
	debug.startTimer();

	if (FxWidget.showOriginal(debug.getWidget())) {
		offs.copy(0, 0, back, null);
		histogram.update(offs);
		return Window.timeoutMax;
	}


	bool useLuminosity = false;
	for (int i = 0; i < 256; i += 1) {
		if (ach(curves.data[i]) != i) {
			useLuminosity = true;
			break;
		}
	}
	if (useLuminosity) {
		offs.colorMap(0, 0, back, null, curves.data);
	} else {
		offs.colorMapRgb(0, 0, back, null, curves.data);
	}
	histogram.update(offs);
	return Window.timeoutMax;
}
bool onCurveUpdate(Histogram this, int32 idx, argb value) {
	Widget ui = this.getWidget();
	argb data& = this.data[idx];
	if (btnLuminosity.isFocused()) {
		data.a = value.a;
		return true;
	}
	if (btnRed.isFocused()) {
		data.r = value.r;
		return true;
	}
	if (btnGreen.isFocused()) {
		data.g = value.g;
		return true;
	}
	if (btnBlue.isFocused()) {
		data.b = value.b;
		return true;
	}
	if (btnRgb.isFocused()) {
		data.b = value.b;
		data.g = value.g;
		data.r = value.r;
		return true;
	}
	return false;
}
bool onButtonClick(Button this) {
	if (this == btnDump) {
		static if (struct(File) != null) {
			char str[32] = {...};
			File.out.write("\nint32_t lookup[256] = {\n");
			for (int i = 0; i < curves.data.length; i += 1) {
				if (i > 0) {
					File.out.write(",\n");
				}
				uint32 col = curves.data[i].v;
				int len = col.format(str, "\t0x%08x");
				File.write(File.out, str[... len]);
			}
			File.out.write("\n};\n");
		}
		return true;
	}
	for (int i = 0; i < 256; i += 1) {
		argb data& = curves.data[i];
		if (this == btnLuminosity) {
			data.a = i;
		}
		else if (this == btnRgb) {
			data.r = i;
			data.g = i;
			data.b = i;
		}
		else if (this == btnRed) {
			data.r = i;
		}
		else if (this == btnGreen) {
			data.g = i;
		}
		else if (this == btnBlue) {
			data.b = i;
		}
	}
	return true;
}

Window.show(offs, onEvent, FxWidget(
	histogram, curves,

	null,
	btnLuminosity, btnRgb, btnRed, btnGreen, btnBlue,
	btnDump,

	null, debug
));
offs.destroy();
back.destroy();
