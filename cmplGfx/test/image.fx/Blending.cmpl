/* Blend two images using a function and transparency
 *
 * use 'tab' / 'shift' + 'tab' to select next control
 * use 'enter' / 'shift' + 'enter' to select next control
 * use '+' / '-' to adjust value of selected control (use shift for more precision)
 * use 'backspace' / 'shift' + 'backspace' to reset selected / every control value
 * use 'space' to press a button, toggle switch or reset slider value
 * use '[' or ']' to show and hide the controls
 *
 * drag the mouse left or right in the window to adjust selected slider value
 */

Image base = Image("../asset/image/forest.jpg", 32);
Image image = Image("../asset/image/texture_nature_01.png", 32);
Image offs = Image(base);
Image blend = Image(image, offs.width(), offs.height(), -1, 1.);

static struct Blending {
	inline linear_dodge(float32 base, float32 blend) = Float32.min(base + blend, 1f);
	inline linear_burn(float32 base, float32 blend) = Float32.max(base + blend - 1, 0f);
	inline color_dodge(float32 base, float32 blend) = (blend == 1 ? blend : Float32.min(base / (1 - blend), 1f));
	inline color_burn(float32 base, float32 blend) = (blend == 0 ? blend : Float32.max((1 - ((1 - base) / blend)), 0f));

	vec4f addition(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = base + blend;
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f subtract(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = base - blend;
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f multiply(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = base * blend;
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f divide(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = base / blend;
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f difference(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = base > blend ? base - blend : blend - base;
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f exclusion(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = .5f - 2 * (base - .5f) * (blend - .5f);
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}

	vec4f lighten(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = base > blend ? base : blend;
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f darken(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = base < blend ? base : blend;
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f linearDodge(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = linear_dodge(base, blend);
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f linearBurn(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = linear_burn(base, blend);
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f colorDodge(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = color_dodge(base, blend);
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f colorBurn(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = color_burn(base, blend);
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}

	vec4f screen(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = 1 - (1 - base) * (1 - blend);
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f overlay(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = base < .5f
			? (2 * base * blend)
			: (1 - 2 * (1 - base) * (1 - blend));
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f softLight(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = blend < .5f
			? (2 * base * blend + base * base * (1 - 2 * blend))
			: (Float32.sqrt(base) * (2 * blend - 1) + 2 * base * (1 - blend));
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f hardLight(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = blend <= .5f
			? (base * (2 * blend))
			: (1 - (1 - base) * (1 - 2 * (blend - .5f)));
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f linearLight(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = blend < .5f
			? linear_burn(base, (2 * blend))
			: linear_dodge(base, (2 * (blend - .5f)));
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f vividLight(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = blend < .5f
			? color_burn(base, (2 * blend))
			: color_dodge(base, (2 * (blend - .5f)));
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
	vec4f pinLight(vec4f base, vec4f blend) {
		inline op(float32 base, float32 blend) = blend < .5f
			? Float32.min(base, 2 * blend)
			: Float32.max(base, 2 *(blend - .5f));
		return {
			x: op(base.x, blend.x);
			y: op(base.y, blend.y);
			z: op(base.z, blend.z);
			w: op(base.w, blend.w);
		};
	}
}

struct BlendButton: Button {
	vec4f blend(vec4f base, vec4f blend);
}

Switch chkReverse = {
	text: "reverse";
	focusable: false;
	width: 192;
};
Slider btnAlpha = {
	text: "alpha";
	value: .75;
};

BlendButton btnAddition = {
	text: "addition";
	blend: Blending.addition;
};
BlendButton btnSubtract = {
	text: "subtract";
	blend: Blending.subtract;
};
BlendButton btnMultiply = {
	text: "multiply";
	blend: Blending.multiply;
};
BlendButton btnDivide = {
	text: "divide";
	blend: Blending.divide;
};
BlendButton btnDifference = {
	text: "difference";
	blend: Blending.difference;
};
BlendButton btnExclusion = {
	text: "exclusion";
	blend: Blending.exclusion;
};

BlendButton btnLighten = {
	text: "lighten";
	blend: Blending.lighten;
};
BlendButton btnDarken = {
	text: "darken";
	blend: Blending.darken;
};
BlendButton btnLinearDodge = {
	text: "linearDodge";
	blend: Blending.linearDodge;
};
BlendButton btnLinearBurn = {
	text: "linearBurn";
	blend: Blending.linearBurn;
};
BlendButton btnColorDodge = {
	text: "colorDodge";
	blend: Blending.colorDodge;
};
BlendButton btnColorBurn = {
	text: "colorBurn";
	blend: Blending.colorBurn;
};

BlendButton btnScreen = {
	text: "screen";
	blend: Blending.screen;
};
BlendButton btnOverlay = {
	text: "overlay";
	blend: Blending.overlay;
};
BlendButton btnSoftLight = {
	text: "softLight";
	blend: Blending.softLight;
};
BlendButton btnHardLight = {
	text: "hardLight";
	blend: Blending.hardLight;
};
BlendButton btnLinearLight = {
	text: "linearLight";
	blend: Blending.linearLight;
};
BlendButton btnVividLight = {
	text: "vividLight";
	blend: Blending.vividLight;
};
BlendButton btnPinLight = {
	text: "pinLight";
	blend: Blending.pinLight;
};

DebugView debug = {
	focusable: false;
	measures: -1;
	draws: -1;
};

int32 onEvent(int32 action, int32 button, int32 x, int32 y) {
	if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
		// exit when releasing escape key
		return Window.quit();
	}
	if (action < Window.EVENT_PROCESSED) {
		// action was not processed by the widget, do not redraw
		return Window.timeoutMax;
	}

	debug.startTimer();
	bool reverse = chkReverse.selected != 0;
	offs.copy(reverse ? base : blend);
	if (BlendButton selected = debug.getWidget().getFocused().as(BlendButton)) {
		offs.copy(0, 0, reverse ? blend : base, null, selected.blend);
		// optionally apply the blend effect with alpha strength (copying back the original image)
		offs.blendAlpha(0, 0, reverse ? base : blend, null, 256 * (1 - btnAlpha.value));
	}
	else if (btnAlpha.isFocused()) {
		offs.blendAlpha(0, 0, reverse ? blend : base, null, 256 * btnAlpha.value);
	}
	return Window.timeoutMax;
}

Window.show(offs, onEvent, FxWidget(
	chkReverse,
	btnAlpha,
	btnAddition,
	btnSubtract,
	btnMultiply,
	btnDivide,
	btnDifference,
	btnExclusion,
	btnLighten,
	btnDarken,
	btnLinearDodge,
	btnLinearBurn,
	btnColorDodge,
	btnColorBurn,
	btnScreen,
	btnOverlay,
	btnSoftLight,
	btnHardLight,
	btnLinearLight,
	btnVividLight,
	btnPinLight,
	debug
));
offs.destroy();
base.destroy();
blend.destroy();
image.destroy();


/* References:
https://mouaif.wordpress.com/2009/01/05/photoshop-math-with-glsl-shaders/
https://gist.github.com/damienmortini/1dbfc4fb420420acf70d
*/
