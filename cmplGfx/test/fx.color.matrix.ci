// Hue saturation brightness demo.

gxSurf back = gxSurf("asset/image/forest.png", 32);
gxSurf font = gxSurf.openFnt("asset/font/modern-1.fnt");
gxSurf offs = gxSurf(back.width(), back.height(), back.depth());

static const mat4f INVERT = mat4f(
	-1, 0, 0, 1,
	0, -1, 0, 1,
	0, 0, -1, 1,
	0, 0,  0, 1
);

static const mat4f GREY_SCALE = mat4f(
	0.299, 0.587, 0.114, 0,
	0.299, 0.587, 0.114, 0,
	0.299, 0.587, 0.114, 0,
	0, 0, 0, 1
);

static const mat4f BLACK_AND_WHITE = mat4f(
	1.5, 1.5, 1.5, -1,
	1.5, 1.5, 1.5, -1,
	1.5, 1.5, 1.5, -1,
	0, 0, 0, 1
);

static const mat4f SEPIA_COLOR = mat4f(
	0.393, 0.769, 0.189, 0,
	0.349, 0.686, 0.168, 0,
	0.272, 0.534, 0.131, 0,
	0, 0, 0, 1
);

static const mat4f POLAROID_COLOR = mat4f(
	1.438,  -0.062, -0.062, 0,
	-0.122, 1.378,  -0.122, 0,
	-0.016, -0.016, 1.483, 0,
	-0.03,  0.05,   -0.02, 1
);

mat4f colorMatrix(float brightness, float saturation, float contrast, float hue) {
	static mat4f brightnessMat(float val) {
		return {
			x: vec4f(1., 0., 0., val);
			y: vec4f(0., 1., 0., val);
			z: vec4f(0., 0., 1., val);
			w: vec4f(0., 0., 0.,  1.);
		};
	}

	static mat4f saturationMat(float val) {
		//~ val between 0, 3
		const float inv = 1 - val;
		const float R = .213f * inv;
		const float G = .715f * inv;
		const float B = .072f * inv;

		return {
			x: vec4f(R + val, G, B, 0.);
			y: vec4f(R, G + val, B, 0.);
			z: vec4f(R, G, B + val, 0.);
			w: vec4f(0., 0., 0., 1.);
		};
	}

	static mat4f contrastMat(float val) {
		float32 c = val;
		float32 t = (1 - c) / 2;

		return {
			x: vec4f(c, 0, 0, t);
			y: vec4f(0, c, 0, t);
			z: vec4f(0, 0, c, t);
			w: vec4f(0, 0, 0, 1);
		};
	}

	static mat4f hueMat(float val) {
		//~ assert(val >= 0 && val <= 2 * Math.pi);
		inline lR = 0.213;
		inline lG = 0.715;
		inline lB = 0.072;
		float cV = val.cos();
		float sV = val.sin();
		return {
			x: vec4f(lR+cV*(1-lR)+sV*(   -lR), lG+cV*(   -lG)+sV*( -lG), lB+cV*( -lB)+sV*(1 - lB),0.);
			y: vec4f(lR+cV*(0-lR)+sV*(0.1430), lG+cV*(1 - lG)+sV*(0.14), lB+cV*( -lB)+sV*(-0.283),0.);
			z: vec4f(lR+cV*(0-lR)+sV*(lR - 1), lG+cV*(   -lG)+sV*(  lG), lB+cV*(1-lB)+sV*(    lB),0.);
			w: vec4f(0., 0., 0., 1.);
		};
	}

	mat4f result = mat4f(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	);

	return result
		.mul(brightnessMat(brightness))
		.mul(saturationMat(saturation))
		.mul(contrastMat(contrast))
		.mul(hueMat(hue));
}

int onEvent(int action, int button, int x, int y);
offs.show(onEvent);
offs.destroy();
back.destroy();
font.destroy();

int onEvent(int action, int button, int x, int y) {
	inline "lib/micro.ui.ci";

	static Slider brightness = {
		text: "brightness";
		minValue: -100;
		maxValue: 100;
	};
	static Slider saturation = {
		text: "saturation";
		maxValue: 500;
		value: 100;
	};
	static Slider contrast = {
		text: "contrast";
		minValue: -100;
		maxValue: 500;
		value: 100;
	};
	static Slider hue = {
		text: "hue";
		minValue: 0;
		maxValue: 360;
	};
	static Button original = {
		text: "original";
		selectable: true;
	};
	static Button invert = {
		text: "invert";
		selectable: true;
	};
	static Button grayScale = {
		text: "gray scale";
		selectable: true;
	};
	static Button blackAndWhite = {
		text: "black & white";
		selectable: true;
	};
	static Button sepiaColor = {
		text: "sepia color";
		selectable: true;
	};
	static Button polaroidColor = {
		text: "polaroid color";
		selectable: true;
	};
	static Slider time = {
		text: "time";
		enabled: false;
	};

	static Layout ui = Layout(offs, font,
		brightness, saturation, contrast, hue,
		original, invert, grayScale, blackAndWhite, sepiaColor, polaroidColor,
		time
	);
	bool redraw = action == Gui.WINDOW_INIT;

	if (uiEvent(ui, action, button, x, y)) {
		redraw = true;
	}
	else if (action == Gui.KEY_PRESS) {
		if (button == 27) {
			return -1;
		}
		if (button == ' ') {
			trace("dumping screen");
			offs.saveBmp("out/dump.bmp", 0);
		}
	}

	if (redraw) {
		uint64 start = System.millis();
		offs.resize(null, back, null, 1);
		if (ui.isSelected(original)) {
		}
		else if (ui.isSelected(invert)) {
			offs.colorMat(null, INVERT.data);
		}
		else if (ui.isSelected(grayScale)) {
			offs.colorMat(null, GREY_SCALE.data);
		}
		else if (ui.isSelected(blackAndWhite)) {
			offs.colorMat(null, BLACK_AND_WHITE.data);
		}
		else if (ui.isSelected(sepiaColor)) {
			offs.colorMat(null, SEPIA_COLOR.data);
		}
		else if (ui.isSelected(polaroidColor)) {
			offs.colorMat(null, POLAROID_COLOR.data);
		}
		else {
			float b = brightness.val() / 100.;
			float s = saturation.val() / 100.;
			float c = contrast.val() / 100.;
			float h = hue.val() / 100.;
			mat4f mat = colorMatrix(b, s, c, h);
			offs.colorMat(null, mat.data);
		}
		offs.drawHist(null, 0x00ffffff);

		time.value = System.millis() - start;
		ui.draw(30, 30);
	}

	return 0;
}
