// Blend two images using a function

inline linear_dodge(float32 base, float32 blend) = Math.min(base + blend, 1f);
inline linear_burn(float32 base, float32 blend) = Math.max(base + blend - 1, 0f);
inline color_dodge(float32 base, float32 blend) = (blend == 1 ? blend : Math.min(base / (1 - blend), 1f));
inline color_burn(float32 base, float32 blend) = (blend == 0 ? blend : Math.max((1 - ((1 - base) / blend)), 0f));

vec4f addition(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = base + blend;
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f subtract(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = base - blend;
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f multiply(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = base * blend;
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f divide(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = base / blend;
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f difference(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = base > blend ? base - blend : blend - base;
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f exclusion(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = .5f - 2 * (base - .5f) * (blend - .5f);
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f lighten(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = base > blend ? base : blend;
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f darken(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = base < blend ? base : blend;
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f linearDodge(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = linear_dodge(base, blend);
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f linearBurn(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = linear_burn(base, blend);
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f colorDodge(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = color_dodge(base, blend);
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f colorBurn(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = color_burn(base, blend);
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f screen(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = 1 - (1 - base) * (1 - blend);
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f overlay(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = base < .5f
		? (2 * base * blend)
		: (1 - 2 * (1 - base) * (1 - blend));
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f softLight(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = blend < .5f
		? (2 * base * blend + base * base * (1 - 2 * blend))
		: (float32.sqrt(base) * (2 * blend - 1) + 2 * base * (1 - blend));
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f hardLight(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = blend <= .5f
		? (base * (2 * blend))
		: (1 - (1 - base) * (1 - 2 * (blend - .5f)));
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f linearLight(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = blend < .5f
		? linear_burn(base, (2 * blend))
		: linear_dodge(base, (2 * (blend - .5f)));
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f vividLight(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = blend < .5f
		? color_burn(base, (2 * blend))
		: color_dodge(base, (2 * (blend - .5f)));
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}
vec4f pinLight(vec4f base, vec4f blend) {
	inline op(float32 base, float32 blend) = blend < .5f
		? Math.min(base, 2 * blend)
		: Math.max(base, 2 *(blend - .5f));
	return {
		x: op(base.x, blend.x);
		y: op(base.y, blend.y);
		z: op(base.z, blend.z);
		w: op(base.w, blend.w);
	};
}

gxSurf base = gxSurf("asset/image/forest.png", 32);
gxSurf image = gxSurf("asset/image/texture_nature_01.png", 32);
gxSurf font = gxSurf.openFnt("asset/font/modern-1.fnt");
gxSurf offs = gxSurf(base);
gxSurf blend = gxSurf(base);

// TODO: add translation to crop matrix
float32 xAsp = float32(offs.width()) / image.width();
float32 yAsp = float32(offs.height()) / image.height();
mat4f m = scale(vec4f(1, 1, 0, 1), Math.max(xAsp, yAsp));
blend.transform(null, image, null, 1, m.data);

int onEvent(int action, int button, int x, int y);
offs.show(onEvent);
font.destroy();
offs.destroy();
base.destroy();
blend.destroy();
image.destroy();

int onEvent(int action, int button, int x, int y) {
	inline "/lib/gfx/micro.ui.ci";

	static Checker chkOrder = {
		text: "order";
		on: "a => b";
		off: "b => a";
		checked: true;
		selectable: false;
	};
	static Slider btnAlpha = {
		text: "alpha";
		value: 192;
		maximum: 256;
		divisor: 256;
	};

	static Button btnAddition = {
		text: "addition";
		data: addition;
	};
	static Button btnSubtract = {
		text: "subtract";
		data: subtract;
	};
	static Button btnMultiply = {
		text: "multiply";
		data: multiply;
	};
	static Button btnDivide = {
		text: "divide";
		data: divide;
	};
	static Button btnDifference = {
		text: "difference";
		data: difference;
	};
	static Button btnExclusion = {
		text: "exclusion";
		data: exclusion;
	};

	static Button btnLighten = {
		text: "lighten";
		data: lighten;
	};
	static Button btnDarken = {
		text: "darken";
		data: darken;
	};
	static Button btnLinearDodge = {
		text: "linearDodge";
		data: linearDodge;
	};
	static Button btnLinearBurn = {
		text: "linearBurn";
		data: linearBurn;
	};
	static Button btnColorDodge = {
		text: "colorDodge";
		data: colorDodge;
	};
	static Button btnColorBurn = {
		text: "colorBurn";
		data: colorBurn;
	};

	static Button btnScreen = {
		text: "screen";
		data: screen;
	};
	static Button btnOverlay = {
		text: "overlay";
		data: overlay;
	};
	static Button btnSoftLight = {
		text: "softLight";
		data: softLight;
	};
	static Button btnHardLight = {
		text: "hardLight";
		data: hardLight;
	};
	static Button btnLinearLight = {
		text: "linearLight";
		data: linearLight;
	};
	static Button btnVividLight = {
		text: "vividLight";
		data: vividLight;
	};
	static Button btnPinLight = {
		text: "pinLight";
		data: pinLight;
	};

	static Slider time = {
		text: "time";
		enabled: false;
	};

	static Layout ui = Layout(offs, font,
		chkOrder,
		btnAlpha,
		btnAddition,
		btnSubtract,
		btnMultiply,
		btnDivide,
		btnDifference,
		btnExclusion,
		btnLighten,
		btnDarken,
		btnLinearDodge,
		btnLinearBurn,
		btnColorDodge,
		btnColorBurn,
		btnScreen,
		btnOverlay,
		btnSoftLight,
		btnHardLight,
		btnLinearLight,
		btnVividLight,
		btnPinLight,
		time);

	bool redraw = uiEvent(ui, action, button, x, y);
	if (action == Gui.KEY_PRESS) {
		if (button == 27) {
			return -1;
		}
	}
	if (redraw) {
		uint64 start = System.millis();
		bool reverse = chkOrder.checked;

		offs.copy(0, 0, reverse ? base : blend, null);
		View selected = ui.selected(View);
		if (selected != null) {
			vec4f fn(vec4f base, vec4f blend) = selected.data;
			offs.blend(0, 0, reverse ? blend : base, null, btnAlpha.val(), false, fn);
		}
		time.value = System.millis() - start;
		ui.draw(30, 30);
	}
	return 0;
}
