// interactive raytracer adapted from Pixel Bender: raytracer.pbk
// based only on spheres, no virtual methods
struct Light {
	vec4f position;
	vec4f ambient;
	vec4f diffuse;
	vec4f specular;
	// by default use constant light attenuation
	vec4f attenuation = vec4f(1, 0, 0, 0);
}

struct Sphere {
	vec4f position;   // x, y, z, radius
	vec4f color;      // r, g, b, TODO: alpha
	vec4f ambient;
	vec4f diffuse;
	vec4f specular;
	float32 shininess = 50;
	float32 reflection = 0;
	float32 checkBoard = 0;
}

Light lights[] = {
	Light {
		position: vec4f(0, 2, -4);
		ambient: vec4f(.1);
		diffuse: vec4f(1);
		specular: vec4f(1);
	};
};

Sphere things[5] = {
	Sphere { // fake the floor with a huge sphere
		position: vec4f(0.0, -1003, -8, 1000);
		color: vec4f(.6, .6, .6);
		checkBoard: 2000;
		ambient: vec4f(.1);
		diffuse: vec4f(.8);
		specular: vec4f(.5);
		reflection: .5;
	};
	Sphere { // put a shiny sphere in the middle
		position: vec4f(0, 2, -10, 2);
		color: vec4f(.8, .8, .8);
		ambient: vec4f(.05);
		diffuse: vec4f(.1);
		specular: vec4f(1);
		reflection: 1;
	};
};

/// returns the distance of the closest intersection
float32 intersect(vec4f pos, vec4f dir, int hitIndex&) {
	float32 result = Float32.inf;
	for (int i = 0; i < things.length; i += 1) {
		Sphere thing! = things[i];
		vec4f dst = pos - thing.position;
		float32 R = thing.position.w;
		float32 B = dp3(dst, dir);
		float32 C = dp3(dst, dst) - R * R;
		float32 D = (B * B) - C;

		if (D > 0) {
			float32 d = -B - Float32.sqrt(D);
			if(d > 0 && d < result) {
				hitIndex = i;
				result = d;
			}
		}
	}

	return result;
}

/// returns how much light is reflected by the object
vec4f shade(Sphere thing!, vec4f pos, vec4f dir, vec4f rayDir) {
	vec4f result = thing.ambient;
	for (int i = 0; i < lights.length; i += 1) {
		Light light! = lights[i];
		vec4f dst = light.position - pos;
		vec4f l = normalize(dst);
		float32 d = length(dst);
		int hitIdx;

		// exclude light if the ray intersects an object closer than the light
		if (intersect(pos, l, &hitIdx) <= d) {
			continue;
		}

		float32 attn = 1 / light.attenuation.eval(d);
		result += attn * thing.ambient * light.ambient;

		float32 diffuse = dp3(dir, l);
		if (diffuse <= 0) {
			continue;
		}

		diffuse = attn * diffuse;
		result += diffuse * thing.diffuse * light.diffuse;

		float32 specular = dp3(l - 2 * diffuse * dir, rayDir);
		if (specular <= 0) {
			continue;
		}

		specular = attn * Float32.pow(specular, thing.shininess);
		result += specular * thing.specular * light.specular;
	}
	return result;
}

/// returns reflection vector
inline reflect(vec4f v, vec4f n) = v - 2 * dp3(v, n) * n;

Camera camera = {};
mat4f mat = {};

// returns the color of the ray-traced scene
vec4f raytrace(vec4f xy) {
	inline MAX_RAY_SHOTS = 10;

	// calculate direction vector for this pixel
	vec4f rayDir = normalize(mat.transform(2 * xy.x - 1, -2 * xy.y + 1, -1));
	vec4f rayPos = camera.position;
	int hitIdx;

	vec4f result = vec4f(0);
	vec4f colorScale = vec4f(1);

	for (int depth = 0; depth < MAX_RAY_SHOTS; depth += 1) {
		float32 distance = intersect(rayPos, rayDir, &hitIdx);
		if (distance >= Float32.inf) {
			// no intersection
			return result;
		}

		Sphere thing& = things[hitIdx];
		vec4f hitPos = rayPos + rayDir * distance;
		vec4f hitDir = normalize(hitPos - thing.position);

		// material color
		vec4f color = thing.color;
		if (thing.checkBoard != 0) {
			bool zx = thing.checkBoard < 0;
			// fake check board texture with spherical uv mapping
			float32 u = thing.checkBoard * (1 + Float32.atan2(zx ? hitDir.x : hitDir.y, hitDir.z) / Float32.pi);
			float32 v = thing.checkBoard * (1 - Float32.acos(zx ? hitDir.y : hitDir.x) / Float32.pi);
			if ((Float32.floor(u) + Float32.floor(v)) % 2 == 0) {
				color *= .5f;
			}
		}

		// blend light with material color
		vec4f light = thing.shade(hitPos, hitDir, rayDir);
		result += colorScale * (color * light);

		if (thing.reflection <= 0) {
			// no reflection, stop ray tracing
			return result;
		}

		// blend according to reflectivity
		colorScale *= thing.reflection * color;

		// update next ray position and direction
		rayDir = normalize(reflect(rayDir, hitDir));
		rayPos = hitPos;
	}
	return result;
}

inline resolution = 512 / 2;
Image image = Image(resolution, resolution, 32);

int onEvent(int action, int button, int x, int y) {
	int64 time = System.millis();
	if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
		// exit when releasing escape key
		return Window.quit();
	}

	static int ox = 0;
	static int oy = 0;
	static int lookAt = 1;
	static float32 slow! = 1 / 50f;
	static float32 fast! = 5 / 50f;

	if (action == Window.MOUSE_MOTION || action == Window.FINGER_MOTION) {
		int dx = x - ox;
		int dy = y - oy;

		if (button == 1 || action == Window.FINGER_MOTION) {
			// orbit around the second sphere
			vec4f orbit = things[lookAt].position;
			camera.rotate(orbit, camera.up, dx * slow);
			camera.rotate(orbit, camera.right, dy * slow);
		}
		else if (button == 2) {
			// rotate the camera
			vec4f orbit = camera.position;
			camera.rotate(orbit, camera.up, -dx * slow);
			camera.rotate(orbit, camera.right, -dy * slow);
		}
		else if (button == 3) {
			// move the camera back and forward
			camera.move(camera.forward, dy * slow);
		}
		else if (button == 4) {
			// pan the camera
			camera.move(camera.right, -dx * slow);
			camera.move(camera.up, dy * slow);
		}
		else {
			// no need to process event
			return Window.timeoutMax;
		}
		ox = x;
		oy = y;
	}
	else if (action == Window.MOUSE_PRESS || action == Window.FINGER_PRESS) {
		ox = x;
		oy = y;
		return Window.timeoutMax;
	}
	else if (action == Window.GESTURE_SCROLL) {
		// move forward and back using the wheel/scroll
		camera.move(camera.forward, y * fast);
	}
	else if (action == Window.KEY_PRESS) {
		if (button == Window.KEY_CODE_ENTER) {
			vec4f target = things[lookAt].position;
			camera = Camera.lookAt(vec4f(target.x, target.y, target.z + target.w * 5, 1), target, vec4f(0, 1, 0));

		}
		else if (button == Window.KEY_CODE_TAB) {
			if ((y & Window.KEY_MASK_SHIFT) != 0) {
				lookAt -= 1;
				if (lookAt < 1) {
					lookAt = 1;
				}
			} else {
				lookAt += 1;
				if (lookAt >= things.length) {
					lookAt = 1;
				}
			}

			vec4f target = things[lookAt].position;
			camera = Camera.lookAt(vec4f(target.x, target.y, target.z + target.w * 5, 1), target, vec4f(0, 1, 0));
		}

		else if (button == Window.KEY_CODE_UP) {
			bool shift = bool(y & Window.KEY_MASK_SHIFT);
			camera.rotate(camera.position, camera.right, -(shift ? fast : slow));
		}
		else if (button == Window.KEY_CODE_DOWN) {
			bool shift = bool(y & Window.KEY_MASK_SHIFT);
			camera.rotate(camera.position, camera.right, +(shift ? fast : slow));
		}
		else if (button == Window.KEY_CODE_LEFT) {
			bool shift = bool(y & Window.KEY_MASK_SHIFT);
			camera.rotate(camera.position, camera.up, -(shift ? fast : slow));
		}
		else if (button == Window.KEY_CODE_RIGHT) {
			bool shift = bool(y & Window.KEY_MASK_SHIFT);
			camera.rotate(camera.position, camera.up, +(shift ? fast : slow));
		}

		else if (button == 'w') {
			bool shift = bool(y & Window.KEY_MASK_SHIFT);
			camera.move(camera.forward, +(shift ? fast : slow));
		}
		else if (button == 'a') {
			bool shift = bool(y & Window.KEY_MASK_SHIFT);
			camera.move(camera.right, -(shift ? fast : slow));
		}
		else if (button == 's') {
			bool shift = bool(y & Window.KEY_MASK_SHIFT);
			camera.move(camera.forward, -(shift ? fast : slow));
		}
		else if (button == 'd') {
			bool shift = bool(y & Window.KEY_MASK_SHIFT);
			camera.move(camera.right, +(shift ? fast : slow));
		}

		else if (button == ' ') {
			// reconfigure up
			camera = Camera.lookAt(camera.position, things[lookAt].position, vec4f(0, 1, 0));
			// trace("camera", camera);
		}

		else {
			return Window.timeoutMax;
		}
	}

	else if (action == Window.WINDOW_INIT) {
		// make a bunch of random spheres
		for (int i = 2; i < things.length; i += 1) {
			float32 fi = i * 11;
			Sphere sphere = {
				position: {
					x: Float32.sin(fi / 5) * 6;
					y: Float32.sin(fi / 4.1f) * 2.5f;
					z: -18 - Float32.sin(fi / 3.1f + 1.2f) * 10;
					w: Float32.pow(Float32.sin(fi / 1.34f + 65.3f) * .5f + .5f, 3f) + .2;
				};
				color: {
					x: Float32.cos(fi / 2.1 + 1.3) * .5 + .5;
					y: Float32.cos(fi / 0.1 + 1.3) * .5 + .5;
					z: Float32.cos(fi / 5.1 + 6.3) * .5 + .5;
				};
				ambient: vec4f(.1);
				diffuse: vec4f(.7);
				specular: vec4f(1);
				reflection: Float32.pow(Float32.sin(fi / 2.1f + 1.243f) * .5f + .5f, 5f);
			};
			things[i] = sphere;
		}
		camera = Camera.lookAt(vec4f(0, 0, 2), things[lookAt].position, vec4f(0, 1, 0));
	}
	else if (action == Window.EVENT_TIMEOUT) {}
	else {
		// no need to process event
		return Window.timeoutMax;
	}

	// recalculate frame
	mat = inverse(camera.matrix(45/2, 1, 1f, 10000f));
	image.eval(null, 0, 0, raytrace);
	time = System.millis() - time;
	char text[256] = {...};
	time.format(text, "Frame time: %d ms");
	Window.setTitle(text);
	return Window.timeoutMax;
}

Window.show(image, onEvent);
image.destroy();
