// simple raytracer adapted from Pixel Bender: raytracer.pbk
struct Light {
	vec4f position;
	vec4f ambient;
	vec4f diffuse;
	vec4f specular;
	// by default use constant light attenuation
	vec4f attenuation = vec4f(1, 0, 0, 0);
}

struct Thing: object {
	vec4f color;      // r, g, b, TODO: alpha
	vec4f ambient;
	vec4f diffuse;
	vec4f specular;
	float32 shininess = 50;
	float32 reflection = 0;

	float32 intersect(Thing this!, vec4f pos, vec4f dir);

	vec4f normal(Thing this!, vec4f pos);

	vec4f texture(Thing this!, vec4f pos) {
		return this.color;
	}
}

struct Plane: Thing {
	vec4f n;
	float32 d;

	float32 intersect(Plane this!, vec4f pos, vec4f dir) {
		float32 den = dp3(this.n, dir);
		inline eps = 1e-14f;

		if (-den < eps) {
			// use Float32.abs(den) value for both sides of the plane
			// no intersection
			return Float32.inf;
		}

		float32 distance = -(dp3(this.n, pos) + this.d) / den;
		if (distance < eps) {
			return Float32.inf;
		}
		return distance;
	}

	vec4f normal(Plane this!, vec4f pos) {
		return this.n;
	}

	static vec4f checkBoard(Plane this!, vec4f p) {
		vec4f n = vec4f(this.n.y, this.n.z, -this.n.x);
		float32 u = dp3(p, n);
		float32 v = dp3(p, cross(n, this.n));
		if (u < 0) { u = 1 - u; }
		if (v < 0) { v = 1 - v; }

		if ((Float32.floor(u) + Float32.floor(v)) % 2 == 0) {
			return this.color / 2;
		}
		return this.color;
	}
}

struct Sphere: Thing {
	vec4f position;
	float32 radius;

	float32 intersect(Sphere this!, vec4f pos, vec4f dir) {
		vec4f dst = pos - this.position;
		float32 R = this.radius;
		float32 B = dp3(dst, dir);
		float32 C = dp3(dst, dst) - R * R;
		float32 D = (B * B) - C;

		if (D <= 0) {
			// no intersection
			return Float32.inf;
		}

		// intersection!
		return -B - Float32.sqrt(D);
	}

	vec4f normal(Sphere this!, vec4f pos) {
		return normalize(pos - this.position);
	}

	static vec4f checkBoard(Sphere this!, vec4f pos) {
		inline s = 3 * this.radius;
		vec4f n = normal(this, pos);
		float32 u = s * (1 + Float32.atan2(n.y, n.z) / Float32.pi);
		float32 v = s * (1 - Float32.acos(n.x) / Float32.pi);
		if ((Float32.floor(u) + Float32.floor(v)) % 2 == 0) {
			return this.color / 2;
		}
		return this.color;
	}
}

struct SkyDome: Sphere {
	Image image;

	float32 intersect(SkyDome this!, vec4f pos, vec4f dir) {
		return Float32.abs(Sphere.intersect(this, pos, dir));
	}

	vec4f texture(SkyDome this!, vec4f pos) {
		vec4f n = normal(this, pos);
		float32 u = (1 + Float32.atan2(n.x, n.z) / Float32.pi) / 2;
		float32 v = Float32.acos(n.y) / Float32.pi;
		return this.image.tex(u, v);
	}
}

Light lights[] = {
	Light {
		position: vec4f(0, 2, -4);
		ambient: vec4f(.1);
		diffuse: vec4f(1);
		specular: vec4f(1);
	};
};

Thing things[20] = {
	SkyDome { // fake the environment with a huge sphere
		image: Image("../asset/image/garden.png");
		position: vec4f(0, 0, 0);
		radius: 100;
		color: vec4f(.6, .6, .6);
		ambient: vec4f(.8);
		diffuse: vec4f(0);
		specular: vec4f(0);
	};
	Plane { // the floor is a marble chess board
		n: normalize(vec4f(0, 1, 0));
		d: 3;
		color: vec4f(.6, .6, .6);
		texture: Plane.checkBoard;
		ambient: vec4f(.1);
		diffuse: vec4f(.8);
		specular: vec4f(.5);
		reflection: .5;
	};
	Sphere { // put a shiny sphere in the middle
		position: vec4f(0, 1, -10);
		radius: 2;
		color: vec4f(.8, .8, .8);
		ambient: vec4f(.05);
		diffuse: vec4f(.1);
		specular: vec4f(1);
		reflection: 1;
	};
};

// make a bunch of random spheres
for (int i = 3; i < things.length; i += 1) {
	float32 fi = i * 11;
	Sphere sphere = {
		position: {
			x: Float32.sin(fi / 5) * 6;
			y: Float32.sin(fi / 4.1f) * 2.5f;
			z: -18 - Float32.sin(fi / 3.1f + 1.2f) * 10;
		};
		radius: Float32.pow(Float32.sin(fi / 1.34f + 65.3f) * .5f + .5f, 3f) + .2f;
		color: {
			x: Float32.cos(fi / 2.1 + 1.3) * .5 + .5;
			y: Float32.cos(fi / 0.1 + 1.3) * .5 + .5;
			z: Float32.cos(fi / 5.1 + 6.3) * .5 + .5;
		};
		ambient: vec4f(.1);
		diffuse: vec4f(.7);
		specular: vec4f(1);
		reflection: Float32.pow(Float32.sin(fi / 2.1f + 1.243f) * .5f + .5f, 5f);
	};
	things[i] = sphere;
}

/// returns the distance of the closest intersection
float32 intersect(vec4f pos, vec4f dir, int hit&) {
	float32 result = Float32.inf;
	for (int i = 0; i < things.length; i += 1) {
		float32 distance = things[i].intersect(pos, dir);
		if (distance > 0 && distance < result) {
			result = distance;
			hit = i;
		}
	}

	return result;
}

/// returns how much light is reflected by the object
vec4f shade(Thing thing!, vec4f pos, vec4f dir, vec4f rayDir) {
	vec4f result = thing.ambient;
	for (int i = 0; i < lights.length; i += 1) {
		Light light! = lights[i];
		vec4f dst = light.position - pos;
		vec4f l = normalize(dst);
		float32 d = length(dst);
		int hitIdx;

		// exclude light if the ray intersects an object closer than the light
		if (intersect(pos, l, &hitIdx) <= d) {
			continue;
		}

		float32 attn = 1 / light.attenuation.eval(d);
		result += attn * thing.ambient * light.ambient;

		float32 diffuse = dp3(dir, l);
		if (diffuse <= 0) {
			continue;
		}

		diffuse = attn * diffuse;
		result += diffuse * thing.diffuse * light.diffuse;

		float32 specular = dp3(l - 2 * diffuse * dir, rayDir);
		if (specular <= 0) {
			continue;
		}

		specular = attn * Float32.pow(specular, thing.shininess);
		result += specular * thing.specular * light.specular;
	}
	return result;
}

/// returns reflection vector
inline reflect(vec4f v, vec4f n) = v - 2 * dp3(v, n) * n;

// returns the color of the ray-traced scene
vec4f raytrace(vec4f xy) {
	inline MAX_RAY_SHOTS = 100;

	// calculate direction vector for this pixel
	vec4f rayDir = normalize(vec4f(2 * xy.x - 1, -2 * xy.y + 1, -2));
	vec4f rayPos = vec4f(0);
	int hitIdx;

	vec4f result = vec4f(0);
	vec4f colorScale = vec4f(1);

	for (int depth = 0; depth < MAX_RAY_SHOTS; depth += 1) {
		float32 distance = intersect(rayPos, rayDir, &hitIdx);
		if (distance >= Float32.inf) {
			// no intersection
			return result;
		}

		Thing thing& = things[hitIdx];
		vec4f hitPos = rayPos + rayDir * distance;
		vec4f hitDir = thing.normal(hitPos);

		// material and texture color
		vec4f color = thing.texture(hitPos);

		// blend light with material color
		vec4f light = thing.shade(hitPos, hitDir, rayDir);
		result += colorScale * (color * light);

		if (thing.reflection <= 0) {
			// no reflection, stop ray tracing
			return result;
		}

		// blend according to reflectivity
		colorScale *= thing.reflection * color;

		// update next ray position and direction
		rayDir = normalize(reflect(rayDir, hitDir));
		rayPos = hitPos;
	}
	return result;
}

Window.show(512, 512, 0, raytrace);
