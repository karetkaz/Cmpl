// Hue saturation brightness demo.

gxSurf back = gxSurf("asset/image/forest.png", 32);
gxSurf font = gxSurf.openFnt("asset/font/modern-1.fnt");
gxSurf offs = gxSurf(back.width(), back.height(), back.depth());

void blur0(gxSurf surf, int radius, double sigma) {
	static double gauss(double x, double sigma) {
		inline SQRT_2_PI_INV = 0.398942280401432677939946059935;
		inline exp = double.exp;

		double t = x / sigma;
		/*switch (dx) {
			default:
				break;
			case -1:
				return 1;
			case 0:
				return SQRT_2_PI_INV * exp(-0.5*t*t) / sigma;
			case 1:
				return -x * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma);
			case 2:
				return (x * x - sigma * sigma) * SQRT_2_PI_INV * exp(-0.5*t*t) / (sigma * sigma * sigma * sigma * sigma);
		}*/
		return SQRT_2_PI_INV * exp(-0.5 * t * t) / sigma;
	}

	uint32 kernelF16[1024] = {};
	float64 kernel[1024] = {};
	float64 kernelSum = 0;

	int mid = radius + 1;
	int size = 2 * mid;

	assert(size < kernel.length);
	if (size <= 0) {
		return;
	}

	for (int i = 0; i < size; i += 1) {
		kernel[i] = gauss(mid - i, sigma);
		kernelSum += kernel[i];
	}

	kernelSum = 1;
	for (int i = 0; i < size; i += 1) {
		kernelF16[i] = 65536 * (kernel[i] / kernelSum);
	}

	int width = surf.width();
	int height = surf.height();
	gxSurf tmp = gxSurf(width, height, surf.depth());

	// x direction: inout -> temp
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			uint32 r = 0;
			uint32 g = 0;
			uint32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _x = x + i - mid;
				uint32 _k = kernelF16[i];
				if (_x >= 0 && _x < width) {
					argb col = argb(surf.get(_x, y));
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			tmp.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}

	// y direction: temp -> inout
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			uint32 r = 0;
			uint32 g = 0;
			uint32 b = 0;
			for (int i = 0; i < size; i += 1) {
				int _y = y + i - mid;
				uint32 _k = kernelF16[i];
				if (_y >= 0 || _y < height) {
					argb col = argb(tmp.get(x, _y));
					r += _k * rch(col);
					g += _k * gch(col);
					b += _k * bch(col);
				}
			}
			surf.set(x, y, argb(r >> 16, g >> 16, b >> 16));
		}
	}
	tmp.destroy();
}

inline blur(gxSurf surf, int radius) = surf.blur(radius, 0.3 * (radius - 1) + 0.8);

void sharpen(gxSurf surf, int amount, int radius) {
	gxSurf blur = gxSurf(surf);
	blur.blur(radius);
	surf.copy(0, 0, blur, null, -amount);

	/* native function is faster
	int width = surf.width();
	int height = surf.height();
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			inline lerp(int32 x, int32 y) = int32(x + -amount * (y - x) / 255);
			argb col = argb(blur.get(x,y));
			int r = rch(col);
			int g = gch(col);
			int b = bch(col);

			col = argb(surf.get(x,y));
			r = lerp(rch(col), r);
			g = lerp(gch(col), g);
			b = lerp(bch(col), b);

			surf.set(x, y, argb(r, g, b));
		}
	}// */
	blur.destroy();
}

int onEvent(int action, int button, int x, int y);
onEvent(Gui.KEY_PRESS, ' ', 0, 0);
offs.show(onEvent);
offs.destroy();
back.destroy();
font.destroy();

int onEvent(int action, int button, int x, int y) {
	static int amount = 0;
	static int radius = 5;
	static int ox = 0;
	static int oy = 0;

	static bool isCtrl = false;
	if (button == 0 && x == 37) {
		if (action == Gui.KEY_PRESS) {
			isCtrl = true;
		}
		if (action == Gui.KEY_RELEASE) {
			isCtrl = false;
		}
		debug("Ctrl", isCtrl);
	}

	static bool isShift = false;
	if (button == 0 && x == 50) {
		if (action == Gui.KEY_PRESS) {
			isShift = true;
		}
		if (action == Gui.KEY_RELEASE) {
			isShift = false;
		}
		debug("Shift", isShift);
	}

	bool reCalculate = false;
	if (action == Gui.KEY_PRESS) {
		if (button == 27) {
			return -1;
		}
		if (button == ' ') {
			reCalculate = true;
		}
		if (button == '\r') {
			amount = isShift ? 100 : 0;
			radius = isCtrl ? 100 : 0;
			reCalculate = true;
		}
		if (button == 'S') {
			trace("dumping screen");
			offs.saveBmp("out/dump.bmp", 0);
		}

		if (button == 0 && x == 116) {	// down
			int delta = isShift ? 10 : 1;
			if (isCtrl) {
				radius -= delta;
			} else {
				amount -= delta;
			}
			reCalculate = true;
		}
		if (button == 0 && x == 111) {	// up
			int delta = isShift ? 10 : 1;
			if (isCtrl) {
				radius += delta;
			} else {
				amount += delta;
			}
			reCalculate = true;
		}

		//debug("keypress", button);
	}
	else if (action == Gui.MOUSE_PRESS) {
		ox = x;
		oy = y;
		return 0;
	}
	else if (action == Gui.MOUSE_MOTION) {
		if (button == 1) {
			amount += oy - y;
			reCalculate = true;
		}
		else if (button > 1) {
			radius += oy - y;
			reCalculate = true;
		}
		ox = x;
		oy = y;
	}

	if (reCalculate) {
		// clamp input values
		amount = Math.clamp(amount, 0, 255);
		radius = Math.clamp(radius, 50, 200);

		uint64 time = System.millis();
		offs.resize(null, back, null, 1);
		offs.sharpen(amount, radius / 10);
		offs.drawHist(null, 0x00ffffff);

		// stop measure execution time
		time = System.millis() - time;

		char text[256];
		FormatFlags flags = { padLen: 4 };
		int pos = text.append(0, "amount: ");
		pos = text.append(pos, amount, flags);
		pos = text.append(pos, "\nradius: ");
		pos = text.append(pos, radius / 10, flags);
		pos = text.append(pos, "\ntime: ");
		pos = text.append(pos, time, flags);
		pos = text.append(pos, " ms\n");

		inline padding = 5;
		gxRect rect = { x: 30, y: 30, w: 0, h: 0 };
		font.clipText(rect, text);
		offs.fill(rect, padding, 0x000000);
		offs.drawText(rect.x, rect.y, font, text, 0xffffff);
	}

	return 0;
}
