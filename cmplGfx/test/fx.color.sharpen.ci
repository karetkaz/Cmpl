// Hue saturation brightness demo.

gxSurf back = gxSurf("asset/image/forest.png", 32);
gxSurf font = gxSurf.openFnt("asset/font/modern-1.fnt");
gxSurf offs = gxSurf(back.width(), back.height(), back.depth());

inline blur(gxSurf surf, int radius) = surf.blur(radius, 0.3 * (radius - 1) + 0.8);

void sharpen(gxSurf surf, int amount, int radius) {
	gxSurf blur = gxSurf(surf);
	blur.blur(radius);
	surf.copy(0, 0, blur, null, -amount);

	/* native alpha blend function is faster
	int width = surf.width();
	int height = surf.height();
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			inline lerp(int32 x, int32 y) = int32(x + -amount * (y - x) / 255);
			argb col = argb(blur.get(x,y));
			int r = rch(col);
			int g = gch(col);
			int b = bch(col);

			col = argb(surf.get(x,y));
			r = lerp(rch(col), r);
			g = lerp(gch(col), g);
			b = lerp(bch(col), b);

			surf.set(x, y, argb(r, g, b));
		}
	}// */
	blur.destroy();
}

int onEvent(int action, int button, int x, int y);
onEvent(Gui.KEY_PRESS, ' ', 0, 0);
offs.show(onEvent);
offs.destroy();
back.destroy();
font.destroy();

struct Slider {
	const char text[*];
	const int divValue = 1;
	const int minValue = 0;
	const int maxValue = 100;
	bool enabled = true;
	int value = 0;
	gxRect rect;//FIXME = {x: 0, y: 0, w: 0, h: 0};
}

int val(Slider slider&) {
	if (slider.value < slider.minValue) {
		slider.value = slider.minValue;
	}
	if (slider.value > slider.maxValue) {
		slider.value = slider.maxValue;
	}
	return slider.value / slider.divValue;
}

struct Checker {
	const char text[*];
	bool enabled = true;
	bool checked = false;
	gxRect rect;//FIXME = {x: 0, y: 0, w: 0, h: 0};
}

struct Button {
	const char text[*];
	bool enabled = true;
	void onClick();
	gxRect rect;//FIXME = {x: 0, y: 0, w: 0, h: 0};
}

struct Layout {
	variant items[200] = {};
	int selectedIndex = -1;
	int count = 0;
	gxRect rect;//FIXME = {x: 0, y: 0, w: 0, h: 0};
}

Layout Layout(variant items...) {
	Layout layout = {
		selectedIndex: -1;
		rect: {x: 0, y: 0, w: 0, h: 0};
	};
	for (int i = 0; i < items.length; i += 1) {
		if (layout.selectedIndex < 0 && items[i].is(Slider)) {
			// select first slider
			layout.selectedIndex = i;
		}
		layout.items[i] = items[i];
	}
	layout.count = items.length;
	return layout;
}

void draw(Layout layout&, int x, int y) {
	int posAll = 0;
	char textAll[1024];
	FormatFlags flags = { padLen: 4 };
	layout.rect.x = x;
	layout.rect.y = y;
	layout.rect.w = 0;
	layout.rect.h = 0;
	for (int i = 0; i < layout.count; i += 1) {
		int pos = 0;
		char text[256];
		if (i == layout.selectedIndex) {
			pos = text.append(pos, "* ");
		} else {
			pos = text.append(pos, " ");
		}
		if (Slider item& = layout.items[i].as(Slider)) {
			pos = text.append(pos, item.text);
			pos = text.append(pos, ": ");
			pos = text.append(pos, item.value / item.divValue, flags);
			font.clipText(item.rect, text);
			item.rect.x = x;
			item.rect.y = y;
			y += item.rect.h;
		}
		else if (Checker item& = layout.items[i].as(Checker)) {
			pos = text.append(pos, item.text);
			pos = text.append(pos, ": ");
			if (item.checked) {
				pos = text.append(pos, "on");
			} else {
				pos = text.append(pos, "off");
			}
			font.clipText(item.rect, text);
			item.rect.x = x;
			item.rect.y = y;
			y += item.rect.h;
		}
		else if (Button item& = layout.items[i].as(Button)) {
			pos = text.append(pos, item.text);
			font.clipText(item.rect, text);
			item.rect.x = x;
			item.rect.y = y;
			y += item.rect.h;
		}
		else {
			abort("item is not a known ui element", layout.items[i]);
		}
		posAll = textAll.append(posAll, text);
		posAll = textAll.append(posAll, "\n");
	}
	font.clipText(layout.rect, textAll);
	offs.fill(layout.rect, 5, 0x000000);
	offs.drawText(layout.rect.x, layout.rect.y, font, textAll, 0xffffff);
}

bool uiEvent(const Layout layout&, int action, int button, int x, int y) {
// TODO: void measure(Layout layout&) { }
// TODO: void layout(Layout layout&) { }
bool click(Layout layout&, int x, int y) {
	bool test(const gxRect rect&, int x, int y) {
		if (x < rect.x || x >= rect.x + rect.w) {
			return false;
		}
		if (y < rect.y || y >= rect.y + rect.h) {
			return false;
		}
		return true;
	}

	for (int i = 0; i < layout.count; i += 1) {
		if (Slider item& = layout.items[i].as(Slider)) {
			if (item.rect.test(x, y)) {
				// debug("clicked", item);
				if (!item.enabled) {
					return false;
				}
				if (layout.selectedIndex == i) {
					return false;
				}
				layout.selectedIndex = i;
				return true;
			}
		}
		else if (Checker item& = layout.items[i].as(Checker)) {
			if (item.rect.test(x, y)) {
				// debug("clicked", item);
				if (!item.enabled) {
					return false;
				}
				item.checked = !item.checked;
				return true;
			}
		}
		else if (Button item& = layout.items[i].as(Button)) {
			if (item.rect.test(x, y)) {
				// debug("clicked", item);
				if (!item.enabled) {
					return false;
				}
				item.onClick();
			}
		}
		else {
			abort("item is not a known ui element", layout.items[i]);
		}
	}
	return false;
}

bool update(Layout layout&, int delta) {
	if (layout.selectedIndex < 0) {
		return false;
	}
	Slider slider& = layout.items[layout.selectedIndex];
	slider.value += delta;
	return true;
}

	static int ox = 0;
	static int px = 0;
	static int oy = 0;
	static int py = 0;

	static bool isCtrl = false;
	if (button == 0 && x == 37) {
		if (action == Gui.KEY_PRESS) {
			isCtrl = true;
		}
		if (action == Gui.KEY_RELEASE) {
			isCtrl = false;
		}
		debug("Ctrl", isCtrl);
	}

	static bool isShift = false;
	if (button == 0 && x == 50) {
		if (action == Gui.KEY_PRESS) {
			isShift = true;
		}
		if (action == Gui.KEY_RELEASE) {
			isShift = false;
		}
		debug("Shift", isShift);
	}

	if (action == Gui.KEY_PRESS) {
		if (button == 0 && x == 116) {	// down
			int delta = isShift ? 10 : 1;
			if (layout.update(-delta)) {
				return true;
			}
		}
		if (button == 0 && x == 111) {	// up
			int delta = isShift ? 10 : 1;
			if (layout.update(+delta)) {
				return true;
			}
		}
	}
	else if (action == Gui.MOUSE_PRESS) {
		px = ox = x;
		py = oy = y;
	}
	else if (action == Gui.MOUSE_RELEASE) {
		if (button == 1 && x == px && y == py) {
			if (layout.click(x, y)) {
				return true;
			}
		}
	}
	else if (action == Gui.MOUSE_MOTION) {
		if (button == 1) {
			if (layout.update(oy - y)) {
				ox = x;
				oy = y;
				return true;
			}
		}
	}
	return false;
}

int onEvent(int action, int button, int x, int y) {
	static Checker autoUpdate = {
		text: "auto update";
		checked: true;
		rect: {x: 0, y: 0, w: 0, h: 0};
	};
	static Slider amount = {
		text: "amount";
		minValue: 0;
		maxValue: 512;
		rect: {x: 0, y: 0, w: 0, h: 0};
	};
	static Slider radius = {
		text: "radius";
		value: 50;
		divValue: 10;
		minValue: 0;
		maxValue: 200;
		rect: {x: 0, y: 0, w: 0, h: 0};
	};
	static Slider time = {
		text: "time";
		enabled: false;
		rect: {x: 0, y: 0, w: 0, h: 0};
	};
	static Layout layout = Layout(autoUpdate, amount, radius, time);
	static int ox = 0;
	static int oy = 0;

	bool reCalculate = false;
	if (uiEvent(layout, action, button, x, y)) {
		reCalculate = true;
	}
	else if (action == Gui.KEY_PRESS) {
		if (button == 27) {
			return -1;
		}
		if (button == ' ') {
			reCalculate = true;
		}
		if (button == '\r') {
			amount.value = 0;
			radius.value = 0;
			reCalculate = true;
		}
		if (button == 'S') {
			trace("dumping screen");
			offs.saveBmp("out/dump.bmp", 0);
		}

	}
	else if (action == Gui.MOUSE_PRESS) {
		ox = x;
		oy = y;
		return 0;
	}
	else if (action == Gui.MOUSE_RELEASE) {
	}
	else if (action == Gui.MOUSE_MOTION) {
		ox = x;
		oy = y;
	}

	if (reCalculate) {
		// clamp input values
		int amountValue = amount.val();
		int radiusValue = radius.val();

		uint64 start = System.millis();
		offs.resize(null, back, null, 1);
		if (autoUpdate.checked) {
			offs.sharpen(amountValue, radiusValue);
		}
		offs.drawHist(null, 0x00ffffff);
		time.value = System.millis() - start;

		layout.draw(30, 30);
	}

	return 0;
}
