#include <cmpl.h>
#include "g3_math.h"
#include "gx_color.h"
#include "gx_gui.h"
#include "gx_surf.h"
#include "g3_draw.h"

// utility macros and external time related functions
#define offsetOf(__RECORD, __FIELD) ((size_t) &((__RECORD*)NULL)->__FIELD)
#define sizeOf(__RECORD, __FIELD) sizeof(((__RECORD*)NULL)->__FIELD)
uint64_t timeMillis();


static struct GxImage fnt[64] = {0};
static GxImage defaultFont(int height);

struct camera cam[1] = {0}; // TODO: singleton like camera
struct GxLight lights[32] = {0};  // max 32 lights

// convert a double to 16 bit fixed point
#define fxp16(__VALUE) ((int32_t)(65536 * (double)(__VALUE)))

static inline vector a2Vec(vector storage, float32_t values[3]) {
	if (values == NULL) {
		return NULL;
	}
	storage->x = values[0];
	storage->y = values[1];
	storage->z = values[2];
	storage->w = 0;
	return storage;
}

static inline GxMesh meshMemMgr(nfcContext ctx, GxMesh recycle, int size) {
	GxMesh result = ctx->rt->api.alloc(ctx, recycle, size);
	if (result == NULL) {
		return NULL;
	}
	memset(result, 0, size);
	return result;
}

static const char *const proto_image_create2d = "Image create(int32 width, int32 height, int32 depth)";
static const char *const proto_image_create3d = "Image create3d(int32 width, int32 height)";
static const char *const proto_image_destroy = "void destroy(Image image)";
static const char *const proto_image_recycle = "Image recycle(Image recycle, int32 width, int32 height, int32 depth, int32 flags)";
static const char *const proto_image_slice = "Image slice(Image image, Rect rect?)";
static vmError surf_recycle(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	if (ctx->proto == proto_image_create2d) {
		int width = rt->api.nextArg(&al)->i32;
		int height = rt->api.nextArg(&al)->i32;
		int depth = rt->api.nextArg(&al)->i32;
		GxImage result = createImage(NULL, width, height, depth, Image2d);
		if (result != NULL) {
			retHnd(ctx, result);
			return noError;
		}
	}
	if (ctx->proto == proto_image_create3d) {
		int width = rt->api.nextArg(&al)->i32;
		int height = rt->api.nextArg(&al)->i32;
		GxImage result = createImage(NULL, width, height, 32, Image3d);
		if (result != NULL) {
			retHnd(ctx, result);
			return noError;
		}
	}
	if (ctx->proto == proto_image_destroy) {
		GxImage surf = rt->api.nextArg(&al)->ref;
		destroyImage(surf);
		return noError;
	}
	if (ctx->proto == proto_image_recycle) {
		GxImage recycle = rt->api.nextArg(&al)->ref;
		int width = rt->api.nextArg(&al)->i32;
		int height = rt->api.nextArg(&al)->i32;
		int depth = rt->api.nextArg(&al)->i32;
		int flags = rt->api.nextArg(&al)->i32;
		GxImage result = createImage(recycle, width, height, depth, flags);
		if (result != NULL) {
			retHnd(ctx, result);
			return noError;
		}
	}
	if (ctx->proto == proto_image_slice) {
		GxImage image = rt->api.nextArg(&al)->ref;
		GxRect region = rt->api.nextArg(&al)->ref;
		GxImage result = sliceImage(NULL, image, region);
		if (result != NULL) {
			retHnd(ctx, result);
			return noError;
		}
	}

	// result could not be returned
	return nativeCallError;
}

static const char *const proto_font_resized = "Image font(int height)";
static const char *const proto_font_default = "Image font";
static vmError surf_font(nfcContext ctx) {
	GxImage result = NULL;
	if (ctx->proto == proto_font_resized) {
		int size = argI32(ctx, 0);
		result = defaultFont(size);
	}
	else if (ctx->proto == proto_font_default) {
		result = defaultFont(0);
	}

	if (result == NULL) {
		return nativeCallError;
	}

	retHnd(ctx, result);
	return noError;
}

static const char *const proto_image_openImg = "Image openImg(char fileName[], int32 depth)";
static const char *const proto_image_openBmp = "Image openBmp(char fileName[], int32 depth)";
static const char *const proto_image_openPng = "Image openPng(char fileName[], int32 depth)";
static const char *const proto_image_openJpg = "Image openJpg(char fileName[], int32 depth)";
static const char *const proto_image_openTtf = "Image openTtf(char fileName[], int32 height)";
static const char *const proto_image_openFnt = "Image openFnt(char fileName[])";
static vmError surf_open(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	struct nfcArgArr fileNameArr = rt->api.nextArg(&al)->arr;
	char *fileName = fileNameArr.ref;
	size_t fileNameLen = strlen(fileName);

	if (fileNameLen > fileNameArr.length) {
		ctx->rt->api.raise(ctx, raiseFatal, "non zero terminated strings not implemented yet");
		return nativeCallError;
	}

	GxImage result = NULL;
	if (ctx->proto == proto_image_openImg) {
		int depth = rt->api.nextArg(&al)->i32;
		result = loadImg(NULL, fileName, depth);
	}
	else if (ctx->proto == proto_image_openTtf) {
		int height = rt->api.nextArg(&al)->i32;
		result = loadTtf(NULL, fileName, height, 31, 256);
	}
	else if (ctx->proto == proto_image_openBmp) {
		int depth = rt->api.nextArg(&al)->i32;
		result = loadBmp(NULL, fileName, depth);
	}
#ifndef NO_LIBPNG
	else if (ctx->proto == proto_image_openPng) {
		int depth = rt->api.nextArg(&al)->i32;
		result = loadPng(NULL, fileName, depth);
	}
#endif
#ifndef NO_LIBJPEG
	else if (ctx->proto == proto_image_openJpg) {
		int depth = rt->api.nextArg(&al)->i32;
		result = loadJpg(NULL, fileName, depth);
	}
#endif
	else if (ctx->proto == proto_image_openFnt) {
		result = loadFnt(NULL, fileName);
	}

	if (result == NULL) {
		return nativeCallError;
	}
	retHnd(ctx, result);
	return noError;
}

static const char *const proto_image_saveBmp = "void saveBmp(Image image, char path[], int32 flags)";
static vmError surf_save(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	struct nfcArgArr path = rt->api.nextArg(&al)->arr;
	int flags = rt->api.nextArg(&al)->i32;

	if (strlen(path.ref) > path.length) {
		ctx->rt->api.raise(ctx, raiseFatal, "non zero terminated strings not implemented yet");
		return nativeCallError;
	}

	int result = saveBmp(path.ref, surf, flags);
	if (result != 0) {
		return nativeCallError;
	}
	return noError;
}

static const char *const proto_image_width = "int32 width(Image image)";
static vmError surf_width(nfcContext ctx) {
	GxImage surf = argHnd(ctx, 0);
	retI32(ctx, surf->width);
	return noError;
}

static const char *const proto_image_height = "int32 height(Image image)";
static vmError surf_height(nfcContext ctx) {
	GxImage surf = argHnd(ctx, 0);
	retI32(ctx, surf->height);
	return noError;
}

static const char *const proto_image_depth = "int32 depth(Image image)";
static vmError surf_depth(nfcContext ctx) {
	GxImage surf = argHnd(ctx, 0);
	retI32(ctx, surf->depth);
	return noError;
}


static const char *const proto_image_get = "int32 get(Image image, int32 x, int32 y)";
static vmError surf_get(nfcContext ctx) {
	GxImage surf = argHnd(ctx, 8);
	int32_t x = argI32(ctx, 4);
	int32_t y = argI32(ctx, 0);

	retU32(ctx, getPixel(surf, x, y));
	return noError;
}

static const char *const proto_image_tex = "vec4f tex(Image image, float32 x, float32 y)";
static vmError surf_tex(nfcContext ctx) {
	GxImage surf = argHnd(ctx, 8);
	int32_t x = argF32(ctx, 4)* 65535 * surf->width;
	int32_t y = argF32(ctx, 0)* 65535 * surf->height;
	vector result = getArg(ctx, ctx->argc - sizeof(struct vector));
	vecldc(result, cast_rgb(getPixelLinear(surf, x, y)));
	return noError;
}

static const char *const proto_image_set = "void set(Image image, int32 x, int32 y, uint32 color)";
static vmError surf_set(nfcContext ctx) {
	GxImage surf = argHnd(ctx, 12);
	int32_t x = argI32(ctx, 8);
	int32_t y = argI32(ctx, 4);
	uint32_t color = argI32(ctx, 0);

	setPixel(surf, x, y, color);
	return noError;
}

static const char *const proto_image_drawText = "void drawText(Image image, Rect roi!, Image font, char text[], int32 color)";
static vmError surf_drawText(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	GxRect rect = rt->api.nextArg(&al)->ref;
	GxImage font = rt->api.nextArg(&al)->ref;
	struct nfcArgArr text = rt->api.nextArg(&al)->arr;
	uint32_t color = rt->api.nextArg(&al)->u32;
	struct GxRect textRect = *rect;
	if (!clipRect(surf, &textRect)) {
		return noError;
	}

	drawText(surf, rect, font, text.ref, text.length, color);
	return noError;
}

static const char *const proto_image_clipText = "void clipText(Image font, Rect rect&, char text[])";
static vmError surf_clipText(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage font = rt->api.nextArg(&al)->ref;
	GxRect rect = rt->api.nextArg(&al)->ref;
	struct nfcArgArr text = rt->api.nextArg(&al)->arr;

	clipText(rect, font, text.ref, text.length);
	return noError;
}

static const char *const proto_image_fillRect = "void fillRect(Image image, int x0, int y0, int x1, int y1, int incl, uint32 color)";
static vmError surf_fillRect(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	int x0 = rt->api.nextArg(&al)->i32;
	int y0 = rt->api.nextArg(&al)->i32;
	int x1 = rt->api.nextArg(&al)->i32;
	int y1 = rt->api.nextArg(&al)->i32;
	int incl = rt->api.nextArg(&al)->i32;
	uint32_t color = rt->api.nextArg(&al)->u32;

	fillRect(surf, x0, y0, x1, y1, incl, color);
	return noError;
}

static const char *const proto_image_blend_color = "color";
static const char *const proto_image_blend_alpha = "alpha";
static const char *const proto_image_blend_dstAlpha = "dstAlpha";
static const char *const proto_image_blend_vec4f = "blendVec4f";

static const char *const proto_image_lookup_3d = "lookup3d";
static const char *const proto_image_lookup_rgb = "lookupRgb";
static const char *const proto_image_lookup_rgbl = "lookupLrgb";
static const char *const proto_image_blend = "void copy(Image image, int32 x, int32 y, Image src, Rect roi?, pointer extra, uint32 blend(pointer extra, uint32 base, uint32 with))";
typedef struct bltContext {
	symn callback;
	vmOffs extra;
	nfcContext nfc;
} *bltContext;
static int blendCallback(argb* dst, argb *src, bltContext ctx, size_t cnt) {
	nfcContext nfc = ctx->nfc;
	rtContext rt = nfc->rt;
#pragma pack(push, 4)
	struct { argb with, base; vmOffs extra; } args = {
			.extra = ctx->extra
	};
#pragma pack(pop)
	for (size_t i = 0; i < cnt; ++i, ++dst, ++src) {
		args.base = *dst;
		args.with = *src;
		if (rt->api.invoke(nfc, ctx->callback, dst, &args, NULL) != noError) {
			return -1;
		}
	}
	return 0;
}
static int blendVec4fCb(argb* dst, argb *src, bltContext ctx, size_t cnt) {
	nfcContext nfc = ctx->nfc;
	rtContext rt = nfc->rt;
	for (size_t i = 0; i < cnt; ++i, ++dst, ++src) {
		struct vector args[2];
		vecldc(args + 0, *src);
		vecldc(args + 1, *dst);
		if (rt->api.invoke(nfc, ctx->callback, args, args, NULL) != noError) {
			return -1;
		}
		*dst = vecrgb(args);
	}
	return 0;
}

static int blendDstAlpha(argb* dst, argb *src, void *extra, size_t cnt) {
	for (size_t i = 0; i < cnt; ++i, ++dst, ++src) {
		*dst = mix_rgb(ach(dst->val), *dst, *src);
	}
	(void) extra;
	return 0;
}
static int blendColor(argb* dst, argb *src, void *extra, size_t cnt) {
	argb col = *(argb *)extra;
	int alpha = col.a;
	for (size_t i = 0; i < cnt; ++i, ++dst, ++src) {
		*dst = mix_rgb(alpha, col, *src);
	}
	return 0;
}

static int copyLut3d(argb* dst, argb *src, argb lut[256*256*256], size_t cnt) {
	for (size_t i = 0; i < cnt; ++i, ++dst, ++src) {
		*dst = lut[src->r + 256 * (src->g + 256 * src->b)];
	}
	return 0;
}
static int copyLutRgb(argb* dst, argb *src, argb lut[256], size_t cnt) {
	for (size_t i = 0; i < cnt; ++i, ++dst, ++src) {
		dst->b = lut[src->b].b;
		dst->g = lut[src->g].g;
		dst->r = lut[src->r].r;
		// dst->a = extra[src->a].a;
	}
	return 0;
}
static int copyLutRgbl(argb* dst, argb *src, argb lut[256], size_t cnt) {
	/*static const int32_t RGB2XYZ[12] = {
		fxp16(0.412453), fxp16(0.357580), fxp16(0.180423), 0,
		fxp16(0.212671), fxp16(0.715160), fxp16(0.072169), 0,
		fxp16(0.019334), fxp16(0.119193), fxp16(0.950227), 0,
	};
	static const int32_t XYZ2RGB[12] = {
		fxp16(+3.240479), fxp16(-1.537150), fxp16(-0.498535), 0,
		fxp16(-0.969256), fxp16(+1.875992), fxp16(+0.041556), 0,
		fxp16(+0.055648), fxp16(-0.204043), fxp16(+1.057311), 0,
	};

	static const int32_t RGB2YIQ[] = {
		fxp16(0.299), fxp16( 0.587), fxp16( 0.114), 0,
		fxp16(0.596), fxp16(-0.275), fxp16(-0.321), 0,
		fxp16(0.212), fxp16(-0.523), fxp16( 0.311), 0,
	};
	static const int32_t YIQ2RGB[] = {
		fxp16(1), fxp16( 0.956), fxp16( 0.621), 0,
		fxp16(1), fxp16(-0.272), fxp16(-0.647), 0,
		fxp16(1), fxp16(-1.105), fxp16( 1.702), 0,
	};*/

	static const int32_t rgb2luv[] = {
		fxp16( 0.299), fxp16( 0.587), fxp16( 0.114), 0,
		fxp16(-0.147), fxp16(-0.289), fxp16( 0.437), 0,
		fxp16( 0.615), fxp16(-0.515), fxp16(-0.100), 0,
	};
	static const int32_t luv2rgb[] = {
		fxp16(1), fxp16( 0.000), fxp16( 1.140), 0,
		fxp16(1), fxp16(-0.394), fxp16(-0.581), 0,
		fxp16(1), fxp16( 2.028), fxp16( 0.000), 0,
	};

	// use alpha channel as luminosity channel lookup for mapping
	for (size_t i = 0; i < cnt; ++i, ++dst, ++src) {
		int32_t r = lut[src->r].r;
		int32_t g = lut[src->g].g;
		int32_t b = lut[src->b].b;

		int32_t l = (r * rgb2luv[0x0] + g * rgb2luv[0x1] + b * rgb2luv[0x2]) >> 16;
		int32_t u = (r * rgb2luv[0x4] + g * rgb2luv[0x5] + b * rgb2luv[0x6]) >> 16;
		int32_t v = (r * rgb2luv[0x8] + g * rgb2luv[0x9] + b * rgb2luv[0xa]) >> 16;

		l = lut[sat_s8(l)].a;

		dst->r = sat_s8((l * luv2rgb[0x0] + u * luv2rgb[0x1] + v * luv2rgb[0x2]) >> 16);
		dst->g = sat_s8((l * luv2rgb[0x4] + u * luv2rgb[0x5] + v * luv2rgb[0x6]) >> 16);
		dst->b = sat_s8((l * luv2rgb[0x8] + u * luv2rgb[0x9] + v * luv2rgb[0xa]) >> 16);
	}
	return 0;
}

static vmError surf_blend(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	int x = rt->api.nextArg(&al)->i32;
	int y = rt->api.nextArg(&al)->i32;
	GxImage src = rt->api.nextArg(&al)->ref;
	GxRect roi = rt->api.nextArg(&al)->ref;
	size_t extra = argRef(ctx, rt->api.nextArg(&al)->offset);
	size_t offset = argRef(ctx, rt->api.nextArg(&al)->offset);
	symn builtin = rt->api.lookup(ctx->rt, offset, KIND_typ);
	symn callback = rt->api.lookup(ctx->rt, offset, KIND_fun);

	if (callback == NULL && builtin == NULL && offset != 0) {
		rt->api.raise(ctx, raiseError, "Invalid callback");
		return nativeCallError;
	}

	if (callback == NULL && builtin == NULL) {
		// convert from one color format to another, or copy
		bltProc blt = getBltProc(src->depth, surf->depth);

		if (copyImage(surf, x, y, src, roi, NULL, blt) < 0) {
			rt->api.raise(ctx, raiseError, "failed to copy image: %T", ctx->sym);
			return nativeCallError;
		}
		return noError;
	}

	if (surf->depth != 32 || src->depth != 32) {
		rt->api.raise(ctx, raiseError, "Image depths must be 32 to blend them with %T", ctx->sym);
		return nativeCallError;
	}

	struct bltContext args = {
			.callback = callback,
			.extra = extra,
			.nfc = ctx,
	};
	bltProc blt = NULL;
	void *arg = NULL;

	if (callback != NULL) {
		blt = (bltProc) blendCallback;
		arg = &args;
	}
	else if (builtin->fmt == proto_image_blend_vec4f) {
		args.callback = rt->api.lookup(ctx->rt, extra, KIND_fun);
		blt = (bltProc) blendVec4fCb;
		arg = &args;
		if (args.callback == NULL) {
			rt->api.raise(ctx, raiseError, "invalid callback function: %T", ctx->sym);
			return nativeCallError;
		}
	}
	else if (builtin->fmt == proto_image_blend_alpha) {
		blt = getBltProc(blt_cpy_mix, surf->depth);
		arg = vmPointer(rt, extra);
		if (blt == NULL || surf->depth != src->depth) {
			rt->api.raise(ctx, raiseError, "invalid alpha mixer for depth: %d <- %d", surf->depth, src->depth);
			return nativeCallError;
		}
	}
	else if (builtin->fmt == proto_image_blend_dstAlpha) {
		blt = (bltProc) blendDstAlpha;
	}
	else if (builtin->fmt == proto_image_blend_color) {
		// blt = getBltProc(blt_set_mix, surf->depth);
		blt = (bltProc) blendColor;
		arg = vmPointer(rt, extra);
	}

	else if (builtin->fmt == proto_image_lookup_3d) {
		blt = (bltProc) copyLut3d;
		arg = vmPointer(rt, extra);
	}
	else if (builtin->fmt == proto_image_lookup_rgb) {
		blt = (bltProc) copyLutRgb;
		arg = vmPointer(rt, extra);
	}
	else if (builtin->fmt == proto_image_lookup_rgbl) {
		blt = (bltProc) copyLutRgbl;
		arg = vmPointer(rt, extra);
	}

	if (copyImage(surf, x, y, src, roi, arg, blt) < 0) {
		rt->api.raise(ctx, raiseError, "failed to copy image: %T", ctx->sym);
		return nativeCallError;
	}

	return noError;
}

static const char *const proto_image_transform = "void transform(Image image, Rect rect?, Image src, Rect roi?, int32 interpolate, float32 mat[16])";
static vmError surf_transform(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	GxRect rect = rt->api.nextArg(&al)->ref;
	GxImage src = rt->api.nextArg(&al)->ref;
	GxRect roi = rt->api.nextArg(&al)->ref;
	int interpolate = rt->api.nextArg(&al)->i32;
	float32_t *mat = rt->api.nextArg(&al)->ref;

	if (transformImage(surf, rect, src, roi, interpolate, mat) < 0) {
		if (surf->depth != src->depth) {
			rt->api.raise(ctx, raiseError, "Invalid source depth: %d, in function: %T", src->depth, ctx->sym);
		}
		return nativeCallError;
	}
	return noError;
}

static const char *const proto_image_blur = "void blur(Image image, int32 radius, float64 sigma)";
static vmError surf_blur(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	int radius = rt->api.nextArg(&al)->i32;
	double sigma = rt->api.nextArg(&al)->f64;

	if (blurImage(surf, radius, sigma) != 0) {
		return nativeCallError;
	}
	return noError;
}

static const char *const proto_image_calcHueHist = "void calcHueHist(Image image, Rect roi?, uint32 lut[256])";
static const char *const proto_image_calcLumHist = "void calcLumHist(Image image, Rect roi?, uint32 lut[256])";
static const char *const proto_image_calcRgbHist = "void calcRgbHist(Image image, Rect roi?, uint32 lut[256])";
static vmError surf_calcHist(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	GxRect roi = rt->api.nextArg(&al)->ref;
	struct nfcArgArr lut = rt->api.nextArg(&al)->arr;

	if (surf->depth != 32) {
		rt->api.raise(ctx, raiseError, "Invalid depth: %d, in function: %T", surf->depth, ctx->sym);
		return nativeCallError;
	}

	/*if (lut.length != 256) {
		ctx->rt->api.raise(ctx, raiseError, "Invalid table size: %d (should be 256), in function: %T", lut.length, ctx->sym);
		return nativeCallError;
	}*/

	struct GxRect rect = {
		.x0 = roi ? roi->x0 : 0,
		.y0 = roi ? roi->y0 : 0,
		.x1 = roi ? roi->x1 : surf->width,
		.y1 = roi ? roi->y1 : surf->height,
	};

	const char *dptr = clipRect(surf, &rect);
	if (dptr == NULL) {
		rt->api.raise(ctx, raiseVerbose, "Empty roi, in function: %T", ctx->sym);
		return noError;
	}

	if (ctx->proto == proto_image_calcHueHist) {
		uint32_t *data = lut.ref;
		for (int i = 0; i < 256; ++i) {
			data[i] = 0;
		}
		for (int y = rect.y0; y < rect.y1; y += 1) {
			uint32_t *cBuff = (uint32_t *) dptr;
			for (int x = rect.x0; x < rect.x1; x += 1) {
				data[hue(*cBuff) * 255 / 360] += 1;
				cBuff += 1;
			}
			dptr += surf->scanLen;
		}
		return noError;
	}
	if (ctx->proto == proto_image_calcLumHist) {
		uint32_t *data = lut.ref;
		for (int i = 0; i < 256; ++i) {
			data[i] = 0;
		}
		for (int y = rect.y0; y < rect.y1; y += 1) {
			uint32_t *cBuff = (uint32_t *) dptr;
			for (int x = rect.x0; x < rect.x1; x += 1) {
				data[lum(*cBuff)] += 1;
				cBuff += 1;
			}
			dptr += surf->scanLen;
		}
		return noError;
	}

	// init
	uint32_t histB[256] = {0};
	uint32_t histG[256] = {0};
	uint32_t histR[256] = {0};
	for (int y = rect.y0; y < rect.y1; y += 1) {
		uint32_t *cBuff = (uint32_t *) dptr;
		for (int x = rect.x0; x < rect.x1; x += 1) {
			histB[bch(*cBuff)] += 1;
			histG[gch(*cBuff)] += 1;
			histR[rch(*cBuff)] += 1;
			cBuff += 1;
		}
		dptr += surf->scanLen;
	}

	uint32_t max = 1;
	for (size_t i = 0; i < 256; i += 1) {
		if (max < histB[i]) {
			max = histB[i];
		}
		if (max < histG[i]) {
			max = histG[i];
		}
		if (max < histR[i]) {
			max = histR[i];
		}
	}

	argb *data = lut.ref;
	for (size_t i = 0; i < 256; i += 1) {
		data[i].b = sat_u8(histB[i] * 255 / max);
		data[i].g = sat_u8(histG[i] * 255 / max);
		data[i].r = sat_u8(histR[i] * 255 / max);
		data[i].a = 0;
	}

	return noError;
}

static const char *const proto_image_colorMat =  "void colorMatrix(Image image, int32 x, int32 y, Image src, Rect roi?, float32 mat[16])";
static int colorMatrix(argb* dst, argb *src, int32_t fxp4x3[16], size_t cnt) {
	for (size_t i = 0; i < cnt; ++i, ++dst, ++src) {
		int32_t r = src->r;
		int32_t g = src->g;
		int32_t b = src->b;

		dst->r = sat_s8((r * fxp4x3[0x0] + g * fxp4x3[0x1] + b * fxp4x3[0x2] + fxp4x3[0x3]) >> 16);
		dst->g = sat_s8((r * fxp4x3[0x4] + g * fxp4x3[0x5] + b * fxp4x3[0x6] + fxp4x3[0x7]) >> 16);
		dst->b = sat_s8((r * fxp4x3[0x8] + g * fxp4x3[0x9] + b * fxp4x3[0xa] + fxp4x3[0xb]) >> 16);
	}
	return 0;
}
static vmError surf_colorMat(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	int x = rt->api.nextArg(&al)->i32;
	int y = rt->api.nextArg(&al)->i32;
	GxImage src = rt->api.nextArg(&al)->ref;
	GxRect roi = rt->api.nextArg(&al)->ref;
	struct nfcArgArr mat = rt->api.nextArg(&al)->arr;

	if (surf->depth != 32) {
		rt->api.raise(ctx, raiseError, "Invalid depth: %d, in function: %T", surf->depth, ctx->sym);
		return nativeCallError;
	}

	/*if (mat.length != 16) {
		ctx->rt->api.raise(ctx, raiseError, "Invalid matrix size: %d (should be 16), in function: %T", surf->depth, ctx->sym);
		return nativeCallError;
	}*/

	// convert floating point values to fixed point(16.16) values
	int32_t cMat[16];
	float32_t *matPtr = mat.ref;
	for (int i = 0; i < 16; i++) {
		cMat[i] = fxp16(matPtr[i]);
	}
	cMat[0x3] *= 256;
	cMat[0x7] *= 256;
	cMat[0xb] *= 256;
	if (copyImage(surf, x, y, src, roi, cMat, (bltProc) colorMatrix) < 0) {
		rt->api.raise(ctx, raiseError, "failed to copy image: %T", ctx->sym);
		return nativeCallError;
	}
	return noError;
}

static const char *const proto_image_gradient = "void gradient(Image image, Rect roi?, int32 type, bool repeat, uint32 colors...)";
static vmError surf_gradient(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	GxRect roi = rt->api.nextArg(&al)->ref;
	GradientFlags type = rt->api.nextArg(&al)->i32;
	int repeat = rt->api.nextArg(&al)->i32;
	struct nfcArgArr colors = rt->api.nextArg(&al)->arr;
	if (repeat) {
		type |= flag_repeat;
	}
	drawGradient(surf, roi, type, colors.length, colors.ref);
	return noError;
}

static const char *const proto_mesh_create = "Mesh create(int32 size)";
static const char *const proto_mesh_recycle = "Mesh recycle(Mesh recycle, int32 size)";
static vmError mesh_recycle(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxMesh recycle = NULL;
	int size = 32;
	if (ctx->proto == proto_mesh_recycle) {
		recycle = rt->api.nextArg(&al)->ref;
		size = rt->api.nextArg(&al)->i32;
	}
	if (ctx->proto == proto_mesh_create) {
		recycle = meshMemMgr(ctx, NULL, sizeof(struct GxMesh));
		size = rt->api.nextArg(&al)->i32;
	}
	GxMesh result = createMesh(recycle, (size_t) size);
	if (result == NULL) {
		return nativeCallError;
	}
	retRef(ctx, vmOffset(ctx->rt, result));
	return noError;
}

static const char *const proto_mesh_destroy = "void destroy(Mesh mesh)";
static vmError mesh_destroy(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxMesh mesh = rt->api.nextArg(&al)->ref;
	destroyMesh(mesh);
	meshMemMgr(ctx, mesh, 0);
	return noError;
}

static const char *const proto_image_drawMesh = "int32 drawMesh(Image image, Mesh mesh, int32 mode)";
static vmError surf_drawMesh(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage surf = rt->api.nextArg(&al)->ref;
	GxMesh mesh = rt->api.nextArg(&al)->ref;
	int32_t mode = rt->api.nextArg(&al)->i32;

	retI32(ctx, drawMesh(surf, mesh, cam, lights, mode));
	return noError;
}

static const char *const proto_mesh_openObj = "Mesh openObj(char path[])";
static const char *const proto_mesh_open3ds = "Mesh open3ds(char path[])";
static vmError mesh_open(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	struct nfcArgArr path = rt->api.nextArg(&al)->arr;
	if (strlen(path.ref) > path.length) {
		ctx->rt->api.raise(ctx, raiseFatal, "non zero terminated strings not implemented yet");
		return nativeCallError;
	}

	GxMesh result = meshMemMgr(ctx, NULL, sizeof(struct GxMesh));
	if (result == NULL) {
		return nativeCallError;
	}
	memset(result, 0, sizeof(struct GxMesh));
	createMesh(result, 20);
	result->hasTex = result->hasNrm = 0;
	result->tricnt = result->vtxcnt = 0;
	if (ctx->proto == proto_mesh_openObj) {
		if (!readObj(result, path.ref)) {
			return nativeCallError;
		}
	}
	else if (ctx->proto == proto_mesh_open3ds) {
		if (!read3ds(result, path.ref)) {
			return nativeCallError;
		}
	}
	else {
		meshMemMgr(ctx, result, 0);
		return nativeCallError;
	}

	retRef(ctx, vmOffset(ctx->rt, result));
	return noError;
}

static const char *const proto_mesh_saveObj = "void saveObj(Mesh mesh, char path[])";
static vmError mesh_save(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxMesh mesh = rt->api.nextArg(&al)->ref;
	struct nfcArgArr path = rt->api.nextArg(&al)->arr;
	if (strlen(path.ref) > path.length) {
		ctx->rt->api.raise(ctx, raiseFatal, "non zero terminated strings not implemented yet");
		return nativeCallError;
	}

	if (mesh == NULL) {
		return nativeCallError;
	}

	if (!saveObj(mesh, path.ref)) {
		return nativeCallError;
	}
	return noError;
}

static const char *const proto_mesh_normalize = "void normalize(Mesh mesh, float32 tolerance, float32 center[3], float32 resize[3])";
static vmError mesh_normalize(nfcContext ctx) {
	struct vector args[2];
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxMesh mesh = rt->api.nextArg(&al)->ref;
	float32_t tolerance = rt->api.nextArg(&al)->f32;
	vector center = a2Vec(&args[0], rt->api.nextArg(&al)->ref);
	vector resize = a2Vec(&args[1], rt->api.nextArg(&al)->ref);
	normMesh(mesh, tolerance, center, resize);
	return noError;
}

static const char *const proto_mesh_addVertex = "int32 addVertex(Mesh mesh, float32 x, float32 y, float32 z)";
static vmError mesh_addVertex(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxMesh mesh = rt->api.nextArg(&al)->ref;
	scalar pos[3];
	pos[0] = rt->api.nextArg(&al)->f32;
	pos[1] = rt->api.nextArg(&al)->f32;
	pos[2] = rt->api.nextArg(&al)->f32;
	if (!addVtx(mesh, pos, NULL, NULL)) {
		// return nativeCallError;
		retI32(ctx, -1);
		return noError;
	}
	retI32(ctx, mesh->vtxcnt - 1);
	return noError;
}

static const char *const proto_mesh_addLine = "int32 addLine(Mesh mesh, int32 v1, int32 v2)";
static const char *const proto_mesh_addFace = "int32 addFace(Mesh mesh, int32 v1, int32 v2, int32 v3)";
static const char *const proto_mesh_addQuad = "int32 addFace(Mesh mesh, int32 v1, int32 v2, int32 v3, int32 v4)";
static vmError mesh_addFace(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxMesh mesh = rt->api.nextArg(&al)->ref;
	int res = -1;
	if (ctx->proto == proto_mesh_addLine) {
		int v1 = rt->api.nextArg(&al)->i32;
		int v2 = rt->api.nextArg(&al)->i32;
		res = addSeg(mesh, v1, v2);
	}
	if (ctx->proto == proto_mesh_addFace) {
		int v1 = rt->api.nextArg(&al)->i32;
		int v2 = rt->api.nextArg(&al)->i32;
		int v3 = rt->api.nextArg(&al)->i32;
		res = addTri(mesh, v1, v2, v3);
	}
	if (ctx->proto == proto_mesh_addQuad) {
		int v1 = rt->api.nextArg(&al)->i32;
		int v2 = rt->api.nextArg(&al)->i32;
		int v3 = rt->api.nextArg(&al)->i32;
		int v4 = rt->api.nextArg(&al)->i32;
		res = addQuad(mesh, v1, v2, v3, v4);
	}
	if (!res) {
		// return nativeCallError;
		retI32(ctx, -1);
		return noError;
	}
	retI32(ctx, mesh->tricnt - 1);
	return noError;
}

static const char *const proto_mesh_setVertexPos = "bool setVertex(Mesh mesh, int32 idx, float32 x, float32 y, float32 z)";
static const char *const proto_mesh_setVertexNrm = "bool setNormal(Mesh mesh, int32 idx, float32 x, float32 y, float32 z)";
static const char *const proto_mesh_setVertexTex = "bool setTexture(Mesh mesh, int32 idx, float32 s, float32 t)";
static vmError mesh_setVertex(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxMesh mesh = rt->api.nextArg(&al)->ref;
	int32_t idx = rt->api.nextArg(&al)->i32;
	int res = 0;
	if (ctx->proto == proto_mesh_setVertexPos) {
		scalar pos[3];
		pos[0] = rt->api.nextArg(&al)->f32;
		pos[1] = rt->api.nextArg(&al)->f32;
		pos[2] = rt->api.nextArg(&al)->f32;
		res = setVtx(mesh, idx, pos, NULL, NULL);
	}
	if (ctx->proto == proto_mesh_setVertexNrm) {
		scalar nrm[3];
		nrm[0] = rt->api.nextArg(&al)->f32;
		nrm[1] = rt->api.nextArg(&al)->f32;
		nrm[2] = rt->api.nextArg(&al)->f32;
		res = setVtx(mesh, idx, NULL, nrm, NULL);
	}
	if (ctx->proto == proto_mesh_setVertexTex) {
		scalar tex[2];
		tex[0] = rt->api.nextArg(&al)->f32;
		tex[1] = rt->api.nextArg(&al)->f32;
		res = setVtx(mesh, idx, NULL, NULL, tex);
	}
	retI32(ctx, res != 0);
	return noError;
}

typedef struct mainLoopArgs {
	nfcContext nfc;
	symn callback;
	vmError error;
	uint64_t timeout;
	GxWindow window;
	struct {
		int32_t y;
		int32_t x;
		int32_t button;
		int32_t action;
		vmOffs closure;
	} event;

} *mainLoopArgs;

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
static void exitMainLoop(mainLoopArgs args) {
	emscripten_cancel_main_loop();
	destroyWindow(args->window);
}
#else

static void exitMainLoop(mainLoopArgs args) {
	args->event.action = WINDOW_CLOSE;
}
#endif

static void mainLoopCallback(mainLoopArgs args) {
#ifdef __EMSCRIPTEN__
	int timeout = 0; // workaround for webassembly
#else
	int timeout = (int) (args->timeout - timeMillis());
	if (timeout < 0) timeout = 0;
#endif
	args->event.action = getWindowEvent(args->window, &args->event.button, &args->event.x, &args->event.y, timeout);
	if (args->event.action == WINDOW_CLOSE) {
		// window is closing, quit loop
		return exitMainLoop(args);
	}

	uint64_t now = timeMillis();
	if (args->event.action == 0) {
		// skip unknown events
		if (args->timeout > now) {
			return;
		}
		args->event.action = EVENT_TIMEOUT;
	}

	symn callback = args->callback;
	if (callback != NULL) {
		nfcContext nfc = args->nfc;
		rtContext rt = nfc->rt;
		args->error = rt->api.invoke(nfc, callback, &timeout, &args->event, args);
		if (args->error != noError) {
			return exitMainLoop(args);
		}
	} else {
		if (args->event.action == KEY_RELEASE && args->event.button == KEY_CODE_ESC) {
			// if there is no callback, exit wit esc key
			return exitMainLoop(args);
		}
		timeout = INT32_MAX;
	}
	args->timeout = now + timeout;
	flushWindow(args->window);
}

static const char *const proto_window_show = "void show(Image surf, pointer closure, int32 onEvent(pointer closure, int32 action, int32 button, int32 x, int32 y))";
static vmError window_show(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxImage offScreen = rt->api.nextArg(&al)->ref;
	size_t cbClosure = argRef(ctx, rt->api.nextArg(&al)->offset);
	size_t cbOffs = argRef(ctx, rt->api.nextArg(&al)->offset);

	struct mainLoopArgs args = {0};
	args.nfc = ctx;
	args.error = noError;
	args.callback = rt->api.lookup(ctx->rt, cbOffs, KIND_fun);
	args.event.closure = (vmOffs) cbClosure;

	int timeout = 0;
	args.window = createWindow(offScreen, rt->main->unit);
	if (args.callback != NULL) {
		args.event.action = WINDOW_INIT;
		args.event.button = 0;
		args.event.x = 0;
		args.event.y = 0;
		vmError error = rt->api.invoke(ctx, args.callback, &timeout, &args.event, &args);
		if (error != noError) {
			return error;
		}
	}
	args.timeout = timeout + timeMillis();
	flushWindow(args.window);

#ifdef __EMSCRIPTEN__
	emscripten_set_main_loop_arg((void*)mainLoopCallback, &args, 0, 1);
	return noError;
#endif
	for ( ; args.event.action != WINDOW_CLOSE; ) {
		mainLoopCallback(&args);
	}

	if (args.callback != NULL) {
		args.event.action = WINDOW_CLOSE;
		args.event.button = 0;
		args.event.x = 0;
		args.event.y = 0;
		rt->api.invoke(ctx, args.callback, NULL, &args.event, &args);
	}

	destroyWindow(args.window);
	return args.error;
}

static const char *const proto_window_title = "void setTitle(char title[])";
static vmError window_title(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	mainLoopArgs args = (mainLoopArgs) ctx->extra;
	if (args != NULL && args->window != NULL) {
		struct nfcArgArr title = rt->api.nextArg(&al)->arr;
		if (strlen(title.ref) > title.length) {
			ctx->rt->api.raise(ctx, raiseFatal, "non zero terminated strings not implemented yet");
			return nativeCallError;
		}
		setWindowTitle(args->window, title.ref);
		return noError;
	}
	return nativeCallError;
}

static const char *const proto_window_quit = "int32 quit()";
static vmError window_quit(nfcContext ctx) {
	mainLoopArgs args = (mainLoopArgs) ctx->extra;
	if (args != NULL && args->window != NULL) {
		exitMainLoop(args);
		retI32(ctx, 0);
		return noError;
	}
	return nativeCallError;
}

static const char *const proto_camera_set = "void camera(float32 proj[16], float32 position[4], float32 forward[4], float32 right[4], float32 up[4])";
static vmError camera_set(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	matrix proj = rt->api.nextArg(&al)->ref;
	vector position = rt->api.nextArg(&al)->ref;
	vector forward = rt->api.nextArg(&al)->ref;
	vector right = rt->api.nextArg(&al)->ref;
	vector up = rt->api.nextArg(&al)->ref;

	memcpy(&cam->proj, proj, sizeof(struct matrix));
	memcpy(&cam->pos, position, sizeof(struct vector));
	memcpy(&cam->dirF, forward, sizeof(struct vector));
	memcpy(&cam->dirR, right, sizeof(struct vector));
	memcpy(&cam->dirU, up, sizeof(struct vector));
	return noError;
}


static const char *const proto_lights_enabled = "bool enabled(int32 light)";
static const char *const proto_lights_enable = "void enable(int32 light, bool on)";
static const char *const proto_lights_position = "void position(int32 light, float32 x, float32 y, float32 z)";
static const char *const proto_lights_ambient = "void ambient(int32 light, float32 r, float32 g, float32 b)";
static const char *const proto_lights_diffuse = "void diffuse(int32 light, float32 r, float32 g, float32 b)";
static const char *const proto_lights_specular = "void specular(int32 light, float32 r, float32 g, float32 b)";
static const char *const proto_lights_attenuation = "void attenuation(int32 light, float32 constant, float32 linear, float32 quadratic)";
static vmError lights_manager(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	size_t light = rt->api.nextArg(&al)->i32;

	if (light >= (sizeof(lights) / sizeof(*lights))) {
		return nativeCallError;
	}

	if (ctx->proto == proto_lights_enabled) {
		retI32(ctx, lights[light].attr);
		return noError;
	}

	if (ctx->proto == proto_lights_enable) {
		int on = rt->api.nextArg(&al)->i32;
		lights[light].attr = on;
		return noError;
	}

	if (ctx->proto == proto_lights_position) {
		float32_t x = rt->api.nextArg(&al)->f32;
		float32_t y = rt->api.nextArg(&al)->f32;
		float32_t z = rt->api.nextArg(&al)->f32;
		vecldf(&lights[light].pos, x, y, z, 1);
		return noError;
	}

	if (ctx->proto == proto_lights_ambient) {
		float32_t r = rt->api.nextArg(&al)->f32;
		float32_t g = rt->api.nextArg(&al)->f32;
		float32_t b = rt->api.nextArg(&al)->f32;
		vecldf(&lights[light].ambi, r, g, b, 1);
		return noError;
	}

	if (ctx->proto == proto_lights_diffuse) {
		float32_t r = rt->api.nextArg(&al)->f32;
		float32_t g = rt->api.nextArg(&al)->f32;
		float32_t b = rt->api.nextArg(&al)->f32;
		vecldf(&lights[light].diff, r, g, b, 1);
		return noError;
	}

	if (ctx->proto == proto_lights_specular) {
		float32_t r = rt->api.nextArg(&al)->f32;
		float32_t g = rt->api.nextArg(&al)->f32;
		float32_t b = rt->api.nextArg(&al)->f32;
		vecldf(&lights[light].spec, r, g, b, 0);
		return noError;
	}

	if (ctx->proto == proto_lights_attenuation) {
		float32_t constant = rt->api.nextArg(&al)->f32;
		float32_t linear = rt->api.nextArg(&al)->f32;
		float32_t quadratic = rt->api.nextArg(&al)->f32;
		vecldf(&lights[light].attn, constant, linear, quadratic, 0);
		return noError;
	}

	return illegalState;
}

static const char *const proto_material_ambient = "void ambient(Mesh mesh, float32 r, float32 g, float32 b)";
static const char *const proto_material_diffuse = "void diffuse(Mesh mesh, float32 r, float32 g, float32 b)";
static const char *const proto_material_specular = "void specular(Mesh mesh, float32 r, float32 g, float32 b)";
static const char *const proto_material_shine = "void shine(Mesh mesh, float32 value)";
static const char *const proto_material_texture = "void texture(Mesh mesh, Image texture)";
static vmError mesh_material(nfcContext ctx) {
	rtContext rt = ctx->rt;
	struct nfcArgs al = rt->api.nfcArgs(ctx);
	GxMesh mesh = rt->api.nextArg(&al)->ref;

	if (ctx->proto == proto_material_ambient) {
		float32_t r = rt->api.nextArg(&al)->f32;
		float32_t g = rt->api.nextArg(&al)->f32;
		float32_t b = rt->api.nextArg(&al)->f32;
		vecldf(&mesh->mtl.ambi, r, g, b, 1);
		return noError;
	}

	if (ctx->proto == proto_material_diffuse) {
		float32_t r = rt->api.nextArg(&al)->f32;
		float32_t g = rt->api.nextArg(&al)->f32;
		float32_t b = rt->api.nextArg(&al)->f32;
		vecldf(&mesh->mtl.diff, r, g, b, 1);
		return noError;
	}

	if (ctx->proto == proto_material_specular) {
		float32_t r = rt->api.nextArg(&al)->f32;
		float32_t g = rt->api.nextArg(&al)->f32;
		float32_t b = rt->api.nextArg(&al)->f32;
		vecldf(&mesh->mtl.spec, r, g, b, 0);
		return noError;
	}

	if (ctx->proto == proto_material_shine) {
		mesh->mtl.spow = rt->api.nextArg(&al)->f32;
		return noError;
	}

	if (ctx->proto == proto_material_texture) {
		mesh->mtl.texture = rt->api.nextArg(&al)->ref;
		return noError;
	}

	return illegalState;
}

static GxImage defaultFont(int height) {
	static const unsigned char font[] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x22, 0x41, 0x55, 0x41, 0x55, 0x5d, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x3e, 0x7f, 0x6b, 0x7f, 0x5d, 0x63, 0x3e, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x6c, 0xfe, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0xe7, 0xe7, 0xe7, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x7e, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x07, 0x03, 0x05, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x1c, 0x08, 0x08, 0x1c, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0c, 0x0e, 0x0a, 0x0a, 0x08, 0x08, 0x18, 0x38, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x18, 0x1c, 0x16, 0x33, 0x71, 0x61, 0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x2a, 0x1c, 0x22, 0x63, 0x22, 0x1c, 0x2a, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x60, 0x7c, 0x7f, 0x7c, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x03, 0x1f, 0x7f, 0x1f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x1c, 0x3e, 0x08, 0x08, 0x3e, 0x1c, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3f, 0x45, 0x45, 0x45, 0x3d, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x22, 0x20, 0x18, 0x14, 0x0c, 0x02, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x1c, 0x3e, 0x08, 0x08, 0x3e, 0x1c, 0x08, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x1c, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x1c, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x04, 0x06, 0x7f, 0x06, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x10, 0x30, 0x7f, 0x30, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x14, 0x36, 0x7f, 0x36, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0x7c, 0x7c, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x24, 0x24, 0xff, 0x24, 0x24, 0x24, 0xff, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x3e, 0x49, 0x48, 0x3e, 0x09, 0x49, 0x3e, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x20, 0x51, 0x52, 0x24, 0x08, 0x12, 0x25, 0x45, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x18, 0x24, 0x24, 0x18, 0x28, 0x45, 0x42, 0x42, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x04, 0x08, 0x10, 0x10, 0x10, 0x10, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x3e, 0x08, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3c, 0x42, 0x46, 0x4a, 0x52, 0x62, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3c, 0x42, 0x02, 0x04, 0x18, 0x20, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3c, 0x42, 0x02, 0x02, 0x1c, 0x02, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x02, 0x06, 0x0a, 0x12, 0x22, 0x42, 0x7f, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7e, 0x40, 0x40, 0x40, 0x7c, 0x02, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3c, 0x42, 0x40, 0x40, 0x7c, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7e, 0x02, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x3c, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x3e, 0x02, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x40, 0x20, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3e, 0x41, 0x01, 0x01, 0x06, 0x08, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1e, 0x21, 0x4d, 0x53, 0x53, 0x4d, 0x40, 0x21, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x14, 0x22, 0x41, 0x41, 0x7f, 0x41, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7e, 0x21, 0x21, 0x21, 0x3e, 0x21, 0x21, 0x21, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1e, 0x21, 0x40, 0x40, 0x40, 0x40, 0x40, 0x21, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7c, 0x22, 0x21, 0x21, 0x21, 0x21, 0x21, 0x22, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7f, 0x40, 0x40, 0x40, 0x7c, 0x40, 0x40, 0x40, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7f, 0x40, 0x40, 0x40, 0x7c, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1e, 0x21, 0x40, 0x40, 0x4f, 0x41, 0x41, 0x21, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x41, 0x41, 0x41, 0x7f, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 0x02, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x42, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x63, 0x55, 0x49, 0x49, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x41, 0x61, 0x51, 0x49, 0x45, 0x43, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x22, 0x41, 0x41, 0x41, 0x41, 0x41, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7e, 0x41, 0x41, 0x41, 0x7e, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x22, 0x41, 0x41, 0x41, 0x49, 0x45, 0x22, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7e, 0x41, 0x41, 0x41, 0x7e, 0x48, 0x44, 0x42, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3e, 0x41, 0x40, 0x40, 0x3e, 0x01, 0x01, 0x41, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7f, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x41, 0x41, 0x22, 0x22, 0x14, 0x14, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x41, 0x41, 0x41, 0x49, 0x49, 0x49, 0x55, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x41, 0x22, 0x14, 0x08, 0x14, 0x22, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x41, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7f, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1e, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x3c, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x10, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x02, 0x3e, 0x42, 0x42, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x40, 0x40, 0x40, 0x5c, 0x62, 0x42, 0x42, 0x62, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x40, 0x40, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x02, 0x02, 0x02, 0x3a, 0x46, 0x42, 0x42, 0x46, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x7e, 0x40, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0c, 0x12, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x46, 0x42, 0x46, 0x3a, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x40, 0x40, 0x40, 0x5c, 0x62, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x08, 0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x02, 0x00, 0x0e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x22, 0x1c, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x20, 0x20, 0x20, 0x22, 0x24, 0x28, 0x34, 0x22, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x49, 0x49, 0x49, 0x49, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x62, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x62, 0x42, 0x62, 0x5c, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x46, 0x42, 0x46, 0x3a, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x62, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x30, 0x0c, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x10, 0x10, 0x7c, 0x10, 0x10, 0x10, 0x12, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x46, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x41, 0x22, 0x22, 0x14, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x41, 0x49, 0x49, 0x55, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x46, 0x3a, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x04, 0x08, 0x10, 0x20, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x06, 0x08, 0x08, 0x08, 0x10, 0x08, 0x08, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0x08, 0x08, 0x08, 0x04, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x14, 0x22, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1e, 0x21, 0x40, 0x40, 0x40, 0x40, 0x41, 0x22, 0x1e, 0x02, 0x1c, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x24, 0x00, 0x42, 0x42, 0x42, 0x42, 0x46, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0c, 0x10, 0x00, 0x3c, 0x42, 0x7e, 0x40, 0x40, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x08, 0x14, 0x22, 0x00, 0x3c, 0x02, 0x3e, 0x42, 0x42, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x24, 0x00, 0x3c, 0x02, 0x3e, 0x42, 0x42, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x18, 0x04, 0x00, 0x3c, 0x02, 0x3e, 0x42, 0x42, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x08, 0x14, 0x08, 0x00, 0x3c, 0x02, 0x3e, 0x42, 0x42, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x40, 0x40, 0x42, 0x3c, 0x04, 0x38, 0x00, 0x00, 0x00,
		0x00, 0x18, 0x24, 0x42, 0x00, 0x3c, 0x42, 0x7e, 0x40, 0x40, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x24, 0x00, 0x3c, 0x42, 0x7e, 0x40, 0x40, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x18, 0x04, 0x00, 0x3c, 0x42, 0x7e, 0x40, 0x40, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x24, 0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x08, 0x14, 0x22, 0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0x08, 0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x22, 0x00, 0x08, 0x14, 0x22, 0x41, 0x7f, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0x14, 0x08, 0x00, 0x08, 0x14, 0x22, 0x41, 0x7f, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0c, 0x10, 0x00, 0x7e, 0x40, 0x40, 0x7c, 0x40, 0x40, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x09, 0x3f, 0x48, 0x48, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0f, 0x18, 0x28, 0x48, 0x4e, 0x78, 0x48, 0x48, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x18, 0x24, 0x42, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x24, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x18, 0x04, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x18, 0x24, 0x42, 0x00, 0x42, 0x42, 0x42, 0x42, 0x46, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x30, 0x08, 0x00, 0x42, 0x42, 0x42, 0x42, 0x46, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x24, 0x00, 0x42, 0x42, 0x42, 0x46, 0x3a, 0x02, 0x42, 0x3c, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x22, 0x00, 0x1c, 0x22, 0x41, 0x41, 0x41, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x22, 0x00, 0x41, 0x41, 0x41, 0x41, 0x41, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x08, 0x3c, 0x42, 0x40, 0x40, 0x42, 0x3c, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x22, 0x20, 0x10, 0x3c, 0x10, 0x10, 0x32, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x41, 0x22, 0x14, 0x08, 0x3e, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x78, 0x44, 0x44, 0x78, 0x44, 0x4e, 0x44, 0x44, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0c, 0x12, 0x10, 0x10, 0x3c, 0x10, 0x10, 0x10, 0x10, 0x10, 0x60, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0c, 0x10, 0x00, 0x3c, 0x02, 0x3e, 0x42, 0x42, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0c, 0x10, 0x00, 0x18, 0x08, 0x08, 0x08, 0x08, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0c, 0x10, 0x00, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x0c, 0x10, 0x00, 0x42, 0x42, 0x42, 0x42, 0x46, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x32, 0x4c, 0x00, 0x5c, 0x62, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x19, 0x26, 0x41, 0x61, 0x51, 0x49, 0x45, 0x43, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x38, 0x04, 0x1c, 0x24, 0x1a, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x00, 0x08, 0x08, 0x30, 0x40, 0x40, 0x41, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x20, 0x62, 0x24, 0x28, 0x10, 0x2e, 0x02, 0x04, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x20, 0x62, 0x24, 0x28, 0x10, 0x2a, 0x0a, 0x0f, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x09, 0x12, 0x24, 0x12, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x24, 0x12, 0x09, 0x12, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10, 0x82, 0x10,
		0xc3, 0x18, 0xc3, 0x18, 0xc3, 0x18, 0xc3, 0x18, 0xc3, 0x18, 0xc3, 0x18, 0xc3, 0x18, 0xc3, 0x18,
		0xd8, 0x83, 0xda, 0x13, 0xd8, 0x83, 0xda, 0x13, 0xd8, 0x83, 0xda, 0x13, 0xd8, 0x83, 0xda, 0x13,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x36, 0x36, 0x36, 0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
		0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
		0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x48, 0x48, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x22, 0x42, 0x5c, 0x44, 0x42, 0x42, 0x52, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7e, 0x42, 0x42, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x52, 0x12, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x7e, 0x21, 0x10, 0x08, 0x04, 0x08, 0x10, 0x21, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x7c, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x50, 0x10, 0x10, 0x14, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x08, 0x3e, 0x49, 0x49, 0x49, 0x3e, 0x08, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1c, 0x22, 0x41, 0x7f, 0x41, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x22, 0x41, 0x41, 0x41, 0x22, 0x14, 0x55, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x1c, 0x12, 0x08, 0x3c, 0x44, 0x44, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x49, 0x49, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1d, 0x22, 0x45, 0x49, 0x51, 0x22, 0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1f, 0x20, 0x40, 0x7f, 0x40, 0x20, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x1c, 0x22, 0x41, 0x41, 0x41, 0x41, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x7f, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x08, 0x08, 0x08, 0x7f, 0x08, 0x08, 0x08, 0x00, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x06, 0x09, 0x0b, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x68, 0x48, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x7f, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x32, 0x4c, 0x00, 0x32, 0x4c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x18, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x0f, 0x08, 0x08, 0x08, 0x08, 0x48, 0x28, 0x18, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x2c, 0x12, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x18, 0x24, 0x08, 0x10, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};

	if ((size_t) height > sizeof(fnt) / sizeof(*fnt)) {
		// invalid height
		return NULL;
	}

	if (fnt[height].basePtr != NULL) {
		// font already cached
		return &fnt[height];
	}

	int nHeight = sizeof(font) >> 8;
	if (height == 0) {
		height = nHeight;
	}

	uint16_t width = 8 * height / nHeight;
	GxImage dst = createImage(&fnt[height], 256 * width, height, 8, ImageFnt);
	if (dst == NULL) {
		gx_debug("Failed to init image");
		return NULL;
	}

	struct GxImage temp = {0};
	GxImage chr = createImage(&temp, 8, nHeight, 8, Image2d);
	if (chr == NULL) {
		gx_debug("Failed to init image");
		return NULL;
	}

	unsigned char *chrPtr = (void *) dst->basePtr;
	GxFLut lut = dst->LLUTPtr;
	lut->count = 256;
	for (int i = 0, x0 = 0; i < 256; ++i, x0 += width) {
		lut->data[i].pad_x = 0;
		lut->data[i].pad_y = 0;
		lut->data[i].width = width;
		lut->data[i].basePtr = chrPtr;
		if (height != nHeight) {
			unsigned char *ptr = (unsigned char *) chr->basePtr;
			for (int y = 0; y < nHeight; ++y) {
				ptr[0] = (font[i * nHeight + y] & 0X80) ? 255 : 0;
				ptr[1] = (font[i * nHeight + y] & 0X40) ? 255 : 0;
				ptr[2] = (font[i * nHeight + y] & 0X20) ? 255 : 0;
				ptr[3] = (font[i * nHeight + y] & 0X10) ? 255 : 0;
				ptr[4] = (font[i * nHeight + y] & 0X08) ? 255 : 0;
				ptr[5] = (font[i * nHeight + y] & 0X04) ? 255 : 0;
				ptr[6] = (font[i * nHeight + y] & 0X02) ? 255 : 0;
				ptr[7] = (font[i * nHeight + y] & 0X01) ? 255 : 0;
				ptr += chr->scanLen;
			}
			struct GxRect roi = {
				.x0 = x0,
				.y0 = 0,
				.x1 = x0 + width,
				.y1 = height
			};
			transformImage(dst, &roi, &temp, NULL, 1, NULL);
		} else {
			unsigned char *ptr = chrPtr;
			for (int y = 0; y < nHeight; ++y) {
				ptr[0] = (font[i * nHeight + y] & 0X80) ? 255 : 0;
				ptr[1] = (font[i * nHeight + y] & 0X40) ? 255 : 0;
				ptr[2] = (font[i * nHeight + y] & 0X20) ? 255 : 0;
				ptr[3] = (font[i * nHeight + y] & 0X10) ? 255 : 0;
				ptr[4] = (font[i * nHeight + y] & 0X08) ? 255 : 0;
				ptr[5] = (font[i * nHeight + y] & 0X04) ? 255 : 0;
				ptr[6] = (font[i * nHeight + y] & 0X02) ? 255 : 0;
				ptr[7] = (font[i * nHeight + y] & 0X01) ? 255 : 0;
				ptr += dst->scanLen;
			}
		}
		chrPtr += width;
	}
	destroyImage(chr);
	return dst;
}

static symn typSigned(rtContext ctx, int size) {
	switch (size) {
		default:
			break;

		case 1:
			return ctx->api.ccLookup(ctx->cc, NULL, "int8");

		case 2:
			return ctx->api.ccLookup(ctx->cc, NULL, "int16");

		case 4:
			return ctx->api.ccLookup(ctx->cc, NULL, "int32");

		case 8:
			return ctx->api.ccLookup(ctx->cc, NULL, "int64");
	}
	return NULL;
}

static void builtinBlend(const struct rtContextRec *rt, const char * proto, symn funType) {
	symn type = rt->api.ccAddType(rt->cc, proto, 0, 1);
	// fake it to be function like
	type->params = funType->params;
	type->type = funType->type;
	type->fmt = proto;
}

const char cmplUnit[] = "cmplGfx/lib.cmpl";
int cmplInit(rtContext ctx, ccContext cc) {
	const struct {
		vmError (*func)(nfcContext);
		const char *proto;
	}
	nfcSurf[] = {
		{surf_recycle,  proto_image_create2d},
		{surf_recycle,  proto_image_create3d},
		{surf_recycle,  proto_image_recycle},
		{surf_recycle,  proto_image_slice},
		{surf_recycle,  proto_image_destroy},
		{surf_open,     proto_image_openBmp},
#ifndef NO_LIBPNG
		{surf_open,     proto_image_openPng},
#endif
#ifndef NO_LIBJPEG
		{surf_open,     proto_image_openJpg},
#endif
		{surf_open,     proto_image_openImg},
		{surf_open,     proto_image_openTtf},
		{surf_open,     proto_image_openFnt},
		{surf_save,     proto_image_saveBmp},

		{surf_width,    proto_image_width},
		{surf_height,   proto_image_height},
		{surf_depth,    proto_image_depth},
		{surf_get,      proto_image_get},
		{surf_set,      proto_image_set},
		{surf_tex,      proto_image_tex},
		{surf_clipText, proto_image_clipText},
		{surf_drawText, proto_image_drawText},

		{surf_fillRect, proto_image_fillRect},
		{surf_blend, proto_image_blend},
		{surf_transform, proto_image_transform},
		{surf_blur, proto_image_blur},

		{surf_colorMat, proto_image_colorMat},
		{surf_calcHist, proto_image_calcHueHist},
		{surf_calcHist, proto_image_calcLumHist},
		{surf_calcHist, proto_image_calcRgbHist},
		{surf_drawMesh, proto_image_drawMesh},
	},
	nfcWindow[] = {
		{window_show,  proto_window_show},
		{window_title, proto_window_title},
		{window_quit,  proto_window_quit},
		{surf_font,    proto_font_resized},
		{surf_font,    proto_font_default},
	},
	nfcMesh[] = {
		{mesh_recycle, proto_mesh_create},
		{mesh_recycle, proto_mesh_recycle},
		{mesh_destroy, proto_mesh_destroy},
		{mesh_open, proto_mesh_openObj},
		{mesh_open, proto_mesh_open3ds},
		{mesh_save, proto_mesh_saveObj},
		{mesh_normalize, proto_mesh_normalize},
		{mesh_addVertex, proto_mesh_addVertex},
		{mesh_addFace, proto_mesh_addLine},
		{mesh_addFace, proto_mesh_addFace},
		{mesh_addFace, proto_mesh_addQuad},
		{mesh_setVertex, proto_mesh_setVertexPos},
		{mesh_setVertex, proto_mesh_setVertexNrm},
		{mesh_setVertex, proto_mesh_setVertexTex},
		{mesh_material, proto_material_ambient},
		{mesh_material, proto_material_diffuse},
		{mesh_material, proto_material_specular},
		{mesh_material, proto_material_shine},
		{mesh_material, proto_material_texture},
	},
	nfcLights[] = {
		{lights_manager, proto_lights_enabled},
		{lights_manager, proto_lights_enable},
		{lights_manager, proto_lights_position},
		{lights_manager, proto_lights_ambient},
		{lights_manager, proto_lights_diffuse},
		{lights_manager, proto_lights_specular},
		{lights_manager, proto_lights_attenuation},
	};

	// rectangle in 2d
	ctx->api.ccAddUnit(cc, NULL, 0,
		"/// The Rect type represents a rectangle in the plain.\n"
		"struct Rect:1 {\n"
		"	/// Represents the left edge of the rectangle\n"
		"	int32 x0 = 0;\n"
		"	/// Represents the top edge of the rectangle\n"
		"	int32 y0 = 0;\n"
		"	/// Represents the right edge of the rectangle\n"
		"	int32 x1 = 0;\n"
		"	/// Represents the bottom edge of the rectangle\n"
		"	int32 y1 = 0;\n"
		"}\n"
	);

	// surfaces are allocated outside the vm, and are handler types
	symn symImage = ctx->api.ccAddType(cc, "Image", sizeof(GxImage), 0);
	symImage->fmt = "%a";

	// meshes are allocated inside the vm, and are reference types
	symn symMesh = ctx->api.ccAddType(cc, "Mesh", sizeof(struct GxMesh), 1);

	if (ctx->api.ccExtend(cc, symMesh)) {
		for (size_t i = 0; i < sizeof(nfcMesh) / sizeof(*nfcMesh); i += 1) {
			if (!ctx->api.ccAddCall(cc, nfcMesh[i].func, nfcMesh[i].proto)) {
				return 1;
			}
		}

		if (!ctx->api.ccAddCall(cc, camera_set, proto_camera_set)) {
			return 1;
		}

		symn symLights = ctx->api.ccBegin(cc, "lights");
		if (symLights != NULL) {
			for (size_t i = 0; i < sizeof(nfcLights) / sizeof(*nfcLights); i += 1) {
				if (!ctx->api.ccAddCall(cc, nfcLights[i].func, nfcLights[i].proto)) {
					return 1;
				}
			}
			ctx->api.ccEnd(cc, symLights);
		}

		// clear color and depth buffers
		ctx->api.ccDefInt(cc, "keepBuffer", keep_buff);

		// backface culling
		ctx->api.ccDefInt(cc, "cullBack", cull_back);
		ctx->api.ccDefInt(cc, "cullFront", cull_front);
		ctx->api.ccDefInt(cc, "cullMode", cull_mode);

		ctx->api.ccDefInt(cc, "drawPlot", draw_plot);
		ctx->api.ccDefInt(cc, "drawWire", draw_wire);
		ctx->api.ccDefInt(cc, "drawFill", draw_fill);
		ctx->api.ccDefInt(cc, "drawMode", draw_mode);

		ctx->api.ccDefInt(cc, "useTexture", draw_tex);
		ctx->api.ccDefInt(cc, "useLights", draw_lit);
		ctx->api.ccDefInt(cc, "drawBounds", draw_box);

		symn vtxCount = ctx->api.ccDefVar(cc, "vertices", typSigned(ctx, sizeOf(struct GxMesh, vtxcnt)));
		symn triCount = ctx->api.ccDefVar(cc, "triangles", typSigned(ctx, sizeOf(struct GxMesh, tricnt)));
		symn segCount = ctx->api.ccDefVar(cc, "segments", typSigned(ctx, sizeOf(struct GxMesh, segcnt)));

		ccKind symKind = symMesh->kind;
		symMesh->kind &= ~ATTR_stat;
		ctx->api.ccEnd(cc, symMesh);
		symMesh->kind = symKind;

		vtxCount->offs = offsetOf(struct GxMesh, vtxcnt);
		triCount->offs = offsetOf(struct GxMesh, tricnt);
		segCount->offs = offsetOf(struct GxMesh, segcnt);
	}

	if (ctx->api.ccExtend(cc, symImage)) {
		symn blend = NULL;
		for (size_t i = 0; i < sizeof(nfcSurf) / sizeof(*nfcSurf); i += 1) {
			symn nfc = ctx->api.ccAddCall(cc, nfcSurf[i].func, nfcSurf[i].proto);
			if (nfc == NULL) {
				return 1;
			}
			if (nfcSurf[i].proto == proto_image_blend) {
				// needed to add some builtin blend methods
				blend = nfc;
			}
		}
		if (blend != NULL && blend->params != NULL) {
			if (ctx->api.ccExtend(cc, blend)) {
				symn method = NULL;
				for (symn p = blend->params; p; p = p->next) {
					// blend callback is the last parameter
					method = p;
				}

				builtinBlend(ctx, proto_image_blend_color, method);// Image.blend.color
				builtinBlend(ctx, proto_image_blend_alpha, method);
				builtinBlend(ctx, proto_image_blend_dstAlpha, method);
				builtinBlend(ctx, proto_image_blend_vec4f, method);
				builtinBlend(ctx, proto_image_lookup_3d, method);
				builtinBlend(ctx, proto_image_lookup_rgb, method);
				builtinBlend(ctx, proto_image_lookup_rgbl, method);
				ctx->api.ccEnd(cc, blend);
			}
		}
		ctx->api.ccEnd(cc, symImage);
	}

	symn gradient = ctx->api.ccAddCall(cc, surf_gradient, proto_image_gradient);
	if (gradient != NULL && ctx->api.ccExtend(cc, gradient)) {
		ctx->api.ccDefInt(cc, "Linear", gradient_lin);
		ctx->api.ccDefInt(cc, "Radial", gradient_rad);
		ctx->api.ccDefInt(cc, "Square", gradient_sqr);
		ctx->api.ccDefInt(cc, "Spiral", gradient_spr);
		ctx->api.ccDefInt(cc, "Conical", gradient_con);
		ctx->api.ccDefInt(cc, "MaskLinear", flag_alpha | gradient_lin);
		ctx->api.ccDefInt(cc, "MaskRadial", flag_alpha | gradient_rad);
		ctx->api.ccDefInt(cc, "MaskSquare", flag_alpha | gradient_sqr);
		ctx->api.ccEnd(cc, gradient);
	}

	symn win = ctx->api.ccBegin(cc, "Window");
	if (win != NULL) {
		ctx->api.ccDefInt(cc, "KEY_PRESS", KEY_PRESS);
		ctx->api.ccDefInt(cc, "KEY_RELEASE", KEY_RELEASE);
		ctx->api.ccDefInt(cc, "MOUSE_PRESS", MOUSE_PRESS);
		ctx->api.ccDefInt(cc, "MOUSE_MOTION", MOUSE_MOTION);
		ctx->api.ccDefInt(cc, "MOUSE_RELEASE", MOUSE_RELEASE);
		ctx->api.ccDefInt(cc, "FINGER_PRESS", FINGER_PRESS);
		ctx->api.ccDefInt(cc, "FINGER_MOTION", FINGER_MOTION);
		ctx->api.ccDefInt(cc, "FINGER_RELEASE", FINGER_RELEASE);
		ctx->api.ccDefInt(cc, "EVENT_TIMEOUT", EVENT_TIMEOUT);
		ctx->api.ccDefInt(cc, "GESTURE_SCROLL", GESTURE_SCROLL);
		ctx->api.ccDefInt(cc, "WINDOW_INIT", WINDOW_INIT);
		ctx->api.ccDefInt(cc, "WINDOW_CLOSE", WINDOW_CLOSE);
		ctx->api.ccDefInt(cc, "WINDOW_ENTER", WINDOW_ENTER);
		ctx->api.ccDefInt(cc, "WINDOW_LEAVE", WINDOW_LEAVE);

		ctx->api.ccDefInt(cc, "KEY_CODE_ESC", KEY_CODE_ESC);
		ctx->api.ccDefInt(cc, "KEY_CODE_BACK", KEY_CODE_BACKSPACE);
		ctx->api.ccDefInt(cc, "KEY_CODE_TAB", KEY_CODE_TAB);
		ctx->api.ccDefInt(cc, "KEY_CODE_ENTER", KEY_CODE_RETURN);
		ctx->api.ccDefInt(cc, "KEY_CODE_CAPSLOCK", KEY_CODE_CAPSLOCK);

		ctx->api.ccDefInt(cc, "KEY_CODE_PRINT_SCREEN", KEY_CODE_PRINT_SCREEN);
		ctx->api.ccDefInt(cc, "KEY_CODE_SCROLL_LOCK", KEY_CODE_SCROLL_LOCK);
		ctx->api.ccDefInt(cc, "KEY_CODE_PAUSE", KEY_CODE_PAUSE);

		ctx->api.ccDefInt(cc, "KEY_CODE_INSERT", KEY_CODE_INSERT);
		ctx->api.ccDefInt(cc, "KEY_CODE_HOME", KEY_CODE_HOME);
		ctx->api.ccDefInt(cc, "KEY_CODE_PAGE_UP", KEY_CODE_PAGE_UP);
		ctx->api.ccDefInt(cc, "KEY_CODE_DELETE", KEY_CODE_DELETE);
		ctx->api.ccDefInt(cc, "KEY_CODE_END", KEY_CODE_END);
		ctx->api.ccDefInt(cc, "KEY_CODE_PAGE_DOWN", KEY_CODE_PAGE_DOWN);
		ctx->api.ccDefInt(cc, "KEY_CODE_RIGHT", KEY_CODE_RIGHT);
		ctx->api.ccDefInt(cc, "KEY_CODE_LEFT", KEY_CODE_LEFT);
		ctx->api.ccDefInt(cc, "KEY_CODE_DOWN", KEY_CODE_DOWN);
		ctx->api.ccDefInt(cc, "KEY_CODE_UP", KEY_CODE_UP);

		ctx->api.ccDefInt(cc, "KEY_CODE_L_SHIFT", KEY_CODE_L_SHIFT);
		ctx->api.ccDefInt(cc, "KEY_CODE_R_SHIFT", KEY_CODE_R_SHIFT);
		ctx->api.ccDefInt(cc, "KEY_CODE_L_CTRL", KEY_CODE_L_CTRL);
		ctx->api.ccDefInt(cc, "KEY_CODE_R_CTRL", KEY_CODE_R_CTRL);
		ctx->api.ccDefInt(cc, "KEY_CODE_L_ALT", KEY_CODE_L_ALT);
		ctx->api.ccDefInt(cc, "KEY_CODE_R_ALT", KEY_CODE_R_ALT);
		ctx->api.ccDefInt(cc, "KEY_CODE_L_GUI", KEY_CODE_L_GUI);
		ctx->api.ccDefInt(cc, "KEY_CODE_R_GUI", KEY_CODE_R_GUI);

		ctx->api.ccDefInt(cc, "KEY_MASK_SHIFT", KEY_MASK_SHIFT);
		ctx->api.ccDefInt(cc, "KEY_MASK_CTRL", KEY_MASK_CTRL);
		ctx->api.ccDefInt(cc, "KEY_MASK_ALT", KEY_MASK_ALT);

		for (size_t i = 0; i < sizeof(nfcWindow) / sizeof(*nfcWindow); i += 1) {
			if (!ctx->api.ccAddCall(cc, nfcWindow[i].func, nfcWindow[i].proto)) {
				return 1;
			}
		}

		ctx->api.ccEnd(cc, win);
	}

	if (/*Initialize:*/ 1) {
		struct vector eye, tgt, up;
		vecldf(&eye, 0, 0, 2.0f, 1);
		vecldf(&tgt, 0, 0, 0, 1);
		vecldf(&up, 0, 1, 0, 1);

		projv_mat(&cam->proj, 30, 1, 1, 100);
		camset(cam, &eye, &tgt, &up);

		for (size_t i = 1; i < sizeof(lights) / sizeof(*lights); ++i) {
			lights[i - 1].next = lights + i;
		}
		initWindowing();
	}

	return 0;
}
void cmplClose(rtContext ctx) {
	for (size_t i = 0; i < sizeof(fnt) / sizeof(*fnt); ++i) {
		destroyImage(fnt + i);
	}
	quitWindowing();
	(void) ctx;
}
