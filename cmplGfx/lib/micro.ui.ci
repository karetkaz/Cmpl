// micro ui, TODO: add comments

struct Style {
	const int align;
	const int border = 3;
	const int padding = 8;

	const Image font = Gui.font;
	const FormatFlags fmtInt;
	const FormatFlags fmtFlt;

	int backgroundColor = 0x1a1a1a;
	int focusedColor = 0x3b4754;
	int valueColor = 0x6897bb;
	int textColor = 0xdadada;

	enum: int32 {
		center: 0;

		left: 1;
		right: 2;
		vertical: left + right;

		top: 4;
		bottom: 8;
		horizontal: top + bottom;

		fill: vertical + horizontal;
	}

	enum: int32 {
		//hovered: 1;
		pressed: 2;
		focused: 4;
	}

	static void measure(const Style this&, Rect valueRect&, const char text[*], int extraChars) {
		Rect measured = {w: 0, h: 0};
		this.font.clipText(&measured, text);
		if (valueRect.w < 0 || (this.align & Style.vertical) == Style.vertical) {
			if (text != null && measured.w != 0) {
				measured.w += extraChars * measured.w / length(text);
			}
			valueRect.w = measured.w + 2 * this.padding;
		}
		if (valueRect.h < 0 || (this.align & Style.horizontal) == Style.horizontal) {
			valueRect.h = measured.h + 2 * this.padding;
		}
	}

	/// Align one rect containing text relative to its container
	static void align(Rect rect, Rect valueRect&, int align) {
		inline abs(int x) = x < 0 ? -x : x;
		if (abs(valueRect.w) > rect.w) {
			valueRect.w = rect.w;
		}
		if (abs(valueRect.h) > rect.h) {
			valueRect.h = rect.h;
		}

		int vertical = align & Style.vertical;
		if (vertical == center) {
			valueRect.x = rect.x + (rect.w - abs(valueRect.w)) / 2;
		}
		else if (vertical == right) {
			valueRect.x = rect.x + (rect.w - abs(valueRect.w));
		}
		else if (vertical == left) {
			valueRect.x = rect.x;
		}
		else { // fit
			valueRect.x = rect.x;
			valueRect.w = rect.w;
		}

		int horizontal = align & Style.horizontal;
		if (horizontal == center) {
			valueRect.y = rect.y + (rect.h - abs(valueRect.h)) / 2;
		}
		else if (horizontal == bottom) {
			valueRect.y = rect.y + (rect.h - abs(valueRect.h));
		}
		else if (horizontal == top) {
			valueRect.y = rect.y;
		}
		else { // fit
			valueRect.y = rect.y;
			valueRect.h = rect.h;
		}
	}

	static void align(const Style this&, Rect rect, Rect valueRect&, const char value[*], int padding, int align) {
		rect.x += padding;
		rect.y += padding;
		rect.w -= 2 * padding;
		rect.h -= 2 * padding;
		this.font.clipText(&valueRect, value);
		align(rect, &valueRect, align);
	}

	static void align(const Style this&, Rect rect, Rect valueRect&, const char value[*], int align) {
		return align(this, rect, &valueRect, value, this.padding, align);
	}

	static void align(const Style this&, Rect rect, Rect valueRect&, const char value[*]) {
		return align(this, rect, &valueRect, value, this.padding, this.align);
	}
}
struct KeyEvent {
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int repeat;
	const int key;
}
struct MouseEvent {
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int clicks;
	const int button;
	const int dx = 0;
	const int dy = 0;
	const int x;
	const int y;

	static bool test(const MouseEvent event&, const Rect rect&) {
		if (event.x < rect.x || event.x >= rect.x + rect.w) {
			return false;
		}
		if (event.y < rect.y || event.y >= rect.y + rect.h) {
			return false;
		}
		return true;
	}
}

struct View: object {
	const int width = -1;
	const int height = -1;
	const int visible = -1;

	bool enabled = true;
	bool selectable = true;

	variant data = null;

	bool onClick(View this) {
		return true;
	}

	bool onReset(View this) {
		return false;
	}

	void onCreate(View this) {
	}

	void onDestroy(View this) {
	}

	bool onKeyEvent(View this, const KeyEvent event&) {
		if (!this.enabled) {
			return false;
		}
		if (event.release) {
			return false;
		}
		if (event.key == 8 && !event.isShift) {
			return this.onReset(this);
		}
		if (event.key == ' ') {
			return this.onClick(this);
		}
		return false;
	}

	bool onMouseEvent(View this, const Rect rect&, const MouseEvent event&) {
		if (!this.enabled) {
			return false;
		}
		if (!event.release) {
			// allow to be focused
			return true;
		}
		if (event.clicks > 1) {
			// double click to reset
			if (this.onReset(this)) {
				return true;
			}
		}
		return this.onClick(this);
	}

	void onMeasure(View this, Rect rect&, const Style style&) {
		if (this.width >= 0) {
			rect.w = this.width;
		}
		if (this.height >= 0) {
			rect.h = this.height;
		}
	}

	void onDraw(View this, Image offs, Rect rect, const Style style&);

	static void onDraw(View this, Image offs, Rect rect, const Style style&, const char text[*], const char value[*]) {
		if (text == null) {
			style.align(rect, &rect, value, Style.center);
			offs.drawText(rect, style.font, value, style.valueColor);
			return;
		}

		Rect valueRoi = rect;
		style.align(valueRoi, &valueRoi, value, Style.right);
		rect.w -= valueRoi.w + style.padding;
		style.align(style, rect, &rect, text);
		offs.drawText(valueRoi, style.font, value, style.valueColor);
		offs.drawText(rect, style.font, text, style.textColor);
	}
}

struct Button: View {
	const char text[*];

	void onMeasure(Button this, Rect rect&, const Style style&) {
		style.measure(&rect, this.text, 0);
		View.onMeasure(this, &rect, style);
	}

	void onDraw(Button this, Image offs, Rect rect, const Style style&) {
		style.align(rect, &rect, this.text);
		offs.drawText(rect, style.font, this.text, style.textColor);
	}
}

struct Switch: View {
	static const char onOff[*][] = {
		"off",
		"on"
	};

	const char text[*];
	const char states[*][] = onOff;

	int selected = 0;
	const int resetValue = 0;//TODO: selected;

	static bool checked(Switch this) {
		return this.selected != 0;
	}

	bool onUpdate(Switch this, int selected) {
		if (selected >= this.states.length) {
			selected = this.states.length - 1;
		}
		else if (selected < 0) {
			selected = 0;
		}

		if (this.selected == selected) {
			return false;
		}

		this.selected = selected;
		return true;
	}

	bool onClick(Switch this) {
		int value = this.selected + 1;
		if (value >= this.states.length) {
			value = 0;
		}
		return this.onUpdate(this, value);
	}

	void onCreate(Switch this) {
		Switch.onUpdate(this, this.selected);// clamp initial value
		int resetValue& = pointer(this.resetValue);
		resetValue = this.selected;
	}

	bool onKeyEvent(Switch this, const KeyEvent event&) {
		if (event.release) {
			return View.onKeyEvent(this, event);
		}
		if (event.key == '+' || event.key == '=') {
			int value = this.selected + 1;
			if (value >= this.states.length) {
				value = 0;
			}
			return this.onUpdate(this, value);
		}
		if (event.key == '-' || event.key == '_') {
			int value = this.selected - 1;
			if (value < 0) {
				value = this.states.length - 1;
			}
			return this.onUpdate(this, value);
		}
		return View.onKeyEvent(this, event);
	}

	void onMeasure(Switch this, Rect rect&, const Style style&) {
		int len = length(this.states[0]);
		for (int i = 0; i < this.states.length; i += 1) {
			int max = length(this.states[0]);
			if (len < max) {
				len = max;
			}
		}
		style.measure(&rect, this.text, len);
		View.onMeasure(this, &rect, style);
	}

	void onDraw(Switch this, Image offs, Rect rect, const Style style&) {
		View.onDraw(this, offs, rect, style, this.text, this.states[this.selected]);
	}
}

struct Slider: View {
	const char text[*];

	int value = 0;
	const int minimum = 0;
	const int maximum = -1u >> 1;
	const int divisor = 0;
	const int resetValue = 0; // TODO: resetValue = value;

	static float64 valFlt(Slider this) {
		float64 value = this.value;
		if (this.divisor != 0) {
			return value / this.divisor;
		}
		return value / (this.maximum - this.minimum);
	}

	bool onUpdate(Slider this, int value) {
		if (value > this.maximum) {
			value = this.maximum;
		}
		if (value < this.minimum) {
			value = this.minimum;
		}
		if (this.value == value) {
			return false;
		}
		this.value = value;
		return true;
	}

	bool onReset(Slider this) {
		return Slider.onUpdate(this, this.resetValue);
	}

	void onCreate(Slider this) {
		Slider.onUpdate(this, this.value);// clamp initial value
		int resetValue& = pointer(this.resetValue);
		resetValue = this.value;
	}

	bool onKeyEvent(Slider this, const KeyEvent event&) {
		if (event.release) {
			return View.onKeyEvent(this, event);
		}
		if (event.key == ' ') {
			return this.onReset(this);
		}
		if (event.key == '+' || event.key == '=') {
			return this.onUpdate(this, this.value + (event.isShift ? 1 : 10));
		}
		if (event.key == '-' || event.key == '_') {
			return this.onUpdate(this, this.value - (event.isShift ? 1 : 10));
		}
		return View.onKeyEvent(this, event);
	}

	bool onMouseEvent(Slider this, const Rect rect&, const MouseEvent event&) {
		if (event.release && event.clicks > 1) {
			Slider.onUpdate(this, this.resetValue);
			return true;
		}

		if (event.clicks < 1) {
			float value = event.dx;
			if (!event.isShift && value != 0) {
				value *= float(this.maximum - this.minimum) / rect.w;
				if (value > -1 && value < 1) {
					value = value < 0 ? -1 : 1;
				}
			}
			this.onUpdate(this, this.value + value);
			return true;
		}
		if (event.release) {
			if (event.y < rect.y + rect.h - rect.h / 3) {
				// clicking the upper part to focus control
				return true;
			}
			float value = event.x - rect.x;
			value *= float(this.maximum - this.minimum) / rect.w;

			this.onUpdate(this, this.minimum + value);
			return true;
		}
		return View.onMouseEvent(this, rect, event);
	}

	void onMeasure(Slider this, Rect rect&, const Style style&) {
		char value[64] = {0};
		if (this.divisor != 0) {
			value.append(0, this.valFlt(), style.fmtFlt);
		} else {
			value.append(0, this.value, style.fmtInt);
		}
		style.measure(&rect, this.text, length(value));
		View.onMeasure(this, &rect, style);
	}

	void onDrawSlider(Slider this, Image offs, Rect rect, const Style style&) {
		if (this.maximum == this.minimum) {
			return;
		}
		const int y0 = rect.y + rect.h - 1;
		const int y1 = y0 - style.padding / 4;
		const int x0 = rect.x;
		const int x1 = rect.x + rect.w;
		const int x = x0 + (this.value - this.minimum) * rect.w / (this.maximum - this.minimum);
		offs.fillRect(x, y0, x1, y1, style.focusedColor);
		offs.fillRect(x0, y0, x, y1, style.valueColor);
	}

	void onDraw(Slider this, Image offs, Rect rect, const Style style&) {
		char value[64] = {0};
		if (this.divisor != 0) {
			value.append(0, this.valFlt(), style.fmtFlt);
		} else {
			value.append(0, this.value, style.fmtInt);
		}
		if (this.onDrawSlider != null) {
			this.onDrawSlider(this, offs, rect, style);
		}
		View.onDraw(this, offs, rect, style, this.text, value);
	}
}

struct Layout: View {
	const int gravity;
	const int itemCount;
	View items[*] = null;
	Rect rects[*] = null;

//	int hoveredIndex = -1;
	int pressedIndex = -1;
	int focusedIndex = -1;

	static bool setSelected(Layout this, int index, bool select) {
		static void clearSelected(Layout this) {
			if (this.focusedIndex < 0) {
				return;
			}
			View view = this.items[this.focusedIndex];
			if (Layout layout = view.as(Layout)) {
				clearSelected(layout);
			}
			this.focusedIndex = -1;
		}
		static void clearActive(Layout this) {
			if (this.pressedIndex < 0) {
				return;
			}
			View view = this.items[this.pressedIndex];
			if (Layout layout = view.as(Layout)) {
				clearActive(layout);
			}
			this.pressedIndex = -1;
		}

		if (index < 0) {
			if (select) {
				clearSelected(this);
			}
			clearActive(this);
			return true;
		}

		assert(index < this.itemCount, "invalid index");
		View view = this.items[index];
		Rect viewRect = this.rects[index];

		if (!view.enabled) {
			// cannot focus or select a disabled view
			this.clearActive();
			return false;
		}

		if (viewRect.w == 0 || viewRect.h == 0) {
			// cannot focus or select an invisible view
			this.clearActive();
			return false;
		}

		if (select && !view.selectable) {
			// can not select a non selectable view
			this.clearActive();
			return false;
		}

		if (select) {
			if (this.focusedIndex != index) {
				this.clearSelected();
				this.focusedIndex = index;
			}
		} else {
			if (this.pressedIndex != index) {
				this.clearActive();
				this.pressedIndex = index;
			}
		}
		return true;
	}
	static bool setSelected(Layout this, bool prev) {
		int focusedIndex = this.focusedIndex;
		if (this.focusedIndex >= 0) {
			// select the next child of the currently selected view
			View selected = this.items[focusedIndex];
			if (Layout layout = selected.as(Layout)) {
				if (layout.setSelected(layout, prev)) {
					return true;
				}
			}
		}

		this.focusedIndex = -1;
		if (prev) {
			if (focusedIndex < 0) {
				focusedIndex = this.itemCount;
			}
			for (int i = focusedIndex - 1; i >= 0; i -= 1) {
				if (setSelected(this, i, true)) {
					break;
				}
			}
		} else {
			for (int i = focusedIndex + 1; i < this.itemCount; i += 1) {
				if (setSelected(this, i, true)) {
					break;
				}
			}
		}

		if (this.focusedIndex < 0) {
			return false;
		}

		View selected = this.items[this.focusedIndex];
		if (Layout layout = selected.as(Layout)) {
			// select the first child of the newly selected layout
			layout.setSelected(layout, prev);
		}

		return true;
	}
	static View getSelected(const Layout this) {
		if (this.focusedIndex < 0) {
			return null;
		}
		View selected = this.items[this.focusedIndex];
		if (Layout layout = selected.as(Layout)) {
			View view = layout.getSelected();
			if (view != null) {
				return view;
			}
		}
		return selected;
	}

	static bool isSelected(const Layout this, View items...) {
		if (this.focusedIndex < 0) {
			// nothing is focused.
			return false;
		}

		View view = this.items[this.focusedIndex];
		for (int i = 0; i < items.length; i += 1) {
			if (items[i] == view) {
				return true;
			}
		}

		if (Layout layout = view.as(Layout)) {
			return isSelected(layout, ...items);
		}
		return false;
	}
	static bool isPressed(const Layout this, View items...) {
		if (this.pressedIndex < 0) {
			// nothing is pressed.
			return false;
		}

		View view = this.items[this.pressedIndex];
		for (int i = 0; i < items.length; i += 1) {
			if (items[i] == view) {
				return true;
			}
		}

		if (Layout layout = view.as(Layout)) {
			return isPressed(layout, ...items);
		}
		return false;
	}

	static void onDraw(View this, Image offs, Rect rect, const Style style&, int state) {
		// TODO: dispatch state to all child views
		if (Layout layout = this.as(Layout)) {
			state = 0;
		}
		if (state & Style.focused) {
			offs.fillRect(rect, style.focusedColor);
		}
		this.onDraw(this, offs, rect, style);
		if (state & Style.pressed) {
			offs.drawRect(rect, style.valueColor);
		}
	}

	bool onClick(Layout this) {
		error("onClick", this);
		return false;
		/* TODO: perform click on focused view
		View view = this.getSelected();
		if (view == null) {
			return false;
		}
		return view.onClick(view);
		*/
	}

	bool onReset(Layout this) {
		bool result = false;
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i];
			if (view.onReset(view)) {
				result = true;
			}
		}
		return result;
	}

	void onCreate(Layout this) {
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i];
			view.onCreate(view);
		}
	}

	void onDestroy(Layout this) {
		// destroy views and free up allocations
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i];
			view.onDestroy(view);
			view.destroy();
		}
		pointer.alloc(this.items, 0);
		pointer.alloc(this.rects, 0);
	}

	bool onKeyEvent(Layout this, const KeyEvent event&) {
		int idx = this.pressedIndex;
		if (idx < 0) {
			idx = this.focusedIndex;
		}
		if (idx < 0) {
			return false;
		}

		View view = this.items[idx];
		return view.onKeyEvent(view, event);
	}

	bool onMouseEvent(Layout this, const Rect rect&, const MouseEvent event&) {
		if (event.dx || event.dy || event.release) {
			int active = this.pressedIndex;
			if (active < 0) {
				// fallback to selected control
				active = this.focusedIndex;
			}
			if (active < 0) {
				// no active control
				return false;
			}

			Rect viewRect& = this.rects[active];
			if (event.release && !event.test(viewRect)) {
				// released outside active control
				return false;
			}

			View view = this.items[active];
			return view.onMouseEvent(view, viewRect, event);
		}

		for (int i = 0; i < this.itemCount; i += 1) {
			if (!event.test(this.rects[i])) {
				continue;
			}

			if (event.release && this.pressedIndex != i) {
				// released over a non pressed view
				return false;
			}

			View view = this.items[i];
			if (!view.onMouseEvent(view, this.rects[i], event)) {
				return false;
			}

			if (event.release) {
				// on release check if active is on event position
				return this.pressedIndex == i;
			}

			// press: update pressed
			if (this.pressedIndex != i) {
				this.setSelected(i, false);
			}
			return true;
		}

		return false;
	}

	void onMeasure(Layout this, Rect rect&, const Style style&) {
		int maxWidth = 0;
		int sumWidth = 0;
		int maxHeight = 0;
		int sumHeight = 0;
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i];
			Rect viewRect& = this.rects[i];
			viewRect.x = viewRect.y = 0;
			viewRect.w = rect.w;
			viewRect.h = rect.h;
			view.onMeasure(view, &viewRect, style);
			int height = Math.abs(viewRect.h);
			sumHeight += height;
			if (maxHeight < height) {
				maxHeight = height;
			}
			int width = Math.abs(viewRect.w);
			sumWidth += width;
			if (maxWidth < width) {
				maxWidth = width;
			}
		}

		View.onMeasure(this, &rect, style);
		if (rect.h < 0) {
			if ((this.gravity & Style.horizontal) != 0) {
				rect.h = maxHeight;
			} else {
				rect.h = -sumHeight;
			}
		}
		if (rect.w < 0) {
			if ((this.gravity & Style.vertical) == 0) {
				rect.w = -sumWidth;
			} else {
				rect.w = maxWidth;
			}
		}
		if (rect.h < 0 && rect.w < 0) {
			// make sure the layout is horizontal or vertical
			if (maxWidth > maxHeight) {
				rect.w = maxWidth;
				rect.h = -sumHeight;
			} else {
				rect.w = -sumWidth;
				rect.h = maxHeight;
			}
		}
	}

	void onLayout(Layout this, Rect rect&);

	void onDraw(Layout this, Image offs, Rect rect, const Style style&) {
		// draw items
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i];
			const Rect viewRect& = this.rects[i];

			if (viewRect.w > 0 && viewRect.h > 0) {
				int state = 0;
				if (i == this.pressedIndex) {
					state |= Style.pressed;
				}
				if (i == this.focusedIndex) {
					state |= Style.focused;
				}
				Layout.onDraw(view, offs, viewRect, style, state);
			}
		}
	}

	static void rowLayout(Layout this, Rect rect&) {
		int gravity = Style.horizontal + Style.left;
		int gap = 0;
		int width = 0;
		int height = 0;
		Rect r = rect;
		r.w = Math.abs(r.w);
		r.h = Math.abs(r.h);
		for (int i = 0; i < this.itemCount; i += 1) {
			Rect viewRect& = this.rects[i];
			width += Math.abs(viewRect.w);
		}
		if (rect.w > width) {
			gap = r.w - width;
			if (this.itemCount > 1) {
				gap /= this.itemCount - 1;
			}
		}
		for (int i = 0; i < this.itemCount; i += 1) {
			View view& = this.items[i];
			Rect viewRect& = this.rects[i];
			Style.align(r, &viewRect, gravity);
			if (Layout layout = view.as(Layout)) {
				layout.onLayout(layout, &viewRect);
			}
			if (viewRect.w > 0 && viewRect.h > 0) {
				r.x += gap + viewRect.w;
			}
			if (height < viewRect.h) {
				height = viewRect.h;
			}
		}
		if (rect.w < width) {
			rect.w = width;
		}
		if (rect.h < height) {
			rect.h = height;
		}
	}
	static void columnLayout(Layout this, Rect rect&) {
		int gravity = Style.vertical + Style.top;
		int gap = 0;
		int width = 0;
		int height = 0;
		Rect r = rect;
		r.w = Math.abs(r.w);
		r.h = Math.abs(r.h);
		for (int i = 0; i < this.itemCount; i += 1) {
			Rect viewRect& = this.rects[i];
			if (rect.w != 0 && rect.h != 0) {
				height += Math.abs(viewRect.h);
			}
		}
		if (rect.h > height) {
			gap = r.h - height;
			if (this.itemCount > 1) {
				gap /= this.itemCount - 1;
			}
		}
		for (int i = 0; i < this.itemCount; i += 1) {
			View view& = this.items[i];
			Rect viewRect& = this.rects[i];
			Style.align(r, &viewRect, gravity);
			if (Layout layout = view.as(Layout)) {
				layout.onLayout(layout, &viewRect);
			}
			if (viewRect.w > 0 && viewRect.h > 0) {
				r.y += gap + viewRect.h;
			}
			if (width < viewRect.w) {
				width = viewRect.w;
			}
		}
		if (rect.w < width) {
			rect.w = width;
		}
		if (rect.h < height) {
			rect.h = height;
		}
	}

	static Layout Row(View items...) {
		Layout layout = {
			onLayout: rowLayout;
			gravity: Style.horizontal;
			itemCount: items.length;
			items: pointer.alloc(null, items.length * sizeof(View));
			rects: pointer.alloc(null, items.length * sizeof(Rect));
		};
		for (int i = 0; i < items.length; i += 1) {
			layout.items[i] = items[i];
		}
		return layout;
	}
	static Layout Column(View items...) {
		Layout layout = {
			onLayout: columnLayout;
			gravity: Style.vertical;
			itemCount: items.length;
			items: pointer.alloc(null, items.length * sizeof(View));
			rects: pointer.alloc(null, items.length * sizeof(Rect));
		};
		for (int i = 0; i < items.length; i += 1) {
			layout.items[i] = items[i];
		}
		return layout;
	}
}

struct Widget: Layout {
	int visibleGroup = -1;
	bool measure = true;
	bool hidden = false;
	Style style;
	Image offs;
	Rect rect;

	// Mouse state
	int clicks;
	int64 time;
	int32 button;
	int32 mouseX;
	int32 mouseY;

	// Keyboard state
	bool isShift = false;
	bool isCtrl = false;
	bool isAlt = false;
	int key = 0;
	int repeat = 0;

	static bool setGroup(Widget this, int group, bool selectFirst) {
		if (this.visibleGroup != group) {
			this.visibleGroup = group;
			if (selectFirst) {
				// measure then focus first visible view
				this.onMeasure(this, &this.rect, this.style);
				this.setSelected(-1, true);
				this.setSelected(false);
			}
			this.measure = true;
			return true;
		}
		return false;
	}
	inline setGroup(Widget this, int group) = setGroup(this, group, false);

	void onMeasure(Widget this, Rect rect&, const Style style&) {
		static void hideViews(Widget widget, Layout layout) {
			for (int i = 0; i < layout.itemCount; i += 1) {
				View view = layout.items[i];
				if (Layout child = view.as(Layout)) {
					hideViews(widget, child);
				}
				if ((widget.visibleGroup & view.visible) == 0) {
					layout.rects[i].w = 0;
					layout.rects[i].h = 0;
				}
			}
		}
		Layout.onMeasure(this, &rect, style);
		hideViews(this, this);
	}

	void onLayout(Widget this, Rect rect&) {
		if (rect.x < 0) {
			rect.x = this.offs.width() - rect.w + rect.x;
		}
		if (rect.y < 0) {
			rect.y = this.offs.height() - rect.h + rect.y;
		}
		Layout.columnLayout(this, &rect);
	}

	void onDraw(Widget this, Image offs, Rect rect, const Style style&) {
//		offs = offs.slice(rect); // todo: clip drawings
		// draw background
		if (style.backgroundColor != -1) {
//			offs.fill(style.backgroundColor); // todo: clip drawings
			int top = rect.y - style.border;
			int left = rect.x - style.border;
			int right = rect.x + rect.w + style.border;
			int bottom = rect.y + rect.h + style.border;
			offs.fillRect(left, top, right, bottom, style.backgroundColor);
		}
		Layout.onDraw(this, offs, rect, style);
//		offs.destroy(); // todo: clip drawings
	}

	bool onMouseEvent(Widget this, const Rect rect&, const MouseEvent event&) {
		static bool focusPressed(Layout this) {
			int index = this.pressedIndex;
			if (index < 0) {
				return false;
			}

			View view = this.items[index];
			if (Layout layout = view.as(Layout)) {
				if (!layout.focusPressed()) {
					return false;
				}
			}

			this.setSelected(index, true);
			return true;
		}

		if (!Layout.onMouseEvent(this, rect, event)) {
			this.setSelected(-1, false);
			return true;
		}

		if (event.release) {
			// clear selection / focused item
			this.focusPressed();
			this.setSelected(-1, false);
		}

		return true;
	}

	static bool onEvent(Widget this, int action, int button, int x, int y) {
		if (action == Gui.WINDOW_INIT) {
			this.onCreate(this);
			// measure then focus first visible view
			this.onMeasure(this, &this.rect, this.style);
			this.setSelected(-1, true);
			this.setSelected(false);
			return true;
		}
		if (action == Gui.WINDOW_CLOSE) {
			// TODO: implement reference counted gc
			this.onDestroy(this);
			this.destroy();
			return false;
		}
		if (action == Gui.WINDOW_DRAW) {
			if (this.hidden) {
				return;
			}
			Rect rect& = this.rect;
			if (this.measure) {
				rect.w = rect.h = -1;
				this.onMeasure(this, &rect, this.style);
				this.onLayout(this, &rect);
				this.measure = false;
			}
			this.onDraw(this, this.offs, rect, this.style);
			return true;
		}
		if (action == Gui.WINDOW_ENTER) {
			// do not process event
			return false;
		}
		if (action == Gui.WINDOW_LEAVE) {
			// do not process event
			return false;
		}

		if (action == Gui.FINGER_PRESS) {
			// finger press results also a mouse event
			// skip the finger event
			return false;
		}
		if (action == Gui.FINGER_MOTION) {
			// translate to mouse event
			action = Gui.MOUSE_MOTION;
		}
		if (action == Gui.FINGER_RELEASE) {
			// finger release results also a mouse event
			// skip the finger event
			return false;
		}

		if (action == Gui.MOUSE_PRESS) {
			if (this.button != button || this.mouseX != x || this.mouseY != y) {
				this.clicks = 0;
			}
			int64 now = System.millis();
			if ((now - this.time) / 1000. > .5) {
				this.clicks = 0;
			}
			this.time = System.millis();
			this.button = button;
			this.mouseX = x;
			this.mouseY = y;
			this.clicks += 1;

			if (button != 1) {
				return false;
			}

			MouseEvent event = {
				release: false;
				isShift: this.isShift;
				isCtrl: this.isCtrl;
				isAlt: this.isAlt;
				clicks: this.clicks;
				button: button;
				x: x;
				y: y;
			};
			return this.onMouseEvent(this, this.rect, event);
		}
		if (action == Gui.MOUSE_MOTION) {
			int oldX = this.mouseX;
			int oldY = this.mouseY;
			this.time = System.millis();
			this.button = button;
			this.mouseX = x;
			this.mouseY = y;
			this.clicks = 0;

			if (button != 1) {
				return false;
			}
			MouseEvent event = {
				release: false;
				isShift: this.isShift;
				isCtrl: this.isCtrl;
				isAlt: this.isAlt;
				clicks: this.clicks;
				button: button;
				dx: x - oldX;
				dy: y - oldY;
				x: x;
				y: y;
			};
			return this.onMouseEvent(this, this.rect, event);
		}
		if (action == Gui.MOUSE_RELEASE) {
			int64 now = System.millis();
			if ((now - this.time) / 1000. > .5) {
				this.clicks = 0;
			}
			if (button != 1) {
				return false;
			}

			MouseEvent event = {
				release: true;
				isShift: this.isShift;
				isCtrl: this.isCtrl;
				isAlt: this.isAlt;
				clicks: this.clicks;
				button: button;
				x: x;
				y: y;
			};
			return this.onMouseEvent(this, this.rect, event);
		}

		if (action == Gui.KEY_PRESS) {
			this.isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
			this.isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
			this.isAlt = (y & Gui.KEY_MASK_ALT) != 0;
			if (this.key != button) {
				this.key = button;
				this.repeat = 0;
			} else {
				this.repeat += 1;
			}

			if (button == '\t' || button == '\r') {
				// Tab, Enter: select prev or next control.
				if (!this.setSelected(this.isShift)) {
					return this.setSelected(this.isShift);
				}
				return true;
			}
			if (button == '[' || button == ']') {
				// hide, show controls
				Rect r& = this.rect;
				if (button == '[' && r.x == r.y) {
					this.hidden = !this.hidden;
					return true;
				}
				if (button == ']' && r.x != r.y) {
					this.hidden = !this.hidden;
					return true;
				}

				if (this.rect.x == this.rect.y) {
					r.x = -r.y;
				} else {
					r.x = r.y;
				}
				this.hidden = false;
				this.measure = true;
				return true;
			}
			if (button == 8 && this.isShift) {
				return this.onReset(this);
			}

			KeyEvent event = {
				release: false;
				isShift: this.isShift;
				isCtrl: this.isCtrl;
				isAlt: this.isAlt;
				repeat: this.repeat;
				key: button;
			};
			return this.onKeyEvent(this, event);
		}
		if (action == Gui.KEY_RELEASE) {
			this.isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
			this.isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
			this.isAlt = (y & Gui.KEY_MASK_ALT) != 0;
			this.key = 0;
			KeyEvent event = {
				release: true;
				isShift: this.isShift;
				isCtrl: this.isCtrl;
				isAlt: this.isAlt;
				repeat: 0;
				key: button;
			};
			return this.onKeyEvent(this, event);
		}

		debug("event not processed", action);
		return false;
	}

	static int draw(Widget this) {
		this.onEvent(Gui.WINDOW_DRAW, 0, 0, 0);
		return 0;
	}
}

Widget Widget(Image offs, int pos, const Style style&, View items...) {
	Widget layout = {
		offs: offs;
		rect: {
			x: pos;
			y: pos;
			w: -1;
			h: -1;
		};
		style: style;
		gravity: Style.vertical;
		itemCount: items.length;
		items: pointer.alloc(null, items.length * sizeof(View));
		rects: pointer.alloc(null, items.length * sizeof(Rect));
	};
	for (int i = 0; i < items.length; i += 1) {
		layout.items[i] = items[i];
	}

	if (pos < 0) {
		layout.rect.y = -pos;
	}
	return layout;
}
Widget Widget(Image offs, int pos, View items...) {
	Style style = {
		align: Style.left;
		fmtInt: { padLen: 4 };
		fmtFlt: { padLen: 4, precision: 2 };
	};
	return Widget(offs, pos, style, ...items);
}

struct Histogram: View {
	const bool lines = false;
	// histogram data is in alpha channel, display it with color rgb
	bool color = false;
	argb data[256] = null;   // FIXME: this should be not possible

	static void update(Histogram this, Image image) {
		uint32 data[*] = pointer(this.data);
		image.calcRgbHist(null, &data);
		this.color = false;
	}

	bool onUpdate(Histogram this, int idx, int value) {
		this.data[idx] = argb(idx, value, value, value);
		return true;
	}

	bool onReset(Histogram this) {
		bool result = false;
		for (int i = 0; i < 256; i += 1) {
			result |= Histogram.onUpdate(this, i, i);
		}
		return result;
	}

	void onCreate(Histogram this) {
		Histogram.onReset(this);
	}

	bool onMouseEvent(Histogram this, const Rect rect&, const MouseEvent event&) {
		if (event.release) {
			return View.onMouseEvent(this, rect, event);
		}

		int x0 = event.x - rect.x;
		int x1 = x0 - event.dx;
		int y0 = event.y - rect.y;
		int y1 = y0 - event.dy;

		if (x0 > x1) {
			int x = x0;
			x0 = x1;
			x1 = x;
			int y = y0;
			y0 = y1;
			y1 = y;
		}
		int y = y0 << 16;
		int dy = y1 - y0;
		if (x1 != x0) {
			dy = (dy << 16) / (x1 - x0);
		}
		if (x0 < 0) {
			y -= x0 * dy;
			x0 = 0;
		}
		if (x1 > 256) {
			x1 = 256;
		}
		int h = rect.h;
		for (int x = x0; x < x1; x += 1) {
			int val = 255 * (h - (y >> 16)) / h;
			this.onUpdate(this, x, val);
			y += dy;
		}
		return true;
	}

	void onMeasure(Histogram this, Rect rect&, const Style style&) {
		if (this.width < 0) {
			rect.w = 256;
		}
		if (this.height < 0) {
			rect.h = 128;
		}
		return View.onMeasure(this, &rect, style);
	}

	void onDraw(Histogram this, Image offs, const Rect rect, const Style style&) {
		enum {
			colB: 0x4371c6;
			colG: 0x72d874;
			colR: 0xfc6165;
			colL: 0xdadada;
		}
		int px = (rect.w - 256) / 2;
		if (this.lines) {
			int y = rect.y + rect.h - 1;
			int pb = bch(this.data[0]) * rect.h / 256;
			int pg = gch(this.data[0]) * rect.h / 256;
			int pr = rch(this.data[0]) * rect.h / 256;
			int pl = ach(this.data[0]) * rect.h / 256;

			for (int i = 1; i < this.data.length; i += 1) {
				int x = rect.x + i + px;
				argb data = this.data[i];
				int bv = bch(data) * rect.h / 256;
				int gv = gch(data) * rect.h / 256;
				int rv = rch(data) * rect.h / 256;
				int lv = ach(data) * rect.h / 256;

				if (this.color) {
					offs.drawLine(x, y - pl, x, y - lv, uint32(data));
				} else {
					offs.drawLine(x, y - pb, x, y - bv, colB);
					offs.drawLine(x, y - pg, x, y - gv, colG);
					offs.drawLine(x, y - pr, x, y - rv, colR);
					offs.drawLine(x, y - pl, x, y - lv, colL);
				}

				pb = bv;
				pg = gv;
				pr = rv;
				pl = lv;
			}
		} else {
			for (int i = 0; i < this.data.length; i += 1) {
				int x = rect.x + i + px;
				argb data = this.data[i];
				if (this.color) {
					int y1 = rect.y + rect.h;
					int y0 = y1 - ach(data) * rect.h / 256;
					offs.fillRect(x, y0 - 1, x + 1, y1, uint32(data));
				} else {
					int bv = bch(data) * rect.h / 256;
					int gv = gch(data) * rect.h / 256;
					int rv = rch(data) * rect.h / 256;
					int lv = ach(data) * rect.h / 256;
					for (int y = 0; y < rect.h; y += 1) {
						uint32 b = colB * uint32(y < bv);
						uint32 g = colG * uint32(y < gv);
						uint32 r = colR * uint32(y < rv);
						uint32 l = colL * uint32(y < lv);
						offs.set(x, rect.h - y + rect.y - 1, r | g | b | l);
					}
				}
			}
		}
	}
}
