// micro ui, TODO: add comments

struct Style {
	const Image font;

	const FormatFlags flagsInt;
	const FormatFlags flagsFlt;

	int backgroundColor = 0x1a1a1a;
	int focusedColor = 0x3b4754;
	int valueColor = 0x6897bb;
	int textColor = 0xdadada;

	int border = 3;
	int padding = 8;

	enum: int32 {
		left: 1;
		right: 2;

		top: 4;
		bottom: 8;

		center: 0;

		fitVertical: left + right;
		fitHorizontal: top + bottom;
	}

	/// Align one rect containing text relative to its container
	static void align(const Style this&, Rect rect, Rect valueRect&, const char value[*], int align) {
		rect.x += this.padding;
		rect.y += this.padding;
		rect.w -= 2 * this.padding;
		rect.h -= 2 * this.padding;
		this.font.clipText(&valueRect, value);

		if (valueRect.w > rect.w) {
			valueRect.w = rect.w;
		}

		int vertical = align & fitVertical;
		if (vertical == center) {
			valueRect.x = rect.x + (rect.w - valueRect.w) / 2;
		}
		else if (vertical == right) {
			valueRect.x = rect.x + (rect.w - valueRect.w);
		}
		else if (vertical == left) {
			valueRect.x = rect.x;
		}
		else { // fit
			valueRect.x = rect.x;
			valueRect.w = rect.w;
		}

		int horizontal = align & fitHorizontal;
		if (horizontal == center) {
			valueRect.y = rect.y + (rect.h - valueRect.h) / 2;
		}
		else if (horizontal == bottom) {
			valueRect.y = rect.y + (rect.h - valueRect.h);
		}
		else if (horizontal == top) {
			valueRect.y = rect.y;
		}
		else { // fit
			valueRect.y = rect.y;
			valueRect.h = rect.h;
		}
	}
}
struct KeyEvent {
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int repeat;
	const int key;
}
struct MouseEvent {
	const Rect clientRect&;
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int repeat;
	const int button;
	const int dx = 0;
	const int dy = 0;
	const int x;
	const int y;
}

struct View: object {
	const int height = 0;
	const int group = 0;
	bool enabled = true;
	bool selectable = true;
	const variant data = null;

	bool onClick(View this) {
		return true;
	}

	bool onReset(View this) {
		return false;
	}

	void onCreate(View this) {
	}

	bool onKeyEvent(View this, const KeyEvent event&) {
		if (event.release) {
			return false;
		}
		if (event.key == 8 && !event.isShift) {
			return this.onReset(this);
		}
		if (event.key == ' ') {
			return this.onClick(this);
		}
		return false;
	}

	bool onMouseEvent(View this, const MouseEvent event&) {
		if (!event.release) {
			return false;
		}
		if (event.repeat > 1) {
			// double click to reset
			return this.onReset(this);
		}
		return this.onClick(this);
	}

	void onMeasure(View this, Rect rect&, const Style style&);

	void onDraw(View this, Image offs, Rect rect, const Style style&);
}

struct Button: View {
	const char text[*];

	void onMeasure(Button this, Rect rect&, const Style style&) {
		if (this.height == 0) {
			rect.h = style.font.height() + 2 * style.padding;
		}
		else if (this.text == null) {
			// TODO: remove hack: empty button used for separator
			rect.h = this.height + style.padding;
		}
		else {
			rect.h = this.height;
		}
	}

	void onDraw(Button this, Image offs, Rect rect, const Style style&) {
		Style.align(style, rect, &rect, this.text, Style.left);
		offs.drawText(rect, style.font, this.text, style.textColor);
	}
}

struct Switch: View {
	const char on[*] = "on";
	const char off[*] = "off";
	const char text[*];

	bool checked = false;
	const bool resetValue = false;

	bool onUpdate(Switch this, bool checked) {
		if (this.checked == checked) {
			return false;
		}
		this.checked = checked;
		return true;
	}

	bool onClick(Switch this) {
		return Switch.onUpdate(this, !this.checked);
	}

	bool onReset(Switch this) {
		return Switch.onUpdate(this, this.resetValue);
	}

	void onCreate(Switch this) {
		bool resetValue& = pointer(this.resetValue);
		resetValue = this.checked;
	}

	bool onKeyEvent(Switch this, const KeyEvent event&) {
		if (event.release) {
			return View.onKeyEvent(this, event);
		}
		if (event.key == '+' || event.key == '=') {
			return this.onUpdate(this, true);
		}
		if (event.key == '-' || event.key == '_') {
			return this.onUpdate(this, false);
		}
		return View.onKeyEvent(this, event);
	}

	void onMeasure(Switch this, Rect rect&, const Style style&) {
		if (this.height == 0) {
			rect.h = style.font.height() + 2 * style.padding;
		} else {
			rect.h = this.height;
		}
	}

	void onDraw(Switch this, Image offs, Rect rect, const Style style&) {
		Rect valueRoi = rect;
		char value[*] = this.checked ? this.on : this.off;

		Style.align(style, valueRoi, &valueRoi, value, Style.right);
		rect.w -= valueRoi.w + style.padding;
		Style.align(style, rect, &rect, this.text, Style.left);
		offs.drawText(valueRoi, style.font, value, style.valueColor);
		offs.drawText(rect, style.font, this.text, style.textColor);
	}
}

struct Slider: View {
	const char text[*];
	int value = 0;
	const int minimum = 0;
	const int maximum = -1u >> 1;
	const int divisor = 0;
	const int resetValue = 0;

	static float64 valFlt(Slider slider&) {
		float64 value = slider.value;
		if (slider.divisor != 0) {
			return value / slider.divisor;
		}
		return value / (slider.maximum - slider.minimum);
	}

	bool onUpdate(Slider this, int value) {
		if (value > this.maximum) {
			value = this.maximum;
		}
		if (value < this.minimum) {
			value = this.minimum;
		}
		if (this.value == value) {
			return false;
		}
		this.value = value;
		return true;
	}

	bool onReset(Slider this) {
		return Slider.onUpdate(this, this.resetValue);
	}

	void onCreate(Slider this) {
		Slider.onUpdate(this, this.value);// clamp initial value
		int resetValue& = pointer(this.resetValue);
		resetValue = this.value;
	}

	bool onKeyEvent(Slider this, const KeyEvent event&) {
		if (event.release) {
			return View.onKeyEvent(this, event);
		}
		if (event.key == ' ') {
			return this.onReset();
		}
		if (event.key == '+' || event.key == '=') {
			return this.onUpdate(this, this.value + (event.isShift ? 1 : 10));
		}
		if (event.key == '-' || event.key == '_') {
			return this.onUpdate(this, this.value - (event.isShift ? 1 : 10));
		}
		return View.onKeyEvent(this, event);
	}

	bool onMouseEvent(Slider this, const MouseEvent event&) {
		if (event.dy != 0 && !event.release) {
			return this.onUpdate(this, this.value + event.dy);
		}
		return View.onMouseEvent(this, event);
	}

	void onMeasure(Slider this, Rect rect&, const Style style&) {
		if (this.height == 0) {
			rect.h = style.font.height() + 2 * style.padding;
		} else {
			rect.h = this.height;
		}
	}

	void onDraw(Slider this, Image offs, Rect rect, const Style style&) {
		Rect valueRoi = rect;
		char value[64] = {0};
		if (this.divisor != 0) {
			float32 valueF64 = float64(this.value) / this.divisor;
			value.append(0, valueF64, style.flagsFlt);
		} else {
			value.append(0, this.value, style.flagsInt);
		}

		Style.align(style, valueRoi, &valueRoi, value, Style.right);
		rect.w -= valueRoi.w + style.padding;
		Style.align(style, rect, &rect, this.text, Style.left);
		offs.drawText(valueRoi, style.font, value, style.valueColor);
		offs.drawText(rect, style.font, this.text, style.textColor);
	}
}

struct Histogram: View {
	const bool lines = false;
	// histogram data is in alpha channel, display it with color rgb
	bool color = false;
	argb data[256] = null;   // FIXME: this should be not possible

	static void update(Histogram this, Image image) {
		uint32 data[*] = pointer(this.data);
		image.calcRgbHist(null, &data);
		this.color = false;
	}

	bool onUpdate(Histogram this, int idx, int value) {
		this.data[idx] = argb(idx, value, value, value);
		return true;
	}

	bool onReset(Histogram this) {
		bool result = false;
		for (int i = 0; i < 256; i += 1) {
			result |= Histogram.onUpdate(this, i, i);
		}
		return result;
	}

	void onCreate(Histogram this) {
		Histogram.onReset(this);
	}

	bool onMouseEvent(Histogram this, const MouseEvent event&) {
		if (event.release) {
			return View.onMouseEvent(this, event);
		}

		const Rect rect& = event.clientRect;
		int x0 = event.x - rect.x;
		int x1 = x0 + event.dx;
		int y0 = event.y - rect.y;
		int y1 = y0 + event.dy;

		if (x0 > x1) {
			int x = x0;
			x0 = x1;
			x1 = x;
			int y = y0;
			y0 = y1;
			y1 = y;
		}
		int y = y0 << 16;
		int dy = y1 - y0;
		if (x1 != x0) {
			dy = (dy << 16) / (x1 - x0);
		}
		if (x0 < 0) {
			y -= x0 * dy;
			x0 = 0;
		}
		if (x1 > 256) {
			x1 = 256;
		}
		int h = rect.h;
		for (int x = x0; x < x1; x += 1) {
			int val = 255 * (h - (y >> 16)) / h;
			this.onUpdate(this, x, val);
			y += dy;
		}
		return true;
	}

	void onMeasure(Histogram this, Rect rect&, const Style style&) {
		if (this.height == 0) {
			rect.h = 128;
		} else {
			rect.h = this.height;
		}
		return;
	}

	void onDraw(Histogram this, Image offs, const Rect rect, const Style style&) {
		enum {
			colB: 0x4371c6;
			colG: 0x72d874;
			colR: 0xfc6165;
			colL: 0xdadada;
		}
		int px = (rect.w - 256) / 2;
		if (this.lines) {
			int y = rect.y + rect.h - 1;
			int pb = bch(this.data[0]) * rect.h / 256;
			int pg = gch(this.data[0]) * rect.h / 256;
			int pr = rch(this.data[0]) * rect.h / 256;
			int pl = ach(this.data[0]) * rect.h / 256;

			for (int i = 1; i < this.data.length; i += 1) {
				int x = rect.x + i + px;
				argb data = this.data[i];
				int bv = bch(data) * rect.h / 256;
				int gv = gch(data) * rect.h / 256;
				int rv = rch(data) * rect.h / 256;
				int lv = ach(data) * rect.h / 256;

				if (this.color) {
					offs.drawLine(x, y - pl, x, y - lv, uint32(data));
				} else {
					offs.drawLine(x, y - pb, x, y - bv, colB);
					offs.drawLine(x, y - pg, x, y - gv, colG);
					offs.drawLine(x, y - pr, x, y - rv, colR);
					offs.drawLine(x, y - pl, x, y - lv, colL);
				}

				pb = bv;
				pg = gv;
				pr = rv;
				pl = lv;
			}
		} else {
			for (int i = 0; i < this.data.length; i += 1) {
				argb data = this.data[i];
				if (this.color) {
					int x = rect.x + i + px;
					int y1 = rect.y + rect.h;
					int y0 = y1 - ach(data) * rect.h / 256;
					offs.fillRect(x, y0 - 1, x + 1, y1, uint32(data));
				} else {
					int x = rect.x + px + i;
					int bv = bch(data) * rect.h / 256;
					int gv = gch(data) * rect.h / 256;
					int rv = rch(data) * rect.h / 256;
					int lv = ach(data) * rect.h / 256;
					for (int y = 0; y < rect.h; y += 1) {
						uint32 b = colB * uint32(y < bv);
						uint32 g = colG * uint32(y < gv);
						uint32 r = colR * uint32(y < rv);
						uint32 l = colL * uint32(y < lv);
						offs.set(x, rect.h - y + rect.y - 1, r | g | b | l);
					}
				}
			}
		}
	}
}

struct Layout: object {
	Style style;
	Image offs;
	Rect rect;

	bool visible = true;
	bool measure = true;
	int selectedIndex = -1;
	int activeIndex = -1;
	bool colorPick = false;
	View views[64] = null;
	Rect rects[64] = null;
	int items = 0;
	int group = 0;

	static bool isActive(const Layout layout&, View views...) {
		View active = layout.activeIndex < 0 ? null : layout.views[layout.activeIndex];
		for (int i = 0; i < views.length; i += 1) {
			if (views[i] == active) {
				return true;
			}
		}
		return false;
	}
	static bool isSelected(const Layout layout&, View items...) {
		View selected = layout.selectedIndex < 0 ? null : layout.views[layout.selectedIndex];
		for (int i = 0; i < items.length; i += 1) {
			if (items[i] == selected) {
				return true;
			}
		}
		return false;
	}

	static View getSelected(const Layout layout&) {
		if (layout.selectedIndex < 0) {
			return null;
		}
		return layout.views[layout.selectedIndex];
	}
	static bool setSelected(Layout layout&, View view) {
		if (view == null) {
			layout.selectedIndex = -1;
			return true;
		}
		for (int i = 0; i < layout.items; i += 1) {
			if (layout.views[i] == view) {
				layout.selectedIndex = i;
				return true;
			}
		}
		return false;
	}
	static bool setGroup(Layout layout&, int group) {
		if (layout.group != group) {
			layout.group = group;
			layout.measure = true;
			return true;
		}
		return false;
	}

	static bool onEvent(Layout layout&, int action, int button, int x, int y) {
		struct Mouse {
			int32 clicks;   // click count
			int64 time;     // old clock
			int32 btn;      // old button
			int32 x;        // old x coord
			int32 y;        // old y coord

			static int click(Mouse old&, int btn, int x, int y) {
				if ((btn != 0 && btn != old.btn) || x != old.x || y != old.y) {
					// reset values
					old.clicks = 1;
					old.time = System.millis();
					old.btn = btn;
					old.x = x;
					old.y = y;
					return 0;
				}
				if (btn == 0) {
					// release button
					// old.time = keep value?;
					// old.btn = keep value?;
					// old.cnt = keep value?;
					return old.clicks;
				}

				int64 now = System.millis();
				if ((now - old.time) / 1000. > .5) {
					// reset counter
					old.clicks = 0;
				}
				old.time = now;
				old.btn = btn;
				old.clicks += 1;
				return old.clicks;
			}
		}

		static int click(Layout layout&, int x, int y) {
			static bool test(const Rect rect&, int x, int y) {
				if (x < rect.x || x >= rect.x + rect.w) {
					return false;
				}
				if (y < rect.y || y >= rect.y + rect.h) {
					return false;
				}
				return true;
			}

			if (!layout.visible) {
				return -1;
			}
			if (!layout.rect.test(x, y)) {
				return -1;
			}
			for (int i = 0; i < layout.items; i += 1) {
				if (!layout.rects[i].test(x, y)) {
					continue;
				}

				View view = layout.views[i];
				if (!view.enabled) {
					return -1;
				}
				return i;
			}
			return -1;
		}
		static bool select(Layout layout&, int index) {
			assert(index >= 0, "invalid selection");
			assert(index < layout.items, "invalid selection");

			View view = layout.views[index];
			if (!view.enabled) {
				return false;
			}
			if (!view.selectable) {
				return false;
			}
			if (layout.group != view.group) {
				if (layout.group != 0) {
					if (view.group != 0) {
						return false;
					}
				}
			}
			layout.selectedIndex = index;
			return true;
		}
		static bool select(Layout layout&, bool prev) {
			layout.activeIndex = -1;
			int selectedIndex = layout.selectedIndex;
			for (int i = 1; i < layout.items; i += 1) {
				int index = selectedIndex + (prev ? -i : i);
				if (index >= layout.items) {
					index -= layout.items;
				}
				else if (index < 0) {
					index += layout.items;
				}
				if (layout.select(index)) {
					return true;
				}
			}
			return false;
		}
		static View active(const Layout layout&) {
			int idx = layout.activeIndex;
			if (idx < 0) {
				idx = layout.selectedIndex;
			}
			if (idx < 0) {
				return null;
			}
			return layout.views[idx];
		}
		static void measure(Layout layout&) {
			int bottom = layout.rect.y;
			for (int i = 0; i < layout.items; i += 1) {
				Rect rect& = layout.rects[i];
				View view = layout.views[i];

				rect.x = layout.rect.x;
				rect.y = bottom;
				rect.w = layout.rect.w;
				rect.h = view.height;

				view.onMeasure(&rect, layout.style);
				if (layout.group != view.group) {
					if (layout.group != 0) {
						if (view.group != 0) {
							rect.h = 0;
						}
					}
				}
				if (rect.h > 0) {
					bottom += rect.h;
				}
			}
			layout.rect.h = bottom - layout.rect.y;
		}
		static void draw(Layout layout&) {
			if (!layout.visible) {
				return;
			}

			// draw background
			if (layout.style.backgroundColor != -1) {
				int b = layout.style.border;
				const Rect r& = layout.rect;
				layout.offs.fillRect(r.x - b, r.y - b, r.x + r.w + b, r.y + r.h + b, layout.style.backgroundColor);
			}

			// draw items
			Image offs = layout.offs.slice(null);
			for (int i = 0; i < layout.items; i += 1) {
				View view = layout.views[i];
				const Rect rect& = layout.rects[i];

				if (i == layout.selectedIndex) {
					layout.offs.fillRect(rect.x, rect.y, rect.x + rect.w, rect.y + rect.h, layout.style.focusedColor);
				}

				if (rect.w > 0 && rect.h > 0) {
					offs.slice(layout.offs, rect);
					Rect rect = {
						x: 0; y: 0;
						w: offs.width();
						h: offs.height();
					};
					view.onDraw(offs, rect, layout.style);
				}

				if (i == layout.activeIndex) {
					layout.offs.drawRect(rect.x, rect.y, rect.x + rect.w - 1, rect.y + rect.h - 1, layout.style.valueColor);
				}
			}
			offs.destroy();
		}

		static Mouse mouse = {};
		static bool isShift;
		static bool isCtrl;
		static bool isAlt;

		layout.colorPick = false;
		if (action == Gui.WINDOW_INIT) {
			layout.selectedIndex = -1;
			layout.measure = true;
			layout.select(false);
			return true;
		}
		if (action == Gui.WINDOW_DRAW) {
			if (layout.measure) {
				layout.measure = false;
				measure(layout);
			}
			layout.draw();
			return true;
		}
		if (action == Gui.WINDOW_ENTER) {
			// do not process event
			return false;
		}
		if (action == Gui.WINDOW_LEAVE) {
			// do not process event
			return false;
		}

		if (action == Gui.FINGER_PRESS) {
			// finger press results also a mouse event
			// skip the finger event
			return false;
		}
		if (action == Gui.FINGER_MOTION) {
			// translate to mouse event
			action = Gui.MOUSE_MOTION;
		}
		if (action == Gui.FINGER_RELEASE) {
			// finger release results also a mouse event
			// skip the finger event
			return false;
		}

		if (action == Gui.MOUSE_PRESS) {
			Mouse.click(&mouse, button, x, y);
			if (button != 1) {
				return false;
			}
			bool result = false;
			int activeIndex = layout.click(x, y);
			if (layout.activeIndex != activeIndex) {
				// active index changed, most probably from -1
				layout.activeIndex = activeIndex;
				result = true;
			}
			if (activeIndex < 0) {
				// allow update of selected control
				activeIndex = layout.selectedIndex;
				layout.colorPick = true;
				if (activeIndex < 0) {
					return result;
				}
			}
			if (View view = layout.views[activeIndex]) {
				Rect rect& = layout.rects[activeIndex];
				MouseEvent event = {
					clientRect: rect;
					release: false;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: mouse.clicks;
					button: button;
					x: x;
					y: y;
				};
				if (view.onMouseEvent(event)) {
					return true;
				}
			}
			return result;
		}
		if (action == Gui.MOUSE_MOTION) {
			int ox = mouse.x;
			int oy = mouse.y;
			Mouse.click(&mouse, -1, x, y);
			if (button != 1) {
				return false;
			}
			if (ox == x && oy == y) {
				return false;
			}
			int activeIndex = layout.activeIndex;
			if (activeIndex < 0) {
				// allow update of selected control
				activeIndex = layout.selectedIndex;
				layout.colorPick = true;
				if (activeIndex < 0) {
					return true;
				}
			}
			if (View view = layout.views[activeIndex]) {
				Rect rect& = layout.rects[activeIndex];
				MouseEvent event = {
					clientRect: rect;
					release: false;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: mouse.clicks;
					button: button;
					dx: ox - x;
					dy: oy - y;
					x: x;
					y: y;
				};
				if (view.onMouseEvent(event)) {
					return true;
				}
			}
			return false;
		}
		if (action == Gui.MOUSE_RELEASE) {
			int btn = mouse.btn;
			Mouse.click(&mouse, 0, x, y);
			if (button != 1) {
				return false;
			}

			bool result = false;
			int activeIndex = layout.activeIndex;
			if (activeIndex >= 0) {
				layout.activeIndex = -1;
				result = true;
			}
			if (activeIndex != layout.click(x, y)) {
				// release on a different view
				return result;
			}
			if (activeIndex < 0) {
				// might be a disabled view
				layout.colorPick = true;
				return result;
			}
			// select / focus the view
			if (layout.select(activeIndex)) {
				result = true;
			}
			if (View view = layout.views[activeIndex]) {
				Rect rect& = layout.rects[activeIndex];
				MouseEvent event = {
					clientRect: rect;
					release: true;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: mouse.clicks;
					button: button;
					x: x;
					y: y;
				};
				if (view.onMouseEvent(event)) {
					result = true;
				}
			}
			return result;
		}

		if (action == Gui.KEY_PRESS) {
			isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
			isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
			isAlt = (y & Gui.KEY_MASK_ALT) != 0;

			if (button == '\t' || button == '\r') {
				// Tab, Enter: select prev or next control.
				return layout.select(isShift);
			}
			if (button == ' ' && isShift) {
				// hide, show controls
				layout.visible = !layout.visible;
				return true;
			}
			if (button == 8 && isShift) {
				bool result = false;
				for (int i = 0; i < layout.items; i += 1) {
					View view = layout.views[i];
					if (view.onReset()) {
						result = true;
					}
				}
				return result;
			}
			if (View view = layout.active()) {
				KeyEvent event = {
					release: false;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: 0;
					key: button;
				};
				if (view.onKeyEvent(event)) {
					return true;
				}
			}
			return false;
		}
		if (action == Gui.KEY_RELEASE) {
			isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
			isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
			isAlt = (y & Gui.KEY_MASK_ALT) != 0;
			if (View view = layout.active()) {
				KeyEvent event = {
					release: true;
					isShift: isShift;
					isCtrl: isCtrl;
					isAlt: isAlt;
					repeat: 0;
					key: button;
				};
				if (view.onKeyEvent(event)) {
					return true;
				}
			}
			return false;
		}

		debug("event not processed", action);
		return false;
	}

	static void draw(Layout layout&) {
		layout.onEvent(Gui.WINDOW_DRAW, 0, 0, 0);
	}
}

Layout Layout(Image offs, int x, int y, Image font, View items...) {
	Layout layout = {
		offs: offs;
		rect: {
			x: x;
			y: y;
			w: 256;
			h: 0;
		};
		style: {
			font: font;
			flagsInt: { padLen: 4 };
			flagsFlt: { padLen: 4, precision: 2 };
		};
	};

	for (int i = 0; i < layout.views.length; i += 1) {
		layout.views[i] = null;
	}

	for (int i = 0; i < items.length; i += 1) {
		assert(i < layout.views.length);
		layout.views[i] = items[i];
		items[i].onCreate(items[i]);
	}
	layout.items = items.length;

	if (y < 0) {
		layout.onEvent(Gui.WINDOW_INIT, 0, 0, 0);
		layout.rect.y = offs.height() - layout.rect.h + y;
	}
	if (x < 0) {
		layout.rect.x = offs.width() - layout.rect.w + x;
	}
	return layout;
}

inline getSelected(const Layout layout&, typename type) = layout.getSelected().as(type);
