// micro ui, TODO: add comments

static if (typename(debugLayoutDraw) == null) {
inline debugLayoutDraw(Image img, const Rect rect&, uint32 rgb) = void(0);
}

struct Style {
	static const argb dark = argb(0x1a1a1a);
	static const argb light = argb(0xdadada);
	static const argb accent = argb(51, 123, 246);

	// text alignment in views
	const int align = 0;

	// padding around text in views
	const int padding = 8;

	const Image font = Gui.font;
	const FormatFlags format;

	uint32 backgroundColor = 0x1a1a1a;
	// int highlightColor = TODO;
	// int disabledColor = TODO;
	uint32 hoveredColor = 0x2a2a2a;
	uint32 focusedColor = 0x3b4754;
	uint32 valueColor = 0x6897bb;
	uint32 textColor = 0xdadada;

	enum: int32 {
		center: 0;

		top: 1;
		left: 2;
		right: 4;
		bottom: 8;

		topLeft: top | left;
		topRight: top | right;
		bottomLeft: bottom | left;
		bottomRight: bottom | right;

		vertical: left | right;
		verticalTop: vertical | top;
		verticalBottom: vertical | bottom;

		horizontal: top | bottom;
		horizontalLeft: horizontal | left;
		horizontalRight: horizontal | right;

		fill: top | left | right | bottom;
	}

	enum: int32 {
		hovered: 1;
		pressed: 2;
		focused: 4;
	}

	static void measure(const Style this&, Rect rect&, const char text[*]) {
		this.font.clipText(&rect, text);
		rect.w += 2 * this.padding;
		rect.h += 2 * this.padding;
	}

	/// Align one rect containing text relative to its container
	static void align(Rect parent, Rect rect&, int align) {
		int vertical = align & Style.vertical;
		if (vertical == center) {
			rect.x = parent.x + (parent.w - rect.w) / 2;
		}
		else if (vertical == right) {
			rect.x = parent.x + (parent.w - rect.w);
		}
		else if (vertical == left) {
			rect.x = parent.x;
		}
		else { // fit
			rect.x = parent.x;
			rect.w = parent.w;
		}

		int horizontal = align & Style.horizontal;
		if (horizontal == center) {
			rect.y = parent.y + (parent.h - rect.h) / 2;
		}
		else if (horizontal == bottom) {
			rect.y = parent.y + (parent.h - rect.h);
		}
		else if (horizontal == top) {
			rect.y = parent.y;
		}
		else { // fit
			rect.y = parent.y;
			rect.h = parent.h;
		}
	}

	static void align(const Style this&, Rect parent, Rect rect&, const char value[*], int align) {
		parent.adjust(-this.padding);
		this.font.clipText(&rect, value);
		align(parent, &rect, align);
	}

	static void align(const Style this&, Rect parent, Rect rect&, const char value[*]) {
		return align(this, parent, &rect, value, this.align);
	}

	static void setColor(Style style&, argb background, argb accent) {
		style.backgroundColor = uint32(background);
		style.hoveredColor = uint32(mix_s8(16, background, accent));
		style.focusedColor = uint32(mix_s8(64, background, accent));
		style.valueColor = uint32(accent);
		style.textColor = uint32(gray(lum(background) > 128 ? 0 : 150));
	}

	inline vertical(int align) = (align & vertical) == vertical;
	inline horizontal(int align) = (align & horizontal) == horizontal;
}
struct KeyEvent {
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int repeat;
	const int key;
}
struct TouchEvent {
	const bool release;
	const bool isShift;
	const bool isCtrl;
	const bool isAlt;
	const int clicks;
	const int button;
	const int dx = 0;
	const int dy = 0;
	const int x;
	const int y;

	static bool test(const TouchEvent event&, const Rect rect&) {
		if (event.x < rect.x || event.x >= rect.x + rect.w) {
			return false;
		}
		if (event.y < rect.y || event.y >= rect.y + rect.h) {
			return false;
		}
		return true;
	}

	static bool isMotion(const TouchEvent event&) {
		return event.dx || event.dy;
	}

	static bool isPress(const TouchEvent event&) {
		return !(event.release || event.dx || event.dy);
	}

	static bool isLongPress(const TouchEvent event&) {
		return event.release && event.clicks < 0;
	}

	static bool isPress(const TouchEvent event&, int button) {
		if (event.release || event.dx || event.dy) {
			return false;
		}
		return event.button == button;
	}
}

/** View is the base class of all user interface elements.
 * it has width and height, forming a rectangular shape on screen.
 * by it's own a view has no position, it must be positioned in a layout.
 */
struct View: object {
	/// fixed or minimum width of the view
	const int width = -5;

	/// fixed or minimum height of the view
	const int height = -5;

	/// the view accepts any user input(event) or not
	bool enabled = true;

	/// the view can be active(focused) or not
	bool focusable = true;

	// parent view
	View parent = null;

	// style (FIXME: using pointer to enable updating the reference)
	pointer style = null;

	/// user attached data
	variant data = null;

	bool onClick(View this) {
		return true;
	}

	bool onReset(View this) {
		return false;
	}

	void onCreate(View this, View parent) {
		assert(this.parent == null || this.parent == parent, "can not add the same view to different layouts");
		this.parent = parent;
		if (this.style == null) {
			this.style = parent.style;
		}
	}

	void onDestroy(View this) { }

	bool onKeyEvent(View this, const KeyEvent event&) {
		if (!this.enabled) {
			// disabled view does not consume events
			return false;
		}
		if (event.release) {
			return false;
		}
		if (event.key == 8 && !event.isShift) {
			return this.onReset(this);
		}
		if (event.key == ' ') {
			return this.onClick(this);
		}
		return false;
	}

	bool onTouchEvent(View this, const Rect rect&, const TouchEvent event&) {
		/* press, release or motion
		if (event.dx || event.dy) {
			return onMotion(event);
		}
		if (event.release) {
			return onRelease(event);
		}
		return onPress(event);*/
		if (!this.enabled) {
			// disabled view does not consume events
			return false;
		}
		if (!event.release) {
			// press and motion events are not consumed
			return false;
		}

		if (event.clicks < 0) {
			// long press, not released
			return this.onReset(this);
		}
		if (event.clicks > 1) {
			// multi click to reset
			if (this.onReset(this)) {
				// do not click with press and hold
				return true;
			}
		}
		return this.onClick(this);
	}

	bool onMeasure(View this, Rect rect&) {
		int width = Math.abs(this.width);
		if (rect.w < width || this.width > 0) {
			rect.w = width;
		}
		int height = Math.abs(this.height);
		if (rect.h < height || this.height > 0) {
			rect.h = height;
		}
		return true;
	}

	void onDraw(View this, Image offs, Rect rect, const Style style&) { }
	static void onDraw(View this, Image offs, Rect rect, int state) {
		Style style& = this.style;

		if (this.parent.style != this.style) {
			offs.fillRect(rect, style.backgroundColor);
		}
		if (state & Style.focused) {
			offs.fillRect(rect, style.focusedColor);
		}
		else if (state & Style.hovered) {
			offs.fillRect(rect, style.hoveredColor);
		}
		this.onDraw(this, offs, rect, style);
		if (state & Style.pressed) {
			offs.drawRect(rect, style.valueColor);
		}
	}
	static void onDraw(View this, Image offs, Rect rect, const Style style&, const char text[*], const char value[*]) {
		// fixme: draw text using textColor and value using valueColor
		if (text == null) {
			style.align(rect, &rect, value);
			offs.drawText(rect, style.font, value, style.valueColor);
			return;
		}

		Rect valueRoi = rect;
		style.align(valueRoi, &valueRoi, value, Style.right);
		rect.w -= valueRoi.w + style.padding;
		style.align(rect, &rect, text);
		offs.drawText(valueRoi, style.font, value, style.valueColor);
		offs.drawText(rect, style.font, text, style.textColor);
	}
}

static void invalidate(View view);
static void focus(View view);

/** Layout is a view containing other views positioned by it.
 * the Layout class does not clip its children.
 * the size of the Layout class should contain all the views.
 */
struct Layout: View {
	struct Item {
		Rect rect;
		View view;
		int align;
	}

	View divider = null;

	int itemCount = 0;
	int itemCapacity = 0;
	Item items[*] = null;

	int hoveredIndex = -1;
	int pressedIndex = -1;
	int focusedIndex = -1;

	int paddingTop = 0;
	int paddingLeft = 0;
	int paddingRight = 0;
	int paddingBottom = 0;

	/** Vertical, horizontal or other orientation of the layout
	 * zero represents a stack(Qt) or frame(Android) layout (all child elements are placed on top of each other)
	 * negative value represents a column layout, specifying the number of columns to be used
	 * positive value represents a row layout, specifying the number of rows to be used
	 */
	int orientation = 1;

	// TODO: use positive value for fixed size, negative values for minimum size
	// int colSpacing = 0;
	// int rowSpacing = 0;

	/// TODO: make width of each cell the same size
	// const bool uniformWidth = true;

	/// TODO: make height of each cell the same size
	// const bool uniformHeight = true;

	static bool clearState(Layout this, int mode) {
		bool result = false;
		if (mode & Style.hovered && this.hoveredIndex >= 0) {
			View view = this.items[this.hoveredIndex].view;
			if (Layout layout = view.as(Layout)) {
				clearState(layout, mode);
			}
			this.hoveredIndex = -1;
			result = true;
		}
		if (mode & Style.pressed && this.pressedIndex >= 0) {
			View view = this.items[this.pressedIndex].view;
			if (Layout layout = view.as(Layout)) {
				clearState(layout, mode);
			}
			this.pressedIndex = -1;
			result = true;
		}
		if (mode & Style.focused && this.focusedIndex >= 0) {
			View view = this.items[this.focusedIndex].view;
			if (Layout layout = view.as(Layout)) {
				clearState(layout, mode);
			}
			this.focusedIndex = -1;
			result = true;
		}
		return result;
	}

	static View getPressed(const Layout this) {
		if (this.pressedIndex < 0) {
			return null;
		}
		View selected = this.items[this.pressedIndex].view;
		if (Layout layout = selected.as(Layout)) {
			View view = getPressed(layout);
			if (view != null) {
				return view;
			}
		}
		return selected;
	}
	static View getFocused(const Layout this) {
		if (this.focusedIndex < 0) {
			return null;
		}
		View selected = this.items[this.focusedIndex].view;
		if (Layout layout = selected.as(Layout)) {
			View view = getFocused(layout);
			if (view != null) {
				return view;
			}
		}
		return selected;
	}
	static bool setFocused(Layout this, View focus) {
		if (focus == null) {
			this.clearState(Style.focused);
		}
		for (int i = 0; i < this.itemCount; i += 1) {
			const Item item& = this.items[i];
			const Rect rect& = item.rect;
			const View view = item.view;
			if (view == focus && this.focusedIndex != i) {
				this.clearState(Style.focused);
				this.focusedIndex = i;
				return true;
			}
			if (Layout layout = view.as(Layout)) {
				if (layout.setFocused(focus) && this.focusedIndex != i) {
					this.clearState(Style.focused);
					this.focusedIndex = i;
					return true;
				}
			}
		}
		return false;
	}

	static Layout capacity(Layout this, int capacity) {
		assert(capacity >= this.itemCount);
		if (capacity == this.itemCapacity) {
			// no need to change
			return;
		}

		Item items[*] = this.items;
		this.itemCapacity = capacity;
		this.items = pointer.alloc(null, this.itemCapacity * sizeof(Item));
		pointer.copy(this.items, items, this.itemCount * sizeof(Item));
		pointer.alloc(items, 0);
		return this;
	}

	static Layout addItems(Layout this, int align, View views...) {
		static View divider(Layout this) {
			if (this.divider != null) {
				return this.divider;
			}
			View divider = {
				enabled: false;
				focusable: false;
			};
			this.divider = divider;
			return divider;
		}

		int itemCount = this.itemCount + views.length;
		if (itemCount >= this.itemCapacity) {
			// double the capacity
			int capacity = 2 * this.itemCapacity;
			if (capacity < itemCount) {
				capacity = itemCount;
			}
			this.capacity(capacity);
		}

		for (int i = 0; i < views.length; i += 1) {
			Item item& = this.items[this.itemCount + i];
			item.view = views[i];
			item.align = align;
			if (item.view == null) {
				item.view = divider(this);
			}
		}
		this.itemCount = itemCount;
		return this;
	}

	static Layout padding(Layout this, int top, int left, int right, int bottom) {
		this.paddingTop = top;
		this.paddingLeft = left;
		this.paddingRight = right;
		this.paddingBottom = bottom;
		this.invalidate();
		return this;
	}

	bool onClick(Layout this) {
		error("onClick", this);
		return false;
	}

	bool onReset(Layout this) {
		bool result = false;
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i].view;
			if (view.onReset(view)) {
				result = true;
			}
		}
		return result;
	}

	void onCreate(Layout this, View parent) {
		assert(this.parent == null, "can not add the same layout multiple times");
		View.onCreate(this, parent);
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i].view;
			view.onCreate(view, this);
		}
	}

	void onDestroy(Layout this) {
		// destroy views and free up allocations
		for (int i = 0; i < this.itemCount; i += 1) {
			View view = this.items[i].view;
			view.onDestroy(view);
			view.destroy();
		}
		pointer.alloc(this.items, 0);
	}

	bool onKeyEvent(Layout this, const KeyEvent event&) {
		int idx = this.focusedIndex;
		if (idx < 0) {
			return false;
		}

		View view = this.items[idx].view;
		return view.onKeyEvent(view, event);
	}

	bool onTouchEvent(Layout this, const Rect rect&, const TouchEvent event&) {
		static int findView(Layout this, int x, int y) {
			for (int i = 0; i < this.itemCount; i += 1) {
				Item item& = this.items[i];
				if (item.view.enabled) {
					Rect rect& = item.rect;
					if (y >= rect.y && y < rect.y + rect.h) {
						if (x >= rect.x && x < rect.x + rect.w) {
							return i;
						}
					}
				}
			}
			return -1;
		}

		bool result = false;
		int active = this.pressedIndex;
		if (!(event.dx || event.dy || event.release) || !event.button) {
			active = findView(this, event.x, event.y);
		}

		if (active < 0) {
			// not an active view
			int states = Style.hovered;
			if (event.release) {
				states |= Style.pressed;
			}
			return this.clearState(states);
		}

		Item item& = this.items[active];
		View view = item.view;
		if (!view.enabled) {
			// not an enabled view
			int states = Style.hovered;
			if (event.release) {
				states |= Style.pressed;
			}
			return this.clearState(states);
		}

		if (this.pressedIndex != active && event.isPress(1)) {
			// pressed a different view, update pressed view
			this.clearState(Style.pressed);
			this.pressedIndex = active;
			result = true;
		}

		bool outside = !event.test(item.rect);
		if (this.hoveredIndex != active || outside) {
			// update current view as hovered
			if (this.clearState(Style.hovered)) {
				result = true;
			}
			if (!outside) {
				this.hoveredIndex = active;
				result = true;
			}
		}

		if (event.release && outside) {
			// return if released outside the pressed view
			return this.clearState(Style.pressed|Style.hovered);
		}

		if (view.onTouchEvent(view, item.rect, event)) {
			// event processed by the view
			result = true;
		}

		if (!event.release) {
			return result;
		}

		bool focusable = view.focusable;
		if (outside) {
			focusable = false;
		}
		else if (event.clicks < 0) {
			// do not focus on long press
			this.clearState(Style.hovered);
			focusable = false;
		}
		else if (this.focusedIndex == active) {
			// already in focus, do not focus
			focusable = false;
		}
		else if (Layout layout = view.as(Layout)) {
			if (layout.focusedIndex == -1) {
				// child is a layout, with no focused item
				focusable = false;
			}
		}

		if (focusable) {
			this.clearState(Style.focused);
			this.focusedIndex = active;
			result = true;
		}
		if (this.clearState(Style.pressed)) {
			return true;
		}
		return result;
	}

	bool onMeasure(Layout this, Rect measured&) {
		int dir = this.orientation;
		int N = Math.abs(dir);
		int n = 0;
		int maxWidth = 0;
		int sumWidth = 0;
		int maxHeight = 0;
		int sumHeight = 0;
		int rows = dir < 0 ? N : 1;
		int cols = dir > 0 ? N : 1;
		for (int i = 0; i < this.itemCount; i += 1) {
			Item item& = this.items[i];
			Rect rect& = item.rect;
			View view = item.view;
			rect.w = rect.h = 0;
			if (view.onMeasure(view, &rect)) {
				int width = rect.w;
				int height = rect.h;
				if (n >= N) {
					cols += int(dir < 0);
					rows += int(dir > 0);
					n = 0;
				}
				sumWidth += width;
				if (maxWidth < width) {
					maxWidth = width;
				}
				sumHeight += height;
				if (maxHeight < height) {
					maxHeight = height;
				}
				n += 1;
			}
		}
		if (rows == 1 && cols == 1) {
			sumWidth = maxWidth;
			sumHeight = maxHeight;
		}
		if (rows > 1) {
			// multi row layout, using uniform width
			sumWidth = maxWidth * cols;
		}
		if (cols > 1) {
			// multi column layout, using uniform height
			sumHeight = maxHeight * rows;
		}
		measured.w = sumWidth + this.paddingLeft + this.paddingRight;
		measured.h = sumHeight + this.paddingTop + this.paddingBottom;
		return View.onMeasure(this, &measured);
	}

	// TODO: make layout part of the measure step: to calculate the correct width and height,
	//       elements inside the layout must be placed to their position
	void onLayout(Layout this, Rect rect&);
	static void verticalLayout(Layout this, Rect measured&, int cols) {
		int rowSpacing = measured.w / cols;
		int colSpacing = 0;
		int grow = 0;

		if (true) {
			int maxSize = 0;
			int sumSize = 0;
			int rows = 0;
			int n = cols;
			for (int i = 0; i < this.itemCount; i += 1) {
				Rect rect& = this.items[i].rect;
				if (rect.w && rect.h) {
					if (n >= cols) {
						sumSize += maxSize;
						maxSize = 0;
						rows += 1;
						n = 0;
					}
					if (maxSize < rect.h) {
						maxSize = rect.h;
					}
					if (colSpacing < maxSize) {
						colSpacing = maxSize;
					}
					n += 1;
				}
			}
			sumSize += maxSize;
			if (rows > 0 && measured.h > sumSize) {
				grow = (measured.h - sumSize) / rows;
			}
		}

		Rect r = {
			x: measured.x;
			y: measured.y;
			w: this.width > 0 ? this.width : measured.w;
			h: this.height > 0 ? this.height : measured.h;
		};

		int n = cols;
		r.y -= colSpacing + grow;
		for (int i = 0; i < this.itemCount; i += 1) {
			Item item& = this.items[i];
			Rect rect& = item.rect;
			if (rect.w && rect.h) {
				if (n >= cols) {
					r.x = measured.x;
					r.y += colSpacing + grow;
					if (cols == 1) {
						// single row, allow non uniform heights
						colSpacing = rect.h;
					//} else {
						// using non uniform heights
						//colSpacing = maxHeight(this, i, cols);
					}
					n = 0;
				}

				r.w = rowSpacing;
				r.h = colSpacing + grow;
				View view = item.view;
				int align = item.align;
				if (view.width > 0 && Style.vertical(align)) {
					// fixed width, center instead of stretch
					align &= ~Style.vertical;
				}
				if (view.height > 0 && Style.horizontal(align)) {
					// fixed height, center instead of stretch
					align &= ~Style.horizontal;
				}

				Style.align(r, &rect, align);
				if (Layout layout = view.as(Layout)) {
					layout.onLayout(layout, &rect);
				}

				r.x += rowSpacing;
				n += 1;
			}
		}
	}
	static void horizontalLayout(Layout this, Rect measured&, int rows) {
		int colSpacing = measured.h / rows;
		int rowSpacing = 0;
		int grow = 0;

		if (true) {
			int maxSize = 0;
			int sumSize = 0;
			int cols = 0;
			int n = rows;
			for (int i = 0; i < this.itemCount; i += 1) {
				Rect rect& = this.items[i].rect;
				if (rect.w && rect.h) {
					if (n >= rows) {
						sumSize += maxSize;
						maxSize = 0;
						cols += 1;
						n = 0;
					}
					if (maxSize < rect.w) {
						maxSize = rect.w;
					}
					if (rowSpacing < rect.w) {
						rowSpacing = rect.w;
					}
					n += 1;
				}
			}
			sumSize += maxSize;
			if (cols > 0 && measured.w > sumSize) {
				grow = (measured.w - sumSize) / cols;
			}
		}

		Rect r = {
			x: measured.x;
			y: measured.y;
			w: this.width > 0 ? this.width : measured.w;
			h: this.height > 0 ? this.height : measured.h;
		};

		int n = rows;
		r.x -= rowSpacing + grow;
		for (int i = 0; i < this.itemCount; i += 1) {
			Item item& = this.items[i];
			Rect rect& = item.rect;
			if (rect.w && rect.h) {
				if (n >= rows) {
					r.y = measured.y;
					r.x += rowSpacing + grow;
					if (rows == 1) {
						// single column, allow non uniform widths
						rowSpacing = rect.w;
					//} else {
						// using non uniform widths
						//rowSpacing = maxWidth(this, i, rows);
					}
					n = 0;
				}

				r.w = rowSpacing + grow;
				r.h = colSpacing;
				View view = item.view;
				int align = item.align;
				if (view.width > 0 && Style.vertical(align)) {
					// fixed width, center instead of stretch
					align &= ~Style.vertical;
				}
				if (view.height > 0 && Style.horizontal(align)) {
					// fixed height, center instead of stretch
					align &= ~Style.horizontal;
				}

				Style.align(r, &rect, align);
				if (Layout layout = view.as(Layout)) {
					layout.onLayout(layout, &rect);
				}

				r.y += colSpacing;
				n += 1;
			}
		}
	}
	void onLayout(Layout this, Rect measured&) {
		inline padd(Rect rect&, int t, int l, int r, int b) = adjust(&rect, -l, -t, l + r, t + b);
		measured.padd(-this.paddingTop, -this.paddingLeft, -this.paddingRight, -this.paddingBottom);
		if (this.orientation > 0) {
			/* Multi column vertical layout, ex 3 cols:
			/--- col0 ---+--- col1 ---+--- col2 ---\
			|   item00   |   item01   |   item02   | row0
			|   item03   |   item04   |            | row1
			.    ...     |    ...     |    ...     . rowN
			\------------+------------+-----------*/
			verticalLayout(this, &measured, this.orientation);
			measured.padd(this.paddingTop, this.paddingLeft, this.paddingRight, this.paddingBottom);
			return;
			//return verticalLayout(this, &measured, this.orientation);
		}
		if (this.orientation < 0) {
			/* multi row horizontal layout, ex 2 rows:
			/--- col0 ---+--- col1 ---+--- col2 ---+--- colN ---\
			|   item00   |   item02   |   item04   |    ...     | row0
			|   item01   |   item03   |    ...     |    ...     | row1
			\------------+------------+------------+--- ... ---*/
			horizontalLayout(this, &measured, -this.orientation);
			measured.padd(this.paddingTop, this.paddingLeft, this.paddingRight, this.paddingBottom);
			return;
			//return horizontalLayout(this, &measured, -this.orientation);
		}

		Rect r = {
			x: measured.x;
			y: measured.y;
			w: this.width > 0 ? this.width : measured.w;
			h: this.height > 0 ? this.height : measured.h;
		};

		for (int i = 0; i < this.itemCount; i += 1) {
			const Item item& = this.items[i];
			const Rect rect& = item.rect;
			if (rect.w && rect.h) {
				const View view = item.view;
				Style.align(measured, &rect, item.align);
				if (Layout layout = view.as(Layout)) {
					layout.onLayout(layout, &rect);
				}
			}
		}
		measured.padd(this.paddingTop, this.paddingLeft, this.paddingRight, this.paddingBottom);
	}

	void onDraw(Layout this, Image offs, Rect parent, const Style style&) {
		for (int i = 0; i < this.itemCount; i += 1) {
			const Item item& = this.items[i];
			const Rect rect& = item.rect;
			if (rect.w > 0 && rect.h > 0) {
				const View view = item.view;
				int state = 0;
				if (view.as(Layout) == null) {
					if (i == this.hoveredIndex) {
						state |= Style.hovered;
					}
					if (i == this.pressedIndex) {
						state |= Style.pressed;
					}
					if (i == this.focusedIndex) {
						state |= Style.focused;
					}
					offs.debugLayoutDraw(rect, 0x00ff00);
				}
				view.onDraw(offs, rect, state);
			}
		}
		offs.debugLayoutDraw(parent, 0xff0000);
	}

	static Layout Custom(int rowsCols, int align, View items...) {
		Layout layout = {
			orientation: rowsCols;
		};
		if (items.length > 0) {
			layout.addItems(align, ...items);
		}
		return layout;
	}
	static Layout Row(View items...) {
		return Custom(-1, Style.fill, ...items);
	}
	static Layout Column(View items...) {
		return Custom(1, Style.fill, ...items);
	}
	static Layout Frame(View items...) {
		return Custom(0, Style.fill, ...items);
	}
	// FIXME: inline Row(View items...) = Custom(-1, Style.fill, items);
	// FIXME: inline Column(View items...) = Custom(1, Style.fill, items);
}

/** Widget is a special kind of layout, which can clip the content of its elements.
 * a widget may clip its children and apply scrolling to them, even show a scrollbar.
 */
struct Widget: Layout {
	Rect rect;	// fixme: move or remove
	Style widgetStyle;

	bool measure = true;
	View focus = null;

	int scrollX = 0;
	int scrollY = 0;

	// fixme: these are needed to draw the widget on an image, move them to a different class
	// the default method should be to draw it on the entire image
	int align = Style.fill;
	int margin = 0;
	int radius = 0;

	static bool focusNext(View view, bool prev) {
		if (view == null) {
			// probably a separator
			return false;
		}
		if (!view.enabled) {
			// can not focus a disabled view
			return false;
		}
		if (!view.focusable) {
			// can not focus a non focusable view
			return false;
		}

		Layout this = view.as(Layout);
		if (this == null) {
			// view is not a layout, and is focusable
			return true;
		}

		int n = this.focusedIndex;
		if (prev) {
			if (n < 0) {
				n = this.itemCount - 1;
			}
			for (int i = n; i >= 0; i -= 1) {
				const Item item& = this.items[i];
				const Rect rect& = item.rect;
				const View view = item.view;
				if (rect.w && rect.h && focusNext(view, prev)) {
					if (view.as(Layout) != null || i != this.focusedIndex) {
						this.focusedIndex = i;
						return true;
					}
				}
			}
		} else {
			if (n < 0) {
				n = 0;
			}
			for (int i = n; i < this.itemCount; i += 1) {
				const Item item& = this.items[i];
				const Rect rect& = item.rect;
				const View view = item.view;
				if (rect.w && rect.h && focusNext(view, prev)) {
					if (view.as(Layout) != null || i > this.focusedIndex) {
						this.focusedIndex = i;
						return true;
					}
				}
			}
		}

		this.clearState(Style.focused);
		return false;
	}

	static Widget addItems(Widget this, int align, View views...) {
		Layout.addItems(this, align, ...views);
		return this;
	}

	static Widget addItems(Widget this, View views...) {
		Layout.addItems(this, Style.fill, ...views);
		return this;
	}

	static Widget theme(Widget this, argb background, argb accent) {
		Style style& = this.style;
		style.setColor(background, accent);
		return this;
	}

	static Widget theme(Widget this, argb background) {
		return this.theme(background, Style.accent);
	}

	static Widget focus(Widget this, View value) {
		this.focus = value;
		return this;
	}

	static Widget padding(Widget this, int padding) {
		Layout.padding(this, padding, padding, padding, padding);
		return this;
	}
	static Layout padding(Widget this, int vertical, int horizontal) {
		Layout.padding(this, vertical, horizontal, horizontal, vertical);
		return this;
	}
	static Layout padding(Layout this, int top, int left, int right, int bottom) {
		Layout.padding(this, top, left, right, bottom);
		return this;
	}

	void onCreate(Widget this, View parent) {
		if (this.style == null) {
			this.style = this.widgetStyle;
		}
		Layout.onCreate(this, parent);
		this.measure = true;

		if (this.focus != null) {
			this.focus.focus();
			this.focus = null;
		}
	}

	bool onMeasure(Widget this, Rect measured&) {
		int margin = this.margin;
		int align = this.align;
		Rect rect = {
			x: margin;
			y: margin;
			w: measured.w - 2 * margin;
			h: measured.h - 2 * margin;
		};

		Layout.onMeasure(this, &measured);
		this.measure = false;

		measured.x = measured.y = 0;
		this.onLayout(this, &measured);
		Style.align(rect, &measured, align);
		return true;
	}

	void onDraw(Widget this, Image offs, Rect rect, const Style style&) {
		offs = offs.slice(rect);
		if (style.backgroundColor != -1) {
			Rect r = { w: offs.width(), h: offs.height() };
			offs.fillRect(r, this.radius, style.backgroundColor);
		}
		Layout.onDraw(this, offs, rect, style);
		offs.destroy();
	}

	bool onKeyEvent(Widget this, const KeyEvent event&) {
		if (Layout.onKeyEvent(this, event)) {
			return true;
		}

		if (event.release) {
			return false;
		}

		if (event.key == '\t' || event.key == '\r') {
			// Tab, Enter: select prev or next control.
			this.clearState(Style.hovered);
			if (!this.focusNext(event.isShift)) {
				return this.focusNext(event.isShift);
			}
			return true;
		}

		if (event.key == '[' || event.key == ']') {
			// hide, show controls
			if (event.key == '[') {
				if (this.align != Style.topLeft) {
					this.align = Style.topLeft;
				} else {
					this.enabled = !this.enabled;
					this.invalidate();
					return true;
				}
			}
			if (event.key == ']') {
				if (this.align != Style.topRight) {
					this.align = Style.topRight;
				} else {
					this.enabled = !this.enabled;
					this.invalidate();
					return true;
				}
			}

			this.enabled = true;
			this.measure = true;
			this.invalidate();
			return true;
		}

		if (event.key == 8 && event.isShift) {
			return this.onReset(this);
		}

		return false;
	}

	// TODO: remove: this override allows to forward the drag event to the focused view
	bool onTouchEvent(Widget this, const Rect rect&, const TouchEvent event&) {
		if (Layout.onTouchEvent(this, rect, event)) {
			return true;
		}

		if (!(event.button && (event.dx || event.dy))) {
			// event is not a drag event
			return false;
		}

		if (this.pressedIndex != -1) {
			// there is a pressed view, and is different than the focused one
			return false;
		}

		View view = getFocused(this);
		if (view == null) {
			// there is no focused view
			return false;
		}
		// forward the event to the view
		return view.onTouchEvent(view, rect, event);
	}
}

/** Window contains all the needed information to display a widget
 * todo: should be able to display a stack of widgets
 */
struct Window {
	const Image offscreen;
	Widget widget;

	// Touch state
	int clicks = 0;
	int64 time = 0;
	int64 timeout = 0;
	int32 button = 0;
	int32 mouseX = 0;
	int32 mouseY = 0;

	// Keyboard state
	bool isShift = false;
	bool isCtrl = false;
	bool isAlt = false;
	int key = 0;
	int repeat = 0;

	static bool hasFocused(const Window window&, View items...) {
		bool hasFocused(const Layout this, View items...) {
			if (this.focusedIndex < 0) {
				// nothing is focused.
				return false;
			}
			if (items.length == 0) {
				// something is focused
				return true;
			}

			View view = this.items[this.focusedIndex].view;
			for (int i = 0; i < items.length; i += 1) {
				if (items[i] == view) {
					return true;
				}
			}

			if (Layout layout = view.as(Layout)) {
				return hasFocused(layout, ...items);
			}
			return false;
		}
		return hasFocused(window.widget, ...items);
	}
	static bool hasPressed(const Window window&, View items...) {
		bool hasPressed(const Layout this, View items...) {
			if (this.pressedIndex < 0) {
				// nothing is pressed.
				return false;
			}
			if (items.length == 0) {
				// something is pressed
				return true;
			}

			View view = this.items[this.pressedIndex].view;
			for (int i = 0; i < items.length; i += 1) {
				if (items[i] == view) {
					return true;
				}
			}

			if (Layout layout = view.as(Layout)) {
				return hasPressed(layout, ...items);
			}
			return false;
		}
		return hasPressed(window.widget, ...items);
	}

	static bool dispatchEvent(Window window&, Widget widget, int action, int button, int x, int y) {
		if (widget.parent == null) {
			// widget was not created, so create it first
			widget.onCreate(widget, widget);
			widget.measure = true;
		}
		if (action == Gui.WINDOW_INIT) {
			return true;
		}
		if (action == Gui.WINDOW_CLOSE) {
			// TODO: implement reference counted gc
			widget.onDestroy(widget);
			widget.destroy();
			return false;
		}
		if (action == Gui.WINDOW_ENTER) {
			// do not process event
			return false;
		}
		if (action == Gui.WINDOW_LEAVE) {
			// clear hovered state
			return widget.clearState(Style.hovered);
		}

		if (action == Gui.FINGER_PRESS) {
			// finger press results also a mouse event
			// skip the finger event
			return false;
		}
		if (action == Gui.FINGER_MOTION) {
			// translate to mouse event
			action = Gui.MOUSE_MOTION;
		}
		if (action == Gui.FINGER_RELEASE) {
			// finger release results also a mouse event
			// skip the finger event
			return false;
		}

		if (action == Gui.MOUSE_PRESS) {
			if (window.button != button || window.mouseX != x || window.mouseY != y) {
				window.clicks = 0;
			}
			int64 now = System.millis();
			if ((now - window.time) / 1000. > .5) {
				window.clicks = 0;
			}
			window.time = now;
			if (button == 1) {
				window.timeout = now + 1000;
			} else {
				window.timeout = 0;
			}
			window.button = button;
			window.mouseX = x;
			window.mouseY = y;
			window.clicks += 1;

			if (button != 1) {
				return false;
			}

			TouchEvent event = {
				release: false;
				isShift: window.isShift;
				isCtrl: window.isCtrl;
				isAlt: window.isAlt;
				clicks: window.clicks;
				button: button;
				x: x - widget.rect.x;
				y: y - widget.rect.y;
			};
			return widget.onTouchEvent(widget, widget.rect, event);
		}
		if (action == Gui.MOUSE_MOTION) {
			int oldX = window.mouseX;
			int oldY = window.mouseY;
			window.time = System.millis();
			window.timeout = 0;
			window.button = button;
			window.mouseX = x;
			window.mouseY = y;
			window.clicks = 0;

			if (button != 0 && button != 1) {
				return false;
			}
			TouchEvent event = {
				release: false;
				isShift: window.isShift;
				isCtrl: window.isCtrl;
				isAlt: window.isAlt;
				clicks: window.clicks;
				button: button;
				dx: x - oldX;
				dy: y - oldY;
				x: x - widget.rect.x;
				y: y - widget.rect.y;
			};
			return widget.onTouchEvent(widget, widget.rect, event);
		}
		if (action == Gui.MOUSE_RELEASE) {
			int64 now = System.millis();
			if ((now - window.time) / 1000. > .5) {
				window.clicks = 0;
			}
			window.timeout = 0;
			if (button != 1) {
				return false;
			}

			TouchEvent event = {
				release: true;
				isShift: window.isShift;
				isCtrl: window.isCtrl;
				isAlt: window.isAlt;
				clicks: window.clicks;
				button: button;
				x: x - widget.rect.x;
				y: y - widget.rect.y;
			};
			return widget.onTouchEvent(widget, widget.rect, event);
		}

		if (action == Gui.KEY_PRESS) {
			window.isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
			window.isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
			window.isAlt = (y & Gui.KEY_MASK_ALT) != 0;
			if (window.key != button) {
				window.key = button;
				window.repeat = 0;
			} else {
				window.repeat += 1;
			}

			KeyEvent event = {
				release: false;
				isShift: window.isShift;
				isCtrl: window.isCtrl;
				isAlt: window.isAlt;
				repeat: window.repeat;
				key: button;
			};
			return widget.onKeyEvent(widget, event);
		}
		if (action == Gui.KEY_RELEASE) {
			window.isShift = (y & Gui.KEY_MASK_SHIFT) != 0;
			window.isCtrl = (y & Gui.KEY_MASK_CTRL) != 0;
			window.isAlt = (y & Gui.KEY_MASK_ALT) != 0;
			window.key = 0;
			KeyEvent event = {
				release: true;
				isShift: window.isShift;
				isCtrl: window.isCtrl;
				isAlt: window.isAlt;
				repeat: 0;
				key: button;
			};
			return widget.onKeyEvent(widget, event);
		}

		if (action == Gui.EVENT_TIMEOUT) {
			if (window.timeout > 0) {
				// long press
				TouchEvent event = {
					release: true;
					isShift: window.isShift;
					isCtrl: window.isCtrl;
					isAlt: window.isAlt;
					clicks: -1;
					button: window.button;
					x: window.mouseX - widget.rect.x;
					y: window.mouseY - widget.rect.y;
				};
				return widget.onTouchEvent(widget, widget.rect, event);
			}
		}

		debug("event not processed", action);
		return false;
	}
	static int draw(Window window&, Widget widget) {
		if (!widget.enabled) {
			// widget is disabled, do not show it
			return 0;
		}
		int64 timeout = 0;
		if (window.timeout > 0) {
			timeout = window.timeout - System.millis();
			if (timeout < 0) {
				timeout = 0;
			}
		}

		Image offs = window.offscreen;
		Rect rect& = widget.rect;
		if (widget.measure) {
			rect.w = offs.width();
			rect.h = offs.height();
			widget.onMeasure(widget, &rect);
			widget.measure = false;
		}

		widget.onDraw(offs, rect, 0);
		return timeout;
	}
}

Widget Widget(int width, int height, const Style style&) {
	Widget widget = {
		rect: {};
		width: width;
		height: height;
		align: Style.center;
		widgetStyle: {
			format: { padLen: 5, precision: 2 };
		};
		style: style;
		focus: widget;	// focus first visible view
	};
	return widget;
}
Widget Widget(int width, int height) {
	const Style style& = null;
	return Widget(width, height, style);
}
Widget Widget(View views...) {
	Widget widget = {
		rect: {};

		radius: 5;
		margin: 10;
		align: Style.topRight;

		paddingTop: 3;
		paddingLeft: 3;
		paddingRight: 3;
		paddingBottom: 3;
		widgetStyle: {
			align: Style.left;
			format: { padLen: 5, precision: 2 };
		};
		focus: widget;	// focus first visible view
	};
	widget.style = widget.widgetStyle;

	if (views.length > 0) {
		widget.addItems(...views);
	}
	return widget;
}

Widget getWidget(View view) {
	for (View v = view; v != null; v = v.parent) {
		if (Widget w = v.as(Widget)) {
			return w;
		}
		// todo: check for cycles (indirect)
		assert(v != v.parent);
	}
	return null;
}

void invalidate(View view) {
	Widget widget = getWidget(view);
	widget.measure = true;
}
void focus(View view) {
	static void clearFocus(Layout layout) {
		for (int i = 0; i < layout.itemCount; i += 1) {
			View view = layout.items[i].view;
			if (Layout child = view.as(Layout)) {
				clearFocus(child);
			}
		}
		layout.hoveredIndex = -1;
		layout.pressedIndex = -1;
		layout.focusedIndex = -1;
	}
	Widget widget = getWidget(view);

	Layout layout = view.as(Layout);
	if (layout == null) {
		// the view is a leaf node, focus it
		widget.clearFocus();
		widget.setFocused(view);
		return;
	}

	View focus = layout.getFocused();
	if (focus != null) {
		// the layout has a focused element, focus it
		widget.clearFocus();
		widget.setFocused(focus);
		return;
	}

	// focus the first element from the layout
	widget.onMeasure(widget, &widget.rect);
	widget.clearFocus();
	widget.setFocused(view);
	widget.focusNext(false);
	widget.measure = true;
}
bool isFocused(View view) {
	Widget widget = getWidget(view);
	return view == widget.getFocused();
}
bool isPressed(View view) {
	Widget widget = getWidget(view);
	return view == widget.getPressed();
}

struct Button: View {
	const char text[*];

	bool onMeasure(Button this, Rect rect&) {
		Style style& = this.style;
		style.measure(&rect, this.text);
		return View.onMeasure(this, &rect);
	}

	void onDraw(Button this, Image offs, Rect rect, const Style style&) {
		View.onDraw(this, offs, rect, style, null, this.text);
	}
}

struct Switch: View {
	static const char onOff[*][] = {
		"off",
		"on"
	};

	const char text[*];
	const char states[*][] = onOff;

	int selected = 0;
	const int resetValue = 0;//TODO: selected;

	// if the view is clicked but not focused, first just focus it
	const bool clickToFocus = false;

	static bool checked(Switch this) {
		return this.selected != 0;
	}

	bool onUpdate(Switch this, int selected) {
		int maxValue = this.states.length;
		if (maxValue == 0) {
			// graphical switch
			maxValue = 2;
		}
		if (selected >= maxValue) {
			selected = maxValue - 1;
		}
		else if (selected < 0) {
			selected = 0;
		}

		if (this.selected == selected) {
			return false;
		}

		this.selected = selected;
		return true;
	}

	bool onReset(Switch this) {
		return this.onUpdate(this, this.resetValue);
	}

	bool onClick(Switch this) {
		if (this.focusable && this.clickToFocus) {
			if (!this.isFocused()) {
				return true;
			}
		}
		int maxValue = this.states.length;
		int value = this.selected + 1;
		if (maxValue == 0) {
			// graphical switch
			maxValue = 2;
		}
		if (value >= maxValue) {
			value = 0;
		}
		return this.onUpdate(this, value);
	}

	void onCreate(Switch this, View parent) {
		View.onCreate(this, parent);
		// clamp initial value
		this.onUpdate(this, this.selected);
		int resetValue& = pointer(this.resetValue);
		resetValue = this.selected;
	}

	bool onKeyEvent(Switch this, const KeyEvent event&) {
		if (event.release) {
			return View.onKeyEvent(this, event);
		}
		if (event.key == '+' || event.key == '=') {
			int value = this.selected + 1;
			return this.onUpdate(this, value);
		}
		if (event.key == '-' || event.key == '_') {
			int value = this.selected - 1;
			return this.onUpdate(this, value);
		}
		return View.onKeyEvent(this, event);
	}

	bool onMeasure(Switch this, Rect rect&) {
		int maxWidth = 0;
		Style style& = this.style;
		for (int i = 0; i < this.states.length; i += 1) {
			Rect measured = {};
			style.measure(&measured, this.states[i]);
			if (maxWidth < measured.w) {
				maxWidth = measured.w;
			}
		}
		style.measure(&rect, this.text);
		if (this.states.length == 0) {
			rect.w += rect.h * 3 / 2;
		} else {
			rect.w += maxWidth;
		}
		return View.onMeasure(this, &rect);
	}

	void onDraw(Switch this, Image offs, Rect rect, const Style style&) {
		char value[*] = null;
		if (this.states.length == 0) {
			Rect onOffRect = {
				x: rect.x;
				y: rect.y;
				w: rect.h * 3 / 2;
				h: rect.h;
			};
			Style.align(rect, &onOffRect, Style.right);

			onOffRect.adjust(-style.padding);
			uint32 color = style.focusedColor;
			if (this.checked()) {
				color = style.valueColor;
			}
			else if (this.isFocused()) {
				color = style.hoveredColor;
			}
			offs.fillRect(onOffRect, onOffRect.h / 2, color);

			if (this.checked()) {
				onOffRect.x += rect.h / 2;
			}

			onOffRect.w = onOffRect.h;
			offs.fillOval(onOffRect, style.textColor);
			rect.w -= rect.h * 3 / 2;
		} else {
			value = this.states[this.selected];
		}
		View.onDraw(this, offs, rect, style, this.text, value);
	}
}

struct Slider: View {
	const char text[*];

	int value = 0;
	const int minimum = 0;
	const int maximum = -1u >> 1;
	const int divisor = 0;
	const int resetValue = 0; // TODO: resetValue = value;

	static float64 valueF64(Slider this) {
		double value = this.value;
		if (this.divisor != 0) {
			return value / this.divisor;
		}
		return value;
	}

	bool onUpdate(Slider this, int value) {
		if (value > this.maximum) {
			value = this.maximum;
		}
		if (value < this.minimum) {
			value = this.minimum;
		}
		if (this.value == value) {
			return false;
		}
		this.value = value;
		return true;
	}

	bool onReset(Slider this) {
		return this.onUpdate(this, this.resetValue);
	}

	void onCreate(Slider this, View parent) {
		View.onCreate(this, parent);
		this.onUpdate(this, this.value);// clamp initial value
		int resetValue& = pointer(this.resetValue);
		resetValue = this.value;
	}

	bool onKeyEvent(Slider this, const KeyEvent event&) {
		if (event.release) {
			return View.onKeyEvent(this, event);
		}
		if (event.key == ' ') {
			return this.onReset(this);
		}
		if (event.key == '+' || event.key == '=') {
			return this.onUpdate(this, this.value + (event.isShift ? 1 : 10));
		}
		if (event.key == '-' || event.key == '_') {
			return this.onUpdate(this, this.value - (event.isShift ? 1 : 10));
		}
		return View.onKeyEvent(this, event);
	}

	bool onTouchEvent(Slider this, const Rect rect&, const TouchEvent event&) {
		if (event.button == 0) {
			return false;
		}
		if (event.release && (event.clicks < 0 || event.clicks > 1)) {
			return this.onReset(this);
		}

		if (event.clicks < 1) {
			float64 value = event.dx;
			if (!event.isShift && value != 0) {
				value *= float64(this.maximum - this.minimum) / rect.w;
				if (value > -1 && value < 1) {
					value = value < 0 ? -1 : 1;
				}
			}
			value += this.value;
			if (value > this.maximum) {
				value = this.maximum;
			}
			if (value < this.minimum) {
				value = this.minimum;
			}
			return this.onUpdate(this, value);
		}
		if (event.release) {
			if (event.y < rect.y + rect.h - rect.h / 3) {
				// clicking the upper part to focus control
				return true;
			}
			float64 value = event.x - rect.x;
			value *= float64(this.maximum - this.minimum) / rect.w;
			return this.onUpdate(this, this.minimum + value);
		}
		return View.onTouchEvent(this, rect, event);
	}

	bool onMeasure(Slider this, Rect rect&) {
		char value[64] = {0};
		Style style& = this.style;
		if (this.divisor != 0) {
			value.append(0, this.valueF64(), style.format);
		} else {
			value.append(0, this.value, style.format);
		}
		Rect valueRect = {};
		style.measure(&valueRect, value);
		style.measure(&rect, this.text);
		rect.w += valueRect.w;
		return View.onMeasure(this, &rect);
	}

	void onDrawSlider(Slider this, Image offs, Rect rect, const Style style&) {
		if (this.maximum == this.minimum) {
			return;
		}
		const int y1 = rect.y + rect.h;
		const int y0 = y1 - style.padding / 4;
		const int x0 = rect.x;
		const int x1 = rect.x + rect.w;
		const int x = x0 + int64(this.value - this.minimum) * rect.w / (this.maximum - this.minimum);
		if (x > x0) {
			offs.fillRect(x0, y0, x, y1, style.valueColor);
		}
		if (x < x1) {
			offs.fillRect(x, y0, x1, y1, style.focusedColor);
		}
	}

	void onDraw(Slider this, Image offs, Rect rect, const Style style&) {
		char value[64] = {0};
		if (this.divisor != 0) {
			value.append(0, this.valueF64(), style.format);
		} else {
			value.append(0, this.value, style.format);
		}
		if (this.onDrawSlider != null) {
			this.onDrawSlider(this, offs, rect, style);
		}
		View.onDraw(this, offs, rect, style, this.text, value);
	}
}

struct Histogram: View {
	const bool lines = false;
	// histogram data is in alpha channel, display it with color rgb
	bool color = false;
	argb data[256] = null;   // FIXME: this should be not possible

	static void update(Histogram this, Image image) {
		uint32 data[*] = pointer(this.data);
		image.calcRgbHist(null, &data);
		this.color = false;
	}

	bool onUpdate(Histogram this, int idx, int value) {
		this.data[idx] = argb(idx, value, value, value);
		return true;
	}

	bool onReset(Histogram this) {
		bool result = false;
		for (int i = 0; i < 256; i += 1) {
			result |= Histogram.onUpdate(this, i, i);
		}
		return result;
	}

	void onCreate(Histogram this, View parent) {
		View.onCreate(this, parent);
		Histogram.onReset(this);
	}

	bool onTouchEvent(Histogram this, const Rect rect&, const TouchEvent event&) {
		if (event.release || !event.button) {
			return View.onTouchEvent(this, rect, event);
		}

		int px = Math.max(0, rect.w - 256) / 2;
		int x0 = event.x - rect.x - px;
		int x1 = x0 - event.dx;
		int y0 = event.y - rect.y;
		int y1 = y0 - event.dy;

		if (x0 > x1) {
			int x = x0;
			x0 = x1;
			x1 = x;
			int y = y0;
			y0 = y1;
			y1 = y;
		}
		int y = y0 << 16;
		int dy = y1 - y0;
		if (x1 != x0) {
			dy = (dy << 16) / (x1 - x0);
		}
		if (x0 < 0) {
			y -= x0 * dy;
			x0 = 0;
		}
		if (x1 > 256) {
			x1 = 256;
		}
		int h = rect.h;
		for (int x = x0; x < x1; x += 1) {
			int val = 255 * (h - (y >> 16)) / h;
			this.onUpdate(this, x, val);
			y += dy;
		}
		return true;
	}

	bool onMeasure(Histogram this, Rect rect&) {
		if (this.width < 0) {
			rect.w = 256;
		}
		if (this.height < 0) {
			rect.h = 128;
		}
		return View.onMeasure(this, &rect);
	}

	void onDraw(Histogram this, Image offs, const Rect rect, const Style style&) {
		enum {
			colB: 0x4371c6;
			colG: 0x72d874;
			colR: 0xfc6165;
			colL: 0xdadada;
		}
		int px = (rect.w - 256) / 2;
		if (this.lines) {
			int y = rect.y + rect.h;
			int pb = bch(this.data[0]) * rect.h / 256;
			int pg = gch(this.data[0]) * rect.h / 256;
			int pr = rch(this.data[0]) * rect.h / 256;
			int pl = ach(this.data[0]) * rect.h / 256;

			for (int i = 1; i < this.data.length; i += 1) {
				int x = rect.x + i + px;
				argb data = this.data[i];
				int bv = bch(data) * rect.h / 256;
				int gv = gch(data) * rect.h / 256;
				int rv = rch(data) * rect.h / 256;
				int lv = ach(data) * rect.h / 256;

				if (this.color) {
					offs.fillRect(x, y - pl, x + 1, y - lv + int(pl == lv), data.v);
				} else {
					offs.fillRect(x, y - pb, x + 1, y - bv + int(pb == bv), colB);
					offs.fillRect(x, y - pg, x + 1, y - gv + int(pg == gv), colG);
					offs.fillRect(x, y - pr, x + 1, y - rv + int(pr == rv), colR);
					offs.fillRect(x, y - pl, x + 1, y - lv + int(pl == lv), colL);
				}

				pb = bv;
				pg = gv;
				pr = rv;
				pl = lv;
			}
		}
		else if (this.color) {
			for (int i = 0; i < this.data.length; i += 1) {
				argb data = this.data[i];
				int x = rect.x + i + px;
				int y1 = rect.y + rect.h;
				int y0 = y1 - ach(data) * rect.h / 256;
				offs.fillRect(x, y0 - int(y1 == y0), x + 1, y1, uint32(data));
			}
		}
		else {
			for (int i = 0; i < this.data.length; i += 1) {
				int x = rect.x + i + px;
				argb data = this.data[i];
				int bv = bch(data) * rect.h / 256;
				int gv = gch(data) * rect.h / 256;
				int rv = rch(data) * rect.h / 256;
				int lv = ach(data) * rect.h / 256;
				for (int y = 0; y < rect.h; y += 1) {
					uint32 b = colB * uint32(y < bv);
					uint32 g = colG * uint32(y < gv);
					uint32 r = colR * uint32(y < rv);
					uint32 l = colL * uint32(y < lv);
					offs.set(x, rect.h - y + rect.y - 1, r | g | b | l);
				}
			}
		}
	}
}

/// debug view to count draws
struct DebugView: View {
	char text[64] = null;

	int64 started = 0;
	int64 maxDuration = 0;
	int64 durations[64] = null;

	int64 measures = 0;
	int64 draws = 0;

	static void startTimer(DebugView this) {
		this.started = System.millis();
		this.maxDuration = 0;
		// todo: don't copy, use a circular queue
		for (int i = this.durations.length - 1; i >= 1; i -= 1) {
			int64 duration = this.durations[i - 1];
			this.durations[i] = duration;
			if (this.maxDuration < duration) {
				this.maxDuration = duration;
			}
		}
		this.durations[0] = this.maxDuration;
	}

	static void update(DebugView this) {
		int pos = 0;
		if (this.measures > 0) {
			pos = this.text.append(pos, pos > 0 ? ", " : "");
			pos = this.text.append(pos, "measures: ");
			pos = this.text.append(pos, this.measures);
		}

		if (this.draws > 0) {
			pos = this.text.append(pos, pos > 0 ? ", " : "");
			pos = this.text.append(pos, "draws: ");
			pos = this.text.append(pos, this.draws);
		}

		if (this.durations[0] > 0 || pos == 0) {
			pos = this.text.append(pos, pos > 0 ? ", " : "");
			pos = this.text.append(pos, "time: ");
			pos = this.text.append(pos, this.durations[0]);
		}
	}

	bool onClick(DebugView this) {
		return this.onReset(this);
	}

	bool onReset(DebugView this) {
		if (this.measures > 0) {
			this.measures = 0;
		}
		if (this.draws > 0) {
			this.draws = 0;
		}
		for (int i = 0; i < this.durations.length; i += 1) {
			this.durations[i] = 0;
		}
		this.maxDuration = 0;
		this.started = 0;
		return true;
	}

	void onCreate(DebugView this, View parent) {
		View.onCreate(this, parent);
		onReset(this);
	}

	bool onMeasure(DebugView this, Rect rect&) {
		if (this.measures >= 0) {
			this.measures += 1;
		}
		this.update();
		Style style& = this.style;
		style.measure(&rect, this.text);
		return View.onMeasure(this, &rect);
	}

	void onDraw(DebugView this, Image offs, Rect rect, const Style style&) {
		if (this.started > 0) {
			int64 duration = System.millis() - this.started;
			this.durations[0] = duration;
			if (this.maxDuration < duration) {
				this.maxDuration = duration;
			}
			this.started = 0;
		}

		if (this.maxDuration > 0) {
			int y0 = rect.y + rect.h;
			float64 ys = rect.h / float64(this.maxDuration);
			float64 xs = rect.w / float64(this.durations.length);
			for (int i = 0; i < this.durations.length; i += 1) {
				int y1 = y0 - ys * this.durations[i];
				int x1 = rect.x + xs * (this.durations.length - i);
				offs.fillRect(x1 - xs, y0, x1, y1, style.focusedColor);
			}
		}

		if (this.draws >= 0) {
			this.draws += 1;
		}
		this.update();
		style.align(rect, &rect, this.text);
		offs.drawText(rect, style.font, this.text, style.textColor);
	}
}

struct Panel: Layout {
	bool visible;

	static bool visible(Panel this, bool value) {
		if (this.visible == value) {
			return false;
		}

		this.visible = value;
		this.invalidate();
		return true;
	}

	bool onMeasure(Panel this, Rect rect&) {
		if (!this.visible) {
			// view is hidden
			rect.w = rect.h = 0;
			return false;
		}
		return Layout.onMeasure(this, &rect);
	}
}

// todo this should be a TabPage and/or Accordion
// tab/expand item should be a custom 2 state button
// use a flag to enable multi selection for both TabPage or Accordion
// in case of TabPage the `select button` should be in the tab list
// in case of Accordion the `expand button` should be in the same list with the pages
struct TabPage: Layout {
	Layout tabs = null;
	Layout active = null;
	View separator = null;
	argb background = argb(0);

	void onCreate(TabPage this, View parent) {
		Layout.onCreate(this, parent);
		this.active = this.items[1].view;
		Style style&  = this.style;
		this.background = mix_s8(128, argb(style.backgroundColor), argb(style.hoveredColor));
	}

	static bool onMeasurePage(Layout layout, Rect rect&) {
		TabPage parent = layout.data.as(TabPage);
		if (parent != null && parent.active != layout) {
			// view is hidden
			rect.w = rect.h = 0;
			return false;
		}
		return Layout.onMeasure(layout, &rect);
	}

	static void onDrawPage(Layout panel, Image offs, Rect rect, const Style style&) {
		TabPage page = panel.data.as(TabPage);
		offs.fillRect(rect, page.background.v);
		Layout.onDraw(panel, offs, rect, style);
	}

	static void onDrawBar(Layout tabs, Image offs, Rect rect, const Style style&) {
		TabPage page = tabs.data.as(TabPage);
		offs.fillRect(rect, page.background.v);
		Layout.onDraw(tabs, offs, rect, style);
	}

	static void onDrawTab(Button tab, Image offs, Rect rect, const Style style&) {
		TabPage page = tab.parent.parent.as(TabPage);
		if (page.active == tab.data.as(Layout)) {
			offs.fillRect(rect, style.focusedColor);
			style.align(rect, &rect, tab.text);
			offs.drawText(rect, style.font, tab.text, style.textColor);
			return;
		}
		Button.onDraw(tab, offs, rect, style);
	}

	static bool onClickTab(Button button) {
		if (Layout page = button.data.as(Layout)) {
			if (TabPage tabs = page.data.as(Layout)) {
				if (tabs.active == page) {
					return false;
				}
				tabs.active = page;
				tabs.invalidate();
				page.focus();
			}
		}
		return true;
	}

	static TabPage addItems(TabPage this, const char text[*], int align, View views...) {
		inline padding = 1;
		if (this.tabs == null) {
			Layout tabs = {
				paddingTop: padding;
				paddingLeft: padding;
				paddingRight: padding;
				paddingBottom: padding;
				data: this;
				onDraw: onDrawBar;
				orientation: -this.orientation;
			};

			View separator = {
				enabled: false;
				width: padding;
				height: padding;
			};

			this.tabs = tabs;
			this.separator = separator;
			Layout.addItems(this, Style.center, tabs);
		}

		Layout page = {
			data: this;
			// fixme: orientation;
			onDraw: onDrawPage;
			onMeasure: onMeasurePage;
		};
		Button tab = {
			text: text;
			data: page;
			focusable: false;
			onDraw: onDrawTab;
			onClick: onClickTab;
		};
		if (this.tabs.itemCount > 0) {
			this.tabs.addItems(0, this.separator);
		}
		this.tabs.addItems(0, tab);
		page.addItems(align, ...views);
		Layout.addItems(this, Style.fill, page);
		return this;
	}
}

static struct Gui {
	static void showWindow(Image offscreen, int onEvent(Window window&, int action, int button, int x, int y), Widget widget) {
		Window window = {
			offscreen: offscreen;
			widget: widget;
		};
		Gui.showWindow(offscreen, window, onEvent);
	}

	static void showWindow(Image offscreen, Widget widget) {
		static int showWindowEvent(Window win&, int action, int button, int x, int y) {
			if (action == Gui.KEY_RELEASE && button == 27) {
				// exit when releasing escape key
				return -1;
			}
			Widget widget = win.widget;
			if (!win.dispatchEvent(widget, action, button, x, y)) {
				// event not processed, wait for the next one
				return 0;
			}
			return win.draw(widget);
		}
		return showWindow(offscreen, showWindowEvent, widget);
	}

	static void showWindow(Widget widget) {
		widget.onCreate(widget, widget);
		widget.onMeasure(widget, &widget.rect);
		widget.measure = true;
		Image offscreen = Image(widget.rect.w, widget.rect.h, 32);
		showWindow(offscreen, widget);
		offscreen.destroy();
	}
}

/* original design
struct View: object {...}	// garbage collected
struct Text: View {...}
struct Label: View {...}
struct Image: View {...}
struct Check: View {...}	// Switch?
struct Input: View {...}	// single line, multi line
struct Select: View {...}	// ComboBox
struct Slider: View {...}
struct Button: View {...}

struct Panel ~= Layout
struct List: View {...}
struct Grid: View {...}
struct Page: View {...}
struct Window: View {...}

Window window = {
	width: 100;
	height: 100;
	items: {
		Button {
			label: "button1";
			onClick: print("x");
		};
	};
};
window.show();
*/
