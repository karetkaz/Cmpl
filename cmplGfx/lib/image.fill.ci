/// Fill the surface with the given color using alpha and blend method
void fill(Image image, const Rect roi&, uint32 color, int32 alpha, argb blend(argb base, argb with)) {
	/* TODO: implement correctly; add native implementation
	static if (fastNativeCalls && typename(Image.copy) != null) {
		return Image.copy(image, x0, y0, src, roi, alpha, extra, pointer(blend));
	}*/
	Rect r = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : image.width();
		h: roi != null ? roi.h : image.height();
	};
	if (!image.clip(&r)) {
		// nothing to set
		return;
	}

	argb with = argb(color);
	for (int y = r.y; y < r.y + r.h; y += 1) {
		for (int x = r.x; x < r.x + r.w; x += 1) {
			argb col = argb(image.get(x, y));
			if (blend != null) {
				col = blend(col, with);
			}
			if (alpha < 256) {
				col = mix_s8(alpha, with, col);
			}
			image.set(x, y, col);
		}
	}
}

/// Fill the surface by evaluating the given function for each pixel
void eval(Image image, const Rect roi&, float32 aspect, float32 time, vec4f eval(vec4f in)) {
	Rect rect = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : image.width();
		h: roi != null ? roi.h : image.height();
	};

	if (!image.clip(&rect)) {
		return;
	}

	float32 w = image.width();
	float32 h = image.height();
	if (aspect == 0) {
		aspect = w / h;
	}
	h *= aspect;
	int x1 = rect.x + rect.w;
	int y1 = rect.y + rect.h;
	vec4f in = vec4f(0, 0, 0, time);
	for (int y = rect.y; y < y1; y += 1) {
		in.y = y / h;
		for (int x = rect.x; x < x1; x += 1) {
			in.x = x / w;
			image.set(x, y, argb(eval(in)));
		}
	}
}
