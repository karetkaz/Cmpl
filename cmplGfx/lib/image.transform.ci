/// Copy one image to another using a transformation matrix [scale, rotate, translate, shear, perspective, etc]
void transform(Image image, const Rect rect&, Image src, const Rect roi&, int32 interpolate, const mat4f mat&) {
	// https://www.w3.org/TR/css-transforms/
	// https://developer.mozilla.org/en-US/docs/Web/CSS/transform
	static if (fastNativeCalls && typename(Image.transform) != null) {
		return Image.transform(image, rect, src, roi, interpolate, pointer(mat.data));
	}

	assert(image.depth() == src.depth());
	assert(image.depth() == 32);

	Rect dRec = {
		x: rect != null ? rect.x : 0;
		y: rect != null ? rect.y : 0;
		w: rect != null ? rect.w : image.width();
		h: rect != null ? rect.h : image.height();
	};
	if (!image.clip(&dRec)) {
		// nothing to set
		return;
	}

	Rect sRec = {
		x: roi != null ? roi.x : 0;
		y: roi != null ? roi.y : 0;
		w: roi != null ? roi.w : src.width();
		h: roi != null ? roi.h : src.height();
	};
	if (!src.clip(&sRec)) {
		// nothing to get
		return;
	}

	if (mat == null) {
		mat4f scale = {
			x: vec4f(float32(sRec.w) / dRec.w, 0, 0, sRec.x);
			y: vec4f(0, float32(sRec.h) / dRec.h, 0, sRec.y);
			z: vec4f(0, 0, 1, 0);
			w: vec4f(0, 0, 0, 1);
		};
		return transform(image, rect, src, roi, interpolate, scale);
	}

	if (interpolate == 0) {
		vec4f p = vec4f(0, 0, 0, 1);
		for (int y = 0; y < dRec.h; y += 1) {
			int dy = dRec.y + y;
			p.y = sRec.y + y;
			for (int x = 0; x < dRec.w; x += 1) {
				int dx = dRec.x + x;
				p.x = sRec.x + x;
				vec4f t = mat.dp4(p);
				image.set(dx, dy, src.get(t.x, t.y));
			}
		}
		return;
	}

	float32 w = src.width();
	float32 h = src.height();
	vec4f p = vec4f(0, 0, 0, 1);
	for (int y = 0; y < dRec.h; y += 1) {
		int dy = dRec.y + y;
		p.y = sRec.y + y;
		for (int x = 0; x < dRec.w; x += 1) {
			int dx = dRec.x + x;
			p.x = sRec.x + x;
			vec4f t = mat.dph(p);
			image.set(dx, dy, argb(src.tex(t.x / w, t.y / h)));
		}
	}
}

/// Create an image by copying another one using a custom width and height
Image Image(Image image, int width, int height, int align, float64 maxScale) {
	// todo: merge with align from micro.ui.ci
	enum: int {
		center: 0;
		left: 1;
		right: 2;
		top: 4;
		bottom: 8;
		fitVertical: left + right;
		fitHorizontal: top + bottom;
		fill: 0x10;
		highRes: 0x20;
	}

	int alignVertical = align & fitVertical;
	int alignHorizontal = align & fitHorizontal;
	bool fitWidth = alignVertical == fitVertical;
	bool fitHeight = alignHorizontal == fitHorizontal;

	float64 scale = 1;
	if (fitWidth && fitHeight) {
		float64 widthScale = width / float64(image.width());
		float64 heightScale = height / float64(image.height());
		if (align & fill) {
			scale = Math.max(widthScale, heightScale);
		} else {
			scale = Math.min(widthScale, heightScale);
		}
	}
	else if (fitWidth) {
		scale = width / float64(image.width());
	}
	else if (fitHeight) {
		scale = height / float64(image.height());
	}
	if (scale > maxScale) {
		scale = maxScale;
	}

	// calculate translation
	float64 tx = 0;
	if (fitWidth || alignVertical == center) {
		tx = (width - image.width() * scale) / 2;
	}
	else if (alignVertical == right) {
		tx = (width - image.width() * scale);
	}

	float64 ty = 0;
	if (fitHeight || alignHorizontal == center) {
		ty = (height - image.height() * scale) / 2;
	}
	else if (alignHorizontal == bottom) {
		ty = (height - image.height() * scale);
	}

	mat4f mat = {
		x: {x: 1 / scale, y: 0, z: 0, w: -tx / scale};
		y: {x: 0, y: 1 / scale, z: 0, w: -ty / scale};
		z: {x: 0, y: 0, z: 1 / scale, w: 0};
		w: {x: 0, y: 0, z: 0, w: 1};
	};

	Image result = Image(width, height, image.depth());
	result.transform(null, image, null, align & highRes ? 1 : 0, mat);
	return result;
}

/// Create an image by opening an image file with custom width and height
Image Image(const char fileName[*], int width, int height, int depth, int align, float64 maxScale) {
	Image image = Image(fileName, depth);
	Image result = Image(image, width, height, align, maxScale);
	image.destroy();
	return result;
}

/// Create an image by opening an image file with custom width and height
inline Image(const char fileName[*], int width, int height, int depth, int align) = Image(fileName, width, height, depth, align, Math.inf);

/// Create an image by opening an image file with custom width and height
inline Image(const char fileName[*], int width, int height, int depth) = Image(fileName, width, height, depth, -1, Math.inf);
