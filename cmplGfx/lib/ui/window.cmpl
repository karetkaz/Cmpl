///@public
static struct Window {
	enum { timeoutMax: (1 << 31) - 1 }

	/// calculate the timeout based on the given fps
	inline timeoutFps(float64 fps) = int64(1000 / fps);

/// Show the given `image` in a window and delegate the events to the `onEvent` callback
void show(Image image, int onEvent(int action, int button, int ex, int ey)) {
	if (onEvent == null) {
		return Window.show(image, null, null);
	}
	static int delegate(int onEvent(int action, int button, int ex, int ey), int action, int button, int ex, int ey) {
		return onEvent(action, button, ex, ey);
	}
	Window.show(image, onEvent, pointer(delegate));
}

/// Show the images in a window clicking on the window will select one of them
void show(int width, int height, Image image0, Image image1, Image image2) {
	struct Data {
		Image offs;
		Image image0;
		Image image1;
		Image image2;
	}

	static int onEvent(pointer extraData, int action, int button, int ex, int ey) {
		Data data& = extraData;
		if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
			// exit when releasing escape key
			return Window.quit();
		}
		if (action == Window.MOUSE_PRESS || action == Window.MOUSE_RELEASE) {
			Image show = data.image0;
			if (action == Window.MOUSE_RELEASE) {
				show = data.image0;
			}
			else if (button == 1) {
				show = data.image1;
			}
			else {
				show = data.image2;
			}
			if (data.offs.width() != show.width() || data.offs.height() != show.height()) {
				data.offs.resize(null, show, null, 1);
			} else {
				data.offs.copy(0, 0, show, null);
			}
		}
		return Window.timeoutMax;
	}

	Image offs = Image(width, height, image0.depth());
	Data data = {
		offs: offs;
		image0: image0;
		image1: image1;
		image2: image2;
	};
	onEvent(data, Window.MOUSE_RELEASE, 0, 0, 0);
	Window.show(offs, data, onEvent);
	offs.destroy();
}

/// Show the images in a window clicking on the window will select one of them
void show(Image image0, Image image1, Image image2) {
	int width = image0.width();
	int height = image0.height();
	return show(width, height, image0, image1, image1);
}

/// Show the images in a window clicking on the window will select one of them
void show(Image image0, Image image1) {
	return show(image0, image1, image1);
}

/// Show the image in a window
void show(Image image) {
	Window.show(image, image, image);
}

/// Show or animate the the procedural image generated by the `eval` function
void show(int32 width, int32 height, int32 animationDownScale, vec4f eval(vec4f in)) {
	static int64 start! = System.millis();
	struct Data {
		vec4f eval(vec4f in);
		Image offs;
		int32 downScale;
		float32 aspect;
		bool animate;
		int32 smooth = 1;
		int32 fpsCount = 0;	// frames drawn
		float32 fpsTime = 0;	// frame per sec shot time
	}

	static int onEvent(pointer extraData, int action, int button, int ex, int ey) {
		if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
			// exit when releasing escape key
			return Window.quit();
		}
		if (action == Window.WINDOW_CLOSE) {
			return Window.quit();
		}

		Data data& = extraData;
		if (action == Window.KEY_RELEASE) {
			if (button == ' ') {
				if (data.animate || data.downScale > 0) {
					data.animate = !data.animate;
				}
				action = Window.WINDOW_INIT;
			}
			else if (button == Window.KEY_CODE_TAB) {
				data.smooth = 1 - data.smooth;
			}
			else if (button == 'S') {
				trace("dumping screen");
				data.offs.saveBmp("out/offs.bmp", 0);
			}
		}
		if (action == Window.WINDOW_INIT && !data.animate) {
			char text[256] = {...};
			int64 now = System.millis();
			float32 time = (now - start) / 1000f;
			data.offs.eval(null, data.aspect, time, data.eval);
			(System.millis() - now).format(text, "Render time: %d ms");
			Window.setTitle(text);
			return Window.timeoutMax;
		}

		if (!data.animate) {
			return Window.timeoutMax;
		}

		float32 time = (System.millis() - start) / 1000f;
		if (data.downScale > 1) {
			Rect r = {
				x1: data.offs.width();
				y1: data.offs.height();
				x0: r.x1 - r.x1 / data.downScale;
				y0: r.y1 - r.y1 / data.downScale;
			};
			data.offs.eval(r, data.aspect, time, data.eval);
			data.offs.resize(null, data.offs, r, data.smooth);
		} else {
			data.offs.eval(null, data.aspect, time, data.eval);
		}
		if (time > data.fpsTime) {
			char text[256] = {...};
			data.fpsCount.format(text, "Fps: %d");
			Window.setTitle(text);
			data.fpsTime = time + 1;
			data.fpsCount = 0;
		}
		data.fpsCount += 1;

		// do not block for any input
		return 0;
	}

	Data data = {
		eval: eval;
		offs: Image(width, height, 32);
		animate: animationDownScale > 0;
		downScale: animationDownScale;
		aspect: width / float32(height);
	};
	Window.show(data.offs, data, onEvent);
	data.offs.destroy();
}

/// Show the the procedural image generated by the `eval` function
void show(int width, int height, vec4f eval(vec4f in)) {
	return show(width, height, 0, eval);
}

/// Show the mesh in a window
void show(int w, int h, float32 fovy, Mesh mesh) {
	struct Data {
		int32 fpsCount = 0;	// frames drawn
		int32 fpsShow = 0;	// frames drawn
		int64 fpsTime = 0;	// frame per sec shot time
		int mode;
		Image offs;
		mat4f proj;
		Camera cam;
		Mesh mesh;

		static void updateCamera(Data this!) {
			Camera camera& = this.cam;
			Mesh.camera(this.proj.data, camera.position.data, camera.forward.data, camera.right.data, camera.up.data);
		}
	}

	int nextInc(int32 x, int mask) {
		int next = x & mask;

		// add lowest bit of mask
		next += mask & -mask;

		// avoid overflow
		next &= mask;

		return next | (x & ~mask);
	}
	int nextBit(int32 x, int mask) {
		int next = x & mask;

		if (next == 0) {
			next = mask & -mask;
		} else {
			// add lowest bit of mask
			next = (next + next) & mask;
		}

		return next | (x & ~mask);
	}

	static int onEvent(pointer extraData, int action, int button, int ex, int ey) {
		Data data& = extraData;
		static int ox = 0;
		static int oy = 0;
		static float32 slow! = 1 / 100f;
		static float32 fast! = 5 / 100f;

		if (action == Window.MOUSE_MOTION || action == Window.FINGER_MOTION) {
			Camera camera& = data.cam;
			int dx = ex - ox;
			int dy = ey - oy;

			if (button == 1 || action == Window.FINGER_MOTION) {
				// orbit around the origin: (x: 0, y: 0, z: 0)
				vec4f orbit = vec4f(0, 0, 0);
				camera.rotate(orbit, camera.up, dx * slow);
				camera.rotate(orbit, camera.right, dy * slow);
				data.updateCamera();
			}
			else if (button == 2) {
				// rotate
				vec4f orbit = camera.position;
				camera.rotate(orbit, camera.up, -dx * slow);
				camera.rotate(orbit, camera.right, -dy * slow);
				data.updateCamera();
			}
			else if (button == 3) {
				// move the camera back and forward
				camera.move(camera.forward, dy * slow);
				data.updateCamera();
			}
			else if (button == 4) {
				// pan the camera
				camera.move(camera.right, -dx * slow);
				camera.move(camera.up, dy * slow);
				data.updateCamera();
			}
			ox = ex;
			oy = ey;
		}
		else if (action == Window.MOUSE_PRESS || action == Window.FINGER_PRESS) {
			ox = ex;
			oy = ey;
			return Window.timeoutMax;
		}
		else if (action == Window.GESTURE_SCROLL) {
			Camera camera& = data.cam;
			camera.move(camera.forward, ey * fast);
			data.updateCamera();
		}

		else if (action == Window.KEY_RELEASE && button == Window.KEY_CODE_ESC) {
			// exit when releasing escape key
			return Window.quit();
		}
		else if (action == Window.KEY_PRESS) {
			if (button == Window.KEY_CODE_ENTER) {
				return onEvent(&data, Window.WINDOW_INIT, button, ex, ey);
			}

			else if (button == 'w') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.forward, +(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 's') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.forward, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 'a') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.right, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == 'd') {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.move(camera.right, +(shift ? fast : slow));
				data.updateCamera();
			}

			else if (button == Window.KEY_CODE_UP) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.right, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Window.KEY_CODE_DOWN) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.right, +(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Window.KEY_CODE_LEFT) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.up, -(shift ? fast : slow));
				data.updateCamera();
			}
			else if (button == Window.KEY_CODE_RIGHT) {
				Camera camera& = data.cam;
				bool shift = bool(ey & Window.KEY_MASK_SHIFT);
				camera.rotate(camera.position, camera.up, +(shift ? fast : slow));
				data.updateCamera();
			}

			else if (button == 'l') {
				data.mode ^= Mesh.useLights;
			}
			else if (button == 'b') {
				data.mode ^= Mesh.drawBounds;
			}
			else if (button >= '0' && button <= '3') {
				int light = button - '0';
				Mesh.lights.enable(light, !Mesh.lights.enabled(light));
			}
			else if (button == 't') {
				data.mode ^= Mesh.useTexture;
			}
			else if (button == '/') {
				data.mode = nextInc(data.mode, Mesh.cullMode);
			}
			else if (button == Window.KEY_CODE_TAB) {
				data.mode = nextBit(data.mode, Mesh.drawMode);
			}
		}

		else if (action == Window.WINDOW_INIT) {
			Mesh.lights.enable(0, true);
			Mesh.lights.position(0, 2., -2., 2.);
			Mesh.lights.ambient(0, .4, .4, .4);
			Mesh.lights.diffuse(0, .8, .8, .8);
			Mesh.lights.specular(0, 1., 1., 1.);
			Mesh.lights.attenuation(0, 1., 0., 0.);

			Mesh.lights.enable(1, false);
			Mesh.lights.position(1, 2., -2., 2.);
			Mesh.lights.ambient(1, .4, .0, .0);
			Mesh.lights.diffuse(1, .8, .0, .0);
			Mesh.lights.specular(1, 1., 1., 1.);
			Mesh.lights.attenuation(1, 1., 0., 0.);

			Mesh.lights.enable(2, false);
			Mesh.lights.position(2, -2, -2, +2);
			Mesh.lights.ambient(2, .0, .4, .0);
			Mesh.lights.diffuse(2, .0, .8, .0);
			Mesh.lights.specular(2, 1., 1., 1.);
			Mesh.lights.attenuation(2, 1., 0., 0.);

			Mesh.lights.enable(3, false);
			Mesh.lights.position(3, -2, +2, +2);
			Mesh.lights.ambient(3, .0, .0, .4);
			Mesh.lights.diffuse(3, .0, .0, .8);
			Mesh.lights.specular(3, 1., 1., 1.);
			Mesh.lights.attenuation(3, 1., 0., 0.);

			Camera camera& = data.cam;
			vec4f eye = {x: 0, y: 0, z: 2, w: 1};
			vec4f at = {x: 0, y: 0, z: 0, w: 1};
			vec4f up = {x: 0, y: 1, z: 0, w: 1};
			data.cam = Camera.lookAt(eye, at, up);
			data.updateCamera();
		}

		int rendered = data.offs.drawMesh(data.mesh, data.mode);

		char text[256] = {...};
		int pos = 0;
		pos = data.mesh.vertices.format(text, pos, "Vertices: %d");
		pos = data.mesh.triangles.format(text, pos, ", Triangles: %d");
		pos = int64(rendered).format(text, pos, " / %d");
		pos = int64(data.fpsShow).format(text, pos, ", Fps: %d");
		Window.setTitle(text);

		int64 time = System.millis();
		if (time > data.fpsTime) {
			data.fpsTime = time + 1000;
			data.fpsShow = data.fpsCount;
			data.fpsCount = 0;
		}
		data.fpsCount += 1;
		return Window.timeoutMax;
	}

	Data data = {
		mode: Mesh.useLights | Mesh.cullBack | Mesh.drawFill;
		offs: Image.create3d(w, h);
		proj: Camera.projection(fovy, w / float32(h), 1, 100);
		cam: {};
		mesh: mesh;
	};
	Window.show(data.offs, data, onEvent);
	data.offs.destroy();
}
}
