/// an 32 bit argb color
struct argb: 0 {
	// value of color
	uint32 v;
	struct: 1 {
		/// blue component
		uint8 b;
	
		/// green component
		uint8 g;
	
		/// red component
		uint8 r;
	
		/// alpha component
		uint8 a;
	}
}

/// cast unsigned integer to argb value
inline argb(uint32 argb) = argb(emit(uint32(argb)));
/// cast argb value to unsigned integer
inline uint32(argb value) = uint32(emit(struct(value)));


// clamp signed gray or color component to fit in 8 bits (0 ... 255)
uint32 grayClamp(int32 c) {
	if (c < 0) {
		return 0;
	}
	if (c > 255) {
		return 255;
	}
	return c;
}
// clamp unsigned gray or color component to fit in 8 bits (0 ... 255)
uint32 grayClamp(uint32 c) {
	if (c > 255) {
		return 255;
	}
	return c;
}


// construct a rgb8 gray color from the given value
inline _gray(uint32 c) = argb((((c << 8) | c) << 8) | c);
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(int32 c) = _gray(grayClamp(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(uint32 c) = _gray(grayClamp(c));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float32 c) = gray(int32(c * 255));
/// construct a rgb8 color from the given gray value, clamp the input
inline gray(float64 c) = gray(int32(c * 255));


/// construct an argb color from the given components
inline _argb(uint32 r, uint32 g, uint32 b) = argb(uint32((((r << 8) | g) << 8) | b));
/// construct an argb color from the given components
inline _argb(uint32 a, uint32 r, uint32 g, uint32 b) = argb(uint32((((((a << 8) | r) << 8) | g) << 8) | b));

/// construct a rgb8 color from the given components, clamp the input
inline argb(int32 r, int32 g, int32 b) = _argb(grayClamp(r), grayClamp(g), grayClamp(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(uint32 r, uint32 g, uint32 b) = _argb(grayClamp(r), grayClamp(g), grayClamp(b));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float32 r, float32 g, float32 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));
/// construct a rgb8 color from the given components, clamp the input
inline argb(float64 r, float64 g, float64 b) = argb(int32(r * 255), int32(g * 255), int32(b * 255));


/// get the Alpha channel of the color
inline ach(argb col) = uint32((uint32(col) >> 24) & 0xff);
/// get the Red channel of the color
inline rch(argb col) = uint32((uint32(col) >> 16) & 0xff);
/// get the Green channel of the color
inline gch(argb col) = uint32((uint32(col) >> 8) & 0xff);
/// get the Blue channel of the color
inline bch(argb col) = uint32(uint32(col) & 0xff);
/// get the luminosity of the color
inline lum(argb c) = uint32((rch(c) * 76 + gch(c) * 150 + bch(c) * 29) >> 8);

/// linear interpolation between `c1` and `c2` by `t`, where t is a 16 bit fixed point
argb rgbLerp16(argb c1, argb c2, uint32 t) {
	inline lrpfix16(uint32 x, uint32 y) = uint32(x + (t * (y - x) >> 16));

	uint32 r = lrpfix16(rch(c1), rch(c2));
	uint32 g = lrpfix16(gch(c1), gch(c2));
	uint32 b = lrpfix16(bch(c1), bch(c2));
	return argb(r, g, b);
}

/// linear interpolation between `c1` and `c2` by `t`, where t is between 0. and 1.
inline rgbLerp(argb c1, argb c2, double t) = rgbLerp16(c1, c2, uint32(t * (1 << 16)));

static if (typename(vec4f) != null) {

/// convert a floating point vector to rgb
inline argb(const vec4f vec&) = argb(vec.x, vec.y, vec.z);

/// calculate the luminosity of a color
inline lum(const vec4f vec&) = 0.299f * vec.x + 0.587f * vec.y + 0.114f * vec.z;

/// convert from hsv color space to rgb color space
vec4f hsv2rgb(vec4f hsv) {
	float32 h = hsv.x;
	float32 s = hsv.y;
	float32 v = hsv.z;

	if (s == 0) {
		return vec4f(v);
	}

	h *= 360 / 60;

	int i = int(h);		// round
	float32 f = h - i;	// fraction

	float32 u = v;
	float32 p = v * (1 - s);
	float32 q = v * (1 - s * f);
	float32 t = v * (1 - s * (1 - f));

	if (i == 0) {
		return vec4f(u, t, p);
	}
	if (i == 1) {
		return vec4f(q, u, p);
	}
	if (i == 2) {
		return vec4f(p, u, t);
	}
	if (i == 3) {
		return vec4f(p, q, u);
	}
	if (i == 4) {
		return vec4f(t, p, u);
	}
	return vec4f(u, p, q);
}
}

/// calculate and draw the histogram of the image
void drawHist(gxSurf image, gxRect roi&, uint32 hist) {
	uint32 lut[256];
	image.calcHist(roi, hist, lut);

	enum {
		margin: 20;
		padding: 7;
		colB: 0x4371c6;
		colG: 0x72d874;
		colR: 0xfc6165;
		colL: 0xdadada;
	}

	gxRect rect = {
		w: 256;
		h: 128;
		y: margin;
		x: image.width() - rect.w - margin;
	};

	image.fillRect(
		rect.x - padding,
		rect.y - padding,
		rect.x + rect.w + padding,
		rect.y + rect.h + padding,
		0
	);

	for (int x = 0; x < rect.w; x += 1) {
		int bv = bch(argb(lut[x])) * rect.h / 256;
		int gv = gch(argb(lut[x])) * rect.h / 256;
		int rv = rch(argb(lut[x])) * rect.h / 256;
		int lv = ach(argb(lut[x])) * rect.h / 256;

		for (int y = 0; y < rect.h; y += 1) {
			uint32 b = colB * uint32(y < bv);
			uint32 g = colG * uint32(y < gv);
			uint32 r = colR * uint32(y < rv);
			uint32 l = colL * uint32(y < lv);
			image.set(x + rect.x, rect.h - y + rect.y - 1, r | g | b | l);
		}
	}
}
