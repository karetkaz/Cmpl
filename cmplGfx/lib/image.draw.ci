/// Fill a rectangle on the `image` specified by the coordinates with the given `color`
void fillRect(Image image, int x0, int y0, int x1, int y1, int incl, uint32 color) {
	static if (fastNativeCalls && typename(Image.fillRect) != null) {
		return Image.fillRect(image, x0, y0, x1, y1, incl, color);
	}

	if (x0 > x1) {
		int t = x0;
		x0 = x1;
		x1 = t;
	}
	if (y0 > y1) {
		int t = y0;
		y0 = y1;
		y1 = t;
	}
	x1 += incl;
	y1 += incl;

	for (int y = y0; y < y1; y += 1) {
		for (int x = x0; x < x1; x += 1) {
			image.set(x, y, color);
		}
	}
}

/// Fill a rectangle on the `image` specified by the coordinates with the given `color`
inline fillRect(Image image, int x0, int y0, int x1, int y1, uint32 color) = image.fillRect(x0, y0, x1, y1, 0, color);

/// Draw a rectangle on the `image` specified by the coordinates with the given `color`
void drawRect(Image image, int x0, int y0, int x1, int y1, uint32 color) {
	if (y0 > y1) {
		int t = y1;
		y1 = y0;
		y0 = t;
	}
	if (x0 > x1) {
		int t = x1;
		x1 = x0;
		x0 = t;
	}

	if (x1 - x0 < 3 || y1 - y0 < 3) {
		// no gap between top and bottom or left and right; draw all at once
		return image.fillRect(x0, y0, x1, y1, color);
	}

	image.fillRect(x0, y0, x1, y0 + 1, color);			// top
	image.fillRect(x0, y0 + 1, x0 + 1, y1 - 1, color);	// left
	image.fillRect(x1 - 1, y0 + 1, x1, y1 - 1, color);	// right
	image.fillRect(x0, y1 - 1, x1, y1, color);			// bottom
}

/// Fill a rounded rectangle on `image` specified by the coordinates and rounding, with the given `color`
void fillRRect(Image image, int x0, int y0, int x1, int y1, int rx, int ry, uint32 color) {
	if (x0 > x1) {
		int t = x0;
		x0 = x1;
		x1 = t;
	}
	if (y0 > y1) {
		int t = y0;
		y0 = y1;
		y1 = t;
	}
	x1 -= int(x1 > x0);
	y1 -= int(y1 > y0);

	int dx = x1 - x0;
	int dy = y1 - y0;
	if (dx < 3 || dy < 3) {
		// no rounding is needed
		return image.fillRect(x0, y0, x1, y1, 1, color);
	}

	ry = Math.min(ry, (dy - int(dx > 16)) / 2);
	rx = Math.min(rx, (dx - int(dy > 16)) / 2);
	if (rx < 8 || ry < 8) {
		if (rx < 1 || ry < 1) {
			// no rounding is needed
			return image.fillRect(x0, y0, x1, y1, 1, color);
		}
		// apply some visual fixes
		rx += int(rx == 7) - int(rx == 6);
		ry += int(ry == 7) - int(ry == 6);
	}

	int64 sx = rx * rx;
	int64 sy = ry * ry;
	int64 rdy = sx * ry;
	int64 rdx = 0;
	int64 r = rdy / 2;

	x0 += rx;
	x1 -= rx;
	for (;y0 < y1;) {
		image.fillRect(x0, y0, x1, y0, 1, color);
		image.fillRect(x0, y1, x1, y1, 1, color);
		if (r >= 0) {
			x0 -= 1;
			x1 += 1;
			r -= rdx += sy;
		}
		if (r < 0) {
			y0 += 1;
			y1 -= 1;
			r += rdy -= sx;
		}
	}
	image.fillRect(x0, y0, x1, y1, 1, color);
}

/// Draw a rounded rectangle on `image` specified by the coordinates and rounding, with the given `color`
void drawRRect(Image image, int x0, int y0, int x1, int y1, int rx, int ry, uint32 color) {
	if (x0 > x1) {
		int t = x0;
		x0 = x1;
		x1 = t;
	}
	if (y0 > y1) {
		int t = y0;
		y0 = y1;
		y1 = t;
	}
	x1 -= int(x1 > x0);
	y1 -= int(y1 > y0);

	int dx = x1 - x0;
	int dy = y1 - y0;
	if (dx < 2 || dy < 2) {
		// no gap between top and bottom or left and right; draw all at once
		return image.fillRect(x0, y0, x1, y1, 1, color);
	}

	ry = Math.min(ry, (dy - int(dx > 16)) / 2);
	rx = Math.min(rx, (dx - int(dy > 16)) / 2);
	if (rx < 8 || ry < 8) {
		if (rx < 1 || ry < 1) {
			// no rounding is needed
			return image.drawRect(x0, y0, x1 + 1, y1 + 1, color);
		}
		// apply some visual fixes
		rx += int(rx == 7) - int(rx == 6);
		ry += int(ry == 7) - int(ry == 6);
	}

	int64 sx = rx * rx;
	int64 sy = ry * ry;
	int64 rdy = sx * ry;
	int64 rdx = 0;
	int64 r = rdy / 2;

	x0 += rx;
	x1 -= rx;
	image.fillRect(x0, y0, x1, y0, 1, color);
	image.fillRect(x0, y1, x1, y1, 1, color);
	for (;y0 < y1;) {
		image.set(x0, y0, color);
		image.set(x1, y0, color);
		image.set(x0, y1, color);
		image.set(x1, y1, color);
		if (r >= 0) {
			x0 -= 1;
			x1 += 1;
			r -= rdx += sy;
		}
		if (r < 0) {
			y0 += 1;
			y1 -= 1;
			r += rdy -= sx;
		}
	}
	image.fillRect(x0, y0, x0, y1, 1, color);
	image.fillRect(x1, y0, x1, y1, 1, color);
}

inline fillOval(Image image, int x0, int y0, int x1, int y1, uint32 color) = image.fillRRect(x0, y0, x1, y1, Math.abs(x0 - x1), Math.abs(y0 - y1), color);
inline drawOval(Image image, int x0, int y0, int x1, int y1, uint32 color) = image.drawRRect(x0, y0, x1, y1, Math.abs(x0 - x1), Math.abs(y0 - y1), color);

/// Fill the given rectangle rounding the corners using the given radius
inline fillRRect(Image image, int x1, int y1, int x2, int y2, int r, uint32 color) = fillRRect(image, x1, y1, x2, y2, r, r, color);
/// draw the given rectangle rounding the corners using the given radius
inline drawRRect(Image image, int x1, int y1, int x2, int y2, int r, uint32 color) = drawRRect(image, x1, y1, x2, y2, r, r, color);

/// Draw a normal or smooth(anti-aliased) line, including ending pixel
void drawLineIncl(Image image, int x0, int y0, int x1, int y1, bool smooth, uint32 color) {
	inline mix(Image image, int x0, int y0, int alpha, uint32 color) = image.set(x0, y0, mix_rgb8(alpha, argb(uint32(image.get(x0, y0))), argb(color)));

	if (x0 == x1 || y0 == y1) {
		// horizontal or vertical line && avoid division by zero
		return image.fillRect(x0, y0, x1, y1, 1, color);
	}

	int dx = x1 - x0;
	int dy = y1 - y0;

	if (Math.abs(dx) > Math.abs(dy)) {
		if (x0 > x1) {
			int x = x0;
			x0 = x1;
			x1 = x;
			y0 = y1;
		}
		int y = y0 << 16;
		dy = (dy << 16) / dx;
		if (x1 > image.width()) {
			x1 = image.width();
		}
		if (x0 < 0) {
			y -= dy * x0;
			x0 = 0;
		}

		if (!smooth) {
			y += 0x8000;
			for (int x = x0; x <= x1; x += 1) {
				image.set(x, y >> 16, color);
				y += dy;
			}
			return;
		}

		for (int x = x0; x <= x1; x += 1) {
			uint32 alpha = (~y >> 8) & 255;
			image.mix(x, y >> 16, alpha, color);
			image.mix(x, (y >> 16) + 1, 255 - alpha, color);
			y += dy;
		}
	} else {
		if (y0 > y1) {
			int y = y0;
			y0 = y1;
			y1 = y;
			x0 = x1;
		}
		int x = x0 << 16;
		dx = (dx << 16) / dy;
		if (y1 > image.height()) {
			y1 = image.height();
		}
		if (y0 < 0) {
			x -= dx * y0;
			y0 = 0;
		}

		if (!smooth) {
			x += 0x8000;
			for (int y = y0; y <= y1; y += 1) {
				image.set(x >> 16, y, color);
				x += dx;
			}
			return;
		}

		for (int y = y0; y <= y1; y += 1) {
			int alpha = (~x >> 8) & 255;
			image.mix(x >> 16, y, alpha, color);
			image.mix((x >> 16) + 1, y, 255 - alpha, color);
			x += dx;
		}
	}
}

inline xcl(int a, int b) = a - int(b < a);	// exclude right bottom
/// Draw a normal or smooth(anti-aliased) line
inline drawLine(Image image, int x0, int y0, int x1, int y1, bool smooth, uint32 color) = drawLineIncl(image, xcl(x0 , x1), xcl(y0, y1), xcl(x1, x0), xcl(y1, y0), smooth, color);

/// Draw a bezier curve normal or smooth(anti-aliased)
void drawBezier(Image image, int x0, int y0, int x1, int y1, int x2, int y2, bool smooth, uint32 color) {
	int px_0 = x0;
	int py_0 = y0;
	int px_1 = 2 * (x1 - x0);
	int py_1 = 2 * (y1 - y0);
	int px_2 = x2 - 2 * x1 + x0;
	int py_2 = y2 - 2 * y1 + y0;

	double dt = 1. / 128;
	for (double t = dt; t < 1; t += dt) {
		x1 = (px_2 * t + px_1) * t + px_0;
		y1 = (py_2 * t + py_1) * t + py_0;
		drawLineIncl(image, x0, y0, x1, y1, smooth, color);
		x0 = x1;
		y0 = y1;
	}
	drawLine(image, x0, y0, x2, y2, smooth, color);
}

/// Draw a bezier curve normal or smooth(anti-aliased)
void drawBezier(Image image, int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3, bool smooth, uint32 color) {
	int px_0 = x0;
	int py_0 = y0;
	int px_1 = 3 * (x1 - x0);
	int py_1 = 3 * (y1 - y0);
	int px_2 = 3 * (x2 - x1) - px_1;
	int py_2 = 3 * (y2 - y1) - py_1;
	int px_3 = x3 - px_2 - px_1 - px_0;
	int py_3 = y3 - py_2 - py_1 - py_0;

	double dt = 1. / 128;
	for (double t = dt; t < 1; t += dt) {
		x1 = ((px_3 * t + px_2) * t + px_1) * t + px_0;
		y1 = ((py_3 * t + py_2) * t + py_1) * t + py_0;
		drawLineIncl(image, x0, y0, x1, y1, smooth, color);
		x0 = x1;
		y0 = y1;
	}
	drawLine(image, x0, y0, x3, y3, smooth, color);
}

// todo: https://rreusser.github.io/regl-gpu-lines/docs/debug.html
// todo: void fillTriangle(Image image, int x0, int y0, int x1, int y1, int x1, int y1, bool smooth, uint32 color);

/// Fill the entire image with the given color
Image fill(Image image, uint32 color) {
	image.fillRect(0, 0, image.width(), image.height(), color);
	return image;
}

/// Fill the given rectangle rounding the corners using the given radius
void fillRect(Image image, const Rect roi&, int rx, int ry, uint32 color) {
	if (roi.w <= 0 || roi.h <= 0) {
		// empty rectangle
		return;
	}
	image.fillRRect(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, rx, ry, color);
}

/// Fill the given rectangle rounding the corners using the given radius
inline fillRect(Image image, const Rect roi&, int r, uint32 color) = fillRect(image, roi, r, r, color);

inline drawAntiAliased = false;
//inline fillOval(Image image, int x0, int y0, int x1, int y1, bool aa, uint32 color) = fillOval(image, x0, y0, x1, y1, color);
//inline drawOval(Image image, int x0, int y0, int x1, int y1, bool aa, uint32 color) = drawOval(image, x0, y0, x1, y1, color);
inline drawLine(Image image, int x0, int y0, int x1, int y1, uint32 color) = drawLine(image, x0, y0, x1, y1, drawAntiAliased, color);
inline drawBezier(Image image, int x0, int y0, int x1, int y1, int x2, int y2, uint32 color) = drawBezier(image, x0, y0, x1, y1, x2, y2, drawAntiAliased, color);
inline drawBezier(Image image, int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3, uint32 color) = drawBezier(image, x0, y0, x1, y1, x2, y2, x3, y3, drawAntiAliased, color);

/// Fill a rectangle on the `image` specified by `roi` with the given `color`
void fillRect(Image image, const Rect roi&, uint32 color) {
	if (roi.w <= 0 || roi.h <= 0) {
		// empty rectangle
		return;
	}
	image.fillRect(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
}

/// Draw a rectangle on the `image` specified by `roi` with the given `color`
void drawRect(Image image, const Rect roi&, uint32 color) {
	if (roi.w <= 0 || roi.h <= 0) {
		// empty rectangle
		return;
	}
	image.drawRect(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
}

/// Fill a rectangle on the `image` specified by `roi` with the given `color`
void fillOval(Image image, const Rect roi&, uint32 color) {
	if (roi.w <= 0 || roi.h <= 0) {
		// empty rectangle
		return;
	}
	image.fillOval(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
}

/// Draw a rectangle on the `image` specified by `roi` with the given `color`
void drawOval(Image image, const Rect roi&, uint32 color) {
	if (roi.w <= 0 || roi.h <= 0) {
		// empty rectangle
		return;
	}
	image.drawOval(roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
}
