/**
 * generate and execute instructions
 */
#ifndef CMPL_CODE_H
#define CMPL_CODE_H

#include "tree.h"

struct opcodeRec {
	signed int const code;			// opcode value (0..255)
	unsigned int const size;		// length of opcode with args
	unsigned int const stack_in;	// operation requires n elements on stack
	unsigned int const stack_out;	// operation produces n elements on the stack
	const char *const name;			// mnemonic for the opcode
};
extern const struct opcodeRec opcode_tbl[256];

typedef enum vmConfig {
	// limit the count of printed elements(stacktrace, array elements)
	maxLogItems = 25,

	vm_stk_align = sizeof(int32_t),	// stack alignment: size of one element on stack; must be 4: 32bits
	vm_mem_align = sizeof(void*),	// memory alignment: sizeof(void*), // value used to pad pointers
	vm_ref_size = sizeof(vmOffs),	// size of reference: 32 or 64 bit
	px_size = 4,	// size in bytes of the exit instruction halt()
	vm_regs = 255	// maximum registers for dup, set, pop, ...
} vmConfig;

/// Opcodes
typedef enum {
	#define OPCODE_DEF(Name, Code, Size, In, Out, Text) Name = (Code),
	#include "code.i"

	opc_last,		// first invalid opcode
	markIP = opc_last,

	opc_ldi,		// argument is the size
	opc_sti,		// argument is the size
	opc_drop,		// convert this to opcode.spc


	u32_bit_and = 0 << 6,
	u32_bit_shl = 1 << 6,
	u32_bit_shr = 2 << 6,
	u32_bit_sar = 3 << 6,
} vmOpcode;

/// Value inside the virtual machine
typedef union {
	int8_t i08;
	int16_t i16;
	int32_t i32;
	int64_t i64;
	uint8_t u08;
	uint16_t u16;
	uint32_t u32;
	uint64_t u64;
	float32_t f32;
	float64_t f64;
	int32_t i24:24;
	union {
		int8_t i08[16];
		int16_t i16[8];
		int32_t i32[4];
		int64_t i64[2];
		uint8_t u08[16];
		uint16_t u16[8];
		uint32_t u32[4];
		uint64_t u64[2];
		float32_t f32[4];
		float64_t f64[2];
	} p128;
	struct {
		vmOffs ref;
		union {
			vmOffs type;
			vmOffs length;
		};
	};
} vmValue;

#pragma pack(push, 1)
/// bytecode instruction
typedef struct vmInstruction {
	uint8_t opc;
	union {
		vmValue arg;		// argument (load const)
		uint8_t idx;		// usually index for stack
		int32_t rel: 24;	// relative offset (ip, sp) +- 7MB
		struct {
			// move instruction: destination, source
			uint8_t dst;	// index of the destination on the stack
			uint8_t src;	// index of the source on the stack
		} mov;
	};
} *vmInstruction;
#pragma pack(pop)

// native function call
typedef struct libc {
	vmError (*call)(nfcContext);
	const char *proto;
	symn sym;
	size_t offs;
	size_t in, out;		// stack parameters
} *libc;

typedef struct jumpToFix {
	astn node;		// syntax tree node for error message
	ccToken kind;	// break or continue
	size_t offs;	//  offset ot the jump
} *jumpToFix;

/**
 * Initialize runtime context.
 *
 * @param mem (optional) use pre allocated memory.
 * @param size the size of memory in bytes to be used.
 * @return runtime context.
 */
rtContext rtInit(void *mem, size_t size);

/**
 * Close runtime context releasing resources.
 *
 * @param ctx runtime context.
 * @return error count, 0 on success.
 */
int rtClose(rtContext ctx);

/**
 * Initialize virtual machine to be able to emit instructions.
 *
 * @param ctx Runtime context.
 * @param onHalt function to be executed when execution and external function invocation terminates.
 * @return offset of the first opcode that can be emitted.
 */
size_t vmInit(rtContext ctx, vmError onHalt(nfcContext));

/**
 * Execute the generated bytecode.
 *
 * @param ctx Runtime context.
 * @param extra Extra data for native calls.
 * @return Error code of execution or noError on success.
 */
vmError execute(rtContext ctx, void *extra);

/**
 * Invoke a function inside the vm.
 *
 * @param ctx Execution context.
 * @param fun Symbol of the function.
 * @param ret (optional) Result value of the invoked function.
 * @param args (optional) Arguments for the function.
 * @param extra (optional) Extra data for each native call executed from here.
 * @return Error code of execution or noError on success.
 * @usage see @rtFindSym example.
 * @note Invocation to `execute` must precede this call.
 */
vmError invoke(nfcContext ctx, symn fun, void *ret, void *args, const void *extra);

/**
 * Lookup a static symbol by offset.
 *
 * @param ctx Runtime context.
 * @param offset Offset of the variable.
 * @param filter filter lookup by static: yes|no, kind: var|typ|fun, cast: ....
 * @note Useful to invoke callbacks from native calls.
 * @usage:

	static symn onMouse = NULL;

	static int setMouseCb(nfcContext ctx) {
		size_t fun = argref(ctx, 0);

		// un-register event callback
		if (fun == 0) {
			onMouse = NULL;
			return noError;
		}

		// register event callback using the symbol of the function.
		onMouse = rt->api.rtLookup(rt, fun);

		// runtime error if symbol is not valid.
		return onMouse != NULL ? noError : nativeCallError;
	}

	static int mouseCb(int btn, int x, int y) {
		if (onMouse != NULL && rt != NULL) {
			// invoke the callback with arguments.
			struct {int32_t btn, x, y;} args = {btn, x, y};
			rt->api.invoke(rt, onMouse, NULL, &args, NULL);
		}
	}

	// expose the callback register function to the compiler
	if (!rt->api.ccDefCall(rt->cc, setMouseCb, "void setMouseCallback(void Callback(int32 btn, int32 x, int32 y)")) {
		error(...)
	}
 */
symn rtLookup(rtContext ctx, size_t offset, ccKind filter);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Plugins
extern const char * const pluginLibImport;
extern const char * const pluginLibInstall;
extern const char * const pluginLibDestroy;

int importLib(rtContext ctx, ccContext cc, const char *path);
void closeLibs(rtContext ctx);

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Instructions
/**
 * Emit an instruction.
 *
 * @param ctx Runtime context.
 * @param opc Opcode.
 * @param arg Argument.
 * @return Program counter.
 */
size_t emitOpc(rtContext ctx, vmOpcode opc, vmValue arg);

/**
 * Advance to the next instruction at the given offset.
 *
 * @param ctx Runtime context.
 * @param pc Offset of the current opcode to be incremented.
 * @param ss Size of the stack.
 * @return NULL or the current instruction pointer.
 */
void* nextOpc(rtContext ctx, size_t *pc, ssize_t *ss);

/**
 * Test for an instruction at the given offset.
 *
 * @param ctx Runtime context.
 * @param offs Offset of the opcode.
 * @param opc Operation code to check.
 * @param arg (optional) Copy the argument of the opcode.
 * @return non zero if at the given location the opc was found.
 */
int testOcp(rtContext ctx, size_t offs, vmOpcode opc, vmValue *arg);

/**
 * Fix a jump instruction, and the stack size.
 *
 * @param ctx Runtime context.
 * @param src Location of the instruction.
 * @param dst Absolute position to jump.
 * @param stc Fix also stack size.
 * @return
 */
void fixJump(rtContext ctx, size_t src, size_t dst, ssize_t stc);

/**
 * Test the virtual machine instruction set(compare implementation with definition `OPCODE_DEF`).
 *
 * @param cb callback executed for each instruction.
 * @return number of errors found during the test.
 */
int vmSelfTest(void cb(const char *error, const struct opcodeRec *info));

/// Emit an instruction without argument(s).
static inline size_t emit(rtContext ctx, vmOpcode opc) {
	vmValue arg = {0};
	return emitOpc(ctx, opc, arg);
}

/// Emit an instruction with an integer argument.
static inline size_t emitInt(rtContext ctx, vmOpcode opc, int64_t value) {
	vmValue arg = {0};
	arg.i64 = value;
	return emitOpc(ctx, opc, arg);
}

/// Emit load int64 constant value instruction.
static inline size_t emitI64(rtContext ctx, int64_t value) {
	vmValue arg = {0};
	arg.i64 = value;
	return emitOpc(ctx, opc_lc64, arg);
}

/// Emit load float64 constant value instruction.
static inline size_t emitF64(rtContext ctx, float64_t value) {
	vmValue arg = {0};
	arg.f64 = value;
	return emitOpc(ctx, opc_lf64, arg);
}

/// Emit load offset value instruction.
static inline size_t emitRef(rtContext ctx, size_t value) {
	vmValue arg = {0};
	arg.u64 = value;
	return emitOpc(ctx, opc_lref, arg);
}

/**
 * Rollback the last emitted instruction
 *
 * @param ctx Runtime context.
 * @return NULL or the current instruction pointer
 */
void *rollbackPc(rtContext ctx);

/**
 * Optimize an assignment by removing extra copy of the value if it is on the top of the stack.
 * replace `dup x`, `set y` with a single `mov x, y` instruction
 * replace `dup 0`, `set x` with a single `set x` instruction
 *
 * @param ctx Runtime context.
 * @param start Begin of the byte code.
 * @param end End of the byte code.
 * @return non zero if the code was optimized.
 */
int foldAssignment(rtContext ctx, size_t start, size_t end);

#ifdef __WATCOMC__
#pragma disable_message(136);	// Warning! W136: Comparison equivalent to 'unsigned == 0'

#include <math.h>
static float fmodf(float x, float y) { return (float) fmod(x, y); }
static float exp2(float x) { return (float) pow(2, x); }
static float sinf(float x) { return (float) sin((float) x); }
static float cosf(float x) { return (float) cos((float) x); }
static float tanf(float x) { return (float) tan((float) x); }
static float logf(float x) { return (float) log((float) x); }
static float expf(float x) { return (float) exp((float) x); }
static float powf(float x, float y) { return (float) pow((float) x, (float) y); }
static float sqrtf(float x) { return (float) sqrt((float) x); }
static float atan2f(float x, float y) { return (float) atan2((float) x, (float) y); }
#endif

#endif
