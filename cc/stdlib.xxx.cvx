//~ #!./main -c -O2 -x
//~ module std;

//~ /*
define clock() = int(0);

const math: float64 {

	/*define i64_as_f64(int64 x) = emit(float64, int64(x));

	//~ nan = 0. / 0;
	//~ nan = -0. / 0;
	nan = i64_as_f64(0x7FFFFFFFFFFFFFFF);
	snan = i64_as_f64(0xFFF8000000000000);

	//~ inf = 1. / 0;
	inf  = i64_as_f64(0x7FF0000000000000);

	//~ ln2 = 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
	ln2  = i64_as_f64(0x3FE62E42FEFA39EF);

	//~ log2E = 1. / ln2;
	log2e = i64_as_f64(0x3FF71547652B82FE);

	//~ ln10 = 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
	//~ log10E = 1. / ln10;

	log2t = i64_as_f64(0x400A934F0979A371);			// lg2(10);
	logt2 = i64_as_f64(0x3FD34413509F79FF);			// lg10(2);


	pi = 3.14159265358979323846264338327950288419716939937510582097494459;	// A000796
	//~ pi   = i64_as_f64(0x400921FB54442D18);

	//~ e = 2.71828182845904523536028747135266249775724709369995957496696763;	// A001113
	e    = i64_as_f64(0x4005BF0A8B145769);

	//~ phi = 1.61803398874989484820458683436563811772030917980576286213544862;	// A001622

	//~ sqrt2	= 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
	//~ sqrtE	= 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
	//~ sqrtPi	= 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
	//~ sqrtPhi	= 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
	*/

	pi = 3.14159265358979323846264338327950288419716939937510582097494459;		// A000796
	e = 2.71828182845904523536028747135266249775724709369995957496696763;		// A001113
	ln2 = 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
	log2E = 1 / ln2;
	ln10 = 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
	log10E = 1 / ln10;
	phi = 1.61803398874989484820458683436563811772030917980576286213544862;		// A001622
	sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
	sqrtE = 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
	sqrtPi = 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
	sqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339

	//~ nan = 0. / 0;
	//~ snan = -0. / 0;
	//~ inf = 1. / 0;
	//~ sinf = -1. / 0;

	// (0. / 0) = -nan ????
	define nan  = emit(float64, i64(0x7FFFFFFFFFFFFFFF));
	define snan = emit(float64, i64(0xFFF8000000000000));
	define inf  = emit(float64, i64(0x7FF0000000000000));

	define isNan(float64 a) = emit(not, f64.ceq, dupp.x2, f64(a));// bool(a != a);
	define isNan(float32 a) = emit(not, f32.ceq, dupp.x1, f32(a));// bool(a != a);
	//~ define isNan(float64 ^a) = bool(a != a);
	//~ define isNan(float32 ^a) = bool(a != a);
	//~ define isInf(float64 ^a) = bool(a && a == 2 * a);
}

const imports: bool {
	print = true;			// prints, clock, rand
	math2 = true;		// min, max, clamp, lerp
	complex = !true;	// Complex numbers

	// simd
	vec2d = true;
	vec4f = true;
	mat4f = !true;

	strUtils = true;
	hexTY = !false;
}

static if (imports.print) {

define println() = putchr('\n');

define print(int32 arg)   = puti64(arg);
define print(int64 arg)   = puti64(arg);
define print(float32 arg) = putf64(arg);
define print(float64 arg) = putf64(arg);
define print(string arg)  = putstr(arg);

void println(int32 arg)   {puti64(arg); putchr('\n');}
void println(int64 arg)   {puti64(arg); putchr('\n');}
void println(float32 arg) {putf64(arg); putchr('\n');}
void println(float64 arg) {putf64(arg); putchr('\n');}
void println(string arg)  {putstr(arg); putchr('\n');}

define clock(int start) = int32(clock() - start);

define rand(int32 max) = int32(rand() % max);
define rand(int32 ^min, int32 max) = int32(min + rand(max - min));

//~ define rand(int64 max) = int64((int64(rand()) * rand()) % max);
define rand(int64 max) = int64(int64(rand()) % max);
define rand(int64 ^min, int64 max) = int64(min + rand(max - min));

const rand2FloatValue = int32(0xffffff);
define rand(float64 max) = float64((max * rand(rand2FloatValue)) / rand2FloatValue);
define rand(float64 ^min, float64 max) = float64(min + rand(max - min));

}
static if (imports.math2) {
define max(int32 ^a, int32 ^b) = int32(a > b ? a : b);
define max(int64 ^a, int64 ^b) = int64(a > b ? a : b);
define max(uint32 ^a, uint32 ^b) = uint32(a > b ? a : b);
define max(float32 ^a, float32 ^b) = float32(a > b ? a : b);
define max(float64 ^a, float64 ^b) = float64(a > b ? a : b);

define min(int32 ^a, int32 ^b) = int32(a < b ? a : b);
define min(int64 ^a, int64 ^b) = int64(a < b ? a : b);
define min(uint32 ^a, uint32 ^b) = uint32(a < b ? a : b);
define min(float32 ^a, float32 ^b) = float32(a < b ? a : b);
define min(float64 ^a, float64 ^b) = float64(a < b ? a : b);

define clamp(int t, int a, int b) = min(max(t, a), b);
define clamp(float t, float a, float b) = min(max(t, a), b);
define clamp(double t, double a, double b) = min(max(t, a), b);

define lerp(float32 t, float32 ^a, float32 b) = float32(a + t * (b - a));
define lerp(float64 t, float64 ^a, float64 b) = float64(a + t * (b - a));

define smooth(float32 ^t) = float32(t * t * (3 - 2 * t));
define smooth(float32 t, float32 ^a, float32 b) = smooth(clamp((t - a) / (b - a), float32(0), float32(1)));

define hypot(float64 ^x, float64 ^y) = sqrt(x * x + y * y);

define nz(float64 ^val1, float64 val2) = float64(val1 ? val1 : val2);
define nz(float64 ^val1, float64 val2, float64 val3) = float64(val1 ? val1 : nz(val2, val3));
define nz(float64 ^val1, float64 val2, float64 val3, float64 val4) = float64(val1 ? val1 : nz(val2, val3, val4));

define eval(float64 ^x, float64 a0, float64 a1) = (a0 + x * a1);
define eval(float64 ^x, float64 a0, float64 a1, float64 a2) = (a0 + x * eval(x, a2, a1));
define eval(float64 ^x, float64 a0, float64 a1, float64 a2, float64 a3) = (a0 + x * eval(x, a3, a2, a1));
define eval(float64 ^x, float64 a0, float64 a1, float64 a2, float64 a3, float64 a4) = (a0 + x * eval(x, a4, a3, a2, a1));

// Sinh returns the hyperbolic sine of x.
float64 sinh(float64 x) {
	// The coefficients are #2029 from Hart & Cheney. (20.36D)
	const: float64 {
		P0 = -0.6307673640497716991184787251e+6;
		P1 = -0.8991272022039509355398013511e+5;
		P2 = -0.2894211355989563807284660366e+4;
		P3 = -0.2630563213397497062819489e+2;
		Q0 = -0.6307673640497716991212077277e+6;
		Q1 = 0.1521517378790019070696485176e+5;
		Q2 = -0.173678953558233699533450911e+3;
	};

	bool sign := false;
	if (x < 0) {
		x = -x;
		sign = true;
	}

	//~ float64 temp;
	if (x > 21) {
		result = exp(x) / 2;
	}
	else if (x > 0.5) {
		result = (exp(x) - exp(-x)) / 2;
	}
	else {
		float64 sq := x * x;
		result = (((P3 * sq + P2) * sq + P1) * sq + P0) * x;
		result = result / (((sq + Q2) * sq + Q1) * sq + Q0);
	}

	if (sign) {
		result = -result;
	}
}

// Cosh returns the hyperbolic cosine of x.
float64 cosh(float64 x) {
	if (x < 0) {
		x = -x;
	}
	if (x > 21) {
		result =  exp(x) / 2;
	}
	else {
		result = (exp(x) + exp(-x)) / 2;
	}
}
}
static if (imports.complex) {
struct Complex {
	float64 re;
	float64 im;
}

//~ define Complex(float64 re, float64 im) = emit(Complex, f64(re), f64(im));
define Complex(float64 re) = Complex(re, 0.);

define neg(Complex a) = emit(Complex, v2d.neg, val(a));

define add(Complex a, Complex b) = emit(Complex, v2d.add, val(b), val(a));
define add(Complex a, float64 b) = emit(Complex, v2d.add, f64(b), f64(0), val(a));
define add(float64 a, Complex b) = emit(Complex, v2d.add, val(b), f64(a), f64(0));

define sub(Complex a, Complex b) = emit(Complex, v2d.sub, val(b), val(a));
define sub(Complex a, float64 b) = emit(Complex, v2d.sub, f64(b), f64(0), val(a));
define sub(float64 a, Complex b) = emit(Complex, v2d.sub, val(b), f64(a), f64(0));

define mul(Complex ^a, Complex ^b) = emit(Complex,
	f64.sub, v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re),	// re = a.re * b.re - a.im * b.im
	f64.add, v2d.mul, val(b), f64(a.im), f64(a.re)	// im = a.re * b.im + a.im * b.re;
);
define mul(Complex a, double b) = emit(Complex, v2d.mul, dupp.x2, f64(b), val(a));
define mul(double a, Complex b) = emit(Complex, v2d.mul, val(b), dupp.x2, f64(a));

Complex div(Complex a, Complex b) {
	// Adapted from Numerical Recipes in C - The Art of Scientific Computing
	// ISBN 0-521-43108-5

	if (abs(b.re) >= abs(b.im)) {
		double r = b.im / b.re;
		double den = b.re + r * b.im;
		result.re = (a.re + r * a.im) / den;
		result.im = (a.im - r * a.re) / den;
	}
	else {
		double r = b.re / b.im;
		double den = b.im + r * b.re;
		result.re = (a.re * r + a.im) / den;
		result.im = (a.im * r - a.re) / den;
	}
}

define abs(Complex ^a) = hypot(a.re, a.im);
define arg(Complex ^a) = atan2(a.re, a.im);

define re(Complex ^a) = float64(a.re);
define im(Complex ^a) = float64(a.im);

Complex inv(Complex a) {
	float64 d = (a.re * a.re + a.im * a.im);
	result = Complex(+a.re / d, -a.im / d);
}

define conj(Complex ^a) = Complex(a.re, -a.im);

define exp(Complex ^a) = Complex(exp(a.re) * cos(a.im), exp(a.re) * sin(a.im));

define log(Complex ^a) = Complex(log(abs(a)), arg(a));

Complex pow(Complex a, Complex b) {
	/*
	if (b.im == 0) {
		if (a.im == 0) return new Complex(Math.pow(a.re, b.re));
		return Complex.exp(Complex.mul(b.re, Complex.log(a)));
	}
	if (a.im == 0) return Complex.exp(Complex.mul(b, Math.log(a.re)));
	return Complex.exp(Complex.mul(b, Complex.log(a)));
	//~ */

	double r = hypot(a.im, a.re);
	double t = atan2(a.im, a.re);
	double u = b.re * t + b.im * log(r);
	double v = pow(r, b.re) * exp(-b.im * t);
	result = Complex(v * cos(u), v * sin(u));
}

define sin(Complex ^a) = Complex(sin(a.re) * cosh(a.im), cos(a.re) * sinh(a.im));
define cos(Complex ^a) = Complex(cos(a.re) * cosh(a.im),-sin(a.re) * sinh(a.im));
define tan(Complex ^a) = div(sin(a), cos(a));

/+ More Trig ... ???
static Complex cot(Complex a) {
	result = cos(a) / sin(a);
}

static Complex sinh(Complex a) {
	result = (exp(a) - exp(-a)) / 2;
}

static Complex cosh(Complex a) {
	result = (exp(a) + exp(-a)) / 2;
}

static Complex tanh(Complex a) {
	result = (exp(2 * a) - 1) / (exp(2 * a) + 1);
}

static Complex coth(Complex a) {
	result = (exp(2 * a) + 1) / (exp(2 * a) - 1);
}


static Complex sech(Complex a) {
	result = inv(cosh(a));
}

static Complex csch(Complex a) {
	result = inv(sinh(a));
}
// +/
}

static if (imports.vec2d) {
struct vec2d {
	float64 x;
	float64 y;
}

define add(vec2d x, vec2d y) = emit(vec2d, v2d.add, val(y), val(x));
define sub(vec2d x, vec2d y) = emit(vec2d, v2d.sub, val(y), val(x));
define mul(vec2d x, vec2d y) = emit(vec2d, v2d.mul, val(y), val(x));
define div(vec2d x, vec2d y) = emit(vec2d, v2d.div, val(y), val(x));

//~ define mod(vec2d x, vec2d y) = emit(vec2d, v2d.rem, val(y), val(x));
define min(vec2d x, vec2d y) = emit(vec2d, v2d.min, val(y), val(x));
define max(vec2d x, vec2d y) = emit(vec2d, v2d.max, val(y), val(x));
define cmp(vec2d x, vec2d y) = emit(v2d.equ, val(y), val(x));

define dot(vec2d ^x, vec2d ^y) = float64(x.x * y.x + x.y * y.y);

static if (imports.print) {
//~ define print(vec2d ^v) = void(putchr(')'), putf64(v.y), void(putstr(", ")), putf64(v.x), void(putstr("vec2d(")));
//~ define println(vec2d ^v) = void(putchr('\n'), print(v));
}
}
static if (imports.vec4f) {
//~ /* is defined from c code ?
struct vec4f {
	float32 x;
	float32 y;
	float32 z;
	float32 w;
}// */

//~ define vec4f(float32 x, float32 y, float32 z, float32 w) = emit(vec4f, f32(x), f32(y), f32(z), f32(w));
define vec4f(vec4f v) = emit(vec4f, val(v));

define vec4f(float32 x, float32 y, float32 z) = vec4f(x, y, z, 0);
define vec4f(float32 val) = emit(vec4f, dupp.x2, dupp.x1, f32(val));

define vec4f(float64 x, float64 y, float64 z, float64 w) = emit(vec4f, f32(x), f32(y), f32(z), f32(w));
define vec4f(float64 x, float64 y, float64 z) = emit(vec4f, f32(x), f32(y), f32(z), f32(0));
define vec4f(float64 val) = emit(vec4f, dupp.x2, dupp.x1, f32(val));

define neg(vec4f rhs) = emit(vec4f, v4f.neg, val(rhs));
define add(vec4f lhs, vec4f rhs) = emit(vec4f, v4f.add, val(rhs), val(lhs));
define sub(vec4f lhs, vec4f rhs) = emit(vec4f, v4f.sub, val(rhs), val(lhs));
define mul(vec4f lhs, vec4f rhs) = emit(vec4f, v4f.mul, val(rhs), val(lhs));
define div(vec4f lhs, vec4f rhs) = emit(vec4f, v4f.div, val(rhs), val(lhs));

define mad(vec4f a, vec4f b, vec4f c) = emit(vec4f, v4f.add, v4f.mul, val(a), val(b), val(c));	// a * b + c

define dp3(vec4f lhs, vec4f rhs) = emit(v4f.dp3, val(rhs), val(lhs));
define dp4(vec4f lhs, vec4f rhs) = emit(v4f.dp4, val(rhs), val(lhs));
define dph(vec4f lhs, vec4f rhs) = emit(v4f.dph, val(rhs), val(lhs));
define cross(vec4f ^a, vec4f ^b) = vec4f(float64(a.y) * b.z - a.z * b.y, float64(a.z) * b.x - a.x * b.z, float64(a.x) * b.y - a.y * b.x);
	//~ tmp.x = lhs->y * rhs->z - lhs->z * rhs->y;
	//~ tmp.y = lhs->z * rhs->x - lhs->x * rhs->z;
	//~ tmp.z = lhs->x * rhs->y - lhs->y * rhs->x;

define lerp(float32 ^t, vec4f ^lhs, vec4f ^rhs) = vec4f(lerp(t, lhs.x, rhs.x), lerp(t, lhs.y, rhs.y), lerp(t, lhs.z, rhs.z), lerp(t, lhs.w, rhs.w));
//~ define lerp(float32 ^t, vec4f ^lhs, vec4f ^rhs) = emit(vec4f, val(lhs));
//~ define lerp(float32 ^t, vec4f ^lhs, vec4f ^rhs) = vec4f(lhs);

define len(vec4f ^v) = sqrt(dp3(v, v));
define eval(vec4f ^v, float32 ^x) = float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
define normalize(vec4f a) = emit(vec4f, v4f.div, dupp.x2, dupp.x1, v4f.dp3, dupp.x4, dupp.x4, val(a));
//~ define normalize(vec4f ^a) = div(a, vec4f(dp3(a, a)));

define float32(vec4f ^vec) = float32(vec.w);
//~ define bool(vec4f ^vec) = bool(vec.x && vec.y && vec.z && vec.w);

//~ operator - (vec4f x) = emit(vec4f, v4f.neg, val(x));
//~ operator (vec4f x) + (vec4f y) = emit(vec4f, v4f.add, val(y), val(x));
//~ operator (vec4f x) - (vec4f y) = emit(vec4f, v4f.sub, val(y), val(x));
//~ operator (vec4f x) * (vec4f y) = emit(vec4f, v4f.mul, val(y), val(x));
//~ operator (vec4f x) / (vec4f y) = emit(vec4f, v4f.div, val(y), val(x));
//~ operator (vec4f x) % (vec4f y) = emit(vec4f, v4f.mod, val(y), val(x));

//~ operators should be implicit ?
//~ operator float32(vec4f vec) = float32(vec.w);
//~ operator bool(vec4f vec) = bool(vec.x && vec.y && vec.z && vec.w);

//~ operator (vec4f v)[int i] = float32(i == 0 ? v.x : i == 1 ? v.y : i == 2 ? v.z : i == 3 ? v.w : math.nan);
//~ operator (vec4f v)[char c] = float32(c == 'x' ? v.x : c == 'y' ? v.y : c == 'z' ? v.z : c == 'w' ? v.w : math.nan);
//~ operator (vec4f v)(float32 x) = eval(v, x);

static if (imports.print) {
//~ define print(vec4f ^v) = void(putchr(')'), putf64(v.w), void(putstr(", ")), putf64(v.z), void(putstr(", ")), putf64(v.y), void(putstr(", ")), putf64(v.x), void(putstr("vec4f(")));
//~ define println(vec4f ^v) = void(putchr('\n'), print(v));
}
}
static if (imports.mat4f) {
struct mat4f {
	vec4f x;
	vec4f y;
	vec4f z;
	vec4f w;
}

define dp3(mat4f ^mat, vec4f ^vec) = vec4f(dp3(mat.x, vec), dp3(mat.y, vec), dp3(mat.z, vec), float32(1));
define dp4(mat4f ^mat, vec4f ^vec) = vec4f(dp4(mat.x, vec), dp4(mat.y, vec), dp4(mat.z, vec), dp4(mat.w, vec));
define dph(mat4f ^mat, vec4f ^vec) = vec4f(dph(mat.x, vec), dph(mat.y, vec), dph(mat.z, vec), dph(mat.w, vec));

mat4f translate(mat4f &mat) {
	//~ result.x.x = mat.x.x;
	result.x.y = mat.y.x;
	result.x.z = mat.z.x;
	result.x.w = mat.w.x;

	result.y.x = mat.x.y;
	//~ result.y.y = mat.y.y;
	result.y.z = mat.z.y;
	result.y.w = mat.w.y;

	result.z.x = mat.x.z;
	result.z.y = mat.y.z;
	//~ result.z.z = mat.z.z;
	result.z.w = mat.w.z;

	result.w.x = mat.x.w;
	result.w.y = mat.y.w;
	result.w.z = mat.z.w;
	//~ result.w.w = mat.w.w;
}

void translate2(mat4f &mat) {
	void swap(float32 &a, float32 &b) {
		float32 tmp = a;
		a = b;
		b = tmp;
	}
	//~ swap(mat.x.x, mat.x.x);
	swap(mat.x.y, mat.y.x);
	swap(mat.x.z, mat.z.x);
	swap(mat.x.w, mat.w.x);

	//~ swap(mat.y.x, mat.x.y);
	//~ swap(mat.y.y, mat.y.y);
	swap(mat.y.z, mat.z.y);
	swap(mat.y.w, mat.w.y);

	//~ swap(mat.z.x, mat.x.z);
	//~ swap(mat.z.y, mat.y.z);
	//~ swap(mat.z.z, mat.z.z);
	swap(mat.z.w, mat.w.z);

	//~ swap(mat.w.x, mat.x.w);
	//~ swap(mat.w.y, mat.y.w);
	//~ swap(mat.w.z, mat.z.w);
	//~ swap(mat.w.w, mat.w.w);
}

}

static if (imports.strUtils) {

/**
calculate the length of a string
*/
int strlen(string str) {
	for (result = 0; str[result]; result += 1) ;
}

/**
returns the first occurrence of the character chr in the string str
*/
int strchr(string str, int chr) {
	result = -1;
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			result = i;
			break;
		}
	}
}

/**
returns the last occurrence of the character chr in the string str
*/
int strrchr(string str, int chr) {
	result = -1;
	for (int i = 0; str[i]; i += 1) {
		if (str[i] == chr) {
			result = i;
		}
	}
}

}

static if (imports.hexTY) {
define hex8  int8;		//%hex8(0x%02x)
define hex16 int16;		//%hex16(0x%04x)
define hex32 int32;		//%hex32(0x%08x)
define hex64 int64;		//%hex64(0x%016X)

define print(hex32 arg) = putx64(arg);
void println(hex32 arg) {putx64(arg); putchr('\n');}
define print(hex64 arg) = putx64(arg);
void println(hex64 arg) {putx64(arg); println();}
}

/+ pointers

//~ define pointer int32;
define void(pointer p) = void();
define bool(pointer p) = emit(bool, load.b8, ref(p));
define int8(pointer p) = emit(int8, load.b8, ref(p));
define int16(pointer p) = emit(int16, load.b16, ref(p));
define int32(pointer p) = emit(int32, load.b32, ref(p));
define int64(pointer p) = emit(int64, load.b64, ref(p));
define uint8(pointer p) = emit(uint8, load.b8, ref(p));
define uint16(pointer p) = emit(uint16, load.b16, ref(p));
define uint32(pointer p) = emit(uint32, load.b32, ref(p));
define float32(pointer p) = emit(float32, load.b32, ref(p));
define float64(pointer p) = emit(float64, load.b64, ref(p));
// +/
// */
