//~ Trace native calls
void f(int &arg) {
	if (arg <= 0) {
		debug("stack trace :-)", 3, 256, variant.null);
		//~ trace("stack trace :-)");
		return;
	}
	int n2 = arg - 1;
	//~ f(n2);
	testFunction(emit(struct, ref(f)), pointer(n2));
}

int N = 4;
//~ f(&N);

void f2(int arg, string b) {
	f(&arg);
}
f2(N, "apple");

// */

//~ /+ test: debug and trace info
struct debugInfo {
	string func;
	double x;
	double expected;
	double got;
}

void f3(pointer maxRecursiveCalls) {
	const int &n = maxRecursiveCalls;
	if (n <= 0) {
		trace("stack trace :-)");
		return;
	}
	int n2 = n - 1;
	testFunction(f3, pointer(n2));
}

//~ BUG: void testFunction2(void cb(double x, debugInfo info, int n), int n, debugInfo &info) {
void testFunction2(void cb(double x, debugInfo &info, int n), int n, debugInfo info) {
	cb(n * 3.14, &info, n);
}
void f4(double x, debugInfo &info, int maxRecursiveCalls) {
	if (maxRecursiveCalls <= 0) {
		trace("stack trace :)");
		return;
	}
	testFunction2(f4, maxRecursiveCalls - 1, info);
}

int n = 2;
testFunction(f3, pointer(n));

debugInfo info = debugInfo("fail", 1, 2, 3);
testFunction2(f4, n, info);
//~ +/
