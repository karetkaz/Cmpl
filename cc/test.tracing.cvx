//~ /*/~ Trace native calls
void f(int &arg) {
	if (arg <= 0) {
		debug("stack trace :-)", 3, 256, variant.null);
		//~ trace("stack trace :-)");
		return;
	}
	int n2 = arg - 1;
	f(&n2);
	//~ testFunction(emit(struct, ref(f)), pointer(n2));
}

int N = 4;
f(&N);

void f2(int arg, string b) {
	//~ x = 0;
	f(&arg);
}
f2(N, "apple");
f2(N, "apple23");
f2(N, "apple354");

// */

//~ define trace(string message) = debug(message, 3, 25, variant.null);
//~ define trace(string message, variant value) = debug(message, 3, 25, value);

//~ /+ test: debug and trace info
//~ define trace(string message) = debug(message, 3, 25, variant.null);

struct debugInfo {
	string func;
	double x;
	double expected;
	double got;
}

void f3(pointer maxRecursiveCalls) {
	const int &n = maxRecursiveCalls;
	if (n <= 0) {
		trace("stack trace :-)");
		return;
	}
	int n2 = n - 1;
	if ((n2 & 1) == 0) {
		return f3(pointer(&n2));
	} // */
	testFunction(f3, pointer(&n2));
}

//~ BUG: void testFunction2(void cb(double x, debugInfo info, int n), int n, debugInfo &info) {
void testFunction2(void cb(double x, debugInfo &info, int n), int n, debugInfo info) {
	cb(n * 3.14, &info, n);
}
void f4(double x, debugInfo &info, int maxRecursiveCalls) {
	if (maxRecursiveCalls <= 0) {
		trace("stack trace :)");
		return;
	}
	testFunction2(f4, maxRecursiveCalls - 1, info);
}

int n = 5;
testFunction(f3, pointer(&n));
int a = 9;
//~ debugInfo info = debugInfo("fail", 1, 2, 3);
//~ testFunction2(f4, n, info);
//~ +/
