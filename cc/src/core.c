/*******************************************************************************
 *   File: core.c
 *   Date: 2011/06/23
 *   Desc: type system
 *******************************************************************************
the core:
	convert ast to bytecode
	initializations, memory management

	emit:
	emit is a low level function like construct. (intrinsic)
	emit's type is the type of the first argument's.
	emit can have as parameters values and opcodes.
		as the first argument of emit we can pass a type or the struct keyword.
			if the first argument is a type, static cast can be done
				ex emit(float32, int32(2))
			if the first argument is struct in a declaration,
			the resulting type will match the declared type.
			size of variable must match the size generated by emit.
				ex complex a = emit(struct, f64(1), f64(-1));
	emit is used for libcalls, constructors, ..., optimizations
*******************************************************************************/
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <time.h>
#include "core.h"

const struct tok_inf tok_tbl[255] = {
	#define TOKDEF(NAME, TYPE, SIZE, STR) {TYPE, SIZE, STR},
	#include "defs.inl"
	{0},
};
const struct opc_inf opc_tbl[255] = {
	#define OPCDEF(NAME, CODE, SIZE, CHCK, DIFF, MNEM) {CODE, SIZE, CHCK, DIFF, MNEM},
	#include "defs.inl"
	{0},
};

static void memswap(void* _a, void* _b, int size) {
	register char *a = _a;
	register char *b = _b;
	while ((size -= 1) >= 0) {
		char c = *a;
		*a = *b;
		*b = c;
		a += 1;
		b += 1;
	}
}

/**
 * @brief get absolute position on stack, of relative offset
 * @param rt Runtime context.
 * @param size size of variable.
 * @return the position of variable on stack.
 */
static inline int stkoffs(state rt, int size) {
	dieif(size < 0, "Error");
	return padded(size, vm_size) + rt->vm.ss * vm_size;
}

/// Initialize runtime context; @see header
state rtInit(void* mem, unsigned size) {
	state rt = mem;

	/*TODO: dynamic memory allocation
	if (mem == NULL) {
		mem = malloc(size);
		rt = mem;
	}
	// */

	dieif(rt == NULL, "internal error");
	memset(mem, 0, sizeof(struct stateRec));

	*(void**)&rt->api.ccBegin = ccBegin;
	*(void**)&rt->api.ccDefInt = ccDefInt;
	*(void**)&rt->api.ccDefFlt = ccDefFlt;
	*(void**)&rt->api.ccDefStr = ccDefStr;
	*(void**)&rt->api.ccAddType = ccAddType;
	*(void**)&rt->api.ccAddCall = ccAddCall;
	*(void**)&rt->api.ccAddCode = ccAddCode;
	*(void**)&rt->api.ccEnd = ccEnd;
	//~ rt->api.ccSymFind = ccSymFind;
	*(void**)&rt->api.mapsym = mapsym;
	*(void**)&rt->api.invoke = invoke;
	*(void**)&rt->api.rtAlloc = rtAlloc;

	*(long*)&rt->_size = size - sizeof(struct stateRec);
	rt->_end = rt->_mem + rt->_size;
	rt->_beg = rt->_mem;

	logFILE(rt, stdout);
	rt->cc = NULL;
	return rt;
}

//#{ symbols: install and query
/// Begin a namespace; @see state.api.ccBegin
symn ccBegin(state rt, const char* cls) {
	symn result = NULL;
	if (rt->cc != NULL) {
		if (cls != NULL) {
			result = install(rt->cc, cls, ATTR_stat | ATTR_const | TYPE_rec, TYPE_vid, 0, rt->cc->type_vid, NULL);
		}
		if (cls == NULL || result) {
			enter(rt->cc, NULL);
		}
	}
	return result;
}

/// Close a namespace; @see header
void ccExtEnd(state rt, symn cls, int mode) {
	if (cls != NULL) {
		symn fields = leave(rt->cc, cls, (mode & ATTR_stat) != 0);
		if (mode & 1) {
			fields->next = cls->flds;
		}
		cls->flds = fields;
	}
}
/// Close a namespace; @see state.api.ccEnd
void ccEnd(state rt, symn cls) {
	ccExtEnd(rt, cls, ATTR_stat);
}

/// Declare int constant; @see state.api.ccDefInt
symn ccDefInt(state rt, char* name, int64_t value) {
	if (!rt || !rt->cc || !name) {
		debug("%x, %s, %D", rt, name, value);
		return NULL;
	}
	name = mapstr(rt->cc, name, -1, -1);
	return install(rt->cc, name, TYPE_def, TYPE_int, 0, rt->cc->type_i32, intnode(rt->cc, value));
}
/// Declare float constant; @see state.api.ccDefFlt
symn ccDefFlt(state rt, char* name, double value) {
	if (!rt || !rt->cc || !name) {
		debug("%x, %s, %F", rt, name, value);
		return NULL;
	}
	name = mapstr(rt->cc, name, -1, -1);
	return install(rt->cc, name, TYPE_def, TYPE_flt, 0, rt->cc->type_f64, fltnode(rt->cc, value));
}
/// Declare string constant; @see state.api.ccDefStr
symn ccDefStr(state rt, char* name, char* value) {
	if (!rt || !rt->cc || !name) {
		debug("%x, %s, %s", rt, name, value);
		return NULL;
	}
	name = mapstr(rt->cc, name, -1, -1);
	if (value != NULL) {
		value = mapstr(rt->cc, value, -1, -1);
	}
	return install(rt->cc, name, TYPE_def, TYPE_str, 0, rt->cc->type_str, strnode(rt->cc, value));
}

/// Find symbol by name; @see header
symn ccFindSym(ccState cc, symn in, char* name) {
	struct astNode ast;
	memset(&ast, 0, sizeof(struct astNode));
	ast.kind = TYPE_ref;
	ast.ref.hash = rehash(name, -1);
	ast.ref.name = name;
	return lookup(cc, in ? in->flds : cc->s->defs, &ast, NULL, 1);
}

// TODO: to be removed
int ccSymValInt(symn sym, int* res) {
	struct astNode ast;
	if (sym && eval(&ast, sym->init)) {
		*res = (int)constint(&ast);
		return 1;
	}
	return 0;
}
// TODO: to be removed
int ccSymValFlt(symn sym, double* res) {
	struct astNode ast;
	if (sym && eval(&ast, sym->init)) {
		*res = constflt(&ast);
		return 1;
	}
	return 0;
}

/// Get symbol by offset; @see state.api.mapsym
symn mapsym(state rt, void* ptr) {
	ptrdiff_t offs = (unsigned char*)ptr - rt->_mem;
	symn sym = NULL;

	// TODO: symbols are saved to read only memory.
	if (offs < 0 || offs > rt->vm.pc) {
		debug("invalid offset: %06x", offs);
		return NULL;
	}
	for (sym = rt->gdef; sym; sym = sym->gdef) {
		if (sym->offs == offs) {
			return sym;
		}
	}

	return NULL;
}
//#}

//#{ emit opcodes
static int emitidx(state rt, vmOpcode opc, int arg) {
	stkval tmp;
	tmp.i8 = (int32_t)rt->vm.ss * vm_size - arg;

	switch (opc) {
		default:
			fatal("Error");
			break;

		case opc_dup1:
		case opc_dup2:
		case opc_dup4:
		case opc_set1:
		case opc_set2:
		case opc_set4:
			tmp.i8 /= vm_size;
			break;

		case opc_drop:
		case opc_ldsp:
			return emitarg(rt, opc, tmp);
	}

	if (tmp.i8 > vm_regs) {
		debug("opc_x%02x(%D(%d))", opc, tmp.i8, arg);
		return 0;
	}
	if (tmp.i8 > rt->vm.ss * vm_size) {
		debug("opc_x%02x(%D(%d))", opc, tmp.i8, arg);
		return 0;
	}
	return emitarg(rt, opc, tmp);
}
/// Emit an instruction without argument.
static int emitopc(state rt, vmOpcode opc) {
	stkval arg;
	arg.i8 = 0;
	return emitarg(rt, opc, arg);
}
/// Increment the top of stack.
static int emitinc(state rt, int arg) {
	return emitint(rt, opc_inc, arg);
}

// emiting constant values.
static inline int emiti32(state rt, int32_t arg) {
	stkval tmp;
	tmp.i8 = arg;
	return emitarg(rt, opc_ldc4, tmp);
}
static inline int emiti64(state rt, int64_t arg) {
	stkval tmp;
	tmp.i8 = arg;
	return emitarg(rt, opc_ldc8, tmp);
}
static inline int emitf32(state rt, float32_t arg) {
	stkval tmp;
	tmp.f4 = arg;
	return emitarg(rt, opc_ldcf, tmp);
}
static inline int emitf64(state rt, float64_t arg) {
	stkval tmp;
	tmp.f8 = arg;
	return emitarg(rt, opc_ldcF, tmp);
}
static inline int emitref(state rt, void* arg) {
	stkval tmp;
	tmp.i8 = vmOffset(rt, arg);
	return emitarg(rt, opc_ldcr, tmp);
}

/**
 * @brief emit the address of the variable.
 * @param rt Runtime context.
 * @param var Variable to be used.
 * @return Program counter.
 */
static inline int emitvar(state rt, symn var) {
	if (!var->stat) {
		return emitidx(rt, opc_ldsp, var->offs);
	}
	return emitint(rt, opc_ldcr, var->offs);
}
//#}

/**
 * @brief Generate bytecode from abstract syntax tree.
 * @param rt Runtime context.
 * @param ast Abstract syntax tree.
 * @param get Override node cast.
 * @return Should be get || cast of ast node.
 */
static ccToken cgen(state rt, astn ast, ccToken get) {
	#ifdef DEBUGGING
	ccToken stmt_qual = 0;
	#endif

	int ipdbg = 0;
	struct astNode tmp;
	ccToken ret = TYPE_any;

	dieif(ast == NULL, "Error");
	dieif(ast->type == NULL, "Error");

	if (get == TYPE_any)
		get = ast->cst2;

	if (!(ret = ast->type->cast))
		ret = ast->type->kind;

	#ifdef DEBUGGING
	// take care of qualified statements `static if` ...
	if (ast->kind >= STMT_beg && ast->kind <= STMT_end) {
		stmt_qual = ast->cst2;
	}
	#endif

	// generate code
	switch (ast->kind) {

		default:
			fatal("Error: %+k");
			return TYPE_any;

		//#{ STMT
		case STMT_do: {	// expr statement
			int stpos = stkoffs(rt, 0);
			ipdbg = emitopc(rt, markIP);
			if (!cgen(rt, ast->stmt.stmt, TYPE_vid)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (stpos > stkoffs(rt, 0)) {
				error(rt, ast->file, ast->line, "statement underflows stack: %+k", ast->stmt.stmt);
			}
		} break;
		case STMT_beg: {	// {} or function body
			astn ptr;
			int ippar = 0;
			int stpos = stkoffs(rt, 0);

			if (ast->cst2 == QUAL_par) {
				rt->vm.su = 0;
				ippar = emitopc(rt, opc_task);

				#ifdef DEBUGGING
				// qualifier processed
				stmt_qual = 0;
				#endif
			}
			for (ptr = ast->stmt.stmt; ptr; ptr = ptr->next) {
				ipdbg = emitopc(rt, markIP);
				if (!cgen(rt, ptr, TYPE_vid)) {		// we will free stack on scope close
					#if DEBUGGING > 2
					fputasm(rt, rt->logf, ipdbg, emitopc(rt, markIP), 0x119);
					#endif
					error(rt, ptr->file, ptr->line, "emmiting statement `%+k`", ptr);
				}
			}
			if (ast->cst2 == TYPE_rec) {
				debug("%t", get);
				get = TYPE_any;
			}
			if (get == TYPE_vid && stpos != stkoffs(rt, 0)) {
				// TODO: call destructor for variables
				if (!emitidx(rt, opc_drop, stpos)) {
					trace("error");
					return TYPE_any;
				}
			}
			if (ippar != 0) {
				fixjump(rt, ippar, emitopc(rt, markIP), rt->vm.su * vm_size);
				emitint(rt, opc_sync, 0);
				debug("parallel data on stack: %d", rt->vm.su);
			}
			ipdbg = 0;	// statement is not debugable
		} break;
		case STMT_if:  {
			int jmpt = 0, jmpf = 0;
			int stpos = stkoffs(rt, 0);
			int tt = eval(&tmp, ast->stmt.test);

			dieif(get != TYPE_vid, "Error");

			ipdbg = emitopc(rt, markIP);
			if (ast->cst2 == QUAL_sta) {
				if (ast->stmt.step || !tt) {
					error(rt, ast->file, ast->line, "invalid static if construct: %s", !tt ? "can not evaluate" : "else part is invalid");
					return TYPE_any;
				}
				#ifdef DEBUGGING
				// qualifier processed
				stmt_qual = 0;
				#endif
				ipdbg = 0;
			}

			if (tt && (rt->vm.opti || ast->cst2 == QUAL_sta)) {	// static if then else
				astn gen = constbol(&tmp) ? ast->stmt.stmt : ast->stmt.step;
				if (gen && !cgen(rt, gen, TYPE_any)) {	// leave the stack
					trace("%+k", gen);
					return TYPE_any;
				}
				// local declarations inside a static if grows the stack.
				stpos = stkoffs(rt, 0);
			}
			else {
				// hack: `if (true) sin(pi/4);` leaves the result of sin on stack
				// so, code will be generated as: if (true) { sin(pi/4); }
				struct astNode block;

				memset(&block, 0, sizeof(struct astNode));
				block.kind = STMT_beg;
				block.type = rt->cc->type_vid;

				if (ast->stmt.stmt && ast->stmt.step) {		// if then else
					if (!cgen(rt, ast->stmt.test, TYPE_bit)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					if (!(jmpt = emitopc(rt, opc_jz))) {
						trace("%+k", ast);
						return TYPE_any;
					}

					block.stmt.stmt = ast->stmt.stmt;
					if (!cgen(rt, &block, TYPE_vid)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					if (!(jmpf = emitopc(rt, opc_jmp))) {
						trace("%+k", ast);
						return TYPE_any;
					}
					fixjump(rt, jmpt, emitopc(rt, markIP), -1);

					block.stmt.stmt = ast->stmt.step;
					if (!cgen(rt, &block, TYPE_vid)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					fixjump(rt, jmpf, emitopc(rt, markIP), -1);
				}
				else if (ast->stmt.stmt) {							// if then
					if (!cgen(rt, ast->stmt.test, TYPE_bit)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					//~ if false skip THEN block
					//~ TODO: warn: never executed code
					if (!(jmpt = emitopc(rt, opc_jz))) {
						trace("%+k", ast);
						return TYPE_any;
					}

					block.stmt.stmt = ast->stmt.stmt;
					if (!cgen(rt, &block, TYPE_vid)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					fixjump(rt, jmpt, emitopc(rt, markIP), -1);
				}
				else if (ast->stmt.step) {							// if else
					if (!cgen(rt, ast->stmt.test, TYPE_bit)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					//~ if true skip ELSE block
					//~ TODO: warn: never executed code
					if (!(jmpt = emitopc(rt, opc_jnz))) {
						trace("%+k", ast);
						return TYPE_any;
					}

					block.stmt.stmt = ast->stmt.step;
					if (!cgen(rt, &block, TYPE_vid)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					fixjump(rt, jmpt, emitopc(rt, markIP), -1);
				}
				dieif(get != TYPE_vid || stpos != stkoffs(rt, 0), "internal fatal error");
			}
			//~ TODO: destruct(ast->stmt.test)
			dieif(stpos != stkoffs(rt, 0), "invalid stacksize(%d:%d) in statement %+k", stkoffs(rt, 0), stpos, ast);
		} break;
		case STMT_for: {
			astn jl = rt->cc->jmps;
			int jstep, lcont, lbody, lbreak;
			int stbreak, stpos = stkoffs(rt, 0);

			dieif(get != TYPE_vid, "Error");

			ipdbg = emitopc(rt, markIP);
			if (ast->stmt.init && !cgen(rt, ast->stmt.init, TYPE_vid)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!(jstep = emitopc(rt, opc_jmp))) {		// continue;
				trace("%+k", ast);
				return TYPE_any;
			}

			lbody = emitopc(rt, markIP);
			if (ast->stmt.stmt && !cgen(rt, ast->stmt.stmt, TYPE_vid)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			lcont = emitopc(rt, markIP);
			if (ast->stmt.step && !cgen(rt, ast->stmt.step, TYPE_vid)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			fixjump(rt, jstep, emitopc(rt, markIP), -1);
			if (ast->stmt.test) {
				if (!cgen(rt, ast->stmt.test, TYPE_bit)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				if (!emitint(rt, opc_jnz, lbody)) {		// continue;
					trace("%+k", ast);
					return TYPE_any;
				}
			}
			else {
				if (!emitint(rt, opc_jmp, lbody)) {		// continue;
					trace("%+k", ast);
					return TYPE_any;
				}
			}

			lbreak = emitopc(rt, markIP);
			stbreak = stkoffs(rt, 0);

			while (rt->cc->jmps != jl) {
				astn jmp = rt->cc->jmps;
				rt->cc->jmps = jmp->next;

				if (jmp->go2.stks != stbreak) {
					error(rt, jmp->file, jmp->line, "`%k` statement is invalid due to previous variable declaration within loop", jmp);
					return TYPE_any;
				}
				switch (jmp->kind) {
					default :
						error(rt, jmp->file, jmp->line, "invalid goto statement: %k", jmp);
						return TYPE_any;

					case STMT_brk:
						fixjump(rt, jmp->go2.offs, lbreak, jmp->go2.stks);
						break;

					case STMT_con:
						fixjump(rt, jmp->go2.offs, lcont, jmp->go2.stks);
						break;
				}
			}

			//~ TODO: destruct(ast->stmt.test)
			if (stpos != stkoffs(rt, 0)) {
				dieif(!emitidx(rt, opc_drop, stpos), "Error");
			}
		} break;
		case STMT_con:
		case STMT_brk: {
			int offs;
			dieif(get != TYPE_vid, "Error");
			ipdbg = emitopc(rt, markIP);
			if (!(offs = emitopc(rt, opc_jmp))) {
				trace("%+k", ast);
				return TYPE_any;
			}

			ast->go2.offs = offs;
			ast->go2.stks = stkoffs(rt, 0);

			ast->next = rt->cc->jmps;
			rt->cc->jmps = ast;
		} break;
		case STMT_ret: {
			//~ TODO: declared reference variables should be freed.
			int bppos = stkoffs(rt, 0);
			ipdbg = emitopc(rt, markIP);
			if (ast->stmt.stmt && !cgen(rt, ast->stmt.stmt, TYPE_vid)) {
				trace("%+k\n%7K", ast, ast);
				return TYPE_any;
			}
			dieif(get != TYPE_vid, "Error");
			if (get == TYPE_vid && rt->vm.ro != stkoffs(rt, 0)) {
				if (!emitidx(rt, opc_drop, rt->vm.ro)) {
					trace("leve %d", rt->vm.ro);
					return TYPE_any;
				}
			}
			if (!emitopc(rt, opc_jmpi)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			fixjump(rt, 0, 0, bppos);
		} break;
		//#}
		//#{ OPER
		case OPER_fnc: {	// '()' emit/call/cast
			int stktop = stkoffs(rt, 0);
			int stkret = stkoffs(rt, sizeOf(ast->type));
			astn argv = ast->op.rhso;
			symn var = linkOf(ast->op.lhso);

			dieif(var == NULL && ast->op.lhso != NULL, "Error %+k", ast);

			// debug(...)
			if (var && var == rt->cc->libc_dbg) {
				if (argv != NULL) {
					while (argv->kind == OPER_com) {
						astn arg = argv->op.rhso;

						if (!cgen(rt, arg, arg->cst2)) {
							trace("%+k", arg);
							return TYPE_any;
						}
						argv = argv->op.lhso;
					}
					if (!cgen(rt, argv, argv->cst2)) {
						trace("%+k", argv);
						return TYPE_any;
					}
				}
				//~ dieif(!emitref(rt, NULL), "__FUNC__");
				dieif(!emiti32(rt, ast->line), "__FILE__");
				dieif(!emitref(rt, ast->file), "__LINE__");
				dieif(!emitint(rt, opc_libc, rt->cc->libc_dbg->offs), "__LIBC__");
				dieif(!emitidx(rt, opc_drop, stkret), "__DROP__");
				break;
			}

			// inline
			if (var && var->kind == TYPE_def) {
				int chachedArgSize = 0;
				symn param = var->prms;

				if (argv != NULL) {
					astn an = NULL;

					// this is done by lookup... but...
					while (argv->kind == OPER_com) {
						astn arg = argv->op.rhso;
						argv = argv->op.lhso;

						arg->next = an;
						an = arg;
					}
					argv->next = an;
					an = argv;

					while (an && param) {
						int inlineArg = 0;
						astn arg = an;

						if (rt->vm.opti && eval(&tmp, arg)) {
							arg = &tmp;
						}

						if (param->cast == TYPE_def) {
							inlineArg = 1;
						}
						else if (an->kind == TYPE_str) {
							if (usedCnt(param) <= 1) {
								inlineArg = 1;
							}
						}
						else if (an->kind == TYPE_ref) {
							if (an->type == param->type) {
								// static variables should not be inlined ?
								// what about indirect references ?
								//~ if (!an->ref.link->stat)
								inlineArg = 1;
							}
						}

						if (inlineArg) {
							if (usedCnt(param) <= 1) {
								astn n = an;
								while (n && n->kind == TYPE_ref && n->ref.link && n->ref.link->kind == TYPE_def) {
									n = n->ref.link->init;
								}
								if (n) switch (n->kind) {
									case TYPE_ref:
										break;
									default:
										warn(rt, 15, ast->file, ast->line, "inlineing argument `%T` used more than once: %+k", param, n);
								}
							}
							param->kind = TYPE_def;
							param->init = an;
						}
						else {
							int stktop = stkoffs(rt, sizeOf(param));
							chachedArgSize += sizeOf(param);
							if (usedCnt(param) <= 1) {
								astn n = an;
								while (n && n->ref.link && n->ref.link->kind == TYPE_def) {
									n = n->ref.link->init;
								}
								if (n) switch (n->kind) {
									case TYPE_ref:
										warn(rt, 15, ast->file, ast->line, "caching argument used once or none: %-T = %+k", param, n);
										break;
									default:
										break;
								}
							}

							warn(rt, 16, ast->file, ast->line, "caching argument: %-T = %+k", param, arg);
							if (!cgen(rt, arg, param->cast)) {
								trace("%+k", arg);
								return TYPE_any;
							}
							param->offs = stkoffs(rt, 0);
							param->kind = TYPE_ref;
							if (stktop != param->offs) {
								error(rt, ast->file, ast->line, "invalid size: %d <> got(%d): `%+k`", stktop, param->offs, param);
								return TYPE_any;
							}
						}
						an = an->next;
						param = param->next;
					}
					dieif(an || param, "Error");
				}

				if (var->init) {
					var->init->file = ast->file;
					var->init->line = ast->line;
				}

				if (!(ret = cgen(rt, var->init, ret))) {
					trace("%+k", ast);
					return TYPE_any;
				}

				if (stkret != stkoffs(rt, 0)) {
					logif(chachedArgSize != stkoffs(rt, 0) - stkret, "%+T(%d%+d): %+k", ast->type, stkret, stkoffs(rt, 0)-stkret, ast);
					if (get != TYPE_vid) {
						if (!emitidx(rt, opc_ldsp, stkret)) {	// get stack
							trace("error");
							return TYPE_any;
						}
						if (!emitint(rt, opc_sti, sizeOf(ast->type))) {
							error(rt, ast->file, ast->line, "store indirect: %T:%d of `%+k`", ast->type, sizeOf(ast->type), ast);
							return TYPE_any;
						}
					}
					if (stkret < stkoffs(rt, 0)) {
						if (!emitidx(rt, opc_drop, stkret)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}
				}

				for (param = var->prms; param; param = param->next) {
					param->kind = TYPE_ref;
					param->init = NULL;
				}
				break;
			}

			// push Result, Arguments
			if (var && !istype(var) && var != rt->cc->emit_opc && var->call) {
				if (sizeOf(var->type) && !emitint(rt, opc_spc, sizeOf(var->type))) {
					trace("%+k", ast);
					return TYPE_any;
				}
				// result size on stack
				dieif(stkret != stkoffs(rt, 0), "Error");
			}
			if (argv != NULL) {
				astn argl = NULL;

				while (argv->kind == OPER_com) {
					astn arg = argv->op.rhso;
					if (!cgen(rt, arg, arg->cst2)) {
						trace("%+k", arg, arg->cst2);
						return TYPE_any;
					}
					arg->next = argl;
					argl = arg;
					argv = argv->op.lhso;
				}

				if (var == rt->cc->emit_opc && isType(argv)) {
					#if defined DEBUGGING && DEBUGGING > 5
					debug("static casting with emit: %+k @(%s: %d)", ast, ast->file, ast->line);
					#endif
					break;
				}

				if (!cgen(rt, argv, argv->cst2)) {
					trace("%+k", argv);
					return TYPE_any;
				}

				if (var && var != rt->cc->emit_opc && var != rt->cc->libc_dbg && var->call && var->cast != TYPE_ref) {
					if (var->prms->offs != stkoffs(rt, 0) - stktop) {
						trace("args:%T(%d != %d(%d - %d))", var, var->prms->offs, stkoffs(rt, 0) - stktop, stkoffs(rt, 0), stktop);
						return TYPE_any;
					}
				}
				argv->next = argl;
				argl = argv;
			}

			if (var == rt->cc->emit_opc) {		// emit()
			}
			else if (istype(var)) {				// cast()
				if (!argv || argv != ast->op.rhso) {
					warn(rt, 1, ast->file, ast->line, "multiple values, array ?: '%+k'", ast);
				}
			}
			else if (var) {						// call()
				if (var->call) {
					if (!cgen(rt, ast->op.lhso, TYPE_ref)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					if (!emitopc(rt, opc_call)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					// clean the stack
					if (stkret != stkoffs(rt, 0)) {
						if (!emitidx(rt, opc_drop, stkret)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}
				}
				else {
					error(rt, ast->file, ast->line, "called object is not a function: %+T", var);
					return TYPE_any;
				}
			}
			else {								// ()
				dieif(ast->op.lhso != NULL, "Error %+k", ast);
				if (!argv || argv != ast->op.rhso) {
					warn(rt, 1, ast->file, ast->line, "multiple values, array ?: '%+k'", ast);
				}
			}
		} break;
		case OPER_idx: {	// '[]'
			int r;
			if (!(r = cgen(rt, ast->op.lhso, TYPE_ref))) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (r == TYPE_arr) {
				if (!emitint(rt, opc_ldi, vm_size)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}

			if (rt->vm.opti && eval(&tmp, ast->op.rhso) == TYPE_int) {
				int offs = sizeOf(ast->type) * (int)constint(&tmp);
				if (!emitinc(rt, offs)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}
			else {
				int size = sizeOf(ast->type);	// size of array element
				if (!cgen(rt, ast->op.rhso, TYPE_u32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				if (size > 1) {
					if (!emitint(rt, opc_mad, size)) {
						trace("%+k", ast);
						return TYPE_any;
					}
				}
				else if (size == 1) {
					if (!emitopc(rt, i32_add)) {
						trace("%+k", ast);
						return TYPE_any;
					}
				}
				else {
					fatal("invalid array element size");
					return TYPE_any;
				}
			}

			if (get == TYPE_ref)
				return TYPE_ref;

			// ve need the value on that position (this can be a ref).
			if (!emitint(rt, opc_ldi, sizeOf(ast->type))) {
				trace("%+k", ast);
				return TYPE_any;
			}
		} break;
		case OPER_dot: {	// '.'
			// TODO: this should work as indexing
			symn var = linkOf(ast->op.rhso);
			int lhsstat = isType(ast->op.lhso);

			if (!var) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!var->stat && lhsstat) {
				error(rt, ast->file, ast->line, "An object reference is required to access the member `%+T`", var);
				return TYPE_any;
			}
			if (var->stat) {
				if (!lhsstat) {
					warn(rt, 5, ast->file, ast->line, "Member `%+T` is accessed with an instance reference", var);
				}
				return cgen(rt, ast->op.rhso, get);
			}

			if (var->memb) {
				if (!cgen(rt, ast->op.lhso, TYPE_ref)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return cgen(rt, ast->op.rhso, get);
			}
			if (var->kind == TYPE_def) {
				// static array length is of this type
				trace("%+T: %t", var, get);
				return cgen(rt, ast->op.rhso, get);
			}

			if (!cgen(rt, ast->op.lhso, TYPE_ref)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!emitinc(rt, var->offs)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (var->cast == TYPE_ref/* && ast->cast == TYPE_ref*/) {
				if (!emitint(rt, opc_ldi, vm_size)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}

			if (get == TYPE_ref) {
				return TYPE_ref;
			}

			if (!emitint(rt, opc_ldi, sizeOf(ast->type))) {
				trace("%+k", ast);
				return TYPE_any;
			}
		} break;

		case OPER_not:		// '!'
		case OPER_adr:		// '&'
		case OPER_pls:		// '+'
		case OPER_mns:		// '-'
		case OPER_cmt: {	// '~'
			vmOpcode opc = -1;
			switch (ast->kind) {
				default:
					fatal("Error");
					return TYPE_any;

				case OPER_adr:
				case OPER_pls:
					return cgen(rt, ast->op.rhso, get);

				case OPER_mns:
					opc = opc_neg;
					break;
				case OPER_not:
					dieif(ret != TYPE_bit, "Error");
					opc = opc_not;
					break;
				case OPER_cmt:
					opc = opc_cmt;
					break;
			}
			if (!cgen(rt, ast->op.rhso, ret)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (!emitint(rt, opc, ret)) {
				trace("%+k", ast);
				return TYPE_any;
			}
		} break;

		case OPER_shl:		// '>>'
		case OPER_shr:		// '<<'
		case OPER_and:		// '&'
		case OPER_ior:		// '|'
		case OPER_xor:		// '^'

		case OPER_equ:		// '=='
		case OPER_neq:		// '!='
		case OPER_lte:		// '<'
		case OPER_leq:		// '<='
		case OPER_gte:		// '>'
		case OPER_geq:		// '>='

		case OPER_add:		// '+'
		case OPER_sub:		// '-'
		case OPER_mul:		// '*'
		case OPER_div:		// '/'
		case OPER_mod: {	// '%'
			int opc = -1;
			switch (ast->kind) {
				default:
					fatal("Error");
					return TYPE_any;

				case OPER_add: opc = opc_add; break;
				case OPER_sub: opc = opc_sub; break;
				case OPER_mul: opc = opc_mul; break;
				case OPER_div: opc = opc_div; break;
				case OPER_mod: opc = opc_mod; break;

				case OPER_neq: opc = opc_cne; break;
				case OPER_equ: opc = opc_ceq; break;
				case OPER_geq: opc = opc_cge; break;
				case OPER_lte: opc = opc_clt; break;
				case OPER_leq: opc = opc_cle; break;
				case OPER_gte: opc = opc_cgt; break;

				case OPER_shl: opc = opc_shl; break;
				case OPER_shr: opc = opc_shr; break;
				case OPER_and: opc = opc_and; break;
				case OPER_ior: opc = opc_ior; break;
				case OPER_xor: opc = opc_xor; break;
			}
			if (!cgen(rt, ast->op.lhso, TYPE_any)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (!cgen(rt, ast->op.rhso, TYPE_any)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (!emitint(rt, opc, ast->op.lhso->cst2)) {	// uint % int => u32.mod
				trace("opc__%02x:%+k", opc, ast);
				return TYPE_any;
			}

			#ifdef DEBUGGING
			// these must be true
			dieif(ast->op.lhso->cst2 != ast->op.rhso->cst2, "RemMe", ast);
			dieif(ret != castOf(ast->type), "RemMe");
			switch (ast->kind) {
				case OPER_neq:
				case OPER_equ:
				case OPER_geq:
				case OPER_lte:
				case OPER_leq:
				case OPER_gte:
					dieif(ret != TYPE_bit, "RemMe(%t): %+7K", ret, ast);
				default:
					break;
			}
			#endif
		} break;

		case OPER_lnd:		// '&&'
		case OPER_lor: {	// '||'
			vmOpcode opc = -1;
			// TODO: short circuit && and ||
			switch (ast->kind) {
				default:
					fatal("Error");
					return TYPE_any;

				case OPER_lnd:
					opc = opc_and;
					break;
				case OPER_lor:
					opc = opc_ior;
					break;
			}

			if (!cgen(rt, ast->op.lhso, TYPE_bit)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!cgen(rt, ast->op.rhso, TYPE_bit)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!emitint(rt, opc, TYPE_u32)) {
				trace("opc__%02x:%+k", opc, ast);
				return TYPE_any;
			}

			/*astn jmp1 = 0, jmp2 = 0;
			switch (ast->kind) {
				default:
					fatal("Error");
					return 0;

				case OPER_lnd:
					jmp1 = newnode(rt->cc, STMT_brk);
					jmp2 = newnode(rt->cc, STMT_brk);
					opc = opc_jnz;
					break;

				case OPER_lor:
					jmp1 = newnode(rt->cc, STMT_con);
					jmp2 = newnode(rt->cc, STMT_con);
					opc = opc_jz;
					break;
			}

			if (!cgen(rt, ast->op.lhso, TYPE_bit)) {
				trace("%+k", ast);
				return 0;
			}
			jmp1->go2.offs = emitopc(rt, opc);
			jmp1->go2.stks = stkoffs(rt, 0);
			jmp1->next = rt->cc->jmps;
			rt->cc->jmps = jmp1;

			if (!cgen(rt, ast->op.rhso, TYPE_bit)) {
				trace("%+k", ast);
				return 0;
			}
			jmp2->go2.offs = emitopc(rt, opc);
			jmp2->go2.stks = stkoffs(rt, 0);
			jmp2->next = rt->cc->jmps;
			rt->cc->jmps = jmp2;
			// */

			#ifdef DEBUGGING
			if (rt->cc->warn > 0) {
				static int firstTimeShowOnly = 1;
				if (firstTimeShowOnly) {
					warn(rt, 1, ast->file, ast->line, "operators `&&` and `||` does not short-circuit yet", ast);
					firstTimeShowOnly = 0;
				}
			}
			// these must be true
			//~ dieif(ast->op.lhso->cst2 != ast->op.rhso->cst2, "RemMe");
			dieif(ast->op.lhso->cst2 != TYPE_bit, "RemMe");
			dieif(ast->op.lhso->cst2 != TYPE_bit, "RemMe");
			dieif(ret != castOf(ast->type), "RemMe");
			dieif(ret != TYPE_bit, "RemMe");
			#endif
		} break;
		case OPER_sel: {	// '?:'
			int jmpt, jmpf;
			if (rt->vm.opti && eval(&tmp, ast->op.test)) {
				if (!cgen(rt, constbol(&tmp) ? ast->op.lhso : ast->op.rhso, TYPE_any)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}
			else {
				int bppos = stkoffs(rt, 0);

				if (!cgen(rt, ast->op.test, TYPE_bit)) {
					trace("%+k", ast);
					return TYPE_any;
				}

				if (!(jmpt = emitopc(rt, opc_jz))) {
					trace("%+k", ast);
					return TYPE_any;
				}

				if (!cgen(rt, ast->op.lhso, TYPE_any)) {
					trace("%+k", ast);
					return TYPE_any;
				}

				if (!(jmpf = emitopc(rt, opc_jmp))) {
					trace("%+k", ast);
					return TYPE_any;
				}

				fixjump(rt, jmpt, emitopc(rt, markIP), bppos);

				if (!cgen(rt, ast->op.rhso, TYPE_any)) {
					trace("%+k", ast);
					return TYPE_any;
				}

				fixjump(rt, jmpf, emitopc(rt, markIP), -1);
			}
		} break;

		case ASGN_set: {	// ':='
			// TODO: ast->type->size;
			int size = sizeOf(ast->type);
			int refAssign = TYPE_ref;

			if (ast->op.lhso->kind == TYPE_ref) {
				symn typ = ast->op.lhso->type;
				//~ symn var = ast->op.lhso->ref.link;
				if (typ->kind == TYPE_rec && typ->cast == TYPE_ref) {
					trace("reference assignment: %+k", ast);
					dieif(ret != TYPE_ref, "Error");
					refAssign = ASGN_set;
					size = vm_size;
				}
			}

			if (!cgen(rt, ast->op.rhso, ret)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (get != TYPE_vid) {
				/* TODO: int &a = b = 9;
				in case when: int &a = b = 9;
				dieif(get == TYPE_ref, "Error");
				*/
				// in case a = b = sum(2, 700);
				// dupplicate the result
				if (!emitint(rt, opc_ldsp, 0)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				if (!emitint(rt, opc_ldi, size)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}
			else {
				ret = get;
			}

			if (!cgen(rt, ast->op.lhso, refAssign)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (!emitint(rt, opc_sti, size)) {
				trace("%+k", ast);
				return TYPE_any;
			}
		} break;
		//#}
		//#{ TVAL
		case TYPE_int: switch (get) {
			default:
				error(rt, ast->file, ast->line, "invalid cast of `%+k:`", ast);
				debug("invalid cast: to (%t) '%+k'", get, ast);
				return TYPE_any;

			case TYPE_vid:
				// void(0);
				return TYPE_vid;

			case TYPE_bit:
				if (!emiti32(rt, ast->con.cint != 0)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_u32;

			case TYPE_u32:
			case TYPE_i32:
				if (!emiti32(rt, (int32_t)ast->con.cint)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				ret = TYPE_i32;
				break;
				//~ return TYPE_i32;//TODO: get?

			case TYPE_i64:
				if (!emiti64(rt, (int64_t)ast->con.cint)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_i64;

			case TYPE_f32:
				if (!emitf32(rt, (float32_t)ast->con.cint)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_f32;

			case TYPE_f64:
				if (!emitf64(rt, (float64_t)ast->con.cint)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_f64;

		} break;
		case TYPE_flt: switch (get) {
			default:
				error(rt, ast->file, ast->line, "invalid cast of `%+k:`", ast);
				debug("invalid cast: to (%t) '%+k'", get, ast);
				return TYPE_any;

			case TYPE_vid:
				// void(0.15);
				return TYPE_vid;

			case TYPE_bit:
				if (!emiti32(rt, ast->con.cflt != 0.)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_u32;

			case TYPE_u32:
			case TYPE_i32:
				if (!emiti32(rt, (int32_t)ast->con.cflt)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_i32;//TODO: get?

			case TYPE_i64:
				if (!emiti64(rt, (int64_t)ast->con.cflt)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_i64;

			case TYPE_f32:
				if (!emitf32(rt, (float32_t)ast->con.cflt)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_f32;

			case TYPE_f64:
				if (!emitf64(rt, (float64_t)ast->con.cflt)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_f64;

		} break;
		case TYPE_str: switch (get) {
			default:
				error(rt, ast->file, ast->line, "invalid cast of `%+k:`", ast);
				debug("invalid cast: to (%t) '%+k'", get, ast);
				return TYPE_any;

			case TYPE_vid:
				// void("");
				return TYPE_vid;

			case TYPE_ref:
				if (!emitref(rt, ast->ref.name)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_ref;

			case TYPE_arr:
				if (!emiti32(rt, strlen(ast->ref.name))) {
					trace("%+k", ast);
					return TYPE_any;
				}
				if (!emitref(rt, ast->ref.name)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return TYPE_ref;
		} break;

		case TYPE_ref: {					// use (var, func, enum, define)
			symn typ = ast->type;			// type
			symn var = ast->ref.link;		// link
			// TODO: ast->type->size;
			int size = sizeOf(typ);

			dieif(typ == NULL, "Error");
			dieif(var == NULL, "Error");

			if (get == ENUM_kwd) {
				trace("%+k", ast);
			}

			switch (var->kind) {
				default:
					error(rt, ast->file, ast->line, "invalid rvalue `%+k:` %t", ast, var->kind);
					return TYPE_any;

				case TYPE_arr:		// typename
				case TYPE_rec:		// typename
				case TYPE_ref: {	// variable
					ccToken retarr = TYPE_any;
					logif(var->size == 0, "invalid use of variable(%s:%d): `%-T`", ast->file, ast->line, var);

					// a slice is needed, push length first.
					if (get == TYPE_arr && ret != TYPE_arr) {
						// ArraySize
						if (!emiti32(rt, typ->offs)) {
							trace("%+k", ast);
							return TYPE_any;
						}
						retarr = TYPE_arr;
						get = TYPE_ref;
					}

					if (!emitvar(rt, var)) {
						trace("%+k", ast);
						return TYPE_any;
					}

					// byVal references are assigned by value
					// byRef references are assigned by reference
					if (get == ASGN_set) {
						get = TYPE_ref;
					}
					//TODO: else if (var != typ && (var->cast == TYPE_ref || var->cast == TYPE_arr)) {
					else if (var->cast == TYPE_ref && var != typ) {
						if (!emitint(rt, opc_ldi, vm_size)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}

					if (get != TYPE_ref) {
						if (get == TYPE_arr && ret == TYPE_arr) {
							//~ info(rt, ast->file, ast->line, "assign to array from %t @ %k", ret, ast);
							size = 8;
						}

						if (!emitint(rt, opc_ldi, size)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}
					else {
						if (var->cast == TYPE_arr) {
							//~ info(rt, __FILE__, __LINE__, "assign to array from %t @ %k", ret, ast);
							retarr = TYPE_arr;
						}
						ret = TYPE_ref;
					}

					if (retarr != 0) {
						ret = get = retarr;
					}
				} break;
				case EMIT_opc:
					dieif(get == TYPE_ref, "Error");
					if (!emitint(rt, var->offs, var->init ? constint(var->init) : 0)) {
						error(rt, ast->file, ast->line, "error emiting opcode: %+k", ast);
						if (stkoffs(rt, 0) > 0) {
							info(rt, ast->file, ast->line, "%+k underflows stack.", ast);
						}
						return TYPE_any;
					}
					return TYPE_vid;

				case TYPE_def:
					//~ TODO: reimplement: it works, but ...
					if (var->init != NULL) {
						//*?
						if (get == ENUM_kwd) {
							get = var->type->type->cast;
						}// */
						return cgen(rt, var->init, get);
					}
			}
		} break;
		case TYPE_def: {					// new (var, func, define)
			symn typ = ast->type;
			symn var = ast->ref.link;
			int size = padded(sizeOf(var), vm_size);
			int stktop = stkoffs(rt, size);

			dieif(typ == NULL, "Error");
			dieif(var == NULL, "Error");

			ipdbg = emitopc(rt, markIP);
			if (var->kind == TYPE_ref) {

				// skip initialized static function variables
				if (var->init && var->offs && !rt->cc->init) {
					return TYPE_vid;
				}

				// initialize (and allocate local) variables.
				if (var->init != NULL) {
					astn val = var->init;

					// ... a = emit(...);	// initialization with emit
					if (val->type == rt->cc->emit_opc) {
						ret = get;
					}

					// string a = null;		// initialization with null
					else if (rt->cc->null_ref == linkOf(val)) {
						trace("assigning null: %-T", var);
						val->cst2 = ret = TYPE_ref;
					}

					// int a(int x) = abs;	// reference initialization
					else if (var->call || var->cast == TYPE_ref) {
						ret = TYPE_ref;
					}

					// int a[3] = {1,2,3};	// array initialization by elements
					// FIXME: if valuetype is arrays base type
					if (typ->kind == TYPE_arr && var->prms == val->type) {
						int i, esize;
						symn base = typ;
						astn tmp = NULL;
						int nelem = 1;
						int ninit = 0;

						// TODO: base should not be stored in var->args !!!
						while (base && base != var->prms) {
							if (base->init == NULL) {
								break;
							}
							// ArraySize
							nelem *= base->offs;
							base = base->type;
						}
						if (base == NULL) {
							base = typ;
						}

						dieif(!base, "Error %+k", ast);

						ret = base->cast;
						esize = sizeOf(base);

						// int a[8] = {0, ...};
						while (val->kind == OPER_com) {
							// stringify the initializers
							val->op.rhso->next = tmp;
							tmp = val->op.rhso;
							val = val->op.lhso;
						}
						val->next = tmp;

						// local variable
						if (var->offs == 0) {
							if (!emitint(rt, opc_spc, size)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							i = padded(esize, vm_size);		// size of one element on stack
						}
						else {
							i = 0;
							size = 0;
						}

						for (tmp = val; val && ninit < nelem; ninit += 1, i += esize, val = val->next) {
							tmp = val;
							if (!cgen(rt, tmp, ret)) {
								trace("%+k", tmp);
								return TYPE_any;
							}

							if (var->offs == 0) {
								if (!emitint(rt, opc_ldsp, i)) {
									trace("%+k", ast);
									return TYPE_any;
								}
							}
							else {
								if (!emitvar(rt, var)) {
									trace("%+k", ast);
									return TYPE_any;
								}
								if (!emitinc(rt, i)) {
									trace("%+k", ast);
									return TYPE_any;
								}
							}

							if (!emitint(rt, opc_sti, esize)) {
								trace("%+k", ast);
								return TYPE_any;
							}
						}

						if (ninit < nelem) {
							int loopCpy;
							int valOffs = 0;
							int dstOffs = 0;
							int stkOffs = stkoffs(rt, 0);

							// push val
							// push dst

							if (!cgen(rt, tmp, ret)) {
								trace("%+k", tmp);
								return TYPE_any;
							}
							valOffs = stkoffs(rt, 0);

							if (var->offs == 0) {
								if (!emitint(rt, opc_ldsp, i - esize)) {
									trace("%+k", ast);
									return TYPE_any;
								}
							}
							else {
								if (!emitvar(rt, var)) {
									trace("%+k", ast);
									return TYPE_any;
								}
								if (!emitinc(rt, i - esize)) {
									trace("%+k", ast);
									return TYPE_any;
								}
							}

							// push end
							// push dst
							if (!emitint(rt, opc_dup1, 0)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitinc(rt, esize * (nelem - ninit))) {
								trace("%+k", ast);
								return TYPE_any;
							}

							if (!emitint(rt, opc_dup1, 1)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							//~ :loopCopy
							loopCpy = emitopc(rt, markIP);
							dstOffs = stkoffs(rt, 0);
							//~ inc dst, size
							//~ dupp val
							//~ dupp dst
							//~ sti size
							if (!emitinc(rt, esize)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							if (!emitidx(rt, opc_ldsp, valOffs)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitint(rt, opc_ldi, esize)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							if (!emitidx(rt, opc_dup1, dstOffs)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							if (!emitint(rt, opc_sti, esize)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							//~ dupp.x2
							//~ clt.i32
							//~ jnz loopCopy
							if (!emitint(rt, opc_dup2, 0)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitopc(rt, i32_cgt)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitint(rt, opc_jnz, loopCpy)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitidx(rt, opc_drop, stkOffs)) {
								trace("%+k", ast);
								return TYPE_any;
							}
						}

						if (val != NULL) {
							error(rt, ast->file, ast->line, "Too many initializers: starting at `%+k`", val);
							return TYPE_any;
						}
					}

					// int a = 99;	// variable initialization
					else {
						logif(val->cst2 != var->cast, "cast error (%t : %t: get: %t): %+k", val->cst2, var->cast, get, val);
						switch (val->kind) {
							case TYPE_int:
							case TYPE_flt:
								val->type = var->type;
							default:
								break;
						}
						if (!cgen(rt, val, var->cast)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}

					if (var->offs == 0) {		// create local variable
						var->offs = stkoffs(rt, 0);
						if (stktop != var->offs) {
							error(rt, ast->file, ast->line, "invalid initializer size: %d diff(%d): `%+k`", stktop, stktop - var->offs, ast);
							return TYPE_any;
						}
					}
					else if (size > 0) {		// initialize gloabal
						if (!emitvar(rt, var)) {
							trace("%+k", ast);
							return TYPE_any;
						}
						if (!emitint(rt, opc_sti, size)) {
							trace("%+k:sizeof(%-T) = %d", ast, var, size);
							return TYPE_any;
						}
					}
				}

				// alloc locally a block of the size of the type;
				else if (var->offs == 0) {
					logif(var->size != sizeOf(typ), "Error %T(%d, %d)", var, var->size, sizeOf(typ));
					if (!emitint(rt, opc_spc, size)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					var->offs = stkoffs(rt, 0);
					if (var->offs < size) {
						error(rt, ast->file, ast->line, "stack underflow", var->offs, size);
						return TYPE_any;
					}
				}
				else {
					// static uninitialized variable
				}
			}

			dieif(get != TYPE_vid, "Error");
			get = ret = TYPE_vid;
		} break;

		case EMIT_opc:
			trace("%+k", ast);
			return TYPE_any;
		//#}
	}

	// generate cast
	if (get != ret) switch (get) {

		case TYPE_vid:
			ret = get;
			break;

		case TYPE_any: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_vid:
			case TYPE_ref:
				break;
		} break;

		case TYPE_bit: switch (ret) {		// to boolean
			default:
				goto errorcast2;

			case TYPE_u32:
			case TYPE_i32:
				if (!emitopc(rt, i32_bol)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_i64:
				if (!emitopc(rt, i64_bol)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f32:
				if (!emitopc(rt, f32_bol)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f64:
				if (!emitopc(rt, f64_bol)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
		} break;

		case TYPE_u32: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_bit:
			case TYPE_i32:
				break;

			case TYPE_i64: {
				if (!emitopc(rt, i64_i32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			} break;
			//~ case TYPE_f32: if (!emitopc(s, f32_i32)) return TYPE_any; break;
			//~ case TYPE_f64: if (!emitopc(s, f64_i32)) return TYPE_any; break;
		} break;

		case TYPE_i32: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_bit:
			//~ case TYPE_any:
			case TYPE_u32:
				break;
			case TYPE_i64:
				if (!emitopc(rt, i64_i32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f32:
				if (!emitopc(rt, f32_i32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f64:
				if (!emitopc(rt, f64_i32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			//~ case TYPE_ref: if (!emitopc(s, opc_ldi, vm_size)) return TYPE_any; break;
		} break;

		case TYPE_i64: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_bit:
			case TYPE_u32:
				if (!emitopc(rt, u32_i64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_i32:
				if (!emitopc(rt, i32_i64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f32:
				if (!emitopc(rt, f32_i64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f64:
				if (!emitopc(rt, f64_i64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			//~ case TYPE_ref: if (!emitopc(s, opc_ldi, 8)) return TYPE_any; break;
		} break;

		case TYPE_f32: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_bit:
			//~ case TYPE_u32:
			case TYPE_i32:
				if (!emitopc(rt, i32_f32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_i64:
				if (!emitopc(rt, i64_f32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f64:
				if (!emitopc(rt, f64_f32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			//~ case TYPE_ref: if (!emitopc(s, opc_ldi, vm_size)) return TYPE_any; break;
		} break;

		case TYPE_f64: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_bit:
			//~ case TYPE_u32:
			case TYPE_i32:
				if (!emitopc(rt, i32_f64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_i64:
				if (!emitopc(rt, i64_f64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f32:
				if (!emitopc(rt, f32_f64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			//~ case TYPE_ref: if (!emitopc(s, opc_ldi, 8)) return 0; break;
		} break;

		case TYPE_ref:
		case TYPE_arr: switch (ret) {
			default:
				goto errorcast2;

			case EMIT_opc:
				return EMIT_opc;
		}

		case TYPE_ptr: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_ref:
				return TYPE_ptr;
		}

		default:
			fatal("%d: unimplemented(cast for `%+k`, %t):%t", ast->line, ast, get, ret);
			// fall to next case

		errorcast2:
			trace("cgen[%t->%t](%+k)\n%7K", ret, get, ast, ast);
			return TYPE_any;
	}

	// zero extend ...
	if (get == TYPE_u32) {
		trace("zero extend: to (%k)[%t->%t] '%-T'", ast, ret, get, ast->type);
		switch (ast->type->size) {
			default:
				fatal("Error");
				break;

			case 1:
				if (!emitint(rt, b32_bit, b32_bit_and | 8)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;

			case 2:
				if (!emitint(rt, b32_bit, b32_bit_and | 16)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;

			case 4:
				break;
		}
	}

	// add debug information
	if (rt->dbg != NULL && ipdbg > 0) {
		int ipEnd = emitopc(rt, markIP);
		if (ipdbg < ipEnd) {
			addCodeMapping(rt, ast, ipdbg, ipEnd);
		}
	}

	#ifdef DEBUGGING
	logif(stmt_qual != 0, "unimplemented qualified statement `%+k`: %t", ast, stmt_qual);
	#endif

	return ret;
}

int gencode(state rt, int mode) {
	ccState cc = rt->cc;
	int Lmain, Lmeta;

	// make global variables static ?
	int gstat = (mode & cgen_glob) == 0;

	dieif(rt->errc, "can not generate code");
	dieif(cc == NULL, "compiler state invalid");

	// leave the global scope.
	rt->defs = leave(rt->cc, NULL, gstat);

	/* reorder the initialization of static variables and functions.
	 * TODO: optimize code.
	 *
	 *	ex: g must be generated before f
	 *	int f() {
	 *		static int g = 9;
	 *		// ...
	 *	}
	 */
	if (rt->gdef != NULL) {
		symn ng, pg = NULL;

		for (ng = rt->gdef; ng; ng = ng->gdef) {
			symn Ng, Pg = NULL;

			for (Ng = ng; Ng; Ng = Ng->gdef) {
				if (Ng->decl == ng) {
					break;
				}
				Pg = Ng;
			}

			//~ this must be generated before sym;
			if (Ng) {
				Pg->gdef = Ng->gdef;	// remove
				Ng->gdef = ng;
				if (pg) {
					pg->gdef = Ng;
				}
				else {
					rt->gdef = Ng;
					break;
				}
				ng = pg;
			}
			pg = ng;
		}
	}

	// used memeory by metadata (string constants and typeinfos)
	Lmeta = rt->_beg - rt->_mem;

	// libcalls
	if (cc->libc != NULL) {
		libc lc, calls;

		calls = (libc)(rt->_beg = paddptr(rt->_beg, sizeof(void*)));
		rt->_beg += sizeof(struct libc) * (cc->libc->pos + 1);
		dieif(rt->_beg >= rt->_end, "memory overrun");

		for (lc = cc->libc; lc; lc = lc->next) {
			calls[lc->pos] = *lc;
		}

		rt->vm.libv = calls;
	}

	// debuginfo
	if (mode & cgen_info) {
		rt->dbg = (dbgState)(rt->_beg = paddptr(rt->_beg, sizeof(void*)));
		rt->_beg += sizeof(struct dbgStateRec);

		dieif(rt->_beg >= rt->_end, "memory overrun");
		memset(rt->dbg, 0, sizeof(struct dbgStateRec));

		initBuff(&rt->dbg->codeMap, 128, sizeof(struct dbgInfo));
	}

	//~ read only memory ends here.
	//~ strings, typeinfos, TODO(constants, functions, enums, ...)
	rt->vm.ro = rt->_beg - rt->_mem;

	// TODO: generate functions first
	rt->vm.opti = mode & cgen_opti;

	// static vars & functions
	if (rt->defs != NULL) {
		symn var = rt->defs;

		// we will append the list of declarations here.
		astn staticinitializers = newnode(cc, STMT_beg);

		// generate global and static variables & functions
		for (var = rt->gdef; var; var = var->gdef) {

			if (var == rt->cc->null_ref)
				continue;

			if (var->kind != TYPE_ref)
				continue;

			if (!var->stat)
				continue;

			dieif(var->kind != TYPE_ref, "Error");

			if (var->call && var->cast != TYPE_ref) {
				int seg = emitopc(rt, markIP);

				if (!var->init) {
					debug("`%T` will be skipped", var);
					continue;
				}

				rt->cc->init = 0;
				rt->vm.sm = 0;
				fixjump(rt, 0, 0, vm_size + var->offs);
				rt->vm.ro = stkoffs(rt, 0);
				rt->vm.sm = rt->vm.ss;		// leave return address on stack

				var->offs = emitopc(rt, markIP);

				if (!cgen(rt, var->init, TYPE_vid)) {
					continue;
				}
				if (!emitopc(rt, opc_jmpi)) {
					error(rt, var->file, var->line, "error emiting function: %-T", var);
					continue;
				}
				while (cc->jmps) {
					error(rt, NULL, 0, "invalid jump: `%k`", cc->jmps);
					cc->jmps = cc->jmps->next;
				}
				var->size = emitopc(rt, markIP) - seg;
				var->init = NULL;
				var->stat = 1;
			}
			else {
				dieif(var->offs != 0, "Error %-T", var);
				logif(var->size != sizeOf(var), "size error: %-T: %d / %d", var, var->size, sizeOf(var));
				var->size = sizeOf(var);

				// align the memory of the variable. speeding up the read and write of it.
				rt->_beg = paddptr(rt->_beg, sizeof(void*));
				var->offs = vmOffset(rt, rt->_beg);
				rt->_beg += var->size;

				dieif(rt->_beg >= rt->_end, "Error");

				if (var->init != NULL) {
					astn init = newnode(cc, TYPE_def);

					if (var->cnst && !isConst(var->init)) {
						warn(rt, 1, var->file, var->line, "non constant initialization of static variable `%-T`", var);
					}

					//~ make initialization from initializer
					init->type = var->type;
					init->file = var->file;
					init->line = var->line;
					init->cst2 = var->cast;
					init->ref.link = var;

					init = opnode(cc, STMT_do, NULL, init);
					init->type = cc->type_vid;
					init->file = var->file;
					init->line = var->line;

					if (staticinitializers->list.head == NULL) {
						staticinitializers->list.head = init;
					}
					else {
						staticinitializers->list.tail->next = init;
					}
					staticinitializers->list.tail = init;
				}
			}
		}

		// initialize static non global variables
		if (staticinitializers && staticinitializers->list.tail) {
			dieif(cc->root == NULL || cc->root->kind != STMT_beg, "Error");
			staticinitializers->list.tail->next = cc->root->stmt.stmt;
			cc->root->stmt.stmt = staticinitializers->list.head;
			//~ staticinitializers->list.tail->next = cc->root->stmt.stmt;
			//~ cc->root = staticinitializers->list.head;
		}
	}

	Lmain = rt->_beg - rt->_mem;
	if (cc->root) {
		int seg = Lmain;
		rt->vm.ss = rt->vm.sm = 0;

		// enable static var initialization
		rt->cc->init = 1;

		// TYPE_vid clears the stack
		if (!cgen(rt, cc->root, gstat ? TYPE_vid : TYPE_any)) {
			error(rt, NULL, 0, "invalid jump: `%k`", cc->jmps);
			fputasm(rt, rt->logf, seg, emitopc(rt, markIP), 0x10);
			trace("Error");
			return 0;
		}

		while (cc->jmps) {
			error(rt, NULL, 0, "invalid jump: `%k`", cc->jmps);
			cc->jmps = cc->jmps->next;
			trace("Error");
			return 0;
		}
	}

	// application exit point: exit(0)
	rt->vm.px = emiti32(rt, 0);
	emitint(rt, opc_libc, 0);

	// program entry point
	rt->vm.pc = Lmain;

	//rt->vm.size.meta = Lmeta;
	//rt->vm.size.code = rt->_beg - rt->_mem;

	rt->_end = rt->_mem + rt->_size;

	if (rt->dbg != NULL) {
		int i, j;
		struct arrBuffer *codeMap = &rt->dbg->codeMap;
		for (i = 0; i < codeMap->cnt; ++i) {
			for (j = i; j < codeMap->cnt; ++j) {
				dbgInfo a = getBuff(codeMap, i);
				dbgInfo b = getBuff(codeMap, j);
				if (a->end > b->end) {
					memswap(a, b, sizeof(struct dbgInfo));
				}
				else if (a->end == b->end) {
					if (a->start < b->start) {
						memswap(a, b, sizeof(struct dbgInfo));
					}
				}
			}
		}
	}

	return rt->errc == 0;
	(void)Lmeta;
}

// install type system
static void install_type(ccState cc, int mode) {
	symn type_rec, type_vid, type_bol, type_ptr = NULL, type_var = NULL;
	symn type_i08, type_i16, type_i32, type_i64;
	symn type_u08, type_u16, type_u32;
	symn type_f32, type_f64;
	symn type_chr;

	type_rec = install(cc, "typename", ATTR_stat | ATTR_const | TYPE_rec, TYPE_ref, 0, NULL, NULL);

	// TODO: typename is of type typename
	type_rec->type = type_rec;

	type_vid = install(cc,    "void", ATTR_stat | ATTR_const | TYPE_rec, TYPE_vid, 0, type_rec, NULL);
	type_bol = install(cc,    "bool", ATTR_stat | ATTR_const | TYPE_rec, TYPE_bit, 4, type_rec, NULL);
	type_i08 = install(cc,    "int8", ATTR_stat | ATTR_const | TYPE_rec, TYPE_i32, 1, type_rec, NULL);
	type_i16 = install(cc,   "int16", ATTR_stat | ATTR_const | TYPE_rec, TYPE_i32, 2, type_rec, NULL);
	type_i32 = install(cc,   "int32", ATTR_stat | ATTR_const | TYPE_rec, TYPE_i32, 4, type_rec, NULL);
	type_i64 = install(cc,   "int64", ATTR_stat | ATTR_const | TYPE_rec, TYPE_i64, 8, type_rec, NULL);
	type_u08 = install(cc,   "uint8", ATTR_stat | ATTR_const | TYPE_rec, TYPE_u32, 1, type_rec, NULL);
	type_u16 = install(cc,  "uint16", ATTR_stat | ATTR_const | TYPE_rec, TYPE_u32, 2, type_rec, NULL);
	type_u32 = install(cc,  "uint32", ATTR_stat | ATTR_const | TYPE_rec, TYPE_u32, 4, type_rec, NULL);
	// type_ = install(cc,  "uint64", ATTR_stat | ATTR_const | TYPE_rec, TYPE_u64, 8, type_rec, NULL);
	type_f32 = install(cc, "float32", ATTR_stat | ATTR_const | TYPE_rec, TYPE_f32, 4, type_rec, NULL);
	type_f64 = install(cc, "float64", ATTR_stat | ATTR_const | TYPE_rec, TYPE_f64, 8, type_rec, NULL);

	if (mode & creg_tptr) {
		type_ptr = install(cc,  "pointer", ATTR_stat | ATTR_const | TYPE_rec, TYPE_ref, vm_size, type_rec, NULL);
		cc->null_ref = install(cc, "null", ATTR_stat | ATTR_const | TYPE_ref, TYPE_any, vm_size, type_ptr, NULL);
	}
	if (mode & creg_tvar) {
		type_var = install(cc, "variant", ATTR_stat | ATTR_const | TYPE_rec, TYPE_rec, 2 * vm_size, type_rec, NULL);
		//~ install(cc, "array", ATTR_const | TYPE_arr, 0, 0, cc->type_var, NULL);		// array is alias for variant[]
	}

	type_vid->pfmt = NULL;
	type_bol->pfmt = "bool(%d)";
	type_i08->pfmt = "int8(%d)";
	type_i16->pfmt = "int16(%d)";
	type_i32->pfmt = "int32(%d)";
	type_i64->pfmt = "int64(%D)";
	type_u08->pfmt = "uint8(%u)";
	type_u16->pfmt = "uint16(%u)";
	type_u32->pfmt = "uint32(%u)";
	// type_->pfmt = "uint64(%U)";
	type_f32->pfmt = "float32(%f)";
	type_f64->pfmt = "float64(%F)";

	cc->type_rec = type_rec;
	cc->type_vid = type_vid;
	cc->type_bol = type_bol;
	cc->type_i32 = type_i32;
	cc->type_i64 = type_i64;
	cc->type_u32 = type_u32;
	cc->type_f32 = type_f32;
	cc->type_f64 = type_f64;
	cc->type_ptr = type_ptr;
	cc->type_var = type_var;

	// aliases.
	install(cc, "int",    ATTR_stat | ATTR_const | TYPE_def, 0, 0, type_i32, NULL);
	install(cc, "long",   ATTR_stat | ATTR_const | TYPE_def, 0, 0, type_i64, NULL);
	install(cc, "float",  ATTR_stat | ATTR_const | TYPE_def, 0, 0, type_f32, NULL);
	install(cc, "double", ATTR_stat | ATTR_const | TYPE_def, 0, 0, type_f64, NULL);

	install(cc, "true",   ATTR_stat | ATTR_const | TYPE_def, 0, 0, type_bol, intnode(cc, 1));
	install(cc, "false",  ATTR_stat | ATTR_const | TYPE_def, 0, 0, type_bol, intnode(cc, 0));

	//~ type_chr = install(cc, "char", ATTR_stat | ATTR_const | TYPE_def, 0, 0, type_u08, NULL);
	type_chr = install(cc, "char", ATTR_stat | ATTR_const | TYPE_rec, TYPE_u32, 1, type_rec, NULL);
	type_chr->pfmt = "char('%c')";

	//~ TODO: struct string: char[] { ... }, temporarly string is alias for uint8[]
	cc->type_str = install(cc, "string", ATTR_stat | ATTR_const | TYPE_arr, TYPE_ref, vm_size, type_chr, NULL);
	cc->type_str->pfmt = "string(`%s`)";

	// hack: string is static sized array.
	cc->type_str->init = intnode(cc, -1);

	if (type_var != NULL) {
		install(cc, "var", ATTR_const | TYPE_def, 0, 0, type_var, NULL);
	}
}

// install emit operator
static void install_emit(ccState cc, int mode) {
	state rt = cc->s;
	symn typ = NULL;
	symn type_v4f = NULL;

	// TODO: emit is a keyword ???
	cc->emit_opc = install(cc, "emit", EMIT_opc, 0, 0, NULL, NULL);

	if (cc->emit_opc && (mode & creg_eopc) == creg_eopc) {

		symn u32, i32, i64, f32, f64, v4f, v2d;

		ccBegin(rt, NULL);
		install(cc, "ref", ATTR_stat | ATTR_const | TYPE_rec, TYPE_ref, vm_size, cc->type_rec, NULL);

		u32 = install(cc, "u32", ATTR_stat | ATTR_const | TYPE_rec, TYPE_u32, 4, cc->type_rec, NULL);
		i32 = install(cc, "i32", ATTR_stat | ATTR_const | TYPE_rec, TYPE_i32, 4, cc->type_rec, NULL);
		i64 = install(cc, "i64", ATTR_stat | ATTR_const | TYPE_rec, TYPE_i64, 8, cc->type_rec, NULL);
		f32 = install(cc, "f32", ATTR_stat | ATTR_const | TYPE_rec, TYPE_f32, 4, cc->type_rec, NULL);
		f64 = install(cc, "f64", ATTR_stat | ATTR_const | TYPE_rec, TYPE_f64, 8, cc->type_rec, NULL);
		v4f = install(cc, "v4f", ATTR_stat | ATTR_const | TYPE_rec, TYPE_rec, 16, cc->type_rec, NULL);
		v2d = install(cc, "v2d", ATTR_stat | ATTR_const | TYPE_rec, TYPE_rec, 16, cc->type_rec, NULL);

		install(cc, "nop", EMIT_opc, 0, opc_nop, cc->type_vid, NULL);
		install(cc, "not", EMIT_opc, 0, opc_not, cc->type_bol, NULL);
		install(cc, "set", EMIT_opc, 0, opc_set1, cc->type_vid, intnode(cc, 1));
		install(cc, "join", EMIT_opc, 0, opc_sync, cc->type_vid, intnode(cc, 1));
		//~ install(cc, "pop1", EMIT_opc, 0, opc_drop, cc->type_vid, intnode(cc, 1));
		//~ install(cc, "set0", EMIT_opc, 0, opc_set1, cc->type_vid, intnode(cc, 0));
		//~ install(cc, "set1", EMIT_opc, 0, opc_set1, cc->type_vid, intnode(cc, 1));

		if ((typ = ccBegin(rt, "dupp"))) {
			install(cc, "x1", EMIT_opc, 0, opc_dup1, cc->type_i32, intnode(cc, 0));
			install(cc, "x1_1", EMIT_opc, 0, opc_dup1, cc->type_i32, intnode(cc, 1));
			install(cc, "x1_2", EMIT_opc, 0, opc_dup1, cc->type_i32, intnode(cc, 2));
			install(cc, "x2", EMIT_opc, 0, opc_dup2, cc->type_i64, intnode(cc, 0));
			install(cc, "x4", EMIT_opc, 0, opc_dup4, cc->type_vid, intnode(cc, 0));
			ccEnd(cc->s, typ);
		}
		if ((typ = ccBegin(rt, "load"))) {
			// load zero
			install(cc, "z32", EMIT_opc, 0, opc_ldz1, cc->type_vid, NULL);
			install(cc, "z64", EMIT_opc, 0, opc_ldz2, cc->type_vid, NULL);
			install(cc, "z128", EMIT_opc, 0, opc_ldz4, cc->type_vid, NULL);

			// load memory
			install(cc, "i8",   EMIT_opc, 0, opc_ldi1, cc->type_vid, NULL);
			install(cc, "i16",  EMIT_opc, 0, opc_ldi2, cc->type_vid, NULL);
			install(cc, "i32",  EMIT_opc, 0, opc_ldi4, cc->type_vid, NULL);
			install(cc, "i64",  EMIT_opc, 0, opc_ldi8, cc->type_vid, NULL);
			install(cc, "i128", EMIT_opc, 0, opc_ldiq, cc->type_vid, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = ccBegin(rt, "store"))) {
			install(cc, "i8",   EMIT_opc, 0, opc_sti1, cc->type_vid, NULL);
			install(cc, "i16",  EMIT_opc, 0, opc_sti2, cc->type_vid, NULL);
			install(cc, "i32",  EMIT_opc, 0, opc_sti4, cc->type_vid, NULL);
			install(cc, "i64",  EMIT_opc, 0, opc_sti8, cc->type_vid, NULL);
			install(cc, "i128", EMIT_opc, 0, opc_stiq, cc->type_vid, NULL);
			ccEnd(rt, typ);
		}

		install(cc, "call", EMIT_opc, 0, opc_call, cc->type_vid, NULL);

		if ((typ = u32) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "cmt", EMIT_opc, 0, b32_cmt, cc->type_u32, NULL);
			install(cc, "and", EMIT_opc, 0, b32_and, cc->type_u32, NULL);
			install(cc,  "or", EMIT_opc, 0, b32_ior, cc->type_u32, NULL);
			install(cc, "xor", EMIT_opc, 0, b32_xor, cc->type_u32, NULL);
			install(cc, "shl", EMIT_opc, 0, b32_shl, cc->type_u32, NULL);
			install(cc, "shr", EMIT_opc, 0, b32_shr, cc->type_u32, NULL);
			install(cc, "sar", EMIT_opc, 0, b32_sar, cc->type_u32, NULL);

			install(cc, "mul", EMIT_opc, 0, u32_mul, cc->type_u32, NULL);
			install(cc, "div", EMIT_opc, 0, u32_div, cc->type_u32, NULL);
			install(cc, "mod", EMIT_opc, 0, u32_mod, cc->type_u32, NULL);

			install(cc, "clt", EMIT_opc, 0, u32_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, u32_cgt, cc->type_bol, NULL);
			//~ install(cc, "to_i64", EMIT_opc, 0, u32_i64, cc->type_i64, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = i32) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "cmt", EMIT_opc, 0, b32_cmt, cc->type_i32, NULL);
			install(cc, "neg", EMIT_opc, 0, i32_neg, cc->type_i32, NULL);
			install(cc, "add", EMIT_opc, 0, i32_add, cc->type_i32, NULL);
			install(cc, "sub", EMIT_opc, 0, i32_sub, cc->type_i32, NULL);
			install(cc, "mul", EMIT_opc, 0, i32_mul, cc->type_i32, NULL);
			install(cc, "div", EMIT_opc, 0, i32_div, cc->type_i32, NULL);
			install(cc, "mod", EMIT_opc, 0, i32_mod, cc->type_i32, NULL);

			install(cc, "ceq", EMIT_opc, 0, i32_ceq, cc->type_bol, NULL);
			install(cc, "clt", EMIT_opc, 0, i32_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, i32_cgt, cc->type_bol, NULL);

			install(cc, "and", EMIT_opc, 0, b32_and, cc->type_i32, NULL);
			install(cc,  "or", EMIT_opc, 0, b32_ior, cc->type_i32, NULL);
			install(cc, "xor", EMIT_opc, 0, b32_xor, cc->type_i32, NULL);
			install(cc, "shl", EMIT_opc, 0, b32_shl, cc->type_i32, NULL);
			install(cc, "shr", EMIT_opc, 0, b32_sar, cc->type_i32, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = i64) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, i64_neg, cc->type_i64, NULL);
			install(cc, "add", EMIT_opc, 0, i64_add, cc->type_i64, NULL);
			install(cc, "sub", EMIT_opc, 0, i64_sub, cc->type_i64, NULL);
			install(cc, "mul", EMIT_opc, 0, i64_mul, cc->type_i64, NULL);
			install(cc, "div", EMIT_opc, 0, i64_div, cc->type_i64, NULL);
			install(cc, "mod", EMIT_opc, 0, i64_mod, cc->type_i64, NULL);
			install(cc, "ceq", EMIT_opc, 0, i64_ceq, cc->type_bol, NULL);
			install(cc, "clt", EMIT_opc, 0, i64_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, i64_cgt, cc->type_bol, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = f32) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, f32_neg, cc->type_f32, NULL);
			install(cc, "add", EMIT_opc, 0, f32_add, cc->type_f32, NULL);
			install(cc, "sub", EMIT_opc, 0, f32_sub, cc->type_f32, NULL);
			install(cc, "mul", EMIT_opc, 0, f32_mul, cc->type_f32, NULL);
			install(cc, "div", EMIT_opc, 0, f32_div, cc->type_f32, NULL);
			install(cc, "mod", EMIT_opc, 0, f32_mod, cc->type_f32, NULL);
			install(cc, "ceq", EMIT_opc, 0, f32_ceq, cc->type_bol, NULL);
			install(cc, "clt", EMIT_opc, 0, f32_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, f32_cgt, cc->type_bol, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = f64) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, f64_neg, cc->type_f64, NULL);
			install(cc, "add", EMIT_opc, 0, f64_add, cc->type_f64, NULL);
			install(cc, "sub", EMIT_opc, 0, f64_sub, cc->type_f64, NULL);
			install(cc, "mul", EMIT_opc, 0, f64_mul, cc->type_f64, NULL);
			install(cc, "div", EMIT_opc, 0, f64_div, cc->type_f64, NULL);
			install(cc, "mod", EMIT_opc, 0, f64_mod, cc->type_f64, NULL);
			install(cc, "ceq", EMIT_opc, 0, f64_ceq, cc->type_bol, NULL);
			install(cc, "clt", EMIT_opc, 0, f64_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, f64_cgt, cc->type_bol, NULL);
			ccEnd(rt, typ);
		}

		if ((typ = v4f) != NULL) {
			type_v4f = typ;
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, v4f_neg, type_v4f, NULL);
			install(cc, "add", EMIT_opc, 0, v4f_add, type_v4f, NULL);
			install(cc, "sub", EMIT_opc, 0, v4f_sub, type_v4f, NULL);
			install(cc, "mul", EMIT_opc, 0, v4f_mul, type_v4f, NULL);
			install(cc, "div", EMIT_opc, 0, v4f_div, type_v4f, NULL);
			install(cc, "equ", EMIT_opc, 0, v4f_ceq, cc->type_bol, NULL);
			install(cc, "min", EMIT_opc, 0, v4f_min, type_v4f, NULL);
			install(cc, "max", EMIT_opc, 0, v4f_max, type_v4f, NULL);
			install(cc, "dp3", EMIT_opc, 0, v4f_dp3, cc->type_f32, NULL);
			install(cc, "dp4", EMIT_opc, 0, v4f_dp4, cc->type_f32, NULL);
			install(cc, "dph", EMIT_opc, 0, v4f_dph, cc->type_f32, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = v2d) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, v2d_neg, typ, NULL);
			install(cc, "add", EMIT_opc, 0, v2d_add, typ, NULL);
			install(cc, "sub", EMIT_opc, 0, v2d_sub, typ, NULL);
			install(cc, "mul", EMIT_opc, 0, v2d_mul, typ, NULL);
			install(cc, "div", EMIT_opc, 0, v2d_div, typ, NULL);
			install(cc, "equ", EMIT_opc, 0, v2d_ceq, cc->type_bol, NULL);
			install(cc, "min", EMIT_opc, 0, v2d_min, typ, NULL);
			install(cc, "max", EMIT_opc, 0, v2d_max, typ, NULL);
			ccEnd(rt, typ);
		}

		if ((mode & creg_eswz) == creg_eswz) {
			unsigned i;
			struct {
				char* name;
				astn node;
			} swz[256];
			for (i = 0; i < lengthOf(swz); i += 1) {
				dieif(rt->_end - rt->_beg < 5, "memory overrun");
				rt->_beg[0] = "xyzw"[(i >> 0) & 3];
				rt->_beg[1] = "xyzw"[(i >> 2) & 3];
				rt->_beg[2] = "xyzw"[(i >> 4) & 3];
				rt->_beg[3] = "xyzw"[(i >> 6) & 3];
				rt->_beg[4] = 0;

				swz[i].name = mapstr(cc, (char*)rt->_beg, -1, -1);
				swz[i].node = intnode(cc, i);
			}
			if ((typ = install(cc, "swz", TYPE_rec, 0, 0, NULL, NULL))) {
				ccBegin(rt, NULL);
				for (i = 0; i < 256; i += 1) {
					install(cc, swz[i].name, EMIT_opc, 0, p4x_swz, type_v4f, swz[i].node);
				}
				ccEnd(rt, typ);
			}
		}
		ccEnd(rt, cc->emit_opc);
	}
}

/// Initialze compiler context; @see header
ccState ccInit(state rt, int mode, int onHalt(libcArgs)) {
	ccState cc;

	dieif(rt->cc != NULL, "Compiler state already initialzed.");
	dieif(rt->_beg != rt->_mem, "Compiler initialization failed.");
	dieif(rt->_end != rt->_mem + rt->_size, "Compiler initialization failed.");

	cc = (ccState)(rt->_end - sizeof(struct ccStateRec));
	rt->_end -= sizeof(struct ccStateRec);

	dieif(rt->_end < rt->_beg, "memory overrun");
	memset(rt->_end, 0, sizeof(struct ccStateRec));

	cc->s = rt;
	rt->cc = cc;

	rt->defs = NULL;
	rt->gdef = NULL;
	cc->defs = NULL;

	cc->_chr = -1;

	cc->fin._ptr = 0;
	cc->fin._cnt = 0;
	cc->fin._fin = -1;

	cc->root = newnode(cc, STMT_beg);

	install_type(cc, mode);
	install_emit(cc, mode);

	ccAddCall(rt, onHalt ? onHalt : libCallHaltQuiet, NULL, "void Halt(int Code);");

	cc->root->type = cc->type_vid;
	cc->root->cst2 = TYPE_any;

	// install a void arg for functions with no arguments
	if (cc->type_vid && (cc->void_tag = newnode(cc, TYPE_ref))) {
		enter(cc, NULL);
		cc->void_tag->ref.name = "";
		cc->void_tag->next = NULL;
		declare(cc, TYPE_ref, cc->void_tag, cc->type_vid);
		leave(cc, NULL, 0);
	}

	if (cc->emit_opc && (cc->emit_tag = newnode(cc, TYPE_ref))) {
		cc->emit_tag->ref.link = cc->emit_opc;
		cc->emit_tag->ref.name = "emit";
		cc->emit_tag->ref.hash = -1;
	}

	install_base(rt, mode);

	return cc;
}

/// Alloc, resize or free memory; @see state.api.rtAlloc
void* rtAlloc(state rt, void* ptr, unsigned size) {
	/* memory manager
	 * using one linked list containing both used and unused memory chunks.
	 * The idea is when allocating a block of memory we always must to traverse the list of chunks.
	 * when freeing a block not. Because of this if a block is used prev points to the previos block.
	 * a block is free when prev is null.
	 .
	 :
	 +------+------+
	 | next | prev |
	 +------+------+
	 |             |
	 .             .
	 : ...         :
	 +-------------
	 | next | prev |
	 +------+------+
	 |             |
	 .             .
	 : ...         :
	 +------+------+
	 :
	*/

	typedef struct memchunk {
		struct memchunk* next;
		struct memchunk* prev;		// not null for used memory
		char data[];
	} *memchunk;

	const int minAllocationSize = 16;
	memchunk chunk = (memchunk)((char*)ptr - sizeof(struct memchunk));
	unsigned allocsize = padded(size + minAllocationSize, minAllocationSize);

	// memory manager is not initialized, initialize it first
	if (rt->vm.heap == NULL) {
		memchunk heap = paddptr(rt->_beg, minAllocationSize);
		memchunk last = paddptr(rt->_end - minAllocationSize, minAllocationSize);

		heap->next = last;
		heap->prev = NULL;

		last->next = NULL;
		last->prev = NULL;

		rt->vm.heap = heap;
	}

	// realloc or free.
	if (ptr != NULL) {
		unsigned chunksize = chunk->next ? ((char*)chunk->next - (char*)chunk) : 0;

		dieif((unsigned char*)ptr < rt->_mem, "memmgr: invalid reference");
		dieif((unsigned char*)ptr > rt->_mem + rt->_size, "memmgr: invalid reference");

		if (1) { // extra check if ptr is in used list.
			memchunk find = rt->vm.heap;
			memchunk prev = find;
			while (find && find != chunk) {
				prev = find;
				find = find->next;
			}
			dieif(find != chunk, "memmgr: pointer not in list.");
			dieif(chunk->prev != prev, "memmgr: pointer not in used list.");
		}

		if (size == 0) {							// free
			memchunk next = chunk->next;
			memchunk prev = chunk->prev;

			// merge with next block if free
			if (next && next->prev == NULL) {
				next = next->next;
				chunk->next = next;
				if (next && next->prev != NULL) {
					next->prev = prev;
				}
			}

			// merge with previos block if free
			if (prev && prev->prev == NULL) {
				chunk = prev;
				prev->next = next;
				if (next->prev != NULL)
					next->prev = prev;
			}

			// mark as unused.
			chunk->prev = NULL;
			chunk = NULL;
		}
		else if (allocsize < chunksize) {			// shrink
			memchunk next = chunk->next;
			memchunk free = (memchunk)((char*)chunk + allocsize);

			// do not make a free unaligned block (realoc 161 to 160 bytes)
			if (((char*)next - (char*)free) > minAllocationSize) {
				chunk->next = free;
				free->next = next;
				free->prev = NULL;

				// merge with next block if free
				if (next->prev == NULL) {
					next = next->next;
					free->next = next;
					if (next && next->prev != NULL) {
						next->prev = free;
					}
				}
				else {
					next->prev = free;
				}
			}
		}
		else {										// grow
			error(rt, __FILE__, __LINE__, "not implemented the case when realloc to grow.");
			chunk = NULL;
		}
	}

	// allocate.
	else if (size > 0) {
		memchunk prev = chunk = rt->vm.heap;

		while (chunk) {
			memchunk next = chunk->next;

			// check if block is free.
			if (chunk->prev == NULL && next) {
				unsigned chunksize = (char*)next - (char*)chunk - allocsize;
				if (allocsize < chunksize) {
					int diff = chunksize - allocsize;
					if (diff > minAllocationSize) {
						memchunk free = (memchunk)((char*)chunk + allocsize);
						chunk->next = free;
						free->prev = NULL;
						free->next = next;
					}
					chunk->prev = prev;
					break;
				}
			}
			prev = chunk;
			chunk = next;
		}
	}

	// debug
	else if (1) {
		memchunk mem = ptr ? (memchunk)((char*)ptr - sizeof(struct memchunk)) : NULL;
		perr(rt, 0, __FILE__, __LINE__, "heap info: memmgr(%06x, %d)", vmOffset(rt, mem), size);
		for (mem = rt->vm.heap; mem; mem = mem->next) {
			char *status = mem->prev ? "used" : "free";
			if (mem->next) {
				int size = (char*)mem->next - (char*)mem - sizeof(struct memchunk);
				perr(rt, 0, NULL, 0, "%s chunk[%d]: @%06x; next: %06x; prev: %06x", status, size, vmOffset(rt, mem), vmOffset(rt, mem->next), vmOffset(rt, mem->prev));
			}
		}
	}

	return chunk ? chunk->data : NULL;
}

// arrayBuffer
int initBuff(struct arrBuffer* buff, int initsize, int elemsize) {
	buff->cnt = 0;
	buff->ptr = 0;
	buff->esz = elemsize;
	buff->cap = initsize * elemsize;
	return setBuff(buff, initsize, NULL) != NULL;
}
void* setBuff(struct arrBuffer* buff, int idx, void* data) {
	int pos = idx * buff->esz;

	//~ void* ptr = getBuff(buff, idx);
	if (pos >= buff->cap) {
		//~ trace("resizing setBuff(%d / %d)\n", idx, buff->cnt);
		buff->cap <<= 1;
		if (pos > 2 * buff->cap) {
			buff->cap = pos << 1;
		}
		buff->ptr = realloc(buff->ptr, buff->cap);
	}

	if (buff->cnt >= idx) {
		buff->cnt = idx + 1;
	}

	if (buff->ptr && data) {
		memcpy(buff->ptr + pos, data, buff->esz);
	}

	return buff->ptr ? buff->ptr + pos : NULL;
}
void* insBuff(struct arrBuffer* buff, int idx, void* data) {
	int pos = idx * buff->esz;
	int newCap = buff->cnt * buff->esz;
	if (newCap < pos) {
		newCap = pos;
	}

	// resize buffer
	if (newCap >= buff->cap) {
		if (newCap > 2 * buff->cap) {
			buff->cap = newCap;
		}
		buff->cap *= 2;
		buff->ptr = realloc(buff->ptr, buff->cap);
	}

	//~ debug("insBuff(buff(cnt: %d), idx: %d, cap: %d, pos : %d)", buff->cnt, idx, newCap, pos);
	if (idx < buff->cnt) {
		//~ debug("insBuff.move(to: %d, from: %d, size: %d)", pos + buff->esz, pos, buff->esz * (buff->cnt - idx));
		memmove(buff->ptr + pos + buff->esz, buff->ptr + pos, buff->esz * (buff->cnt - idx));
		idx = buff->cnt;
	}

	if (buff->cnt >= idx) {
		buff->cnt = idx + 1;
	}

	if (buff->ptr && data) {
		memcpy(buff->ptr + pos, data, buff->esz);
	}

	return buff->ptr ? buff->ptr + pos : NULL;
}
void* getBuff(struct arrBuffer* buff, int idx) {
	int pos = idx * buff->esz;

	if (pos >= buff->cap)
		return NULL;

	return buff->ptr ? buff->ptr + pos : NULL;
}
void freeBuff(struct arrBuffer* buff) {
	free(buff->ptr);
	buff->ptr = 0;
	buff->cap = 0;
	buff->esz = 0;
}

dbgInfo getCodeMapping(state rt, int position) {
	if (rt->dbg != NULL) {
		int i;
		for (i = 0; i < rt->dbg->codeMap.cnt; ++i) {
			dbgInfo result = getBuff(&rt->dbg->codeMap, i);
			if (position >= result->start) {
				if (position < result->end) {
					return result;
				}
			}
		}
	}
	return NULL;
}
dbgInfo addCodeMapping(state rt, astn ast, int start, int end) {
	dbgInfo result = NULL;
	if (rt->dbg != NULL) {
		int i;
		for (i = 0; i < rt->dbg->codeMap.cnt; ++i) {
			result = getBuff(&rt->dbg->codeMap, i);
			if (start <= result->start) {
				break;
			}
		}

		if (result == NULL || start != result->start) {
			result = insBuff(&rt->dbg->codeMap, i, NULL);
		}

		if (result != NULL) {
			result->stmt = ast;
			result->file = ast->file;
			result->line = ast->line;
			result->start = start;
			result->end = end;
		}
	}
	return result;
}
