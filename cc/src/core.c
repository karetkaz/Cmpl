/*******************************************************************************
 *   File: core.c
 *   Date: 2011/06/23
 *   Desc: type system
 *******************************************************************************
the core:
	convert ast to vmcode
	initializations, memory management

	emit:
	emit is a low level function like construct. (intrinsic)
	emit's type is the type of the first argument's.
	emit can have as parameters values and opcodes.
		as the first argument of emit we can pass a type or the struct keyword.
			if the first argument is a type, static cast can be done
				ex emit(float32, int32(2))
			if the first argument is struct in a declaration,
			the resulting type will match the declared type.
			size of variable must match the size generated by emit.
				ex complex a = emit(struct, f64(1), f64(-1));
	emit is used for libcalls, constructors, ..., optimizations

*******************************************************************************/
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <time.h>
#include "core.h"

static void memswap(void* _a, void* _b, int size) {
	register char *a = _a;
	register char *b = _b;
	while ((size -= 1) >= 0) {
		char c = *a;
		*a = *b;
		*b = c;
		a += 1;
		b += 1;
	}
}

const tok_inf tok_tbl[255] = {
	#define TOKDEF(NAME, TYPE, SIZE, STR) {TYPE, SIZE, STR},
	#include "defs.inl"
	{0},
};
const opc_inf opc_tbl[255] = {
	#define OPCDEF(NAME, CODE, SIZE, CHCK, DIFF, TIME, MNEM) {CODE, SIZE, CHCK, DIFF, MNEM},
	#include "defs.inl"
	{0},
};

static inline int genRef(state rt, symn var) {
	//~ logif(var->stat != (var->offs < 0), "FixMe(%d)@%d %-T (%s:%d)", var->stat, var->offs, var, var->file, var->line);
	if (!var->stat)
		return emitidx(rt, opc_ldsp, var->offs);
	return emitint(rt, opc_ldcr, var->offs);
}

/* TODO: remove function:
 * static expressions should be handled by lookup.
 */
int isStatic(ccState cc, astn ast) {
	if (ast) switch (ast->kind) {
		default:
			return 0;

		//#{ OPER
		case OPER_fnc:		// '()' emit/call/cast
		case OPER_idx:		// '[]'
		case OPER_dot:		// '.'
			return 0;

		case OPER_com:
		case OPER_not:		// '!'
		case OPER_pls:		// '+'
		case OPER_mns:		// '-'
		case OPER_cmt:		// '~'
			return isStatic(cc, ast->op.rhso);

		case OPER_shl:		// '>>'
		case OPER_shr:		// '<<'
		case OPER_and:		// '&'
		case OPER_ior:		// '|'
		case OPER_xor:		// '^'

		case OPER_equ:		// '=='
		case OPER_neq:		// '!='
		case OPER_lte:		// '<'
		case OPER_leq:		// '<='
		case OPER_gte:		// '>'
		case OPER_geq:		// '>='

		case OPER_add:		// '+'
		case OPER_sub:		// '-'
		case OPER_mul:		// '*'
		case OPER_div:		// '/'
		case OPER_mod:		// '%'
			return isStatic(cc, ast->op.lhso) && isStatic(cc, ast->op.rhso);

		case OPER_lnd:		// '&&'
		case OPER_lor:		// '||'
			return isStatic(cc, ast->op.lhso) && isStatic(cc, ast->op.rhso);

		case OPER_sel:		// '?:'
			return isStatic(cc, ast->op.test) && isStatic(cc, ast->op.lhso) && isStatic(cc, ast->op.rhso);

		case ASGN_set:		// ':='
			return 0;
		//#}
		//#{ TVAL
		case TYPE_int:
		case TYPE_flt:
		case TYPE_str:
			return 1;

		case TYPE_ref: {					// use (var, func, define)
			symn typ = ast->type;			// type
			symn var = ast->ref.link;		// link
			dieif(!typ || !var, "FixMe");
			return var->stat || var->nest > cc->nest;
		}

		//~ case TYPE_def:					// new (var, func, define)
		//~ case EMIT_opc:
		//#}
	}
	return 0;
}

int isConst(astn ast) {
	if (ast != NULL) {
		struct astNode tmp;

		while (ast->kind == OPER_com) {
			if (!isConst(ast->op.rhso)) {
				trace("%+k", ast);
				return 0;
			}
			ast = ast->op.lhso;
		}

		if (eval(&tmp, ast)) {
			return 1;
		}

		if (ast->kind == OPER_fnc) {
			// check if it is an initializer or a pure function
			symn ref = linkOf(ast->op.lhso);
			if (ref && !ref->cnst) {
				return 0;
			}

			// check if arguments are constants
			return isConst(ast->op.rhso);
		}

		else if (ast->kind == TYPE_ref) {
			symn ref = linkOf(ast);
			if (ref && ref->cnst) {
				return 1;
			}
		}

		// string constant is constant
		else if (ast->kind == TYPE_str) {
			return 1;
		}
	}

	trace("%+k", ast);
	return 0;
}

//#{ symbols: install and query
symn ccBegin(state rt, char* cls) {
	symn result = NULL;
	if (rt->cc != NULL) {
		if (cls != NULL) {
			result = install(rt->cc, cls, ATTR_const | ATTR_stat | TYPE_rec, TYPE_vid, 0, NULL, NULL);
		}
		if (cls == NULL || result) {
			enter(rt->cc, NULL);
		}
	}
	return result;
}
void ccExtEnd(state rt, symn cls, int mode) {
	if (cls != NULL) {
		symn args = leave(rt->cc, cls, (mode & ATTR_stat) != 0);
		if (mode & 1) {
			args->next = cls->prms;
		}
		//~ TODO: prms is the tail of the list.
		cls->prms = args;
	}
}
void ccEnd(state rt, symn cls) {
	ccExtEnd(rt, cls, ATTR_stat);
}

symn ccDefInt(state rt, char* name, int64_t value) {
	if (!rt || !name) {
		debug("%x, %s, %D", rt, name, value);
		return NULL;
	}
	name = mapstr(rt->cc, name, -1, -1);
	return install(rt->cc, name, TYPE_def, TYPE_int, 0, rt->cc->type_i32, intnode(rt->cc, value));
}
symn ccDefFlt(state rt, char* name, double value) {
	if (!rt || !name) {
		debug("%x, %s, %F", rt, name, value);
		return NULL;
	}
	name = mapstr(rt->cc, name, -1, -1);
	return install(rt->cc, name, TYPE_def, TYPE_flt, 0, rt->cc->type_f64, fltnode(rt->cc, value));
}
symn ccDefStr(state rt, char* name, char* value) {
	if (!rt || !name) {
		debug("%x, %s, %s", rt, name, value);
		return NULL;
	}
	name = mapstr(rt->cc, name, -1, -1);
	value = value ? mapstr(rt->cc, value, -1, -1) : NULL;
	return install(rt->cc, name, TYPE_def, TYPE_str, 0, rt->cc->type_str, strnode(rt->cc, value));
}

symn mapsym(state rt, void* ptr) {
	int offs;
	symn sym = NULL;

	if (ptr == NULL) {
		trace("null");
		return NULL;
	}

	if (ptr < (void*)rt->_mem) {
		fatal("Error");
		return NULL;
	}

	if ((unsigned char*)ptr > rt->_mem + rt->vm.pc) {		// pc
		fatal("Error");
		return NULL;
	}

	offs = ((unsigned char*)ptr - rt->_mem);
	for (sym = rt->gdef; sym; sym = sym->gdef) {
		if (sym->offs == offs)
			return sym;
	}

	return NULL;
}

symn ccFindSym(ccState cc, symn in, char* name) {
	struct astNode ast;
	memset(&ast, 0, sizeof(struct astNode));
	ast.kind = TYPE_ref;
	ast.ref.hash = rehash(name, -1);
	ast.ref.name = name;
    return lookup(cc, in ? in->prms : cc->s->defs, &ast, NULL, 1);
}
int ccSymValInt(symn sym, int* res) {
	struct astNode ast;
	if (sym && eval(&ast, sym->init)) {
		*res = (int)constint(&ast);
		return 1;
	}
	return 0;
}
int ccSymValFlt(symn sym, double* res) {
	struct astNode ast;
	if (sym && eval(&ast, sym->init)) {
		*res = constflt(&ast);
		return 1;
	}
	return 0;
}

/* get a libcall arg by name
int getarg(state rt, char* name, void* copy) {

	dieif(!rt || rt->libc || !name || !copy, "FixMe");

	if (rt->libc->args) {
		symn arg = rt->libc->args;
		while (arg != NULL) {
			if (strcmp(name, arg->name) == 0)
				break;
			arg = arg->next;
		}
		if (arg != NULL) {
			int argc = (char*)rt->retv - (char*)rt->argv;

			void* offs = ((char*)rt->argv) + argc - arg->offs;

			if (arg->cast == TYPE_ref) {
				offs = *(void**)offs;
			}

			memcpy(copy, offs, arg->size);
			return arg->size;
		}
	}
	return -1;
}*/
//#}

static ccToken cgen(state rt, astn ast, ccToken get) {
	int ipdbg = emitopc(rt, markIP);

	#ifdef DEBUGGING
	ccToken qual = TYPE_any;
	#endif

	struct astNode tmp;
	ccToken ret = TYPE_any;

	dieif(!ast || !ast->type, "FixMe `%+k`", ast);

	//~ TODO: RemMe
	if (get == TYPE_any)
		get = ast->cst2;

	if (!(ret = ast->type->cast))
		ret = ast->type->kind;

	#ifdef DEBUGGING
	// take care of qualified statements `static if` ...
	if (ast->kind >= STMT_beg && ast->kind <= STMT_end) {
		qual = ast->cst2;
	}
	#endif

	// generate code
	switch (ast->kind) {
		//* c should warn about non cased enum members
		default:
			fatal("FixMe(%+k)", ast);
			return TYPE_any;
		//~ */
		//#{ STMT
		case STMT_do:  {	// expr or decl statement
			int stpos = stkoffs(rt, 0);
			if (!cgen(rt, ast->stmt.stmt, TYPE_vid)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (stpos > stkoffs(rt, 0)) {
				warn(rt, 1, ast->file, ast->line, "statement underflows stack: %+k", ast->stmt.stmt);
			}
		} break;
		case STMT_beg: {	// {} or function body
			astn ptr;
			int ippar = 0;
			//~ int stpar = rt->vm.su;
			int stpos = stkoffs(rt, 0);
			symn free = rt->cc->free;

			rt->cc->free = NULL;
			if (ast->cst2 == QUAL_par) {
				rt->vm.su = 0;
				ippar = emitopc(rt, opc_task);
				#ifdef DEBUGGING
				qual = TYPE_any;
				#endif
			}
			for (ptr = ast->stmt.stmt; ptr; ptr = ptr->next) {
				ipdbg = emitopc(rt, markIP);
				if (!cgen(rt, ptr, TYPE_vid)) {		// we will free stack on scope close
					#if DEBUGGING > 2
					//~ trace("%+k\n%7K", ast, ast);
					fputasm(rt, rt->logf, ipdbg, -1, 0x119);
					#endif
					error(rt, ptr->file, ptr->line, "emmiting statement `%+k`", ptr);
				}
			}
			if (ast->cst2 == TYPE_rec) {
				debug("%t", get);
				get = TYPE_any;
			}
			if (get == TYPE_vid && stpos != stkoffs(rt, 0)) {
				/*/ TODO: destruct
				symn var;
				for (var = rt->cc->free; var; var = var->next) {
					if (var->cast == TYPE_ref || var->cast == TYPE_arr) {
						if (!emitopc(rt, opc_ldz1)) {
							trace("%+k", ast);
							return TYPE_any;
						}

						if (!genRef(rt, var->offs)) {
							trace("%+k", ast);
							return TYPE_any;
						}
						if (!emitint(rt, opc_ldi, vm_size)) {
							trace("%+k", ast);
							return TYPE_any;
						}

						if (!emitint(rt, opc_libc, rt->cc->libc_mem->offs)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}
					debug("delete var: %-T", var);
				} // */
				if (!emitidx(rt, opc_drop, stpos)) {
					trace("error");
					return TYPE_any;
				}
			}
			rt->cc->free = free;
			if (ippar) {
				//~ rt->vm.pp.ss += 1;
				fixjump(rt, ippar, emitopc(rt, markIP), rt->vm.su * vm_size);
				emitint(rt, opc_sync, 0);
			}
			logif(ippar, "parallel data on stack: %d", rt->vm.su);
			/*if (rt->vm.su > rt->vm.su - stpar)
				rt->vm.su = rt->vm.su - stpar;
			// */
		} break;
		case STMT_if:  {
			int jmpt = 0, jmpf = 0;
			int stpos = stkoffs(rt, 0);
			int tt = eval(&tmp, ast->stmt.test);

			dieif(get != TYPE_vid, "FixMe");

			if (ast->cst2 == QUAL_sta) {
				if (ast->stmt.step || !tt) {
					error(rt, ast->file, ast->line, "invalid static if construct: %s", !tt ? "can not evaluate" : "else part is invalid");
					return TYPE_any;
				}
				#ifdef DEBUGGING
				qual = TYPE_any;
				#endif
			}

			if (tt && (rt->vm.opti || ast->cst2 == QUAL_sta)) {	// static if then else
				astn gen = constbol(&tmp) ? ast->stmt.stmt : ast->stmt.step;
				if (gen && !cgen(rt, gen, TYPE_any)) {	// leave the stack
					trace("%+k", gen);
					return TYPE_any;
				}
				// local declarations inside a static if grows the stack.
				stpos = stkoffs(rt, 0);
			}
			else {
				// hack: if (true) sin(pi/4); will leave the result on stack;
				// code will be generated as: if(true) {sin(pi/4);}
				struct astNode block;

				memset(&block, 0, sizeof(struct astNode));
				block.kind = STMT_beg;
				block.type = rt->cc->type_vid;

				if (ast->stmt.stmt && ast->stmt.step) {		// if then else
					if (!cgen(rt, ast->stmt.test, TYPE_bit)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					if (!(jmpt = emitopc(rt, opc_jz))) {
						trace("%+k", ast);
						return TYPE_any;
					}

					block.stmt.stmt = ast->stmt.stmt;
					if (!cgen(rt, &block, TYPE_vid)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					if (!(jmpf = emitopc(rt, opc_jmp))) {
						trace("%+k", ast);
						return TYPE_any;
					}
					fixjump(rt, jmpt, emitopc(rt, markIP), -1);

					block.stmt.stmt = ast->stmt.step;
					if (!cgen(rt, &block, TYPE_vid)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					fixjump(rt, jmpf, emitopc(rt, markIP), -1);
				}
				else if (ast->stmt.stmt) {							// if then
					if (!cgen(rt, ast->stmt.test, TYPE_bit)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					//~ if false skip THEN block
					if (!(jmpt = emitopc(rt, opc_jz))) {
						trace("%+k", ast);
						return TYPE_any;
					}

					block.stmt.stmt = ast->stmt.stmt;
					if (!cgen(rt, &block, TYPE_vid)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					fixjump(rt, jmpt, emitopc(rt, markIP), -1);
				}
				else if (ast->stmt.step) {							// if else
					if (!cgen(rt, ast->stmt.test, TYPE_bit)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					//~ if true skip ELSE block
					if (!(jmpt = emitopc(rt, opc_jnz))) {
						trace("%+k", ast);
						return TYPE_any;
					}

					block.stmt.stmt = ast->stmt.step;
					if (!cgen(rt, &block, TYPE_vid)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					fixjump(rt, jmpt, emitopc(rt, markIP), -1);
				}
				dieif(get != TYPE_vid || stpos != stkoffs(rt, 0), "internal fatal error");
			}
			//~ TODO: destruct(ast->stmt.test)
			logif(stpos != stkoffs(rt, 0), "invalid stacksize(%d:%d) in statement %+k", stkoffs(rt, 0), stpos, ast);
		} break;
		case STMT_for: {
			astn jl = rt->cc->jmps;
			int jstep, lcont, lbody, lbreak;
			int stbreak, stpos = stkoffs(rt, 0);

			dieif(get != TYPE_vid, "FixMe");
			if (ast->stmt.init && !cgen(rt, ast->stmt.init, TYPE_vid)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!(jstep = emitopc(rt, opc_jmp))) {		// continue;
				trace("%+k", ast);
				return TYPE_any;
			}

			lbody = emitopc(rt, markIP);
			if (ast->stmt.stmt && !cgen(rt, ast->stmt.stmt, TYPE_vid)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			lcont = emitopc(rt, markIP);
			if (ast->stmt.step && !cgen(rt, ast->stmt.step, TYPE_vid)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			fixjump(rt, jstep, emitopc(rt, markIP), -1);
			if (ast->stmt.test) {
				if (!cgen(rt, ast->stmt.test, TYPE_bit)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				if (!emitint(rt, opc_jnz, lbody)) {		// continue;
					trace("%+k", ast);
					return TYPE_any;
				}
			}
			else {
				if (!emitint(rt, opc_jmp, lbody)) {		// continue;
					trace("%+k", ast);
					return TYPE_any;
				}
			}

			lbreak = emitopc(rt, markIP);
			stbreak = stkoffs(rt, 0);

			while (rt->cc->jmps != jl) {
				astn jmp = rt->cc->jmps;
				rt->cc->jmps = jmp->next;

				if (jmp->go2.stks != stbreak) {
					error(rt, jmp->file, jmp->line, "`%k` statement is invalid due to previous variable declaration within loop", jmp);
					return TYPE_any;
				}

				switch (jmp->kind) {
					default :
						error(rt, jmp->file, jmp->line, "invalid goto statement: %k", jmp);
						return TYPE_any;
					case STMT_brk:
						fixjump(rt, jmp->go2.offs, lbreak, jmp->go2.stks);
						break;
					case STMT_con:
						fixjump(rt, jmp->go2.offs, lcont, jmp->go2.stks);
						break;
				}
			}

			//~ TODO: destruct(ast->stmt.test)
			if (stpos != stkoffs(rt, 0)) {
				dieif(!emitidx(rt, opc_drop, stpos), "FixMe");
			}
		} break;
		case STMT_con:
		case STMT_brk: {
			int offs;
			dieif(get != TYPE_vid, "FixMe");
			if (!(offs = emitopc(rt, opc_jmp))) {
				trace("%+k", ast);
				return TYPE_any;
			}

			ast->go2.offs = offs;
			ast->go2.stks = stkoffs(rt, 0);

			ast->next = rt->cc->jmps;
			rt->cc->jmps = ast;
		} break;
		case STMT_ret: {
			//~ TODO: declared reference variables should be freed.
			int bppos = stkoffs(rt, 0);
			if (rt->cc->free != NULL) {
				symn var = rt->cc->free;
				error(rt, var->file, var->line, "return will not free dynamically allocated variables `%-T`", var);
			}
			if (ast->stmt.stmt && !cgen(rt, ast->stmt.stmt, TYPE_vid)) {
				trace("%+k\n%7K", ast, ast);
				return TYPE_any;
			}
			dieif(get != TYPE_vid, "FixMe");
			if (get == TYPE_vid && rt->vm.ro != stkoffs(rt, 0)) {
				if (!emitidx(rt, opc_drop, rt->vm.ro)) {
					trace("leve %d", rt->vm.ro);
					return TYPE_any;
				}
			}
			if (!emitopc(rt, opc_jmpi)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			fixjump(rt, 0, 0, bppos);
		} break;
		//#}
		//#{ OPER
		case OPER_fnc: {	// '()' emit/call/cast
			int stktop = stkoffs(rt, 0);
			int stkret = stkoffs(rt, sizeOf(ast->type));
			astn argv = ast->op.rhso;
			symn var = linkOf(ast->op.lhso);

			dieif(!var && ast->op.lhso, "FixMe[%+k]", ast);

			// debug(...)
			if (rt->cc->libc_dbg && var == rt->cc->libc_dbg) {
				if (argv) {
					/*XXX:if (argv->kind == OPER_com) {
						// the last argument is a object by reference, pass also its type by ref
						symn typ = argv->op.rhso->type;
						if (argv->op.rhso->kind == OPER_adr) {
							typ = argv->op.rhso->op.rhso->type;
						}
						if (!genRef(rt, typ)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}*/
					while (argv->kind == OPER_com) {
						astn arg = argv->op.rhso;

						if (!cgen(rt, arg, arg->cst2)) {
							trace("%+k", arg);
							return TYPE_any;
						}
						argv = argv->op.lhso;
					}
					if (!cgen(rt, argv, argv->cst2)) {
						trace("%+k", argv);
						return TYPE_any;
					}
				}
				//~ dieif(!emitref(rt, NULL), "__FUNC__");
				dieif(!emiti32(rt, ast->line), "__FILE__");
				dieif(!emitref(rt, ast->file), "__FILE__");
				dieif(!emitint(rt, opc_libc, rt->cc->libc_dbg->offs), "__LIBC__");
				dieif(!emitidx(rt, opc_drop, stkret), "__DROP__");
				break;
			}

			// inline
			if (var && var->kind == TYPE_def) {
				int chachedArgSize = 0;
                symn param = var->prms;

                if (argv != NULL) {
					astn an = NULL;

					// this is done by lookup... but...
					while (argv->kind == OPER_com) {
						astn arg = argv->op.rhso;
						argv = argv->op.lhso;

						arg->next = an;
						an = arg;
					}
					argv->next = an;
					an = argv;

                    while (an && param) {
						int inlineArg = 0;
						astn arg = an;

						if (rt->vm.opti && eval(&tmp, arg)) {
							arg = &tmp;
						}

                        if (param->cast == TYPE_def) {
							inlineArg = 1;
						}
						else if (an->kind == TYPE_str) {
                            if (!param->used || !param->used->ref.used) {
								inlineArg = 1;
							}
						}
						else if (an->kind == TYPE_ref) {
                            if (an->type == param->type) {
								// static variables should not be inlined ?
								// what about indirect references ?
								//~ if (!an->ref.link->stat)
								inlineArg = 1;
							}
						}

						if (inlineArg) {
                            if (param->used && param->used->ref.used) {
								astn n = an;
								while (n && n->ref.link && n->ref.link->kind == TYPE_def) {
									n = n->ref.link->init;
								}
								if (n) switch (n->kind) {
									case TYPE_ref:
										break;
									default:
                                        warn(rt, 15, ast->file, ast->line, "inlineing argument `%T` used more than once: %+k", param, n);
								}
							}
                            param->kind = TYPE_def;
                            param->init = an;
						}
						else {
                            int stktop = stkoffs(rt, sizeOf(param));
                            chachedArgSize += sizeOf(param);
                            if (!param->used || !param->used->ref.used) {
								astn n = an;
								while (n && n->ref.link && n->ref.link->kind == TYPE_def) {
									n = n->ref.link->init;
								}
								if (n) switch (n->kind) {
									case TYPE_ref:
                                        warn(rt, 15, ast->file, ast->line, "caching argument used once or none: %-T = %+k", param, n);
										break;
									default:
										break;
								}
							}

                            warn(rt, 16, ast->file, ast->line, "caching argument: %-T = %+k", param, arg);
                            if (!cgen(rt, arg, param->cast)) {
								trace("%+k", arg);
								return TYPE_any;
							}
                            param->offs = stkoffs(rt, 0);
                            param->kind = TYPE_ref;
                            if (stktop != param->offs) {
                                error(rt, ast->file, ast->line, "invalid size: %d <> got(%d): `%+k`", stktop, param->offs, param);
								return TYPE_any;
							}
						}
						an = an->next;
                        param = param->next;
					}
                    dieif(an || param, "FixMe");
				}

				if (var->init) {
					var->init->file = ast->file;
					var->init->line = ast->line;
				}

				if (!(ret = cgen(rt, var->init, ret))) {
					trace("%+k", ast);
					return TYPE_any;
				}

				if (stkret != stkoffs(rt, 0)) {
					logif(chachedArgSize != stkoffs(rt, 0) - stkret, "%+T(%d%+d): %+k", ast->type, stkret, stkoffs(rt, 0)-stkret, ast);
					if (get != TYPE_vid) {
						if (!emitidx(rt, opc_ldsp, stkret)) {	// get stack
							trace("error");
							return TYPE_any;
						}
						if (!emitint(rt, opc_sti, sizeOf(ast->type))) {
							error(rt, ast->file, ast->line, "store indirect: %T:%d of `%+k`", ast->type, sizeOf(ast->type), ast);
							return TYPE_any;
						}
					}
					if (stkret < stkoffs(rt, 0)) {
						if (!emitidx(rt, opc_drop, stkret)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}
				}

                for (param = var->prms; param; param = param->next) {
                    param->kind = TYPE_ref;
                    param->init = NULL;
				}
				break;
			}

			// push Result, Arguments
			if (var && !istype(var) && var != rt->cc->emit_opc && var->call) {
				if (sizeOf(var->type) && !emitint(rt, opc_spc, sizeOf(var->type))) {
					trace("%+k", ast);
					return TYPE_any;
				}
				// result size on stack
				dieif(stkret != stkoffs(rt, 0), "FixMe");
			}
			if (argv) {
				astn argl = NULL;

				while (argv->kind == OPER_com) {
					astn arg = argv->op.rhso;
					if (!cgen(rt, arg, arg->cst2)) {
						trace("%+k", arg, arg->cst2);
						return TYPE_any;
					}
					arg->next = argl;
					argl = arg;
					argv = argv->op.lhso;
				}

				if (var == rt->cc->emit_opc && isType(argv)) {
					logif(DEBUGGING > 5, "static casting with emit: %+k @(%s: %d)", ast, ast->file, ast->line);
					break;
				}

				if (!cgen(rt, argv, argv->cst2)) {
					trace("%+k", argv);
					return TYPE_any;
				}

				if (var && var != rt->cc->emit_opc && var != rt->cc->libc_dbg && var->call && var->cast != TYPE_ref) {
					if (var->prms->offs != stkoffs(rt, 0) - stktop) {
						trace("args:%T(%d != %d(%d - %d))", var, var->prms->offs, stkoffs(rt, 0) - stktop, stkoffs(rt, 0), stktop);
						return TYPE_any;
					}
				}
				argv->next = argl;
				argl = argv;
			}

			if (var == rt->cc->emit_opc) {		// emit()
			}
			else if (istype(var)) {				// cast()
				if (!argv || argv != ast->op.rhso) {
					warn(rt, 1, ast->file, ast->line, "multiple values, array ?: '%+k'", ast);
				}
			}
			else if (var) {						// call()
				if (var->call) {
					if (!cgen(rt, ast->op.lhso, TYPE_ref)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					if (!emitopc(rt, opc_call)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					// clean the stack
					if (stkret != stkoffs(rt, 0) && !emitidx(rt, opc_drop, stkret)) {
						trace("%+k", ast);
						return TYPE_any;
					}
				}
				else {
					error(rt, ast->file, ast->line, "called object is not a function: %+T", var);
					return TYPE_any;
				}
			}
			else {								// ()
				dieif(ast->op.lhso, "FixMe %+k:%+k", ast, ast->op.lhso);
				if (!argv || argv != ast->op.rhso)
					warn(rt, 1, ast->file, ast->line, "multiple values, array ?: '%+k'", ast);
			}
		} break;
		case OPER_idx: {	// '[]'
			int r;
			if (!(r = cgen(rt, ast->op.lhso, TYPE_ref))) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (r == TYPE_arr) {
				if (!emitint(rt, opc_ldi, vm_size)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}

			if (rt->vm.opti && eval(&tmp, ast->op.rhso) == TYPE_int) {
				int offs = sizeOf(ast->type) * (int)constint(&tmp);
				if (!emitinc(rt, offs)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}
			else {
				int size = sizeOf(ast->type);	// size of array element
				if (!cgen(rt, ast->op.rhso, TYPE_u32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				if (size > 1) {
					//~ TODO: an index operator (mad with immediate value should be used)
					if (!emiti32(rt, size)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					if (!emitopc(rt, opc_umad)) {
						trace("%+k", ast);
						return TYPE_any;
					}
				}
				else if (size == 1) {
					if (!emitopc(rt, i32_add)) {
						trace("%+k", ast);
						return TYPE_any;
					}
				}
				else {
					// size of array element size error
					fatal("FixMe");
					return TYPE_any;
				}
			}

			if (get == TYPE_ref)
				return TYPE_ref;

			// ve need the value on that position (this can be a ref).
			if (!emitint(rt, opc_ldi, sizeOf(ast->type))) {
				trace("%+k", ast);
				return TYPE_any;
			}
		} break;
		case OPER_dot: {	// '.'
			// TODO: this should work as indexing
			symn var = linkOf(ast->op.rhso);
			int lhsstat = isType(ast->op.lhso);

			if (!var) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!var->stat && lhsstat) {
				error(rt, ast->file, ast->line, "An object reference is required to access the member `%+T`", var);
				return TYPE_any;
			}
			if (var->stat) {
				if (!lhsstat) {
					warn(rt, 5, ast->file, ast->line, "Member `%+T` is accessed with an instance reference", var);
				}
				return cgen(rt, ast->op.rhso, get);
			}

			if (var->memb) {
				if (!cgen(rt, ast->op.lhso, TYPE_ref)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				return cgen(rt, ast->op.rhso, get);
			}
			if (var->kind == TYPE_def) {
				// static array length is of this type
				trace("%+T: %t", var, get);
				return cgen(rt, ast->op.rhso, get);
			}

			if (!cgen(rt, ast->op.lhso, TYPE_ref)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!emitinc(rt, var->offs)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (var->cast == TYPE_ref/* && ast->cast == TYPE_ref*/) {
				if (!emitint(rt, opc_ldi, vm_size)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}

			if (get == TYPE_ref) {
				return TYPE_ref;
			}

			if (!emitint(rt, opc_ldi, sizeOf(ast->type))) {
				trace("%+k", ast);
				return TYPE_any;
			}
		} break;

		case OPER_not:		// '!'
		case OPER_adr:		// '&'
		case OPER_pls:		// '+'
		case OPER_mns:		// '-'
		case OPER_cmt: {	// '~'
			vmOpcode opc = -1;
			switch (ast->kind) {
				default:
					fatal("FixMe");
					return TYPE_any;

				case OPER_adr:
				case OPER_pls:
					return cgen(rt, ast->op.rhso, get);

				case OPER_mns:
					opc = opc_neg;
					break;
				case OPER_not:
					dieif(ret != TYPE_bit, "FixMe");
					opc = opc_not;
					break;
				case OPER_cmt:
					opc = opc_cmt;
					break;
			}
			if (!cgen(rt, ast->op.rhso, ret)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (!emitint(rt, opc, ret)) {
				trace("%+k", ast);
				return TYPE_any;
			}
		} break;

		case OPER_shl:		// '>>'
		case OPER_shr:		// '<<'
		case OPER_and:		// '&'
		case OPER_ior:		// '|'
		case OPER_xor:		// '^'

		case OPER_equ:		// '=='
		case OPER_neq:		// '!='
		case OPER_lte:		// '<'
		case OPER_leq:		// '<='
		case OPER_gte:		// '>'
		case OPER_geq:		// '>='

		case OPER_add:		// '+'
		case OPER_sub:		// '-'
		case OPER_mul:		// '*'
		case OPER_div:		// '/'
		case OPER_mod: {	// '%'
			int opc = -1;
			switch (ast->kind) {
				default:
					fatal("FixMe");
					return TYPE_any;

				case OPER_add: opc = opc_add; break;
				case OPER_sub: opc = opc_sub; break;
				case OPER_mul: opc = opc_mul; break;
				case OPER_div: opc = opc_div; break;
				case OPER_mod: opc = opc_mod; break;

				case OPER_neq: opc = opc_cne; break;
				case OPER_equ: opc = opc_ceq; break;
				case OPER_geq: opc = opc_cge; break;
				case OPER_lte: opc = opc_clt; break;
				case OPER_leq: opc = opc_cle; break;
				case OPER_gte: opc = opc_cgt; break;

				case OPER_shl: opc = opc_shl; break;
				case OPER_shr: opc = opc_shr; break;
				case OPER_and: opc = opc_and; break;
				case OPER_ior: opc = opc_ior; break;
				case OPER_xor: opc = opc_xor; break;
			}
			if (!cgen(rt, ast->op.lhso, TYPE_any)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (!cgen(rt, ast->op.rhso, TYPE_any)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (!emitint(rt, opc, ast->op.lhso->cst2)) {	// uint % int => u32.mod
				trace("opc__%02x:%+k", opc, ast);
				return TYPE_any;
			}

			#ifdef DEBUGGING
			// these must be true
			dieif(ast->op.lhso->cst2 != ast->op.rhso->cst2, "RemMe", ast);
			dieif(ret != castOf(ast->type), "RemMe");
			switch (ast->kind) {
				case OPER_neq:
				case OPER_equ:
				case OPER_geq:
				case OPER_lte:
				case OPER_leq:
				case OPER_gte:
					dieif(ret != TYPE_bit, "RemMe(%t): %+7K", ret, ast);
				default:
					break;
			}
			#endif
		} break;

		case OPER_lnd:		// '&&'
		case OPER_lor: {	// '||'
			vmOpcode opc = -1;
			// TODO: short circuit && and ||
			switch (ast->kind) {
				default:
					fatal("FixMe");
					return TYPE_any;

				case OPER_lnd: opc = opc_and; break;
				case OPER_lor: opc = opc_ior; break;
			}

			if (!cgen(rt, ast->op.lhso, TYPE_bit)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!cgen(rt, ast->op.rhso, TYPE_bit)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (!emitint(rt, opc, TYPE_u32)) {
				trace("opc__%02x:%+k", opc, ast);
				return TYPE_any;
			}// */

			/*astn jmp1 = 0, jmp2 = 0;
			switch (ast->kind) {
				default: fatal("FixMe"); return 0;
				case OPER_lnd:
					jmp1 = newnode(rt->cc, STMT_brk);
					jmp2 = newnode(rt->cc, STMT_brk);
					opc = opc_jnz;
					break;
				case OPER_lor:
					jmp1 = newnode(rt->cc, STMT_con);
					jmp2 = newnode(rt->cc, STMT_con);
					opc = opc_jz;
					break;
			}

			if (!cgen(rt, ast->op.lhso, TYPE_bit)) {
				trace("%+k", ast);
				return 0;
			}
			jmp1->go2.offs = emitopc(rt, opc);
			jmp1->go2.stks = stkoffs(rt, 0);
			jmp1->next = rt->cc->jmps;
			rt->cc->jmps = jmp1;

			if (!cgen(rt, ast->op.rhso, TYPE_bit)) {
				trace("%+k", ast);
				return 0;
			}
			jmp2->go2.offs = emitopc(rt, opc);
			jmp2->go2.stks = stkoffs(rt, 0);
			jmp2->next = rt->cc->jmps;
			rt->cc->jmps = jmp2;
			// */

			#ifdef DEBUGGING
			if (rt->cc->warn > 0) {
				static int firstTimeShowOnly = 1;
				if (firstTimeShowOnly) {
					warn(rt, 1, ast->file, ast->line, "operators `&&` and `||` does not short-circuit yet", ast);
					firstTimeShowOnly = 0;
				}
			}
			// these must be true
			//~ dieif(ast->op.lhso->cst2 != ast->op.rhso->cst2, "RemMe", ast);
			dieif(ast->op.lhso->cst2 != TYPE_bit, "RemMe", ast);
			dieif(ast->op.lhso->cst2 != TYPE_bit, "RemMe", ast);
			dieif(ret != castOf(ast->type), "RemMe");
			dieif(ret != TYPE_bit, "RemMe");
			#endif
		} break;
		case OPER_sel: {	// '?:'
			int jmpt, jmpf;
			if (rt->vm.opti && eval(&tmp, ast->op.test)) {
				if (!cgen(rt, constbol(&tmp) ? ast->op.lhso : ast->op.rhso, TYPE_any)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}
			else {
				int bppos = stkoffs(rt, 0);

				if (!cgen(rt, ast->op.test, TYPE_bit)) {
					trace("%+k", ast);
					return TYPE_any;
				}

				if (!(jmpt = emitopc(rt, opc_jz))) {
					trace("%+k", ast);
					return TYPE_any;
				}

				if (!cgen(rt, ast->op.lhso, TYPE_any)) {
					trace("%+k", ast);
					return TYPE_any;
				}

				if (!(jmpf = emitopc(rt, opc_jmp))) {
					trace("%+k", ast);
					return TYPE_any;
				}

				fixjump(rt, jmpt, emitopc(rt, markIP), bppos);

				if (!cgen(rt, ast->op.rhso, TYPE_any)) {
					trace("%+k", ast);
					return TYPE_any;
				}

				fixjump(rt, jmpf, emitopc(rt, markIP), -1);
			}
		} break;

		case ASGN_set: {	// ':='
			// TODO: ast->type->size;
			int size = sizeOf(ast->type);
			int refAssign = TYPE_ref;

			if (ast->op.lhso->kind == TYPE_ref) {
				symn typ = ast->op.lhso->type;
				//~ symn var = ast->op.lhso->ref.link;
				if (typ->kind == TYPE_rec && typ->cast == TYPE_ref) {
					logif(1, "reference Assignment: %+k", ast);
					dieif(ret != TYPE_ref, "FixMe");
					refAssign = ASGN_set;
					size = vm_size;
				}
			}

			if (!cgen(rt, ast->op.rhso, ret)) {
				trace("%+k", ast);
				return TYPE_any;
			}

			if (get != TYPE_vid) {
				dieif(get == TYPE_ref, "FixMe");	// case when: int &a = b = 9;
				// in case a = b = sum(2, 700);
				// dupplicate the result
				if (!emitint(rt, opc_ldsp, 0)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				if (!emitint(rt, opc_ldi, size)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			}
			else
				ret = get;

			if (!cgen(rt, ast->op.lhso, refAssign)) {
				trace("%+k", ast);
				return TYPE_any;
			}
			if (!emitint(rt, opc_sti, size)) {
				trace("%+k", ast);
				return TYPE_any;
			}
		} break;
		//#}
		//#{ TVAL
		case TYPE_int: switch (get) {
			//~ case TYPE_rec: return emiti32(s, ast->con.cint) ? TYPE_i32 : 0;
			case TYPE_vid: return TYPE_vid;
			case TYPE_bit: return emiti32(rt, constbol(ast)) ? TYPE_u32 : TYPE_any;
			case TYPE_u32: return emiti32(rt, (uint32_t)ast->con.cint) ? TYPE_u32 : TYPE_any;
			case TYPE_i32: return emiti32(rt, (int32_t)ast->con.cint) ? TYPE_i32 : TYPE_any;
			case TYPE_i64: return emiti64(rt, ast->con.cint) ? TYPE_i64 : TYPE_any;
			case TYPE_f32: return emitf32(rt, (float32_t)ast->con.cint) ? TYPE_f32 : TYPE_any;
			case TYPE_f64: return emitf64(rt, (float64_t)ast->con.cint) ? TYPE_f64 : TYPE_any;
			default:
				error(rt, ast->file, ast->line, "invalid cast of `%+k:`", ast);
				debug("invalid cast: to (%t) '%+k'", get, ast);
				return TYPE_any;
		} break;
		case TYPE_flt: switch (get) {
			case TYPE_vid: return TYPE_vid;
			case TYPE_bit: return emiti32(rt, constbol(ast)) ? TYPE_u32 : TYPE_any;
			case TYPE_u32: return emiti32(rt, (uint32_t)ast->con.cflt) ? TYPE_u32 : TYPE_any;
			case TYPE_i32: return emiti32(rt, (int32_t)ast->con.cflt) ? TYPE_i32 : TYPE_any;
			case TYPE_i64: return emiti64(rt, (int64_t)ast->con.cflt) ? TYPE_i64 : TYPE_any;
			case TYPE_f32: return emitf32(rt, (float32_t)ast->con.cflt) ? TYPE_f32 : TYPE_any;
			case TYPE_f64: return emitf64(rt, (float64_t)ast->con.cflt) ? TYPE_f64 : TYPE_any;
			default:
				error(rt, ast->file, ast->line, "invalid cast of `%+k:`", ast);
				debug("invalid cast: to (%t) '%+k'", get, ast);
				return TYPE_any;
		} break;
		case TYPE_str: switch (get) {
			case TYPE_vid: return TYPE_vid;
			case TYPE_ref: return emitref(rt, ast->ref.name) ? TYPE_ref : TYPE_any;
			case TYPE_arr: {
				if (!emiti32(rt, strlen(ast->ref.name))) {
					trace("%+k", ast);
					return TYPE_any;
				}
				if (!emitref(rt, ast->ref.name)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			} return TYPE_ref;
			default:
				error(rt, ast->file, ast->line, "invalid cast of `%+k:`", ast);
				debug("invalid cast: to (%t) '%+k'", get, ast);
				return TYPE_any;
		} break;

		case TYPE_ref: {					// use (var, func, define)
			symn typ = ast->type;			// type
			symn var = ast->ref.link;		// link
			// TODO: ast->type->size;
			int size = sizeOf(typ);
			dieif(!typ || !var, "FixMe");

			switch (var->kind) {
				case TYPE_arr:		// typename
				case TYPE_rec:		// typename
				case TYPE_ref: {	// variable
					ccToken retarr = TYPE_any;
					logif(var->size == 0, "invalid use of variable: `%-T`", var);

					// a slice is needed, push(length).
					//~ logif(get == TYPE_arr, "assign to array from %t to %t @ %k(%t)", ret, get, ast, ast->type->cast);
					if (get == TYPE_arr && ret != TYPE_arr) {
						// ArraySize
						if (!emiti32(rt, typ->offs)) {// size / typ->type->size)) {
							trace("%+k", ast);
							return TYPE_any;
						}
						retarr = TYPE_arr;
						get = TYPE_ref;
					}

					if (!genRef(rt, var)) {
						trace("%+k", ast);
						return TYPE_any;
					}

					// byVal references are assigned by value
					// byRef references are assigned by reference
					if (get == ASGN_set) {
						get = TYPE_ref;
					}
					//TODO: else if (var != typ && (var->cast == TYPE_ref || var->cast == TYPE_arr)) {
					else if (var->cast == TYPE_ref && var != typ) {
						if (!emitint(rt, opc_ldi, vm_size)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}

					if (get != TYPE_ref) {
						if (get == TYPE_arr && ret == TYPE_arr) {
							//~ info(rt, __FILE__, __LINE__, "assign to array from %t @ %k", ret, ast);
							//~ info(rt, ast->file, ast->line, "assign to array from %t @ %k", ret, ast);
							size = 8;
						}

						if (!emitint(rt, opc_ldi, size)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}
					else {
						if (var->cast == TYPE_arr) {
							//~ info(rt, __FILE__, __LINE__, "assign to array from %t @ %k", ret, ast);
							retarr = TYPE_arr;
						}
						ret = TYPE_ref;
					}

					if (retarr != 0) {
						ret = get = retarr;
					}
				} break;
				case EMIT_opc:
					dieif(get == TYPE_ref, "FixMe");
					if (!emitint(rt, var->offs, var->init ? constint(var->init) : 0)) {
						error(rt, ast->file, ast->line, "error emiting opcode: %+k", ast);
						if (stkoffs(rt, 0) > 0) {
							info(rt, ast->file, ast->line, "%+k underflows stack.", ast);
						}
						return TYPE_any;
					}
					return TYPE_vid;

				case TYPE_def:
					//~ TODO: reimplement: it works, but ...
					if (var->init) {
						return cgen(rt, var->init, get);
					}
				default:
					error(rt, ast->file, ast->line, "invalid rvalue `%+k:` %t", ast, var->kind);
					return TYPE_any;
			}
		} break;
		case TYPE_def: {					// new (var, func, define)
			symn typ = ast->type;
			symn var = ast->ref.link;
			int size = padded(sizeOf(var), vm_size);
			int stktop = stkoffs(rt, size);
			dieif(!typ || !var, "FixMe");

			if (var->kind == TYPE_ref) {

				// skip initialized static function variables
				if (var->init && var->offs && !rt->cc->sini) {
					return TYPE_vid;
				}

				// initialize (and allocate local) variables.
				if (var->init != NULL) {
					astn val = var->init;

					// ... a = emit(...);	// initialization with emit
					if (val->type == rt->cc->emit_opc) {
						ret = get;
					}

					// string a = null;		// initialization with null
					else if (rt->cc->null_ref == linkOf(val)) {
						trace("assigning null: %-T", var);
						val->cst2 = ret = TYPE_ref;
					}

					// int a(int x) = abs;	// reference initialization
					else if (var->call || var->cast == TYPE_ref) {
						ret = TYPE_ref;
					}

					// int a[3] = {1,2,3};	// array initialization by elements
					// FIXME: if valuetype is arrays base type
					if (typ->kind == TYPE_arr && var->prms == val->type) {
						int i, esize;
						symn base = typ;
						astn tmp = NULL;
						int nelem = 1;
						int ninit = 0;

						// TODO: base should not be stored in var->args !!!
						while (base && base != var->prms) {
							if (base->init == NULL)
								break;
							// ArraySize
							//~ nelem *= base->size / base->type->size;//constint(base->init);//->con.cint;
							nelem *= base->offs;
							base = base->type;
						}
						if (base == NULL) {
							base = typ;
						}

						dieif(!base, "FixMe %+k", ast);

						ret = base->cast;
						esize = sizeOf(base);

						// int a[8] = 0; / int a[8] = 0, 1, 2, 3, 4, 5, 6, 7;

						while (val->kind == OPER_com) {
							// stringify the initializers
							val->op.rhso->next = tmp;
							tmp = val->op.rhso;
							val = val->op.lhso;
						}
						val->next = tmp;

						// local variable
						if (var->offs == 0) {
							if (!emitint(rt, opc_spc, size)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							i = padded(esize, vm_size);		// size of one element on stack
						}
						else {
							i = 0;
							size = 0;
						}

						for (tmp = val; val && ninit < nelem; ninit += 1, i += esize, val = val->next) {
							tmp = val;
							if (!cgen(rt, tmp, ret)) {
								trace("%+k", tmp);
								return TYPE_any;
							}

							if (var->offs == 0) {
								if (!emitint(rt, opc_ldsp, i)) {
									trace("%+k", ast);
									return TYPE_any;
								}
							}
							else {
								if (!genRef(rt, var)) {
									trace("%+k", ast);
									return TYPE_any;
								}
								if (!emitinc(rt, i)) {
									trace("%+k", ast);
									return TYPE_any;
								}
							}

							if (!emitint(rt, opc_sti, esize)) {
								trace("%+k", ast);
								return TYPE_any;
							}
						}

						if (ninit < nelem) {
							int loopCpy;
							int valOffs = 0;
							int dstOffs = 0;
							int stkOffs = stkoffs(rt, 0);

							// push val
							// push dst

							if (!cgen(rt, tmp, ret)) {
								trace("%+k", tmp);
								return TYPE_any;
							}
							valOffs = stkoffs(rt, 0);

							if (var->offs == 0) {
								if (!emitint(rt, opc_ldsp, i - esize)) {
									trace("%+k", ast);
									return TYPE_any;
								}
							}
							else {
								if (!genRef(rt, var)) {
									trace("%+k", ast);
									return TYPE_any;
								}
								if (!emitinc(rt, i - esize)) {
									trace("%+k", ast);
									return TYPE_any;
								}
							}

							// push end
							// push dst
							if (!emitint(rt, opc_dup1, 0)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitinc(rt, esize * (nelem - ninit))) {
								trace("%+k", ast);
								return TYPE_any;
							}

							if (!emitint(rt, opc_dup1, 1)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							//~ :loopCopy
							loopCpy = emitopc(rt, markIP);
							dstOffs = stkoffs(rt, 0);
							//~ inc dst, size
							//~ dupp val
							//~ dupp dst
							//~ sti size
							if (!emitinc(rt, esize)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							if (!emitidx(rt, opc_ldsp, valOffs)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitint(rt, opc_ldi, esize)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							if (!emitidx(rt, opc_dup1, dstOffs)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							if (!emitint(rt, opc_sti, esize)) {
								trace("%+k", ast);
								return TYPE_any;
							}

							//~ dupp.x2
							//~ clt.i32
							//~ jnz loopCopy
							if (!emitint(rt, opc_dup2, 0)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitopc(rt, i32_cgt)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitint(rt, opc_jnz, loopCpy)) {
								trace("%+k", ast);
								return TYPE_any;
							}
							if (!emitidx(rt, opc_drop, stkOffs)) {
								trace("%+k", ast);
								return TYPE_any;
							}
						}

						if (val != NULL) {
							error(rt, ast->file, ast->line, "Too many initializers: starting at `%+k`", val);
							return TYPE_any;
						}
					}

					// int a = 99;	// variable initialization
					else {
						logif(val->cst2 != var->cast, "FixMe(%t : %t): %15.15K", val->cst2, var->cast, val);
						if (!cgen(rt, val, var->cast)) {
							trace("%+k", ast);
							return TYPE_any;
						}
					}

					if (var->offs == 0) {		// create local variable
						var->offs = stkoffs(rt, 0);
						if (stktop != var->offs) {
							error(rt, ast->file, ast->line, "invalid initializer size: %d diff(%d): `%+k`", stktop, stktop - var->offs, ast);
							return TYPE_any;
						}
					}
					else if (size > 0) {		// initialize gloabal
						if (!genRef(rt, var)) {
							trace("%+k", ast);
							return TYPE_any;
						}
						if (!emitint(rt, opc_sti, size)) {
							trace("%+k:sizeof(%-T) = %d", ast, var, size);
							return TYPE_any;
						}
					}
				}

				// alloc locally a block of the size of the type;
				else if (var->offs == 0) {
					logif(var->size != sizeOf(typ), "FixMe %T(%d, %d)", var, var->size, sizeOf(typ));
					if (!emitint(rt, opc_spc, size)) {
						trace("%+k", ast);
						return TYPE_any;
					}
					var->offs = stkoffs(rt, 0);
					if (var->offs < size) {
						error(rt, ast->file, ast->line, "stack underflow", var->offs, size);
						return TYPE_any;
					}
				}
				else {
					// static uninitialized variable
				}
			}

			dieif(get != TYPE_vid, "FixMe");
			get = ret = TYPE_vid;
		} break;

		case EMIT_opc:
			trace("%+k", ast);
			return TYPE_any;
		//#}
	}

	// generate cast
	if (get != ret) switch (get) {

		case TYPE_vid:
			ret = get;
			break;

		case TYPE_any: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_vid:
			case TYPE_ref:
				break;
		} break;

		case TYPE_bit: switch (ret) {		// to boolean
			default:
				goto errorcast2;

			case TYPE_u32:
			case TYPE_i32:
				if (!emitopc(rt, i32_bol)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_i64:
				if (!emitopc(rt, i64_bol)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f32:
				if (!emitopc(rt, f32_bol)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f64:
				if (!emitopc(rt, f64_bol)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
		} break;

		case TYPE_u32: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_bit:
			case TYPE_i32:
				break;

			case TYPE_i64: {
				if (!emitopc(rt, i64_i32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
			} break;
			//~ case TYPE_f32: if (!emitopc(s, f32_i32)) return TYPE_any; break;
			//~ case TYPE_f64: if (!emitopc(s, f64_i32)) return TYPE_any; break;
		} break;

		case TYPE_i32: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_bit:
			//~ case TYPE_any:
			case TYPE_u32:
				break;
			case TYPE_i64:
				if (!emitopc(rt, i64_i32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f32:
				if (!emitopc(rt, f32_i32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f64:
				if (!emitopc(rt, f64_i32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			//~ case TYPE_ref: if (!emitopc(s, opc_ldi, vm_size)) return TYPE_any; break;
		} break;

		case TYPE_i64: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_bit:
			case TYPE_u32:
				if (!emitopc(rt, u32_i64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_i32:
				if (!emitopc(rt, i32_i64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f32:
				if (!emitopc(rt, f32_i64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f64:
				if (!emitopc(rt, f64_i64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			//~ case TYPE_ref: if (!emitopc(s, opc_ldi, 8)) return TYPE_any; break;
		} break;

		case TYPE_f32: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_bit:
			//~ case TYPE_u32:
			case TYPE_i32:
				if (!emitopc(rt, i32_f32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_i64:
				if (!emitopc(rt, i64_f32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f64:
				if (!emitopc(rt, f64_f32)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			//~ case TYPE_ref: if (!emitopc(s, opc_ldi, vm_size)) return TYPE_any; break;
		} break;

		case TYPE_f64: switch (ret) {
			default:
				goto errorcast2;
				
			case TYPE_bit:
			//~ case TYPE_u32:
			case TYPE_i32:
				if (!emitopc(rt, i32_f64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_i64:
				if (!emitopc(rt, i64_f64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			case TYPE_f32:
				if (!emitopc(rt, f32_f64)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;
			//~ case TYPE_ref: if (!emitopc(s, opc_ldi, 8)) return 0; break;
		} break;

		case TYPE_ref:
		case TYPE_arr: switch (ret) {
			default:
				goto errorcast2;

			case EMIT_opc:
				return EMIT_opc;
		}

		case TYPE_ptr: switch (ret) {
			default:
				goto errorcast2;

			case TYPE_ref:
				return TYPE_ptr;
		}

		default:
			fatal("%d: unimplemented(cast for `%+k`, %t):%t", ast->line, ast, get, ret);
			// fall to next case

		errorcast2:
			trace("cgen[%t->%t](%+k)\n%7K", ret, get, ast, ast);
			return TYPE_any;
	}

	// zero extend ...
	if (get == TYPE_u32) {
		switch (ast->type->size) {
			default:
				fatal("FixMe");
				break;

			case 1:
				if (!emitint(rt, b32_bit, b32_bit_and | 8)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;

			case 2:
				if (!emitint(rt, b32_bit, b32_bit_and | 16)) {
					trace("%+k", ast);
					return TYPE_any;
				}
				break;

			case 4:
				break;
		}
	}

	// debug info, invalid after first execution
	if ((ast->kind == TYPE_def || (ast->kind > STMT_beg && ast->kind < STMT_end))) {
		int ipEnd = emitopc(rt, markIP);
		if (ipdbg < ipEnd) {
			addCodeMapping(rt, ast, ipdbg, ipEnd);
			//~ list l = (list)setBuff(&rt->cc->dbg, rt->cc->dbg.cnt, NULL);
			//~ dieif(!l, "Fatal Error allocating @%d", rt->cc->dbg.cnt);
			//~ l->data = (unsigned char*)ast;
			//~ l->size = ipdbg;
		}
	}

	#ifdef DEBUGGING
	logif(qual != 0, "unimplemented qualified statement `%+k`: %t", ast, qual);
	#endif

	return ret;
}

int gencode(state rt, int level, int doDebug) {
	ccState cc = rt->cc;
	libc lc = NULL;
	int Lmain;

	dieif(rt->errc, "can not generate code");
	dieif(cc == NULL, "compiler state invalid");

	/* leaving the global scope.
	 * HACK: if the optimization level is negative,
	 * global variables wont be static.
	 */
	rt->defs = leave(rt->cc, NULL, level >= 0);

	/* reorder the initialization of static variables.
	 * TODO: optimize code.
	 *
	 *	ex: g must be generated before f
	 *	int f() {
	 *		static int g = 9;
	 *		// ...
	 *	}
	 */
	if (rt->gdef != NULL) {
		symn ng, pg = NULL;
		for (ng = rt->gdef; ng; ng = ng->gdef) {
			symn Ng, Pg = NULL;

			for (Ng = ng; Ng; Ng = Ng->gdef) {
				if (Ng->decl == ng) {
					break;
				}
				Pg = Ng;
			}

			//~ this must be generated before sym;
			if (Ng) {
				Pg->gdef = Ng->gdef;	// remove
				Ng->gdef = ng;
				if (pg) {
					pg->gdef = Ng;
				}
				else {
					rt->gdef = Ng;
					break;
				}
				ng = pg;
			}
			pg = ng;
		}
	}

	// allocate used memeory
	rt->vm.pos = rt->_beg - rt->_mem;
	rt->vm.opti = level < 0 ? -level : level;

	rt->vm.size.meta = rt->vm.pos;

	// libcalls
	if (cc->libc) {
		rt->vm.libv = rt->_mem + rt->vm.pos;
		rt->vm.pos += sizeof(struct libc) * (cc->libc->pos + 1);
		dieif(rt->_end < rt->_mem + rt->vm.pos, "memory overrun");
		for (lc = cc->libc; lc; lc = lc->next) {
			((struct libc*)rt->vm.libv)[lc->pos] = *lc;
		}
	}

	if (doDebug) {
		rt->dbg = (dbgState)(rt->_mem + rt->vm.pos);
		rt->vm.pos += sizeof(struct dbgStateRec);
		dieif(rt->_end < rt->_mem + rt->vm.pos, "memory overrun");
		memset(rt->dbg, 0, sizeof(struct dbgStateRec));

		initBuff(&rt->dbg->codeMap, 128, sizeof(struct dbgInfo));
	}

	//~ read only memory ends here.
	//~ strings, typeinfos, TODO(constants, functions, enums, ...)
	rt->vm.ro = rt->vm.pos;

	// static vars & functions
	if (rt->defs) {
		symn var = rt->defs;

		// we will append the list of declarations here.
		astn staticinitializers = newnode(cc, STMT_beg);

		// mark global variables, and make them static if needed.
		for (var = rt->defs; var; var = var->next) {
			// include only variables.
			if (var->kind != TYPE_ref)
				continue;

			if (!var->stat && level >= 0) {
				var->stat = 1;
			}
			var->glob = 1;
		}
		// generate global and static variables & functions
		for (var = rt->gdef; var; var = var->gdef) {

			if (var == rt->cc->null_ref)
				continue;

			if (var->kind != TYPE_ref)
				continue;

			if (!(var->glob || var->stat))
				continue;

			dieif(var->kind != TYPE_ref, "FixMe");

			if (var->call && var->cast != TYPE_ref) {
				int seg = emitopc(rt, markIP);

				if (!var->init) {
					debug("`%T` will be skipped", var);
					continue;
				}

				rt->cc->sini = 0;
				rt->vm.sm = 0;
				fixjump(rt, 0, 0, vm_size + var->offs);
				rt->vm.ro = stkoffs(rt, 0);
				rt->vm.sm = rt->vm.ss;		// leave return address on stack

				var->offs = emitopc(rt, markIP);

				if (!cgen(rt, var->init, TYPE_vid)) {
					continue;
				}
				if (!emitopc(rt, opc_jmpi)) {
					error(rt, var->file, var->line, "error emiting function: %-T", var);
					continue;
				}
				while (cc->jmps) {
					error(rt, NULL, 0, "invalid jump: `%k`", cc->jmps);
					cc->jmps = cc->jmps->next;
				}
				var->size = emitopc(rt, markIP) - seg;
				var->init = NULL;
				var->stat = 1;
			}
			else {
				dieif(var->offs, "FixMe %-T@%d:%t", var, var->offs, var->cast);
				var->size = sizeOf(var);
				var->offs = rt->vm.pos;
				rt->vm.pos += var->size;

				//~ rt->vm.size.data += var->size;

				if (var->init && !var->glob) {
					astn init = newnode(cc, TYPE_def);

					if (!isConst(var->init)) {
						warn(rt, 1, var->file, var->line, "non constant initialization of static variable `%-T`", var);
					}

					//~ make initialization from initializer
					init->type = var->type;
					init->file = var->file;
					init->line = var->line;
					init->cst2 = var->cast;
					init->ref.link = var;

					init = opnode(cc, STMT_do, NULL, init);
					init->type = cc->type_vid;
					init->file = var->file;
					init->line = var->line;

					if (staticinitializers->list.head == NULL) {
						staticinitializers->list.head = init;
					}
					else {
						staticinitializers->list.tail->next = init;
					}
					staticinitializers->list.tail = init;
				}
			}
		}

		// initialize static non global variables
		if (staticinitializers && staticinitializers->list.tail) {
			dieif(!cc->root || cc->root->kind != STMT_beg, "FixMe");
			staticinitializers->list.tail->next = cc->root->stmt.stmt;
			cc->root->stmt.stmt = staticinitializers->list.head;
		}
	}

	rt->cc->sini = 1;

	Lmain = rt->vm.pos;
	if (cc->root) {
		int seg = rt->vm.pos;
		rt->vm.ss = rt->vm.sm = 0;

		// TYPE_vid clears the stack
		if (!cgen(rt, cc->root, level < 0 ? TYPE_any : TYPE_vid)) {
			error(rt, NULL, 0, "invalid jump: `%k`", cc->jmps);
			fputasm(rt, rt->logf, seg, -1, 0x10);
			trace("Error");
			return 0;
		}

		while (cc->jmps) {
			error(rt, NULL, 0, "invalid jump: `%k`", cc->jmps);
			cc->jmps = cc->jmps->next;
			trace("Error");
			return 0;
		}
	}

	rt->vm.px = emiti32(rt, 0);
	emitint(rt, opc_libc, 0);

	// program entry point
	rt->vm.pc = Lmain;
	rt->vm.size.code = rt->vm.pos;
	rt->vm.size.data = rt->vm.pos;

	rt->_beg = rt->_end = NULL;
	rt->vm._heap = NULL;

	if (rt->dbg != NULL) {
		int i, j;
		arrBuffer *codeMap = &rt->dbg->codeMap;
		for (i = 0; i < codeMap->cnt; ++i) {
			for (j = i; j < codeMap->cnt; ++j) {
				dbgInfo a = getBuff(codeMap, i);
				dbgInfo b = getBuff(codeMap, j);
				if (a->end > b->end) {
					memswap(a, b, sizeof(struct dbgInfo));
				}
				else if (a->end == b->end) {
					if (a->start < b->start) {
						memswap(a, b, sizeof(struct dbgInfo));
					}
				}
			}
		}
		/*for (i = 0; i < codeMap->cnt; ++i) {
			dbgInfo dbg = getBuff(codeMap, i);
			astn ast = dbg->code;
			fputfmt(stdout, "%s:%d:@%06x-%06x: %+k\n", ast->file, ast->line, dbg->start, dbg->end, ast);
		}*/
	}

	return rt->errc;
}

// install basic types
symn emit_opc_ = NULL;
static void install_type(ccState cc, int mode) {
	symn type_rec, type_vid, type_bol, type_ptr = NULL, type_var = NULL;
	symn type_i08, type_i16, type_i32, type_i64;
	symn type_u08, type_u16, type_u32;
	symn type_f32, type_f64;
	symn type_chr;

	type_rec = install(cc, "typename", ATTR_const | ATTR_stat | TYPE_rec, TYPE_ref, 0, NULL, NULL);

	type_vid = install(cc,    "void", ATTR_const | ATTR_stat | TYPE_rec, TYPE_vid, 0, type_rec, NULL);
	type_bol = install(cc,    "bool", ATTR_const | ATTR_stat | TYPE_rec, TYPE_bit, 4, type_rec, NULL);
	type_i08 = install(cc,    "int8", ATTR_const | ATTR_stat | TYPE_rec, TYPE_i32, 1, type_rec, NULL);
	type_i16 = install(cc,   "int16", ATTR_const | ATTR_stat | TYPE_rec, TYPE_i32, 2, type_rec, NULL);
	type_i32 = install(cc,   "int32", ATTR_const | ATTR_stat | TYPE_rec, TYPE_i32, 4, type_rec, NULL);
	type_i64 = install(cc,   "int64", ATTR_const | ATTR_stat | TYPE_rec, TYPE_i64, 8, type_rec, NULL);
	type_u08 = install(cc,   "uint8", ATTR_const | ATTR_stat | TYPE_rec, TYPE_u32, 1, type_rec, NULL);
	type_u16 = install(cc,  "uint16", ATTR_const | ATTR_stat | TYPE_rec, TYPE_u32, 2, type_rec, NULL);
	type_u32 = install(cc,  "uint32", ATTR_const | ATTR_stat | TYPE_rec, TYPE_u32, 4, type_rec, NULL);
	// type_ = install(cc,  "uint64", ATTR_const | ATTR_stat | TYPE_rec, TYPE_u64, 8, type_rec, NULL);
	type_f32 = install(cc, "float32", ATTR_const | ATTR_stat | TYPE_rec, TYPE_f32, 4, type_rec, NULL);
	type_f64 = install(cc, "float64", ATTR_const | ATTR_stat | TYPE_rec, TYPE_f64, 8, type_rec, NULL);

	type_vid->pfmt = "";
	type_bol->pfmt = "bool(%d)";
	type_i08->pfmt = "int8(%d)";
	type_i16->pfmt = "int16(%d)";
	type_i32->pfmt = "int32(%d)";
	type_i64->pfmt = "int64(%D)";
	type_u08->pfmt = "uint8(%u)";
	type_u16->pfmt = "uint16(%u)";
	type_u32->pfmt = "uint32(%u)";
	// type_->pfmt = "uint64(%U)";
	type_f32->pfmt = "float32(%f)";
	type_f64->pfmt = "float64(%F)";
	type_rec->type = type_rec;

	if (mode & creg_tptr) {
		type_ptr = install(cc,  "pointer", ATTR_const | ATTR_stat | TYPE_rec, TYPE_ref, vm_size, type_rec, NULL);
		cc->null_ref = install(cc, "null", ATTR_const | ATTR_stat | TYPE_ref, TYPE_any, vm_size, type_ptr, NULL);
		if (type_ptr != NULL) {
			type_ptr->pfmt = "pointer(@%06x)";
		}
	}

	if (mode & creg_tvar) {
		type_var = install(cc, "variant", ATTR_const | ATTR_stat | TYPE_rec, TYPE_rec, 2 * vm_size, type_rec, NULL);
	}

	cc->type_rec = type_rec;
	cc->type_vid = type_vid;
	cc->type_bol = type_bol;
	cc->type_i32 = type_i32;
	cc->type_i64 = type_i64;
	cc->type_u32 = type_u32;
	cc->type_f32 = type_f32;
	cc->type_f64 = type_f64;
	cc->type_ptr = type_ptr;
	cc->type_var = type_var;

	// aliases.
	install(cc, "int",    ATTR_const | TYPE_def, 0, 0, type_i32, NULL);
	install(cc, "long",   ATTR_const | TYPE_def, 0, 0, type_i64, NULL);
	install(cc, "float",  ATTR_const | TYPE_def, 0, 0, type_f32, NULL);
	install(cc, "double", ATTR_const | TYPE_def, 0, 0, type_f64, NULL);

	install(cc, "true",   ATTR_const | TYPE_def, 0, 0, type_bol, intnode(cc, 1));
	install(cc, "false",  ATTR_const | TYPE_def, 0, 0, type_bol, intnode(cc, 0));

	//~ type_chr = install(cc, "char", ATTR_const | ATTR_stat | TYPE_def, 0, 0, type_u08, NULL);
	type_chr = install(cc, "char", ATTR_const | ATTR_stat | TYPE_rec, TYPE_u32, 1, type_rec, NULL);
	type_chr->pfmt = "'%c'";

	//~ TODO: struct string: char[] { ... }, temporarly string is alias for uint8[]
	cc->type_str = install(cc, "string", ATTR_const | ATTR_stat | TYPE_arr, TYPE_ref, vm_size, type_chr, NULL);
	if (cc->type_str != NULL) {
		cc->type_str->pfmt = "string(`%s`)";
		cc->type_str->init = intnode(cc, -1);
	}

	if (type_var != NULL) {
		install(cc, "var",    ATTR_const | TYPE_def, 0, 0, type_var, NULL);
		//~ install(cc, "array", ATTR_const | TYPE_arr, 0, 0, cc->type_var, NULL);		// array is alias for variant[]
	}

	(void)type_i08;
	(void)type_i16;
	(void)type_u16;
}

// install the emit thingie
static void install_emit(ccState cc, int mode) {
	state rt = cc->s;
	symn typ = NULL;
	symn type_v4f = NULL;

	// TODO: emit is a keyword ???
	cc->emit_opc = install(cc, "emit", EMIT_opc, 0, 0, NULL, NULL);
	emit_opc_ = cc->emit_opc;

	if (cc->emit_opc && (mode & creg_eopc) == creg_eopc) {

		symn u32, i32, i64, f32, f64, v4f, v2d;

		ccBegin(rt, NULL);
		install(cc, "ref", ATTR_const | ATTR_stat | TYPE_rec, TYPE_ref, vm_size, NULL, NULL);

		u32 = install(cc, "u32", ATTR_const | ATTR_stat | TYPE_rec, TYPE_u32, 4, NULL, NULL);
		i32 = install(cc, "i32", ATTR_const | ATTR_stat | TYPE_rec, TYPE_i32, 4, NULL, NULL);
		i64 = install(cc, "i64", ATTR_const | ATTR_stat | TYPE_rec, TYPE_i64, 8, NULL, NULL);
		f32 = install(cc, "f32", ATTR_const | ATTR_stat | TYPE_rec, TYPE_f32, 4, NULL, NULL);
		f64 = install(cc, "f64", ATTR_const | ATTR_stat | TYPE_rec, TYPE_f64, 8, NULL, NULL);

		v4f = install(cc, "v4f", ATTR_const | ATTR_stat | TYPE_rec, TYPE_rec, 16, NULL, NULL);
		v2d = install(cc, "v2d", ATTR_const | ATTR_stat | TYPE_rec, TYPE_rec, 16, NULL, NULL);

		install(cc, "nop", EMIT_opc, 0, opc_nop, cc->type_vid, NULL);
		install(cc, "not", EMIT_opc, 0, opc_not, cc->type_bol, NULL);
		//~ install(cc, "pop", EMIT_opc, 0, opc_drop, cc->type_vid, intnode(cc, 1));
		install(cc, "set", EMIT_opc, 0, opc_set1, cc->type_vid, intnode(cc, 1));
		//~ install(cc, "join", EMIT_opc, 0, opc_sync, cc->type_vid, intnode(cc, 1));
		//~ install(cc, "set0", EMIT_opc, opc_set1, cc->type_vid, intnode(cc, 0));
		//~ install(cc, "set1", EMIT_opc, opc_set1, cc->type_vid, intnode(cc, 1));

		if ((typ = ccBegin(rt, "dupp"))) {
			install(cc, "x1", EMIT_opc, 0, opc_dup1, cc->type_i32, intnode(cc, 0));
			install(cc, "x1_1", EMIT_opc, 0, opc_dup1, cc->type_i32, intnode(cc, 1));
			install(cc, "x1_2", EMIT_opc, 0, opc_dup1, cc->type_i32, intnode(cc, 2));
			install(cc, "x2", EMIT_opc, 0, opc_dup2, cc->type_i64, intnode(cc, 0));
			install(cc, "x4", EMIT_opc, 0, opc_dup4, cc->type_vid, intnode(cc, 0));
			ccEnd(cc->s, typ);
		}
		if ((typ = install(cc, "load", ATTR_const | ATTR_stat | TYPE_rec, TYPE_vid, 0, NULL, NULL))) {
			ccBegin(rt, NULL);

			// load zero
			install(cc, "z32", EMIT_opc, 0, opc_ldz1, cc->type_vid, NULL);
			install(cc, "z64", EMIT_opc, 0, opc_ldz2, cc->type_vid, NULL);
			install(cc, "z128", EMIT_opc, 0, opc_ldz4, cc->type_vid, NULL);

			// load memory
			install(cc, "i8",   EMIT_opc, 0, opc_ldi1, cc->type_vid, NULL);
			install(cc, "i16",  EMIT_opc, 0, opc_ldi2, cc->type_vid, NULL);
			install(cc, "i32",  EMIT_opc, 0, opc_ldi4, cc->type_vid, NULL);
			install(cc, "i64",  EMIT_opc, 0, opc_ldi8, cc->type_vid, NULL);
			install(cc, "i128", EMIT_opc, 0, opc_ldiq, cc->type_vid, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = install(cc, "store", ATTR_const | ATTR_stat | TYPE_rec, TYPE_vid, 0, NULL, NULL))) {
			ccBegin(rt, NULL);
			install(cc, "i8",   EMIT_opc, 0, opc_sti1, cc->type_vid, NULL);
			install(cc, "i16",  EMIT_opc, 0, opc_sti2, cc->type_vid, NULL);
			install(cc, "i32",  EMIT_opc, 0, opc_sti4, cc->type_vid, NULL);
			install(cc, "i64",  EMIT_opc, 0, opc_sti8, cc->type_vid, NULL);
			install(cc, "i128", EMIT_opc, 0, opc_stiq, cc->type_vid, NULL);
			ccEnd(rt, typ);
		}

		install(cc, "call", EMIT_opc, 0, opc_call, cc->type_vid, NULL);

		if ((typ = u32) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "cmt", EMIT_opc, 0, b32_cmt, cc->type_u32, NULL);
			install(cc, "and", EMIT_opc, 0, b32_and, cc->type_u32, NULL);
			install(cc,  "or", EMIT_opc, 0, b32_ior, cc->type_u32, NULL);
			install(cc, "xor", EMIT_opc, 0, b32_xor, cc->type_u32, NULL);
			install(cc, "shl", EMIT_opc, 0, b32_shl, cc->type_u32, NULL);
			install(cc, "shr", EMIT_opc, 0, b32_shr, cc->type_u32, NULL);
			install(cc, "sar", EMIT_opc, 0, b32_sar, cc->type_u32, NULL);

			install(cc, "mul", EMIT_opc, 0, u32_mul, cc->type_u32, NULL);
			install(cc, "div", EMIT_opc, 0, u32_div, cc->type_u32, NULL);
			install(cc, "mod", EMIT_opc, 0, u32_mod, cc->type_u32, NULL);

			install(cc, "mad", EMIT_opc, 0, opc_umad, cc->type_u32, NULL);
			install(cc, "clt", EMIT_opc, 0, u32_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, u32_cgt, cc->type_bol, NULL);
			//~ install(cc, "to_i64", EMIT_opc, 0, u32_i64, cc->type_i64, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = i32) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "cmt", EMIT_opc, 0, b32_cmt, cc->type_i32, NULL);
			install(cc, "neg", EMIT_opc, 0, i32_neg, cc->type_i32, NULL);
			install(cc, "add", EMIT_opc, 0, i32_add, cc->type_i32, NULL);
			install(cc, "sub", EMIT_opc, 0, i32_sub, cc->type_i32, NULL);
			install(cc, "mul", EMIT_opc, 0, i32_mul, cc->type_i32, NULL);
			install(cc, "div", EMIT_opc, 0, i32_div, cc->type_i32, NULL);
			install(cc, "mod", EMIT_opc, 0, i32_mod, cc->type_i32, NULL);

			install(cc, "ceq", EMIT_opc, 0, i32_ceq, cc->type_bol, NULL);
			install(cc, "clt", EMIT_opc, 0, i32_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, i32_cgt, cc->type_bol, NULL);

			install(cc, "and", EMIT_opc, 0, b32_and, cc->type_i32, NULL);
			install(cc,  "or", EMIT_opc, 0, b32_ior, cc->type_i32, NULL);
			install(cc, "xor", EMIT_opc, 0, b32_xor, cc->type_i32, NULL);
			install(cc, "shl", EMIT_opc, 0, b32_shl, cc->type_i32, NULL);
			install(cc, "shr", EMIT_opc, 0, b32_sar, cc->type_i32, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = i64) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, i64_neg, cc->type_i64, NULL);
			install(cc, "add", EMIT_opc, 0, i64_add, cc->type_i64, NULL);
			install(cc, "sub", EMIT_opc, 0, i64_sub, cc->type_i64, NULL);
			install(cc, "mul", EMIT_opc, 0, i64_mul, cc->type_i64, NULL);
			install(cc, "div", EMIT_opc, 0, i64_div, cc->type_i64, NULL);
			install(cc, "mod", EMIT_opc, 0, i64_mod, cc->type_i64, NULL);
			install(cc, "ceq", EMIT_opc, 0, i64_ceq, cc->type_bol, NULL);
			install(cc, "clt", EMIT_opc, 0, i64_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, i64_cgt, cc->type_bol, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = f32) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, f32_neg, cc->type_f32, NULL);
			install(cc, "add", EMIT_opc, 0, f32_add, cc->type_f32, NULL);
			install(cc, "sub", EMIT_opc, 0, f32_sub, cc->type_f32, NULL);
			install(cc, "mul", EMIT_opc, 0, f32_mul, cc->type_f32, NULL);
			install(cc, "div", EMIT_opc, 0, f32_div, cc->type_f32, NULL);
			install(cc, "mod", EMIT_opc, 0, f32_mod, cc->type_f32, NULL);
			install(cc, "ceq", EMIT_opc, 0, f32_ceq, cc->type_bol, NULL);
			install(cc, "clt", EMIT_opc, 0, f32_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, f32_cgt, cc->type_bol, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = f64) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, f64_neg, cc->type_f64, NULL);
			install(cc, "add", EMIT_opc, 0, f64_add, cc->type_f64, NULL);
			install(cc, "sub", EMIT_opc, 0, f64_sub, cc->type_f64, NULL);
			install(cc, "mul", EMIT_opc, 0, f64_mul, cc->type_f64, NULL);
			install(cc, "div", EMIT_opc, 0, f64_div, cc->type_f64, NULL);
			install(cc, "mod", EMIT_opc, 0, f64_mod, cc->type_f64, NULL);
			install(cc, "ceq", EMIT_opc, 0, f64_ceq, cc->type_bol, NULL);
			install(cc, "clt", EMIT_opc, 0, f64_clt, cc->type_bol, NULL);
			install(cc, "cgt", EMIT_opc, 0, f64_cgt, cc->type_bol, NULL);
			ccEnd(rt, typ);
		}

		if ((typ = v4f) != NULL) {
			type_v4f = typ;
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, v4f_neg, type_v4f, NULL);
			install(cc, "add", EMIT_opc, 0, v4f_add, type_v4f, NULL);
			install(cc, "sub", EMIT_opc, 0, v4f_sub, type_v4f, NULL);
			install(cc, "mul", EMIT_opc, 0, v4f_mul, type_v4f, NULL);
			install(cc, "div", EMIT_opc, 0, v4f_div, type_v4f, NULL);
			install(cc, "equ", EMIT_opc, 0, v4f_ceq, cc->type_bol, NULL);
			install(cc, "min", EMIT_opc, 0, v4f_min, type_v4f, NULL);
			install(cc, "max", EMIT_opc, 0, v4f_max, type_v4f, NULL);
			install(cc, "dp3", EMIT_opc, 0, v4f_dp3, cc->type_f32, NULL);
			install(cc, "dp4", EMIT_opc, 0, v4f_dp4, cc->type_f32, NULL);
			install(cc, "dph", EMIT_opc, 0, v4f_dph, cc->type_f32, NULL);
			ccEnd(rt, typ);
		}
		if ((typ = v2d) != NULL) {
			ccBegin(rt, NULL);
			install(cc, "neg", EMIT_opc, 0, v2d_neg, typ, NULL);
			install(cc, "add", EMIT_opc, 0, v2d_add, typ, NULL);
			install(cc, "sub", EMIT_opc, 0, v2d_sub, typ, NULL);
			install(cc, "mul", EMIT_opc, 0, v2d_mul, typ, NULL);
			install(cc, "div", EMIT_opc, 0, v2d_div, typ, NULL);
			install(cc, "equ", EMIT_opc, 0, v2d_ceq, cc->type_bol, NULL);
			install(cc, "min", EMIT_opc, 0, v2d_min, typ, NULL);
			install(cc, "max", EMIT_opc, 0, v2d_max, typ, NULL);
			ccEnd(rt, typ);
		}

		if ((mode & creg_swiz) == creg_swiz) {
			int i;
			struct {
				char* name;
				astn node;
			} swz[256];
			for (i = 0; i < 256; i += 1) {
				dieif(rt->_end - rt->_beg < 5, "memory overrun");
				rt->_beg[0] = "xyzw"[i>>0&3];
				rt->_beg[1] = "xyzw"[i>>2&3];
				rt->_beg[2] = "xyzw"[i>>4&3];
				rt->_beg[3] = "xyzw"[i>>6&3];
				rt->_beg[4] = 0;

				swz[i].name = mapstr(cc, (char*)rt->_beg, -1, -1);
				swz[i].node = intnode(cc, i);
			}
			if ((typ = install(cc, "swz", TYPE_rec, 0, 0, NULL, NULL))) {
				ccBegin(rt, NULL);
				for (i = 0; i < 256; i += 1) {
					install(cc, swz[i].name, EMIT_opc, 0, p4x_swz, type_v4f, swz[i].node);
				}
				ccEnd(rt, typ);
			}
			/*if ((typ = install(cc, "dup", TYPE_rec, 0, 0))) {
				//~ extended set(masked) and dup(swizzle): p4d.dup.xyxy / p4d.set.xyz0
				enter(cc, NULL);
				for (i = 0; i < 256; i += 1)
					install(cc, swz[i].name, EMIT_opc, p4x_dup, type_v4f, swz[i].node);
				typ->args = leave(cc, typ, 1);
			}// */
			/*if ((typ = install(cc, "set", TYPE_rec, 0, 0))) {
				enter(cc, NULL);

				// 0: set 0.0
				// 1: set 1.0
				// 2: set src
				// 3: set dst

				install(cc,    "x", EMIT_opc, p4x_set, type_v4f, intnode(cc, 0));
				install(cc,    "y", EMIT_opc, p4x_set, type_v4f, intnode(cc, 0));
				install(cc,    "z", EMIT_opc, p4x_set, type_v4f, intnode(cc, 0));
				install(cc,    "w", EMIT_opc, p4x_set, type_v4f, intnode(cc, 0));
				install(cc,  "xyz", EMIT_opc, p4x_set, type_v4f, intnode(cc, 0));
				install(cc, "xyzw", EMIT_opc, p4x_set, type_v4f, intnode(cc, 0));
				install(cc, "xyz0", EMIT_opc, p4x_set, type_v4f, intnode(cc, 0));
				install(cc, "xyz1", EMIT_opc, p4x_set, type_v4f, intnode(cc, 0));
				install(cc, "xyz_", EMIT_opc, p4x_set, type_v4f, intnode(cc, 0));
				typ->args = leave(cc, typ, 1);
			}// */
		}
		//~ cc->emit_opc->args = leave(cc, cc->emit_opc, 1);
		ccEnd(rt, cc->emit_opc);
	}
}

state rtInit(void* mem, unsigned size) {
	state rt = mem;

	/*TODO: if (mem == NULL) {
		rt = malloc(size);
	}*/

	dieif(rt == NULL, "internal error");
	memset(mem, 0, sizeof(struct stateRec));

	*(void**)&rt->api.ccBegin = ccBegin;
	*(void**)&rt->api.ccDefInt = ccDefInt;
	*(void**)&rt->api.ccDefFlt = ccDefFlt;
	*(void**)&rt->api.ccDefStr = ccDefStr;
	*(void**)&rt->api.ccAddType = ccAddType;
	*(void**)&rt->api.ccAddCall = ccAddCall;
	*(void**)&rt->api.ccAddCode = ccAddCode;
	*(void**)&rt->api.ccEnd = ccEnd;
	//~ rt->api.ccSymFind = ccSymFind;
	*(void**)&rt->api.mapsym = mapsym;
	*(void**)&rt->api.invoke = vmCall;
	*(void**)&rt->api.rtAlloc = rtAlloc;

	rt->_size = size - sizeof(struct stateRec);
	rt->_end = rt->_mem + rt->_size;
	rt->_beg = rt->_mem;

	logFILE(rt, stdout);//stderr);
	rt->cc = NULL;
	return rt;
}
ccState ccInit(state rt, int mode, int onHalt(state, void*)) {
	ccState cc = (void*)(rt->_end - sizeof(struct ccStateRec));

	dieif(rt->_beg != rt->_mem, "Compiler initialization failed.");
	dieif(rt->_end != rt->_mem + rt->_size, "Compiler initialization failed.");

	rt->_end -= sizeof(struct ccStateRec);
	dieif(rt->_end < rt->_beg, "memory overrun");
	memset(rt->_end, 0, sizeof(struct ccStateRec));

	cc->s = rt;
	rt->cc = cc;

	rt->defs = NULL;
	rt->gdef = NULL;
	cc->defs = NULL;

	cc->_chr = -1;

	cc->fin._ptr = 0;
	cc->fin._cnt = 0;
	cc->fin._fin = -1;

	install_type(cc, mode);

	install_emit(cc, mode);

	// install a void arg for functions with no arguments
	if (cc->type_vid && (cc->void_tag = newnode(cc, TYPE_ref))) {
		enter(cc, NULL);
		cc->void_tag->ref.name = "";
		cc->void_tag->next = NULL;
		declare(cc, TYPE_ref, cc->void_tag, cc->type_vid);
		leave(cc, NULL, 0);
	}

	if (cc->emit_opc && (cc->emit_tag = newnode(cc, TYPE_ref))) {
		cc->emit_tag->ref.link = cc->emit_opc;
		cc->emit_tag->ref.name = "emit";
		cc->emit_tag->ref.hash = -1;
	}

	install_base(rt, mode, onHalt);

	return cc;
}
ccState ccOpen(state rt, char* file, int line, char* text) {
	if (rt->cc || ccInit(rt, creg_def, NULL)) {
		if (source(rt->cc, text == NULL, text ? text : file) != 0)
			return NULL;

		if (file != NULL) {
			rt->cc->file = mapstr(rt->cc, file, -1, -1);
		}
		else {
			rt->cc->file = NULL;
		}

		rt->cc->line = line;
	}
	return rt->cc;
}
int ccDone(state rt) {
	astn ast;
	ccState cc = rt->cc;

	// not initialized
	if (cc == NULL)
		return -1;

	// check no token left to read
	if ((ast = peek(cc))) {
		error(rt, ast->file, ast->line, "unexpected: `%k`", ast);
		return -1;
	}

	// close input
	source(cc, 0, NULL);

	// return errors
	return rt->errc;
}

/** allocate memory in the runtime state.
 * if (size != 0 && ptr != NULL): realloc
 * if (size != 0 && ptr == NULL): alloc
 * if (size == 0 && ptr != NULL): free
 * if (size == 0 && ptr == NULL): nothing
 * return NULL if cannot allocate, or size == 0
**/
void* rtAlloc(state rt, void* ptr, unsigned size) {
	/* memory manager
	 * using one double linked list with used and unused memory chunks.
	 * The idea is when allocating a block of memory we always must to traverse the list of chunks.
	 * when freeing a block not. Because of this if a block is used prev points to the previos block.
	 * a block is free when prev is null.
	 .
	 :
	>+--------------------------------+
	 | next                           |
	 +--------------------------------+
	 | prev                           |
	 +--------------------------------+
	 | 0                              |
	 .                                .
	 : ...                            :
	 | next - this bytes              |
	>+--------------------------------+
	 | next                           |
	 +--------------------------------+
	 | prev                           |
	 +--------------------------------+
	 | 0                              |
	 : ...                            :
	 | next - this bytes              |
	 +--------------------------------+
	 :
	the lowest bit in size indicates
	*/

	typedef struct memchunk {
		struct memchunk* next;
		struct memchunk* prev;		// not null for used memory
		char data[0];
	} *memchunk;

	memchunk memd = (memchunk)((char*)ptr - sizeof(struct memchunk));
	size = padded(size, sizeof(struct memchunk));

	// memory manager was not initialized, initialize it first
	if (rt->vm._heap == NULL) {
		memchunk heap = (void*)padded((int)(rt->_mem + rt->vm.px + 16), 16);
		int heapsize = rt->_size - (heap->data - (char*)rt->_mem);
		memchunk last = (void*)((char*)heap + heapsize - sizeof(struct memchunk));
		last->prev = last->next = NULL;
		heap->prev = NULL;
		heap->next = last;
		rt->vm._heap = heap;
	}

	if (ptr) {	// realloc or free.
		int chunksize = memd->next ? ((char*)memd->next - (char*)memd) : 0;

		dieif((unsigned char*)ptr < rt->_mem, "memmgr: invalid reference");
		dieif((unsigned char*)ptr > rt->_mem + rt->_size, "memmgr: invalid reference");

		if (1) {
			// extra check if ptr is in used list.
			memchunk find = rt->vm._heap;
			memchunk prev = find;
			while (find && find != memd) {
				prev = find;
				find = find->next;
			}
			dieif(find != memd, "memmgr: pointer not in list.");
			dieif(memd->prev != prev, "memmgr: pointer not in used list.");
		}

		if (size == 0) {							// free
			memchunk prev = memd->prev;
			memchunk next = memd->next;

			if (next && next->prev == NULL) {	// next block is free
				next = next->next;
				memd->next = next;
				if (next && next->prev != NULL)
					next->prev = prev;
			}
			if (prev && prev->prev == NULL) {	// prev block is free
				memd = prev;
				prev->next = next;
				if (next->prev != NULL)
					next->prev = prev;
			}
			memd->prev = NULL;			// mark as unused.
			memd = NULL;
		}
		else if (size > chunksize) {				// grow
			//~ fatal("FixMe: %s", "realloc memory to grow");
			error(rt, __FILE__, __LINE__, "not implemented the case when realloc to grow.");
			memd = NULL;
		}
		else if (size > sizeof(struct memchunk)) {	// shrink
			memchunk next = memd->next;
			memchunk free = (memchunk)((char*)memd + size);
			if (((char*)next - (char*)free) > sizeof(struct memchunk)) {
				memd->next = free;
				free->next = next;
				free->prev = NULL;
				if (next->prev == NULL) {	// next block is free
					next = next->next;
					free->next = next;
					if (next && next->prev != NULL)
						next->prev = free;
				}
				else {
					next->prev = free;
				}
			}
		}
	}
	else {		// alloc.
		if (size > 0) {
			memchunk prev = memd = rt->vm._heap;
			while (memd) {
				memchunk next = memd->next;

				// check if block is free.
				if (memd->prev == NULL && next) {
					int chunksize = (char*)next - (char*)memd;
					chunksize -= sizeof(struct memchunk);

					if (size < chunksize) {
						int diff = chunksize - size;
						if (diff > 16) {
							memchunk free = (memchunk)((char*)memd + size);
							memd->next = free;
							free->prev = NULL;
							free->next = next;
						}
						memd->prev = prev;
						break;
					}
				}
				prev = memd;
				memd = next;
			}
		}
	}

	//~ debug("memmgr(%x, %d): (%x, %d)", vmOffset(rt, ptr), size, vmOffset(rt, memd ? memd->data : NULL), memd ? memd->size : -1);
	if (0) {
		memchunk mem = ptr ? (memchunk)((char*)ptr - sizeof(struct memchunk)) : NULL;
		perr(rt, 0, __FILE__, __LINE__, "heap info: memmgr(%06x, %d)", vmOffset(rt, mem), size);
		for (mem = rt->vm._heap; mem; mem = mem->next) {
			char *status = mem->prev ? "used" : "free";
			if (mem->next) {
				int size = (char*)mem->next - (char*)mem;
				perr(rt, 0, NULL, 0, "%s chunk@%06x[%06x:%06x] %d", status, vmOffset(rt, mem), vmOffset(rt, mem->prev), vmOffset(rt, mem->next), size);
			}
		}
	}
	return memd ? memd->data : NULL;
}

// arrBuffer
int initBuff(arrBuffer* buff, int initsize, int elemsize) {
	buff->cnt = 0;
	buff->ptr = 0;
	buff->esz = elemsize;
	buff->cap = initsize * elemsize;
	return setBuff(buff, initsize, NULL) != NULL;
}
void* setBuff(arrBuffer* buff, int idx, void* data) {
	int pos = idx * buff->esz;

	//~ void* ptr = getBuff(buff, idx);
	if (pos >= buff->cap) {
		//~ trace("resizing setBuff(%d / %d)\n", idx, buff->cnt);
		buff->cap <<= 1;
		if (pos > 2 * buff->cap) {
			buff->cap = pos << 1;
		}
		buff->ptr = realloc(buff->ptr, buff->cap);
	}

	if (buff->cnt >= idx) {
		buff->cnt = idx + 1;
	}

	if (buff->ptr && data) {
		memcpy(buff->ptr + pos, data, buff->esz);
	}

	return buff->ptr ? buff->ptr + pos : NULL;
}
void* insBuff(arrBuffer* buff, int idx, void* data) {
	int pos = idx * buff->esz;
	int newCap = buff->cnt * buff->esz;
	if (newCap < pos) {
		newCap = pos;
	}

	// resize buffer
	if (newCap >= buff->cap) {
		if (newCap > 2 * buff->cap) {
			buff->cap = newCap;
		}
		buff->cap *= 2;
		buff->ptr = realloc(buff->ptr, buff->cap);
	}

	//~ debug("insBuff(buff(cnt: %d), idx: %d, cap: %d, pos : %d)", buff->cnt, idx, newCap, pos);
	if (idx < buff->cnt) {
		//~ debug("insBuff.move(to: %d, from: %d, size: %d)", pos + buff->esz, pos, buff->esz * (buff->cnt - idx));
		memmove(buff->ptr + pos + buff->esz, buff->ptr + pos, buff->esz * (buff->cnt - idx));
		idx = buff->cnt;
	}

	if (buff->cnt >= idx) {
		buff->cnt = idx + 1;
	}

	if (buff->ptr && data) {
		memcpy(buff->ptr + pos, data, buff->esz);
	}

	return buff->ptr ? buff->ptr + pos : NULL;
}
void* getBuff(arrBuffer* buff, int idx) {
	int pos = idx * buff->esz;

	if (pos >= buff->cap)
		return NULL;

	return buff->ptr ? buff->ptr + pos : NULL;
}
void freeBuff(arrBuffer* buff) {
	free(buff->ptr);
	buff->ptr = 0;
	buff->cap = 0;
	buff->esz = 0;
}
