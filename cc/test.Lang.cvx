// tests

/*
//~ int a = 9;
//~ int b = 4;

//~ (a, b) = b, a;


//~ float x1 = 9;
//~ static float x2 = 9;
//~ define inc(float x) = float(x + 1);
//~ define sqr(float x) = float(x * x);
//~ float inc0 = inc(9.);	// inline: used only once
//~ float inc1 = inc(x1);	// inline: used only once
//~ float inc2 = inc(x2);	// inline: used only once
//~ float sqr0 = sqr(9.);	// cached: used more than once
//~ float sqr1 = sqr(x1);	// inline: local variable
//~ float sqr2 = sqr(x2);	// cached: static variable


Complex Ca = Complex(3., 4.);
Complex Cb = Complex(2., 5.);
Complex C1 = mul(Ca, Cb);
Complex C2 = mul(Ca, Complex(2., 5.));
Complex C3 = neg(Complex(2., 5.));

define Re(Complex &a) = (a.re);
define Im(Complex &a) = (a.im);
//~ Complex C4 = Complex(Im(Complex(2., 5.)), 0.);
//~ Complex C5 = Complex(3., Im(Complex(2., 5.)));
//~ double d1 = Im(Complex(2., 5.));
//~ double d2 = Re(Complex(2., 5.));
//~ */

/* test: function members

int32 f3(int a, int b) {
	/+static int32 f4(int a, int b) {
		return a < b ? a : b;
	}
	return f4(a, b);+/
	return a < b ? a : b;
}
/+
struct Struct {
	//~ int32 &r[1];
	int32 f1(int a, int b) = f3;
	//~ int32 f2(int a, int b) = null;
	int32 f3(int a, int b) {
		return a < b ? a : b;
	}
}

Struct instance;
//~ +/
//~ */

/* TODO: const ref assignment
struct m {
	static const int X = 9;
	const int a;
	int b;
	int c;// = 8;
}

m m1 = m(5, 9, 1);
int &ref_m1_a = m1.a;	// hacked: warn if const/nonconst ref assignment.
ref_m1_a = 666;

int x = m1.a;

// */

/* TODO: arrays of references string
string x = "almax a fa alatt";

string ss[3];// = {x,x,x};
ss[0] = x;//"alma1 a fa alatt";
ss[1] = "alma2 a fa alatt";
ss[2] = "alma3 a fa alatt";

string y;
y = ss[1];

//~ int iii[3] = 1, 2, 3;
//~ string sss[3] = x, "alma2 a fa alatt", "alma3 a fa alatt";
//~ string y = sss[0];
//~ sss[0][3] = 'A';

//~ println(y);
//~ print(ss[1]);
// */

/* TODO: array.isNullOrEmpty()
bool isNullOrEmpty(int a[]) {
	if (a == null)
		result = true;
	if (a.length == 0)
		result = true;
}

//~ int val_null[] = null;
int val_empty[0];
int val_nonempty[10] = {9};

//~ bool res_true1 = isNullOrEmpty(null);
//~ bool res_true2 = isNullOrEmpty(val_null);
bool res_true3 = isNullOrEmpty(val_empty);
bool res_false = isNullOrEmpty(val_nonempty);
//~ */

/* TEST: xrgb
struct xrgb: 1 {
	uint8 b;	//%0x%02x
	uint8 g;	//%0x%02x
	uint8 r;	//%0x%02x
	uint8 x;	//%0x%02x
}
struct xrgbi32: 0 {
	xrgb rgb;
	int32 val;
}

xrgb a = emit(xrgb, i32(0x801f008f));
xrgb b = emit(xrgb, i32(0x2f3f1f));

//~ int r = a.r + b.r;

xrgbi32 r;
/+ TODO: initializations
xrgbi32 r1 = {val : 0};
xrgbi32 r2 = {
	r: Math.min(a.r + b.r, 255),
	g: Math.min(a.g + b.g, 255),
	b: Math.min(a.b + b.b, 255),
	a: 0,
};
// +/

r.rgb.r = Math.min(a.r + b.r, 255);
r.rgb.g = Math.min(a.g + b.g, 255);
r.rgb.b = Math.min(a.b + b.b, 255);
// */

/* TODO: Trace with external call
void f(int &arg) {
	if (arg <= 0) {
		debug("stack trace :-)", 3, 256, variant.null);
		//~ trace("stack trace :-)");
		return;
	}
	int n2 = arg - 1;
	//~ f(n2);
	testFunction(emit(struct, ref(f)), pointer(n2));
}

int N = 4;
//~ f(&N);

void f2(int arg, string b) {
	f(&arg);
}
f2(N, "apple");

// */

//~ /+ test: debug and trace info
struct debugInfo {
	string func;
	double x;
	double expected;
	double got;
}

void f3(pointer maxRecursiveCalls) {
	const int &n = maxRecursiveCalls;
	if (n <= 0) {
		trace("stack trace :-)");
		return;
	}
	int n2 = n - 1;
	testFunction(f3, pointer(&n2));
}

//~ BUG: void testFunction2(void cb(double x, debugInfo info, int n), int n, debugInfo &info) {
void testFunction2(void cb(double x, debugInfo &info, int n), int n, debugInfo info) {
	cb(n * 3.14, &info, n);
}
void f4(double x, debugInfo &info, int maxRecursiveCalls) {
	if (maxRecursiveCalls <= 0) {
		trace("stack trace :)");
		return;
	}
	testFunction2(f4, maxRecursiveCalls - 1, info);
}

int n = 2;
testFunction(f3, pointer(&n));

debugInfo info = debugInfo("fail", 1, 2, 3);
testFunction2(f4, n, info);
//~ +/

/+ test: print the content of memory :)
char memory[] = emit(struct, ref(null), i32(65536));
for(int i = 1; i < memory.length; i += 1) {
	if (i % 80 == 0) {
		println();
	}
	print("%c", memory[i]);
}// +/
