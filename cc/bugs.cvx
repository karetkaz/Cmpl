//~ tests_which_does_not_work;

/+ TODOS:
//~ int alma(int h)[10];
//~ int stringMap[string];		stringMap[]

//~ void alma(int a) {static int A = a;}

//~ int x1[20] = 9;
//~ int x2[] = x1;	// size should be 8
//~ +/

/+ inlineing ...
define sqr1(float64 ^x) = x*x;
define sqr2(float64 x) = sqr1(x);
double x = 9;
double y1 = sqr1(x*x+x);		// 
double y2 = sqr2(x*x+x);		// should produce the same code as above
//~ +/

/+ BUG: convert char slice to string 
const char str1[] = "alma a fa alatt nyari piros alma";
const char str2[] = {'a', 'l', 'm', 'a', 0};
string str3 = "alma";
//~ TODO: BUG: string str4 = string(str1);

// makeing slices from strings (substring)
//~ char slice1[] = emit(struct, ref(str2), i32(2));
//~ char slice2[] = emit(struct, i32.add, ref(str2), i32(2), i32(2));
//~ +/

/+ DONE: static casting pointers
pointer x = emit(pointer, ref("erZKJVDlaknjsdvkSDNVlk"));
string str = emit(string, ref(x));
//~ println(emit(string, ref(x)));
//~ +/

/+ DONE: fixed size array for defines
void testArr(double x[]) {
	print("%d\n", int64(x.length));
	x[3] = 8;
}

define TestArr(double x[16]) = testArr(x);

double x[16] = {1};
//~ testArr(x);
//~ TestArr(x);
//~ +/

/+ DONE: return does not cast
double f(int32 v) {result = v;}
double g(int32 v) {return v;}
double h(int32 v) {return result = v;}

int v = 12756;
double v1 = v;
assert(v == f(v));
assert(f(v) == g(v));
assert(f(v) == h(v));

//~ +/

/+ BUG: struct containing references.
struct Refs {
	int &i;
	double &d;
	int f();
}

int a = 6;
double b = 6;
int f() { print("ok\n"); }

static Refs refs = Refs(&a, &b, f);

void refassign() {
	static int a = 62;
	static double b = 62;
	static int f2() { print("ok62\n"); }

	refs = Refs(&a, &b, f2);
}

//~ refassign();
refs.f();

//~ if (refs.f != null) { refs.f(); }

//~ +/

/+ BUG: function returning reference or string type.
//~ define sizeof(typename type) = int(type.size);
//~ define new(typename type) = memmgr(null, type.size);

struct ComplexByVal {double re; double im;}
struct &ComplexByRef {double re; double im;}

//~ void print(ComplexByRef val) { print("%F", val.re); print(", "); print("%F", val.im); print("\n"); }

/+ TODO: 
ComplexByRef ComplexByRef(double re, double im) {
	result = new(ComplexByRef);
	result.re = re;
	result.im = im;
	return result;
}// +/

ComplexByVal v1 = ComplexByVal(3,-2);
ComplexByRef v2 = new(ComplexByRef);
ComplexByRef v3 = emit(ComplexByRef, i32(-1));
//~ ComplexByRef v4 = ComplexByRef(2, -3);

//~ v2.re = v1.re;
//~ v3 = v2;
//~ v2 = null;


//~ TODO: return string.
//~ string alma() {result = "alma";}

// +/
