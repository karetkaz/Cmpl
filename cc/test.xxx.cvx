//~ module test_what_does_not_work;

//~ int alma(int h)[10];
//~ int stringMap[string];		stringMap[]

//~ void alma(int a) {
	//~ static int A = a;
//~ }

/+ inlineing ...
define sqr2(float64 ^x) = x*x;
define sqr1(float64 x) = sqr2(x);
define sqr(float64 x) = sqr1(x);
double x = 9;
double y = sqr(x*x+x);
//~ +/

//~ assert(0, "alma");

/+ static casting pointers
pointer x = emit(pointer, ref("erZKJVDlaknjsdvkSDNVlk"));
string str = emit(string, ref(x));
//~ println(emit(string, ref(x)));
//~ +/

/+ ???
define double2 float64; //%%4.50g
double2 x = 3.14 / 4 + .0001;
double2 s1 = sin(x);
double2 s2 = Math.Sin(x);
//~ int a = 16 << 10;

int A = 9;
pointer a = emit(pointer, ref(A));
pointer b = emit(pointer, int(A));
int &a2 = A;
//~ +/

/+ fixed size array for defines
void testArr(double x[]) {
	print("%d\n", int64(x.length));
	x[1] = 8;
}// */

//~ define TestArr(double x[16]) = testArr(x);

double x[16] = 3;
testArr(x);
//~ TestArr(x);
testFunc(x);
testFunc2(x);
//~ +/

	static int &T = null;
void refassign(int &t) {
	&T = t;
}

int a = 6;
refassign(a);

//~ define ComplexByRef(double re, double im) = emit(ComplexByRef, store.b64, dupp.x1_2, f64(re), store.b64, i32.add, i32(8), dupp.x1_2, f64(im), ref(memmgr(null, 16)));

/*
ComplexByRef ComplexByRef(double re, double im) {
	result = new(ComplexByRef);
	result.re = re;
	result.im = im;
	return result;
}// */

/* typenames
//~ define sizeof(typename type) = int(type.size);
int sizeof(typename type) {return type.size;}
define new(typename type) = memmgr(null, type.size);

//~ void print(ComplexByRef val) { print("%F", val.re); print(", "); print("%F", val.im); print("\n"); }
struct ComplexByVal {double re; double im;}
struct &ComplexByRef {double re; double im;}

ComplexByVal v1;// = ComplexByVal(0, 0);
ComplexByRef v2 = new(ComplexByRef);

typename t1 = ComplexByVal;
typename t2 = ComplexByRef;

int s1 = sizeof(ComplexByVal);
int s2 = sizeof(ComplexByRef);
// */

//~  int x = sizeof(int64);
