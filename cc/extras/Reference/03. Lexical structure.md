# Lexical structure

## Comments

- line comments: // ...
- block comments: /* ... */
- nested comments: /+ ... +/

## Identifiers

variable or type names.

identifier = (letter)+

## Keywords
	break, const, continue, else, emit, enum, for,
	if, inline, operator, parallel, return, static, struct

## Operators

### Operators precedence table

| Operator   | Title          | Example    | Description |
|-----|-----------------------|------------|-------------|
| 15: Primary ||| Associates left to right |
| ( ) | Function call           | sqrt(x)    | function call, type cast, emit |
| [ ] | Array subscript         | values[10] ||
|  .  | Member access           | child.name ||
| 14: Unary ||| Associates right to left |
|  &  | Address of              | &x         ||
|  +  | Unary plus              | +a         ||
|  -  | Unary minus             | -a         ||
|  ~  | Bitwise not             | ~077       ||
|  !  | Logical not             | !ready     ||
| 13: Multiplicative ||| Associates left to right |
|  *  | Multiplication          | i * j||
|  /  | Division                | i / j||
|  %  | Modulus                 | i % j||
| 12: Additive ||| Associates left to right |
|  +  | Addition                | value + i||
|  -  | Subtraction             | x - 10||
| 11: Bit shift ||| Associates left to right |
|  << | Left shift              | byte << 4||
|  >> | Right shift             | i >> 2||
| >>> | Right shift unsigned    |i >>> 2||
| 10: Relational ||| Associates left to right |
|  <  | Less than               | i < 10||
|  <= | Less than or equal to   | i <= j||
|  >  | Greater than            | i > 0||
|  >= | Greater than or eq to   | count >= 90||
| 9: Equality ||| Associates left to right |
|  == | Equal to               | result == 0 ||
|  != | Not equal to           | c != EOF ||
| === | Same as (is)           | str1 === str2 ||
| !== | Not same as (is not)   | str1 !== str2 ||
| 8: Bitwise AND ||| Associates left to right |
|  &  | Bitwise AND            | word & 077 ||
| 7: Bitwise XOR ||| Associates left to right |
|  ^  | Bitwise XOR            | word1 ^ word2 ||
| 6: Bitwise OR ||| Associates left to right |
| &#124; | Bitwise OR             | word &#124; bits ||
| 5: Logical AND ||| Associates left to right |
|  && | Logical AND            | j > 0 && j < 10 ||
| 4: Logical OR ||| Associates left to right |
|&#124;&#124;| Logical OR             | i > 80 &#124;&#124; ready ||
| 3: Conditional ||| Associates right to left |
|  ?: | Conditional operator   |a > b ? a : b ||
| 2: Assignment ||| Associates right to left |
| := /= %= += -= &= ^= &#124;= <<= >>= | Assignment operators | ||
| 1: Collection ||| Associates left to right |
|  ,  | Comma operator         | i = 10, j = 0||

## Integer and floating-point literals

- binary literals: '0'[bB][01]+
- octal literals: '0'[oO]?[0-7]+
- hexadecimal literals: '0'[xX][0-9a-fA-F]+
- decimal literals: [1-9][0-9]*
- floating point literals: ([1-9][0-9]*)? ('.'[0-9]*)? ([eE]([+-]?)[0-9]+)?

## Character and string literals

- character literals: \'[^\'\n]*
- string literals: \"[^\"\n]*

### Escape sequences
[TODO]
Escape sequences are used to define certain special characters within string literals.

The following escape sequences are available:

		\': single quote
		\": double quote
		\?: question mark
		\\: backslash
		\a: audible bell
		\b: backspace
		\f: form feed - new page
		\n: line feed - new line
		\r: carriage return
		\t: horizontal tab
		\v: vertical tab
		\nnn: arbitrary octal value, maximum of 3 characters.
		\xnn: arbitrary hexadecimal value, always 2 characters.
		\<new line>: wraps on next line.

- Octal escape sequences have a limit of three octal digits, but terminate at the first character that is not a valid octal digit if encountered sooner.
- Hexadecimal escape sequences parses always the next two characters.
- A universal character name in a narrow string literal may map to more than one char due to multibyte encoding.

### Multiline Strings

A string literal is multiline if it starts with a backslash followed by a newline.

# Expressions

Expressions are responsible for computing values.

## Constants

Compile time constant expressions:

- A compile time constant expression is an expression whose value can be determined at compile time
(during verification), before any part of the program has been executed. 

- Compile time constant expressions consist of the following sub-expressions:
	- Literals such as null, Number, Boolean and String literals
	- References to properties whose values are compile-time constants
	- Operators whose result can be computed at compile time

- Expressions in certain contexts are required to be compile time constant expressions.
	- the size of a static array: int a[20];
	- the condition of a static if statement: static if (true) {...}
	- ...

## Identifiers

Used to reference typenames, variables and functions.

## Unary expressions

	!: logical not. Results true or false ***
	~: ones complement. Valid for integer types.
	-: unary minus. Change the sign of a number.
	+: unary plus. ???

## Binary expressions

### Arithmetic expressions

Are used to return new values computed from the two operands.

		+, -, *, /, %,
		&, |, ^,
		<<, >>, >>>

### Relational expressions

Are used to return true or false based on the comparation of the left and right operand.

		==, !=, ===, !==,
		<, <=, >, >=

### Logical expressions [TODO]
		||, &&

### Assignment expressions

- Are used to calculate and store new values in the left operand, returning the right operand.
- The composed operators are expanded, this means that (a += 3 + b) is the same as a = a + (3 + b)

		:=, +=, -=, *=, /=, %=, &=, |=, ^=, ~=, <<=, >>=, >>>=

## Ternary expressions
		?: operator
		int a = (b == 9 ? c : d);
