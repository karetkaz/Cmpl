# Declarations

Every declaration (typename, function or variable) results in a variable declaration and definition.

## Aliasing \{#}

	syntax:
		('static' | 'const')* 'define' name ('(' args ')')? '=' expr;

	examples:
		// type aliasing
		define double = float64;

		// constant aliasing
		define PI = 3.14...;

		// expression aliasing with arguments
		define min(int a, int b) = a < b ? a : b;

- the right hand side can also use local variables if static is not used
- static should force the right side not to use local variables
- const should force the right side to be constant

## Enumerations \{E}

	syntax:
		'enum' NAME? (':' typename)? '{' (NAME initializer? ';')* '}';

- An enumeration declares a list of named constants all of a given type.
- It may also add a new type, the enumeration type, if the name is specified.
- The enumeration type is a reference type, and its instances may be assigned only 
with the values listed inside the enumeration.
- The type of the enumerated values can be specified. If not specified the type of elements of the enum will be int.

	example:

		struct vec3f {
			float x;
			float y;
			float z;
		}

		enum coord: vec3f {
			x = vec3f(1, 0, 0);
			y = vec3f(0, 1, 0);
			z = vec3f(0, 0, 1);
		}

		coord e1 = coord.X;             // ok: enum variable can be assigned with a value from the enumeration.
		coord e2 = e1;                  // ok: enum variable can be assigned with the same type of variable.
		e2 = coord.X;                   // ok.
		e2 = e1;                        // ok.

		vec3f v1 = coord.Y;             // ok: values from enum are of type vec3f, so it can be assigned.
		vec3f v2 = e1;                  // ok: enum variables can be assigned to variables of their base type.
		v2 = coord.X;                   // ok.
		v2 = e2;                        // ok.

		coord e3 = v1;                  // error: enum variable can be assigned only from a value from the enumeration.
		e3 = v1;                        // error.
		coord e0;                       // error: enum variable must be initialized.

### Enumeration initializer

When declaring an enumeration there will be declared the following initializers:

from string: [TODO] lookup by name:

		define coord(string name);

	example:
		coord a = coord("x");
		assert(a === coord.x);

### Enumeration implementation

- Variables of enum types are references to members of the enumeration.
- There are basically 2 different enumeration kinds: reference or value based.

	1. when the base type is value type, the members of the enumeration will be ordered in the memory,
		like in an array. In this case the lookup is easy and can be done in constant time.

	- when the base type is reference type, ex strings, the enumeration holds references to each member.
		lookup in this case must match each member in the enumeration, if references are unordered.

		iterating over an enum: [TODO]
			for (Coords coord: Coords) {
				...
			}

		indexing an enum: [TODO]
			assert(Coords[2] === Coords.y);

		assigning to an array of base type: [TODO]
			vec3f enumValues[] = Coords

## Structs and Unions \{S}

	syntax:
		('static')? 'struct' name? (':' (pack|base))? '{' decl+ '}'

	example:
		struct Complex {
			const double re;
			const double im;
		}

- structures may contain only instance or static variables.
- declaring a function in a struct results in a function reference, or a static function in case it is implemented.

example:
```
struct a {
	int f1(int a, int b);
	int f2(int a, int b) = null;
	int f3(int a, int b) {
		return a < b ? a : b;
	}
}
```

- fields f1 and f2 are function reference instance members.
- f3 is converted to a static function, triggering a warning that it should be declared static.

	- static structures:

		Static declared structures have all members static.
		These types of structs will have the size 0, and can not be instantiated.
			the best example of its usage is: static struct Math {...}

	- packed structures

		a struct can be packed with a small integer of a power of 2
			[0, 1, 2, 4, 8, 16, 32].

		When a struct is packed with 0 it means is a union.

	- extended structures

		[TODO] should be class ?

		[TODO] a struct can be extended from another struct.

		[TODO] if the basetype is not byref there should be an error.

		[TODO] when a static struct is derived it becomes static and ...

		if a struct is declared as extending another type then:
			the extended type must be a reference type.
			parameters of this type are passed by reference.
			assignment of variables of this type is by reference.

		example:
			struct ComplexClass: object {double re; double im;}

	- structure initializer

		when declaring a struct there will be declared the following initializers:

		with all members, in case packing is not zero, and there is at least one field.
			define Complex(double re, double im) = emit(Complex, double(re), double(im));

		from pointer: [TODO] static cast
			define Complex(pointer ptr) = emit(Complex&, ref(ptr));

		from variant: [TODO] dynamic cast
			define Complex(variant var) = emit(Complex&, variant.unbox(var, Complex));

## Variables and Functions \{&}

	syntax:
		#~ variable + array
		('static' | 'const')* type name ('['expr?']')? ('=' expr)? ';'

		#~ function
		('static' | 'const')* type name ('('args?')')? (('=' expr) | ('{' stmt* '}'))? ';'

there are 3 forms of function declaration:

		void normal(int &x) { x = x * x; }
		void reference(int &x) = normal;
		[TODO] void forward(int &x);

- Functions are assigned and passed to functions by reference.
- Probably there would be a better idea to pass them as delegates,
meaning that there should be pushed an extra parameter,
a pointer to the captured variable, or the (this) object in case of methods.

When invoking argument functions we have to add closure parameter.
	When generating functions we have to generate the delegate also.
	This means that before each function we have to generate
	an extra instruction: `set.b32 0`, this removes the closure pointer,
	by popping the return value and overwriting the closure pointer with this value.

- A variable is a named property which value may change at runtime. Using the const attribute the variable may be assigned only during initialization.

	Static variables [TODO]

constant variables and fields
	if a field or variable is marked with the const keyword it must be initialized.

### Initialization

Struct initialization
```
// call the initializer function
Complex x = Complex(1, 2);

// TODO: literal initialization
Complex x = {re: 1, im: 2};

// TODO: literal initialization with type
Model x = Sphere {x:0, y:0, z:0, radius: 20};
```

Array initialization
```
int a[100] = {1, 2, 3, 0};
// TODO:
string xmlEscape[255] = {
	*: null,
	'"': "&quot;",
	'\'': "&apos;";
	'<': "&lt;",
	'>': "&gt;",
	'&': "&amp;";
};
```

## Operators and Properties {Â±} [TODO]

- Operators are similar to the aliasing construct operators.
- While aliasing is implicit, operators are explicit.
- Operators are statically resolved at compile time.

### Type conversion operator

	syntax:
		'operator' type '(' type rhs ')' '=' expr ';'

	example.Complex:
		operator Complex(float64 re) = Complex(re, 0);
		Complex a = 9.;       // ok: operators are explicit.

	example.Degrees:
		struct Celsius {double degrees;}
		struct Fahrenheit {double degrees;}

		// Celsius(double) and Fahrenheit(double) initializers are generated by the compiler.

		// explicit type conversion using defines
		define Celsius(Fahrenheit fahrenheit) = Celsius((fahrenheit.degrees - 32) * (5. / 9.));
		define Fahrenheit(Celsius celsius) = Fahrenheit((celsius.degrees + 32) * (9. / 5.));

		// implicit type conversion using operators
		operator Celsius(Fahrenheit fahrenheit) = Celsius(fahrenheit);
		operator Fahrenheit(Celsius celsius) = Fahrenheit(celsius);

		Celsius boilC = Celsius(100.);
		Fahrenheit boilF_implicit = Fahrenheit(boilC);          // executes define
		Fahrenheit boilF_explicit = boilC;                      // executes operator

### Unary, binary operators

	syntax:
		#~ unary
		'operator' operator '(' type rhs ')' '=' expr ';'
		#~ binary
		'operator' '(' type lhs ')' operator '(' type rhs ')' '=' expr ';'

	example.Complex:
		operator - (Complex a) = Complex(-a.re, -a.im);
		Complex b = -a;

		operator (Complex a) + (Complex b) = Complex(a.re + b.re, a.im + b.im);
		Complex sum = a + b;

### Property operators

	syntax:
		#~ getter
		'operator' '(' type rhs ')' '.' name '=' expr ';'
		#~ method
		'operator' '(' type rhs ')' '.' name '(' args ')' ('=' expr ';') | ('{' stmt* '}')
		#? indexer
		'operator' '(' type rhs ')' '[' args ']' ('=' expr ';') | ('{' stmt* '}')
		#? invoker
		'operator' '(' type rhs ')' '(' args ')' ('=' expr ';') | ('{' stmt* '}')
		#? setters
		probably not a good idea, and not really use full, getter returning an rvalue is assignable.

	example.Complex:
		Complex a = 3.	                        # 3 + 0*i
		Complex b = Complex(5, 1);              # 5 + i

		operator (Complex a).Abs = Math.hypot(a.re, a.im);
		double x = a.Abs;

		operator (Complex a).Add(Complex b) = Complex(a.re + b.re, a.im + b.im);
		Complex sum = a.Add(b);

		operator (Complex c)[int idx] = float64(idx == 0 ? c.re : idx == 1 ? c.im : Math.Nan);
		operator (Complex c)[string idx] = float64(idx == "re" ? c.re : idx == "im" ? c.im : Math.Nan);

		operator (Complex c)(int idx) = c[i];

		float64 re = a[0];        // => operator (Complex c)[int idx]
		float64 im = a["im"];     // => operator (Complex c)[string idx]
		float64 re2 = a(0);       // => operator (Complex c)(int idx)

	example.Graphics:
		#~ getter
		operator (gxSurf src).width = width(src);
		operator (gxSurf src).height = height(src);
		operator (gxSurf src).depth = depth(src);

		#~ member
		operator (gxSurf src).getPixel(int x, int y) = getPixel(src, x, y);

		#~ indexer
		operator (gxSurf src)[int x, int y] = src.getPixel(x, y);

		#~ usage
		gxSurf src = gxSurf("1.jpg");
		int width = src.width;
		int height = src.height;

		int color1 = src.getPixel(10, 10);
		int color2 = src[10][10];

