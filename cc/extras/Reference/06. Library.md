# Library reference

<!--todo:
	Builtins
		emit
		debug
		memmgr
			alloc
			free
		memcpy
		memset
		tryExec
		...
	String
	Streams
	Collection
		* Array: Immutable
		- Vector: Array
		- Stack: Vector
		- Queue: Vector
		- Map: Immutable
		- TreeMap: Map
		- HashMap: Map
		- MultiMap(Map map): Map
		- Set: Immutable
		- TreeSet: Set
		- HashSet: Set
		- MultiSet(Set set): Set
		- List
	+ Comparator
	+ Iterator
	...
-->

## The `emit` builtin function.
- emit is a low level builtin function.
- its return type is defined by the first argument.
- emit can have as parameters values and opcodes.
- as the first argument of emit we can pass a type or the struct keyword.

example:
```
define add(Complex a, Complex b) = emit(Complex, v2d.add, Complex(b), Complex(a));
```

- the above example has the following meaning:
	- // parameters are evaluated from right to left
	- push a          ; put by value a on the stack.
	- push b          ; put by value b on the stack.
	- v2d.add         ; Packed Double-Precision Floating-Point Add (see: sse2 ADDPD instruction)
	- // the result is on the stack of type Complex.

- if the first argument is a type, static cast can be done.

example:
```
float32 a = 500;
int32 b = emit(int32, f32(a));
assert(b == 1140457472);
```

- if the first argument is the struct keyword in a declaration,
the resulting type will match the declared type, if the
size of the variable match the size generated by emit.

example 2:
```
// create a slice
char a[] = emit(struct, ref("string"), i32(3));
// then a = {'s', 't', 'r'};
```

## Exception handling
	There is no try catch to handle exceptions, but the debug function can abort the execution of the code.

### The `raise` builtin function.

`void raise(int level, string message, variant inspect, int trace);`

is used to abort, assert, debug, log, warn, ...

- the function logs the file name and line number where the function was invoked.
	- message: the message to be printed.
	- inspect: a variant (type + reference), serialize this object, useful in assertions, see{test.Math}
	- level: level to be printed on
		- 0: silent, does not print anything.
		- -1: print the error then stop the execution of the vm.
		- values greater than 0 may be skipped depending on log level.
	- trace: prints the last n stack trace, if running in debug mode.

execSafe
execAsync

### The `tryExec` builtin function.

`int tryExec(pointer args, void action(pointer args));`
[TODO: with support for closures] `int tryExec(void action());`

the function executes the given action, returning 0 if it was executed with success.

possible return values are defined by the enumeration:
```
enum {
	noError,
	invalidIP,
	invalidSP,
	stackOverflow,
	memReadError,
	memWriteError,
	divisionByZero,
	illegalInstruction,
	libCallAbort,
	executionAborted
}
```

## Constant evaluation [TODO vm way]
	Constant expression evaluation should be done by the vm.
		An expression is constant:
			if no memory writing is performed.
			memory read occurs only from the read only region.
			no non const function is invoked.
			no libcall is invoked? (what about sin(double x) and the others).
			no stack manipulation is performed?

## Compilation memory management

The memory is organized in 4 segments:

- meta: read only
	- identifiers and string constants (are emited in the compilation phase).
	- typename and variable metadata (are emited in the compilation phase).
	- [TODO] enumeration values.

- code: read only
	- functions body.

- data: uninitialized memory (initialized with exec)
	static variables

- heap: heap and stack(s).

In the compilation phase the lower part of the memory is filled with persistant data which remains 
available for code execution, while the upper part is filled with token structures and other temporary structs.
In the codegeneration phase enums and functions should be generated first continuig to fill the lower part of the memory.
In the execution phase variables from the data section are initialized (the generated code may be executed more than one time).


