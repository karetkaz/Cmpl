// TODO: small optimization

/+ Optimize stack deallocations
{
	int a[1<<10];
	{
		int a[2<<10];
		{
			int a[3<<10];
			{
				int a[4<<10];
				{
					int a[5<<10];
					{
						int a[6<<10];
						a[0] = 6;
					}
					a[0] = 5;
				}
				//~ a[0] = 4;
			}
			//~ a[0] = 3;
		}
		a[0] = 2;
	}
	//~ a[0] = 1;
}// +/

/+ Optimize stack allocation
{
	string a = "a";
	print(a);
}

// |init(ro: 34576, ss: 0, sm: 2, pc: 34576, px: 34591) {
// |todo.Optimize.cvx:30: string a = 'a'
// |	1f da 59 00 00             load.ref 59da
// |todo.Optimize.cvx:31: print(a);
// |	12 00                      dup.x1 sp(0)
// |	09 1b 00 00                libc(27): print(string val): void
// |	10 fc ff ff                spc -4
//! dup.x1 sp(0) and spc -4 can be removed
// |}
//~ +/

/+ Optimize returning void
void testRetVoid0() {
}

void testRetVoid1() {
	return;
}

void testRetVoid2() {
	return result;
}

void testRetVoid3() {
	return void(0);
}

void testRetVoid4() {
	return testRetVoid0();
}

void testRetVoid5() {
	return void((3.14/3));
}

long testRetLong0() {
	return 9;
}

// |void testRetVoid1(void) [@008d61: 2] {
// |	.local void testRetVoid1.result [@000000, size:0, cast:.err]
// |	.local void [@000000, size:0, cast:.def]
// |todo.Optimize.cvx:51: return
// |	03                         ret
// do not generate multiple returns.
// |	03                         ret
// |}
//~ +/

/+ add to System ...
enum Arch { // ARMv6, ARMv7, x64, x86
	arm
	?armf
	i386
	x86_64 | amd64
}

enum Platform: string {
	Windows = "Windows";
	Darwin = "Darwin";
	Linux = "Linux";
}

enum Config {
	Release
	Debug
}

Arch arch = Arch.?

boolean bigEndian = false;

//~ +/

/+ ? Templates see Collections and streams ?

struct Fixed(int FractBits): 0 {
	static if (FractBits < 0 || FractBits > 24) {
		error: invalid fraction bits;
	}

	int32 value;

	enum: int32 {

		fxpmask = (1 << FractBits) - 1;

		fxp_nan = 0x80000000;
		fxp_one = 1 << FractBits;

		fxp_d2r = 0x000477d1 >> (24 - FractBits);		// pi / 180 : degrees to radians
		fxp_r2d = 0x394bb834 >> (24 - FractBits);		// 180 / pi : radians to degrees

		fxp_ln2 = 0x00b17217 >> (24 - FractBits);		// .6931471805599453 : natural logarithm (2)
		fxp_lg2 = 0x004d104d >> (24 - FractBits);		// .3010299956639812 : decimal logarithm (2)
		fxp_l2e = 0x01715476 >> (24 - FractBits);		// 1.442695040888963 : logarithm base 2  (e)
		fxp_l2t = 0x035269e1 >> (24 - FractBits);		// 3.321928094887362 : logarithm base 2 (10)

		fxp_mpi = 0x3243f6a8 >> (28 - FractBits);
		fxp_2pi = 0x3243f6a8 >> (28 - FractBits - 1);
		fxp_pi2 = 0x3243f6a8 >> (28 - FractBits + 1);
	}

	static const inline asFixed(const int32 val) = emit(Fixed, i32(val));
	static const inline toFixed(const int32 val) = emit(Fixed, i32(val << FractBits));
	static const inline toFixed(const float64 val) = emit(Fixed, int32(val * (1 << FractBits)));

	static inline add(fixed ^lhs, fixed ^rhs) = asFixed(lhs.value + rhs.value);
	static inline sub(fixed ^lhs, fixed ^rhs) = asFixed(lhs.value - rhs.value);
	static inline mul(fixed ^lhs, fixed ^rhs) = asFixed(int64.Sar(int64(lhs.value) * rhs.value, FractBits));
	static inline mul(fixed ^lhs, int32 rhs) = asFixed(lhs.value * rhs);
	static inline mul(int32 lhs, fixed ^rhs) = asFixed(lhs * rhs.value);
	static inline div(fixed ^lhs, fixed ^rhs) = asFixed(int64.Shl(lhs.value, FractBits) / rhs.value);
	static inline div(fixed ^lhs, int32 rhs) = asFixed(lhs.value / rhs);
	static inline mod(fixed ^lhs, fixed ^rhs) = asFixed(lhs.value % rhs.value);
	static inline inv(fixed rhs) = div(asFixed(fxp_one), rhs);
	...
}
//~ +/

/+ initialization (type and variable)

//~ int a1 = int(0);
//~ int a2 = int{0};

//~ typename strty = string;
//~ typename complex = Complex;
//~ Complex c1 = Complex(10, 20);         // constructor
//~ Complex c2 = {re: 10, im:20};         // auto literal
//~ Complex c2 = Complex {re: 10, im:20}; // typed literal

struct Person {
	LastName: string,
	FirstName: string,
	BirthYear: int(1970);
	Jobs: string[] = null,
	next: Person& = null,
	Address: struct {
		Type: enum {Home, Work, Other}
		PostOfficeBox: String;
		StreetAddress: String;
		ZipCode: String;
		City: String;
		State: String;
		Country: String;
	};
	Address2: struct& {
		Type: enum {Home, Work, Other}
		PostOfficeBox: String;
		StreetAddress: String;
		ZipCode: String;
		City: String;
		State: String;
		Country: String;
	} = null;
	Phone: struct[] {
		Type: enum {Mobile, Home, Work, Fax, Other} = Other;
		Value: String;
	} = null,
	Mail: struct[] {
		Type: enum {Home, Work, Other} = Other;
		value: String = "";
	} = null,
	Dates: struct[] {
		type: enum {Other, BirthDay, Aniversary}
		value: String;
	} = [],
	Gender: enum {Male, Female, NotDefined} = NotDefined;
};

Person person = {
	LastName: "Last";
	FirstName: "First";
	Address: {
		Type: Home;
		Value: "12345678";
	};
	Phone: [{
		Type: Mobile;
		Value: "12345678";
	}, {
		Type: Home;
		Value: "23456789";
	}];
	Gender: Male;
};
//~ +/

/+ initialization (type and variable): Ui
struct Rect {
	int top = 0;
	int right = 0;
	int bottom = 0;
	int left = 0;
}
struct Anchor {
	enum Style {
		Fill;
		FillTop;
		FillRight;
		FillBottom;
		FillLeft;

		Center;
		CenterTop;
		CenterRight;
		CenterBottom;
		CenterLeft;
	};

	int &top = null;
	int &bottom = null;
	bool centerHorizontal = false;	// center / fill

	int &left = null;
	int &right = null;
	bool centerVertical = false;	// center / fill

	static Anchor dock(Style dock, Rect r, int **pin) {
		result.top = r.top;
		result.bottom = r.bottom;
		result.centerHorizontal = true;

		result.left = r.left;
		result.right = r.right;
		result.centerVertical = true;

		switch (dock) {

			case Fill:
				result.centerHorizontal = false;
				result.centerVertical = false;
			case Center:
				break;

			case FillTop:
				result.centerHorizontal = false;
			case CenterTop:
				result.bottom = pin;
				break;

			case FillRight:
				result.centerVertical = false;
			case CenterRight:
				result.left = pin;
				break;

			case FillBottom:
				result.centerHorizontal = false;
			case CenterBottom:
				result.top = pin;
				break;

			case FillLeft:
				result.centerVertical = false;
			case CenterLeft:
				result.right = pin;
				break;
		}
	}
}
struct Font {...}

// garbage collecteted
struct View: object {
	struct Style {
		Ancor anchor = {};
		Rect margin;
		Rect padding {	// default padding is 4
			top: 4;
			right: 4;
			bottom: 4;
			left: 4;
		};
		rgb color = rgb(127);	// grey
		int radius = 0;
		//~ ? border;
		int width = 25;
		int height = 25;
	}

	Style style;
	Rect position;	// calc by the layout

	define width = style.width;
	define height = style.height;

	bool enabled;
	bool focusable;
	View children[];
}

//~ struct List: View {...}
//~ struct Grid: View {...}
struct Text: View {...}
struct Label: View {...}
struct Image: View {...}
struct Check: View {...}
struct Input: View {...}	// single line, multi line, html
struct Select: View {...}	// ComboBox
struct Slider: View {...}

//~ struct Page: View {...}
struct Window: View {...}
struct Button: View {
	bool checked = false;
	bool checkable = false;
	//~ property alias pressed: mouseArea.pressed
	//~ property alias text: label.text
	//~ property alias platformMouseAnchors: mouseArea.anchors

	View.Style style {
		width: 100;
		height: 25;
		radius: 8;
	};
	Group &group = null;

	Image image {
		anchor: dock(CenterLeft, parent);
		source: button.iconSource
		define visible = bool(source != "")
	}
	Label label {
		anchor: Anchor.dock(Anchor.Style.CenterRight, ?parent, image.right);

		elide: Text.ElideRight

		font {
			family: button.platformStyle.fontFamily;
			weight: button.platformStyle.fontWeight;
			pixelSize: button.platformStyle.fontPixelSize;
			capitalization: button.platformStyle.fontCapitalization;
		}
		colors {
			disabled: Style.disabledTextColor;
			enabled: Style.textColor;
			focused: Style.textColor;
			pressed: pressedTextColor;
			checked: checkedTextColor;
		}
		text: ""
		define visible = bool(text != "")
	}

	children: const[image, label];
}

Window window {
	width: 100;
	height: 100;
	children [
		Button {
			label: "button1";
			onClick()
		};
	];
};

window.show();

// +/

/+ initialization (type and variable): Email
struct Email {
	struct Part: object {}
	struct TextPart: Part {}
	struct FilePart: Part {}
	struct MultiPart: Part {}

	string to[];
	string cc[];
	string bcc[];
	string from;
	string subject;
	Part body;
}
Email email = {
	to: {"testTo1", "testTo2", "testTo3"};
	from: "testFrom";
	subject: "html/plain alternative";
	body: MultiPart {
		headers{ "Content-Type": "multipart/alternative" };
		parts{
			TextPart{
				// put plain text first as backup
				// headers: {"Content-Type": "text/plain"};
				text: "this is bold and italics!";
			};
			TextPart{
				// put html part last as best alternative
				headers { "Content-Type": "text/html" };
				text: "this is <b>bold</b> and <i>italics</i>!";
			};
		]
	}
}
//~ +/

/*
struct Alarm {
	// Alarm starts on
	Date start;

	// Alarm ends on
	Date end;

	// duration in seconds
	int duration;

	// 
	int repeat;
	enum: int {
		repeatDaily     = 0x10000;
		repeatWeekly    = 0x10000;
		repeatMonthly   = 0x10000;

		repeatDaylyMon  = 0x00001;
		repeatDaylyTue  = 0x00002;
		repeatDaylyWed  = 0x00004;
		repeatDaylyThu  = 0x00008;
		repeatDaylyFri  = 0x00010;
		repeatDaylySat  = 0x00020;
		repeatDaylySun  = 0x00040;
	}
}
*/
