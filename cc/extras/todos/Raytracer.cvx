// simple raytracer
struct Camera {
	vec4f right;
	vec4f up;
	vec4f forward;
	vec4f position;

	static Camera lookAt({vec4f position; vec4f target; vec4f up}) {
		result.forward = normalize(sub(target, position));
		result.right = normalize(crs(up, result.forward));
		result.up = crs(result.forward, result.right);
		result.position = position;
	}
}

struct Light {
	const vec4f position;
	const vec4f color;
	const float intensity = 10;
}

struct Ray {
	const vec4f position;
	const vec4f direction;
}


struct Shape: object {
	// abstract method must be overriden
	const bool intersect(const Shape this, const Ray &ray, float &outDistance);

	// enable intersect member shadowing
	//~ operator (Shape this).intersect(const Ray &ray, float &outDistance) = this.intersect(this, &ray, &outDistance);
}

struct Plane: Shape {
	const vec4f normal;
	const float offset;

	// override intersection method
	intersect: bool(const Plane this, const Ray &ray, float &outDistance) {
		float denom = dp3(ray.direction, this.normal);
		if (denom == 0) {
			return false;
		}
		outDistance = -(Vector.Dot(this.normal, ray.position) + this.offset) / denom;
		//~ vec4f outPosition = add(ray.position, mul(ray.direction, outDistance));
		//~ vec4f outNormal = this.normal;
		return true;
	}
}

struct Sphere: Shape {
	const vec4f position;
	const float radius;

	// override intersection method
	intersect: bool(const Sphere this, const Ray &ray, float &outDistance) {
		var dst = sub(ray.position, this.position);
		var B = dp3(dst, ray.direction);
		var C = dp3(dst, dst) - (this.radius * this.radius);
		var D = B * B - C;

		if (D <= 0) {
			return false;
		}
		outDistance = -B - Math.sqrt(D);
		//~ vec4f outPosition = add(ray.position, mul(ray.direction, outDistance));
		//~ vec4f outNormal = normalize(sub(outPosition, this.position));
		return true;
	}
}

struct Scene {
	Camera camera;
	Light lights[];
	Shape things[];

	Shape intersect(const Scene &this, const Ray &ray) {
		result = null;
		float closest = Math.inf;
		for (Shape shape: this.things) {
			float distance;
			if (shape.intersect(ray, &distance)) {
				if (closest > distance) {
					closest = distance;
					result = shape;
				}
			}
		}
		return result;
	}
}

Scene scene = {
	camera: Camera.lookAt({
		position: vec4f(0, 0, -15);
		target: vec4f(-0.2, 0, 5);
		up: vec4f(0, 1, 0);
	});
	lights: [{
		position: vec4f(5, 10, -1);
		color: vec4f(0.8, 0.8, 0.8);
	}, {
		position: vec4f(-3, 5, -15);
		color: vec4f(0.8, 0.8, 0.8);
		intensity: 100;
	}];
	things: [
		Sphere {
			position: vec4f(-1.5, 1.5, 2),
			radius: 1.5,
		};
		Sphere {
			position: vec4f(1, 0.25, 1),
			radius: .5,
		};
		Plane {
			normal: normalize(vec4f(0.1, 0.9, -0.5)),
			offset: 1.2,
		};
	];
};
