// TODO:
struct string: object {

	struct Builder: object {
		define defSize = 256;
		string cache = null;
		char data[];
		int size;

		bool ensureCap(int length) {
			result = false;
			if (data.length < size) {
				char newdata[] = new(char, 2 * int.bsf(size));
				for (int i = 0; i < data.length; i += 1) {
					newdata[i] = data[i];
				}
				data = newdata;
				result = true;
			}
			return result;
		}

		Builder Append(bool value) {
			if (value) {
				if (ensureCap(size + 4)) {
					data[size++] = 't';
					data[size++] = 'r';
					data[size++] = 'u';
					data[size++] = 'e';
					cache = null;
				}
			}
			else {
				if (ensureCap(size + 5)) {
					data[size++] = 'f';
					data[size++] = 'a';
					data[size++] = 'l';
					data[size++] = 's';
					data[size++] = 'e';
					cache = null;
				}
			}
			return this;
		}
		Builder Append(char value) {
			if (ensureCap(size + 1)) {
				data[size++] = value;
				cache = null;
			}
			return this;
		}
		Builder Append(string value) {
			if (value.length > 0 && ensureCap(size + value.length)) {
				for (int i = 0 ; i < value.length; i += 1) {
					data[size++] = value[i];
				}
				cache = null;
			}
			return this;
		}

		Builder Append(int64 value, int radix, int paddChar, int paddSize, bool forceSign) {
			struct Options {
				const char signChar;

				const char paddChar;
				const int paddSize;

				const int radix;
			}

			void Append(Builder dst, int64 value, int pos, Options &opt) {
				if (value != 0) {
					Append(value / opt.radix, pos + 1, opt);
					dst.Append("0123456789"[value % opt.radix]);
				}
				else {
					int padd = opt.paddSize - pos;

					if (opt.signChar) {
						padd -= 1;
					}

					for (int i = 0; i < padd; i += 1) {
						dst.Append(opt.padChar);
					}

					if (opt.signChar) {
						dst.Append(opt.signChar);
					}
				}
			}

			int signChar = value < 0 ? '-' : forceSign ? '+' : 0;
			Options opt = Options(signChar, paddChar, paddSize, radix);

			cache = null;
			Append(this, value, 0, &opt);
		}

		Builder Append(int64 value, int radix) {
			Append(value, radix, 0, 0, false);
		}
		Builder Append(int64 value) {
			Append(value, 10);
		}

		Builder Append(int32 value, int radix) {
			Append(int64(value), radix);
		}
		Builder Append(int32 value) {
			Append(int64(value));
		}

		string ToString() {
			if (cache == null) {
				cache = new(char, size);
				for (int i = 0; i < size; i += 1) {
					cache[i] = data[i];
				}
			}
			return cache;
		}
	}

	// enumerate comparator functions
	enum Comparator: int(string a, string b) {
		caseSensitive = int(string a, string b) {
			int maxLength = Math.min(a.length, b.length);
			for (int i = 0; i < maxLength; i += 1) {
				result = a[i] - b[i];
				if (result != 0) {
					return result;
				}
			}
			return 0;
		}
		caseIgnore = int(string a, string b) {
			int maxLength = Math.min(a.length, b.length);
			for (int i = 0; i < maxLength; i += 1) {
				result = toLowerCase(a[i]) - toLowerCase(b[i]);
				if (result != 0) {
					return result;
				}
			}
			return 0;
		}
	}

	// private members
	struct {
		/// reference to the parent string.
		string subStringOf;

		/// slice of characters.
		const char value[];
	}

	// private operations
	static struct {
		int Compare(string strA, int ofsA, string strB, int ofsB, CompareOptions options, int count) {...}
		define Compare(string a, string b, CompareOptions options) = Compare(a, 0, b, 0, options, a.length);
		define Compare(string a, string b, bool ignoreCase) = Compare(a, b, ignoreCase ? CompareOptions.IgnoreCase : CompareOptions.None);
		define Compare(string a, string b) = Compare(a, b, CompareType.None);

		int IndexOf(string str, string val, CompareOptions options) {...}
		int IndexOf(string str, char val, CompareOptions options) {...
			result = -1;
			if (options == CompareOptions.None) {
				for (int i = 0; str[i]; i += 1) {
					if (str[i] == val) {
						result = i;
						break;
					}
				}
			}
			return result;
		}
		define IndexOf(string str, string val, bool ignoreCase) = IndexOf(str, val, ignoreCase ? CompareOptions.IgnoreCase : CompareOptions.None);
		define IndexOf(string str, string val) = IndexOf(str, val, CompareOptions.None);
		define IndexOf(string str, char val, bool ignoreCase) = IndexOf(str, val, ignoreCase ? CompareOptions.IgnoreCase : CompareOptions.None);
		define IndexOf(string str, char val) = IndexOf(str, val, CompareOptions.None);

		int LastIndexOf(string str, string val, CompareOptions options) {...}
		int LastIndexOf(string str, char val, CompareOptions options) {...
			result = -1;
			if (options == CompareOptions.None) {
				for (int i = 0; str[i]; i += 1) {
					if (str[i] == chr) {
						result = i;
					}
				}
			}
			return result;
		}
		define LastIndexOf(string str, string val, bool ignoreCase) = LastIndexOf(str, val, ignoreCase ? CompareOptions.IgnoreCase : CompareOptions.None);
		define LastIndexOf(string str, string val) = LastIndexOf(str, val, CompareOptions.None);
		define LastIndexOf(string str, char val, bool ignoreCase) = LastIndexOf(str, val, ignoreCase ? CompareOptions.IgnoreCase : CompareOptions.None);
		define LastIndexOf(string str, char val) = LastIndexOf(str, val, CompareOptions.None);

		bool StartsWith(string str, string val, CompareOptions options) {
			if (str.length > val.length) {
				return Compare(str, 0, val, 0, options, val.length) == 0;
			}
			return false;
		}
		define StartsWith(string str, string val, bool ignoreCase) = StartsWith(str, val, ignoreCase ? CompareOptions.IgnoreCase : CompareOptions.None);
		define StartsWith(string str, string val) = StartsWith(str, val, CompareOptions.None);

		bool EndsWith(string str, string val, CompareOptions options) {
			if (str.length > val.length) {
				return Compare(str, str.length - val.length, val, 0, options, val.length) == 0;
			}
			return false;
		}
		define EndsWith(string str, string val, bool ignoreCase) = EndsWith(str, val, ignoreCase ? CompareOptions.IgnoreCase : CompareOptions.None);
		define EndsWith(string str, string val) = EndsWith(str, val, CompareOptions.None);

		string ToLowerCase(string str) {
			result = new(char, str.length);
			for (int i = 0; i < str.length; i += 1) {
				result[i] = str[i];
			}
		}
	}

	/// format string
	static string Format(string format, var args...) {
		Builder resBuilder = Builder(Builder.defSize);
		int j = 0;
		for (int i = 0; i < format.length; i += 1) {
			chr = format[i];
			if (chr == '%') {
				int beg = i;

				char sgn = 0;
				chr = format[i += 1];
				if (chr == '-' || chr == '+') {
					sgn = chr;
					chr = format[i += 1];
				}

				char pad = 0;
				if (chr == '0' || chr == ' ') {
					pad = chr;
					chr = format[i += 1];
				}

				int len = 0;
				for (; chr >= '0' && chr <= '9'; ) {
					len = (len * 10) + (chr - '0');
					chr = format[i += 1];
				}

				int prc = 0;
				if (chr == '.') {
					chr = format[i += 1];
					for (; chr >= '0' && chr <= '9'; ) {
						prc = (prc * 10) + (chr - '0');
						chr = format[i += 1];
					}
				}

				switch (chr) {
					case 'c':
						resBuilder.append(char(args[j += 1]), sgn, pad, len, prc);
						break;
					case 's':
						resBuilder.append(string(args[j += 1]), sgn, pad, len, prc);
						break;

					case 'd':
						resBuilder.append(int32(args[j += 1]), sgn, pad, len, prc);
						break;
					case 'D':
						resBuilder.append(int64(args[j += 1]), sgn, pad, len, prc);
						break;

					case 'b':
						resBuilder.append(int32(args[j += 1]), sgn, pad, len, prc, 2);
						break;
					case 'B':
						resBuilder.append(int64(args[j += 1]), sgn, pad, len, prc, 2);
						break;

					case 'o':
						resBuilder.append(int32(args[j += 1]), sgn, pad, len, prc, 8);
						break;
					case 'O':
						resBuilder.append(int64(args[j += 1]), sgn, pad, len, prc, 8);
						break;

					case 'f':
						resBuilder.append(float32(args[j += 1]), sgn, pad, len, prc);
						break;
					case 'F':
						resBuilder.append(float64(args[j += 1]), sgn, pad, len, prc);
						break;

					case 'x':
						resBuilder.append(int32(args[j += 1]), sgn, pad, len, prc, 16);
						break;
					case 'X':
						resBuilder.append(int64(args[j += 1]), sgn, pad, len, prc, 16);
						break;

					case 'o':
						resBuilder.append(string(typename.invoke(args[j += 1], "toString", string(format, beg, i))));
						break;

					else:
						resBuilder.append(string(format, beg, i));
						break;
				}
			}
			else {
				resBuilder.append(chr);
			}
		}
		return string(resBuilder);
	}

	prototype {
		char charAt(int idx)					// Returns the character at the specified index.
		//~ char charCodeAt(int idx)			// Returns a number indicating the Unicode value of the character at the given index.
		string concat(string other)				// Combines the text of two strings and returns a new string.
		//~ int indexOf(char chr)					// Returns the index within the calling String object of the first occurrence of the specified value, or -1 if not found.
		//~ int lastIndexOf(char chr)				// Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found.
		int localeCompare(string other)			// Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order.
		Match[] match(regexp re)				// Used to match a regular expression against a string.
		replace()								// Used to find a match between a regular expression and a string, and to replace the matched substring with a new substring.
		search()								// Executes the search for a match between a regular expression and a specified string.
		string substr(int offset, int length)	// Returns the characters in a string beginning at the specified location through the specified number of characters.
		string substring(int start, int end)	// Returns the characters in a string between two indexes into the string.
		//~ string toLocaleLowerCase()				// The characters within a string are converted to lower case while respecting the current locale.
		//~ string toLocaleUpperCase()				// The characters within a string are converted to upper case while respecting the current locale.
		//~ string toLowerCase()					// Returns the calling string value converted to lower case.
		//~ string toUpperCase()					// Returns the calling string value converted to uppercase.
		//~ toString()							// Returns a string representing the specified object.
		//~ valueOf()							Returns the primitive value of the specified object.

		contains: function(str) {
			return this.indexOf(str) > -1;
		},
		endsWith: function(str) {
			var pos = this.indexOf(str);
			return pos > -1 && this.length == pos + str.length;
		}

		string[] split(string str, string separator) {
			int n = 0;
			for (int i = 0; i < str.length; i += 1) {
				if (separator.indexOf(str[i]) >= 0) {
					n += 1;
				}
			}

			result = new(string, n);
			for (int i = n = 0; i < str.length; i += 1) {
				if (separator.indexOf(str[i]) >= 0) {
					result[n] = string(str, beg, i - beg);
				}
			}
		}
		string slice(string str, int beg, int len) {
			assert(beg > str.length, "");
			if (beg > str.length)
				return null;

			if (len >= str.length - beg)
				len = str.length - beg - 1;

			return str[beg : beg + len];
			//~ result = emit(struct, i32.add, i32(beg), byRef(str), i32(len));
		}

	}

	///////////////////////////////////////////////
	// Operators ...
	/// implicit copy constructor from slice
	operator string(char values[]) = copyFrom(values);
	operator string(Builder builder) = Builder.ToString(builder);

	// direct access to length.
	operator (string str).length = int(str == null ? 0 : str.value.length);

	// enable get only: expression is not an rvalue.
	operator (string str)[int index] = char(str.value[chkBound(str, index)]);

	operator (string str).IndexOf(char val) = IndexOf(str, val);
	operator (string str).IndexOf(string val) = IndexOf(str, val);
}
