<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" type="text/css" href="Inspector.css">
<script type="application/javascript" src="Inspector.js"></script>
<script type="application/javascript" src="jsLibs/jsData.js"></script>
<script>

var data = Instrument();

function setActiveTab(tab, node, contentWriter) {
	var tabs = document.getElementById('tabs').children;
	var elements = document.getElementById('content').children;
	for (var i = 0; i < tabs.length; i++) {
		var element = tabs[i];
		if (element === tab) {
			element.classList.add('active');
		}
		else {
			element.classList.remove('active');
		}
	}
	for (var i = 0; i < elements.length; i++) {
		var element = elements[i];
		if (element === node.parentElement) {
			element.classList.add('active');
		}
		else {
			element.classList.remove('active');
		}
	}
	if (contentWriter != null) {
		var text, args = [];
		for (i = 2; i < arguments.length; ++i) {
			args[i - 2] = arguments[i];
		}
		text = contentWriter.apply(this, args);
		if (text !== undefined) {
			node.innerText = text;
		}
	}
}

function fileChanged(input, tab, loading, chart, tree) {
	if (input.files.length !== 1) {
		return;
	}
	setActiveTab(tab, loading);
	data.loadFile(input.files[0], function() {
		setActiveTab(tab, chart, function() {
			displayCallTree(chart, tree)
		});
	});
}

function displayCallTree(chart, callTree, focus) {
	var samples = data.getSamples();
	var tree = (focus && focus.__proto__);
	if (tree != null) {
		tree = {
			enter: tree.enter,
			leave: tree.leave,
			calltree: [tree]
		}
	}
	tree = extendCallTree(tree || samples);

	function extendCallTree(obj, parent) {
		var i, ct, result = Object.create(obj);
		if (obj.calltree != null) {
			ct = [];
			for (i = 0; i < obj.calltree.length; ++i) {
				ct.push(extendCallTree(obj.calltree[i], result));
			}
			Object.defineProperty(result, 'calltree', {value: ct});
		}
		Object.defineProperty(result, 'parent', {value: parent});
		return result;
	}

	function walkCallTree(node, depth, action) {
		if (node.calltree != null) {
			for (var i = 0; i < node.calltree.length; ++i) {
				var child = node.calltree[i];
				action(child, depth, node);
				walkCallTree(child, depth + 1, action);
			}
		}
	}

	if (chart != null) {
		var chartWidth = chart.clientWidth;
		var timeScale = chartWidth / (tree.leave - tree.enter);
		var heightScale = 2 + parseFloat(getComputedStyle(chart).fontSize);
		var maxDepth = 100;//(chart.clientHeight) / heightScale - 1;
		var minTime = 0;//(tree.leave - tree.enter) / 5000;	// 0.05%

		callTree.innerHTML = '';
		chart.innerHTML = '';

		var row = document.createElement("tr");
		var func, hits, selfTime, totalTime;
		row.appendChild(hits = document.createElement("th"));
		row.appendChild(selfTime = document.createElement("th"));
		row.appendChild(totalTime = document.createElement("th"));
		row.appendChild(func = document.createElement("th"));
		hits.innerText = "Hits";
		selfTime.innerText = "Self Time";
		totalTime.innerText = "Total Time";
		func.innerText = "Function";
		callTree.appendChild(row);

		walkCallTree(tree, 0, function(node, depth) {
			var expandable = false;
			var left = timeScale * (node.enter - tree.enter);
			var right = timeScale * (tree.leave - node.leave);

			var funct = node.func || { name: '??' };
			var sample = samples.samples[funct.offs] || {};	// make everithing undefined if function is not found

			var globalTime = samples.leave - samples.enter;

			var callSelfCost = (node.self * 100 / globalTime).toFixed(2) + ' %';
			var callTotalCost = (node.total * 100 / globalTime).toFixed(2) + ' %';
			var sampleSelfCost = (sample.self * 100 / globalTime).toFixed(2) + ' %';
			var sampleTotalCost = (sample.total * 100 / globalTime).toFixed(2) + ' %';

			var callSelfTime = (node.self * 1000 / samples.ticksPerSec).toFixed(2) + ' ms';
			var callTotalTime = (node.total * 1000 / samples.ticksPerSec).toFixed(2) + ' ms';
			var sampleSelfTime = (sample.self * 1000 / samples.ticksPerSec).toFixed(2) + ' ms';
			var sampleTotalTime = (sample.total * 1000 / samples.ticksPerSec).toFixed(2) + ' ms';

			var funcPos = ' <@' + funct.offs + '>';
			if (funct.file && funct.line) {
				funcPos = '(' + funct.file + ':' + funct.line + ')';
			}
			var title = 'Function: ' + funct.name + funcPos;
			if (sample.hits > 1) {
				title += '\nHit Count: ' + node.hits + ' / ' + sample.hits;
				title += '\nSelf Cost: ' + callSelfCost + ' / ' + sampleSelfCost;
				title += '\nSelf Time: ' + callSelfTime + ' / ' + sampleSelfTime;
				title += '\nTotal Cost: ' + callTotalCost + ' / ' + sampleTotalCost;
				title += '\nTotal Time: ' + callTotalTime + ' / ' + sampleTotalTime;
			}
			else {
				title += '\nHit Count: ' + sample.hits;
				title += '\nSelf Cost: ' + sampleSelfCost;
				title += '\nSelf Time: ' + sampleSelfTime;
				title += '\nTotal Cost: ' + sampleTotalCost;
				title += '\nTotal Time: ' + sampleTotalTime;
			}
			title += '\n' + funct.proto;

			// add to call chart
			if (depth < maxDepth && timeScale * node.total > .3) {
				var div = document.createElement("div");
				chart.appendChild(div);

				div.innerText = '\u00A0' + funct.name;

				div.style.left = left;
				div.style.right = right;
				div.style.top = depth * heightScale + 1;
				div.style.height = heightScale - 1;
				div.title = title;
				node.htmlChartNode = div;
				div.onclick = function() {
					var n;
					if (node.htmlTreeNode != null) {
						for (n = node; n != null; n = n.parent) {
							if (n.htmlTreeNode != null) {
								n.htmlTreeNode.style.display = '';
							}
						}
						node.htmlTreeNode.scrollIntoView(!true);
						node.htmlTreeNode.classList.add('hover');
						setTimeout(function() {
							node.htmlTreeNode.classList.remove('hover');
						}, 500);
					}
				}
				div.ondblclick = function(e) {
					displayCallTree(chart, callTree, node);
				};
			}

			// add to call tree
			if (node.total > minTime) {
				var row = document.createElement("tr");
				var func, hits, selfTime, totalTime;
				row.appendChild(hits = document.createElement("td"));
				row.appendChild(selfTime = document.createElement("td"));
				row.appendChild(totalTime = document.createElement("td"));
				row.appendChild(func = document.createElement("td"));

				hits.innerText = node.hits;
				//selfTime.innerText = callSelfCost;
				//totalTime.innerText = callTotalCost;
				// use local precentages
				selfTime.innerText = (node.self * 100 / (tree.leave - tree.enter)).toFixed(2) + ' %';
				totalTime.innerText = (node.total * 100 / (tree.leave - tree.enter)).toFixed(2) + ' %';


				node.htmlTreeNode = row;		// add a reference to the table row

				// check if the node has subcalls
				walkCallTree(node, 0, function(childNode, depth) {
					if (childNode.total > minTime && depth >= 0) {
						expandable = true;
					}
				});

				if (expandable) {
					// expanded by default.
					func.classList.add("expanded");

					// bind the function to toggle expand
					row.callTreeShow = function(expand) {
						if (!expandable) {
							return false;
						}
						func.classList.remove("collapsed");
						func.classList.remove("expanded");
						func.classList.add(expand ? "expanded" : "collapsed");
						return true;
					}

					func.onclick = function(event) {
						if (func.classList.contains("collapsed")) {
							row.callTreeShow(true);
							walkCallTree(node, 0, function(node, depth) {
								// expand only one depth
								if (node.htmlTreeNode == null || (!event.ctrlKey && depth > 0)) {
									return;
								}
								node.htmlTreeNode.style.display = '';
								/*if (event.ctrlKey && node.htmlExpander != null) {
									node.htmlTreeNode.innerText = expanded;
								}*/
							});
						}
						else {
							row.callTreeShow(false);
							walkCallTree(node, 0, function(node, depth) {
								// collapse each subnode
								if (node.htmlTreeNode == null) {
									return;
								}
								node.htmlTreeNode.style.display = 'none';
								if (node.htmlTreeNode.callTreeShow != null) {
									node.htmlTreeNode.callTreeShow(false);
								}
							});
						}
					}
				}

				func.appendChild(document.createTextNode(funct.proto));
				func.style.paddingLeft = (expandable ? depth : depth + 1) + 'em';
				row.title = title;
				row.onmouseenter = function(e) {
					if (node.htmlChartNode != null) {
						node.htmlChartNode.classList.add('hover');
					}
				};
				row.onmouseleave = function(e) {
					if (node.htmlChartNode != null) {
						node.htmlChartNode.classList.remove('hover');
					}
				};
				callTree.appendChild(row);
			}
		});
	}
}

function printCallTree() {
	return toJsString(data.getSamples(), '\n');
}

</script>
</head>
<body style="overflow:auto">
  <div id="tabs">
	<input id="filedata" onchange="fileChanged(this, call_tree_tab, loading, call_chart_data, call_tree_data);" type="file">
	<span id="call_tree_tab" onClick="setActiveTab(this, call_chart_data);" onDblClick="displayCallTree(call_chart_data, call_tree_data);">CallTree</span>
	<span onClick="setActiveTab(this, code, printCallTree);">CallInfo</span>
	<span onClick="setActiveTab(this, code, data.api.getSciteApi);">SciteApi</span>
	<span onClick="setActiveTab(this, code, data.api.getAll);">Symbols</span>
	<span onClick="setActiveTab(this, search);">Search</span>
  </div>
  <div id="content">
	<div><h1 id="loading">Loading data ...</h1></div>
	<div>
		<div id="call_chart_data"></div>
		<div id="call_tree_tool_bar"></div>
		<table>
			<tbody id="call_tree_data"></tbody>
		</table>
	</div>
	<div><pre id="code"></pre></div>
	<div><pre id="search"></pre></div>
  </div>
</body>
</html>
