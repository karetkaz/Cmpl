//~ #open src/core.h
//~ #open src/core.c
//~ #open src/tree.c

//~ #open src/code.c			// virtual mashine
//~ #open src/type.c			// type system
//~ #open src/parser.c			// input, lexer, parser
//~ #open src/printer.c			// pretty print, logger
//~ #open src/main.c

//~ define nan = emit(float64, int64(0xfff8000000000000));
//~ int c = 8192 + 19;
//~ define f64hex float64;	//%0x%016X
//~ define f32hex float32;	//%0x%08x
//~ f64hex nan1 = --(0/0.);
//~ f32hex nan2 = --(0/0.);

//~ double nan1 = Math.nan;
//~ double x = -1./0;//1e-500;
//~ bool n1 = isNan(x);
//~ bool n2 = isInf(x);
//~ bool n3 = isFinite(x);

//~ int64 n = 9;
//~ int i = !!n;

//~ /*
enum unittesting: bool {
	asin = true;
	acos = true;
}
float64 vf[10] =
	4.9790119248836735e+00,
	7.7388724745781045e+00,
	-2.7688005719200159e-01,
	-5.0106036182710749e+00,
	9.6362937071984173e+00,
	2.9263772392439646e+00,
	5.2290834314593066e+00,
	2.7279399104360102e+00,
	1.8253080916808550e+00,
	-8.6859247685756013e+00;

define epsilon = 1e-15;

static if (unittesting.asin) {
float64 asin[10] =
	5.2117697218417440497416805e-01,
	8.8495619865825236751471477e-01,
	-2.769154466281941332086016e-02,
	-5.2482360935268931351485822e-01,
	1.3002662421166552333051524e+00,
	2.9698415875871901741575922e-01,
	5.5025938468083370060258102e-01,
	2.7629597861677201301553823e-01,
	1.83559892257451475846656e-01,
	-1.0523547536021497774980928e+00;

for (int i = 0; i < vf.length; i += 1) {
	float64 x = vf[i] / 10;
	float64 f = Asin(x);
	if (abs(asin[i] - f) > epsilon) {
		//TODO: debug("test failed", {func: "Asin", arg_x: x, got: f, want: asin[i]});
		debug("test failed"); print("Asin(%g)", x); print(" = %g", f); print(", want %g\n", asin[i]);
	}
}
}
static if (unittesting.acos) {
float64 acos[10] =
	1.0496193546107222142571536e+00,
	6.8584012813664425171660692e-01,
	1.5984878714577160325521819e+00,
	2.0956199361475859327461799e+00,
	2.7053008467824138592616927e-01,
	1.2738121680361776018155625e+00,
	1.0205369421140629186287407e+00,
	1.2945003481781246062157835e+00,
	1.3872364345374451433846657e+00,
	2.6231510803970463967294145e+00;

for (int i = 0; i < vf.length; i += 1) {
	float64 x = vf[i] / 10;
	float64 f = Acos(x);
	if (abs(acos[i] - f) > epsilon) {
		//TODO: debug("test failed", {func: "Acos", arg_x: x, got: f, want: acos[i]});
		debug("test failed"); print("Acos(%g)", x); print(" = %g", f); print(", want %g\n", acos[i]);
	}
}
}
//~ */
//~ float32 x = -8.5;
//~ float32 y = x % 1;
//~ double nan = emit(struct, int64(0xfff8000000000000));
/*
int count = 19;
define Array(typename type, int32 ^n) = emit(struct, byRef(memmgr(null, type.size * n)), i32(n));

int32 arr2[] = Array(int32, count);

//~ for (int i = 0; i < arr2.length; i += 1) {arr2[i] = i + 10;}

int size = sizeof(arr2);
//~ */
/*TODO: refs and ptrs
int32 ival = 9;

int32 &iref1 = null;
int32 &iref2 = ival;

int32ptr iptr1 = null;
int32ptr iptr2 = ival;
int32ptr iptr3 = iref2;

//~ int32 x = iref2;

//~ int32ptr aaa(int &a) {&result = &a;}
//~ int32ptr t = aaa(null);
//~ */

/* typename
struct ss {
	int32 x;
	int32 y;
	struct ss {
		int64 x;
		int64 y;
	}
}

ss A = ss(1, 2);
ss.ss a = ss.ss(1, 2);

int n1 = sizeof(ss);
int n2 = sizeof(ss.ss);

//~ */

/* alloc / realloc / free
//~ define realloc(pointer ptr, int size) = memmgr(ptr, size);
define malloc(int size) = memmgr(null, size);
define free(pointer ptr) = memmgr(ptr, 0);

pointer p1 = null;
pointer p2 = null;
pointer p3 = null;
pointer p4 = null;

memmgr(null, 0);
p1 = malloc(160);
p2 = malloc(160);
p3 = malloc(160);
memmgr(null, 0);

if (true) {
	p3 = free(p3);
	p2 = free(p2);
	p1 = free(p1);
}
else {
	p1 = free(p1);
	p2 = free(p2);
	p3 = free(p3);
}

//~ realloc(null, 0);
//~ */

/* random floats
float32 frand() {
	uint32 randnum = rand() * rand();
	float32 tmp = emit(float32, i32((randnum >> 9 ) | 0x3f800000));
	result = tmp - 1;
}

float64 drand() {
	uint32 randnum1 = rand() * rand();
	uint32 randnum2 = rand() * rand();
	float64 tmp = emit(float64, i32(randnum1), i32((randnum2 >> 12) | 0x3ff00000));
	result = tmp - 1;
}

float maxrand = -1;
for(int i = 0; i < 30; i += 1) {
	float64 currand = drand();

	if (maxrand < currand)
		maxrand = currand;

	print("%f\n", currand);
}

// */

/* xxx
struct m {
	static const int X = 9;
	const int a;
	int b;
	int c;// = 8;
}

m m1 = m(5, 9, 1);
int &ref_m1_a = m1.a;	// hacked: warn if const/nonconst ref assignment.
ref_m1_a = 666;

int x = m1.a;

// */

/* arrays

// 1.K int maximum(int arr[12])
// 2.K int maximum(int arr[])
// 3.X int maximum(int arr...)

int arr2[3] = 1, 2, 3;
//~ int arr3[] = arr2;
//~ /+

int maximum(int arr[]) {
	result = arr[0];
	for (int i = 1; i < arr.length; i += 1) {
		if (result < arr[i]) {
			result = arr[i];
		}
	}
}

void sort(int arr[]) {
	for (int i = 0; i < arr.length - 1; i += 1) {
		for (int j = i + 1; j < arr.length; j += 1) {
			if (arr[i] > arr[j]) {
				int tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
			}
		}
	}
}

int bsearch(int arr[], int elem) {
	int lo = 0;
	int hi = arr.length;

	result = -1;
	for (;lo < hi;) {
		int mid = lo + ((hi - lo) / 2);
		int val = arr[mid];

		if (val < elem) {
			lo = mid + 1;
		}
		else if (val > elem) {
			hi = mid;
		}
		else {
			result = mid;
			//~ return;
			lo = hi;
		}
	}
}

void randomize(int arr[]) {
	for (int i = 0; i < arr.length; i += 1) {
		arr[i] = rand() % 30;
	}
}

//~ define hex32 int32;		// %hex32(0x%08x)

randomize(arr2);
int max = maximum(arr2);
int toFind = arr2[arr2.length / 2];
sort(arr2);
int index = bsearch(arr2, toFind);
// +/

//~ */

/* strings
string x = "almax a fa alatt";
string ss[3];
ss[0] = x;//"alma1 a fa alatt";
ss[1] = "alma2 a fa alatt";
ss[2] = "alma3 a fa alatt";
string y = ss[1];

int iii[3] = 1, 2, 3;
string sss[3] = x, "alma2 a fa alatt", "alma3 a fa alatt";

int a = ss.length;

ss[0][3] = 'A';

println(y);
println(ss[2]);

// */

/* static and nonstatic members.
struct alma {
	static int a0 = 9;
	int a1;
	int a2;
	int a3;
}

//~ alma &alma_a1 = null;
//~ int offs = emit(int, byRef(alma_a1.a3));
//~ int offs = emit(int, ref(alma(null).a2));

//~ pointer x = null;
//~ alma a2 = alma(x);

//~ alma a = alma(12, 13, 14);
//~ alma.a0 = 99;
//~ a = alma(a.a1, 0);

//~ a.a0 = 98;			// warning: member is accessed through an instance reference
//~ alma.a1 = 99;		// error: object reference is required to access the member `alma.a1`
//~ alma &a2 = a;
//~ int alma_a0 = alma.a0;
// */

/* xrgb
struct xrgb:1 {
	uint8 b;
	uint8 g;
	uint8 r;
	uint8 x;
}
struct xrgbi32:0 {
	xrgb rgb;
	int32 val;
}
//~ xrgb res = result;
//~ define min(int ^a, int ^b) = (a < b ? a : b);
//~ define clamp(int t, int a, int b) = min(max(t, a), b);

xrgb a = emit(xrgb, i32(0x801f008f));

//~ int structSize = xrgb.class.size;
//~ int objectSize = a.class.size;
//~ xrgb b = emit(a.typeOf, i32(0x1f002f));

//~ xrgb b = emit(xrgb, i32(0x2f3f1f));
//~ int r = a.r + b.r;

//~ xrgbi32 r;
//~ r.val = 0;

//~ r.rgb.r = min(a.r + b.r, 255);
//~ r.rgb.g = min(a.g + b.g, 255);
//~ r.rgb.b = min(a.b + b.b, 255);
// */

/* invoke functions ...
int method0() {}
int method1(int x) {
	//~ print("!alma a fa alatt nyÃ¡ri piros alma\n");
	static int i = 0;
	result = i += x;
	print("%D\n", int64(result));
}
int method1() {result = method1(1);}
int method2() {result = method1(2);}

void methodCall(int method()) {
	if (method == null) {
		print("(null)\n");
		return;
	}
	//~ print("(xxxx)\n");
	int n = method();
	//~ print("%D\n", int64(n));
}

//~ /+	just call it
static if (true) {
	method1();
	method2();
}// +/

//~ /+	call passed to another fun
//~ methodCall(method1);	// this will not work because there are 2 method1 named functions
methodCall(null);
methodCall(method2);
//~ +/

//~ /+	call as a reference
int method() = null;//method2;

//~ method = null;

if (method != null) {
	method();
}

methodCall(method);

// +/

//~ */
/* return function ...

/+ count down
struct Closure {int call(Closure &data); int data;}
define Invoke(Closure &wcd) = wcd.call(wcd);
//~ operator (Closure &wdc)() = wcd.call(wcd);

int countdown(Closure &a) {result = a.data; a.data -= 1;}

Closure a = Closure(countdown, 3);
Closure b = Closure(countdown, 30);

println(Invoke(a));
println(Invoke(b));
println(Invoke(a));
println(Invoke(a));
println(Invoke(a));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
// +/

//~ /+ count down (2) with args
struct Closure {int64 call(Closure &c, int64 n); int64 data; int32 calls; /+...+/ }
define Closure(int64 call(Closure &c, int64 n), int64 data) = Closure(call, data, 0);

define Invoke(Closure c, int64 n) = c.call(&c, n);
//~ operator (Closure c)(int64 n) = c.call(c, n);

int64 countdown(Closure &c, int64 n) {result = c.data; c.data -= n; c.calls += 1; }

Closure a = Closure(countdown, 90);

print("%d\n", int64(Invoke(a, 9)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));
//~ +/
//~ */
/*BUG: assignment by reference

int64 a = 32;
//~ a = 33;
void setup() {
	//~ static int64 &b = a;
	print("%d\n", int64(a));
}
setup();
//~ */

/* factorial
define n = 6;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
define eps = 1e-50;
double tmp = 1.;
double res = 1.;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* iterating

void printIT(int ri) {
	print("iterator {%d}\n", int64(ri));
}

//~ /+
struct array_iterator {
	int pos;
	int arr[];
}

array_iterator iterator1(int a[]) {
	result = array_iterator(0, a);
}
define iterator(int a[]) = array_iterator(0, a);

bool next(array_iterator &it, int &val) {
	result = it.pos < it.arr.length;
	if (result) {
		//~ val = it.arr[it.pos];
		val = it.pos;
		it.pos += 1;
	}
}

int a[40] = 1, 2, 3, 4;
array_iterator it = iterator(a);
for (int pos : a) {
	printIT(pos);
}

/+
define iterator(file &f) = emit(file, ref(f));
bool next(file &it, int &chr) {
	chr = fgetc(it);
	result = chr != -1;
}// +/

/+
struct range {
	int min;
	int max;
	bool exclusive;
}

struct range_iterator {
	int pos;
	int max;
	bool exclusive;
}

define iterator(range ^r) = range_iterator(r.min, r.max, r.exclusive);	// start at min, and end at max

void printIT(range_iterator ri) {
	print("iterator {");
	print("pos: %d", int64(ri.pos));
	print(", max: %d", int64(ri.max));
	//~ print(", excl: %d", int64(ri.exclusive));
	print("}\n");
}

bool next(range_iterator &it, int &val) {
	result = it.pos - it.exclusive < it.max;
	//~ result = it.pos < it.max;
	if (result) {
		val = it.pos;
		it.pos += 1;
	}
}
bool next(range_iterator &it, range_iterator &val) {
	result = it.pos - it.exclusive < it.max;
	//~ result = it.pos < it.max;
	if (result) {
		val = it;
		it.pos += 1;
	}
}

//~ /+
for (range_iterator it : range(10, 13, true)) {
	printIT(it);
}// +/

//~ /+
for (int it : range(10, 13, true)) {
	printIT(it);
}// +/

/+
for (range_iterator it = iterator(range(10, 13, true)); next(it, it); ) {
	printIT(it);
}// +/
//~ +/

//~ */

/*
double val = 9;//emit(float64, i64(0x7ff8000000000000));
print("0b%064B\n", val);
print("0x%016X\n", val);

println(int64(val));
println(float64(val));
double f64_nan = emit(float64, i64(0b0111111111111000000000000000000000000000000000000000000000000000));
double f64_inf = emit(float64, i64(0b0111111111110000000000000000000000000000000000000000000000000000));
double f64_one = emit(float64, i64(0b0011111111110000000000000000000000000000000000000000000000000000));
//~ */

/* enumeration
/+
struct vec4f {
	float32 x;
	float32 y;
	float32 z;
	float32 w;
}// +/

enum: vec4f {
	O = vec4f(0, 0, 0, 0);
	X = vec4f(1, 0, 0, 0);
	Y = vec4f(0, 1, 0, 0);
	Z = vec4f(0, 0, 1, 0);
}

vec4f z = Z;
// */
/+ const variable, parameter, member
int a(const int x) {
	int &X = x;		// todo: constant asigned to non constant
	X = 0;
	result = x;
}

int x = a(4);

const vec4f Z = vec4f(0, 0, 1, 0);
//~ +/

/*
struct individual {
	bool gene[2][10];
	double xreal[2];
	double objectives[2];
	double constraints[2];

	const int rank;
	double constr_violation;
	const double xbin[10];
	//~ double crowd_dist;
}

struct population {
	double min;
	double max;
	individual ind[1000];
}

//~ /+
define pi1M(double x, double y) = (x + y);
define pi2M(double x, double y) = (x + y);

int fitness(individual &ind) {
	ind.objectives[0]= -pi1M(ind.xbin[0], ind.xbin[1]);
	ind.objectives[1]= -pi2M(ind.xbin[0], ind.xbin[1]); 
}

// +/
//~ double size = 88006400 / double(1 << 20);
static population pop[3000];


//~ */

//~ int n = sizeof(Math);

/+ bugs:
int s1 = sizeof(pointer);		// pointer casts to ref
int s2 = sizeof(Math);			// enum base type is not typename
//~ arrays in structures suck
// +/
/+ todo:
- var type: variant, always by ref, struct variant {typename type; uint8 data[0]};
	var x = new int(0);
	var x = new vec4f(0, 1, 0, 1);
	var x = new int[20];
	var x = new {
		x: "alma";
		z: int(3);
		c: vec4f(2,3,4,5);
		ss: {
			z:"alma";
 		};
		f: function()
	};

	//~ sort_function(int array[0, 3, 4, 2, 5, 1], int function(int a, int b){return a.compareTo(b);})
	//~ sort_delegate(int array[0, 3, 4, 2, 5, 1], int delegate{int xxx}(int a, int b){return a == b ? 0 : a > b ? 1 : -1;});

// +/

/* optimizing stackalloc
	// spc -24
		spc -16
		spc -8

{
	int a[1<<10];
	{
		int a[1<<10];
		{
			int a[1<<10];
			{
				int a[1<<20];
				{
					int a[1<<10];
					{
						int a[1<<10];
						a[0] = 9;
					}
					a[0] = 9;
				}
				a[0] = 9;
			}
			a[0] = 9;
		}
		a[0] = 9;
	}
}*/

/+Optimize
	// remove dup.x1 sp(0) and spc -4
		ldc.ref 5ee1
		dup.x1 sp(0)
		libc: define print( &val)
		spc -4

//~ +/
/+class string: char[] {
	static format(string format, var args) {}
	struct Builder {
		
	}
	
	prototype {
		char charAt(int idx)					// Returns the character at the specified index.
		//~ char charCodeAt(int idx)			// Returns a number indicating the Unicode value of the character at the given index.
		string concat(string other)				// Combines the text of two strings and returns a new string.
		int indexOf(char chr)					// Returns the index within the calling String object of the first occurrence of the specified value, or -1 if not found.
		int lastIndexOf(char chr)				// Returns the index within the calling String object of the last occurrence of the specified value, or -1 if not found.
		int localeCompare(string other)			// Returns a number indicating whether a reference string comes before or after or is the same as the given string in sort order.
		Match[] match(regexp re)				// Used to match a regular expression against a string.
		replace()								// Used to find a match between a regular expression and a string, and to replace the matched substring with a new substring.
		search()								// Executes the search for a match between a regular expression and a specified string.
		slice()									// Extracts a section of a string and returns a new string.
		string[] split(string sep)				// Splits a String object into an array of strings by separating the string into substrings.
		string substr(int offset, int length)	// Returns the characters in a string beginning at the specified location through the specified number of characters.
		string substring(int start, int end)	// Returns the characters in a string between two indexes into the string.
		string toLocaleLowerCase()				// The characters within a string are converted to lower case while respecting the current locale.
		string toLocaleUpperCase()				// The characters within a string are converted to upper case while respecting the current locale.
		string toLowerCase()					// Returns the calling string value converted to lower case.
		string toUpperCase()					// Returns the calling string value converted to uppercase.
		//~ toString()							// Returns a string representing the specified object.
		//~ valueOf()							Returns the primitive value of the specified object.
	}
}// +/
