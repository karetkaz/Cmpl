//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

//~ module test;

//~ int alma(int h)[10];	???
//~ void fun(int x) = true ? null : void(int x){print(x);});

/*
const M:double {
	pi = 3.14159265358979323846264338327950288419716939937510582097494459;		// A000796
	e = 2.71828182845904523536028747135266249775724709369995957496696763;		// A001113
	ln2 = 0.693147180559945309417232121458176568075500134360255254120680009;		// A002162
	log2E = 1 / ln2;
	ln10 = 2.30258509299404568401799145468436420760110148862877297603332790;		// A002392
	log10E = 1 / ln10;
	phi = 1.61803398874989484820458683436563811772030917980576286213544862;		// A001622
	sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
	sqrtE = 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
	sqrtPi = 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
	sqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
}// */

//~ const Pi1 = 3.14159265358979323846264338327950288419716939937510582097494459;
//~ const Pi2 :int = 3.14159265358979323846264338327950288419716939937510582097494459;
//~ const Pi3 :float64 = 3.14159265358979323846264338327950288419716939937510582097494459;

//~ struct gxClut:1 {			// Color Look Up Table (Palette) structure
	//~ int16	count;
	//~ uint8	flags;
	//~ uint8	trans;
	//~ int32	data[256];
//~ }




void openImg(string file) {
	//~ string fileName = file;//emit(string, load.b32, ref(file));//emit(string, string(file));
	//~ int8 alma[0] = emit();
	//~ int len;
	//~ for (len = 0; file[len] != 0; len += 1) {}
	//~ print("len = "); 
	println(file);
	/+if (int(len > 4) & int(alma[len - 4] == '.')) {
		int chr = alma[len - 3];
		if (int(chr == 'j') | int(chr == 'J')) {
			int chr = alma[len - 2];
			if (int(chr == 'p') | int(chr == 'P')) {
				int chr = alma[len - 1];
				if (int(chr == 'g') | int(chr == 'G')) {
					println("jpg");
					//~ result = readJpg(file);
				}
			}
		}
		if (int(chr == 'b') | int(chr == 'B')) {
			int chr = alma[len - 2];
			if (int(chr == 'm') | int(chr == 'M')) {
				int chr = alma[len - 1];
				if (int(chr == 'p') | int(chr == 'P')) {
					println("bmp");
					//~ result = readBmp(file);
				}
			}
		}
	}// +/
}

string fileName = "alma.bmp";

//~ openImg("alma");

//~ println(fileName);
/*
struct slice {
	int length;
	ptr data;
}

struct variant {
	typeInfo &typeref;
	pointer  data;
}
*/
//~ hex32 xxx = 0;
/*
struct gxRect: 4 {
	int x;
	int y;
	int w;
	int h;
}

define gxRect(int x, int y, int w, int h) = emit(gxRect, i32(x), i32(y), i32(w), i32(h));

gxRect x = gxRect(1,2,3,4);
gxRect y = gxRect(1,2,3,4);
gxRect z = gxRect(1,2,3,4);

//~ vec4f vvv = vec4f(1,2,3,4);
println(vec4f(1.,2.,3.,4.));
*/
/*
//~ addEventListener(MouseEvent.CLICK, function() {System.exit(0);});
//~ float a = lerp(.6, 0, 1);

struct gxRect {
	int x;
	int y;
	int w;
	int h;
}
void tileSurf(int dst, int src, gxRect &roi) {
	int dstw = 0;//width(dst);
	int dsth = 0;//height(dst);
	int srcw = 0;//width(src);
	int srch = 0;//height(src);

	if (roi == null) {
		srcw = roi.w;
		srch = roi.h;
	}
}
// */

/*
void bitsget(bool signed, int size, int64 &min, int64 &max) {
	int64 mask = bits.shr(int64(-1), -size);
	min = bits.shl(-int64(signed), size - 1);
	max = bits.and(min - 1, mask);
}

hex64 min;
hex64 max;

hex64 umin;
hex64 umax;

int bitsize = 18;
bitsget(true, bitsize, min, max);
bitsget(!true, bitsize, umin, umax);
// */

/* call functions passed as argument to function
//~ void method() = null;

//~ /+

/+int postInc(int &a, int inc) {
	result = a;
	a += inc;
}
define postInc(int a) = postInc(a, 1);

//~ int x = 0;
//~ int x1 = postInc(x);
//~ int x2 = postInc(x);
//~ int x3 = postInc(x);
// +/

int method4() {}
int method5(int x) {}

//~ /+	the methods
int method2(int x) {
	//~ putstr("!alma a fa alatt ny√°ri piros alma\n");
	static int i = 0;
	result = i += x;
	println(result);
}
int method2() {result = method2(3);}
int method3() {result = method2(2);}
// +/

/+	just call it
static if (true) {
	method2();
	method2();
	method2();
}// +/

/+	call passed to another fun
void methodCall(int method()) {
	if (method != null) {
		int n = method();
	}
	else println("(null)");
}
methodCall(method3);
methodCall(method3);
methodCall(null);

//~ +/

//~ /+	call as a reference
void methodV() {method2(2);}
//~ int method3() {}
//~ static 
if (true) {

void method() = methodV;

if (method != null) {
	method();
}
//~ else println("(null)");
}
// +/

//~ */

/* use: ./ccvm -c -x -O-2 test.cvx
debug1(1, 2, 3);

static int X = 1;
static int Y = 2;
static int Z = 3;

int x = 1;
int y = 2;
int z = 3;
//~ */

/* Test functions

void alma(int &x) {print("alma:");println(x);}
void korte(int &x) {print("korte:");println(x);}

// this wont work if not static
//~ void almaref(int &x) = alma;

void setCallBack(int mode, void handler(int &Event)) {
	if (handler != null)
		handler(mode);
}

setCallBack(100, null);
setCallBack(101, alma);
setCallBack(106, korte);
//~ setCallBack(106, almaref);

// */

/* using strings

long cikkId = 165;
long raktar = 3;
long btetelId = 6398;
double mennyiseg = 1;

define strlen = 25;
define char uint8; //%'%c'
char val[strlen + 1];
val[strlen] = 0;

println("INSERT INTO gyariszam(cikk_id, mennyiseg, b_tetel_id, raktar_id, gyariszam) VALUES");
for (int i = 0; i < 40; i += 1) {

	for (int j = 0; j < strlen; j += 1)
		val[j] = random('a', 'z');

	print("("); print(cikkId);
	print(", "); print(mennyiseg);
	print(", "); print(btetelId);
	print(", "); print(raktar);
	print(", '"); print(emit(string, ref(val)));
	println("'),");
}
// */

/* recursive
void recurse(int x) {
	if (x > 0) {
		print("pre: "); println(x);
		recurse(x - 1);
		print("post: "); println(x);
	}
}

recurse(20);
// */

/* Bits: hi, lo, extend
define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend
define Lo64(int64 a) = emit(int32, set, i64(a));	// Lo32 part
define Hi64(int64 a) = emit(int32, pop, i64(a));	// Hi32 part
//~ define Lo32(int32 a) = int32(a & 0xffff);			// Lo16 part
//~ define Hi32(int32 a) = Lo32(a >> 16);				// Hi16 part
//~ define Lo16(int32 a) = int32(a & 0xff);				// Lo16 part
//~ define Hi16(int32 a) = Lo16(a >> 8);				// Hi16 part

hex64 val = 0xff00ff00ff0f0f0f9;
hex32 lo = Lo64(val);
hex32 hi = Hi64(val);

void xx() {
	static int xx1 = 0;
}

// */

/* clamp, lerp, smooth
//~ define e1 = double(2);
//~ define e1 = float(2);
float e1 = 0;
float e2 = 6;
float s = (e2 - e1) / 100;
for (float x = e1; x < e2; x += s) {	// x in [e1, e2]
	float t = (x - e1) / (e2 - e1);		// t in [0., 1.]
	//~ println(lerp(t, e1, e2));
	println(smooth(x, e1, e2));
	//~ println(clamp(t, .2, .6));
}
// */

/* cross, normalize
vec4f a = vec4f(1., 2., 3., 5.);
vec4f b = vec4f(0., 2., 0., 5.);
vec4f e = cross(a, b);
vec4f E = normalize(cross(vec4f(1., 2., 3.), vec4f(10., 20., 3.)));
// */

/* float compare
define __eps = 1e-15;
//~ define eq(float32 a, float32 b, float32 eps) = bool(abs(a - b) < eps);
define eq(float64 a, float64 b, float64 eps) = bool(abs(a - b) < eps);

//~ define eq(float32 a, float32 b) = eq(a, b, float32(__eps));
define eq(float64 a, float64 b) = eq(a, b, __eps);

define double1 float64;//%%2.10F

double1 a = 0.1; //%hexaban 0x%016X
double1 b = 0.2;
double1 c = 0.3;
bool x = (a + b) + c == a + (b + c);
bool x1 = eq((a + b) + c, a + (b + c));

// */

/* random numbers
for (int i = 0; i < 60; i += 1) {
	println(random(1.001));
}
// */

/* using emit; and emit();
//~ string alma = "alma a fa alatt";
//~ println(1 + 4);

int64 t1 = 314;
int64 t2 = emit();
int64 t3 = emit;
print(t2);
print(t3);

//~ t3 = 90;
//~ println(t3);
// */

/+ hex view: use: ./ccvm -c -x -O-2 test.cvx

int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
define n = 6;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
//~ {
	//~ int i = 1;
	res *= i;
}
// */
/* calc E
define eps = 1e-50;
double tmp = 1.;
double res = 1.;
//~ hex64 Res = emit();
for (int i = 1; tmp > eps; i += 1) {
	//~ double old = res;
	res += tmp /= i;
	//~ if (old == res) tmp = 0;
}
// */

/* test scope:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (0) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(0)

//~ */
