//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

//~ module test;

//~ vec4f Alma = vec4f(1., 2., 3., 4.);
//~ vec4f alma = emit(vec4f, swz.xzwy, val(Alma));

//~ int alma(int h)[10];	???
//~ void fun(int x) = true ? null : void(int x){print(x);});
/*
struct slice {
	int length;
	ptr data;
}

struct variant {
	typeInfo &typeref;
	pointer  data;
}

*/

/* Bits: hi, lo, extend
define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend
define Lo64(int64 a) = emit(int32, set, i64(a));	// Lo32 part
define Hi64(int64 a) = emit(int32, pop, i64(a));	// Hi32 part
//~ define Lo32(int32 a) = int32(a & 0xffff);			// Lo16 part
//~ define Hi32(int32 a) = Lo32(a >> 16);				// Hi16 part
//~ define Lo16(int32 a) = int32(a & 0xff);				// Lo16 part
//~ define Hi16(int32 a) = Lo16(a >> 8);				// Hi16 part

//~ struct HL32{int32 lo; int32 hi;}
//~ define Lo64(int64 &a) = int32(emit(HL32, ref(a)).lo);	// Lo32 part
//~ define Hi64(int64 &a) = int32(emit(HL32, ref(a)).hi);	// Hi32 part

hex64 val = 0xff00ff00ff0f0f0f9;
hex32 lo = Lo64(val);
hex32 hi = Hi64(val);

// */
/* get 0 < n <= 64 bit minimum / maximum (signed/unsigned) values
void bitsget(bool signed, int size, int64 &min, int64 &max) {
	int64 mask = bits.shr(int64(-1), -size);
	min = bits.shl(-int64(signed), size - 1);
	max = bits.and(min - 1, mask);
}

hex64 min;
hex64 max;

hex64 umin;
hex64 umax;

int bitsize = 64;
bitsget(true, bitsize, min, max);
bitsget(!true, bitsize, umin, umax);
// */

//~ int i = 9;
//~ int8 arr[6];
//~ println(int(arr[9]));

void puthex(int32 num) {
	/*void puthex_(int32 num) {
		if (num >= 16) {
			puthex_(num / 16);
		}
		putchr("0123456789ABCDEF"[num % 16]);
	}
	puthex_(num);
	// */
	if (num >= 16) {
		puthex(num / 16);
	}
	putchr("0123456789ABCDEF"[num % 16]);
}

int x = 0x0f00ff98;

puthex(x);
putchr('\n');
//~ println(int("0123456789ABCDEF"[9]));
/* call functions passed as argument to function
//~ void method() = null;

//~ /+

/+int postInc(int &a, int inc) {
	result = a;
	a += inc;
}
define postInc(int a) = postInc(a, 1);

//~ int x = 0;
//~ int x1 = postInc(x);
//~ int x2 = postInc(x);
//~ int x3 = postInc(x);
// +/

int method4() {}
int method5(int x) {}

//~ /+	the methods
int method2(int x) {
	//~ putstr("!alma a fa alatt ny√°ri piros alma\n");
	static int i = 0;
	result = i += x;
	println(result);
}
int method2() {result = method2(3);}
int method3() {result = method2(2);}
// +/

//~ /+	just call it
static if (true) {
	method2();
	method2();
	method2();
}// +/

//~ /+	call passed to another fun
void methodCall(int method()) {
	if (method != null) {
		int n = method();
	}
	else println("(null)");
}
methodCall(method3);
methodCall(method3);
methodCall(method3);
methodCall(method3);
methodCall(method3);
methodCall(null);
//~ +/

/+	call as a reference
void methodV() {method2(2);}
//~ int method3() {}
//~ static 
if (true) {

void method() = methodV;

if (method != null) {
	method();
}
//~ else println("(null)");
}
// +/

//~ */

/* use: ./ccvm -c -x -O-2 test.cvx
debug1(1, 2, 3);

static int X = 1;
static int Y = 2;
static int Z = 3;

int x = 1;
int y = 2;
int z = 3;
//~ */

/* using strings

long cikkId = 165;
long raktar = 3;
long btetelId = 6398;
double mennyiseg = 1;

define strlen = 25;
define char uint8;
char val[strlen + 1];
val[strlen] = 0;

println("INSERT INTO gyariszam(cikk_id, mennyiseg, b_tetel_id, raktar_id, gyariszam) VALUES");
for (int i = 0; i < 40; i += 1) {

	for (int j = 0; j < strlen; j += 1)
		val[j] = random('a', 'z');

	print("("); print(cikkId);
	print(", "); print(mennyiseg);
	print(", "); print(btetelId);
	print(", "); print(raktar);
	print(", '"); print(emit(string, ref(val)));
	println("'),");
}
// */

/* recursive
void recurse(int x) {
	if (x > 0) {
		print("pre: "); println(x);
		recurse(x - 1);
		print("post: "); println(x);
	}
}

recurse(20);
// */

/* clamp, lerp, smooth
//~ define e1 = double(2);
//~ define e1 = float(2);
float e1 = 0;
float e2 = 6;
float s = (e2 - e1) / 100;
for (float x = e1; x < e2; x += s) {	// x in [e1, e2]
	float t = (x - e1) / (e2 - e1);		// t in [0., 1.]
	//~ println(lerp(t, e1, e2));
	println(smooth(x, e1, e2));
	//~ println(clamp(t, .2, .6));
}
// */

/* cross, normalize
vec4f a = vec4f(1., 2., 3., 5.);
vec4f b = vec4f(0., 2., 0., 5.);
vec4f e = cross(a, b);
vec4f E = normalize(cross(vec4f(1., 2., 3.), vec4f(10., 20., 3.)));
// */

/* float compare
define __eps = 1e-15;
//~ define eq(float32 a, float32 b, float32 eps) = bool(abs(a - b) < eps);
define eq(float64 a, float64 b, float64 eps) = bool(abs(a - b) < eps);

//~ define eq(float32 a, float32 b) = eq(a, b, float32(__eps));
define eq(float64 a, float64 b) = eq(a, b, __eps);

define double1 float64;//%%2.10F

double1 a = .1; //%hexaban 0x%016X
double1 b = .2;
double1 c = .3;
double1 d = (a + b) + c; //%%.20f
double1 e = a + (b + c); //%%.20f
bool x = (a + b) + c == a + (b + c);
bool x1 = eq((a + b) + c, a + (b + c));

// */

/* random numbers
for (int i = 0; i < 60; i += 1) {
	println(random(1., 1.001));
}
// */

/* using emit(); ./ccvm -c -x -O-2 test.cvx
int64 t1 = 314;
int64 t2 = emit();
print(t2);

// */

/+ hex view: use: ./ccvm -c -x -O-2 test.cvx

int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
const n = 6;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
const eps = 1e-50;
double tmp = 1.;
double res = 1.;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* test scope:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (0) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(0)

//~ */
