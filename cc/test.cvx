//~ src/ccvm.c
//~ src/pvmc.h
//~ ./main ="3 + 3 -4 + -2"

/* TODOS:
 * static if (true) does not enter new scope
 ? static if else part
 * nameless enum does not enter new scope
 ? nameless struct does not enter new scope
 * .
 ? separate struct and unoin declaration.
 *	in case of structures create a new constructor with all members; fix padding on stack.
 ?	in case of unions create a constructors with all members? or with the bigger.

 * default ctor from:
 *  	(basic types): ptr, basic types			// int(ptr), float(ptr), int(float), float(int)
 *  	(struct types): ptr, fields as param	// struct X{int a; float b;} => X(int a, float b)
 *  	(class types): box,
 * 
 ~ function argument cast bugs
 * TODO: define fact(int64 n) = (n * fact(n - 1));
 * define read(typename typ, pointer &ptr) = typ((ptr += sizeof(typ)) - sizeof(typ));
 * define write(typename typ, pointer &ptr, typ value) = memcpy((ptr += sizeof(typ)) - sizeof(typ), value);
 * 
 * int32 a = int(pointer(0xB8000));
 * pointer(0xB8000) := int32(9);
**/
/* TODOS(emit)
 * some emit opcodes should have const params
 * enable type as first param: emit(i32, f32(1)); see f32 as i32; remove void?
 * enable emit as param in emit: define mad(a, b, c) = emit(f32.add, f32.mul, f32(a), f32(b), f32(c));
 * 
**/
//~ define fact(int64 n) = (n * fact(n - 1));
//~ flt32 a = -math.nan;
/*
/+enum vec4F: vec4f {
	X = vec4f(1, 0, 0, 1);
	Y = vec4f(0, 1, 0, 1);
	Z = vec4f(0, 0, 1, 1);
}

vec4f a;// = vec4F.X;
a = vec4F.X;
//~ +/

enum alma2: bool {
	//~ X = xyz(1, 0, 0);
	//~ Y = xyz(0, 1, 0);
	//~ Z = xyz(0, 0, 1);
	b = 3476;// = M.Phi;		// problems
	c = 9;
	x = true;
	y = !true;
	z = false;
}
alma2 XX = alma2.y;
int a = alma2.z;

//~ */

/*enum Test {
	Emit = -0;
	Bits = -0;
	Type = -0;
	Misc = -0;
	//~ Libc = -1;
	//~ Call = 0;
} // */
/*static if (Test.Emit) {
static if (Test.Emit & 0x01) {
flt32 res1 = emit(f32.div, f32(2), f32(math.pi));	// ok
flt64 res2 = emit(f64.neg, f64(math.pi));			// ok
flt32 res3 = emit(f32(math.pi));				// ok
int32 res4 = emit(f32(math.pi));				// ok

emit(f64(math.pi));
int32 i32 = emit();
flt32 f32 = emit();
int64 i64 = emit();
flt64 f64 = emit();

}
static if (Test.Emit & 0x02) {
define shl(int32 value, int count) = emit(i32.shl, i32(count), i32(value));
define shr(int32 value, int count) = emit(i32.shr, i32(count), i32(value));
define shr(uns32 value, int count) = emit(u32.shr, i32(count), i32(value));

define add(flt32 a, flt32 b) = flt32(emit(f32.add, f32(b), f32(a)));		// := a + b
define sub(flt32 a, flt32 b) = flt32(emit(f32.sub, f32(b), f32(a)));
define mul(flt32 a, flt32 b) = flt32(emit(f32.mul, f32(b), f32(a)));
define div(flt32 a, flt32 b) = flt32(emit(f32.div, f32(b), f32(a)));
define mod(flt32 a, flt32 b) = flt32(emit(f32.mod, f32(b), f32(a)));

define mad(flt32 a, flt32 b, flt32 c) = emit(f32.add, f32.mul, f32(a), f32(b), f32(c));	// a * b + c
define mad(flt64 a, flt64 b, flt64 c) = emit(f64.add, f64.mul, f64(a), f64(b), f64(c));	// a * b + c
define mad(int32 size, int32 index, int32 offset) = emit(u32.mad, i32(size), i32(index), i32(offset));

int a = -0x8989;

int32 a1 = shr(uns32(a), 8);
int64 a2 = shr(int32(a), 8);

//~ flt32 X1 = mad(2, 3, 4000);
//~ flt32 X2 = mad(float(2), float(3), float(4000));
//~ flt32 X3 = mad(2., 3., 4000.);

}
static if (Test.Emit & 0x04) {
double a_re = 3.;
double a_im = 4.;
double b_re = 2.;
double b_im = 5.;

enum prog {
	none;
	sisd;
	simd;
}

define test2exec = prog.simd;
define times2exec = -10000000;

static if (times2exec < 0) {
	static if (test2exec == prog.sisd) {
		flt64 re = a_re * b_re - a_im * b_im;
		flt64 im = a_re * b_im + a_im * b_re;
	}

	static if (test2exec == prog.simd) {
		flt64 re = emit(f64.sub, v2d.mul, f64(b_im), f64(b_re), f64(a_im), f64(a_re));		// re = a.re * b.re - a.im * b.im
		flt64 im = emit(f64.add, v2d.mul, f64(b_re), f64(b_im), f64(a_im), f64(a_re));		// im = a.re * b.im + a.im * b.re
	}
}

static if (times2exec > 0) {
	static if (test2exec == prog.sisd) {	// 28.689(10000000)
		for (int i = 0; i < times2exec; i += 1) {
			flt64 re = a_re * b_re - a_im * b_im;
			flt64 im = a_re * b_im + a_im * b_re;
		}
	}
	static if (test2exec == prog.simd) {	// 26.072(10000000)
		for (int i = 0; i < times2exec; i += 1) {
			emit(v2d.mul, f64(b_im), f64(b_re), f64(a_im), f64(a_re));		// a.re * b.re, a.im * b.im
			flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
			emit(v2d.mul, f64(b_re), f64(b_im), f64(a_im), f64(a_re));		// a.re * b.im, a.im * b.re
			flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
		}
	}
}
}
static if (Test.Emit & 0x08) {

vec4f v1 = emit(f32(11), f32(12), f32(13), f32(14));
vec4f v2 = emit(f32(21), f32(22), f32(23), f32(24));

//~ emit(swz.xywz);
//~ emit(v4f.add, f32(v1.x), f32(v1.y), f32(v1.z), f32(v1.w));
emit(v4f.add);		// (Error | Warn)? statement underflows stack
//~ emit(v4f.dp3);
//~ 1+emit(v4f.dp3);

vec4f fv = emit();
flt32 sp[4] = emit();

//~ flt32 x0 = fv.x;
//~ flt32 y0 = fv.y;
//~ flt32 z0 = fv.z;
//~ flt32 w0 = fv.w;
//~ flt32 x = sp[0];
//~ flt32 y = sp[1];
//~ flt32 z = sp[2];
//~ flt32 w = sp[3];
//~ for (int i = 0; i < 4; i += 1)
	//~ sp[i] = i < 0;

//~ int32 i32 = emit(void);
//~ flt32 f32 = emit(void);
//~ int64 i64 = emit(void);
//~ flt64 f64 = emit(void);

//~ flt32 stop[] = new flt32[4];
//~ f64x2 res5 = emit(void, f64(1), f64(2));

}
} // */
/*static if (Test.Bits) {
int32 var = 0x00001080;		// input
static if (Test.Bits & 1) {
int32 BSR_lib = bsr(var);
int32 BSR_res = -1;
if (var != 0) {
	uns32 ans = 0;
	uns32 x = var;
	//~ if (x & 0xffffffff00000000) { ans += 32; x >>= 32; }
	if (x & 0xffff0000) { ans += 16; x >>= 16; }
	if (x & 0x0000ff00) { ans +=  8; x >>=  8; }
	if (x & 0x000000f0) { ans +=  4; x >>=  4; }
	if (x & 0x0000000c) { ans +=  2; x >>=  2; }
	if (x & 0x00000002) { ans +=  1; }
	BSR_res = ans;
}
}
static if (Test.Bits & 2) {
int32 BHI_lib = bhi(var);
int32 BHI_res = -1;
if (var) {
	uns32 u = var;
	u |= u >> 1;
	u |= u >> 2;
	u |= u >> 4;
	u |= u >> 8;
	u |= u >> 16;
	BHI_res = u - (u >> 1);
}
}
static if (Test.Bits & 4) {
int32 SWP_lib = swp(var);
int32 SWP_res = -1;
if (var) {
	uns32 x = var;
	x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
	x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
	x = ((x >> 4) & 0x0F0F0F0F) | ((x & 0x0F0F0F0F) << 4);
	x = ((x >> 8) & 0x00FF00FF) | ((x & 0x00FF00FF) << 8);
	SWP_res = (x >> 16) | (x << 16);
}
//~+/
}
} // */
/*static if (Test.Type) {
static if (Test.Type & 0x01) {
enum M: flt64 {
	E		= 2.71828182845904523536028747135266249775724709369995957496696763;	// A001113
	Pi		= 3.14159265358979323846264338327950288419716939937510582097494459;	// A000796
	Phi		= 1.61803398874989484820458683436563811772030917980576286213544862;	// A001622
	Sqrt2	= 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
	SqrtE	= 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
	SqrtPi	= 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
	SqrtPhi	= 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
	Ln2		= 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
	Log2E	= 1. / Ln2;
	Ln10	= 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
	Log10E	= 1. / Ln10;
	Nan		= 0. / 0;
	Inf		= 1. / 0;
	//~ define isNan(flt64 a) = bool(a == a);
	//~ define isNan(flt32 a) = bool(a == a);
}

flt64 PI1 = math.pi;
flt64 PI2 = M.Pi;

}
static if (Test.Type & 0x02) {

define lerp(flt64 a, flt64 b, flt64 t) = flt64(a + t * (b - a));
define lerp(flt32 a, flt32 b, flt32 t) = flt32(a + t * (b - a));
flt64 TT2_1 = lerp(0., 5., .5);

define isNan(flt64 x) = bool(x != x);
define isNan(flt32 x) = bool(x != x);
flt64 NAN = math.nan;
int isNan1 = isNan(NAN);
int isNan2 = isNan(math.nan);
}
static if (Test.Type & 0x04) {
//~ struct and arrays
struct fit32:0 {int32 i;flt32 f;}
struct fit64:0 {int64 i;flt64 f;}
define intTY int32;

struct intabc: 8 {
	intTY X;		//~!%=(%?08b)
	intTY Y;		//~!%=(%?08b)
	intTY Z;		//~!%=(%?08b)
	//~ intTY W;		//!X%?03x
	fit64 U;
}

intabc alma;
alma.U.f = 9;
alma.X = 8;
//~ alma.Z = alma.Y = alma.X = 7;

intTY c[3] = emit();
c[1] |= 1;

//~ intabc alma1 = alma;
}
static if (Test.Type & 0x08) {
struct bgra: 1 {
	uns8 b; 	//!%blue(%D)
	uns8 g; 	//!%green(%D)
	uns8 r; 	//!%red(%D)
	uns8 a; 	//!%alpha(%D)
}
//~ define argb(uns8 r, uns8 g, uns8 b) = bgra(b, g, r, 0);
//~ define argb(uns8 a, uns8 r, uns8 g, uns8 b) = bgra(b, g, r, a);

struct color: 0 {
	int32 val;	//!%rgb(#%08x)
	bgra col;	//!%
}
//~ define color(uns8 a, uns8 r, uns8 g, uns8 b) = int32(a << 24 | r << 16 | g << 8 | b);
//~ define color(uns8 r, uns8 g, uns8 b) = int32(r << 16 | g << 8 | b);

color C1 = emit(i32(0xcafebabc));
color C2 = emit(i32(0xcafebabd));
color C3 = emit(i32(0xcafebabe));
color C4 = emit(i32(0xcafebabf));

//~ int32 i = color(1, 2, 3);
//~ color Cn = color(1, 2, 3);

uns8  u08[4] = emit();
uns32 u32[4] = emit();

enum colors: color {
	none = int32(-1);
	pink = color(2,3,4);
}
}
static if (Test.Type & 0x10) {
}
} // */
/*static if (Test.Misc) {
static if (Test.Misc & 1) {
// Matrix Multiply
define WIDTH = 4;
define HEIGHT = WIDTH;
define scalar flt64;

scalar m1[HEIGHT][WIDTH];
scalar m2[HEIGHT][WIDTH];
scalar m3[HEIGHT][WIDTH];

//~ /+ Initialize
for (int i = 0; i < HEIGHT; i += 1) {
	for (int j = 0; j < WIDTH; j += 1) {
		m1[i][j] = m2[i][j] = (i == j) + 1;
	}
} // +/

//~ Compute
for (int i = 0; i < HEIGHT; i += 1) {
	for (int j = 0; j < WIDTH; j += 1) {
		m3[i][j] = 0;
		for (int k = 0; k < WIDTH; k += 1) {
			m3[i][j] += m1[i][k] * m2[k][j];
		}
	}
}

//~ /+ Print
for (int i = 0; i < HEIGHT; i += 1) {
	for (int j = 0; j < WIDTH; j += 1) {
		if (j != 0)
			putchr(' ');
		puti64(m3[i][j]);
	}
	putchr('\n');
} // +/
}
} // */
/* Type Test X
/+	function
int sum(int n) {result = 0; for (int i = 1; i < n; i += 1) result += i;}
int prd(int n) {result = 0; for (int i = 1; i < n; i += 1) result *= i;}

// +/
/+X	operators

//~ define v4f32(flt32 xyz) = emit(v4f, f32(xyz), f32(xyz), f32(xyz), f32(xyz));
//~ define v4f32(flt32 x, flt32 y, flt32 z) = emit(v4f, f32(x), f32(y), f32(z), f32(1));

// class
v4f32 operator(flt32 x, flt32 y, flt32 z, flt32 w) = emit(v4f, f32(x), f32(y), f32(z), f32(w));

// object
void operator(v4f32 &lhs) (flt32 x, flt32 y, flt32 z, flt32 w) {
	//~ usage: stupid
	//~ v4f32 a;
	//~ a(1,2,3,4);
	//~ a(1,2,9,4);
	
	lhs.x = x;
	lhs.y = y;
	lhs.z = z;
	lhs.w = w;
}

flt32 operator (v4f32 lhs) (flt32 val) {
	//~ usage:
	//~ v4f32 polyv4f = v4f32(1,2,3,4);
	//~ flt32 polyval = polyv4f(8);

	return ((((lhs.w) * val + lhs.z) * val + lhs.y) * val) + lhs.x;
}
flt32 operator (v4f32 lhs) [int32 idx] {
	if (idx == 0 || idx == 'x')
		return lhs.x;
	if (idx == 1 || idx == 'y')
		return lhs.y;
	if (idx == 2 || idx == 'z')
		return lhs.z;
	if (idx == 3 || idx == 'w')
		return lhs.w;
	return 0.0;

	//~ if (int[0, 'x'].indexOf(idx) >= 0)
		//~ return lhs.x;
}

operator (v4f32 lhs) % (v4f32 rhs) = v4f32.crs(lhs, rhs);

flt32 operator (v4f32 lhs) ^ (v4f32 rhs) {	// length
	v4f32 tmp = lhs - rhs;
	return v4f32.dp3(tmp, tmp);
}

//~ operator -(int rhs) = emit(i32.neg, rhs);
//~ operator (int lhs) + (int rhs) = emit(i32.add, i32(rhs), i32(lhs));

//~ +/
/+ Complex: X
struct Complex {
	flt64 re;
	flt64 im;
}

//~ operator -(Complex rhs) = Complex(-rhs.re, -rhs.im);
//~ operator (Complex lhs) + (Complex rhs) = Complex(lhs.re + rhs.re, lhs.im + rhs.im);
//~ operator (Complex lhs) - (Complex rhs) = Complex(lhs.re - rhs.re, lhs.im - rhs.im);
//~ operator (Complex lhs) * (Complex rhs) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);

operator -(Complex rhs) = emit(v2d.neg);
operator (Complex lhs) + (Complex rhs) = emit(v2d.add, v2d(rhs), v2d(lhs));
operator (Complex lhs) - (Complex rhs) = emit(v2d.sub, v2d(rhs), v2d(lhs));
operator (Complex a) * (Complex b) = Complex {
	re = emit(f64.sub, v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re));		// re = a.re * b.re - a.im * b.im
	im = emit(f64.add, v2d.mul, f64(b.re), f64(b.im), f64(a.im), f64(a.re));		// im = a.re * b.im + a.im * b.re
}
//~ +/
/+ ?reflect?
enum TypeCode:int8 {
	any = 0x00;		// error
	vid = 0x01;		// void;
	bit = 0x02;		// bool;
	int = 0x03;		// int64, int32, int16, int8, uns32, uns16, uns8;
	flt = 0x04;		// flt64, flt32;
	p4x = 0x05;		// (p2f64, p4f32), (p4f64, p8f32) (p2i64, p4i32, p8i16, p16i8), (p2u64, p4u32, p8u16, p16u8), ...
	arr = 0x06;		// pointer, string, array, ..., ???
	def = 0x07;		// struct, union, class, enum, 
	//~ enu
	//~ rec
	ref = 0x0f;		// variable
	//~ ATTR_ind = 0x10;		// indirect(pointer to)
}

struct TypeInfo {
	char file[];
	int32 line;

	char name[];
	int32 size;				// size / offset

	TypeInfo &base;			// base type of TYPE_ref (void, int, float, struct, ...), return type of func
	TypeInfo &args;			// record fields / function args
	TypeInfo &next;			// next type, arg, 
	TypeCode code;			// TypeCode
	//~ define indirect = ((this.code & ATTR_ind) != 0);
}

bool instanceof(TypeInfo &ty, ref obj) {
	for ( ; ty; ty = ty.base)
		if (ty == obj.type)
			return true;
	return false;
}

TypeInfo findMethod(TypeInfo &ty, string name, ref ...args) {
}

ref callMethod(string name, ref ...args) {
	result := libcall(name, args);
}

TypeInfo[] GetMethods(TypeInfo ty, string name) {
	TypeInfo result[], it;

	while (ty && ty.code != TYPE_ref) {

		for (it = ty.args; it; it = it.next) {

			if (it.code != TYPE_ref)
				continue;

			if (it.name != name)
				continue;

			if (it.call)
				result += it;
		}
		ty = ty.base;
	}

	return result;
}
TypeInfo[] GetMembers(TypeInfo ty, string name) {
	TypeInfo result[], it;

	while (ty && ty.code != TYPE_ref) {

		for (it = ty.args; it; it = it.next) {

			if (it.code != TYPE_ref)
				continue;

			if (it.name != name)
				continue;

			if (!it.call)
				result += it;
		}

		ty = ty.base;

	}

	return result;
}
TypeInfo[] GetNestedTypes(TypeInfo ty, string name) {
	TypeInfo *result[], *it;

	while (ty && ty.code != TYPE_ref) {

		for (it = ty.args; it; it = it.next) {

			if (it.code == TYPE_ref)
				continue;

			if (it.name != name)
				continue;

			if (!it.call)
				result += it;
		}
		ty = ty.base;
	}

	return result;
}
//~ define arguments(TypeInfo ty) = ty.args;

struct TypeBox {
	void* obj;
	TypeInfo* typ;
}

define BoxType(ref obj) = TypeBox(obj, obj.class);
define UnBoxType(TypeInfo obj) = TypeBox(obj, obj.class);

//~ +/
//~ */

//~ float multidimmatrix[3][3][3][3];

/+ Compare:
define ty flt64;
ty x = 5;
ty y = 5;
bool eq = x == y;
bool lt = x < y;
bool gt = x > y;

//~ bool ne = x != y;
//~ bool le = x <= y;
//~ bool ge = x >= y;
//~ +/

//~ define a = 1;
//~ define b = 2;
//~ define c = 3;

//~ flt32 a22 = emit(f32.add, f32.mul, f32(a), f32(b), f32(c));
//~ flt32 top = emit();
//~ flt32 a23 = top;

//~ double a_re = 3.;
//~ double a_im = 4.;
//~ double b_re = 2.;
//~ double b_im = 5.;
//~ flt64 re = emit(f64.sub, v2d.mul, f64(b_im), f64(b_re), f64(a_im), f64(a_re));		// re = a.re * b.re - a.im * b.im
//~ flt64 im = emit(f64.add, v2d.mul, f64(b_re), f64(b_im), f64(a_im), f64(a_re));		// im = a.re * b.im + a.im * b.re
//~ flt64 re = a_re * b_re - a_im * b_im;
//~ flt64 im = a_re * b_im + a_im * b_re;

//~ /* i22

//~ struct FontStyle {int32 value;}
//~ FontStyle xxl = FontStyle('xxl');

define color int32;
define string int32;

struct Font {
	string face;
	int style;
	alma: struct {
		int a;
		int b;
	}
	style: enum {
		normal;
		italic;
		oblique;
	}// +/
	color back;
	color fore;
	int size;
}

Font a;
a.face = 2009;
//~ a.style = Font.oblique;

/+ TODO:
Font init1 = Font(-1, 2, 3, 4, 5, 6);
Font init2 = Font{
	face = 2;
	style = Font.normal;
	back = 0x340788;
	fore = 0x340788;
	size = 9;
};
//~ +/

/+
define string int64;
struct Font {
	string face;
	style: enum {
		normal;
		italic;
		oblique;
	}
	Color back;
	Color fore;
	int size;
}

/*struct lexer {
	//~ pattern
	int colourize(int x, int &ww);
	int folddoc(int x, int &ww);
	comment: struct {
		string line;
		stream: struct {
			string start;
			string end;
		}
		box: struct {
			string start;
			string middle;
			string end;
		}
	}
	string keywords[];
	command: struct[] {
			String name;
			mode: struct {
				bool groupundo;
				bool savebefore;
				subsystem: enum {	// enum variable
					lua;
					exe;
					script;
				}
			}
			shortcut: enum: int32 {
				//~ Virtual Keys, Standard Set
				VK_LBUTTON = 1;
				VK_RBUTTON = 2;
				VK_CANCEL = 3;
				VK_MBUTTON = 4;
				//~ NOT contiguous with L & RBUTTON
				VK_BACK = 8;
				VK_TAB = 9;
				VK_CLEAR = 12;
				VK_RETURN = 13;
				VK_SHIFT = $10;
				VK_CONTROL = 17;
				VK_MENU = 18;
				VK_PAUSE = 19;
				VK_CAPITAL = 20;
				VK_ESCAPE = 27;
				VK_SPACE = $20;
				VK_PRIOR = 33;
				VK_NEXT = 34;
				VK_END = 35;
				VK_HOME = 36;
				VK_LEFT = 37;
				VK_UP = 38;
				VK_RIGHT = 39;
				VK_DOWN = 40;
				VK_SELECT = 41;
				VK_PRINT = 42;
				VK_EXECUTE = 43;
				VK_SNAPSHOT = 44;
				VK_INSERT = 45;
				VK_DELETE = 46;
				VK_HELP = 47;
				//~ VK_0 thru VK_9 are the same as ASCII '0' thru '9' ($30 - $39)
				//~ VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' ($41 - $5A)
				VK_LWIN = 91;
				VK_RWIN = 92;
				VK_APPS = 93;
				VK_NUMPAD0 = 96;
				VK_NUMPAD1 = 97;
				VK_NUMPAD2 = 98;
				VK_NUMPAD3 = 99;
				VK_NUMPAD4 = 100;
				VK_NUMPAD5 = 101;
				VK_NUMPAD6 = 102;
				VK_NUMPAD7 = 103;
				VK_NUMPAD8 = 104;
				VK_NUMPAD9 = 105;
				VK_MULTIPLY = 106;
				VK_ADD = 107;
				VK_SEPARATOR = 108;
				VK_SUBTRACT = 109;
				VK_DECIMAL = 110;
				VK_DIVIDE = 111;
				VK_F1 = 112;
				VK_F2 = 113;
				VK_F3 = 114;
				VK_F4 = 115;
				VK_F5 = 116;
				VK_F6 = 117;
				VK_F7 = 118;
				VK_F8 = 119;
				VK_F9 = 120;
				VK_F10 = 121;
				VK_F11 = 122;
				VK_F12 = 123;
				VK_F13 = 124;
				VK_F14 = 125;
				VK_F15 = 126;
				VK_F16 = 127;
				VK_F17 = 128;
				VK_F18 = 129;
				VK_F19 = 130;
				VK_F20 = 131;
				VK_F21 = 132;
				VK_F22 = 133;
				VK_F23 = 134;
				VK_F24 = 135;
				VK_NUMLOCK = 144;
				VK_SCROLL = 145;
				//~ VK_L & VK_R - left and right Alt, Ctrl and Shift virtual keys.
				//~ Used only as parameters to GetAsyncKeyState() and GetKeyState().
				//~ No other API or message will distinguish left and right keys in this way.
				VK_LSHIFT = 160;
				VK_RSHIFT = 161;
				VK_LCONTROL = 162;
				VK_RCONTROL = 163;
				VK_LMENU = 164;
				VK_RMENU = 165;
				VK_PROCESSKEY = 229;
				VK_ATTN = 246;
				VK_CRSEL = 247;
				VK_EXSEL = 248;
				VK_EREOF = 249;
				VK_PLAY = 250;
				VK_ZOOM = 251;
				VK_NONAME = 252;
				VK_PA1 = 253;
				VK_OEM_CLEAR = 254;
			}
			string command;
		}
}

this.font = {
	//~ style = font.style.normal;
	face = "verdana";
	size = 12;
}

this.lexer = {
	patter = "*.d";
	commands = {
		command("Compile", "dostring os.Exec("make -" + filename)", Ctrl + F7),
		command("Execute", "$(filename)", F5),
		command("Build", "make -all", F7),
		command("Debug", "gdb" + filename, F5),
		command("Fold", "dostring FoldLines()", Ctrl + Shift + KeypadDivide),
	}
}
// +/
//~ */

/* factorial
define n = 5;
int64 res = 1;
for (int i = 1; i <= n; i += 1)
	res *= i;

// */
/* calc E
define eps = 1e-100;
double res = 1;
double tmp = 1;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* test scope:
for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i2 = 9;		// ERR: i2 unexpected

static if (0) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(0)

//~ int arr[] = int{1,2,3,4,5,6,7,8};
//~ */
/* test if-else:
int i = 3;
float a = 4;
if (i) {
	a = 0;
	if (i == 1) a = 1.1; else a = 2.1;
	if (i == 1) a = 1.2; else ;
	if (i == 1) ;else a = 2.2;
	if (i == 1) a = 3;

	else if (i == 2) a = 1.42;
	else if (i == 3) a = 1.43;
	else if (i == 4) a = 1.44;
	else if (i == 5) a = 1.45;
	else if (i == 6) a = 1.46;
}
else {
	if (a <= 5) {
		if (a < 2.5) i = 1;
		else i = 2;
	}
	else {
		if (a < 7.5) i = 3;
		else i = 4;
	}
}

// */
/* stupid things
/+ swap typedefs
define float flt64;
define double flt32;
double res = .35;
//~ +/
/+ do nothing
if (1)
	{{{{{;;;};}};;;}{;;;}}
else
	{{;};;{;}}
//~ +/
//~ */

/*+-
struct vec4f {
	flt32 x;
	flt32 y;
	flt32 z;
	flt32 w;
}

static if (useEmit) {
	operator + (vec4f rhs) = emit(vec4f, rhs);
	operator - (vec4f rhs) = vec4f(emit(v4f.neg, rhs));
	operator ~ (vec4f rhs) = vec4f(emit(v4f.rcp, rhs));
	operator (vec4f lhs) + (vec4f rhs) = vec4f(emit(v4f.add, lhs, rhs));

	define dp3(vec4f lhs, vec4f rhs) = flt32(emit(v4f.dp3, lhs, rhs));
	define dp4(vec4f lhs, vec4f rhs) = flt32(emit(v4f.dp4, lhs, rhs));
	define dph(vec4f lhs, vec4f rhs) = flt32(emit(v4f.dph, lhs, rhs));
}
else {
	operator + (vec4f rhs) = vec4f(+rhs.x, +rhs.y, +rhs.z, +rhs.w);
	operator - (vec4f rhs) = vec4f(-rhs.x, -rhs.y, -rhs.z, -rhs.w);
	operator ~ (vec4f rhs) = vec4f(1. / rhs.x, 1. / rhs.y, 1. / rhs.z, 1. / rhs.w);
	operator (vec4f lhs) + (vec4f rhs) = vec4f(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w);

	define dp4(vec4f lhs, vec4f rhs) = flt32(lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z + lhs.w * rhs.w);
	define dph(vec4f lhs, vec4f rhs) = flt32(lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z + lhs.w);
	define dp3(vec4f lhs, vec4f rhs) = flt32(lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z);
}

operator vec4f(flt32 x, flt32 y, flt32 z) = vec4f(x, y, z, 1);
operator vec4f(flt32 x) = vec4f(x, x, x, x);

operator flt32(vec4f vec) = vec.w;
operator bool(vec4f vec) = bool(vec.x && vec.y && vec.z && vec.w);


flt32 index(v4f32 vec, int32 idx) {
	if (idx == 0 || idx == 'x')
		return lhs.x;
	if (idx == 1 || idx == 'y')
		return lhs.y;
	if (idx == 2 || idx == 'z')
		return lhs.z;
	if (idx == 3 || idx == 'w')
		return lhs.w;
	return 0.0;
}

define peval(vec4f vec, flt32 val) = flt32((((vec.w * val + vec.z) * val + vec.y) * val) + vec.x);

define len(vec4f lhs) = sqrt(dp3(lhs, lhs));

operator (ref vec4f lhs) += (vec4f rhs) = (lhs = lhs + rhs);

// operator() d:"opCall"; cpp: "flt32 vec4f::operator () (flt32 val) {...}"
operator (vec4f vec) (flt32 val) = peval(vec, val);

// operator() d:"opIndex"; cpp: "flt32 vec4f::operator [] (int32 val) {...}"
operator (vec4f vec) [int32 idx] = index(vec, val);

struct Complex {
	flt64 re;
	flt64 im;
}
operator Complex(flt64 re, flt64 im) = emit(v2d, f64(re), f64(im));

operator -(Complex rhs) = Complex(-rhs.re, -rhs.im);
operator (Complex lhs) + (Complex rhs) = Complex(lhs.re + rhs.re, lhs.im + rhs.im);
operator (Complex lhs) - (Complex rhs) = Complex(lhs.re - rhs.re, lhs.im - rhs.im);

operator -(Complex rhs) = emit(v2d.neg);
operator (Complex lhs) + (Complex rhs) = emit(v2d.add, p4x(rhs), p4x(lhs));
operator (Complex lhs) - (Complex rhs) = emit(v2d.sub, p4x(rhs), p4x(lhs));

operator (Complex b) [int a] = double(a ? b.im : b.re);

operator sub(Complex lhs, Complex rhs) = emit(f64x2.sub, v2d(rhs), v2d(lhs));

Complex operator (Complex a) * (Complex b) {
	emit(v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re));		// a.re * b.re, a.im * b.im
	flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
	emit(v2d.mul, f64(b.re), f64(b.im), f64(a.im), f64(a.re));		// a.re * b.im, a.im * b.re
	flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
	return Complex(re, im);
}

// */
