//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

/* alloc / realloc / free
pointer p1;
pointer p2;
pointer p3;
pointer p4;
realloc(null, 0);
p1 = realloc(null, 160);
p2 = realloc(null, 160);
p3 = realloc(null, 160);
realloc(null, 0);

if (true) {
	p3 = realloc(p3, 0);
	p2 = realloc(p2, 0);
	p1 = realloc(p1, 0);
}
else {
	p1 = realloc(p1, 0);
	p2 = realloc(p2, 0);
	p3 = realloc(p3, 0);
}

//~ realloc(null, 100);
//~ realloc(null, 200);
//~ realloc(null, 300);

//~ realloc(null, 0);
//~ */

//~ ./main -C -i./lbit.dll -O2 -xd test.cvx
//~ int i = bitops.btc(0x1ff);
/*void func1() {

	const inertial_pan = 50;
	void func1() {
		if (inertial_pan) {
		}
	}
}// */

/* random floats
float32 frand() {
	uint32 randnum = rand() * rand();
	float32 tmp = emit(float32, i32((randnum >> 9 ) | 0x3f800000));
	result = tmp - 1;
}

float64 drand() {
	uint32 randnum1 = rand() * rand();
	uint32 randnum2 = rand() * rand();
	float64 tmp = emit(float64, i32(randnum1), i32((randnum2 >> 12) | 0x3ff00000));
	result = tmp - 1;
}

float maxrand = -1;
for(int i = 0; i < 30; i += 1) {
	float64 currand = drand();

	if (maxrand < currand)
		maxrand = currand;

	print("%f\n", currand);
}

// */

/*static struct m {
	int a = 9;
	int b = 6;
	int c = 8;
}

m m1;

int x = m.a;

// */

/* arrays

// 1. int maximum(int arr[12])
// 2. int maximum(int arr[])
// 3. int maximum(int arr...)

int arr2[2] = 1, 2;
int arr3[2, 2] = 1, 2, 3, 4;
//~ int arr3[] = arr2;
//~ /+

int maximum(int arr[]) {
	result = arr[0];
	for (int i = 1; i < arr.length; i += 1) {
		if (result < arr[i]) {
			result = arr[i];
		}
	}
}

void sort(int arr[]) {
	for (int i = 0; i < arr.length - 1; i += 1) {
		for (int j = i + 1; j < arr.length; j += 1) {
			if (arr[i] > arr[j]) {
				int tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
			}
		}
	}
}

int bsearch(int arr[], int elem) {
	int lo = 0;
	int hi = arr.length;

	result = -1;
	for (;lo < hi;) {
		int mid = lo + ((hi - lo) / 2);
		int val = arr[mid];

		if (val < elem) {
			lo = mid + 1;
		}
		else if (val > elem) {
			hi = mid;
		}
		else {
			result = mid;
			//~ return;
			lo = hi;
		}
	}
}

void randomize(int arr[]) {
	for (int i = 0; i < arr.length; i += 1) {
		arr[i] = rand() % 30;
	}
}

//~ define hex32 int32;		// %hex32(0x%08x)

randomize(arr2);
int max = maximum(arr2);
int toFind = arr2[arr2.length / 2];
sort(arr2);
int index = bsearch(arr2, toFind);
// +/

//~ int arr2[] = null;
//~ int arr2[] = emit(val, ref(realloc(null, 4 * 300)), i32(300));//[3][3];
//~ define newArray(int ty, int ^n) = emit(val, ref(realloc(null, ty * n)), i32(n));
//~ int arr0[2] = 2, 3;
//~ int arr9[] = newArray(4, 300);
//~ int arr2[] = emit(val, ref(null), i32(0));
//~ int arr3[] = emit(val, ref(arr0), i32(arr0.length));

//~ int n = 400;

//~ int arr4[] = emit(val, ref(memmgr(null, 4 * n)), i32(n));
//~ int arr5[n];
//~ */

/* strings
//~ string s = "alma a fa alatt";		// this should be dynamic.
//~ uint8 ss[4];
//~ int a = ss.length;
string x = "almax a fa alatt";
//~ string ss[3];
//~ ss[0] = x;//"alma1 a fa alatt";
//~ ss[1] = "alma2 a fa alatt";
//~ ss[2] = "alma3 a fa alatt";
//~ string y = ss[1];

int iii[3] = 1, 2, 3;
string sss[3] = x, "a2", "a3";

//~ ss[0][3] = 'A';

//~ println(y);
//~ println(ss[2]);

//~ string c = ss[0];
//~ putstr(c);

//~ int a = 9;
//~ int &b = null;
//~ &b = a;

//~ b = 88;
// */

/* static and nonstatic members.
struct alma {
	static int a0 = 9;
	int a1;
	int a2;
	int a3;
}

alma a;// = alma(12, 13, 14);
alma.a0 = 99;
//~ a = alma(a.a1, 0);
int alma_a0 = alma.a0;

a.a0 = 98;		// error: member accessed through an instance reference
alma.a1 = 99;		// error: undefined 
//~ alma &a2 = null;
//~ int offsa2 = emit(int, ref(a2.a2));
//~ int offsa2 = emit(int, ref(alma(null).a2));
// */

/* xrgb
struct:1 xrgb {
	uint8 b;
	uint8 g;
	uint8 r;
	uint8 x;
}
struct:0 xrgbi32 {
	xrgb rgb;
	int32 val;
}
//~ xrgb res = result;
//~ define min(int ^a, int ^b) = (a < b ? a : b);
//~ define clamp(int t, int a, int b) = min(max(t, a), b);

xrgb a = emit(xrgb, i32(0x801f008f));

//~ int structSize = xrgb.class.size;
//~ int objectSize = a.class.size;
//~ xrgb b = emit(a.typeOf, i32(0x1f002f));

//~ xrgb b = emit(xrgb, i32(0x2f3f1f));
//~ int r = a.r + b.r;

//~ xrgbi32 r;
//~ r.val = 0;

//~ r.rgb.r = min(a.r + b.r, 255);
//~ r.rgb.g = min(a.g + b.g, 255);
//~ r.rgb.b = min(a.b + b.b, 255);
// */

/* get 0 < n <= 64 bit minimum / maximum (signed/unsigned) values
define hex64 int64;//%%016X
void bitsget(bool signed, int size, int64 &min, int64 &max) {
	int64 mask = int64.Shr(int64(-1), -size);
	min = int64.Shl(-int64(signed), size - 1);
	max = int64.And(min - 1, mask);
}

hex64 min;
hex64 max;
hex64 umin;
hex64 umax;

int bitsize = 50;

bitsget(true, bitsize, &min, &max);
bitsget(!true, bitsize, &umin, &umax);
// */

/* invoke functions ...
int method0() {}
int method1(int x) {
	//~ print("!alma a fa alatt nyÃ¡ri piros alma\n");
	static int i = 0;
	result = i += x;
	print("%D\n", int64(result));
}
int method1() {result = method1(1);}
int method2() {result = method1(2);}

void methodCall(int method()) {
	if (method == null) {
		print("(null)\n");
		return;
	}
	//~ print("(xxxx)\n");
	int n = method();
	//~ print("%D\n", int64(n));
}

//~ /+	just call it
static if (true) {
	method1();
	method2();
}// +/

//~ /+	call passed to another fun
//~ methodCall(method1);	// this will not work because there are 2 method1 named functions
methodCall(null);
methodCall(method2);
//~ +/

//~ /+	call as a reference
int method() = null;//method2;

//~ method = null;

if (method != null) {
	method();
}

methodCall(method);

// +/

//~ */
/* return function ...

/+ count down
struct Closure {int call(Closure &data); int data;}
define Invoke(Closure &wcd) = wcd.call(wcd);
//~ operator (Closure &wdc)() = wcd.call(wcd);

int countdown(Closure &a) {result = a.data; a.data -= 1;}

Closure a = Closure(countdown, 3);
Closure b = Closure(countdown, 30);

println(Invoke(a));
println(Invoke(b));
println(Invoke(a));
println(Invoke(a));
println(Invoke(a));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
// +/

//~ /+ count down (2) with args
struct Closure {int64 call(Closure &c, int64 n); int64 data; int32 calls; /+...+/ }
define Closure(int64 call(Closure &c, int64 n), int64 data) = Closure(call, data, 0);

define Invoke(Closure &c, int64 n) = c.call(&c, n);
//~ operator (Closure &c)(int64 n) = c.call(c, n);

int64 countdown(Closure &c, int64 n) {result = c.data; c.data -= n; c.calls += 1; }

Closure a = Closure(countdown, 90);

print("%d\n", int64(Invoke(a, 9)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));

/+todo:
	function a = function{data: int64(90), calls: int(0)} int(int64 n) {
		result = c.data;
		c.data -= n;
		c.calls += 1;
	};

	println(Invoke(a, 9));
	println(Invoke(a, 2));
	println(Invoke(a, 2));
	println(Invoke(a, 2));


//~ sort_function(int array[0, 3, 4, 2, 5, 1], int function(int a, int b){return a.compareTo(b);})
//~ sort_delegate(int array[0, 3, 4, 2, 5, 1], int delegate{int xxx}(int a, int b){return a == b ? 0 : a > b ? 1 : -1;});

// +/

//~ */
/* assignment by reference

int64 a = 32;
a = 33;
void setup() {
	static int64 &b = a;
	print("%d\n", int64(b));
}
setup();

//~ */

/+ hex view: use: ./ccvm -c -x -O-2 test.cvx

int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
const n = 6;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
const eps = 1e-50;
double tmp = 1.;
double res = 1.;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* scope test:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (!true) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(false)

//~ */

/* iterating

/+
struct array_iterator {
	int arr[];
	int pos;
	int max;	// arr.length
}
array_iterator iterator(int a[]) {
	result.pos = 0;
	result.arr = a;
	result.max = a.length;
}
bool next(array_iterator &it, int &val) {
	if (result = it.pos < it.max) {
		val = it.arr[it.pos];
		it.pos += 1;
	}
}// +/

/+
define iterator(file &f) = emit(file, ref(f));
bool next(file &it, int &chr) {
	chr = fgetc(it);
	result = chr != -1;
}// +/

struct range {
	int min;
	int max;
	bool exclusive;
}

struct range_iterator {
	int pos;
	int max;
	bool exclusive;
}

define iterator(range ^r) = range_iterator(r.min, r.max, r.exclusive);	// start at min, and end at max

void println(range_iterator ri) {
	print("iterator {");
	print("pos: "); print(ri.pos);
	print(", max: "); print(ri.max);
	print(", excl: "); print(ri.exclusive);
	print("}\n");
}

bool next(range_iterator &it, int &val) {
	if (result = it.pos - it.exclusive < it.max) {
		val = it.pos;
		it.pos += 1;
	}
}
bool next(range_iterator &it, range_iterator &val) {
	if (result = it.pos - it.exclusive < it.max) {
		val = it;
		it.pos += 1;
	}
}

for (range_iterator a : range(10, 14, true)) {
	println(a);
}

//~ */

//~ const val = 0./0;
//~ print("0b%064B\n", emit(int64, f64(val)));
//~ print("0x%016X\n", emit(int64, f64(val)));
//~ double f64_nan = emit(float64, i64(0b0111111111111000000000000000000000000000000000000000000000000000));
//~ double f64_inf = emit(float64, i64(0b0111111111110000000000000000000000000000000000000000000000000000));
//~ double f64_one = emit(float64, i64(0b0011111111110000000000000000000000000000000000000000000000000000));

/+
int O(int a) {
	print("%d\n", int64(a));
	result = a;
}

int A = 31;
int b() {
	static int B = O(A);
	int c() {
		static int C = O(A);
		result = C;
	}
	result = c();
}
A = 33;
int d = b();
int e = b();

// +/

/* global variables cgen order
struct alma {
	static int a1;
	static int a2;
	const int a3;
}
static bool a;
static bool b() {

	//~ static alma dd;
	static bool c;
	static bool d() {
		if (1) {
			static bool e;
			static bool f;
		}
	}
	//~ static bool g;
	static bool h() {
		static bool i;
		static bool j;
	}
}
static bool k;
static bool l;
//~ */
/*
struct individual {
	bool gene[2][10];
	double xreal[2];
	double objectives[2];
	double constraints[2];

	const int rank;
	double constr_violation;
	const double xbin[10];
	//~ double crowd_dist;
}

struct population {
	double min;
	double max;
	individual ind[3];
}
/+
int fitness(individual &ind) {
	ind.objectives[0]= -pi1M(xbin[0],xbin[1]);
	ind.objectives[1]= -pi2M(xbin[0],xbin[1]); 

}

// +/

population pop;

//~ */

//~ /*
static struct Perlin {		// perlin noise
	const B = 0x100;
	const BM = 0xff;
	const N = 0x1000;
	const NP = 12;   // 2^N
	const NM = 0xfff;

	int p[B + B + 2];
	float g3[B + B + 2, 3];
	float g2[B + B + 2, 2];
	float g1[B + B + 2];

	bool start = true;

	void init(void) {
		int i;
		define sqr(float ^x) = float(x * x);
		for (i = 0 ; i < B ; i+=1) {
			p[i] = i;

			g1[i] = float((rand() % (B + B)) - B) / B;

			for (int j = 0 ; j < 2 ; j+=1)
				g2[i][j] = float((rand() % (B + B)) - B) / B;

			//~ normalize2(g2[i]);
			float n2 = sqrt(sqr(g2[i][0]) + sqr(g2[i][1]));
			if (n2 != 0) {
				g2[i][0] /= n2;
				g2[i][1] /= n2;
			}

			for (int j = 0 ; j < 3 ; j+=1)
				g3[i][j] = float((rand() % (B + B)) - B) / B;

			//~ normalize3(g3[i]);
			float n3 = sqrt(sqr(g3[i][0]) + sqr(g3[i][1]) + sqr(g3[i][1]));
			if (n3 != 0) {
				g3[i][0] /= n3;
				g3[i][1] /= n3;
				g3[i][2] /= n3;
			}
		}

		for (;i -= 1;) {
			int k = p[i];
			int j = rand() % B;
			p[i] = p[j];
			p[j] = k;
		}

		for (i = 0 ; i < B + 2 ; i+=1) {
			p[B + i] = p[i];
			g1[B + i] = g1[i];
			for (int j = 0 ; j < 2 ; j+=1)
				g2[B + i][j] = g2[i][j];
			for (int j = 0 ; j < 3 ; j+=1)
				g3[B + i][j] = g3[i][j];
		}
	}

	void setup(float vec_i, int &b0, int &b1, float &r0,float &r1) {
		float t = vec_i + N;
		b0 = int(t) & BM;
		b1 = (b0+1) & BM;
		r0 = t - int(t);
		r1 = r0 - 1.;
	}

	define s_curve(double t) = smooth(t);
	//~ define s_curve(double ^t) = double( t * t * (3. - 2. * t) );

	float Noise(float x) {
		int bx0;
		int bx1;
		float rx0;
		float rx1;
		float sx;
		float u;
		float v;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);

		sx = s_curve(rx0);

		u = rx0 * g1[ p[ bx0 ] ];
		v = rx1 * g1[ p[ bx1 ] ];

		result = lerp(sx, u, v);
	}
	float Noise(float x, float y) {
		int bx0;
		int bx1;
		int by0;
		int by1;
		float rx0;
		float rx1;
		float ry0;
		float ry1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);
		setup(y, &by0, &by1, &ry0, &ry1);

		int i = p[ bx0 ];
		int j = p[ bx1 ];

		int b00 = p[ i + by0 ];
		int b10 = p[ j + by0 ];
		int b01 = p[ i + by1 ];
		int b11 = p[ j + by1 ];

		float sx = s_curve(rx0);
		float sy = s_curve(ry0);

		define at2(float rx, float ry, int i) = float( rx * g2[i][0] + ry * g2[i][1] );

		float a = lerp(sx, at2(rx0,ry0, b00), at2(rx1,ry0, b10));
		float b = lerp(sx, at2(rx0,ry1, b01), at2(rx1,ry1, b11));

		result = lerp(sy, a, b);
	}
	float Noise(float x, float y, float z) {

		int bx0;
		int bx1;
		int by0;
		int by1;
		int bz0;
		int bz1;
		float rx0;
		float rx1;
		float ry0;
		float ry1;
		float rz0;
		float rz1;

		if (start) {
			start = false;
			init();
		}

		setup(x, &bx0, &bx1, &rx0, &rx1);
		setup(y, &by0, &by1, &ry0, &ry1);
		setup(z, &bz0, &bz1, &rz0, &rz1);

		int i = p[ bx0 ];
		int j = p[ bx1 ];

		int b00 = p[ i + by0 ];
		int b10 = p[ j + by0 ];
		int b01 = p[ i + by1 ];
		int b11 = p[ j + by1 ];

		float sx = s_curve(rx0);
		float sy = s_curve(ry0);
		float sz = s_curve(rz0);

		define at3(float rx, float ry, float rz, int i) = float( rx * g3[i][0] + ry * g3[i][1] + rz * g3[i][2] );

		float a;
		float b;
		float c;
		float d;
		float u;
		float v;

		u = at3(rx0,ry0,rz0, b00 + bz0);
		v = at3(rx1,ry0,rz0, b10 + bz0);
		a = lerp(sx, u, v);

		u = at3(rx0,ry1,rz0, b01 + bz0);
		v = at3(rx1,ry1,rz0, b11 + bz0);
		b = lerp(sx, u, v);

		c = lerp(sy, a, b);

		u = at3(rx0,ry0,rz1, b00 + bz1);
		v = at3(rx1,ry0,rz1, b10 + bz1);
		a = lerp(sx, u, v);

		u = at3(rx0,ry1,rz1, b01 + bz1);
		v = at3(rx1,ry1,rz1, b11 + bz1);
		b = lerp(sx, u, v);

		d = lerp(sy, a, b);

		result = lerp(sz, c, d);
	}
}

//~ Perlin p;
//~ float n1 = Perlin.Noise(.3, .9);
//~ */
