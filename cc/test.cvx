//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

//~ module test;

//~ int alma(int h)[10];



/* Bits
//~ define zxt64(int32 a) = int64(uint32(a));			// zero extend
//~ define sxt64(int32 a) = int64(int32(a));			// sign extend
//~ define Lo64(int64 a) = emit(int32, set, i64(a));	// Lo32 part
//~ define Hi64(int64 a) = emit(int32, pop, i64(a));	// Hi32 part

//~ hex64 val = 0xff00ff00ff0f0f0f9;
//~ hex32 lo = Lo64(val);
//~ hex32 hi = Hi64(val);
// */

/* fixed point math
define fixed int32;
define __fix = 16;

define fixed_fix(int64 &val, int &__fix) = fixed(bits.shr(val + (bits.shr(val, __fix) + 1), __fix));
define add(fixed lhs, fixed rhs, int __fix) = fixed(lhs + rhs);
define sub(fixed lhs, fixed rhs, int __fix) = fixed(lhs - rhs);
define mul(fixed lhs, fixed rhs, int __fix) = fixed_fix(int64(lhs) * rhs, __fix);

define fixed(int32 val, int __fix) = fixed(val << __fix);
define fixed(float32 val, int __fix) = fixed(val * (1 << __fix));
define fixed(float64 val, int __fix) = fixed(val * (1 << __fix));

define int(fixed val, int __fix) = int(val >> __fix);
define double(fixed val, int __fix) = double(val / double(1 << __fix));

define fixed_fix(int64 val) = fixed_fix(val, __fix);
define add(fixed lhs, fixed rhs) = add(lhs, rhs, __fix);
define sub(fixed lhs, fixed rhs) = sub(lhs, rhs, __fix);
define mul(fixed lhs, fixed rhs) = mul(lhs, rhs, __fix);

define fixed(int val)   = fixed(val, __fix);
define fixed(float32 val) = fixed(val, __fix);
define fixed(float64 val) = fixed(val, __fix);

define int(fixed val) = int(val, __fix);
define double(fixed val) = double(val, __fix);

double fixed_test = double(add(fixed(2.5), fixed(3)));
//~ println(fixed_test);
// */

/* clamp, lerp, smooth
//~ define e1 = double(2);
//~ define e1 = float(2);
float e1 = 0;
float e2 = 6;
float s = (e2 - e1) / 100;
for (float x = e1; x < e2; x += s) {	// x in [e1, e2]
	float t = (x - e1) / (e2 - e1);		// t in [0., 1.]
	//~ println(lerp(t, e1, e2));
	println(smooth(x, e1, e2));
	//~ println(clamp(t, .2, .6));
}
// */

//~ vec4f a = vec4f(1., 2., 3., 5.);
//~ vec4f b = vec4f(0., 2., 0., 5.);
//~ vec4f e = cross(a, b);
//~ vec4f E = normalize(cross(vec4f(1., 2., 3.), vec4f(10., 20., 3.)));

define __eps = 1e-15;
define eq(float32 &a, float32 &b, float32 eps) = bool(abs(a - b) < eps);
define eq(float64 &a, float64 &b, float64 eps) = bool(abs(a - b) < eps);

define eq(float32 &a, float32 &b) = eq(a, b, float32(__eps));
define eq(float64 &a, float64 &b) = eq(a, b, __eps);

double a = 0.1;
double b = 0.2;
double c = 0.3;
bool x = (a + b) + c == a + (b + c);
bool x1 = eq((a + b) + c, a + (b + c), 1e-15);

// */

/* random numbers
for (int i = 0; i < 60; i += 1) {
	println(random(2.));
	//~ println((1 + i) * 2);
}
// */

//~ emit(void, call, i32(0x));		// stack overflow

/* function
int sum(int a, int b) {
	result = a + b;
}// */

/* fogyasztas
define fogyasztas(double _km, double _benzin, double _atlag) = double(_benzin * _km * _atlag / 100.);

double km = 4. * 5 * 16;
double atlag = 9.0;
double benzin = 4.90;
double fogyasztas = fogyasztas(km, benzin, atlag);
// */

/+ big integer math
static if (1) {
struct i32x8 {
	int32 i8;	//%%08x
	int32 i7;	//%%08x
	int32 i6;	//%%08x
	int32 i5;	//%%08x
	int32 i4;	//%%08x
	int32 i3;	//%%08x
	int32 i2;	//%%08x
	int32 i1;	//%%08x
} // */

define i32x8(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8) = emit(i32x8, i32(i1), i32(i2), i32(i3), i32(i4), i32(i5), i32(i6), i32(i7), i32(i8));
define i32x8(int32 i0) = emit(i32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32.shr, i32(31), dupp.x1, i32(i0));
define i32x8(uint32 i0) = emit(i32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32(0), i32(i0));

//~ i32x8 a = i32x8(0x0f1f2f3f, 0x4f5f6f7f, 0x8f9fffff, 0xffffffff, 0x0efffffff, 0xffffffff, 0xffffffff, 0xffffffff);
//~ i32x8 b = i32x8(0x0fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);

i32x8 a = i32x8(int32(0x0fffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff));
i32x8 b = i32x8(1);

//~ i32x8 a = i32x8(0);
//~ i32x8 b = i32x8(15);

i32x8 c;

/*TODO: no functions
i32x8 add(i32x8 a, i32x8 b) {
	//~ i32x8 c;
	hex64 ovf = 0xffffffff;
	hex64 sum;
	int64 carry = 0;
	c.i1 = int32(sum = zxt64(a.i1) + b.i1 + carry);
	carry = sum > ovf;
	c.i2 = int32(sum = zxt64(a.i2) + b.i2 + carry);
	carry = sum > ovf;
	c.i3 = int32(sum = zxt64(a.i3) + b.i3 + carry);
	carry = sum > ovf;
	c.i4 = int32(sum = zxt64(a.i4) + b.i4 + carry);
	carry = sum > ovf;
	c.i5 = int32(sum = zxt64(a.i5) + b.i5 + carry);
	carry = sum > ovf;
	c.i6 = int32(sum = zxt64(a.i6) + b.i6 + carry);
	carry = sum > ovf;
	c.i7 = int32(sum = zxt64(a.i7) + b.i7 + carry);
	carry = sum > ovf;
	c.i8 = int32(sum = zxt64(a.i8) + b.i8 + carry);
	//~ carry = sum > ovf;
}

i32x8 add(i32x8 a, int32 b) {}

i32x8 cmt(i32x8 b) {
	result.i1 = ~b.i1;
	result.i2 = ~b.i2;
	result.i3 = ~b.i3;
	result.i4 = ~b.i4;
	result.i5 = ~b.i5;
	result.i6 = ~b.i6;
	result.i7 = ~b.i7;
	result.i8 = ~b.i8;
}
i32x8 neg(i32x8 b) {}

i32x8 add(i32x8 a, i32x8 b, int32 &c = null);
i32x8 add(i32x8 a, int32 b, int32 &c = null);
i32x8 sub(i32x8 a, i32x8 b, int32 &c = null);
i32x8 sub(i32x8 a, int32 b, int32 &c = null);
i32x8 mul(i32x8 a, i32x8 b, i32x8 &hi = null);
i32x8 mul(i32x8 a, int32 b, i32x8 &hi = null);
i32x8 div(i32x8 a, i32x8 b, i32x8 &rem = null);
i32x8 div(i32x8 a, int32 b, i32x8 &rem = null);
i32x8 mod(i32x8 a, i32x8 b) {div(a, b, result);}
i32x8 mod(i32x8 a, int32 b) {div(a, b, result);}

i32x8 sub(i32x8 a, i32x8 b) {}

// */
//~ /*

static if (!true) {		// add
	hex64 ovf = 0xffffffff;
	hex64 sum;
	int64 carry = 0;
	c.i1 = int32(sum = zxt64(a.i1) + b.i1 + carry);
	carry = sum > ovf;
	c.i2 = int32(sum = zxt64(a.i2) + b.i2 + carry);
	carry = sum > ovf;
	c.i3 = int32(sum = zxt64(a.i3) + b.i3 + carry);
	carry = sum > ovf;
	c.i4 = int32(sum = zxt64(a.i4) + b.i4 + carry);
	carry = sum > ovf;
	c.i5 = int32(sum = zxt64(a.i5) + b.i5 + carry);
	carry = sum > ovf;
	c.i6 = int32(sum = zxt64(a.i6) + b.i6 + carry);
	carry = sum > ovf;
	c.i7 = int32(sum = zxt64(a.i7) + b.i7 + carry);
	carry = sum > ovf;
	c.i8 = int32(sum = zxt64(a.i8) + b.i8 + carry);
	//~ carry = sum > ovf;
} // */
static if (!true) {		// sub
	hex64 ovf = 0;//xffffffff;
	hex64 sum;
	int64 borrow = 0;
	c.i1 = int32(sum = zxt64(a.i1) - b.i1 - borrow);
	borrow = sum < ovf;
	c.i2 = int32(sum = zxt64(a.i2) - b.i2 - borrow);
	borrow = sum < ovf;
	c.i3 = int32(sum = zxt64(a.i3) - b.i3 - borrow);
	borrow = sum < ovf;
	c.i4 = int32(sum = zxt64(a.i4) - b.i4 - borrow);
	borrow = sum < ovf;
	c.i5 = int32(sum = zxt64(a.i5) - b.i5 - borrow);
	borrow = sum < ovf;
	c.i6 = int32(sum = zxt64(a.i6) - b.i6 - borrow);
	borrow = sum < ovf;
	c.i7 = int32(sum = zxt64(a.i7) - b.i7 - borrow);
	borrow = sum < ovf;
	c.i8 = int32(sum = zxt64(a.i8) - b.i8 - borrow);
	//~ borrow = sum < ovf;
} // */
} // +/

/* using emit; and emit();
//~ string alma = "alma a fa alatt";
//~ println(1 + 4);

float32 t1 = 3.14;
hex32 t2 = emit();
int32 t3 = emit;
//~ println(t3);

t3 = 90;
//~ println(t3);
// */

/* using strings

long cikkId = 165;
long raktar = 3;
long btetelId = 6398;
double mennyiseg = 1;

define strlen = 25;

int8 val[strlen + 1];
val[strlen] = 0;

string str = string(val);

println("INSERT INTO gyariszam(cikk_id, mennyiseg, b_tetel_id, raktar_id, gyariszam) VALUES");
for (int i = 0; i < 40; i += 1) {

	for (int j = 0; j < strlen; j += 1)
		val[j] = random('a', 'z');

	print("("); print(cikkId);
	print(", "); print(mennyiseg);
	print(", "); print(btetelId);
	print(", "); print(raktar);
	print(", '"); print(str);
	println("'),");
}
// */

/+ hex view
int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
define n = 7;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
double res = 1.;
double tmp = 1.;
define eps = 1e-200;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* test scope:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (1) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(0)

//~ */
