//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

static if (true) {	// sdt.lib
define print(int32 arg) = puti64(int64(arg));
define print(flt32 arg) = putf64(flt64(arg));
define print(int64 arg) = puti64(int64(arg));
define print(flt64 arg) = putf64(flt64(arg));

define vec4f(int32 x, int32 y, int32 z, int32 w) = emit(vec4f, f32(x), f32(y), f32(z), f32(w));
define vec4f(flt32 x, flt32 y, flt32 z, flt32 w) = emit(vec4f, f32(x), f32(y), f32(z), f32(w));
define vec4f(flt64 x, flt64 y, flt64 z, flt64 w) = emit(vec4f, f32(x), f32(y), f32(z), f32(w));
//~ define vec4f(int32 x, int32 y, int32 z) = emit(vec4f, f32(x), f32(y), f32(z), f32(0));
//~ define vec4f(flt32 x, flt32 y, flt32 z) = emit(vec4f, f32(x), f32(y), f32(z), f32(0));
define vec4f(flt64 x, flt64 y, flt64 z) = emit(vec4f, f32(x), f32(y), f32(z), f32(0));
//~ define vec4f(int32 val) = emit(vec4f, dupp_x2, dupp_x1, f32(val));
//~ define vec4f(flt32 val) = emit(vec4f, dupp_x2, dupp_x1, f32(val));
define vec4f(flt64 val) = emit(vec4f, dupp_x2, dupp_x1, f32(val));

//~ define dp3(vec4f lhs, vec4f rhs) = emit(v4f.dp3, v4f(lhs), v4f(rhs));
//~ define dp4(vec4f lhs, vec4f rhs) = emit(v4f.dp4, v4f(lhs), v4f(rhs));
//~ define dph(vec4f lhs, vec4f rhs) = emit(v4f.dph, v4f(lhs), v4f(rhs));

}// */

//~ int a = int(9);
//~ vec4f a = vec4f(1., 2., 3., .0);
//~ vec4f b = vec4f(5.8 / 9);
/*
//~ flt32 res3 = emit(f32, f32(math.pi));
//~ class RoundingModeType: int32 {};
enum RoundingMode {
	ROUND_UP = 0;
	ROUND_DOWN = 1;
	ROUND_CEILING = 2;
	ROUND_FLOOR = 3;
	ROUND_HALF_UP = 4;
	ROUND_HALF_DOWN = 5;
	ROUND_HALF_EVEN = 6;
	ROUND_UNNECESSARY = 7;
}

define sqr(flt64 value) = flt64(value * value);
define round(flt64 value, flt64 mode) = flt64(value + mode);
define round(flt64 value) = round(value, RoundingMode.ROUND_FLOOR);

define a = 6;
//~ double a1 = round(2.998);
double a2 = round(sqr(6), sqr(a));

struct Font {
	string Name;
	type: enum Type {
		Bold;
		Italic;
		Underline;
	};

	alma: struct Alma{
		int a;
		int b;
	}

}

define f2 : Font[200];

f2 a;

x.type = Font.Type.Italic;
//~ x.type = Font.Italic;
*/

static if (1) {
struct i32x8 {
	//~ int32 i0[8];
	// optimized for print layout
	int32 i8;	//!%%08x
	int32 i7;	//!%%08x
	int32 i6;	//!%%08x
	int32 i5;	//!%%08x
	int32 i4;	//!%%08x
	int32 i3;	//!%%08x
	int32 i2;	//!%%08x
	int32 i1;	//!%%08x
}
define i32x8(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8) = emit(i32x8, i32(i1), i32(i2), i32(i3), i32(i4), i32(i5), i32(i6), i32(i7), i32(i8));

//~ i32x8 a = i32x8(0x00000000, 0xffffffff, 0x00000000, 0x8fffffff, 0x00000000, 0xffffffff, 0x00000000, 0x8fffffff);
//~ i32x8 b = i32x8(0x00000000, 0xffffffff, 0xffffffff, 0x7fffffff, 0x00000000, 0xffffffff, 0xffffffff, 0x7fffffff);
//~ i32x8 a = i32x8(0, 0, 0, 0, 0, 0, 0, 0);
i32x8 b = i32x8(0, 0, 0, 0, 0, 0, 0, 1);
//~ i32x8 a = i32x8(0x0fffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff);
i32x8 a = i32x8(0x0f1f2f3f, 0x4f5f6f7f, 0x8f9fffff, 0xffffffff, 0x0efffffff, 0xffffffff, 0xffffffff, 0xffffffff);
i32x8 c;

enum TestType {
	cmt;
	neg;
	add;	// done
	sub;
	mul;
	div;
	mod;
	shl;
	shr;
	sar;
}

define test = TestType.add;
/*i32x8 add(i32x8 a, i32x8 b) {
	result.i1 = int32(a.i1 + b.i1);
	result.i2 = int32(a.i2 + b.i2 + (uns32(result.i1) < (a.i1 | b.i1)));
	result.i3 = int32(a.i3 + b.i3 + (uns32(result.i2) < (a.i2 | b.i2)));
	result.i4 = int32(a.i4 + b.i4 + (uns32(result.i3) < (a.i3 | b.i3)));
	result.i5 = int32(a.i5 + b.i5 + (uns32(result.i4) < (a.i4 | b.i4)));
	result.i6 = int32(a.i6 + b.i6 + (uns32(result.i5) < (a.i5 | b.i5)));
	result.i7 = int32(a.i7 + b.i7 + (uns32(result.i6) < (a.i6 | b.i6)));
	result.i8 = int32(a.i8 + b.i8 + (uns32(result.i7) < (a.i7 | b.i7)));
} // */

static if (test == TestType.cmt) {
c.i1 = ~b.i1;
c.i2 = ~b.i2;
c.i3 = ~b.i3;
c.i4 = ~b.i4;
c.i5 = ~b.i5;
c.i6 = ~b.i6;
c.i7 = ~b.i7;
c.i8 = ~b.i8;
}
static if (test == TestType.neg) {
c.i1 = int32(-b.i1);
c.i2 = int32(-b.i2 - (uns32(c.i1) > b.i1));
c.i3 = int32(-b.i3 - (uns32(c.i2) > b.i2));
c.i4 = int32(-b.i4 - (uns32(c.i3) > b.i3));
c.i5 = int32(-b.i5 - (uns32(c.i4) > b.i4));
c.i6 = int32(-b.i6 - (uns32(c.i5) > b.i5));
c.i7 = int32(-b.i7 - (uns32(c.i6) > b.i6));
c.i8 = int32(-b.i8 - (uns32(c.i7) > b.i7));
}
static if (test == TestType.add) {
c.i1 = int32(a.i1 + b.i1);
c.i2 = int32(a.i2 + b.i2 + (uns32(c.i1) < (a.i1 | b.i1)));
c.i3 = int32(a.i3 + b.i3 + (uns32(c.i2) < (a.i2 | b.i2)));
c.i4 = int32(a.i4 + b.i4 + (uns32(c.i3) < (a.i3 | b.i3)));
c.i5 = int32(a.i5 + b.i5 + (uns32(c.i4) < (a.i4 | b.i4)));
c.i6 = int32(a.i6 + b.i6 + (uns32(c.i5) < (a.i5 | b.i5)));
c.i7 = int32(a.i7 + b.i7 + (uns32(c.i6) < (a.i6 | b.i6)));
c.i8 = int32(a.i8 + b.i8 + (uns32(c.i7) < (a.i7 | b.i7)));
}
static if (test == TestType.sub) {
c.i1 = int32(a.i1 - b.i1);
c.i2 = int32(a.i2 - b.i2 - (uns32(c.i1) > (a.i1 | b.i1)));
c.i3 = int32(a.i3 - b.i3 - (uns32(c.i2) > (a.i2 | b.i2)));
c.i4 = int32(a.i4 - b.i4 - (uns32(c.i3) > (a.i3 | b.i3)));
c.i5 = int32(a.i5 - b.i5 - (uns32(c.i4) > (a.i4 | b.i4)));
c.i6 = int32(a.i6 - b.i6 - (uns32(c.i5) > (a.i5 | b.i5)));
c.i7 = int32(a.i7 - b.i7 - (uns32(c.i6) > (a.i6 | b.i6)));
c.i8 = int32(a.i8 - b.i8 - (uns32(c.i7) > (a.i7 | b.i7)));
}
static if (test == TestType.mul) {
// This needs shift ops
c.i1 = int32(a.i1 * b.i1);
c.i2 = 0;
c.i3 = 0;
c.i4 = 0;
c.i5 = 0;
c.i6 = 0;
c.i7 = 0;
c.i8 = 0;
}

static if (test == TestType.shl) {
c.i1 = int32((uns32(a.i1) >> b.i1) | (uns32(a.i2) << (32 - b.i1)));
//~ c.i2 = int32((uns32(a.i2) >> b.i1) | (uns32(a.i3) << (32 - b.i1)));
//~ c.i3 = int32((uns32(a.i3) >> b.i1) | (uns32(a.i4) << (32 - b.i1)));
//~ c.i4 = int32((uns32(a.i4) >> b.i1) | (uns32(a.i5) << (32 - b.i1)));
//~ c.i5 = int32((uns32(a.i5) >> b.i1) | (uns32(a.i6) << (32 - b.i1)));
//~ c.i6 = int32((uns32(a.i6) >> b.i1) | (uns32(a.i7) << (32 - b.i1)));
//~ c.i7 = int32((uns32(a.i7) >> b.i1) | (uns32(a.i8) << (32 - b.i1)));
//~ c.i8 = int32(uns32(a.i8) >> b.i1);
}
}
static if (0) {
struct i32x4 {
	// optimized for print layout
	int32 i4;	//!%%08x
	int32 i3;	//!%%08x
	int32 i2;	//!%%08x
	int32 i1;	//!%%08x
}
define i32x4(int i1, int i2, int i3, int i4) = emit(i32x4, i32(i1), i32(i2), i32(i3), i32(i4));

//~ i32x4 a = i32x4(0x00000000, 0xffffffff, 0x00000000, 0x8fffffff);
//~ i32x4 b = i32x4(0x00000000, 0xffffffff, 0xffffffff, 0x7fffffff);
//~ i32x4 a = i32x4(0, 0, 0, 0);
//~ i32x4 b = i32x4(0, 0, 0, 0);
i32x4 b = i32x4(0, 0, 0, 1);
i32x4 a = i32x4(0x00000000, 0xffffffff, 0xffffffff, 0xffffffff);

i32x4 c;
c.i1 = int32(a.i1 + b.i1);
c.i2 = int32(a.i2 + b.i2 + (uns32(c.i1) < (a.i1 | b.i1)));
c.i3 = int32(a.i3 + b.i3 + (uns32(c.i2) < (a.i2 | b.i2)));
c.i4 = int32(a.i4 + b.i4 + (uns32(c.i3) < (a.i3 | b.i3)));
}

//~ flt32 dp3(vec4f a, vec4f b) {result = a.x * b.x + a.y * b.y + a.z * b.z;}
//~ flt32 dph(vec4f a, vec4f b) {result = a.x * b.x + a.y * b.y + a.z * b.z + a.w;}
//~ flt32 dp4(vec4f a, vec4f b) {result = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;}
//~ flt32 dot(vec4f a, vec4f b) = dp3;

/* factorial
define n = 6;
int64 res = int64(1);
for (int i = 1; i <= n; i += 1)
	res *= i;

// */
/* calc E
double res = 1.;
{
	// hide these
	double tmp = 1.;
	define eps = 1e-100;
	for (int i = 1; tmp > eps; i += 1) {
		//~ res = res + (tmp = tmp / i);
		res += tmp /= i;
	}
}
// */

/* test scope:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (1) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(0)

//~ */

//~ /+ TODO: error
define dim = 20;
define scalar flt32;
scalar M[dim][dim][dim];
//~ scalar m1[dim][dim];
//~ scalar m2[dim][dim];
//~ scalar m3[dim][dim];

/+ Initialize
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		m1[i][j] = m2[i][j] = (i == j) + 1;
	}
} // +/
/*/~ Compute
for (int i = 0; i < dim; i += 1) {
	print(i);
	putchr('\n');
	for (int j = 0; j < dim; j += 1) {
		m3[i][j] = 0;
		for (int k = 0; k < dim; k += 1) {
			m3[i][j] += m1[i][k] * m2[k][j];
		}
	}
}// */
/+ Print
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		if (j != 0)
			putchr(' ');
		print(m1[i][j]);
	}
	putchr('\n');
} // +/
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		putchr('\t');
		for (int k = 0; k < dim; k += 1) {
			if (k != 0)
				putchr(' ');
			print(M[i][j][k]);
		}
		putchr('\n');
	}
	putchr('\n');
} // +/
// +/
