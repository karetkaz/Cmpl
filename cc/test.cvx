//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

//~ module test;

//~ int alma(int h)[10];	???
//~ void fun(int x) = true ? null : void(int x){print(x);});
//~ addEventListener(MouseEvent.CLICK, function() {System.exit(0);});
//~ float a = lerp(.6, 0, 1);

//~ type pointer;

//~ define int(pointer p) = *(int*)p;
//~ define int(pointer p) = emit(i32.ldi, ref(p));

void method() = null;

void method2() {
	println("2");
}

void methodCall(void method()) {
	method();
}

//~ method = method2;
methodCall(method2);
//~ println("2");
//~ method();

/*
debug1(1, 2, 3);

static int X = 1;
static int Y = 2;
static int Z = 3;

int x = 1;
int y = 2;
int z = 3;
//~ */

/* Test external Calls
static int X = 912;
void testCallBack0(int n) {
	print("X = ");
	println(X);
	X += 0;
}
void testCallBack1(int n) {
	print("X = ");
	println(X);
	X += 1;
}
void testCallBackn(int n) {
	print("X = ");
	println(X);
	X += n;
}
setCallBack(testCallBack1);
//~ */

/* Test functions

struct gxRect {
	int32 x;	//%x: %d
	int32 y;	//%y: %d
	int32 w;	//%width: %d
	int32 h;	//%height: %d
}

enum gxBlit {
	copy;
	and;
	or;
	xor;
	add;
	sub;
	mul;
	div;
}

define println2(int x) = void(println(), print(x));

void almaref(int &x) = null;
void alma(int &x) {print("alma:");println(x);}
void korte(int &x) {print("korte:");println(x);}

void setCallBack(int mode, void handler(int &Event)) {
	//~ if (handler != null)
	handler(mode);
}

//~ setCallBack(100, null);
setCallBack(101, alma);
setCallBack(106, korte);

// */

/* recursive
void recurse(int x) {
	if (x > 0) {
		print("pre: "); println(x);
		recurse(x - 1);
		print("post: "); println(x);
	}
}

recurse(20);
// */

/* TODO
if (int32 == int32) {
	println("alma");
}// */

/* module gfx2d;
const gxBlit {
	copy
	and
	or
	xor
	key
	//~ Blt32lum;		// extract
	//~ Blt32rch;		// Red Channel
	//~ Blt32gch;		// Green Channel
	//~ Blt32bch;		// Blue Channel

	//~ Blt32_15;
	//~ Blt32_16;
	//~ Blt32_24;
	//~ Blt32cpy;
	//~ Blt32and;
	//~ Blt32ior;
	//~ Blt32xor;
	//~ Blt32mix;		// alpha mix
	//~ Blt32add;		// Add
	//~ Blt32sub;		// Subtract
	//~ Blt32dif;		// Difference
	//~ Blt32mul;		// Multiply
	//~ Blt32div;		// Divide
	//~ Blt32min;		// Darken
	//~ Blt32max;		// Lighten
	//~ Blt32scr;		// Screen
	//~ Blt32ovr;		// Overlay
	//~ Blt32rch;		// Red Channel
	//~ Blt32gch;		// Green Channel
	//~ Blt32bch;		// Blue Channel
}
struct gxRect {}
struct gxClip {}
struct gxSurf {}

pointer gx_cliprect(gxSurf& src, gxRect);

pointer getpaddr(gxSurf, int, int);
xrgb getpixel(gxSurf &src, int x, int y);
xrgb getpix16(gxSurf &src, fix x, fix y, xrgb c);
void setpixel(gxSurf &dst, int x, int y, xrgb c);
void setblock(gxSurf &dst, int x0, int y0, int x1, int y1, xrgb c);

define sethline(gxSurf, int x0, int &y0, int x1, xrgb col) = setblock(x0, y0, x1, y0, col);
define setvline(gxSurf, int &x0, int y0, int y1, xrgb col) = setblock(x0, y0, x0, y1, col);

int fillsurf(gxSurf dst, gxRect roi, gxBlit mode, long col);
int copysurf(gxSurf dst, int x, int y, gxSurf src, gxRect roi, gxBlit mode);
int zoomsurf(gxSurf dst, gxRect rect, gxSurf src, gxRect roi, int lin);


void drawline(gxSurf dst, int x0, int y0, int x1, int y1, xrgb col);
void drawrect(gxSurf dst, int x0, int y0, int x1, int y1, xrgb col);
void drawoval(gxSurf dst, int x0, int y0, int x1, int y1, xrgb col);
void drawbez2(gxSurf dst, int x0, int y0, int x1, int y1, int x2, int y2, xrgb col);
void drawbez3(gxSurf dst, int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3, xrgb col);

void clipText(gxRect roi, gxSurf fnt, string str);
void drawChar(gxSurf dst, int x, int y, gxSurf fnt, char chr, xrgb col);
void drawText(gxSurf dst, int x, int y, gxSurf fnt, string str, xrgb col);

//~ define gx_getclip(gxSurf s) {return s.clipPtr ? s.clipPtr : gxClip(pointer(&s));}

int loadBMP(gx_Surf dst, string fileName, int depth);
int loadJPG(gx_Surf dst, string fileName, int depth);
int saveBMP(string fileName, gxSurf src, int depth);

}// +/
// */

/* Bits: hi, lo, extend
define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend
define Lo64(int64 a) = emit(int32, set, i64(a));	// Lo32 part
define Hi64(int64 a) = emit(int32, pop, i64(a));	// Hi32 part
//~ define Lo32(int32 a) = int32(a & 0xffff);			// Lo16 part
//~ define Hi32(int32 a) = Lo32(a >> 16);				// Hi16 part
//~ define Lo16(int32 a) = int32(a & 0xff);				// Lo16 part
//~ define Hi16(int32 a) = Lo16(a >> 8);				// Hi16 part

hex64 val = 0xff00ff00ff0f0f0f9;
hex32 lo = Lo64(val);
hex32 hi = Hi64(val);
// */

/* fixed point math
define fixed int32;
define __fix = 16;

define fixed_fix(int64 &val, int &__fix) = fixed(bits.shr(val + bits.shr(val, __fix) + 1, __fix));
define add(fixed lhs, fixed rhs, int __fix) = fixed(lhs + rhs);
define sub(fixed lhs, fixed rhs, int __fix) = fixed(lhs - rhs);
define mul(fixed lhs, fixed rhs, int __fix) = fixed_fix(int64(lhs) * rhs, __fix);

define fixed(int32 val, int __fix) = fixed(val << __fix);
define fixed(float32 val, int __fix) = fixed(val * (1 << __fix));
define fixed(float64 val, int __fix) = fixed(val * (1 << __fix));

define int(fixed val, int __fix) = int(val >> __fix);
define double(fixed val, int __fix) = double(val / double(1 << __fix));

define fixed_fix(int64 val) = fixed_fix(val, __fix);
define add(fixed lhs, fixed rhs) = add(lhs, rhs, __fix);
define sub(fixed lhs, fixed rhs) = sub(lhs, rhs, __fix);
define mul(fixed lhs, fixed rhs) = mul(lhs, rhs, __fix);

define fixed(int val)   = fixed(val, __fix);
define fixed(float32 val) = fixed(val, __fix);
define fixed(float64 val) = fixed(val, __fix);

define int(fixed val) = int(val, __fix);
define double(fixed val) = double(val, __fix);

double fixed_test = double(add(fixed(2.5), fixed(3)));
// */

/* clamp, lerp, smooth
//~ define e1 = double(2);
//~ define e1 = float(2);
float e1 = 0;
float e2 = 6;
float s = (e2 - e1) / 100;
for (float x = e1; x < e2; x += s) {	// x in [e1, e2]
	float t = (x - e1) / (e2 - e1);		// t in [0., 1.]
	//~ println(lerp(t, e1, e2));
	println(smooth(x, e1, e2));
	//~ println(clamp(t, .2, .6));
}
// */

/* cross, normalize
vec4f a = vec4f(1., 2., 3., 5.);
vec4f b = vec4f(0., 2., 0., 5.);
vec4f e = cross(a, b);
vec4f E = normalize(cross(vec4f(1., 2., 3.), vec4f(10., 20., 3.)));
// */

/* float compare
define __eps = 1e-15;
//~ define eq(float32 a, float32 b, float32 eps) = bool(abs(a - b) < eps);
define eq(float64 a, float64 b, float64 eps) = bool(abs(a - b) < eps);

//~ define eq(float32 a, float32 b) = eq(a, b, float32(__eps));
define eq(float64 a, float64 b) = eq(a, b, __eps);

define double1 float64;//%%2.10F

double1 a = 0.1; //%hexaban 0x%016X
double1 b = 0.2;
double1 c = 0.3;
bool x = (a + b) + c == a + (b + c);
bool x1 = eq((a + b) + c, a + (b + c));

// */

/* random numbers
for (int i = 0; i < 60; i += 1) {
	println(random(1.001));
}
// */

/*functions
void stackOwerflow() {
	//~ emit(ref, ref(stackOwerflow));
	stackOwerflow();
}

stackOwerflow();

// */

/* using emit; and emit();
//~ string alma = "alma a fa alatt";
//~ println(1 + 4);

int64 t1 = 314;
int64 t2 = emit();
int64 t3 = emit;
print(t2);
print(t3);

//~ t3 = 90;
//~ println(t3);
// */

/* using strings

long cikkId = 165;
long raktar = 3;
long btetelId = 6398;
double mennyiseg = 1;

define strlen = 25;

int8 val[strlen + 1];
val[strlen] = 0;

string str = string(val);

println("INSERT INTO gyariszam(cikk_id, mennyiseg, b_tetel_id, raktar_id, gyariszam) VALUES");
for (int i = 0; i < 40; i += 1) {

	for (int j = 0; j < strlen; j += 1)
		val[j] = random('a', 'z');

	print("("); print(cikkId);
	print(", "); print(mennyiseg);
	print(", "); print(btetelId);
	print(", "); print(raktar);
	print(", '"); print(str);
	println("'),");
}
// */

/+ hex view
int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
define n = 10;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
define eps = 1e-50;
double tmp = 1.;
double res = 1.;
//~ hex64 Res = emit();
for (int i = 1; tmp > eps; i += 1) {
	//~ double old = res;
	res += tmp /= i;
	//~ if (old == res) tmp = 0;
}
// */

/* test scope:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (0) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(0)

//~ */
