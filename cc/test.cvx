//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

//~ module test;

//~ int alma(int h)[10];	???
//~ void fun(int x) = true ? null : void(int x){print(x);});
//~ addEventListener(MouseEvent.CLICK, function() {System.exit(0);});
//~ float a = lerp(.6, 0, 1);

float32 res1 = emit(f32.div, f32(2), f32(math.pi));
float64 res2 = emit(f64.neg, f64(math.pi));
float32 res3 = emit(float32, f32(math.pi));


/*
void bitsget(bool signed, int size, int64 &min, int64 &max) {
	int64 mask = bits.shr(int64(-1), -size);
	min = bits.shl(-int64(signed), size - 1);
	max = bits.and(min - 1, mask);
}

int bits = 24;
hex64 min;
hex64 max;

hex64 umin;
hex64 umax;

bitsget(true, bits, min, max);
bitsget(!true, bits, umin, umax);
// */

/* 
//~ void method() = null;

void method2() {
	static int i = 9;
	//~ println( i += 2);
	puti64( i += 2);
	putchr('\n');
	//~ putstr("!alma a fa alatt nyári piros alma\n");
}// +/
static if (true) {
	method2();
	method2();
	method2();
}// +/
/+static if (true) {		// TODO: without static
	void method() = method2;

	//~ void method() = null;
	//~ method = method2;

	method();
	method();
	method();
}// +/

//~ /+
void methodCall(void method()) {
	//~ putstr("!alma a fa alatt nyári piros alma\n");
	if (method != null)
		method();
}
methodCall(method2);
methodCall(null);
//~ +/

//~ */

/* use: ./ccvm -c -x -O-2 test.cvx
debug1(1, 2, 3);

static int X = 1;
static int Y = 2;
static int Z = 3;

int x = 1;
int y = 2;
int z = 3;
//~ */

/* Test external Calls
static int X = 912;
void testCallBack0(int n) {
	print("X = ");
	println(X);
	X += 0;
}
void testCallBack1(int n) {
	print("X = ");
	println(X);
	X += 1;
}
void testCallBackn(int n) {
	print("X = ");
	println(X);
	X += n;
}
setCallBack(testCallBackn);
//~ */

/* Test functions

void alma(int &x) {print("alma:");println(x);}
void korte(int &x) {print("korte:");println(x);}

// this wont work if not static
//~ void almaref(int &x) = alma;

void setCallBack(int mode, void handler(int &Event)) {
	if (handler != null)
		handler(mode);
}

setCallBack(100, null);
setCallBack(101, alma);
setCallBack(106, korte);
//~ setCallBack(106, almaref);

// */


/* using strings

long cikkId = 165;
long raktar = 3;
long btetelId = 6398;
double mennyiseg = 1;

define strlen = 25;
int8 val[strlen + 1];
val[strlen] = 0;

println("INSERT INTO gyariszam(cikk_id, mennyiseg, b_tetel_id, raktar_id, gyariszam) VALUES");
for (int i = 0; i < 40; i += 1) {

	for (int j = 0; j < strlen; j += 1) {
		int c = random('a', 'z');
		val[j] = c;
	}
		//~ val[j] = 'a' + random('z');
		//~ val[j] = c;//random('a', 'z');

	print("("); print(cikkId);
	print(", "); print(mennyiseg);
	print(", "); print(btetelId);
	print(", "); print(raktar);
	print(", '"); print(emit(string, ref(val)));
	println("'),");
}
// */

/* recursive
void recurse(int x) {
	if (x > 0) {
		print("pre: "); println(x);
		recurse(x - 1);
		print("post: "); println(x);
	}
}

recurse(20);
// */

/* Bits: hi, lo, extend
define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend
define Lo64(int64 a) = emit(int32, set, i64(a));	// Lo32 part
define Hi64(int64 a) = emit(int32, pop, i64(a));	// Hi32 part
//~ define Lo32(int32 a) = int32(a & 0xffff);			// Lo16 part
//~ define Hi32(int32 a) = Lo32(a >> 16);				// Hi16 part
//~ define Lo16(int32 a) = int32(a & 0xff);				// Lo16 part
//~ define Hi16(int32 a) = Lo16(a >> 8);				// Hi16 part

hex64 val = 0xff00ff00ff0f0f0f9;
hex32 lo = Lo64(val);
hex32 hi = Hi64(val);

void xx() {
	static int xx1 = 0;
}

// */

/* clamp, lerp, smooth
//~ define e1 = double(2);
//~ define e1 = float(2);
float e1 = 0;
float e2 = 6;
float s = (e2 - e1) / 100;
for (float x = e1; x < e2; x += s) {	// x in [e1, e2]
	float t = (x - e1) / (e2 - e1);		// t in [0., 1.]
	//~ println(lerp(t, e1, e2));
	println(smooth(x, e1, e2));
	//~ println(clamp(t, .2, .6));
}
// */

/* cross, normalize
vec4f a = vec4f(1., 2., 3., 5.);
vec4f b = vec4f(0., 2., 0., 5.);
vec4f e = cross(a, b);
vec4f E = normalize(cross(vec4f(1., 2., 3.), vec4f(10., 20., 3.)));
// */

/* float compare
define __eps = 1e-15;
//~ define eq(float32 a, float32 b, float32 eps) = bool(abs(a - b) < eps);
define eq(float64 a, float64 b, float64 eps) = bool(abs(a - b) < eps);

//~ define eq(float32 a, float32 b) = eq(a, b, float32(__eps));
define eq(float64 a, float64 b) = eq(a, b, __eps);

define double1 float64;//%%2.10F

double1 a = 0.1; //%hexaban 0x%016X
double1 b = 0.2;
double1 c = 0.3;
bool x = (a + b) + c == a + (b + c);
bool x1 = eq((a + b) + c, a + (b + c));

// */

/* random numbers
for (int i = 0; i < 60; i += 1) {
	println(random(1.001));
}
// */

/* using emit; and emit();
//~ string alma = "alma a fa alatt";
//~ println(1 + 4);

int64 t1 = 314;
int64 t2 = emit();
int64 t3 = emit;
print(t2);
print(t3);

//~ t3 = 90;
//~ println(t3);
// */

/+ hex view: use: ./ccvm -c -x -O-2 test.cvx

int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
define n = 6;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
//~ {
	//~ int i = 1;
	res *= i;
}
// */
/* calc E
define eps = 1e-50;
double tmp = 1.;
double res = 1.;
//~ hex64 Res = emit();
for (int i = 1; tmp > eps; i += 1) {
	//~ double old = res;
	res += tmp /= i;
	//~ if (old == res) tmp = 0;
}
// */

/* test scope:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (0) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(0)

//~ */
