//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

//~ module test;

//~ int x = 5;
//~ int a = pow(2, x);
//~ int b = 1 << x;

//~ double x = 9*13;

//~ int alma(int h)[10];	???

/* gfx2d
module gfx2d;
/+libc {
const gxBlit {
	copy
	and
	or
	xor
	key
	//~ Blt32lum;		// extract
	//~ Blt32rch;		// Red Channel
	//~ Blt32gch;		// Green Channel
	//~ Blt32bch;		// Blue Channel

	//~ Blt32_15;
	//~ Blt32_16;
	//~ Blt32_24;
	//~ Blt32cpy;
	//~ Blt32and;
	//~ Blt32ior;
	//~ Blt32xor;
	//~ Blt32mix;		// alpha mix
	//~ Blt32add;		// Add
	//~ Blt32sub;		// Subtract
	//~ Blt32dif;		// Difference
	//~ Blt32mul;		// Multiply
	//~ Blt32div;		// Divide
	//~ Blt32min;		// Darken
	//~ Blt32max;		// Lighten
	//~ Blt32scr;		// Screen
	//~ Blt32ovr;		// Overlay
	//~ Blt32rch;		// Red Channel
	//~ Blt32gch;		// Green Channel
	//~ Blt32bch;		// Blue Channel
}
struct gxRect {}
struct gxClip {}
struct gxSurf {}

pointer gx_cliprect(gxSurf& src, gxRect);

pointer getpaddr(gxSurf, int, int);
xrgb getpixel(gxSurf &src, int x, int y);
xrgb getpix16(gxSurf &src, fix x, fix y, xrgb c);
void setpixel(gxSurf &dst, int x, int y, xrgb c);
void setblock(gxSurf &dst, int x0, int y0, int x1, int y1, xrgb c);

define sethline(gxSurf, int x0, int &y0, int x1, xrgb col) = setblock(x0, y0, x1, y0, col);
define setvline(gxSurf, int &x0, int y0, int y1, xrgb col) = setblock(x0, y0, x0, y1, col);

int fillsurf(gxSurf dst, gxRect roi, gxBlit mode, long col);
int copysurf(gxSurf dst, int x, int y, gxSurf src, gxRect roi, gxBlit mode);
int zoomsurf(gxSurf dst, gxRect rect, gxSurf src, gxRect roi, int lin);


void drawline(gxSurf dst, int x0, int y0, int x1, int y1, xrgb col);
void drawrect(gxSurf dst, int x0, int y0, int x1, int y1, xrgb col);
void drawoval(gxSurf dst, int x0, int y0, int x1, int y1, xrgb col);
void drawbez2(gxSurf dst, int x0, int y0, int x1, int y1, int x2, int y2, xrgb col);
void drawbez3(gxSurf dst, int x0, int y0, int x1, int y1, int x2, int y2, int x3, int y3, xrgb col);

void clipText(gxRect roi, gxSurf fnt, string str);
void drawChar(gxSurf dst, int x, int y, gxSurf fnt, char chr, xrgb col);
void drawText(gxSurf dst, int x, int y, gxSurf fnt, string str, xrgb col);

//~ define gx_getclip(gxSurf s) {return s.clipPtr ? s.clipPtr : gxClip(pointer(&s));}

//~ int loadCUR(gx_Surf, const char*, int);
int loadBMP(gx_Surf dst, string fileName, int depth);
int loadJPG(gx_Surf dst, string fileName, int depth);
int saveBMP(string fileName, gxSurf src, int depth);

int loadFNT(gxSurf, string fileName);

}// +/
// */

/* Bits: hi, lo, extend
define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend
define Lo64(int64 a) = emit(int32, set, i64(a));	// Lo32 part
define Hi64(int64 a) = emit(int32, pop, i64(a));	// Hi32 part
//~ define Lo32(int32 a) = int32(a & 0xffff);			// Lo16 part
//~ define Hi32(int32 a) = Lo32(a >> 16);				// Hi16 part
//~ define Lo16(int32 a) = int32(a & 0xff);				// Lo16 part
//~ define Hi16(int32 a) = Lo16(a >> 8);				// Hi16 part

hex64 val = 0xff00ff00ff0f0f0f9;
hex32 lo = Lo64(val);
hex32 hi = Hi64(val);
// */

/* fixed point math
define fixed int32;
define __fix = 16;

define fixed_fix(int64 &val, int &__fix) = fixed(bits.shr(val + (bits.shr(val, __fix) + 1), __fix));
define add(fixed lhs, fixed rhs, int __fix) = fixed(lhs + rhs);
define sub(fixed lhs, fixed rhs, int __fix) = fixed(lhs - rhs);
define mul(fixed lhs, fixed rhs, int __fix) = fixed_fix(int64(lhs) * rhs, __fix);

define fixed(int32 val, int __fix) = fixed(val << __fix);
define fixed(float32 val, int __fix) = fixed(val * (1 << __fix));
define fixed(float64 val, int __fix) = fixed(val * (1 << __fix));

define int(fixed val, int __fix) = int(val >> __fix);
define double(fixed val, int __fix) = double(val / double(1 << __fix));

define fixed_fix(int64 val) = fixed_fix(val, __fix);
define add(fixed lhs, fixed rhs) = add(lhs, rhs, __fix);
define sub(fixed lhs, fixed rhs) = sub(lhs, rhs, __fix);
define mul(fixed lhs, fixed rhs) = mul(lhs, rhs, __fix);

define fixed(int val)   = fixed(val, __fix);
define fixed(float32 val) = fixed(val, __fix);
define fixed(float64 val) = fixed(val, __fix);

define int(fixed val) = int(val, __fix);
define double(fixed val) = double(val, __fix);

double fixed_test = double(add(fixed(2.5), fixed(3)));
//~ println(fixed_test);
// */

/* clamp, lerp, smooth
//~ define e1 = double(2);
//~ define e1 = float(2);
float e1 = 0;
float e2 = 6;
float s = (e2 - e1) / 100;
for (float x = e1; x < e2; x += s) {	// x in [e1, e2]
	float t = (x - e1) / (e2 - e1);		// t in [0., 1.]
	//~ println(lerp(t, e1, e2));
	println(smooth(x, e1, e2));
	//~ println(clamp(t, .2, .6));
}
// */

/* cross, normalize
vec4f a = vec4f(1., 2., 3., 5.);
vec4f b = vec4f(0., 2., 0., 5.);
vec4f e = cross(a, b);
vec4f E = normalize(cross(vec4f(1., 2., 3.), vec4f(10., 20., 3.)));
// */

/* float compare
define __eps = 1e-15;
//~ define eq(float32 a, float32 b, float32 eps) = bool(abs(a - b) < eps);
define eq(float64 a, float64 b, float64 eps) = bool(abs(a - b) < eps);

//~ define eq(float32 a, float32 b) = eq(a, b, float32(__eps));
define eq(float64 a, float64 b) = eq(a, b, __eps);

double a = 0.1;
double b = 0.2;
double c = 0.3;
bool x = (a + b) + c == a + (b + c);
bool x1 = eq((a + b) + c, a + (b + c));

// */

/* random numbers
for (int i = 0; i < 60; i += 1) {
	println(random(0.001));
}
// */

//~ emit(void, call, i32(0x));		// stack overflow

/* function
define test = 3;
define rty int64;
define aty int64;
/+static if (test == 1) {
rty Result;
aty A = 9;
string ptr = "";
Result = A + A;

rty sum(aty a) {
	result = a + a;
}
}// +/
/+static if (test == 2) {
rty Result;
aty B = 5;
aty A = 9;
string ptr = "";
Result = A + B;

rty sum(aty a, aty b) {
	result = a + b;
}
}// +/
static if (test == 3) {
rty Result;
aty C = 5;
aty B = 7;
aty A = 9;
string ptr = "";
Result = A + B;
rty sum(aty a, aty b, aty c) {
	result = a + b;
}
}// +/

// */

/* fogyasztas
define fogyasztas(double _km, double _benzin, double _atlag) = double(_benzin * _km * _atlag / 100.);

double km = 4. * 5 * 16;
double atlag = 9.0;
double benzin = 4.90;
double fogyasztas = fogyasztas(km, benzin, atlag);
// */

/+ big integer math
static if (1) {
struct i32x8 {
	int32 i8;	//%%08x
	int32 i7;	//%%08x
	int32 i6;	//%%08x
	int32 i5;	//%%08x
	int32 i4;	//%%08x
	int32 i3;	//%%08x
	int32 i2;	//%%08x
	int32 i1;	//%%08x
} // */

define i32x8(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8) = emit(i32x8, i32(i1), i32(i2), i32(i3), i32(i4), i32(i5), i32(i6), i32(i7), i32(i8));
define i32x8(int32 i0) = emit(i32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32.shr, i32(31), dupp.x1, i32(i0));
define i32x8(uint32 i0) = emit(i32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32(0), i32(i0));

i32x8 a = i32x8(int32(0x0fffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff));
i32x8 b = i32x8(1);

i32x8 c;

/*TODO: no functions
i32x8 add(i32x8 a, i32x8 b) {
	//~ i32x8 c;
	hex64 ovf = 0xffffffff;
	hex64 sum;
	int64 carry = 0;
	c.i1 = int32(sum = zxt64(a.i1) + b.i1 + carry);
	carry = sum > ovf;
	c.i2 = int32(sum = zxt64(a.i2) + b.i2 + carry);
	carry = sum > ovf;
	c.i3 = int32(sum = zxt64(a.i3) + b.i3 + carry);
	carry = sum > ovf;
	c.i4 = int32(sum = zxt64(a.i4) + b.i4 + carry);
	carry = sum > ovf;
	c.i5 = int32(sum = zxt64(a.i5) + b.i5 + carry);
	carry = sum > ovf;
	c.i6 = int32(sum = zxt64(a.i6) + b.i6 + carry);
	carry = sum > ovf;
	c.i7 = int32(sum = zxt64(a.i7) + b.i7 + carry);
	carry = sum > ovf;
	c.i8 = int32(sum = zxt64(a.i8) + b.i8 + carry);
	//~ carry = sum > ovf;
}

i32x8 add(i32x8 a, int32 b) {}

i32x8 cmt(i32x8 b) {
	result.i1 = ~b.i1;
	result.i2 = ~b.i2;
	result.i3 = ~b.i3;
	result.i4 = ~b.i4;
	result.i5 = ~b.i5;
	result.i6 = ~b.i6;
	result.i7 = ~b.i7;
	result.i8 = ~b.i8;
}
i32x8 neg(i32x8 b) {}

i32x8 add(i32x8 a, i32x8 b, int32 &c = null);
i32x8 add(i32x8 a, int32 b, int32 &c = null);
i32x8 sub(i32x8 a, i32x8 b, int32 &c = null);
i32x8 sub(i32x8 a, int32 b, int32 &c = null);
i32x8 mul(i32x8 a, i32x8 b, i32x8 &hi = null);
i32x8 mul(i32x8 a, int32 b, i32x8 &hi = null);
i32x8 div(i32x8 a, i32x8 b, i32x8 &rem = null);
i32x8 div(i32x8 a, int32 b, i32x8 &rem = null);
i32x8 mod(i32x8 a, i32x8 b) {div(a, b, result);}
i32x8 mod(i32x8 a, int32 b) {div(a, b, result);}

i32x8 sub(i32x8 a, i32x8 b) {}

// */
//~ /*

define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend
static if (true) {		// add
	hex64 ovf = 0xffffffff;
	hex64 sum;
	int64 carry = 0;
	c.i1 = int32(sum = zxt64(a.i1) + b.i1 + carry);
	carry = sum > ovf;
	c.i2 = int32(sum = zxt64(a.i2) + b.i2 + carry);
	carry = sum > ovf;
	c.i3 = int32(sum = zxt64(a.i3) + b.i3 + carry);
	carry = sum > ovf;
	c.i4 = int32(sum = zxt64(a.i4) + b.i4 + carry);
	carry = sum > ovf;
	c.i5 = int32(sum = zxt64(a.i5) + b.i5 + carry);
	carry = sum > ovf;
	c.i6 = int32(sum = zxt64(a.i6) + b.i6 + carry);
	carry = sum > ovf;
	c.i7 = int32(sum = zxt64(a.i7) + b.i7 + carry);
	carry = sum > ovf;
	c.i8 = int32(sum = zxt64(a.i8) + b.i8 + carry);
	//~ carry = sum > ovf;
} // */
static if (!true) {		// sub.xxx
	hex64 ovf = 0;//xffffffff;
	hex64 sum;
	int64 borrow = 0;
	c.i1 = int32(sum = zxt64(a.i1) - b.i1 - borrow);
	borrow = sum < ovf;
	c.i2 = int32(sum = zxt64(a.i2) - b.i2 - borrow);
	borrow = sum < ovf;
	c.i3 = int32(sum = zxt64(a.i3) - b.i3 - borrow);
	borrow = sum < ovf;
	c.i4 = int32(sum = zxt64(a.i4) - b.i4 - borrow);
	borrow = sum < ovf;
	c.i5 = int32(sum = zxt64(a.i5) - b.i5 - borrow);
	borrow = sum < ovf;
	c.i6 = int32(sum = zxt64(a.i6) - b.i6 - borrow);
	borrow = sum < ovf;
	c.i7 = int32(sum = zxt64(a.i7) - b.i7 - borrow);
	borrow = sum < ovf;
	c.i8 = int32(sum = zxt64(a.i8) - b.i8 - borrow);
	//~ borrow = sum < ovf;
} // */
} // +/

/* using emit; and emit();
//~ string alma = "alma a fa alatt";
//~ println(1 + 4);

int64 t1 = 314;
int64 t2 = emit();
int64 t3 = emit;
print(t2);
print(t3);

//~ t3 = 90;
//~ println(t3);
// */

/* using strings

long cikkId = 165;
long raktar = 3;
long btetelId = 6398;
double mennyiseg = 1;

define strlen = 25;

int8 val[strlen + 1];
val[strlen] = 0;

string str = string(val);

println("INSERT INTO gyariszam(cikk_id, mennyiseg, b_tetel_id, raktar_id, gyariszam) VALUES");
for (int i = 0; i < 40; i += 1) {

	for (int j = 0; j < strlen; j += 1)
		val[j] = random('a', 'z');

	print("("); print(cikkId);
	print(", "); print(mennyiseg);
	print(", "); print(btetelId);
	print(", "); print(raktar);
	print(", '"); print(str);
	println("'),");
}
// */

/+ hex view
int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
define n = 10;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
define eps = 1e-50;
double tmp = 1.;
double res = 1.;
//~ hex64 Res = emit();
for (int i = 1; tmp > eps; i += 1) {
	//~ double old = res;
	res += tmp /= i;
	//~ if (old == res) tmp = 0;
}
// */

/* test scope:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (0) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(0)

//~ */
