//~ #!/home/kmz/Desktop/Build/cc/main
//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c
//~ int a = 9;
//~ int &b = a;

define hex64 int64;	//%%016X
define hex32 int32;	//%%08x
void test(int test2(int test3)) {
}
/*
pointer p1 = realloc(null, 100);
pointer p2 = realloc(null, 200);
pointer p3 = realloc(null, 300);

//~ pointer p4 = realloc(p3, 200);

//~ realloc(null, 100);
//~ realloc(null, 200);
//~ realloc(null, 300);

realloc(null, 0);
*/

/*
int a[3][3];
//~ a[2][1] = 55;

{
	int i = 2;
	int j = 1;
	a[i][j] = 99;
}
*/
/*
//~ int a[2, 3, 4];
//~ float64 a[4, 4] = 0;
	//~ 1, 2, 3, 4,
	//~ 5, 6, 7, 8,
	//~ 1, 2, 3, 4,
	//~ 9, 0, 1, 2;

//~ string s = "alma a fa alatt";		// this should be dynamic.
//~ uint8 ss[4];
//~ int a = ss.length;
string x = "almax a fa alatt";
string ss[3];
ss[0] = x;//"alma1 a fa alatt";
ss[1] = "alma2 a fa alatt";
ss[2] = "alma3 a fa alatt";
string y = ss[1];

//~ ss[0][3] = 'A';

//~ println(y);
//~ println(ss[2]);

//~ string c = ss[0];
//~ putstr(c);

//~ int a = 9;
//~ int &b = null;
//~ &b = a;

//~ b = 88;
// */

//~ int alma(int h)[10];	???
//~ void fun(int x) = true ? null : void(int x){print(x);};
//~ void fun(int x) = null;

//~ mat4f a = mat4f( 1,  2,  3,  4,
				 //~ 5,  6,  7,  8,
				 //~ 9, 10, 11, 12,
				//~ 13, 14, 15, 16);


/*
struct Vec2{double x; double y;}
struct Vec3{double x; double y; double z;}
//~ struct Vec3{double x; double y; double z; double x1; double y1; double z1; double x2; double y2; double z2;}
//~ define Vec3(double x, double y, double z) = Vec3(x,y,z,x+1,y+1,z+1,x+2,y+2,z+2);

define ldv3(Vec3 ^a) = emit(Vec3, val(a));

//~ define add(Vec3 &a, Vec3 &b) = Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
define sub(Vec3 ^a, Vec3 ^b) = Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
//~ define mul(Vec3 &a, Vec3 &b) = Vec3(a.x * b.x, a.y * b.y, a.z * b.z);
//~ define div(Vec3 &a, Vec3 &b) = Vec3(a.x / b.x, a.y / b.y, a.z / b.z);
define div(Vec3 ^a, double ^b) = Vec3(a.x / b, a.y / b, a.z / b);

define dot(Vec3 ^a, Vec3 ^b) = double(a.x * b.x + a.y * b.y + a.z * b.z);
define cross(Vec3 ^a, Vec3 ^b) = Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
define divnz(Vec3 ^a, double ^b) = (b ? div(a, b) : a);
define normalize(Vec3 ^a) = divnz(a, sqrt(dot(a, a)));

int x1l;
Vec3 x3 = Vec3(1, 2, 3);
x3 = normalize(x3);
//~ */

/* static and nonstatic members.
struct alma {
	static int a0 = 9;
	const int a1;
	int a2;
}

int a = App.width;
string x = App.Xxx.width2;

//~ alma a = alma(12, 13);
//~ alma.a0 = 99;
//~ a = alma(a.a1, 0);

//~ int alma_a0 = alma.a0;

// */

/*
struct slice {
	const int length;
	const pointer value;
}

struct variant {
	const typeInfo &type;
	const pointer  value;
}

struct delegate {
	const int call(pointer value, int param1, ...);
	const pointer value;
}

*/
//~ int x = 179;
//~ int n = 2;
//~ const r = 3;
//~ int res = (x / pow(r, n)) % r;

//~ double aaa = .0e44;

hex32 x = 3 << 6;
/* iota
uint8 tmp[1024];
string str = emit(string, ref(tmp));
itoa(str, 1024, 10, 1, true, "");
//~ */
/*
struct:1 xrgb {
	uint8 b;
	uint8 g;
	uint8 r;
	uint8 x;
}
struct:0 xrgbi32 {
	xrgb rgb;
	int32 val;
}
//~ xrgb res = result;
//~ define min(int ^a, int ^b) = (a < b ? a : b);
//~ define clamp(int t, int a, int b) = min(max(t, a), b);

xrgb a = emit(xrgb, i32(0x801f008f));

//~ int structSize = xrgb.class.size;
//~ int objectSize = a.class.size;
//~ xrgb b = emit(a.typeOf, i32(0x1f002f));

//~ xrgb b = emit(xrgb, i32(0x2f3f1f));
//~ int r = a.r + b.r;

//~ xrgbi32 r;
//~ r.val = 0;

//~ r.rgb.r = min(a.r + b.r, 255);
//~ r.rgb.g = min(a.g + b.g, 255);
//~ r.rgb.b = min(a.b + b.b, 255);
// */

/* Bits: hi, lo, extend

define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend
define Lo64(int64 a) = emit(int32, set, i64(a));	// Lo32 part
define Hi64(int64 a) = emit(int32, pop, i64(a));	// Hi32 part
//~ define Lo32(int32 a) = int32(a & 0xffff);			// Lo16 part
//~ define Hi32(int32 a) = Lo32(a >> 16);				// Hi16 part
//~ define Lo16(int32 a) = int32(a & 0xff);				// Lo16 part
//~ define Hi16(int32 a) = Lo16(a >> 8);				// Hi16 part

//~ struct HL32{int32 lo; int32 hi;}
//~ define Lo64(int64 &a) = int32(emit(HL32, ref(a)).lo);	// Lo32 part
//~ define Hi64(int64 &a) = int32(emit(HL32, ref(a)).hi);	// Hi32 part

hex64 val = 0xff00ff00ff0f0f0f9;
hex32 lo = Lo64(val);
hex32 hi = Hi64(val);

// */
/* get 0 < n <= 64 bit minimum / maximum (signed/unsigned) values
define hex64 int64;	//%%016X
void bitsget(bool signed, int size, int64 &min, int64 &max) {
	int64 mask = bits.shr(int64(-1), -size);
	min = bits.shl(-int64(signed), size - 1);
	max = bits.and(min - 1, mask);
	//~ max = min;
}

hex64 min;
hex64 max;
hex64 umin;
hex64 umax;

int bitsize = 60;

bitsget(true, bitsize, min, max);
bitsget(!true, bitsize, umin, umax);
// */

/* call functions passed as argument to function

int method2(int x) {
	//~ putstr("!alma a fa alatt nyÃ¡ri piros alma\n");
	static int i = 0;
	result = i += x;
	println(result);
}
int method2() {result = method2(3);}
int method3() {result = method2(2);}

//~ /+	just call it
static if (true) {
	method2();
	method2();
	method2();
}// +/

//~ /+	call passed to another fun
void methodCall(int method()) {
	if (method != null) {
		int n = method();
	}
	else println("(null)");
}
methodCall(null);
methodCall(method3);
methodCall(method3);
methodCall(method3);
methodCall(method3);
methodCall(null);
//~ +/

/+	call as a reference
TODO
void method() = method3;

if (method != null) {
	method();
}
}
// +/

//~ */
/* return fun

/+ count down
struct Closure {int call(Closure &data); int data;}
define Invoke(Closure &wcd) = wcd.call(wcd);
//~ operator (Closure &wdc)() = wcd.call(wcd);

int countdown(Closure &a) {result = a.data; a.data -= 1;}

Closure a = Closure(countdown, 3);
Closure b = Closure(countdown, 30);

println(Invoke(a));
println(Invoke(b));
println(Invoke(a));
println(Invoke(a));
println(Invoke(a));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
// +/


/+var a = int delegate{int a = 3}(int n) {
	result = a;
	a -= n;
});

//~ sort_function(int array[0, 3, 4, 2, 5, 1], int function(int a, int b){return a.compareTo(b);})
//~ sort_delegate(int array[0, 3, 4, 2, 5, 1], int delegate{int xxx}(int a, int b){return a == b ? 0 : a > b ? 1 : -1;});

//~ int delegate(int) alma = null;		// 
//~ int function(int) alma = null;		// indirect reference to function
// +/

//~ /+ count down (2) with args
struct Closure {int64 call(Closure &c, int64 n); int64 data; int32 calls; /+...+/ }
define Closure(int64 call(Closure &c, int64 n), int64 data) = Closure(call, data, 0);

define Invoke(Closure &c, int64 n) = c.call(c, n);
//~ operator (Closure &c)(int64 n) = c.call(c, n);

int64 countdown(Closure &c, int64 n) {result = c.data; c.data -= n; c.calls += 1; }

Closure a = Closure(countdown, 90);

println(Invoke(a, 9));
println(Invoke(a, 2));
println(Invoke(a, 2));
println(Invoke(a, 2));

/+todo: 
	//~ var a = struct {data: int64(90), calls: int(0)};

	function a = function{data: int64(90), calls: int(0)} int(int64 n) {
		result = c.data;
		c.data -= n;
		c.calls += 1;
	};

	println(Invoke(a, 9));
	println(Invoke(a, 2));
	println(Invoke(a, 2));
	println(Invoke(a, 2));
		
// +/

// +/

//~ */
/* assignment by reference
struct ByRef {
	int a;
	int b;
}

ByRef a = ByRef(1, 2);
ByRef &b = a;
&b = null;
//~ int x = b.typeOf.sizeOf;
int size = int.sizeOf;
//~ */

/+ hex view: use: ./ccvm -c -x -O-2 test.cvx

int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
const n = 9;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
const eps = 1e-50;
double tmp = 1.;
double res = 1.;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* scope test:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (!true) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(false)

//~ */

/* iterating

/+
struct array_iterator {
	int arr[];
	int pos;
	int max;	// arr.length
}
array_iterator iterator(int a[]) {
	result.pos = 0;
	result.arr = a;
	result.max = a.length;
}
bool next(array_iterator &it, int &val) {
	if (result = it.pos < it.max) {
		val = it.arr[it.pos];
		it.pos += 1;
	}
}// +/

/+
define iterator(file &f) = emit(file, ref(f));
bool next(file &it, int &chr) {
	chr = fgetc(it);
	result = chr != -1;
}// +/

struct range {int min; int max;}
struct range_iterator {int pos; int max;}
define iterator(range ^r) = range_iterator(r.min, r.max);	// start at min, and end at max

bool next(range_iterator &it, int &val) {
	result = it.pos < it.max;
	if (result) {
		val = it.pos;
		it.pos += 1;
	}
}

for (int a : range(10, 16)) {
	println(a);
}

//~ */

//~ double a = emit(float64, i64(0x7FF0009000000000));
//~ double XXXa = emit(float64, i64(0b0111111111110000000000000000000000000000000000000000000000000000));
//~ double XXXb = emit(float64, i64(0b0011111111110000000000000000000000000000000000000000000000000000));

/* global variables cgen order
	struct alma {
		static int a1;
		static int a2;
		const int a3;
	}
static bool a;
static bool b() {

	//~ static alma dd;
	static bool c;
	static bool d() {
		if (1) {
			static bool e;
			static bool f;
		}
	}
	//~ static bool g;
	static bool h() {
		static bool i;
		static bool j;
	}
}
static bool k;
static bool l;
//~ */
/*
struct individual {
	bool gene[2][10];
	double xreal[2];
	double objectives[2];
	double constraints[2];

	const int rank;
	double constr_violation;
	const double xbin[10];
	//~ double crowd_dist;
}

struct population {
	double min;
	double max;
	individual ind[3];
}
/+
int fitness(individual &ind) {
	ind.objectives[0]= -pi1M(xbin[0],xbin[1]);
	ind.objectives[1]= -pi2M(xbin[0],xbin[1]); 

}

// +/

population pop;

//~ */
