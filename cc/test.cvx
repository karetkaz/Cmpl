//~ #open src/core.h
//~ #open src/core.c
//~ #open src/tree.c

//~ #open src/code.c			// virtual machine
//~ #open src/type.c			// type system
//~ #open src/parser.c			// input, lexer, parser
//~ #open src/printer.c			// pretty print, logger
//~ #open src/main.c

int intSize = typename(int64).size;
//~ int intSize2 = int64.size;
typename t1 = void;
typename t2 = int64;

/* Arrays, Pointers, References Alloc
define new(typename type) = memmgr(null, type.size);
define new(typename type, int32 ^n) = emit(struct, ref(memmgr(null, type.size * n)), i32(n));// creates a slice: {data, length}

//~ int64 &i32ref = new(int64);

int32 i32arr[] = new(int32, 100);

//~ for (int i = 0; i < arr2.length; i += 1) {
	//~ arr2[i] = i + 10;
//~ }

//~ int size = sizeof(arr2);
//~ */

/* sizeof
struct ss {
	int32 x;
	int32 y;
	struct ss {
		int64 x;
		int64 y;
	}
}

ss A = ss(1, 2);
ss.ss a = ss.ss(1, 2);

int n1 = sizeof(ss);
int n2 = sizeof(ss.ss);

//~ */
/* typename
struct ss {
	int32 x;
	int32 y;
	struct ss {
		int64 x;
		int64 y;
	}
}

ss A = ss(1, 2);
ss.ss a = ss.ss(1, 2);

typename t1 = ss;
typename t2 = ss.ss;

int n1 = sizeof(ss);
int n2 = sizeof(ss.ss);

//~ */

/* alloc / realloc / free
//~ define realloc(pointer ptr, int size) = memmgr(ptr, size);
define malloc(int size) = memmgr(null, size);
define free(pointer ptr) = memmgr(ptr, 0);

pointer p1 = null;
pointer p2 = null;
pointer p3 = null;
pointer p4 = null;

memmgr(null, 0);
p1 = malloc(160);
p2 = malloc(160);
p3 = malloc(160);
memmgr(null, 0);

if (true) {
	p3 = free(p3);
	p2 = free(p2);
	p1 = free(p1);
}
else {
	p1 = free(p1);
	p2 = free(p2);
	p3 = free(p3);
}

//~ realloc(null, 0);
//~ */

/* random floats
float32 frand() {
	uint32 randnum = rand() * rand();
	float32 tmp = emit(float32, i32((randnum >> 9 ) | 0x3f800000));
	result = tmp - 1;
}

float64 drand() {
	uint32 randnum1 = rand() * rand();
	uint32 randnum2 = rand() * rand();
	float64 tmp = emit(float64, i32(randnum1), i32((randnum2 >> 12) | 0x3ff00000));
	result = tmp - 1;
}

float maxrand = -1;
for(int i = 0; i < 30; i += 1) {
	float64 currand = drand();

	if (maxrand < currand)
		maxrand = currand;

	print("%f\n", currand);
}

// */

/* const ref assignment
struct m {
	static const int X = 9;
	const int a;
	int b;
	int c;// = 8;
}

m m1 = m(5, 9, 1);
int &ref_m1_a = m1.a;	// hacked: warn if const/nonconst ref assignment.
ref_m1_a = 666;

int x = m1.a;

// */

/* string arrays
string x = "almax a fa alatt";

string ss[3] = null;
ss[0] = x;//"alma1 a fa alatt";
ss[1] = "alma2 a fa alatt";
ss[2] = "alma3 a fa alatt";

string y;
y = ss[1];

//~ int iii[3] = 1, 2, 3;
//~ string sss[3] = x, "alma2 a fa alatt", "alma3 a fa alatt";
//~ string y = sss[0];
//~ sss[0][3] = 'A';

//~ println(y);
//~ print(ss[1]);
// */

//~ int &x = null;
//~ x = 4;

/* xrgb
struct xrgb:1 {
	uint8 b;
	uint8 g;
	uint8 r;
	uint8 x;
}
struct xrgbi32:0 {
	xrgb rgb;
	int32 val;
}
//~ xrgb res = result;
//~ define min(int ^a, int ^b) = (a < b ? a : b);
//~ define clamp(int t, int a, int b) = min(max(t, a), b);

xrgb a = emit(xrgb, i32(0x801f008f));

//~ int structSize = xrgb.class.size;
//~ int objectSize = a.class.size;
//~ xrgb b = emit(a.typeOf, i32(0x1f002f));

//~ xrgb b = emit(xrgb, i32(0x2f3f1f));
//~ int r = a.r + b.r;

//~ xrgbi32 r;
//~ r.val = 0;

//~ r.rgb.r = min(a.r + b.r, 255);
//~ r.rgb.g = min(a.g + b.g, 255);
//~ r.rgb.b = min(a.b + b.b, 255);
// */

//~ define dim = 10;
//~ static int x[dim][dim][dim][dim] = 690;
//~ static int x[dim][dim][dim][dim][dim] = 690;

//~ typename t = Complex;
//~ if (t == Complex) {
	//~ print("Complex\n");
//~ }
//~ float64 c;
//~ float64 x = Math.modf(Math.pi, &c);

/* invoke functions ...
int method0() {}
int method1(int x) {
	//~ print("!alma a fa alatt nyÃ¡ri piros alma\n");
	static int i = 0;
	result = i += x;
	print("%D\n", int64(result));
}
int method1() {result = method1(1);}
int method2() {result = method1(2);}

void methodCall(int method()) {
	if (method == null) {
		print("(null)\n");
		return;
	}
	//~ print("(xxxx)\n");
	int n = method();
	//~ print("%D\n", int64(n));
}

//~ /+	just call it
static if (true) {
	method1();
	method2();
}// +/

//~ /+	call passed to another fun
//~ methodCall(method1);	// this will not work because there are 2 method1 named functions
methodCall(null);
methodCall(method2);
//~ +/

//~ /+	call as a reference
int method() = null;//method2;

//~ method = null;

if (method != null) {
	method();
}

methodCall(method);

// +/

//~ */
/* return function ...

/+ count down
struct Closure {int call(Closure &data); int data;}
define Invoke(Closure &wcd) = wcd.call(wcd);
//~ operator (Closure &wdc)() = wcd.call(wcd);

int countdown(Closure &a) {result = a.data; a.data -= 1;}

Closure a = Closure(countdown, 3);
Closure b = Closure(countdown, 30);

println(Invoke(a));
println(Invoke(b));
println(Invoke(a));
println(Invoke(a));
println(Invoke(a));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
// +/

//~ /+ count down (2) with args
struct Closure{int64 call(Closure &c, int64 n); int64 data; int32 calls; /+...+/ }
define Closure(int64 call(Closure &c, int64 n), int64 data) = Closure(call, data, 0);

define Invoke(Closure c, int64 n) = c.call(&c, n);
//~ operator (Closure c)(int64 n) = c.call(c, n);

int64 countdown(Closure &c, int64 n) {result = c.data; c.data -= n; c.calls += 1; }

Closure a = Closure(countdown, 90);

print("%d\n", int64(Invoke(a, 9)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));
//~ +/
//~ */
/*BUG: assignment by reference

int64 a = 32;
//~ a = 33;
void setup() {
	//~ static int64 &b = a;
	print("%d\n", int64(a));
}
setup();
//~ */

/* factorial
define n = 6;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
define eps = 1e-50;
double tmp = 1.;
double res = 1.;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* iterating

struct range {
	int min;
	int max;
	//~ bool exclusive;
}

struct range_iterator {
	int pos;
	int max;
	//~ bool exclusive;
}

define iterator(range ^r) = range_iterator(r.min, r.max);	// start at min, and end at max

void printIT(int ri) {
	print("iterator {%d}\n", int64(ri));
}

void printIT(range_iterator ri) {
	print("iterator {");
	print("pos: %d", int64(ri.pos));
	print(", max: %d", int64(ri.max));
	//~ print(", excl: %d", int64(ri.exclusive));
	print("}\n");
}

bool next(range_iterator &it, int &val) {
	//~ result = it.pos - it.exclusive < it.max;
	result = it.pos < it.max;
	if (result) {
		val = it.pos;
		it.pos += 1;
	}
}
bool next(range_iterator &it, range_iterator &val) {
	//~ result = it.pos - it.exclusive < it.max;
	result = it.pos < it.max;
	if (result) {
		val = it;
		it.pos += 1;
	}
}

//~ /+
for (range_iterator it : range(10, 13)) {
	printIT(it);
}// +/

/+
for (int it : range(10, 13)) {
	printIT(it);
}// +/

/+ file
define iterator(file &f) = emit(file, ref(f));
bool next(file &it, int &chr) {
	chr = fgetc(it);
	result = chr != -1;
}// +/

//~ */

/*
double val = 9;//emit(float64, i64(0x7ff8000000000000));
print("0b%064B\n", val);
print("0x%016X\n", val);

println(int64(val));
println(float64(val));
double f64_nan = emit(float64, i64(0b0111111111111000000000000000000000000000000000000000000000000000));
double f64_inf = emit(float64, i64(0b0111111111110000000000000000000000000000000000000000000000000000));
double f64_one = emit(float64, i64(0b0011111111110000000000000000000000000000000000000000000000000000));
//~ */

/* enumeration
/+
struct vec4f {
	float32 x;
	float32 y;
	float32 z;
	float32 w;
}// +/

enum: vec4f {
	O = vec4f(0, 0, 0, 0);
	X = vec4f(1, 0, 0, 0);
	Y = vec4f(0, 1, 0, 0);
	Z = vec4f(0, 0, 1, 0);
}

vec4f z = Z;
// */

/*
struct individual {
	bool gene[2][10];
	double xreal[2];
	double objectives[2];
	double constraints[2];

	const int rank;
	double constr_violation;
	const double xbin[10];
	//~ double crowd_dist;
}

struct population {
	double min;
	double max;
	individual ind[1000];
}

//~ /+
define pi1M(double x, double y) = (x + y);
define pi2M(double x, double y) = (x + y);

int fitness(individual &ind) {
	ind.objectives[0]= -pi1M(ind.xbin[0], ind.xbin[1]);
	ind.objectives[1]= -pi2M(ind.xbin[0], ind.xbin[1]); 
}

// +/
//~ double size = 88006400 / double(1 << 20);
static population pop[3000];


//~ */
