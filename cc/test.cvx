//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

/* alloc / realloc / free
pointer p1;
pointer p2;
pointer p3;
pointer p4;
realloc(null, 0);
p1 = realloc(null, 160);
p2 = realloc(null, 160);
p3 = realloc(null, 160);
realloc(null, 0);

if (true) {
	p3 = realloc(p3, 0);
	p2 = realloc(p2, 0);
	p1 = realloc(p1, 0);
}
else {
	p1 = realloc(p1, 0);
	p2 = realloc(p2, 0);
	p3 = realloc(p3, 0);
}

//~ realloc(null, 100);
//~ realloc(null, 200);
//~ realloc(null, 300);

//~ realloc(null, 0);
//~ */
/*
//~ string s = "alma a fa alatt";		// this should be dynamic.
//~ uint8 ss[4];
//~ int a = ss.length;
string x = "almax a fa alatt";
//~ string ss[3];
//~ ss[0] = x;//"alma1 a fa alatt";
//~ ss[1] = "alma2 a fa alatt";
//~ ss[2] = "alma3 a fa alatt";
//~ string y = ss[1];

int iii[3] = 1, 2, 3;
string sss[3] = x, "a2", "a3";

//~ ss[0][3] = 'A';

//~ println(y);
//~ println(ss[2]);

//~ string c = ss[0];
//~ putstr(c);

//~ int a = 9;
//~ int &b = null;
//~ &b = a;

//~ b = 88;
// */

//~ ./main -C -i./lbit.dll -O2 -xd test.cvx
//~ int i = bitops.btc(0x1ff);

/* random floats
float32 frand() {
	uint32 randnum = rand() * rand();
	float32 tmp = emit(float32, i32((randnum >> 9 ) | 0x3f800000));
	result = tmp - 1;
}

float64 drand() {
	uint32 randnum1 = rand() * rand();
	uint32 randnum2 = rand() * rand();
	float64 tmp = emit(float64, i32(randnum1), i32((randnum2 >> 12) | 0x3ff00000));
	result = tmp - 1;
}

float maxrand = -1;
for(int i = 0; i < 30; i += 1) {
	float64 currand = drand();

	if (maxrand < currand)
		maxrand = currand;

	print("%f\n", currand);
}

// */

/* array as arguments
int arr1[20];
int a;

// 1. int maximum(int n, int arr[12])
// 2. int maximum(int n, int arr[])
// 3. int maximum(int n, int arr...)

int maximum(int length, int arr[20]) {
	result = arr[0];
	for (int i = 1; i < length; i += 1) {
		if (result < arr[i]) {
			result = arr[i];
		}
	}
}

a = maximum(arr1.length, arr1);


//~ */

//~ /* static and nonstatic members.
struct alma {
	static int a0 = 9;
	const int a1;
	int a2;
}

alma a = alma(12, 13);
alma.a0 = 99;
a = alma(a.a1, 0);

int alma_a0 = alma.a0;

// */

/* xrgb
struct:1 xrgb {
	uint8 b;
	uint8 g;
	uint8 r;
	uint8 x;
}
struct:0 xrgbi32 {
	xrgb rgb;
	int32 val;
}
//~ xrgb res = result;
//~ define min(int ^a, int ^b) = (a < b ? a : b);
//~ define clamp(int t, int a, int b) = min(max(t, a), b);

xrgb a = emit(xrgb, i32(0x801f008f));

//~ int structSize = xrgb.class.size;
//~ int objectSize = a.class.size;
//~ xrgb b = emit(a.typeOf, i32(0x1f002f));

//~ xrgb b = emit(xrgb, i32(0x2f3f1f));
//~ int r = a.r + b.r;

//~ xrgbi32 r;
//~ r.val = 0;

//~ r.rgb.r = min(a.r + b.r, 255);
//~ r.rgb.g = min(a.g + b.g, 255);
//~ r.rgb.b = min(a.b + b.b, 255);
// */

/* get 0 < n <= 64 bit minimum / maximum (signed/unsigned) values
define hex64 int64;//%%016X
void bitsget(bool signed, int size, int64 &min, int64 &max) {
	int64 mask = bits.shr(int64(-1), -size);
	min = bits.shl(-int64(signed), size - 1);
	max = bits.and(min - 1, mask);
}

hex64 min;
hex64 max;
hex64 umin;
hex64 umax;

int bitsize = 50;

bitsget(true, bitsize, &min, &max);
bitsget(!true, bitsize, &umin, &umax);
// */

/* call functions ...
int method0() {}
int method1(int x) {
	//~ print("!alma a fa alatt nyÃ¡ri piros alma\n");
	static int i = 0;
	result = i += x;
	print("%D\n", int64(result));
}
int method1() {result = method1(1);}
int method2() {result = method1(2);}

void methodCall(int method()) {
	if (method == null) {
		print("(null)\n");
		return;
	}
	//~ print("(xxxx)\n");
	int n = method();
	//~ print("%D\n", int64(n));
}

//~ /+	just call it
static if (true) {
	method1();
	method2();
}// +/

//~ /+	call passed to another fun
//~ methodCall(method1);	// this will not work because there are 2 method1 named functions
methodCall(null);
methodCall(method2);
//~ +/

//~ /+	call as a reference
int method() = null;//method2;

//~ method = null;

if (method != null) {
	method();
}

methodCall(method);

// +/

//~ */
/* return function ...

/+ count down
struct Closure {int call(Closure &data); int data;}
define Invoke(Closure &wcd) = wcd.call(wcd);
//~ operator (Closure &wdc)() = wcd.call(wcd);

int countdown(Closure &a) {result = a.data; a.data -= 1;}

Closure a = Closure(countdown, 3);
Closure b = Closure(countdown, 30);

println(Invoke(a));
println(Invoke(b));
println(Invoke(a));
println(Invoke(a));
println(Invoke(a));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
// +/

//~ /+ count down (2) with args
struct Closure {int64 call(Closure &c, int64 n); int64 data; int32 calls; /+...+/ }
define Closure(int64 call(Closure &c, int64 n), int64 data) = Closure(call, data, 0);

define Invoke(Closure &c, int64 n) = c.call(&c, n);
//~ operator (Closure &c)(int64 n) = c.call(c, n);

int64 countdown(Closure &c, int64 n) {result = c.data; c.data -= n; c.calls += 1; }

Closure a = Closure(countdown, 90);

print("%d\n", int64(Invoke(a, 9)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));

/+todo:
	function a = function{data: int64(90), calls: int(0)} int(int64 n) {
		result = c.data;
		c.data -= n;
		c.calls += 1;
	};

	println(Invoke(a, 9));
	println(Invoke(a, 2));
	println(Invoke(a, 2));
	println(Invoke(a, 2));


//~ sort_function(int array[0, 3, 4, 2, 5, 1], int function(int a, int b){return a.compareTo(b);})
//~ sort_delegate(int array[0, 3, 4, 2, 5, 1], int delegate{int xxx}(int a, int b){return a == b ? 0 : a > b ? 1 : -1;});

// +/

//~ */
/* assignment by reference

int64 a = 32;
a = 33;
void setup() {
	static int &b = a;
	print("%d\n", int64(b));
}
setup();

//~ */

/+ hex view: use: ./ccvm -c -x -O-2 test.cvx

int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
const n = 9;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
const eps = 1e-50;
double tmp = 1.;
double res = 1.;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* scope test:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (!true) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(false)

//~ */

/* iterating

/+
struct array_iterator {
	int arr[];
	int pos;
	int max;	// arr.length
}
array_iterator iterator(int a[]) {
	result.pos = 0;
	result.arr = a;
	result.max = a.length;
}
bool next(array_iterator &it, int &val) {
	if (result = it.pos < it.max) {
		val = it.arr[it.pos];
		it.pos += 1;
	}
}// +/

/+
define iterator(file &f) = emit(file, ref(f));
bool next(file &it, int &chr) {
	chr = fgetc(it);
	result = chr != -1;
}// +/

struct range {
	int min;
	int max;
	bool exclusive;
}

struct range_iterator {
	int pos;
	int max;
	bool exclusive;
}

define iterator(range ^r) = range_iterator(r.min, r.max, r.exclusive);	// start at min, and end at max

void println(range_iterator ri) {
	print("iterator {");
	print("pos: "); print(ri.pos);
	print(", max: "); print(ri.max);
	print(", excl: "); print(ri.exclusive);
	print("}\n");
}

bool next(range_iterator &it, int &val) {
	if (result = it.pos - it.exclusive < it.max) {
		val = it.pos;
		it.pos += 1;
	}
}
bool next(range_iterator &it, range_iterator &val) {
	if (result = it.pos - it.exclusive < it.max) {
		val = it;
		it.pos += 1;
	}
}

for (range_iterator a : range(10, 14, true)) {
	println(a);
}

//~ */

//~ const val = 0./0;
//~ print("0b%064B\n", emit(int64, f64(val)));
//~ print("0x%016X\n", emit(int64, f64(val)));
//~ double f64_nan = emit(float64, i64(0b0111111111111000000000000000000000000000000000000000000000000000));
//~ double f64_inf = emit(float64, i64(0b0111111111110000000000000000000000000000000000000000000000000000));
//~ double f64_one = emit(float64, i64(0b0011111111110000000000000000000000000000000000000000000000000000));

/+
int O(int a) {
	print("%d\n", int64(a));
	result = a;
}

int A = 31;
int b() {
	static int B = O(A);
	int c() {
		static int C = O(A);
		result = C;
	}
	result = c();
}
A = 33;
int d = b();
int e = b();

// +/

/* global variables cgen order
struct alma {
	static int a1;
	static int a2;
	const int a3;
}
static bool a;
static bool b() {

	//~ static alma dd;
	static bool c;
	static bool d() {
		if (1) {
			static bool e;
			static bool f;
		}
	}
	//~ static bool g;
	static bool h() {
		static bool i;
		static bool j;
	}
}
static bool k;
static bool l;
//~ */
/*
struct individual {
	bool gene[2][10];
	double xreal[2];
	double objectives[2];
	double constraints[2];

	const int rank;
	double constr_violation;
	const double xbin[10];
	//~ double crowd_dist;
}

struct population {
	double min;
	double max;
	individual ind[3];
}
/+
int fitness(individual &ind) {
	ind.objectives[0]= -pi1M(xbin[0],xbin[1]);
	ind.objectives[1]= -pi2M(xbin[0],xbin[1]); 

}

// +/

population pop;

//~ */
