//~ #!/home/kmz/Desktop/Build/cc/main
//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

//~ module test;

//~ vec4f Alma = vec4f(1., 2., 3., 4.);
//~ vec4f alma = emit(vec4f, swz.xzwy, val(Alma));

//~ int alma(int h)[10];	???
//~ void fun(int x) = true ? null : void(int x){print(x);});
/*
struct slice {
	int length;
	pointer value;
}

struct variant {
	const typeInfo &type;
	const pointer  value;
}

struct delegate {
	const int call(variant this, int param1, ...);
	const pointer  value;
}

define variant(typeInfo &type, pointer value) = emit(variant, ref(type), ptr(value));
define variant(int x) = variant(int, new int(x));
define variant(doubkle x) = variant(int, new double(x));

define var: variant;

var a = variant(10);

*/
/*
void printstr1(string a) {putstr(a);println();}
void printstr2(string &a) {putstr(a);println();}

int ttt(string s) {s = "alma33";}
int preinc(int &i) {result = i += 1;}
int postinc(int &i) {result = i; i += 1;}

string args[2];
args[0] = "alma";
args[1] = "korte";

println(args[0]);
printstr1(args[0]);
printstr2(args[0]);
//~ ttt(args[1]);

int i = 9;
int j = preinc(i);

string s = "korte";
//~ ttt(s);

//~ */

/* Bits: hi, lo, extend
define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend
define Lo64(int64 a) = emit(int32, set, i64(a));	// Lo32 part
define Hi64(int64 a) = emit(int32, pop, i64(a));	// Hi32 part
//~ define Lo32(int32 a) = int32(a & 0xffff);			// Lo16 part
//~ define Hi32(int32 a) = Lo32(a >> 16);				// Hi16 part
//~ define Lo16(int32 a) = int32(a & 0xff);				// Lo16 part
//~ define Hi16(int32 a) = Lo16(a >> 8);				// Hi16 part

//~ struct HL32{int32 lo; int32 hi;}
//~ define Lo64(int64 &a) = int32(emit(HL32, ref(a)).lo);	// Lo32 part
//~ define Hi64(int64 &a) = int32(emit(HL32, ref(a)).hi);	// Hi32 part

hex64 val = 0xff00ff00ff0f0f0f9;
hex32 lo = Lo64(val);
hex32 hi = Hi64(val);

// */
/* get 0 < n <= 64 bit minimum / maximum (signed/unsigned) values
//~ define hex64 int64;	//%%016X
void bitsget(bool signed, int size, int64 &min, int64 &max) {
	int64 mask = bits.shr(int64(-1), -size);
	min = bits.shl(-int64(signed), size - 1);
	max = bits.and(min - 1, mask);
	//~ max = min;
}

hex64 min;
hex64 max;

hex64 umin;
hex64 umax;

int bitsize = 64;

bitsget(true, bitsize, min, max);
bitsget(!true, bitsize, umin, umax);
// */
/*
//~ int i = 9;
//~ int8 arr[6];
//~ println(int(arr[9]));

//~ uint32 x = 30;
//~ uint32 y = x % 32;

int fn1(int64 a) {
	static int xxx = 99;
	static int fn2(int b) {
		result = b + xxx;
	}
	result = fn2(a);
}

int a = fn1(4);
// */

/* returning a function

//~ struct vardata {byte data...;}
//~ struct delegate {var call(vardata data...); vardata data...;}

//~ struct fnWrap {var call(var data); var &data;}
//~ define fnWrap(var data, var call(var data)) = emit(fnWrap, ref(fun), var(data));
/+
struct fnWrap {int call(int data); int data;}
define fnWrap(int call(int data), int data) = emit(fnWrap, ref(call), int(data));
define fnCall(fnWrap &wcd) = wcd.call(wcd.data);
//~ operator (fnWrap &wcd)() = wcd.call(wcd.data);
	// fnWrap test = fnWrap(fun1, 70);
	// int a = test();

//~ fnWrap test = fnWrap(70, int function(int a) {result = a * 8;});
//~ fnWrap test = fnWrap(70, new int[] {1, 2, 3, 4});

int fun1(int a) {result = a + 10;}
int fun2(int a) {result = a * 10;}

fnWrap test = fnWrap(fun1, 70);
int a = fnCall(test);
int b = fnCall(fnWrap(fun1, 50));
//~ +/

//~ /+ count down
struct fnWrap {int call(fnWrap &data); int data;}
define fnWrap(int call(fnWrap &data), int data) = emit(fnWrap, ref(call), i32(data));
define fnCall(fnWrap &wcd) = wcd.call(wcd);

int countdown(fnWrap &a) {result = a.data; a.data -= 1;}

fnWrap a = fnWrap(countdown, 3);
println(fnCall(a));
println(fnCall(a));
println(fnCall(a));
println(fnCall(a));
// +/

/+ count down
struct fnWrap {int call(fnWrap &data); int &data;}
define fnWrap(int call(fnWrap &data), int &data) = emit(fnWrap, ref(call), ref(data));
define fnCall(fnWrap &wcd) = wcd.call(wcd);

int countdown(fnWrap &a) {
	static int a2 = 99;
	result = a.data;
	a.data -= 1;
}

int n = 7;

fnWrap a = fnWrap(countdown, n);
println(fnCall(a));
println(fnCall(a));
println(fnCall(a));
println(fnCall(a));
//~ println(n);
//~ println(n);
// +/
//~ */

/* puthex
void puthex(int32 num) {
	if (num >= 16) {
		puthex(num / 16);
	}
	putchr("0123456789ABCDEF"[num % 16]);
}

int x = 0x0f00ff98;

puthex(x);
putchr('\n');
// */

/* call functions passed as argument to function
//~ void method() = null;

//~ /+

/+int postInc(int &a, int inc) {
	result = a;
	a += inc;
}
define postInc(int a) = postInc(a, 1);

//~ int x = 0;
//~ int x1 = postInc(x);
//~ int x2 = postInc(x);
//~ int x3 = postInc(x);
// +/

int method4() {}
int method5(int x) {}

//~ /+	the methods
int method2(int x) {
	//~ putstr("!alma a fa alatt ny√°ri piros alma\n");
	static int i = 0;
	result = i += x;
	println(result);
}
int method2() {result = method2(3);}
int method3() {result = method2(2);}
// +/

//~ /+	just call it
static if (true) {
	method2();
	method2();
	method2();
}// +/

//~ /+	call passed to another fun
void methodCall(int method()) {
	if (method != null) {
		int n = method();
	}
	else println("(null)");
}
methodCall(null);
methodCall(method3);
methodCall(method3);
methodCall(method3);
methodCall(method3);
methodCall(null);
//~ +/

/+	call as a reference
void methodV() {method2(2);}
//~ int method3() {}
//~ static 
if (true) {

void method() = methodV;

if (method != null) {
	method();
}
//~ else println("(null)");
}
// +/

//~ */

/* use: ./ccvm -c -x -O-2 test.cvx
debug1(1, 2, 3);

static int X = 1;
static int Y = 2;
static int Z = 3;

int x = 1;
int y = 2;
int z = 3;
//~ */

/* using strings

long cikkId = 165;
long raktar = 3;
long btetelId = 6398;
double mennyiseg = 1;

define strlen = 25;
define char uint8;
char val[strlen + 1];
val[strlen] = 0;

println("INSERT INTO gyariszam(cikk_id, mennyiseg, b_tetel_id, raktar_id, gyariszam) VALUES");
for (int i = 0; i < 40; i += 1) {

	for (int j = 0; j < strlen; j += 1)
		val[j] = rand('a', 'z');

	print("("); print(cikkId);
	print(", "); print(mennyiseg);
	print(", "); print(btetelId);
	print(", "); print(raktar);
	print(", '"); print(emit(string, ref(val)));
	println("'),");
}
// */

/* recursive
void recurse(int x) {
	if (x > 0) {
		print("pre: "); println(x);
		recurse(x - 1);
		print("post: "); println(x);
	}
}

recurse(20);
// */

/* clamp, lerp, smooth
//~ define e1 = double(2);
//~ define e1 = float(2);
float e1 = 0;
float e2 = 6;
float s = (e2 - e1) / 100;
for (float x = e1; x < e2; x += s) {	// x in [e1, e2]
	float t = (x - e1) / (e2 - e1);		// t in [0., 1.]
	//~ println(lerp(t, e1, e2));
	println(smooth(x, e1, e2));
	//~ println(clamp(t, .2, .6));
}
// */

/* cross, normalize
vec4f a = vec4f(1., 2., 3., 5.);
vec4f b = vec4f(0., 2., 0., 5.);
vec4f e = cross(a, b);
vec4f E = normalize(cross(vec4f(1., 2., 3.), vec4f(10., 20., 3.)));
// */

/* float compare
define __eps = 1e-15;
//~ define eq(float32 a, float32 b, float32 eps) = bool(abs(a - b) < eps);
define eq(float64 a, float64 b, float64 eps) = bool(abs(a - b) < eps);

//~ define eq(float32 a, float32 b) = eq(a, b, float32(__eps));
define eq(float64 a, float64 b) = eq(a, b, __eps);

define double1 float64;//%%2.10F

double1 a = .1; //%hexaban 0x%016X
double1 b = .2;
double1 c = .3;
double1 d = (a + b) + c; //%%.20f
double1 e = a + (b + c); //%%.20f
bool x = (a + b) + c == a + (b + c);
bool x1 = eq((a + b) + c, a + (b + c));

// */

/* random numbers
for (int i = 0; i < 60; i += 1) {
	println(rand(1., 1.001));
}
// */

/* itoa

void itoa(string dst, int val, int rad, int prc) {
	// the recursive one
	int _itoa(string dst, int32 num, int rad, int pad, int pos) {
		if (num > 0) {
			pos = _itoa(dst, num / rad, rad, pad - 1, pos + 1);
			dst[pos - 1] = "0123456789abcdefghijklmnopqrstuvwxyz"[num % rad];
		}
		else if (pad > 0) {
			pos = _itoa(dst, 0, rad, pad - 1, pos + 1);
			dst[pos - 1] = '0';
		}
		else {
			dst[pos] = '\0';
			pos = 0;
		}
		result = pos + 1;
	}
	if (rad < 36) {
		_itoa(dst, val, rad, prc, 0);
	}
	else {
		dst[0] = 0;
	}
}

void putrad(int32 num, int rad) {
	if (num >= rad) {
		putrad(num / rad, rad);
	}
	putchr("0123456789abcdefghijklmnopqrstuvwxyz"[num % rad]);
}

putrad(13, 7);println();
putrad(13, 2);println();

//~ println(args[0]);
//~ println(args[1]);
//~ println(args[2]);

/+for (int i = 0; i < 200; i += 1) {
	putrad(i, 10);
	putstr(" = ");
	putrad(i, 20);
	println();
}// +/

// */

/+ hex view: use: ./ccvm -c -x -O-2 test.cvx

int64 x = 0x84444444ffffffff;
hex64 xhex64[1] = emit();
hex32 xhex32[2] = emit();
hex16 xhex16[4] = emit();
hex8  xhex08[8] = emit();
// +/

/* factorial
const n = 6;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
const eps = 1e-50;
double tmp = 1.;
double res = 1.;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* test scope:

for (int i = 0; i < 20; i += 1) {int i2 = 9;}	// OK
for (int i = 0; i < 20; i += 1) {int i = 9;}	// ERR: i redefined
for (int i = 0; i < 20; i += 1) int i1 = 9;		// ERR: i2 unexpected

static if (!true) {int a = 99;}

int a2 = a;						// ERR: a undeclared if static if(false)

//~ */

/* iterating

/+struct array_iterator {
	int arr[];
	int pos;
	int max;	// arr.length
}
array_iterator iterator(int a[]) {
	result.pos = 0;
	result.arr = a;
	result.max = a.length;
}
bool next(array_iterator &it, int &val) {
	if (result = it.pos < it.max) {
		val = it.arr[it.pos];
		it.pos += 1;
	}
}// +/

/+define iterator(file &f) = emit(file, ref(f));
bool next(file &it, int &chr) {
	chr = fgetc(it);
	result = chr != -1;
}// +/

/+for (int a : range(0, 8)){/+...+/} => {
	iterator .it = iterator(range(0, 8));
	for (int a; next(.it, &a); ) {/+...+/}
}// +/

struct range {int min; int max;}
define range(int min, int max) = emit(range, i32(min), i32(max));

// iterate
struct range_iterator {int pos; int max;}
define range_iterator(int pos, int max) = emit(range_iterator, i32(pos), i32(max));

define iterator(range ^r) = range_iterator(r.min, r.max);	// start at min, and end at max
bool next(range_iterator &it, int &val) {
	result = it.pos < it.max;
	if (result) {
		val = it.pos;
		it.pos += 1;
	}
}

for (int a : range(10, 16)) {
	println(a);
}

//~ */

//~ double a = emit(float64, i64(0x7FF0009000000000));
double XXXa = emit(float64, i64(0b0111111111110000000000000000000000000000000000000000000000000000));
double XXXb = emit(float64, i64(0b0011111111110000000000000000000000000000000000000000000000000000));
