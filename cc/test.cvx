//~ src/ccvm.c
//~ src/pvmc.h
//~ ./main ="3 + 3 -4 + -2"

/* TODOS:
 * static if (true) does not enter new scope
 ? static if else part
 * nameless enum does not enter new scope
 ? nameless struct does not enter new scope
 * .
 ? separate struct and unoin declaration.
 *	in case of structures create a new constructor with all members; fix padding on stack.
 ?	in case of unions create a constructors with all members? or with the bigger.

 * default ctor from:
 *  	(basic types): ptr, basic types			// int(ptr), float(ptr), int(float), float(int)
 *  	(struct types): ptr, fields as param	// struct X{int a; float b;} => X(int a, float b)
 *  	(class types): box,
 * 
 ~ function argument cast bugs
 * TODO: define fact(int64 n) = (n * fact(n - 1));
 * define read(typename typ, pointer &ptr) = typ((ptr += sizeof(typ)) - sizeof(typ));
 * define write(typename typ, pointer &ptr, typ value) = memcpy((ptr += sizeof(typ)) - sizeof(typ), value);
 * 
 * int32 a = int(pointer(0xB8000));
 * pointer(0xB8000) := int32(9);
**/
/* TODOS(emit)
 * some emit opcodes should have const params
 * enable type as first param: emit(i32, f32(1)); see f32 as i32; remove void?
 * enable emit as param in emit: define mad(a, b, c) = emit(f32.add, f32.mul, f32(a), f32(b), f32(c));
 * 
**/
//~ define fact(int64 n) = (n * fact(n - 1));
//~ flt32 a = -math.nan;
//~ /*
/*enum vec4F: vec4f {
	X = vec4f(1, 0, 0, 1);
	Y = vec4f(0, 1, 0, 1);
	Z = vec4f(0, 0, 1, 1);
}*/
//~ vec4f a = int.X;
/*
enum alma2:int8 {
	//~ X = xyz(1, 0, 0);
	//~ Y = xyz(0, 1, 0);
	//~ Z = xyz(0, 0, 1);
	b = 3476;// = M.Phi;		// problems
	c;
}
//~ int a = alma2.b;

if (.9) {
	int a = 0.8;
}
//~ double a1 = M.Ln2;
//~ double a2 = M.Log2E;

//~ define  .add(flt32 x, flt32 y) = emit(f32.add, f32(y), f32(x));
//~ operator add(flt32 x, flt32 y) = emit(f32.add, f32(y), f32(x));

//~ operator clt(string x, string y) = bool(strcmp(x, y) < 0);
//~ operator cgt(string x, string y) = bool(strcmp(x, y) > 0);
//~ operator cle(string x, string y) = bool(strcmp(x, y) <= 0);
//~ operator cge(string x, string y) = bool(strcmp(x, y) >= 0);
//~ operator ceq(string x, string y) = bool(strcmp(x, y) == 0);
//~ operator cne(string x, string y) = bool(strcmp(x, y) != 0);
//~ */

/*enum Test {
	Emit = 8;
	Libc = 0;
	Type = 0;
} // */
/*static if (Test.Emit) {
static if (Test.Emit & 0x01) {
//~ flt32 res1 = emit(f32.div, f32(2), f32(math.pi));	// ok
//~ flt64 res2 = emit(f64.neg, f64(math.pi));			// ok
//~ flt32 res3 = emit(void, f32(math.pi));				// ok
//~ int32 res4 = emit(void, f32(math.pi));				// ok

emit(void, f64(math.pi));
int32 i32 = emit(void);
flt32 f32 = emit(void);
int64 i64 = emit(void);
flt64 f64 = emit(void);

}
static if (Test.Emit & 0x02) {
define shl(int32 value, int count) = emit(i32.shl, i32(count), i32(value));
define shr(int32 value, int count) = emit(i32.shr, i32(count), i32(value));
define shr(uns32 value, int count) = emit(u32.shr, i32(count), i32(value));

define add(flt32 a, flt32 b) = emit(f32.add, f32(b), f32(a));		// := a + b
define sub(flt32 a, flt32 b) = emit(f32.sub, f32(b), f32(a));
define mul(flt32 a, flt32 b) = emit(f32.mul, f32(b), f32(a));
define div(flt32 a, flt32 b) = emit(f32.div, f32(b), f32(a));
define mod(flt32 a, flt32 b) = emit(f32.mod, f32(b), f32(a));

define mad(flt32 a, flt32 b, flt32 c) = emit(f32.add, f32(c), f32(emit(f32.mul, f32(b), f32(a))));
define mad(flt64 a, flt64 b, flt64 c) = emit(f64.add, f64(c), f64(emit(f64.mul, f64(b), f64(a))));
define mad(int32 size, int32 index, int32 offset) = emit(u32.mad, i32(size), i32(index), i32(offset));

int a1 = shr(uns32(-1), 8);
int a2 = shr(int32(-1), 8);

//~ flt32 X1 = mad(2, 3, 4000);
flt32 X2 = mad(float(2), float(3), float(4000));
flt32 X3 = mad(2., 3., 4000.);

}
static if (Test.Emit & 0x04) {
define a_re = 3.;
define a_im = 4.;
define b_re = 2.;
define b_im = 5.;

enum prog {
	none;
	sisd;
	simd;
}

define test2exec = prog.sisd;
define times2exec = -10000000;

static if (times2exec < 0) {
	static if (test2exec == prog.sisd) {
		flt64 re = a_re * b_re - a_im * b_im;
		flt64 im = a_re * b_im + a_im * b_re;
	}

	static if (test2exec == prog.simd) {
		emit(v2d.mul, f64(b_im), f64(b_re), f64(a_im), f64(a_re));		// a.re * b.re, a.im * b.im
		flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
		emit(v2d.mul, f64(b_re), f64(b_im), f64(a_im), f64(a_re));		// a.re * b.im, a.im * b.re
		flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
	}
}

static if (times2exec > 0) {
	static if (test2exec == prog.sisd) {	// 28.689(10000000)
		for (int i = 0; i < times2exec; i += 1) {
			flt64 re = a_re * b_re - a_im * b_im;
			flt64 im = a_re * b_im + a_im * b_re;
		}
	}
	static if (test2exec == prog.simd) {	// 26.072(10000000)
		for (int i = 0; i < times2exec; i += 1) {
			emit(v2d.mul, f64(b_im), f64(b_re), f64(a_im), f64(a_re));		// a.re * b.re, a.im * b.im
			flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
			emit(v2d.mul, f64(b_re), f64(b_im), f64(a_im), f64(a_re));		// a.re * b.im, a.im * b.re
			flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
		}
	}
}
}
static if (Test.Emit & 0x08) {

vec4f v1 = emit(void, f32(11), f32(12), f32(13), f32(14));
vec4f v2 = emit(void, f32(21), f32(22), f32(23), f32(24));

//~ emit(swz.xywz);
//~ emit(v4f.add, f32(v1.x), f32(v1.y), f32(v1.z), f32(v1.w));
//~ emit(v4f.add);
//~ emit(v4f.dp3);
//~ 1+emit(v4f.dp3);

vec4f fv = emit(void);
flt32 sp[4] = emit(void);

//~ flt32 x0 = fv.x;
//~ flt32 y0 = fv.y;
//~ flt32 z0 = fv.z;
//~ flt32 w0 = fv.w;
//~ flt32 x = sp[0];
//~ flt32 y = sp[1];
//~ flt32 z = sp[2];
//~ flt32 w = sp[3];
//~ for (int i = 0; i < 4; i += 1)
	//~ sp[i] = i < 0;

//~ int32 i32 = emit(void);
//~ flt32 f32 = emit(void);
//~ int64 i64 = emit(void);
//~ flt64 f64 = emit(void);

//~ flt32 stop[] = new flt32[4];
//~ f64x2 res5 = emit(void, f64(1), f64(2));

}
} // */
/*static if (Test.Libc) {
int32 var = 0x00001080;		// input
int32 res = -1;
static if (Test.Libc == 1) {
int32 BSR = bsr(var);
if (var != 0) {
	uns32 ans = 0;
	uns32 x = var;
	//~ if (x & 0xffffffff00000000) { ans += 32; x >>= 32; }
	if (x & 0xffff0000) { ans += 16; x >>= 16; }
	if (x & 0x0000ff00) { ans +=  8; x >>=  8; }
	if (x & 0x000000f0) { ans +=  4; x >>=  4; }
	if (x & 0x0000000c) { ans +=  2; x >>=  2; }
	if (x & 0x00000002) { ans +=  1; }
	res = ans;
}
}
static if (Test.Libc == 2) {
int32 BHI = bhi(var);
if (var) {
	uns32 u = var;
	u |= u >> 1;
	u |= u >> 2;
	u |= u >> 4;
	u |= u >> 8;
	u |= u >> 16;
	res = u - (u >> 1);
}
}
static if (Test.Libc == 3) {
int32 SWP = swp(var);
if (var) {
	uns32 x = var;
	x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
	x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
	x = ((x >> 4) & 0x0F0F0F0F) | ((x & 0x0F0F0F0F) << 4);
	x = ((x >> 8) & 0x00FF00FF) | ((x & 0x00FF00FF) << 8);
	res = (x >> 16) | (x << 16);
}
//~+/
}
} // */
/*static if (Test.Type) {
static if (Test.Type == 1) {
enum M: flt64 {
	E		= 2.71828182845904523536028747135266249775724709369995957496696763;	// A001113
	Pi		= 3.14159265358979323846264338327950288419716939937510582097494459;	// A000796
	Phi		= 1.61803398874989484820458683436563811772030917980576286213544862;	// A001622
	Sqrt2	= 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
	SqrtE	= 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
	SqrtPi	= 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
	SqrtPhi	= 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
	Ln2		= 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
	Log2E	= 1. / Ln2;
	Ln10	= 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
	Log10E	= 1. / Ln10;
	Nan		= 0. / 0;
	Inf		= 1. / 0;
	//~ define isNan(flt64 a) = bool(a == a);
	//~ define isNan(flt32 a) = bool(a == a);
}

flt64 a = math.pi;
flt64 b = M.Pi;

}
static if (Test.Type == 2) {
}
static if (Test.Type == 3) {
}
static if (Test.Type == 4) {
}
} // */
/* Call Test X
/+	Basic functions
//~ define sqr(double a) = double(a * a);
//~ double res2 = sqrt(sqr(5.8));
//~ double a2z = sqr(2.5);

//~ flt32 dot3(vec4f a, vec4f b) = emit(v4f.dp3, v4f(b), v4f(a));
//~ flt32 dotH(vec4f a, vec4f b) = emit(v4f.dph, v4f(b), v4f(a));		// XXX
//~ flt32 dot4(vec4f a, vec4f b) = emit(v4f.dp4, v4f(b), v4f(a));
//~ vec4f rdiv(vec4f a, vec4f b) = emit(v4f.div, v4f(b), v4f(a));

//~ define .add(vec4f x, vec4f y) = emit(v4f.add, v4f(y), v4f(x));
//~ define .sub(vec4f x, vec4f y) = emit(v4f.sub, v4f(y), v4f(x));
//~ define Dot3(vec4f x, vec4f y) = emit(v4f.dp3, v4f(y), v4f(x));

//~ define ty flt32;
//~ ty abs(ty a) = a < 0 ? -a : a;
//~ ty sqr(ty a) = a * a;
//~ //ty a1 = sqr(1,2,3,4);			// error
//~ ty a2 = sqr(4);
//~ ty a3 = sqr(12);
//~ flt64 top[2] = emit(void, f64(1), f64(2));
//~ flt64 a = sin(math.pi / 2);
flt64 a = 9;
flt64 b = 3;
flt64 min = a < b ? a : b;
flt64 max = a > b ? a : b;

//~ flt64 A = 2 < 2 ? 3 : 4;
// +/
// */
/* Type Test X
/+ Math Constants
define E		= 2.71828182845904523536028747135266249775724709369995957496696763;	// A001113
define Pi		= 3.14159265358979323846264338327950288419716939937510582097494459;	// A000796
define Phi		= 1.61803398874989484820458683436563811772030917980576286213544862;	// A001622
define Sqrt2	= 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
define SqrtE	= 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
define SqrtPi	= 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
define SqrtPhi	= 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
define Ln2		= 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
define Log2E	= 1 / Ln2;
define Ln10		= 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
define Log10E	= 1 / Ln10;
//~ +/
/+	alias1
define Math math;
define nan = Math.nan;
bool c0 = math.isNan(0.);
bool c1 = Math.isNan(nan);
bool c2 = Math.isNan(math.nan);
bool c3 = math.isNan(Math.nan);
bool c3 = nan != nan;

//~ bool xxx = Math.nan != Math.nan;
//~ +/
/+X	struct
struct vec4d {
	struct vec3d {
		float x;
		float y;
		float z;
	};
	float x;
	float y;
	float z;
	float w;
}

define v4 vec4d;
define v3 vec4d.vec3d;

v3 v;
//~ v.x = 0;
//~ v.y = 1;
//~ v.z = 2;
//~ v = vec4d(1,2,3,4);

struct s1 {
struct s2 {
struct s3 {
struct s4 {
struct s5 {
struct s6 {
struct s7 {
	int a;
};
};
};
};
};
};
};

// +/
/+	function
double sqr(double x) = x * x;	// inline
int isNan(flt64 x) = x != x;
int isNan(flt32 x) = x != x;
//~ int isNan(int32 x) = x == 0x7fffffff;
//~ int isNan(int16 x) = x == 0x7fff;
//~ int isNan(int8 x) = x == 0x7f;

void count(flt32 x) {for (int i = 0; i < x; i += 1);}

double lerp(double a, double b, double t) = a + t * (b - a);
//~ int a = isNan(9);
int a = isNan(flt64(math.nan));
//~ int a = isNan(0x7fffffff);
//~ int x[] = emit(void);
//~ double a = 3;// + math.nan;
//~ double q = lerp(5, 7, .1);
//~ double X = count(5);
//~ int a = sqr(8);
// +/
/+	constant
//~ define ftype flt64;
//~ ftype isnan(ftype a) = bool(a != a);
//~ ftype b = +0.;
//~ ftype a = -0.;
//~ ftype c = 1/0.;
//~ ftype d = -1/0.;
//~ ftype e = 0/0.;
//~ bool w = a == b;
//~ bool x = isnan(e);

float v = 1 - 2 * math.pi;
int32 xxx = float(int(double(3)));
flt64 f = 1e310;
flt32 f32 = math.inf;
flt64 f64 = -math.inf;
flt64 f642 = f32;
flt32 f322 = f64;
//~ +/
/+X	operators

//~ define v4f32(flt32 xyz) = emit(v4f, f32(xyz), f32(xyz), f32(xyz), f32(xyz));
//~ define v4f32(flt32 x, flt32 y, flt32 z) = emit(v4f, f32(x), f32(y), f32(z), f32(1));

// class
v4f32 operator(flt32 x, flt32 y, flt32 z, flt32 w) = emit(v4f, f32(x), f32(y), f32(z), f32(w));

// object
void operator(v4f32 lhs) (flt32 x, flt32 y, flt32 z, flt32 w) {
	//~ usage: stupid
	//~ v4f32 a;
	//~ a(1,2,3,4);
	//~ a(1,2,9,4);
	
	lhs.x = x;
	lhs.y = y;
	lhs.z = z;
	lhs.w = w;
}

flt32 operator (v4f32 lhs) (flt32 val) {
	//~ usage:
	//~ v4f32 polyv4f = v4f32(1,2,3,4);
	//~ flt32 polyval = polyv4f(8);

	return ((((lhs.w) * val + lhs.z) * val + lhs.y) * val) + lhs.x;
}
flt32 operator (v4f32 lhs) [int32 idx] {
	if (idx == 0 || idx == 'x')
		return lhs.x;
	if (idx == 1 || idx == 'y')
		return lhs.y;
	if (idx == 2 || idx == 'z')
		return lhs.z;
	if (idx == 3 || idx == 'w')
		return lhs.w;
	return 0.0;

	//~ if (int[0, 'x'].has(idx))
		//~ return lhs.x;
}

v4f32 operator (v4f32 lhs) % (v4f32 rhs) {
	return v4f32.crs(lhs, rhs);
}
flt32 operator (v4f32 lhs) ^ (v4f32 rhs) {	// length
	v4f32 tmp = lhs - rhs;
	return v4f32.dp3(tmp, tmp);
}

//~ int operator -(int rhs) = emit(i32.add, rhs);
//~ int operator (int lhs) + (int rhs) = emit(i32.add, i32(rhs), i32(lhs));

//~ +/
/+ Complex: X
struct Complex {
	flt64 re;
	flt64 im;
}

//~ Complex operator -(Complex rhs) = Complex(-rhs.re, -rhs.im);
//~ Complex operator (Complex lhs) + (Complex rhs) = Complex(lhs.re + rhs.re, lhs.im + rhs.im);
//~ Complex operator (Complex lhs) - (Complex rhs) = Complex(lhs.re - rhs.re, lhs.im - rhs.im);

Complex operator -(Complex rhs) = emit(v2d.neg);
Complex operator (Complex lhs) + (Complex rhs) = emit(v2d.add);
Complex operator (Complex lhs) - (Complex rhs) = emit(v2d.sub);

define .sub(Complex lhs, Complex rhs) = emit(v2d.sub, v2d(rhs), v2d(lhs));

Complex operator (Complex a) * (Complex b) {
	emit(v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re));		// a.re * b.re, a.im * b.im
	flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
	emit(v2d.mul, f64(b.re), f64(b.im), f64(a.im), f64(a.re));		// a.re * b.im, a.im * b.re
	flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
	return Complex(re, im);
}

//~ +/
/+ Compare:
define ty flt64;
ty x = 5;
ty y = 5;
bool eq = x == y;
bool lt = x < y;
bool gt = x > y;

//~ bool ne = x != y;
//~ bool le = x <= y;
//~ bool ge = x >= y;
//~ +/

/+ ?reflect?
enum TypeCode:int8 {
	any = 0x00;		// error
	vid = 0x01;		// void;
	bit = 0x02;		// bool, uns32, uns16, uns8;
	int = 0x03;		// int64, int32, int16, int8;
	flt = 0x04;		// flt64, flt32;
	p4x = 0x05;		// (p2f64, p4f32), (p4f64, p8f32) (p2i64, p4i32, p8i16, p16i8), (p2u64, p4u32, p8u16, p16u8), ...
	arr = 0x06;		// pointer, string, array, ..., ???
	def = 0x07;		// struct, union, class, enum, 
	//~ enu
	//~ rec
	ref = 0x0f;		// variable
	//~ ATTR_ind = 0x10;		// indirect(pointer to)
}

/+struct TypeInfo {
	char file[];
	int32 line;

	char name[];
	int32 size;				// size / offset

	TypeInfo ref base;		// base type of TYPE_ref (void, int, float, struct, ...), return type of func
	TypeInfo ref args;		// record fields / function args
	TypeInfo ref next;		// next type, arg, 
	TypeCode code;			// TypeCode
}

bool instanceof(TypeInfo ty, ref obj) {
	for ( ; ty; ty = ty.base)
		if (ty == obj.type)
			return true;
	return false;
}

TypeInfo[] GetMethods(TypeInfo ty, string name) {
	TypeInfo result[], it;

	while (ty && ty.code != TYPE_ref) {

		for (it = ty.args; it; it = it.next) {

			if (it.code != TYPE_ref)
				continue;

			if (it.name != name)
				continue;

			if (it.call)
				result += it;
		}
		ty = ty.base;
	}

	return result;
}
TypeInfo[] GetMembers(TypeInfo ty, string name) {
	TypeInfo result[], it;

	while (ty && ty.code != TYPE_ref) {

		for (it = ty.args; it; it = it.next) {

			if (it.code != TYPE_ref)
				continue;

			if (it.name != name)
				continue;

			if (!it.call)
				result += it;
		}
		ty = ty.base;
	}

	return result;
}
TypeInfo[] GetNestedTypes(TypeInfo ty, string name) {
	TypeInfo *result[], *it;

	while (ty && ty.code != TYPE_ref) {

		for (it = ty.args; it; it = it.next) {

			if (it.code == TYPE_ref)
				continue;

			if (it.name != name)
				continue;

			if (!it.call)
				result += it;
		}
		ty = ty.base;
	}

	return result;
}
//~ define arguments(TypeInfo ty) = ty.args;

struct TypeBox {
	void* obj;
	TypeInfo* typ;
}

define BoxType(ref obj) = TypeBox(obj, obj.class);
define UnBoxType(TypeInfo obj) = TypeBox(obj, obj.class);
// +/

//~ +/

//~ define isNan(flt32 a) = (a != a);
//~ define isNan(flt64 a) = (a != a);
//~ flt64 nan = emit(void, i64(0x7ff8000000000000));
//~ int a = isNan(flt32(nan));

//~ double a = 345.41 + 18.18 -1e-14;//363.59;
//~ flt64 a1 = 1.e-1;
//~ flt64 a0 = emit(void, i64(0x3fb999999999999a));		//%08x
//~ double a2 = .0;
//~ double a3 = .0e1;
//~ double a = 9223372036854775807.;
//~ int64 max = 0x7fffffffffffffff;
//~ int64 max = 9223372036854775807;
//~ emit(void, i32(0xffffffff), i32(0x7fffffff));
//~ */

/*
int64 var = 0x00001080;		// input
int64 res = -1;
int64 BSR = bsr(var);
if (var != 0) {
	int64 ans = 0;
	int64 x = var;
	if (x & 0xffffffff00000000) { ans += 32; x >>= 32; }
	if (x & 0xffff0000) { ans += 16; x >>= 16; }
	if (x & 0x0000ff00) { ans +=  8; x >>=  8; }
	if (x & 0x000000f0) { ans +=  4; x >>=  4; }
	if (x & 0x0000000c) { ans +=  2; x >>=  2; }
	if (x & 0x00000002) { ans +=  1; }
	res = ans;
}//*/

/* try some stupid things
//~ define float flt64;
//~ define double flt32;
double res = 31.749 + .35;
//~ double res = 21.073 + .34;
//~ double res = 29.700 + .34;
// */

//~ /* struct and arrays
struct intflt32:0 {int32 i;flt32 f;}
struct intflt64:0 {int64 i;flt64 f;}
define intTY int8;
struct intabc: 4 {
	intTY X;		//~!%=(%?08b)
	intTY Y;		//~!%=(%?08b)
	intTY Z;		//~!%=(%?08b)
	//~ intTY W;		//!X%?03x
	intflt32 U;
}// */
//~ int intABC(int32 a, int32 b, int32 c) ;
//~ emit(void, i32(0));
//~ emit(void, f32(math.Snan));
//~ emit(void, i32(0));
//~ int32 c[3] = emit(void);
//~ flt32 d[3] = emit(void);
//~ d[2] = 9;

intabc alma;
//~ alma.U.f = 9;
alma.X = 8;
alma.Z = alma.X;
//~ intabc alma;
//~ alma.a = 9;
//~ int32 c[3] = emit(void);
//~ int i = 2;			//!%d

//~ int j;
// */

/* calc e
define eps = 1e-100;
double res = 1;
double tmp = 1;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */
/* factorial
define n = 5;
int64 res = 1;
for (int i = 1; i <= n; i += 1)
	res *= i;

// */

/* test if:
int i = 3;
flt64 a = 9;
if (a) {
	i = 0;
}
else {
	a = 2;
}
//~ */

/* test if:
int i = 3;
float a = 4;
if (i) {
	a = 0;
	if (i == 1) a = 1.1; else a = 2.1;
	if (i == 1) a = 1.2; else ;
	if (i == 1) ;else a = 2.2;
	if (i == 1) a = 3;

	else if (i == 2) a = 1.42;
	else if (i == 3) a = 1.43;
	else if (i == 4) a = 1.44;
	else if (i == 5) a = 1.45;
	else if (i == 6) a = 1.46;
}
else {
	if (a <= 5) {
		if (a < 2.5) i = 1;
		else i = 2;
	}
	else {
		if (a < 7.5) i = 3;
		else i = 4;
	}
}

// */
/* test if: 'when nothing happens'
if (1)
	{{{{{;;;};}};;;}{;;;}}
else
	{{;};;{;}}
//*/

/*+-
struct vec4f {
	flt32 x;
	flt32 y;
	flt32 z;
	flt32 w;
}

static if (useEmit) {
	operator + (vec4f rhs) = emit(vec4f, rhs);
	operator - (vec4f rhs) = vec4f(emit(v4f.neg, rhs));
	operator ~ (vec4f rhs) = vec4f(emit(v4f.rcp, rhs));
	operator (vec4f lhs) + (vec4f rhs) = vec4f(emit(v4f.add, lhs, rhs));

	define dp3(vec4f lhs, vec4f rhs) = flt32(emit(v4f.dp3, lhs, rhs));
	define dp4(vec4f lhs, vec4f rhs) = flt32(emit(v4f.dp4, lhs, rhs));
	define dph(vec4f lhs, vec4f rhs) = flt32(emit(v4f.dph, lhs, rhs));
}
else {
	operator + (vec4f rhs) = vec4f(+rhs.x, +rhs.y, +rhs.z, +rhs.w);
	operator - (vec4f rhs) = vec4f(-rhs.x, -rhs.y, -rhs.z, -rhs.w);
	operator ~ (vec4f rhs) = vec4f(1. / rhs.x, 1. / rhs.y, 1. / rhs.z, 1. / rhs.w);
	operator (vec4f lhs) + (vec4f rhs) = vec4f(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w);

	define dp4(vec4f lhs, vec4f rhs) = flt32(lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z + lhs.w * rhs.w);
	define dph(vec4f lhs, vec4f rhs) = flt32(lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z + lhs.w);
	define dp3(vec4f lhs, vec4f rhs) = flt32(lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z);
}

operator vec4f(flt32 x, flt32 y, flt32 z) = vec4f(x, y, z, 1);
operator vec4f(flt32 x) = vec4f(x, x, x, x);

operator flt32(vec4f vec) = vec.w;
operator bool(vec4f vec) = bool(vec.x && vec.y && vec.z && vec.w);


flt32 index(v4f32 vec, int32 idx) {
	if (idx == 0 || idx == 'x')
		return lhs.x;
	if (idx == 1 || idx == 'y')
		return lhs.y;
	if (idx == 2 || idx == 'z')
		return lhs.z;
	if (idx == 3 || idx == 'w')
		return lhs.w;
	return 0.0;
}

define peval(vec4f vec, flt32 val) = flt32((((vec.w * val + vec.z) * val + vec.y) * val) + vec.x);

define len(vec4f lhs) = sqrt(dp3(lhs, lhs));

operator (ref vec4f lhs) += (vec4f rhs) = (lhs = lhs + rhs);

// operator() d:"opCall"; cpp: "flt32 vec4f::operator () (flt32 val) {...}"
operator (vec4f vec) (flt32 val) = peval(vec, val);

// operator() d:"opIndex"; cpp: "flt32 vec4f::operator [] (int32 val) {...}"
operator (vec4f vec) [int32 idx] = index(vec, val);

struct Complex {
	flt64 re;
	flt64 im;
}
operator Complex(flt64 re, flt64 im) = emit(v2d, f64(re), f64(im));

operator -(Complex rhs) = Complex(-rhs.re, -rhs.im);
operator (Complex lhs) + (Complex rhs) = Complex(lhs.re + rhs.re, lhs.im + rhs.im);
operator (Complex lhs) - (Complex rhs) = Complex(lhs.re - rhs.re, lhs.im - rhs.im);

operator -(Complex rhs) = emit(v2d.neg);
operator (Complex lhs) + (Complex rhs) = emit(v2d.add, p4x(rhs), p4x(lhs));
operator (Complex lhs) - (Complex rhs) = emit(v2d.sub, p4x(rhs), p4x(lhs));

operator (Complex b) [int a] = double(a ? b.im : b.re);

operator sub(Complex lhs, Complex rhs) = emit(f64x2.sub, v2d(rhs), v2d(lhs));

Complex operator (Complex a) * (Complex b) {
	emit(v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re));		// a.re * b.re, a.im * b.im
	flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
	emit(v2d.mul, f64(b.re), f64(b.im), f64(a.im), f64(a.re));		// a.re * b.im, a.im * b.re
	flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
	return Complex(re, im);
}

// */
