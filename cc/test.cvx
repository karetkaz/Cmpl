//~ src/ccvm.h
//~ ./main ="3 + 3 -4 + -2"
//~ src/pvmc.h

/* HEX-Editors:
	Hackman Suite
	http://www.fairdell.com/hextemplate/
	http://www.1000files.com/free/hex-editor.html
	http://www.x-ways.net/winhex/templates/index.html

**/
/* TODOS:
 * static if (true) does not enter new scope
 * static if else part
 * nameless enum does not enter new scope
 ? nameless struct does not enter new scope
 * .
 ? separate struct and unoin declaration.
 *	in case of structures create a new constructor with all members; fix padding on stack.
 ?	in case of unions create a constructors with all members? or with the bigger.

 * Double parsing precision loss (Tokenizer): use parsef64 from util
 ~ function argument cast bugs
 * TODO: int fact(int n) = (n * fact(n - 1)); : castId(NULL) ??? why ?
 * 
**/
/* TODOS(emit)
 * some emit opcodes should have const params
 * enable type as first param: emit(i32, f32(1)); see f32 as i32; remove void?
 * enable emit as param in emit: define mad(a, b, c) = emit(f32.add, f32.mul, f32(a), f32(b), f32(c));
 * 
**/
//~ int fact(int n) = (n * fact(n - 1));
/*
static if (0) {
	int a = 1 + 2 * 3 + 4;
	int c = 1 * 2 + 3 * 4;
}
static if (0) {

	define usefloat = 0;

	static if (usefloat) {
		flt64 bcc;
	}

	static if (!usefloat) {
		int64 bcc;
	}

	bcc = 99;
}

//~ define scalar flt32; struct xyz:4{...}

enum M: flt64 {
	E		= 2.71828182845904523536028747135266249775724709369995957496696763;	// A001113
	Pi		= 3.14159265358979323846264338327950288419716939937510582097494459;	// A000796
	Phi		= 1.61803398874989484820458683436563811772030917980576286213544862;	// A001622
	Sqrt2	= 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
	SqrtE	= 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
	SqrtPi	= 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
	SqrtPhi	= 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
	Ln2		= 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
	Log2E	= 1. / Ln2;
	Ln10	= 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
	Log10E	= 1. / Ln10;
}

enum alma2:int8 {
	//~ X = xyz(1, 0, 0);
	//~ Y = xyz(0, 1, 0);
	//~ Z = xyz(0, 0, 1);
	b = 3476;// = M.Phi;		// problems
	c;
}
int a = alma2.b;

double a1 = M.Ln2;
double a2 = M.Log2E;

//~ define add(xx flt32 x, xx flt32 y) = emit(f32.add, f32(y), f32(x));
//~ operator .add(xx flt32 x, xx flt32 y) = emit(f32.add, f32(y), f32(x));

//~ operator .clt(string x, string y) = bool(strcmp(x, y) < 0);
//~ operator .cgt(string x, string y) = bool(strcmp(x, y) > 0);
//~ operator .cle(string x, string y) = bool(strcmp(x, y) <= 0);
//~ operator .cge(string x, string y) = bool(strcmp(x, y) >= 0);
//~ operator .ceq(string x, string y) = bool(strcmp(x, y) == 0);
//~ operator .cne(string x, string y) = bool(strcmp(x, y) != 0);
//~ operator .idx(string x, string y) = bool(strcmp(x, y) != 0);
//~ */

/* Emit Test K
//! int32 a = emit(void, f32(3.14));
//! int32 st[2] = emit(void);			// see the top of stack as int[2]
//! see program -emit

/+	Basic emits 1
int32 shl(int32 value, int count) = emit(i32.shl, i32(count), i32(value));
int32 sar(int32 value, int count) = emit(i32.sar, i32(count), i32(value));
int32 shr(int32 value, int count) = emit(i32.shr, i32(count), i32(value));

int a = shr(-1, 8);
//~ +/
/+	Basic emits
flt32 res1 = emit(f32.div, f32(2), f32(math.pi));	// ok
flt64 res2 = emit(f64.neg, f64(math.pi));			// ok
flt32 res3 = emit(void, f32(math.pi));				// ok
int32 res4 = emit(void, f32(math.pi));				// ok

emit(void, f64(math.pi));
int32 i32 = emit(void);
flt32 f32 = emit(void);
int64 i64 = emit(void);
flt64 f64 = emit(void);

//~ +/
/+	swizzle test
vec4f swz1 = emit(swz.xyzw, f32(math.pi/8), f32(math.pi/4), f32(math.pi/2), f32(math.pi));
//~ vec4f swz2 = emit(swz.xzwy, f32(1/2), f32(2/2), f32(3/2), f32(4/2));
//~ +/
/+	vector 4xf32 test
emit(void, f32(11), f32(12), f32(13), f32(14));
emit(void, f32(21), f32(22), f32(23), f32(24));
emit(v4f.div);
f32x4 swz1 = emit(void);
//~ flt32 vdot = emit(v4f.dp4);
flt32 sp[4] = emit(void);
flt32 x = sp[0];
//~ flt32 y = swz1.x;

//~ flt32 stop[4] = new flt32[4];
//~ f64x2 res5 = emit(void, f64(1), f64(2));
//~ +/
/+	Complex mul
define a_re = 3.;
define a_im = 4.;
define b_re = 2.;
define b_im = 5.;

enum prog {
	sisd = 9;
	simd;
	none;
}

define test2exec = prog.sisd;
define times2exec = -1000000;

static if (times2exec < 0) {
	static if (test2exec == prog.sisd) {
		flt64 re = a_re * b_re - a_im * b_im;
		flt64 im = a_re * b_im + a_im * b_re;
	}

	static if (test2exec == prog.simd) {
		emit(v2d.mul, f64(b_im), f64(b_re), f64(a_im), f64(a_re));		// a.re * b.re, a.im * b.im
		flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
		emit(v2d.mul, f64(b_re), f64(b_im), f64(a_im), f64(a_re));		// a.re * b.im, a.im * b.re
		flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
	}
}

static if (times2exec > 0) {
	static if (test2exec == prog.sisd) {	// 28.689(10000000)
		for (int i = 0; i < times2exec; i += 1) {
			flt64 re = a_re * b_re - a_im * b_im;
			flt64 im = a_re * b_im + a_im * b_re;
		}
	}
	static if (test2exec == prog.simd) {	// 26.072(10000000)
		for (int i = 0; i < times2exec; i += 1) {
			emit(v2d.mul, f64(b_im), f64(b_re), f64(a_im), f64(a_re));		// a.re * b.re, a.im * b.im
			flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
			emit(v2d.mul, f64(b_re), f64(b_im), f64(a_im), f64(a_re));		// a.re * b.im, a.im * b.re
			flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
		}
	}
}

//~ +/

//~ */
/* Libc Test K
int32 var = 0x00001080;
int32 res = -1;
//~ /+	// public static int bsr(int i)
//~ int32 lib = bsr(var);
if (var != 0) {
	uns32 ans = 0;
	uns32 x = var;
	if (x & 0xffff0000) { ans += 16; x >>= 16; }
	if (x & 0x0000ff00) { ans +=  8; x >>=  8; }
	if (x & 0x000000f0) { ans +=  4; x >>=  4; }
	if (x & 0x0000000c) { ans +=  2; x >>=  2; }
	if (x & 0x00000002) { ans +=  1; }
	res = ans;
}
//~+/
/+	// public static int hi1(int i)
int32 lib = bhi(var);
if (var) {
	uns32 u = var;
	u |= u >> 1;
	u |= u >> 2;
	u |= u >> 4;
	u |= u >> 8;
	u |= u >> 16;
	res = u - (u >> 1);
}
//~+/
/+	// public static int lo1(int i)
	res = var & -var;
//~+/
/+	// public static int bitswap(uns i)
int32 lib = swp(var);
if (var) {
	uns32 x = var;
	x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
	x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
	x = ((x >> 4) & 0x0F0F0F0F) | ((x & 0x0F0F0F0F) << 4);
	x = ((x >> 8) & 0x00FF00FF) | ((x & 0x00FF00FF) << 8);
	res = (x >> 16) | (x << 16);
}
//~+/
//~*/
/* Call Test X
/+	Basic functions
//~ double sqr(double a) = double(a * a);
//~ double res2 = sqrt(sqr(5.8));
//~ double a2z = sqr(2.5);

//~ flt32(int32 x) = emit(i32.f32, i32(x));
//~ flt32(int32 x) = emit(i32.f32, i32(x));

//~ flt32 dot3(vec4f a, vec4f b) = emit(v4f.dp3, v4f(b), v4f(a));
//~ flt32 dotH(vec4f a, vec4f b) = emit(v4f.dph, v4f(b), v4f(a));		// XXX
//~ flt32 dot4(vec4f a, vec4f b) = emit(v4f.dp4, v4f(b), v4f(a));
//~ vec4f rdiv(vec4f a, vec4f b) = emit(v4f.div, v4f(b), v4f(a));

//~ define .add(vec4f x, vec4f y) = emit(v4f.add, v4f(y), v4f(x));
//~ define .sub(vec4f x, vec4f y) = emit(v4f.sub, v4f(y), v4f(x));
//~ define Dot3(vec4f x, vec4f y) = emit(v4f.dp3, v4f(y), v4f(x));

//~ define ty flt32;
//~ ty abs(ty a) = a < 0 ? -a : a;
//~ ty sqr(ty a) = a * a;
//~ //ty a1 = sqr(1,2,3,4);			// error
//~ ty a2 = sqr(4);
//~ ty a3 = sqr(12);
//~ flt64 top[2] = emit(void, f64(1), f64(2));
//~ float a = sin(math.pi);
// +/
// */

/+ Type Test X
/+ Math Constants
define E		= 2.71828182845904523536028747135266249775724709369995957496696763;	// A001113
define Pi		= 3.14159265358979323846264338327950288419716939937510582097494459;	// A000796
define Phi		= 1.61803398874989484820458683436563811772030917980576286213544862;	// A001622
define Sqrt2	= 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
define SqrtE	= 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
define SqrtPi	= 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
define SqrtPhi	= 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
define Ln2		= 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
define Log2E	= 1 / Ln2;
define Ln10		= 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
define Log10E	= 1 / Ln10;
//~ +/
/+	alias1
define Math math;
define nan = Math.nan;
bool c0 = math.isNan(0.);
bool c1 = Math.isNan(nan);
bool c2 = Math.isNan(math.nan);
bool c3 = math.isNan(Math.nan);

//~ bool xxx = Math.nan != Math.nan;
//~ +/
/+	alias
define myint uns16;
int64 min = myint.min;
int64 max = myint.max;
int64 msk = myint.mask;
int64 bts = myint.bits;
int64 size = myint.size;
//~ +/
/+X	struct
struct vec4d {
	struct vec3d {
		float x;
		float y;
		float z;
	};
	float x;
	float y;
	float z;
	float w;
}

define v4 vec4d;
define v3 vec4d.vec3d;

v3 v;
//~ v.x = 0;
//~ v.y = 1;
//~ v.z = 2;
//~ v = vec4d(1,2,3,4);

struct s1 {
struct s2 {
struct s3 {
struct s4 {
struct s5 {
struct s6 {
struct s7 {
	int a;
};
};
};
};
};
};
};

// +/
/+	function
double sqr(double x) = x * x;	// inline
int isNan(flt64 x) = x != x;
int isNan(flt32 x) = x != x;
//~ int isNan(int32 x) = x == 0x7fffffff;
//~ int isNan(int16 x) = x == 0x7fff;
//~ int isNan(int8 x) = x == 0x7f;

void count(flt32 x) {for (int i = 0; i < x; i += 1);}

double lerp(double a, double b, double t) = a + t * (b - a);
//~ int a = isNan(9);
int a = isNan(flt64(math.nan));
//~ int a = isNan(0x7fffffff);
//~ int x[] = emit(void);
//~ double a = 3;// + math.nan;
//~ double q = lerp(5, 7, .1);
//~ double X = count(5);
//~ int a = sqr(8);
// +/
/+	constant
//~ define ftype flt64;
//~ ftype isnan(ftype a) = bool(a != a);
//~ ftype b = +0.;
//~ ftype a = -0.;
//~ ftype c = 1/0.;
//~ ftype d = -1/0.;
//~ ftype e = 0/0.;
//~ bool w = a == b;
//~ bool x = isnan(e);

float v = 1 - 2 * math.pi;
int32 xxx = float(int(double(3)));
flt64 f = 1e310;
flt32 f32 = math.inf;
flt64 f64 = -math.inf;
flt64 f642 = f32;
flt32 f322 = f64;
//~ +/
/+X	operators

//~ define v4f32(flt32 xyz) = emit(v4f, f32(xyz), f32(xyz), f32(xyz), f32(xyz));
//~ define v4f32(flt32 x, flt32 y, flt32 z) = emit(v4f, f32(x), f32(y), f32(z), f32(1));
//~ define v4f32(flt32 x, flt32 y, flt32 z, flt32 w) = emit(v4f, f32(x), f32(y), f32(z), f32(w));

// class
v4f32 operator(flt32 x, flt32 y, flt32 z, flt32 w) = emit(v4f, f32(x), f32(y), f32(z), f32(w));

// object
void operator(v4f32 lhs) (flt32 x, flt32 y, flt32 z, flt32 w) {
	//~ usage: stupid
	//~ v4f32 a;
	//~ a(1,2,3,4);
	//~ a(1,2,9,4);
	
	lhs.x = x;
	lhs.y = y;
	lhs.z = z;
	lhs.w = w;
}

flt32 operator (v4f32 lhs) (flt32 val) {
	//~ usage:
	//~ v4f32 polyv4f = v4f32(1,2,3,4);
	//~ flt32 polyval = polyv4f(8);

	return ((((lhs.w) * val + lhs.z) * val + lhs.y) * val) + lhs.x;
}
flt32 operator (v4f32 lhs) [int32 idx] {
	if (idx == 0 || idx == 'x')
		return lhs.x;
	if (idx == 1 || idx == 'y')
		return lhs.y;
	if (idx == 2 || idx == 'z')
		return lhs.z;
	if (idx == 3 || idx == 'w')
		return lhs.w;
	return 0.0;

	//~ if (int[0, 'x'].has(idx))
		//~ return lhs.x;
}

v4f32 operator (v4f32 lhs) % (v4f32 rhs) {
	return v4f32.crs(lhs, rhs);
}
flt32 operator (v4f32 lhs) ^ (v4f32 rhs) {	// length
	v4f32 tmp = lhs - rhs;
	return v4f32.dp3(tmp, tmp);
}

//~ int operator -(int rhs) = emit(i32.add, rhs);
//~ int operator (int lhs) + (int rhs) = emit(i32.add, i32(rhs), i32(lhs));

//~ +/
/+ Complex: X
struct Complex {
	flt64 re;
	flt64 im;
}
Complex operator new(flt64 re, flt64 im) = emit(v2d, f64(re), f64(im));

//~ Complex operator -(Complex rhs) = Complex(-rhs.re, -rhs.im);
//~ Complex operator (Complex lhs) + (Complex rhs) = Complex(lhs.re + rhs.re, lhs.im + rhs.im);
//~ Complex operator (Complex lhs) - (Complex rhs) = Complex(lhs.re - rhs.re, lhs.im - rhs.im);

Complex operator -(Complex rhs) = emit(v2d.neg);
Complex operator (Complex lhs) + (Complex rhs) = emit(v2d.add);
Complex operator (Complex lhs) - (Complex rhs) = emit(v2d.sub);

define .sub(Complex lhs, Complex rhs) = emit(v2d.sub, v2d(rhs), v2d(lhs));

Complex operator (Complex a) * (Complex b) {
	emit(v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re));		// a.re * b.re, a.im * b.im
	flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
	emit(v2d.mul, f64(b.re), f64(b.im), f64(a.im), f64(a.re));		// a.re * b.im, a.im * b.re
	flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
	return Complex(re, im);
}

//~ +/
/+ Compare:
define ty flt64;
ty x = 5;
ty y = 5;
bool eq = x == y;
bool lt = x < y;
bool gt = x > y;

//~ bool ne = x != y;
//~ bool le = x <= y;
//~ bool ge = x >= y;
//~ +/

/+ ?reflect?
enum TypeCode:int8 {
	TYPE_any = 0x00;		// error
	TYPE_void = 0x01;		// void;
	TYPE_bit = 0x02;		// bool, uns32, uns16, uns8;
	TYPE_int = 0x03;		// int64, int32, int16, int8;
	TYPE_flt = 0x04;		// flt64, flt32;
	TYPE_p4x = 0x05;		// (p2f64, p4f32), (p4f64, p8f32) (p2i64, p4i32, p8i16, p16i8), (p2u64, p4u32, p8u16, p16u8), ...
	TYPE_??? = 0x06;		// pointer, string, array, ..., ???
	TYPE_def = 0x07;		// struct, union, class?
	//~ TYPE_enu
	//~ TYPE_rec
	//~ TYPE_fun
	TYPE_ref = 0x0f;		// variable
	//~ ATTR_ind = 0x10;		// indirect(pointer to)
}

struct TypeInfo {
	char file[];
	int32 line;

	char name[];
	int32 size;				// size / offset

	TypeInfo ref base;		// base type of TYPE_ref (void, int, float, struct, ...), return type of func
	TypeInfo ref args;		// record fields / function args
	TypeInfo ref next;		// next type, arg, 
	TypeCode code;			// TypeCode
}

bool instanceof(TypeInfo ty, ref obj) {
	for ( ; ty; ty = ty.base)
		if (ty == obj.type)
			return true;
	return false;
}

TypeInfo[] GetMethods(TypeInfo ty, string name) {
	TypeInfo result[], it;

	while (ty && ty.code != TYPE_ref) {

		for (it = ty.args; it; it = it.next) {

			if (it.code != TYPE_ref)
				continue;

			if (it.name != name)
				continue;

			if (it.call)
				result += it;
		}
		ty = ty.base;
	}

	return result;
}
TypeInfo[] GetMembers(TypeInfo ty, string name) {
	TypeInfo result[], it;

	while (ty && ty.code != TYPE_ref) {

		for (it = ty.args; it; it = it.next) {

			if (it.code != TYPE_ref)
				continue;

			if (it.name != name)
				continue;

			if (!it.call)
				result += it;
		}
		ty = ty.base;
	}

	return result;
}
TypeInfo[] GetNestedTypes(TypeInfo ty, string name) {
	TypeInfo *result[], *it;

	while (ty && ty.code != TYPE_ref) {

		for (it = ty.args; it; it = it.next) {

			if (it.code == TYPE_ref)
				continue;

			if (it.name != name)
				continue;

			if (!it.call)
				result += it;
		}
		ty = ty.base;
	}

	return result;
}
//~ define arguments(TypeInfo ty) = ty.args;

struct TypeBox {
	void* obj;
	TypeInfo* typ;
}

define BoxType(ref obj) = TypeBox(obj, obj.class);
define UnBoxType(TypeInfo obj) = TypeBox(obj, obj.class);
// +/

//~ +/

//~ define isNan(flt32 a) = (a != a);
//~ define isNan(flt64 a) = (a != a);

define add(flt32 a, flt32 b) = emit(f32.add, f32(b), f32(a));		// := a + b
define sub(flt32 a, flt32 b) = emit(f32.sub, f32(b), f32(a));
define mul(flt32 a, flt32 b) = emit(f32.mul, f32(b), f32(a));
define div(flt32 a, flt32 b) = emit(f32.div, f32(b), f32(a));
define mod(flt32 a, flt32 b) = emit(f32.mod, f32(b), f32(a));

//~ define mad1(flt32 a, flt32 b, flt32 c) = emit(f32.add, f32(c), emit(f32.mul), f32(b), f32(a));
//~ define mad1(flt32 a, flt32 b, flt32 c) = emit(f32.add, f32(c), f32.mul, f32(b), f32(a));
//~ define mad(flt32 a, flt32 b, flt32 c) = add(mul(a, b), c);
//~ define mad(flt32 a, flt32 b, flt32 c) = add(mul(a, b), c);
define mad(uns32 size, uns32 index, uns32 offset) = emit(u32.mad, i32(size), i32(index), i32(offset));
//~ define mad(flt32 a, flt32 b, flt32 c) = (a * b + c);

//~ flt32 X = div(add(0, 1), add(0, 2));
flt32 X1 = mad(2, 3, 4000);
//~ flt32 X2 = emit(u32.mad, i32(4), i32(3), i32(2));
//~ flt32 X2 = emit(f32.add, f32(3), f32.mul, f32(2), f32(1));
//~ flt32 X3 = emit(f32.add, f32(emit(f32.mul)), f32(4), f32(3), f32(2));

//~ /*
struct intabc {
	int32 a;		//! @format %04x
	int32 b;		//! @format %04x
	int32 c;		//! @format %04x
}

emit(void, i32(10), i32(20), i32(30));
intabc xx1 = emit(void);
int xx2[3] = emit(void);

xx1.b = 2;
//~ xx2[0] = 2;

//~ define .idx(flt32 a, flt32 b) = emit(f32.sub, f32(b), f32(a));
//~ define .idx(flt32 a, flt32 b) = emit(f32.sub, f32(b), f32(a));
//~ operator (flt32 a) - (flt32 b) = emit(f32.sub);
//~ flt32 a = emit(f32.sub, f32(1), f32(2));
//~ */

/* calc e
//~ define double float;
define eps = 1e-20;
double res = 1;
double tmp = 1;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */
/* factorial
define n = 29;
int64 res = 1;
for (int i = 1; i <= n; i += 1)
	res *= i;

// */
/* static test
enum use {
	none = 0;
	_int = 1;
	_flt = 2;
};

define u = use._flt;

static if (u == use._int) {
	int32 a = 9;
}
static if (u == use._flt) {
	flt32 a = 9;
}
int64 a2 = a;
*/

/* test if:
int i = 3;
flt64 a = 9;
if (a) {
	i = 0;
}
else {
	a = 2;
}
//~ */

/* test if:
int i = 3;
float a = 4;
if (i) {
	a = 0;
	if (i == 1) a = 1.1; else a = 2.1;
	if (i == 1) a = 1.2; else ;
	if (i == 1) ;else a = 2.2;
	if (i == 1) a = 3;

	else if (i == 2) a = 1.42;
	else if (i == 3) a = 1.43;
	else if (i == 4) a = 1.44;
	else if (i == 5) a = 1.45;
	else if (i == 6) a = 1.46;
}
else {
	if (a <= 5) {
		if (a < 2.5) i = 1;
		else i = 2;
	}
	else {
		if (a < 7.5) i = 3;
		else i = 4;
	}
}

// */
/* test if: 'when nothing happens'
if (1)
	{{{{{;;;};}};;;}{;;;}}
else
	{{;};;{;}}
//*/
/* test if: isNan(val)
double isNan(flt32 x) = bool(x != x);
flt64 val = math.nan;
bool isNan1 = isNan(val);
//~ bool isNan2 = val != val;
// */

/* RayTrace
define rgb int32;
define qual = 1;
define width = 320 << qual;
define height = 240 << qual;

rgb cBuff[width * height];

define cBuff(int x, int y) = (Buff[y * width + x]);

/+
for (int i = 0; i < height; i += 1)
	for (int j = 0; j < width; j += 1)
		cBuff(i, j) := i ^ j;
// +/

class vec4f {
	flt32 x;
	flt32 y;
	flt32 z;
	flt32 w;
	//~ static this() {}
	this() {x = y = z = w = 0;}
	this(flt32 x) {this.x = this.y = this.z = x; this.w = 1;}
	this(flt32 x, flt32 y, flt32 z) {this.x = x; this.y = y; this.z = z; this.w = 0;}
	this(flt32 x, flt32 y, flt32 z, flt32 w) {this.x = x; this.y = y; this.z = z; this.w = w;}

	vec4f operator +(vec4f lhs, vec4f rhs) {return add(lhs, rhs);}
	vec4f operator +(vec4f lhs, flt32 rhs) {return add(lhs, vec4f(rhs));}
	vec4f operator +(flt32 lhs, vec4f rhs) {return add(vec4f(lhs), rhs);}
	vec4f operator +=(out vec4f lhs, vec4f rhs) {return lhs = add(lhs, rhs);}
	vec4f operator +=(out vec4f lhs, flt32 rhs) {return lhs = add(lhs, vec4f(rhs));}

	static vec4f neg(vec4f rhs) {emit(pf4.neg, p4f(rhs));}
	static vec4f add(vec4f lhs, vec4f rhs) {return emit(add.pf4, v4f(lhs), v4f(rhs));}
	static vec4f sub(vec4f lhs, vec4f rhs) {return emit(sub.pf4, v4f(lhs), v4f(rhs));}
	static vec4f mul(vec4f lhs, vec4f rhs) {return emit(mul.pf4, v4f(lhs), v4f(rhs));}
	static vec4f div(vec4f lhs, vec4f rhs) {return emit(div.pf4, v4f(lhs), v4f(rhs));}

	static flt32 dp3(vec4f lhs, vec4f rhs) {return flt32(emit(dp3.pf4, v4f(lhs), v4f(rhs)));}
	static flt32 dp4(vec4f lhs, vec4f rhs) {return flt32(emit(dp4.pf4, v4f(lhs), v4f(rhs)));}
	static flt32 dph(vec4f lhs, vec4f rhs) {return flt32(emit(dph.pf4, v4f(lhs), v4f(rhs)));}
	static flt32 len(vec4f lhs) {return sqrt(flt32(emit(dph.pf4, v4f(lhs), v4f(lhs))));}

	static flt32 eval(float val) {return (((w * val + z) * val + y) * val) + x;}

	flt32 dp3(vec4f rhs) {return dp3(this, rhs);}
	flt32 dph(vec4f rhs) {return dph(this, rhs);}
	flt32 dp4(vec4f rhs) {return dp4(this, rhs);}
	flt32 len() {return len(this);}

	static vec4f mul(ref vec4f res, ref vec4f lhs, ref vec4f rhs) {
		res.x = lhs.x * rhs.x;
		res.y = lhs.y * rhs.y;
		res.z = lhs.z * rhs.z;
		res.w = lhs.w * rhs.w;
		return res;
	}

	operator vec *= (vec rhs) {return mul(this, this, rhs);}
	static operator vec * (vec lhs, vec rhs) {return mul(this, lhs, rhs);}

	flt32 operator () (flt32 val) {return this.eval(val);}

	flt32 operator (v4f32 lhs) [int32 idx] {
		if (idx == 0 || idx == 'x')
			return lhs.x;
		if (idx == 1 || idx == 'y')
			return lhs.y;
		if (idx == 2 || idx == 'z')
			return lhs.z;
		if (idx == 3 || idx == 'w')
			return lhs.w;
		return 0.0;
	}

};

class Light {
	vector	ambi;		// Ambient
	vector	diff;		// Diffuse
	vector	spec;		// Specular
	vector	attn;		// Attenuation

	vector	pos;		// position
	vector	dir;		// direction
	scalar	sCos;
	scalar	sExp;
	short	attr;		// typeof(on/off)
}

vec4f lit(out vec4f ambi, out vec4f diff, out vec4f spec, vec4f pos, vec4f nrm, vec4f eye, Light l[]) {}

struct Material {
	vec4f emis;
	vec4f ambi;
	vec4f diff;
	vec4f spec;
	flt32 spow;
}

enum Materials : Material {	// material

	Brass = Material(
		vec4f(0.329410, 0.223529, 0.027451, 1),
		vec4f(0.780392, 0.568627, 0.113725, 1),
		vec4f(0.992157, 0.941176, 0.807843, 1),
		flt32(27.8974));

	Bronze = Material(
		vec4f(0.2125, 0.1275, 0.054, 1.0),
		vec4f(0.714, 0.4284, 0.18144, 1.0), 
		vec4f(0.393548, 0.271906, 0.166721),
		flt32(25.6));

	Chrome = Material(
		vec4f(0.25, 0.25, 0.25, 1.0),
		vec4f(0.4, 0.4, 0.4, 1.0),
		vec4f(0.774597, 0.774597, 0.774597, 1.0),
		flt32(76.8));

	Silver = Material(
		vec4f(0.19225, 0.19225, 0.19225, 1.0),
		vec4f(0.50754, 0.50754, 0.50754, 1.0),
		vec4f(0.508273, 0.508273, 0.508273, 1.0),
		flt32(51.2));

	Gold = Material(
		vec4f(0.24725, 0.1995, 0.0745, 1.0),
		vec4f(0.75164, 0.60648, 0.22648, 1.0),
		vec4f(0.628281, 0.555802, 0.366065, 1.0),
		flt32(51.2));

	Jade = Material(
		vec4f(0.135,0.2225,0.1575,0.95),
		vec4f(0.54, 0.89, 0.63, 0.95),
		vec4f(0.316228, 0.316228, 0.316228, 0.95),
		flt32(12.8));

	Ruby = Material(
		vec4f(0.1745,0.01175 ,0.01175,0.55),
		vec4f(0.61424,0.04136, 0.04136,0.55),
		vec4f(0.727811, 0.626959, 0.626959,0.55),
		flt32(76.8));
}

lights[] = {
	Light(...),
	new lghtsrc(...),
};

scene[] = {
	new prim(new sphere(...), mtl.gold),
	new prim(new tours(...), mtl.gold),
	new mesh(mtl.gold),
};

struct hitinfo {
	vec4f pos;
	vec4f nrm;
	flt32 len;
}

vec4f traceRay(const vec4f dir, int depth) {
	vec4f pos, N, col;
	flt32 d = math.inf;
	prim p = null;
	hitinfo hit;

	for (prim ps : scene) {
		if (ps.hit(hit, dir)) {
			if (hit.len > d) {
				pos = hit.pos;
				N = hit.nrm;
				d = hit.len;
				p = ps;
			}
		}
	}
	if (p != null) {
		for (Light l : lights) {
			bool inShadow = false;
			vec4f p2l = nrm(p.pos - l.pos);		// direction to light
			for (prim ps : scene) {
				if (ps.hit(hit, dir)) {
					inShadow = true;
				}
			}
			if (!inShadow) {
				col = p.mtl.lit(l, N, pos, vec4f(0, 0, 1));
			}
		}
		if (depth > 0 && p.mtl.reflect) {
			col += traceRay(rfl(nrm, pos), depth - 1);
		}
		if (depth > 0 && p.mtl.refract) {
			col += traceRay(rfr(nrm, pos), depth - 1);
		}
	}
	return col;
}

main() {
	for (int y = 0; y < height; y += 1) {
		for (int x = 0; x < width; x += 1) {
			flt32 s = x - width / 2.;
			flt32 t = y - height / 2.;
			vec4f dir = vec4f(s, t, 100, 0);
			cBuff(x, y, traceRay(dir.nrm()));
		}
	}
	bmp.save("raytr1.bmp", cBuff, width, height, 24);
}

class lights {
	Light[] l;
	uns32 it;

	Light first() {return l[it = 0];}
	Light next() {return l[it = 0];}
	bool has() {return it < l.length;}
}

for (Light l : lights) => for (Light l = lights.first(); lights.has(); l = lights.next())
//~ for (Light l : lights) => for (Light l = lights.first(); lights.first(); l = lights.next())


//~ */

/*
struct vec4f {
	flt32 x;
	flt32 y;
	flt32 z;
	flt32 w;
}

static if (useEmit) {
	operator + (vec4f rhs) = vec4f(emit(void, rhs));
	operator - (vec4f rhs) = vec4f(emit(v4f.neg, rhs));
	operator ~ (vec4f rhs) = vec4f(emit(v4f.rcp, rhs));
	operator (vec4f lhs) + (vec4f rhs) = vec4f(emit(v4f.add, lhs, rhs));

	define dp3(vec4f lhs, vec4f rhs) = flt32(emit(v4f.dp3, lhs, rhs));
	define dp4(vec4f lhs, vec4f rhs) = flt32(emit(v4f.dp4, lhs, rhs));
	define dph(vec4f lhs, vec4f rhs) = flt32(emit(v4f.dph, lhs, rhs));
	operator vec4f(flt32 x, flt32 y, flt32 z, flt32 w) = vec4f(emit(void, f32(x), f32(y), f32(z), f32(w)));
}
else {
	//! vec4f(flt32 x, flt32 y, flt32 z, flt32 w) is defined / ablt
	operator + (vec4f rhs) = vec4f(+rhs.x, +rhs.y, +rhs.z, +rhs.w);
	operator - (vec4f rhs) = vec4f(-rhs.x, -rhs.y, -rhs.z, -rhs.w);
	operator ~ (vec4f rhs) = vec4f(1. / rhs.x, 1. / rhs.y, 1. / rhs.z, 1. / rhs.w);
	operator (vec4f lhs) + (vec4f rhs) = vec4f(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w);

	define dp4(vec4f lhs, vec4f rhs) = flt32(lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z + lhs.w * rhs.w);
	define dph(vec4f lhs, vec4f rhs) = flt32(lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z + lhs.w);
	define dp3(vec4f lhs, vec4f rhs) = flt32(lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z);
}

operator vec4f(flt32 x, flt32 y, flt32 z) = vec4f(x, y, z, 1);
operator vec4f(flt32 x) = vec4f(x, x, x, x);

operator flt32(vec4f vec) = vec.w;
operator bool(vec4f vec) = bool(vec.x && vec.y && vec.z && vec.w);


flt32 index(v4f32 vec, int32 idx) {
	if (idx == 0 || idx == 'x')
		return lhs.x;
	if (idx == 1 || idx == 'y')
		return lhs.y;
	if (idx == 2 || idx == 'z')
		return lhs.z;
	if (idx == 3 || idx == 'w')
		return lhs.w;
	return 0.0;
}

define peval(vec4f vec, flt32 val) = flt32((((vec.w * val + vec.z) * val + vec.y) * val) + vec.x);

define len(vec4f lhs) = sqrt(dp3(lhs, lhs));

operator (ref vec4f lhs) += (vec4f rhs) = (lhs = lhs + rhs);

// operator() d:"opCall"; cpp: "flt32 vec4f::operator () (flt32 val) {...}"
operator (vec4f vec) (flt32 val) = peval(vec, val);

// operator() d:"opIndex"; cpp: "flt32 vec4f::operator [] (int32 val) {...}"
operator (vec4f vec) [int32 idx] = index(vec, val);

struct Complex {
	flt64 re;
	flt64 im;
}
operator Complex(flt64 re, flt64 im) = emit(v2d, f64(re), f64(im));

operator -(Complex rhs) = Complex(-rhs.re, -rhs.im);
operator (Complex lhs) + (Complex rhs) = Complex(lhs.re + rhs.re, lhs.im + rhs.im);
operator (Complex lhs) - (Complex rhs) = Complex(lhs.re - rhs.re, lhs.im - rhs.im);
operator (Complex lhs) * (Complex rhs) = Complex(0, 0);

operator -(Complex rhs) = emit(v2d.neg);
operator (Complex lhs) + (Complex rhs) = emit(v2d.add);
operator (Complex lhs) - (Complex rhs) = emit(v2d.sub);

operator (int a) + (int b) = osszead();
operator + (int b) = osszead();
operator (Complex b) [int a] = double(a ? b.im : b.re);

operator ()(Polinom b, float val);

operator (Polinom b) (float val) = float(0);
b(3);

operator sub(Complex lhs, Complex rhs) = emit(f64x2.sub, v2d(rhs), v2d(lhs));

Complex operator (Complex a) * (Complex b) {
	emit(v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re));		// a.re * b.re, a.im * b.im
	flt64 re = emit(f64.sub);										//>re = a.re * b.re - a.im * b.im
	emit(v2d.mul, f64(b.re), f64(b.im), f64(a.im), f64(a.re));		// a.re * b.im, a.im * b.re
	flt64 im = emit(f64.add);										//>im = a.re * b.im + a.im * b.re
	return Complex(re, im);
}

// */
