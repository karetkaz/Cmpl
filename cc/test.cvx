//~ #open src/core.h
//~ #open src/core.c
//~ #open src/tree.c

//~ #open src/code.c			// virtual machine
//~ #open src/type.c			// type system
//~ #open src/parser.c			// input, lexer, parser
//~ #open src/printer.c			// pretty print, logger
//~ #open src/main.c

struct hex32: int32; //%%08x
define d1 = 2;
define d2 = 3;
define d3 = 4;
uint8 arr[d1][d2][d3] = {1,2,3, 1,2,3};
const char str1[] = "alma a fa alatt nyari piros alma";
const char str2[] = {'a', 'l', 'm', 'a', 0};
//~ string str3 = "alma";

//~ char a[] = emit(struct, ref(null), i32(139135));
//~ char a[] = emit(struct, ref(null), i32(27330));
//~ for(int i = 1; i < 2 * a.length; i += 1) {
	//~ print("%c", a[i]);
//~ }
/* TODO:

string alma() {
	result = "alma";
}
// */



//~ /* typename...
struct xxx {
	int64 x1;
	int64 x2;
}

define Xxx = xxx;		// alias

typename type = Xxx;

xxx a = xxx(0, 0);
Xxx b = xxx(0, 0);

int size1 = typename(xxx).size;
int size2 = typename(Xxx).size;
int size3 = typename(type).size;

string name = typename.name(type);
string file = typename.file(type);
int line = typename.line(type);

//~ typename t1 = void;
//~ typename t2 = int64;
//~ typename t3 = typename;

//~ typename t = Complex;
//~ if (t == Complex) {
	//~ print("Complex\n");
//~ }
//~ if (Complex == t) {
	//~ print("Complex\n");
//~ }

//~ */

/* typename
struct ss {
	int32 x;
	int32 y;
	struct ss {
		int64 x;
		int64 y;
	}
}

ss A = ss(1, 2);
ss.ss a = ss.ss(1, 2);

typename t1 = ss;
typename t2 = ss.ss;

int n1 = sizeof(ss);
int n2 = sizeof(ss.ss);

//~ */

/* Arrays, Pointers, References Alloc
//~ define new(typename type) = memmgr(null, type.size);
//~ define new(typename type, int32 ^n) = emit(struct, ref(memmgr(null, type.size * n)), i32(n));// creates a slice: {data, length}

//~ int64 &i32ref = new(int64);

//~ int32 i32arr[] = new(int32, 100);
int32 i32arr[] = emit(struct, ref(memmgr(null, sizeof(int32) * 100)), i32(100));
for (int i = 0; i < i32arr.length; i += 1) {
	i32arr[i] = i + 10;
}

//~ */

/* alloc / realloc / free
//~ define realloc(pointer ptr, int size) = memmgr(ptr, size);
define malloc(int size) = memmgr(null, size);
define free(pointer ptr) = memmgr(ptr, 0);

//~ static int a = 7;

pointer p1 = null;
pointer p2 = null;
pointer p3 = null;
pointer p4 = null;
//~ pointer p5 = emit(pointer, ref(a));

memmgr(null, 0);
p1 = malloc(160);
//~ p1 = free(p1);
p2 = malloc(161);
p3 = malloc(160);
//~ p4 = malloc(160);

//~ p2 = memmgr(p2, 250);
memmgr(null, 0);
//~ / *

define test = 1;
static if (test == 1) {
	p3 = free(p3);
	p2 = free(p2);
	p1 = free(p1);
}
static if (test == 2) {
	p1 = free(p1);
	p2 = free(p2);
	p3 = free(p3);
}
static if (test == 3) {
	p2 = free(p2);
	p1 = free(p1);
	p3 = free(p3);
}
static if (test == 4) {
	p2 = free(p2);
	p3 = free(p3);
	p1 = free(p1);
}

free(p4);
//~ */

/* random floats
float32 frand() {
	uint32 randnum = rand() * rand();
	float32 tmp = emit(float32, i32((randnum >> 9 ) | 0x3f800000));
	result = tmp - 1;
}

float64 drand() {
	uint32 randnum1 = rand() * rand();
	uint32 randnum2 = rand() * rand();
	float64 tmp = emit(float64, i32(randnum1), i32((randnum2 >> 12) | 0x3ff00000));
	result = tmp - 1;
}

float maxrand = -1;
for(int i = 0; i < 30; i += 1) {
	float64 currand = drand();

	if (maxrand < currand)
		maxrand = currand;

	print("%f\n", currand);
}

// */

/* const ref assignment
struct m {
	static const int X = 9;
	const int a;
	int b;
	int c;// = 8;
}

m m1 = m(5, 9, 1);
int &ref_m1_a = m1.a;	// hacked: warn if const/nonconst ref assignment.
ref_m1_a = 666;

int x = m1.a;

// */

/* TODO: string arrays
string x = "almax a fa alatt";

string ss[3] = null;
ss[0] = x;//"alma1 a fa alatt";
ss[1] = "alma2 a fa alatt";
ss[2] = "alma3 a fa alatt";

string y;
y = ss[1];

//~ int iii[3] = 1, 2, 3;
//~ string sss[3] = x, "alma2 a fa alatt", "alma3 a fa alatt";
//~ string y = sss[0];
//~ sss[0][3] = 'A';

//~ println(y);
//~ print(ss[1]);
// */

/* xrgb
struct xrgb: 1 {
	uint8 b;
	uint8 g;
	uint8 r;
	uint8 x;
}
struct xrgbi32: 0 {
	xrgb rgb;
	int32 val;
}
//~ xrgb res = result;
//~ define clamp(int t, int a, int b) = min(max(t, a), b);

xrgb a = emit(xrgb, i32(0x801f008f));

//~ xrgb b = emit(xrgb, i32(0x2f3f1f));
//~ int r = a.r + b.r;

//~ xrgbi32 r;
//~ r.val = 0;

//~ r.rgb.r = min(a.r + b.r, 255);
//~ r.rgb.g = min(a.g + b.g, 255);
//~ r.rgb.b = min(a.b + b.b, 255);
// */

//~ define dim = 3;
//~ static int x[dim][dim][dim][dim] = {690};
//~ static int x[dim][dim][dim][dim][dim] = {690};

/* invoke functions ...
int method0() {}
int method1(int x) {
	//~ print("!alma a fa alatt nyÃ¡ri piros alma\n");
	static int i = 0;
	result = i += x;
	print("%D\n", int64(result));
}
int method1() {result = method1(1);}
int method2() {result = method1(2);}

void methodCall(int method()) {
	if (method == null) {
		print("(null)\n");
		return;
	}
	//~ print("(xxxx)\n");
	int n = method();
	//~ print("%D\n", int64(n));
}

//~ /+	just call it
static if (true) {
	method1();
	method2();
}// +/

//~ /+	call passed to another fun
//~ methodCall(method1);	// this will not work because there are 2 method1 named functions
methodCall(null);
methodCall(method2);
//~ +/

//~ /+	call as a reference
int method() = null;//method2;

//~ method = null;

if (method != null) {
	method();
}

methodCall(method);

// +/

//~ */
/* return function ...
/+ count down
struct Closure {int call(Closure &data); int data;}
define Invoke(Closure &wcd) = wcd.call(wcd);
//~ operator (Closure &wdc)() = wcd.call(wcd);

int countdown(Closure &a) {result = a.data; a.data -= 1;}

Closure a = Closure(countdown, 3);
Closure b = Closure(countdown, 30);

println(Invoke(a));
println(Invoke(b));
println(Invoke(a));
println(Invoke(a));
println(Invoke(a));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
println(Invoke(b));
// +/

//~ /+ count down (2) with args
struct Closure{int64 call(Closure &c, int64 n); int64 data; int32 calls; /+...+/ }
define Closure(int64 call(Closure &c, int64 n), int64 data) = Closure(call, data, 0);

define Invoke(Closure c, int64 n) = c.call(&c, n);
//~ operator (Closure c)(int64 n) = c.call(c, n);

int64 countdown(Closure &c, int64 n) {result = c.data; c.data -= n; c.calls += 1; }

Closure a = Closure(countdown, 90);

print("%d\n", int64(Invoke(a, 9)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));
print("%d\n", int64(Invoke(a, 2)));
//~ +/
//~ */
/*BUG: assignment by reference

int64 a = 32;
a = 33;
void setup() {
	static int64 &b = a;
	print("%d\n", int64(a));
}
setup();
//~ */

/* factorial
define n = 6;
int64 res = 1;
for (int i = 1; i <= n; i += 1) {
	res *= i;
}
// */
/* calc E
define eps = 1e-50;
double tmp = 1.;
double res = 1.;
for (int i = 1; tmp > eps; i += 1) {
	res += tmp /= i;
}
// */

/* TODO: arrays
bool isNullOrEmpty(int a[]) {
	if (a == null)
		result = true;
	if (a.length == 0)
		result = true;
}

//~ int val_null[] = null;
int val_empty[0];
int val_elements[10] = {9};

//~ bool res_true1 = isNullOrEmpty(null);
//~ bool res_true2 = isNullOrEmpty(val_null);
bool res_true3 = isNullOrEmpty(val_empty);
bool res_false = isNullOrEmpty(val_elements);
//~ */

/*
double val = 9;//emit(float64, i64(0x7ff8000000000000));
print("0b%064B\n", val);
print("0x%016X\n", val);

println(int64(val));
println(float64(val));
double f64_nan = emit(float64, i64(0b0111111111111000000000000000000000000000000000000000000000000000));
double f64_inf = emit(float64, i64(0b0111111111110000000000000000000000000000000000000000000000000000));
double f64_one = emit(float64, i64(0b0011111111110000000000000000000000000000000000000000000000000000));
//~ */

/* enumeration
/+
struct vec4f {
	float32 x;
	float32 y;
	float32 z;
	float32 w;
}// +/

enum xo: vec4f {
	O = vec4f(0, 0, 0, 0);
	X = vec4f(1, 0, 0, 0);
	Y = vec4f(0, 1, 0, 0);
	Z = vec4f(0, 0, 1, 0);
}

vec4f z = xo.Z;
//~ xo k = xo.Z;	// ok
//~ xo x = z;		// error
// */

/* ai: Genetic algorithm
struct individual {
	bool gene[2][10];
	double xreal[2];
	double objectives[2];
	double constraints[2];

	const int rank;
	double constr_violation;
	const double xbin[10];
	//~ double crowd_dist;
}

struct population {
	double min;
	double max;
	individual ind[1000];
}

//~ /+
define pi1M(double x, double y) = (x + y);
define pi2M(double x, double y) = (x + y);

int fitness(individual &ind) {
	ind.objectives[0]= -pi1M(ind.xbin[0], ind.xbin[1]);
	ind.objectives[1]= -pi2M(ind.xbin[0], ind.xbin[1]); 
}

// +/
//~ double size = 88006400 / double(1 << 20);
//~ static population pop[3000];
//~ int size = sizeof(population) * 3000 >> 20;


//~ */

//~ Date date = Date(2011, 10, 24);
//~ Date.Parts parts = Date.ToParts(date.days);

/* itoa
int val = 20;
char buff[512] = {0};

itoa(buff, "alma: %+20.10i, aweigf", val);
println(string(buff));
//~ */

/*Bug: const struct array initialization
struct Biorithm {
	int color;
	int period;
	int period2;
	string name;
}

static const Biorithm biorithms1[7] = {
	Biorithm(0x7070ff, 23,  0, "Physical"),
	Biorithm(0xff0000, 28,  0, "Emotional"),
	Biorithm(0x00ff00, 33,  0, "Intellectual"),
	Biorithm(0xdadada, 38,  0, "Intuitive"),
	Biorithm(0x6f6f6f, 23, 33, "Mastery"),
	Biorithm(0xfeab00, 23, 28, "Passion"),
	Biorithm(0x9466db, 28, 33, "Wisdom")
};

static const Biorithm biorithms2[] = {
	Biorithm(0x7070ff, 23,  0, "Physical"),
	Biorithm(0xff0000, 28,  0, "Emotional"),
	Biorithm(0x00ff00, 33,  0, "Intellectual"),
	Biorithm(0xdadada, 38,  0, "Intuitive"),
	Biorithm(0x6f6f6f, 23, 33, "Mastery"),
	Biorithm(0xfeab00, 23, 28, "Passion"),
	Biorithm(0x9466db, 28, 33, "Wisdom")
};

void printsize(Biorithm biorithms[]) {
	print("length: %d\n", biorithms.length);
}

printsize(biorithms1);
printsize(biorithms2);
//~ */

/* DONE
float64 Sum(float64 data[]) = Math.Sum;
float64 Mean(float64 data[]) = Math.Mean;

float64 data[3] = {1,2,3};
float64 sum = Sum(data);
float64 mean = Mean(data);
//~ */
