/* TODO:
	static if else part?
	js like initialization.
	inside a static if false threat errors as warnings?

	separate struct and unoin declaration?
	in case of unions create a constructor?

	int s2 = sizeof(Math);			// enum base type is not typename
 */
/* TODO: define/operator
 * define-s are implicit
 * operator-s are explicit
 * 
 * struct float3{float x; float y; float z;}
 * struct float4{float x; float y; float z; float w;}
 * 
 * and:
 * define float3(float4 x) = float3(x.x, x.y, x.z);			// this works
 * operator float4(float3 x) = float4(x.x, x.y, x.z, 0.);
 *
 * then:
 * float4 a = float4(1., 2., 3., 4.);
 * float3 b = float3(a);
 * float4 c = b;				// this will call `operator float4(float3 x)`
 * float3 d = a;				// Error: no operator float3(float4 x)
 * 
 * define void(var &a) = var.tryInvoke(a.type, ".dtor", a.Data);
 * 
 * define void(int8 &&a)    = void(0);
 * define void(int16 &&a)   = void(0);
 * define void(int32 &&a)   = void(0);
 * define void(int64 &&a)   = void(0);
 * define void(uint8 &&a)   = void(0);
 * define void(uint16 &&a)  = void(0);
 * define void(uint32 &&a)  = void(0);
 * define void(float32 &&a) = void(0);
 * define void(float64 &&a) = void(0);
 * 
 * 
 * operator -(int32 rhs) = emit(i32.neg, i32(rhs));
 * operator (int32 lhs) + (int32 rhs) = emit(i32.add, i32(rhs), i32(lhs));
 * 
 * operator (string lhs) [int32 rhs] = emit(int32, ldi.byte, i32.mad, i32(1), i32(rhs), ref(lhs));
 * operator (string lhs) [int32 rhs] (int32 setValue) = emit(int32, ldi.byte, i32.mad, i32(1), i32(rhs), ref(lhs));
 * 
 * operator int32(string value) = atoi(value, 10);
 * 
**/

/* TODO: out param
 * inout argument: &&
 * in case of defines: symbolic parameter
 *   void free(pointer &&ref) {
 *     memmgr(ref, 0);
 *     ref = null;
 *   }
 * 
**/
/+ TODO: errors
/+ recursively define
define fact(int64 n) = (n * fact(n - 1));
//~ +/
//~ +/
/* BUGS:
	arrays in structures
	array of references

// */

enum Test {
	Emit = ~0;
	Bits = ~0;
	Type = ~0;
	Misc = ~0;
	Math = ~0;
	Call = ~0;
}
static if (true) {
struct hex8: int8;			//%hex8(%02x)
struct hex16: int16;		//%hex16(%04x)
struct hex32: int32;		//%hex32(%08x)
struct hex64: int64;		//%hex64(%016X)
struct bin32: int32;		//%bin32(%032b)

define print(hex32 arg) = print("%08x", int64(arg));
define println(hex32 arg) = print("%08x\n", int64(arg));
define print(hex64 arg) = print("%08X", int64(arg));
define println(hex64 arg) = print("%08X\n", int64(arg));
}

static if (Test.Emit) {
/+ emit should be such as:
#pragma aux (parm [edi] [eax] [edx] value [edi] modify exact [xmm0]) vecmul =\
	"movps	xmm0, [eax]"\
	"mulps	xmm0, [edx]"\
	"movups	[edi], xmm0"
+/
static if (Test.Emit & 0x01) {
float32 res1 = emit(float32, f32.div, f32(2), f32(Math.pi));
float64 res2 = emit(f64.neg, f64(Math.pi));
float32 res3 = emit(i32, f32(Math.pi));
hex32 res4 = emit(i32, f32(Math.pi));
}
static if (Test.Emit & 0x02) {
define shl(int32 value, int count) = emit(i32.shl, i32(count), i32(value));
define shr(int32 value, int count) = emit(i32.shr, i32(count), i32(value));
define shr(uint32 value, int count) = emit(u32.shr, i32(count), i32(value));

define add(float32 a, float32 b) = emit(f32.add, f32(b), f32(a));		// := a + b
define sub(float32 a, float32 b) = emit(f32.sub, f32(b), f32(a));
define mul(float32 a, float32 b) = emit(f32.mul, f32(b), f32(a));
define div(float32 a, float32 b) = emit(f32.div, f32(b), f32(a));
define mod(float32 a, float32 b) = emit(f32.mod, f32(b), f32(a));

define mad(float32 a, float32 b, float32 c) = emit(f32.add, f32.mul, f32(a), f32(b), f32(c));	// a * b + c
define mad(float64 a, float64 b, float64 c) = emit(f64.add, f64.mul, f64(a), f64(b), f64(c));	// a * b + c
define mad(int32 size, int32 index, int32 offset) = emit(u32.mad, i32(size), i32(index), i32(offset));

//~ int a = -0x8989;
//! int32 a1 = shr(uint32(a), 8);
//! int64 a2 = shr(int32(a), 8);

//~ float32 X1 = mad(2, 3, 4000);
//~ float32 X2 = mad(float32(2), float32(3), float32(4000));
//~ float32 X3 = mad(2., 3., 4000.);

}
static if (Test.Emit & 0x04) {	// Complex multiplication

enum prog {
	sisd = 1;
	simd = 2;
}

define test2exec = prog.simd;
define times2exec = -10000000;

struct Complex {
	float64 re;
	float64 im;
}

//~ define Complex(float64 re, float64 im) = emit(Complex, f64(re), f64(im));
//~ define Complex(float64 re) = Complex(re, float64(0));

static if (test2exec) {
static if (test2exec == prog.sisd) {

define add(Complex &a, Complex &b) = Complex(a.re + b.re, a.im + b.im);
define add(Complex &a, float64 b) = Complex(a.re + b, a.im);
define add(float64 a, Complex &b) = Complex(a + b.re, b.im);

define sub(Complex &a, Complex &b) = Complex(a.re - b.re, a.im - b.im);
define sub(Complex &a, float64 b) = Complex(a.re - b, a.im);
define sub(float64 a, Complex &b) = Complex(a - b.re, b.im);

define mul(Complex &a, Complex &b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
define mul(Complex &a, float64 &b) = Complex(a.re * b, a.im * b);
define mul(float64 &a, Complex &b) = Complex(a * b.re, a * b.im);
}
static if (test2exec == prog.simd) {
//~ define add(Complex &a, Complex &b) = emit(Complex, v2d.add, f64(b.re), f64(b.im), f64(a.re), f64(a.im));
define add(Complex a, Complex b) = emit(Complex, v2d.add, Complex(b), Complex(a));
define add(Complex &a, float64 b) = emit(Complex, v2d.add, f64(b), f64(0), Complex(a));
define add(float64 a, Complex &b) = emit(Complex, v2d.add, Complex(b), f64(a), f64(0));

define sub(Complex a, Complex b) = emit(Complex, v2d.sub, Complex(b), Complex(a));
define sub(Complex &a, float64 b) = emit(Complex, v2d.sub, f64(b), f64(0), Complex(a));
define sub(float64 a, Complex &b) = emit(Complex, v2d.sub, Complex(b), f64(a), f64(0));

define mul(Complex &a, Complex &b) = emit(Complex,
	f64.sub, v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re),	// re = a.re * b.re - a.im * b.im
	f64.add, v2d.mul, Complex(b), f64(a.im), f64(a.re)	// im = a.re * b.im + a.im * b.re;
);
//~ define mul(Complex &a, double b) = emit(Complex, v2d.mul, f64(b), f64(b), f64(a.im), f64(a.re));
//~ define mul(double a, Complex &b) = emit(Complex, v2d.mul, f64(b.im), f64(b.re), f64(a), f64(a));
}
}

Complex Ca = Complex(3., 4.);
Complex Cb = Complex(2., 5.);
Complex Cc = mul(Ca, Cb);
//~ Complex Cc = mul(Complex(3., 4.), Complex(2., 5.));

static if (times2exec > 0) {
	for (int i = 0; i < times2exec; i += 1) {
		Complex C1 = mul(Ca, Cb);
	}
}
}// +/
static if (Test.Emit & 0x08) {	// Vector4

//~ vec4f v1 = emit(vec4f, f32(11), f32(12), f32(13), f32(14));
//~ vec4f v2 = emit(vec4f, f32(21), f32(22), f32(23), f32(24));
vec4f v1 = vec4f(11., 12., 13., 14.);
vec4f v2 = vec4f(21., 22., 23., 24.);
//~ println(v2);
//~ vec4f v3 = emit(vec4f, swz.xywz, vec4f(v1));
}// +/
} // */
static if (Test.Bits) {
static if (Test.Bits & 1) {		// compute bits

bin32 test_bit1_value = 100;
bin32 test_bit1_bitlo = bitlo(test_bit1_value);
bin32 test_bit1_bithi = bithi(test_bit1_value);
bin32 test_bit1_bswap = bitswp(test_bit1_value);
int32 test_bit1_bitcnt = bitcnt(test_bit1_value);
int32 test_bit1_bitsf = bitsf(test_bit1_value);
int32 test_bit1_bitsr = bitsr(test_bit1_value);
}
static if (Test.Bits & 2) {		// compute bits
void bitsget(int bitsize, bool signed, int64 &min, int64 &max) {
	int64 mask = int64.Shr(int64(-1), -bitsize);
	min = int64.Shl(-int64(signed), bitsize - 1);
	max = int64.And(min - 1, mask);
}

int bitsize = 10;
hex64 min;
hex64 max;
hex64 umin;
hex64 umax;

bitsget(bitsize, true, &min, &max);
bitsget(bitsize, !true, &umin, &umax);

//~ assert(umin == 0);
//~ assert(umin != min);
//~ assert(umax != max);

}
} // */
static if (Test.Type) {
static if (Test.Type & 0x01) {		// lookup test

define int1 = int(1990);
define int1() = int(1995);
define int1(int32 _) = int(2010);
define int1(float64 _) = int(2015);

//~ int32 a1 = int1;			// 1990
//~ int32 a2 = int1();			// 1995
//~ int32 a3 = int1(0);			// 2010
//~ int32 a4 = int1(0.);		// 2015

assert(int1 == 1990);
assert(int1() == 1995);
assert(int1(0) == 2010);
assert(int1(0.) == 2015);

}
static if (Test.Type & 0x02) {

float64 NAN = Math.nan; // 0 / 0.;
int isNan1 = int(Math.isNan(NAN));
int isNan2 = int(Math.isNan(Math.nan));
}
static if (Test.Type & 0x04) {		// union & packing
//~ struct and arrays
struct fltint32:0 {int32 i;float32 f;}
struct fltint64:0 {int64 i;float64 f;}


/*define intTY int32;
struct intabc:8 {
	intTY X;		//%%?08b
	intTY Y;		//%%?08b
	intTY Z;		//%%?08b
	//~ intTY W;		//!X%?03x
	fiu64 U;
}*/

fltint64 fltintunionvalue;
fltintunionvalue.f = 0;
}
static if (Test.Type & 0x08) {		// color
struct bgra:1 {
	uint8 b; 	//%blue(%d)
	uint8 g; 	//%green(%d)
	uint8 r; 	//%red(%d)
	uint8 a; 	//%alpha(%d)
}
struct color:0 {
	int32 val;	//%#%08x
	bgra col;	//%
}

define color(int32 c) = emit(color, i32(c));
//~ define cxff(int32 c) = int32(c & 0xff);
//~ define color(int32 a, int32 r, int32 g, int32 b) = emit(color, i32((cxff(a) << 24) | (cxff(r) << 16) | (cxff(g) << 8) | cxff(b)));

define color(int32 a, int32 r, int32 g, int32 b) = color(int32(((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | ((b & 0xff) << 0)));
define color(float64 a, float64 r, float64 g, float64 b) = color(int32(a*255), int32(r*255), int32(g*255), int32(b*255));

define color(int32 r, int32 g, int32 b) = color(int32(255), r, g, b);
define color(float64 r, float64 g, float64 b) = color(float64(1), r, g, b);

//~ color C1 = color(0xcafebabd);
//~ color C2 = color(0xca, 0xfe, 0xba, 0xbc);
//~ color C3 = emit(color, i32(0xcafebabe));
//~ color C4 = emit(color, i32(0xcafebabf));
color C5 = color(0.1, .5, .7);
//~ color C5 = color(1, 5, 205);

enum colors: color {
	c5 = color(0.1, .5, 1.);
	none = color(-1);
	//~ pink = color(2,3,4);
}
color c5 = colors.c5;

}
static if (Test.Type & 0x10) {		// arrays
// 1.K int maximum(int arr[12])
// 2.K int maximum(int arr[])
// 3.X int maximum(int arr...)

int arr2[3] = 1, 2, 3;	// array
int arr3[] = arr2;		// slice

int maximum(int arr[]) {
	result = arr[0];
	for (int i = 1; i < arr.length; i += 1) {
		if (result < arr[i]) {
			result = arr[i];
		}
	}
}

void sort(int arr[]) {
	for (int i = 0; i < arr.length - 1; i += 1) {
		for (int j = i + 1; j < arr.length; j += 1) {
			if (arr[i] > arr[j]) {
				int tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
			}
		}
	}
}

int bsearch(int arr[], int elem) {
	int lo = 0;
	int hi = arr.length;

	result = -1;
	for (;lo < hi;) {
		int mid = lo + ((hi - lo) / 2);
		int val = arr[mid];

		if (val == elem) {
			return mid;
		}
		else if (val > elem) {
			hi = mid;
		}
		else {
			lo = mid + 1;
		}
	}
}

void randomize(int arr[], int max) {
	for (int i = 0; i < arr.length; i += 1) {
		arr[i] = rand() % max;
	}
}

randomize(arr2, 300);
int test_arr_max = maximum(arr2);
int test_arr_toFind = arr2[arr2.length / 2];
sort(arr2);
int test_arr_index = bsearch(arr2, test_arr_toFind);

}
} // */
static if (Test.Misc) {
static if (Test.Misc & 1) {			// matrix multiply
// Matrix Multiply

define dim = 3;
define scalar float64;		//%%f
scalar m1[dim][dim];
scalar m2[dim][dim];
scalar m3[dim][dim];

//~ /+ Initialize
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		//~TODO: error: m1[i][j] = m2[i][j] = (i == j) + 2;
		m1[i][j] = m2[i][j] = (i == j) * 1. + 0;
	}
} // +/

//~ /+ Compute
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		m3[i][j] = 0;
		for (int k = 0; k < dim; k += 1) {
			m3[i][j] += m1[i][k] * m2[k][j];
		}
	}
} // +/

//~ /+ Print
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		if (j != 0)
			putchr(' ');
		print(m3[i][j]);
	}
	putchr('\n');
} // +/
}
} // */
static if (Test.Math) {
static if (Test.Math & 1) {
	double x = Math.pi / 2;
	double absx = Math.abs(-x);
	double sinx = sin(x);
	double cosx = cos(x);
	double tanx = tan(x);
	double logx = log(x);
	double expx = exp(x);
	double powx = pow(2, 8);
	//~ double ___x = ___(x);
}
//~ /+
static if (false) {// && Test.Math & 2) {		// fixed point
struct fixed:0 {	//%%08x
	int32 value;
	define point = 24;
	define mul(int32 lhs, int32 rhs, int __fixp) = int32(int64.Sar(int64(lhs) * rhs, __fixp));
	define div(int32 lhs, int32 rhs, int __fixp) = int32(int64.Shl(int64(lhs), __fixp) / rhs);
}

define fixed(int32 val) = emit(fixed, i32(val << fixed.point));
define fixed(float64 val) = emit(fixed, int32(float64(val * (1 << fixed.point))));
define int32(fixed ^val) = int(val.value >> fixed.point);
define float64(fixed ^val) = double(val.value / double(1 << fixed.point));
define double(fixed ^val) = double(val.value / double(1 << fixed.point));

static struct Fixed {
	define Fixed(const int32 val) = emit(fixed, i32(val));
	define Fixed(const int64 val) = emit(fixed, i32(val));
	define fxpoint = fixed.point;
	// constants
	enum: int32 {
		fxpmask = (1 << fxpoint) - 1;

		fxp_nan = 0x80000000;
		fxp_inf = 0x7fffffff;
		fxp_one = 1 << fxpoint;

		fxp_d2r = 0x000477d1 >> (24 - fxpoint);		// pi / 180 : degrees to radians
		fxp_r2d = 0x394bb834 >> (24 - fxpoint);		// 180 / pi : radians to degrees
		fxp_ln2 = 0x00b17217 >> (24 - fxpoint);		// .6931471805599453 : natural logarithm (2)
		fxp_lg2 = 0x004d104d >> (24 - fxpoint);		// .3010299956639812 : decimal logarithm (2)
		fxp_l2e = 0x01715476 >> (24 - fxpoint);		// 1.442695040888963 : logarithm base 2  (e)
		fxp_l2t = 0x035269e1 >> (24 - fxpoint);		// 3.321928094887362 : logarithm base 2 (10)

		fxp_mpi = 0x3243f6a8 >> (28 - fxpoint);
		fxp_2pi = 0x3243f6a8 >> (28 - fxpoint - 1);
		fxp_pi2 = 0x3243f6a8 >> (28 - fxpoint + 1);
	}

	define add(fixed ^lhs, fixed ^rhs) = Fixed(lhs.value + rhs.value);
	define sub(fixed ^lhs, fixed ^rhs) = Fixed(lhs.value - rhs.value);
	define mul(fixed ^lhs, fixed ^rhs) = Fixed(fixed.mul(lhs.value, rhs.value, fxpoint));
	define mul(fixed ^lhs, int32 rhs) = Fixed(lhs.value * rhs);
	define mul(int32 lhs, fixed ^rhs) = Fixed(lhs * rhs.value);
	define div(fixed ^lhs, fixed ^rhs) = Fixed(fixed.div(lhs.value, rhs.value, fxpoint));
	define div(fixed ^lhs, int32 rhs) = Fixed(lhs.value / rhs);
	define mod(fixed ^lhs, fixed ^rhs) = Fixed(lhs.value % rhs.value);

	//~ define mul(fixed lhs, fixed rhs) = fxpmul(lhs.value, rhs.value, fxpoint);
	//~ define div(fixed lhs, fixed rhs) = fxpdiv(lhs.value, rhs.value, fxpoint);
	define inv(fixed rhs) = div(Fixed(fxp_one), rhs);


	uint32 bsr(uint32 x) {		//scan bit reverse (first bit = 31 (msb))
		if (x != 0) {
			result = 0;
			if ((x & 0xffff0000) != 0) { result += 16; x >>= 16; }
			if ((x & 0x0000ff00) != 0) { result +=  8; x >>=  8; }
			if ((x & 0x000000f0) != 0) { result +=  4; x >>=  4; }
			if ((x & 0x0000000c) != 0) { result +=  2; x >>=  2; }
			if ((x & 0x00000002) != 0) { result +=  1; }
		}
		else {
			result = -1;
		}
	}
	uint32 gettbl(int16 tbl[], int32 x) {
		uint32 idx = (x >> (fxpoint -  8)) & 0x00ff;
		uint32 lrp = (x << (24 - fxpoint)) & 0xffff;
		result = (tbl[idx] << 16) + lrp * (tbl[idx + 1] - tbl[idx]);
	}
	fixed eval(fixed x, const fixed p[]) {
		result = p[0];
		for (int i = 1; i < p.length; i += 1) {
			result = add(p[i], mul(result, x));
			//~ result = mul(result, x);
			//~ result = add(result, p[i]);
		}
	}
	fixed eval4(fixed x, const fixed p[4]) {
		result.value = p[0].value;
		result.value = p[1].value + fixed.mul(result.value, x.value, fxpoint);
		result.value = p[2].value + fixed.mul(result.value, x.value, fxpoint);
		result.value = p[3].value + fixed.mul(result.value, x.value, fxpoint);
	}

	fixed fxp2xp(fixed x) {
		static const uint16 tbl2xp[257] =		// (2 ** x) - 1, x : [0,1)
			0x0000, 0x00b2, 0x0164, 0x0217, 0x02ca, 0x037d, 0x0431, 0x04e6,
			0x059b, 0x0651, 0x0707, 0x07bd, 0x0874, 0x092c, 0x09e4, 0x0a9c,
			0x0b56, 0x0c0f, 0x0cc9, 0x0d84, 0x0e3f, 0x0efa, 0x0fb6, 0x1073,
			0x1130, 0x11ee, 0x12ac, 0x136b, 0x142a, 0x14e9, 0x15aa, 0x166a,
			0x172c, 0x17ed, 0x18b0, 0x1972, 0x1a36, 0x1afa, 0x1bbe, 0x1c83,
			0x1d48, 0x1e0e, 0x1ed5, 0x1f9c, 0x2064, 0x212c, 0x21f5, 0x22be,
			0x2388, 0x2452, 0x251d, 0x25e8, 0x26b4, 0x2781, 0x284e, 0x291c,
			0x29ea, 0x2ab9, 0x2b88, 0x2c58, 0x2d28, 0x2df9, 0x2ecb, 0x2f9d,
			0x3070, 0x3143, 0x3217, 0x32ec, 0x33c1, 0x3496, 0x356c, 0x3643,
			0x371a, 0x37f2, 0x38cb, 0x39a4, 0x3a7e, 0x3b58, 0x3c33, 0x3d0e,
			0x3dea, 0x3ec7, 0x3fa4, 0x4082, 0x4161, 0x4240, 0x431f, 0x4400,
			0x44e1, 0x45c2, 0x46a4, 0x4787, 0x486a, 0x494e, 0x4a33, 0x4b18,
			0x4bfe, 0x4ce4, 0x4dcb, 0x4eb3, 0x4f9b, 0x5084, 0x516e, 0x5258,
			0x5343, 0x542e, 0x551a, 0x5607, 0x56f4, 0x57e2, 0x58d1, 0x59c1,
			0x5ab0, 0x5ba1, 0x5c92, 0x5d84, 0x5e77, 0x5f6a, 0x605e, 0x6153,
			0x6248, 0x633e, 0x6434, 0x652c, 0x6624, 0x671c, 0x6815, 0x690f,
			0x6a0a, 0x6b05, 0x6c01, 0x6cfe, 0x6dfb, 0x6ef9, 0x6ff8, 0x70f7,
			0x71f7, 0x72f8, 0x73fa, 0x74fc, 0x75ff, 0x7702, 0x7807, 0x790c,
			0x7a11, 0x7b18, 0x7c1f, 0x7d27, 0x7e2f, 0x7f38, 0x8042, 0x814d,
			0x8259, 0x8365, 0x8472, 0x857f, 0x868e, 0x879d, 0x88ac, 0x89bd,
			0x8ace, 0x8be0, 0x8cf3, 0x8e07, 0x8f1b, 0x9030, 0x9146, 0x925c,
			0x9373, 0x948c, 0x95a4, 0x96be, 0x97d8, 0x98f3, 0x9a0f, 0x9b2c,
			0x9c49, 0x9d67, 0x9e86, 0x9fa6, 0xa0c6, 0xa1e8, 0xa30a, 0xa42d,
			0xa550, 0xa675, 0xa79a, 0xa8c0, 0xa9e7, 0xab0e, 0xac37, 0xad60,
			0xae8a, 0xafb5, 0xb0e0, 0xb20d, 0xb33a, 0xb468, 0xb597, 0xb6c7,
			0xb7f7, 0xb929, 0xba5b, 0xbb8e, 0xbcc2, 0xbdf7, 0xbf2c, 0xc063,
			0xc19a, 0xc2d2, 0xc40b, 0xc544, 0xc67f, 0xc7bb, 0xc8f7, 0xca34,
			0xcb72, 0xccb1, 0xcdf1, 0xcf31, 0xd073, 0xd1b5, 0xd2f8, 0xd43d,
			0xd582, 0xd6c7, 0xd80e, 0xd956, 0xda9e, 0xdbe8, 0xdd32, 0xde7d,
			0xdfc9, 0xe116, 0xe264, 0xe3b3, 0xe503, 0xe654, 0xe7a5, 0xe8f8,
			0xea4b, 0xeb9f, 0xecf5, 0xee4b, 0xefa2, 0xf0fa, 0xf253, 0xf3ad,
			0xf507, 0xf663, 0xf7c0, 0xf91e, 0xfa7c, 0xfbdc, 0xfd3c, 0xfe9e,
			0xffff;

		/**	fxp2xp(x) <=> 2 ** x
		 *	n = floor(x), q = fract(x)
		 *	=> exp2(x) = exp2(n + q) = exp2(n) * exp2(q)
		 *	exp2(q) = look up from table tbl2px (>> (32 - FXPOINT) + FXP_ONE)
		 *	exp2(x) = (x >= 0) ? (exp2(q) << n) : (exp2(q) >> -n)
		 *	---------------------------------------------------
		**/
		int32 n = (x.value >> fxpoint) + fxpoint;
		if (n < 0 || n >= 31) {
			result = Fixed(n < 0 ? 0 : fxp_inf);
		}
		else {
			result.value = (1 << n) | (gettbl(tbl2xp, x.value) >> (32 - n));
		}
	}

	fixed fxplg2(fixed x) {
		static const int16 tbllg2[257] = 		// log2(x) - 1, x : [0,1)
			0x0000, 0x0171, 0x02e0, 0x044e, 0x05ba, 0x0725, 0x088e, 0x09f7,
			0x0b5d, 0x0cc3, 0x0e27, 0x0f8a, 0x10eb, 0x124b, 0x13aa, 0x1508,
			0x1664, 0x17bf, 0x1919, 0x1a71, 0x1bc8, 0x1d1e, 0x1e73, 0x1fc6,
			0x2119, 0x226a, 0x23ba, 0x2508, 0x2656, 0x27a2, 0x28ed, 0x2a37,
			0x2b80, 0x2cc8, 0x2e0f, 0x2f54, 0x3098, 0x31dc, 0x331e, 0x345f,
			0x359f, 0x36de, 0x381b, 0x3958, 0x3a94, 0x3bce, 0x3d08, 0x3e41,
			0x3f78, 0x40af, 0x41e4, 0x4319, 0x444c, 0x457f, 0x46b0, 0x47e1,
			0x4910, 0x4a3f, 0x4b6c, 0x4c99, 0x4dc5, 0x4eef, 0x5019, 0x5142,
			0x526a, 0x5391, 0x54b7, 0x55dc, 0x5700, 0x5824, 0x5946, 0x5a68,
			0x5b89, 0x5ca8, 0x5dc7, 0x5ee5, 0x6003, 0x611f, 0x623a, 0x6355,
			0x646f, 0x6588, 0x66a0, 0x67b7, 0x68ce, 0x69e4, 0x6af8, 0x6c0c,
			0x6d20, 0x6e32, 0x6f44, 0x7055, 0x7165, 0x7274, 0x7383, 0x7490,
			0x759d, 0x76aa, 0x77b5, 0x78c0, 0x79ca, 0x7ad3, 0x7bdb, 0x7ce3,
			0x7dea, 0x7ef0, 0x7ff6, 0x80fb, 0x81ff, 0x8302, 0x8405, 0x8507,
			0x8608, 0x8709, 0x8809, 0x8908, 0x8a06, 0x8b04, 0x8c01, 0x8cfe,
			0x8dfa, 0x8ef5, 0x8fef, 0x90e9, 0x91e2, 0x92db, 0x93d2, 0x94ca,
			0x95c0, 0x96b6, 0x97ab, 0x98a0, 0x9994, 0x9a87, 0x9b7a, 0x9c6c,
			0x9d5e, 0x9e4f, 0x9f3f, 0xa02e, 0xa11e, 0xa20c, 0xa2fa, 0xa3e7,
			0xa4d4, 0xa5c0, 0xa6ab, 0xa796, 0xa881, 0xa96a, 0xaa53, 0xab3c,
			0xac24, 0xad0c, 0xadf2, 0xaed9, 0xafbe, 0xb0a4, 0xb188, 0xb26c,
			0xb350, 0xb433, 0xb515, 0xb5f7, 0xb6d9, 0xb7ba, 0xb89a, 0xb97a,
			0xba59, 0xbb38, 0xbc16, 0xbcf4, 0xbdd1, 0xbead, 0xbf8a, 0xc065,
			0xc140, 0xc21b, 0xc2f5, 0xc3cf, 0xc4a8, 0xc580, 0xc658, 0xc730,
			0xc807, 0xc8de, 0xc9b4, 0xca8a, 0xcb5f, 0xcc34, 0xcd08, 0xcddc,
			0xceaf, 0xcf82, 0xd054, 0xd126, 0xd1f7, 0xd2c8, 0xd399, 0xd469,
			0xd538, 0xd607, 0xd6d6, 0xd7a4, 0xd872, 0xd93f, 0xda0c, 0xdad9,
			0xdba5, 0xdc70, 0xdd3b, 0xde06, 0xded0, 0xdf9a, 0xe063, 0xe12c,
			0xe1f5, 0xe2bd, 0xe385, 0xe44c, 0xe513, 0xe5d9, 0xe69f, 0xe765,
			0xe82a, 0xe8ef, 0xe9b3, 0xea77, 0xeb3b, 0xebfe, 0xecc1, 0xed83,
			0xee45, 0xef06, 0xefc8, 0xf088, 0xf149, 0xf209, 0xf2c8, 0xf387,
			0xf446, 0xf505, 0xf5c3, 0xf680, 0xf73e, 0xf7fb, 0xf8b7, 0xf973,
			0xfa2f, 0xfaea, 0xfba5, 0xfc60, 0xfd1a, 0xfdd4, 0xfe8e, 0xff47,
			0xffff;

		/**	log2(x) logarithm base 2
		 * 	log2(x) = log2((2 ** n) * (x / 2 ** n)) = 
		 * 	= log2(2 ** n) + log2(x / 2 ** n) = n + log2(q)
		 * 	n = first bit in x (ASM : BSR (bit scan reverse))
		 * 	q = x / 2 ** n = (x > 1) ? (x >> n) : (x << -n)
		 * 	x > 1 <=> n - FXPOINT > 0
		 * 	log2(q) = get from table [tbllg2], q in [1, 2)
		 * 	---------------------------------------------------
		**/
		if (x.value <= 0) {
			result.value = (x.value != 0) ? fxp_nan : -fxp_inf;
		}
		else {
			int32 n = bsr(x.value) - fxpoint;
			uint32 q = gettbl(tbllg2, n > 0 ? (x.value >> n) : (x.value << -n));
			result.value = (n << fxpoint) + (q >> (32 - fxpoint));
		}
	}

	void sincos(fixed x, fixed &s, fixed &c) {
		static const fixed polysin[4] =		// eps < 0.000124 in [0, 2pi]
			fixed(-1./5040	+.00001),		// 1/7!
			fixed(+1./120	+.00000),		// 1/5!
			fixed(-1./6		-.00006),		// 1/3!
			fixed(+1./1		+.00000);		// 1/1!
		static const fixed polycos[4] =		// eps < 0.000126 in [0, 2pi]
			fixed(-1./720	-.00004),		// 1/6!
			fixed(+1./24	+.00003),		// 1/4!
			fixed(-1./2		-.00007),		// 1/2!
			fixed(+1./1		-.00010);		// 1/0!

		int32 ssgn = 1;
		int32 csgn = 1;

		x.value %= fxp_2pi;

		if (x.value < 0) {
			x.value += fxp_2pi;
		}

		// x in [0, 2*pi)
		if (x.value >= fxp_mpi) {
			x.value = fxp_2pi - x.value;
			ssgn = -1;
		}

		// x in [0, pi)
		if (x.value >= fxp_pi2) {
			x.value -= fxp_mpi;
			ssgn = -ssgn;
			csgn = -1;
		}

		// x in [0, pi/2)
		fixed sqr = mul(x, x);
		c = mul(csgn, eval4(sqr, polycos));
		s = mul(ssgn, mul(x, eval4(sqr, polysin)));
	}

	//~ ln(x) := ln2 * l2(x);
	define Ln(fixed x) = mul(fxp_ln2, fxplg2(x));

	//~ ln(x) := lg2 * l2(x);
	define Lg(fixed x) = mul(fxp_lg2, fxplg2(x));

	//~ e ** x = 2 ** (l2e * x)
	define Exp(fixed x) = fxp2xp(mul(fxp_l2e, x));

	//~ 10 ** x = 2 ** (l2t * x)
	//~ define Txp(fixed x) = fxp2xp(mul(fxp_l2t, x));

	fixed Sqrt(fixed x) {
		if (x.value < 0) {
			return Fixed(fxp_nan);
		}

		static if ((fixed.point & 1) == 0) {
			// from "Graphics Gems"
			uint32 testDiv;
			uint32 root = 0;			// Clear root
			uint32 remHi = 0;			// Clear high part of partial remainder
			uint32 remLo = x.value;			// Get argument into low part of partial remainder
			uint32 count = 16 + (fxpoint >> 1);	// Load loop counter
			for (;count > 0; count -= 1) {
				remHi = (remHi << 2) | (remLo >> 30);		// get 2 bits of arg
				remLo <<= 2;
				root <<= 1;					// Get ready for the next bit in the root
				testDiv = (root << 1) + 1;			// Test radical
				if (remHi >= testDiv) {
					remHi -= testDiv;
					root += 1;
				}
			}
			result = Fixed(int32(root));
		}
		static if ((fixed.point & 1) != 0) {
			result = fxp2xp(div(fxplg2(x), 2));
		}
		//~ result = x.value < 0 ? Fixed(fxp_nan) : fxp2xp(div(fxplg2(x), 2));
	}

	fixed Rsq(fixed x) {
		result = x.value < 0 ? Fixed(fxp_nan) : fxp2xp(div(fxplg2(x), -2));
	}

	fixed Pow(fixed x, fixed y) {
		if (x.value <= 0) {
			//~ Domain error in fxppow
			result = Fixed(x.value ? fxp_nan : fxp_inf);
		}
		else if ((y.value & fxpmask) == 0) {
			fixed sqr = x;
			int32 pow = (y.value < 0 ? -y.value : y.value) >> fxpoint;
			fixed res = Fixed(fxp_one);
			for ( ; pow; ) {
				if (pow & 1) {
					res = mul(res, sqr);
				}
				sqr = mul(sqr, sqr);
				pow >>= 1;
			}
			result = y.value < 0 ? inv(res) : res;
		}
		else {
			result = fxp2xp(mul(fxplg2(x), y));
		}
	}

	fixed Sin(fixed x) {
		fixed temp;
		sincos(x, &result, &temp);
	}
	fixed Cos(fixed x) {
		fixed temp;
		sincos(x, &temp, &result);
	}
	fixed Tan(fixed x) {
		fixed sin;
		fixed cos;
		sincos(x, &sin, &cos);
		result = div(sin, cos);
	}
	fixed Asin(fixed x) {
		const fixed polyasin[4] =			// eps < 0.000106 in [-1, +1]
			fixed(-0.0187293),
			fixed(+0.0742610),
			fixed(-0.2121144),
			fixed(+1.5707288);

		int32 neg = 0;
		if (x.value < 0) {
			x.value = -x.value;
			neg = 2;
		}
		result = eval4(x, polyasin);
		result = mul(result, Sqrt(Fixed(fxp_one - x.value)));
		result.value -= neg * (result.value - fxp_pi2);
		result.value = fxp_pi2 - result.value;
	}

/*
long fxpacos(long x) {
	//~ static const fixed polyacos[4] =			// eps < 0.000117 in [-1, +1]
		//~ fixed(-0.0187293),
		//~ fixed(+0.0742610),
		//~ fixed(-0.2121144),
		//~ fixed(+1.5707288);
	long res, neg = 2 * (x < 0);
	x = x < 0 ? -x : x;
	res = fxvevalp(polyacos, x);
	res = fxpmul(res, fxpsqrt(FXP_ONE - x));
	res += neg * (FXP_PI2 - res);
	return res;
}

long fxpatan(long x) {
	return fxpatan2(x, FXP_ONE);
}

long fxpatan2(long x, long y) {
	//~ static const fixed polyatan[4] =			// eps < 0.000195 in [-9, +9] R
		//~ fixed(-0.0410220),
		//~ fixed(+0.1493840),
		//~ fixed(-0.3224560),
		//~ fixed(+0.9993370);

	long mx, my, tmp, res;
	//~ if (!x || !y) return 0;
	mx = (x < 0 ? -x : x);
	my = (y < 0 ? -y : y);
	tmp = fxpdiv(mx < my ? mx : my, mx > my ? mx : my);
	res = fxvevalp(polyatan, fxpmul(tmp, tmp));
	res = fxpmul(res, tmp);
	res = (mx > my) ? FXP_PI2 - res : res;
	res = (y < 0) ? FXP_MPI - res : res;
	res = (x < 0) ? -res : res;
	return res;
}

long fxpsinh(long x) {
	//~ cosh(x) := (exp(x) - exp(-x)) / 2
	return (fxpexp(x) - fxpexp(-x)) >> 1;
}

long fxpcosh(long x) {
	//~ cosh(x) := (exp(x) + exp(-x)) / 2
	return (fxpexp(x) + fxpexp(-x)) >> 1;
}

long fxptanh(long x) {
	//~ tanh(x) := (exp(2*x) - 1) / (exp(2*x) + 1)
	long ans = fxpexp(x << 1);
	if (ans == FXP_INF) return FXP_ONE;
	return fxpdiv((ans - FXP_ONE), (ans + FXP_ONE));
}

long fxpasinh(long x) {
	//~ asinh(x) := logn(sqrt(sqr(x) + 1) + x)
	return fxplgn(fxpsqrt(fxpmul(x, x) + FXP_ONE) + x);
}

long fxpacosh(long x) {
	//~ acosh(x) := logn(sqrt(sqr(x) - 1) + x)
	return fxplgn(fxpsqrt(fxpmul(x, x) - FXP_ONE) + x);
}

long fxpatanh(long x) {
	//~ atanh(x) := -logn((1 - x) / (1 + x)) / 2
	if ((x < 0 ? -x : x) >= FXP_ONE) return FXP_NAN;
	return -fxplgn(fxpdiv(FXP_ONE - x, FXP_ONE + x)) >> 1;
}
// */
}
//~ +/

//~ double fixed_test = double(Fixed.add(fixed(2.225), fixed(3)));

double float_value = 40;//Math.pi / 4;
double fixed_value = float64(fixed(float_value));

double float_test1 = Math.Sin(float_value);
double fixed_test1 = float64(Fixed.Sin(fixed(float_value)));

double float_test2 = Math.Cos(float_value);
double fixed_test2 = float64(Fixed.Cos(fixed(float_value)));

double float_test3 = tan(float_value);
double fixed_test3 = float64(Fixed.Tan(fixed(float_value)));

//~ double float_value = 3.7;
//~ double fixed_value = double(fixed(float_value));

double float_test4 = pow(float_value, .5);
double fixed_test4 = float64(Fixed.Sqrt(fixed(float_value)));

//~ double float_test4 = pow(6, float_value);
//~ double fixed_test4 = double(Fixed.Pow(fixed(6), fixed(float_value)));
}// +/

}
static if (Test.Call) {
static if (Test.Call & 1) {			// 256 bit(8x32bit) integer
struct int32x8 {
	int32 i8;	//%%08x
	int32 i7;	//%%08x
	int32 i6;	//%%08x
	int32 i5;	//%%08x
	int32 i4;	//%%08x
	int32 i3;	//%%08x
	int32 i2;	//%%08x
	int32 i1;	//%%08x
	//~ int32 i1;	//%%08x
	//~ int32 i2;	//%%08x
	//~ int32 i3;	//%%08x
	//~ int32 i4;	//%%08x
	//~ int32 i5;	//%%08x
	//~ int32 i6;	//%%08x
	//~ int32 i7;	//%%08x
	//~ int32 i8;	//%%08x
} // */

//~ define i32x8(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8) = emit(i32x8, i32(i1), i32(i2), i32(i3), i32(i4), i32(i5), i32(i6), i32(i7), i32(i8));
define int32x8(int32 i0) = emit(int32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32.shr, i32(31), dupp.x1, i32(i0));
define int32x8(uint32 i0) = emit(int32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32(0), i32(i0));

void println(int32x8 &x) {
	print("%d, ", x.i1);
	print("%d, ", x.i2);
	print("%d, ", x.i3);
	print("%d, ", x.i4);
	print("%d, ", x.i5);
	print("%d, ", x.i6);
	print("%d, ", x.i7);
	print("%d\n", x.i8);
}

//~ define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend

int32x8 cmt(const int32x8 &b) {
	result.i1 = ~b.i1;
	result.i2 = ~b.i2;
	result.i3 = ~b.i3;
	result.i4 = ~b.i4;
	result.i5 = ~b.i5;
	result.i6 = ~b.i6;
	result.i7 = ~b.i7;
	result.i8 = ~b.i8;
}
int32x8 neg(const int32x8 &b) {
	int64 sum;
	int64 ovf = 0;
	int64 carry = 0;

	define opNeg(int b) = int32(sum = ovf - zxt64(b) - carry);
	result.i1 = opNeg(b.i1);
	carry = sum < ovf;
	result.i2 = opNeg(b.i2);
	carry = sum < ovf;
	result.i3 = opNeg(b.i3);
	carry = sum < ovf;
	result.i4 = opNeg(b.i4);
	carry = sum < ovf;
	result.i5 = opNeg(b.i5);
	carry = sum < ovf;
	result.i6 = opNeg(b.i6);
	carry = sum < ovf;
	result.i7 = opNeg(b.i7);
	carry = sum < ovf;
	result.i8 = opNeg(b.i8);
}

int32x8 add(const int32x8 &a, const int32x8 &b, bool &carryInOut) {
	int64 sum;
	int64 ovf = 0xffffffff;
	int64 carry = carryInOut;

	define opAdd(int a, int b) = int32(sum = zxt64(a) + zxt64(b) + carry);

	result.i1 = opAdd(a.i1, b.i1);
	carry = sum > ovf;
	result.i2 = opAdd(a.i2, b.i2);
	carry = sum > ovf;
	result.i3 = opAdd(a.i3, b.i3);
	carry = sum > ovf;
	result.i4 = opAdd(a.i4, b.i4);
	carry = sum > ovf;
	result.i5 = opAdd(a.i5, b.i5);
	carry = sum > ovf;
	result.i6 = opAdd(a.i6, b.i6);
	carry = sum > ovf;
	result.i7 = opAdd(a.i7, b.i7);
	carry = sum > ovf;
	result.i8 = opAdd(a.i8, b.i8);
	carryInOut = sum > ovf;
}
int32x8 add(const int32x8 &a, const int32x8 &b) {
	bool carry = false;
	result = add(a, b, &carry);
}
int32x8 add(const int32x8 &a, int32 b) {
	bool carry = false;
	int32x8 bx8 = int32x8(b);
	result = add(a, &bx8, &carry);
}

int32x8 sub(const int32x8 &a, const int32x8 &b, bool &carryInOut) {
	int64 sum;
	int64 ovf = 0;
	int64 carry = carryInOut;

	define opSub(int a, int b) = int32(sum = zxt64(a) - zxt64(b) - carry);
	result.i1 = opSub(a.i1, b.i1);
	carry = sum < ovf;
	result.i2 = opSub(a.i2, b.i2);
	carry = sum < ovf;
	result.i3 = opSub(a.i3, b.i3);
	carry = sum < ovf;
	result.i4 = opSub(a.i4, b.i4);
	carry = sum < ovf;
	result.i5 = opSub(a.i5, b.i5);
	carry = sum < ovf;
	result.i6 = opSub(a.i6, b.i6);
	carry = sum < ovf;
	result.i7 = opSub(a.i7, b.i7);
	carry = sum < ovf;
	result.i8 = opSub(a.i8, b.i8);
	carryInOut = sum < ovf;
}
int32x8 sub(const int32x8 &a, const int32x8 &b) {
	bool carry = false;
	result = sub(a, b, &carry);
}
int32x8 sub(const int32x8 &a, int32 b) {
	bool carry = false;
	int32x8 bx8 = int32x8(b);
	result = sub(a, &bx8, &carry);
}


int32x8 mul(const int32x8 &a, const int32x8 &b, int32x8 &hi) {
	
}
int32x8 mul(int32x8 &a, int32 b);

//~ i32x8 div(i32x8 &a, i32x8 &b, i32x8 &rem);
//~ i32x8 div(i32x8 &a, i32x8 &b, i32x8 &rem);
//~ i32x8 div(i32x8 &a, int32  b, i32x8 &rem);

//~ i32x8 mod(i32x8 &a, i32x8 &b) {div(a, b, result);}
//~ i32x8 mod(i32x8 &a, int32  b) {div(a, b, result);}

int32x8 i32x8_a = int32x8(-10);
//~ int32x8 i32x8_b = int32x8(1);
int32x8 i32x8_c = sub(&i32x8_a, -19);

} // +/
static if (Test.Call & 2) {
int bar(int a) {
	int foo(int b) {
		int abc() { return 1; }
		return b + abc();
	}
	return foo(a);
}
int i = bar(3); // i is assigned 4
//~ assert(i == 4);
}
}

/* itoa
uint8 tmp[1024];
string str = emit(string, ref(tmp));
itoa(str, 1024, 10, 1, true, "");
//~ */
/* Reflect
enum TypeCode: int32 {
	CAST_any = 0x00000000;		// invalid, error, ...
	CAST_vid = 0x00000001;		// void;
	CAST_bit = 0x00000002;		// bool;
	CAST_i32 = 0x00000003;		// int8, int16, int32
	CAST_u32 = 0x00000004;		// uint8, uint16, uint32
	CAST_i64 = 0x00000005;		// int64
	CAST_u64 = 0x00000006;		// uint64
	CAST_f32 = 0x00000007;		// float32
	CAST_f64 = 0x00000008;		// float64
	CAST_ptr = 0x00000009;		// pointer

	CAST_arr = 0x0000000a;		// slice(size, data)
	CAST_var = 0x0000000b;		// variant(type, data)
	CAST____ = 0x0000000d;		// typename
	CAST____ = 0x0000000e;		// variable
	CAST____ = 0x0000000f;		// function

	TYPE_def = 0x00000000;		// alias (or error)
	TYPE_rec = 0x00000010;		// typename
	TYPE_ref = 0x00000020;		// variable
	TYPE_fun = 0x00000030;		// function (variable and typename too)

	ATTR_con = 0x00000001;		// constant
	ATTR_sta = 0x00000002;		// static
	ATTR_par = 0x00000004;		// parrallel
	ATTR_snc = 0x00000008;		// synchronized
	ATTR_ref = 0x00000010;		// indirect
	ATTR_prv = 0x00000010;		// private
}

struct TypeInfo {
	pointer file;		// declared in file (cstr)
	int32 line;			// declared on line

	pointer name;		// typename (cstr)
	int32 offs;			// offset
	int32 size;			// size

	TypeInfo &base;		// function return type, typename base, variable type
	TypeInfo &args;		// function arguments, typename fields, ?
	TypeInfo &next;		// next type, argument, field

	int8  kind;			// ref(var / fun), type,
	int8  cast;			// casts to ...
	int16 attr;			// attributes

	//~ get typename = bool((this.kind & 0xf) != TYPE_ref);
	//~ get constant = bool(this.kind & ATTR_con);
	//~ get indirect = bool(this.kind & ATTR_ind);
	//~ get function = bool(this.kind & ATTR_fun);
}

//~ class typename: TypeInfo;
//~ class variable: TypeInfo;

bool instanceof(TypeInfo &ty, var obj) {
	TypeInfo &oty = obj.type;
	while (ty && ty != oty) {
		ty = ty.base;
	}
	return ty;
}

define lookUp(TypeInfo &type, int level, string name) = lookUp(type, level, name, null);

TypeInfo& lookUp(TypeInfo &type, int level, string name, variant args...) {

	bool func = args != null;

	while (type && level > 0 && type.code != TYPE_ref) {

		for (TypeInfo arg : type.args) {

			// skip defines, consts, ...
			if (arg.code != TYPE_ref)
				continue;

			// lookup only variables or functions
			if (arg.call != func)
				continue;

			if (arg.name != name)
				continue;

			if (func) {
				int i = 0;
				for (TypeInfo &param : arg.args) {

					if (i >= args.Length)
						break;

					if (param.load) ...		// by ref
					if (param.call) ...		// argument is a funtion: (byref must be set)

					if (!canAssign(param, args[i]))
						break;

					if (param.type != args[i].type)		// check return types
						break;

					if (!param.Vararg)
						i += 1;
				}

				if (i != args.Length)
					continue;
			}
			return arg;
		}

		// base class has this member ?
		type = type.base;
		level -= 1;
	}
	return null;
}

struct cls {
	static int32 c;
	int32 a;
	int32 b;
	static int M1(int a, int b) {return a + b;}
}


var a1 = var(34);
var a2 = var(4);
var t1;
cls obj;

assert(invoke(cls, "c", t1) && t1 == var(cls.c));				// t1 := cls.c;
assert(invoke(cls, "c", null, a1) && t1 == var(cls.c));			// cls.c := a1;
assert(invoke(cls, "c", t1, a1) && t1 == var(cls.c));			// t1 := cls.c = a1;

assert(invoke(cls, "M1", t1, a1, a2) && t1 == var(cls.M1(a1, a2));
assert(invoke(obj, "M1", t1, a1, a2) && t1 == var(obj.M1(a1, a2));

assert(invoke(obj, "a", t1) && t1 == var(obj.a));
assert(invoke(obj, "a", null, a2) && a2 == var(obj.a));			// t1 := obj.a := a2;

bool invoke(var obj, string name, var &&res, var args...) {
	TypeInfo class = obj.type == TypeInfo ? &obj.data : obj.type;
	TypeInfo Method = lookUp(type, -1, name, args);

	if (Method != null && Method.offset > 0) {
		uint8 stop[4096];			// this is on top of stack
		pointer st = pointer(stop);

		memset(st, Method.type.size);	// clear result

		for (int i = 0; i < Method.args.length; i += 1) {
			TypeInfo marg = Method.args[i];

			if (marg.offset > stop.length)
				return false;

			memcpy(st + marg.offset, args[i].data, marg.size);
		}

		emit(call, u32(Method.offset));

		res.type = Method.type;
		res.data = malloc(Method.type.size);
		memcpy(res.data, st, Method.type.size);
		//~ or short: res = variant(Method.type, st);

		return true;
	}
	return false;
}

invoke(t2, "a", t1, var(34));			// t1 = t2.a = 34;
invoke(t2, "a", t1, t2);				// t1 = t2.a;

bool invoke(variant obj, string name, var &&res, var args...) {
	return invoke(obj.type, name, &&res, obj, args);
}

//~ */
