//~ ./main -c -O2 -xv test_all.cvx -i./lbit.so
//~ #open src/pvmc.h
//~ #open src/ccvm.h

//~ #open src/ccvm.c
//~ #open src/code.c
//~ #open src/clog.c
//~ #open src/type.c

//~ #open src/tree.c
//~ #open src/parse.c
//~ #open src/main.c

/* TODO:
 ? static if else part
 * .
 ? separate struct and unoin declaration.
 *	in case of structures create a new constructor with all members; fix padding on stack, copy arrays, ...
 ?	in case of unions create a constructors with the bigger member.
 * 
 * define-s are implicit
 * operator-s are explicit
 * 
 * struct float3{float x; float y; float z;}
 * struct float4{float x; float y; float z; float w;}
 * 
 * and:
 * define float3(float4 x) = float3(x.x, x.y, x.z);			// this works
 * operator float4(float3 x) = float4(x.x, x.y, x.z, 0.);
 *
 * then:
 * float4 a = float4(1., 2., 3., 4.);
 * float3 b = float3(a);
 * float4 c = b;				// this will call `operator float4(float3 x)`
 * float3 d = a;				// Error: no operator float3(float4 x)
 * 
 * define void(var &a) = var.tryInvoke(a.Class, ".dtor", a.Data);
 * 
 * define void(int8 &a)    = void(0);
 * define void(int16 &a)   = void(0);
 * define void(int32 &a)   = void(0);
 * define void(int64 &a)   = void(0);
 * define void(uint8 &a)   = void(0);
 * define void(uint16 &a)  = void(0);
 * define void(uint32 &a)  = void(0);
 * define void(float32 &a) = void(0);
 * define void(float64 &a) = void(0);
 * 
 * 
**/
//~ /+ TODO: errors
/+ recursively define
define fact(int64 n) = (n * fact(n - 1));
//~ +/
//~ +/
/* TODO: operators

'operator (int lhs) + (int rhs)' := 'define .add(int lhs, int rhs)'

operator -(int rhs) = emit(i32.neg, i32(rhs));
operator (int lhs) + (int rhs) = emit(i32.add, i32(rhs), i32(lhs));
operator (string lhs) [int rhs] = emit(int, ldi.byte, i32.mad, i32(1), i32(rhs), ref(lhs));
operator (string lhs) [int rhs] (int setValue) = emit(int, ldi.byte, i32.mad, i32(1), i32(rhs), ref(lhs));
operator int(string value) = atoi(value, 10);
// */

const nan = 0./0;

const Test {
	Emit = ~0;
	Bits = ~0;
	Type = ~0;
	Call = ~0;
	Misc = ~0;
	Math = ~0;
}
static if (true) {
define hex8  int8;		//%hex8(0x%02x)
define hex16 int16;		//%hex16(0x%04x)
define hex32 int32;		//%hex32(0x%08x)
define hex64 int64;		//%hex64(0x%016X)

define print(hex32 arg) = print("%08x", int64(arg));
define println(hex32 arg) = print("%08x\n", int64(arg));
define print(hex64 arg) = print("%08X", int64(arg));
define println(hex64 arg) = print("%08X\n", int64(arg));
}

static if (Test.Emit) {
/+ emit should be such as:
#pragma aux (parm [edi] [eax] [edx] value [edi] modify exact [xmm0]) vecmul =\
	"movps	xmm0, [eax]"\
	"mulps	xmm0, [edx]"\
	"movups	[edi], xmm0"
+/
static if (Test.Emit & 0x01) {
float32 res1 = emit(f32.div, float32(2), float32(Math.pi));
float64 res2 = emit(f64.neg, f64(Math.pi));
float32 res3 = emit(int32, f32(Math.pi));
hex32 res4 = emit(hex32, f32(Math.pi));

//~ these won't work because of global vars, use option: -O-2
//~ emit(f64(math.pi));
//~ int32 i32 = emit();
//~ hex32 x32 = emit();
//~ int64 i64 = emit();
//~ hex64 x64 = emit();
//~ uint32 u32 = emit();
//~ float32 f32 = emit();
//~ float64 f64 = emit();

}
static if (Test.Emit & 0x02) {
define shl(int32 value, int count) = emit(i32.shl, i32(count), i32(value));
define shr(int32 value, int count) = emit(i32.shr, i32(count), i32(value));
define shr(uint32 value, int count) = emit(u32.shr, i32(count), i32(value));

define add(float32 a, float32 b) = emit(f32.add, f32(b), f32(a));		// := a + b
define sub(float32 a, float32 b) = emit(f32.sub, f32(b), f32(a));
define mul(float32 a, float32 b) = emit(f32.mul, f32(b), f32(a));
define div(float32 a, float32 b) = emit(f32.div, f32(b), f32(a));
define mod(float32 a, float32 b) = emit(f32.mod, f32(b), f32(a));

define mad(float32 a, float32 b, float32 c) = emit(f32.add, f32.mul, f32(a), f32(b), f32(c));	// a * b + c
define mad(float64 a, float64 b, float64 c) = emit(f64.add, f64.mul, f64(a), f64(b), f64(c));	// a * b + c
define mad(int32 size, int32 index, int32 offset) = emit(u32.mad, i32(size), i32(index), i32(offset));

//~ int a = -0x8989;
//! int32 a1 = shr(uint32(a), 8);
//! int64 a2 = shr(int32(a), 8);

//~ float32 X1 = mad(2, 3, 4000);
//~ float32 X2 = mad(float32(2), float32(3), float32(4000));
//~ float32 X3 = mad(2., 3., 4000.);

}
static if (Test.Emit & 0x04) {	// Complex

const prog {
	sisd = 1;
	simd = 2;
}

const test2exec = prog.simd;
const times2exec = -1000000;

struct Complex {
	float64 re;
	float64 im;
}

//~ define Complex(float64 re, float64 im) = emit(Complex, f64(re), f64(im));
//~ define Complex(float64 re) = Complex(re, float64(0));

static if (test2exec) {
static if (test2exec == prog.sisd) {

define add(Complex &a, Complex &b) = Complex(a.re + b.re, a.im + b.im);
define add(Complex &a, float64 b) = Complex(a.re + b, a.im);
define add(float64 a, Complex &b) = Complex(a + b.re, b.im);

define sub(Complex &a, Complex &b) = Complex(a.re - b.re, a.im - b.im);
define sub(Complex &a, float64 b) = Complex(a.re - b, a.im);
define sub(float64 a, Complex &b) = Complex(a - b.re, b.im);

define mul(Complex &a, Complex &b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);
define mul(Complex &a, float64 &b) = Complex(a.re * b, a.im * b);
define mul(float64 &a, Complex &b) = Complex(a * b.re, a * b.im);
}
static if (test2exec == prog.simd) {
//~ define add(Complex &a, Complex &b) = emit(Complex, v2d.add, f64(b.re), f64(b.im), f64(a.re), f64(a.im));
define add(Complex a, Complex b) = emit(Complex, v2d.add, val(b), val(a));
define add(Complex &a, float64 b) = emit(Complex, v2d.add, f64(b), f64(0), val(a));
define add(float64 a, Complex &b) = emit(Complex, v2d.add, val(b), f64(a), f64(0));

define sub(Complex a, Complex b) = emit(Complex, v2d.sub, val(b), val(a));
define sub(Complex &a, float64 b) = emit(Complex, v2d.sub, f64(b), f64(0), val(a));
define sub(float64 a, Complex &b) = emit(Complex, v2d.sub, val(b), f64(a), f64(0));

define mul(Complex &a, Complex &b) = emit(Complex,
	f64.sub, v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re),	// re = a.re * b.re - a.im * b.im
	f64.add, v2d.mul, val(b), f64(a.im), f64(a.re)	// im = a.re * b.im + a.im * b.re;
);
//~ define mul(Complex &a, double b) = emit(Complex, v2d.mul, f64(b), f64(b), f64(a.im), f64(a.re));
//~ define mul(double a, Complex &b) = emit(Complex, v2d.mul, f64(b.im), f64(b.re), f64(a), f64(a));
}
}

Complex Ca = Complex(3., 4.);
Complex Cb = Complex(2., 5.);
Complex Cc = mul(Ca, Cb);
//~ Complex Cc = mul(Complex(3., 4.), Complex(2., 5.));

static if (times2exec > 0) {
	for (int i = 0; i < times2exec; i += 1) {
		Complex C1 = mul(Ca, Cb);
	}
}
}// +/
static if (Test.Emit & 0x08) {	// Vector4

//~ vec4f v1 = emit(vec4f, f32(11), f32(12), f32(13), f32(14));
//~ vec4f v2 = emit(vec4f, f32(21), f32(22), f32(23), f32(24));
vec4f v1 = vec4f(11., 12., 13., 14.);
vec4f v2 = vec4f(21., 22., 23., 24.);

//~ vec4f v3 = emit(vec4f, swz.xywz, val(v1));

//~ vec4f fv = emit();
//~ float32 sp[4] = emit();

//~ float32 x0 = fv.x;
//~ float32 y0 = fv.y;
//~ float32 z0 = fv.z;
//~ float32 w0 = fv.w;

//~ float32 x = sp[0];
//~ float32 y = sp[1];
//~ float32 z = sp[2];
//~ float32 w = sp[3];

//~ for (int i = 0; i < 4; i += 1)
	//~ sp[i] = i < 0;

//~ int32 i32 = emit(void);
//~ float32 f32 = emit(void);
//~ int64 i64 = emit(void);
//~ float64 f64 = emit(void);

}// +/
} // */
static if (Test.Bits) {
int32 var = 0x00001080;		// input
static if (Test.Bits & 1) {		// bit scan reverse
int32 BSR_lib = bits.bsr(var);
int32 BSR_res = -1;
if (var != 0) {
	uint32 ans = uint32(0);
	uint32 x = uint32(var);
	//~ if (x & 0xffffffff00000000) { ans += 32; x >>= 32; }
	if (x & uint32(0xffff0000)) { ans += 16; x >>= 16; }
	if (x & uint32(0x0000ff00)) { ans +=  8; x >>=  8; }
	if (x & uint32(0x000000f0)) { ans +=  4; x >>=  4; }
	if (x & uint32(0x0000000c)) { ans +=  2; x >>=  2; }
	if (x & uint32(0x00000002)) { ans +=  1; }
	BSR_res = ans;
}
}
static if (Test.Bits & 2) {		// highest bit
//~ hex32 BLO_res = var & -var;
hex32 BHI_lib = bits.hibit(var);
hex32 BHI_res = -1;
if (var) {
	uint32 u = uint32(var);
	u |= u >> 1;
	u |= u >> 2;
	u |= u >> 4;
	u |= u >> 8;
	u |= u >> 16;
	BHI_res = u - (u >> 1);
}
}
static if (Test.Bits & 4) {		// swap bits
hex32 SWP_lib = bits.swp(var);
hex32 SWP_res = -1;
if (var) {
	uint32 x = uint32(var);
	x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
	x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
	x = ((x >> 4) & 0x0F0F0F0F) | ((x & 0x0F0F0F0F) << 4);
	x = ((x >> 8) & 0x00FF00FF) | ((x & 0x00FF00FF) << 8);
	SWP_res = (x >> 16) | (x << 16);
}
//~ +/
}
static if (Test.Bits & 8) {		// compute bits
//~ /+
void bitsget(bool signed, int size, int64 &min, int64 &max) {
	int64 mask = bits.shr(int64(-1), -size);
	min = bits.shl(-int64(signed), size - 1);
	max = bits.and(min - 1, mask);
}

int bitsize = 14;
hex64 min;
hex64 max;
hex64 umin;
hex64 umax;

bitsget(true, bitsize, &min, &max);
bitsget(!true, bitsize, &umin, &umax);
//~ +/
}
} // */
static if (Test.Type) {
static if (Test.Type & 0x01) {		// lookup test

define int1 = int(1990);
define int1() = int(1995);
define int1(int32 _) = int(2010);
define int1(float64 _) = int(2015);

int32 a1 = int1;			// 1990
int32 a2 = int1();			// 1995
int32 a3 = int1(0);			// 2010
int32 a4 = int1(0.0);		// 2015

}
static if (Test.Type & 0x02) {

//~ double TT2_1 = lerp(x, 0., 5.);
//~ float e1 = 0;
//~ float e2 = 1;
//~ float s = (e2-e1) / 400;
//~ for (float t = e1; t < e2; t += s) {
	//~ println(smooth(t, e1, e2));
	//~ println(clamp(t, .2, .5));
//~ }

define isNan(float64 x) = bool(x != x);
define isNan(float32 x) = bool(x != x);
float64 NAN = nan;//Math.nan;
//~ int isNan1 = int(isNan(NAN));
//~ int isNan2 = int(isNan(Math.nan));
}
static if (Test.Type & 0x04) {		// enum
//~ struct and arrays
struct:0 fiu32 {int32 i;float32 f;}
struct:0 fiu64 {int64 i;float64 f;}
define intTY int32;

struct:8 intabc {
	intTY X;		//%%?08b
	intTY Y;		//%%?08b
	intTY Z;		//%%?08b
	//~ intTY W;		//!X%?03x
	fiu64 U;
}

intabc alma;
alma.U.f = 9;
alma.X = 8;
//~ alma.Z = alma.Y = alma.X = 7;

//~ intTY c[3] = emit();
//~ c[1] |= 1;

//~ intabc alma1 = alma;
}
static if (Test.Type & 0x08) {		// color
struct:1 bgra {
	uint8 b; 	//%blue(%d)
	uint8 g; 	//%green(%d)
	uint8 r; 	//%red(%d)
	uint8 a; 	//%alpha(%d)
}
struct:0 color {
	int32 val;	//%#%08x
	bgra col;	//%
}

define color(int32 c) = emit(color, i32(c));
//~ define cxff(int32 c) = int32(c & 0xff);
//~ define color(int32 a, int32 r, int32 g, int32 b) = emit(color, i32((cxff(a) << 24) | (cxff(r) << 16) | (cxff(g) << 8) | cxff(b)));

define color(int32 a, int32 r, int32 g, int32 b) = color(int32(((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | ((b & 0xff) << 0)));
define color(float64 a, float64 r, float64 g, float64 b) = color(int32(a*255), int32(r*255), int32(g*255), int32(b*255));

define color(int32 r, int32 g, int32 b) = color(int32(255), r, g, b);
define color(float64 r, float64 g, float64 b) = color(float64(1), r, g, b);

//~ color C1 = color(0xcafebabd);
//~ color C2 = color(0xca, 0xfe, 0xba, 0xbc);
//~ color C3 = emit(color, i32(0xcafebabe));
//~ color C4 = emit(color, i32(0xcafebabf));
color C5 = color(0.1, .5, 1.);
//~ color C5 = color(1, 5, 205);

//~ uint8  u08[4] = emit();
//~ uint32 u32[4] = emit();

/+ TODO: enums
enum colors: color {
	c5 = color(0.1, .5, 1.);
	none = int32(-1);
	//~ pink = color(2,3,4);
}
color c5 = colors.c5;
// +/
}
static if (Test.Type & 0x10) {
}
} // */
static if (Test.Misc) {
static if (Test.Misc & 1) {			// matrix multiply
// Matrix Multiply

define dim = 3;
define scalar float64;		//%%f
scalar m1[dim][dim];
scalar m2[dim][dim];
scalar m3[dim][dim];

//~ /+ Initialize
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		//~TODO: error: m1[i][j] = m2[i][j] = (i == j) + 2;
		m1[i][j] = m2[i][j] = (i == j) * 2. + 1;
	}
} // +/

//~ /+ Compute
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		m3[i][j] = 0;
		for (int k = 0; k < dim; k += 1) {
			m3[i][j] += m1[i][k] * m2[k][j];
		}
	}
} // +/

//~ /+ Print
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		if (j != 0)
			putchr(' ');
		print(float64(m1[i][j]));
	}
	putchr('\n');
} // +/
}
} // */
static if (Test.Math) {
static if (Test.Math & 1) {

	//~ for (int i = 0; i < 0; i += 1) ;

	double x = Math.pi / 2;
	double absx = abs(-x);
	double sinx = sin(x);
	double cosx = cos(x);
	double tanx = tan(x);
	double logx = log(x);
	double expx = exp(x);
	double powx = pow(2, 8);
	//~ double ___x = ___(x);
}
static if (Test.Math & 2) {		// fixed point
define fixed int32;
define __fix = 16;

define fixed_fix(int64 ^val, int ^__fix) = fixed(bits.shr(val + bits.shr(val, __fix) + 1, __fix));
define add(fixed lhs, fixed rhs, int __fix) = fixed(lhs + rhs);
define sub(fixed lhs, fixed rhs, int __fix) = fixed(lhs - rhs);
define mul(fixed lhs, fixed rhs, int __fix) = fixed_fix(int64(lhs) * rhs, __fix);

define fixed(int32 val, int __fix) = fixed(val << __fix);
define fixed(float32 val, int __fix) = fixed(val * (1 << __fix));
define fixed(float64 val, int __fix) = fixed(val * (1 << __fix));

define int(fixed val, int __fix) = int(val >> __fix);
define double(fixed val, int __fix) = double(val / double(1 << __fix));

define fixed_fix(int64 val) = fixed_fix(val, __fix);
define add(fixed lhs, fixed rhs) = add(lhs, rhs, __fix);
define sub(fixed lhs, fixed rhs) = sub(lhs, rhs, __fix);
define mul(fixed lhs, fixed rhs) = mul(lhs, rhs, __fix);

define fixed(int val)   = fixed(val, __fix);
define fixed(float32 val) = fixed(val, __fix);
define fixed(float64 val) = fixed(val, __fix);

define int(fixed val) = int(val, __fix);
define double(fixed val) = double(val, __fix);

double fixed_test = double(add(fixed(2.5), fixed(3)));
}

} // */
static if (Test.Call) {
static if (Test.Call & 1) {			// 256 bit(8x32bit) integer
struct i32x8 {
	int32 i8;	//%%08x
	int32 i7;	//%%08x
	int32 i6;	//%%08x
	int32 i5;	//%%08x
	int32 i4;	//%%08x
	int32 i3;	//%%08x
	int32 i2;	//%%08x
	int32 i1;	//%%08x
	//~ int32 i1;	//%%08x
	//~ int32 i2;	//%%08x
	//~ int32 i3;	//%%08x
	//~ int32 i4;	//%%08x
	//~ int32 i5;	//%%08x
	//~ int32 i6;	//%%08x
	//~ int32 i7;	//%%08x
	//~ int32 i8;	//%%08x
} // */

//~ define i32x8(int i1, int i2, int i3, int i4, int i5, int i6, int i7, int i8) = emit(i32x8, i32(i1), i32(i2), i32(i3), i32(i4), i32(i5), i32(i6), i32(i7), i32(i8));
define i32x8(int32 i0) = emit(i32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32.shr, i32(31), dupp.x1, i32(i0));
define i32x8(uint32 i0) = emit(i32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32(0), i32(i0));

void println(i32x8 &x) {
	print("%d, ", x.i1);
	print("%d, ", x.i2);
	print("%d, ", x.i3);
	print("%d, ", x.i4);
	print("%d, ", x.i5);
	print("%d, ", x.i6);
	print("%d, ", x.i7);
	print("%d\n", x.i8);
}

//~ define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend

i32x8 cmt(i32x8 &b) {
	result.i1 = ~b.i1;
	result.i2 = ~b.i2;
	result.i3 = ~b.i3;
	result.i4 = ~b.i4;
	result.i5 = ~b.i5;
	result.i6 = ~b.i6;
	result.i7 = ~b.i7;
	result.i8 = ~b.i8;
}
i32x8 neg(i32x8 &b) {
	int64 sum;
	int64 ovf = 0;
	int64 carry = 0;

	define opNeg(int b) = int32(sum = ovf - zxt64(b) - carry);
	result.i1 = opNeg(b.i1);
	carry = sum < ovf;
	result.i2 = opNeg(b.i2);
	carry = sum < ovf;
	result.i3 = opNeg(b.i3);
	carry = sum < ovf;
	result.i4 = opNeg(b.i4);
	carry = sum < ovf;
	result.i5 = opNeg(b.i5);
	carry = sum < ovf;
	result.i6 = opNeg(b.i6);
	carry = sum < ovf;
	result.i7 = opNeg(b.i7);
	carry = sum < ovf;
	result.i8 = opNeg(b.i8);
}
i32x8 add(i32x8 &a, i32x8 &b) {
	int64 sum;
	int64 ovf = 0xffffffff;
	int64 carry = 0;

	define opAdd(int a, int b) = int32(sum = zxt64(a) + zxt64(b) + carry);
	result.i1 = opAdd(a.i1, b.i1);
	carry = sum > ovf;
	result.i2 = opAdd(a.i2, b.i2);
	carry = sum > ovf;
	result.i3 = opAdd(a.i3, b.i3);
	carry = sum > ovf;
	result.i4 = opAdd(a.i4, b.i4);
	carry = sum > ovf;
	result.i5 = opAdd(a.i5, b.i5);
	carry = sum > ovf;
	result.i6 = opAdd(a.i6, b.i6);
	carry = sum > ovf;
	result.i7 = opAdd(a.i7, b.i7);
	carry = sum > ovf;
	result.i8 = opAdd(a.i8, b.i8);
}
i32x8 sub(i32x8 &a, i32x8 &b) {
	int64 sum;
	int64 ovf = 0;
	int64 carry = 0;

	define opSub(int a, int b) = int32(sum = zxt64(a) - zxt64(b) - carry);
	result.i1 = opSub(a.i1, b.i1);
	carry = sum < ovf;
	result.i2 = opSub(a.i2, b.i2);
	carry = sum < ovf;
	result.i3 = opSub(a.i3, b.i3);
	carry = sum < ovf;
	result.i4 = opSub(a.i4, b.i4);
	carry = sum < ovf;
	result.i5 = opSub(a.i5, b.i5);
	carry = sum < ovf;
	result.i6 = opSub(a.i6, b.i6);
	carry = sum < ovf;
	result.i7 = opSub(a.i7, b.i7);
	carry = sum < ovf;
	result.i8 = opSub(a.i8, b.i8);
}

//~ i32x8 add(i32x8 &a, int32  b) {}
//~ i32x8 sub(i32x8 &a, i32x8 &b) {}
//~ i32x8 add(i32x8 &a, i32x8 &b, int32 &ovf = null);
//~ i32x8 add(i32x8 &a, int32  b, int32 &ovf = null);
//~ i32x8 sub(i32x8 &a, i32x8 &b, int32 &ovf = null);
//~ i32x8 sub(i32x8 &a, int32  b, int32 &ovf = null);
//~ i32x8 mul(i32x8 &a, i32x8 &b, i32x8 &ovf) {}
//~ i32x8 mul(i32x8 &a, i32x8 &b, i32x8 &ovf = null);
//~ i32x8 mul(i32x8 &a, int32  b, i32x8 &ovf = null);

//~ i32x8 div(i32x8 &a, i32x8 &b, i32x8 &rem) {}
//~ i32x8 div(i32x8 &a, i32x8 &b, i32x8 &rem = null);
//~ i32x8 div(i32x8 &a, int32  b, i32x8 &rem = null);
//~ i32x8 mod(i32x8 &a, i32x8 &b) {div(a, b, result);}
//~ i32x8 mod(i32x8 &a, int32  b) {div(a, b, result);}

//~ TODO: no indirect store, if global variables are enabled will fail
//~ i32x8 i32x8_a = i32x8(int32(0x0fffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff), int32(0xffffffff));
//~ i32x8 i32x8_b = i32x8(1);
//~ i32x8 i32x8_c = add(i32x8_a, i32x8_b);

} // +/
} // */

/* itoa
uint8 tmp[1024];
string str = emit(string, ref(tmp));
itoa(str, 1024, 10, 1, true, "");
//~ */

/* Reflect
const TypeCode: int32 {
	CAST_any = 0x00000000;		// invalid, error, ...
	CAST_vid = 0x00000001;		// void;
	CAST_bit = 0x00000002;		// bool;
	CAST_i32 = 0x00000003;		// int8, int16, int32
	CAST_u32 = 0x00000004;		// uint8, uint16, uint32
	CAST_i64 = 0x00000005;		// int64
	CAST_u64 = 0x00000006;		// uint64
	CAST_f32 = 0x00000007;		// float32
	CAST_f64 = 0x00000008;		// float64
	CAST_ptr = 0x00000009;		// pointer

	CAST_arr = 0x0000000a;		// slice(size, data)
	CAST_var = 0x0000000b;		// variant(type, data)
	CAST_p4x = 0x0000000c;		// 
	CAST____ = 0x0000000d;		// typename
	CAST____ = 0x0000000e;		// variable
	CAST____ = 0x0000000f;		// function

	TYPE_def = 0x00000000;		// alias (or error)
	TYPE_rec = 0x00000010;		// typename
	TYPE_ref = 0x00000020;		// variable
	TYPE_fun = 0x00000030;		// function (variable and typename too)

	ATTR_con = 0x00000001;		// constant
	ATTR_sta = 0x00000002;		// static
	ATTR_par = 0x00000004;		// parrallel
	ATTR_snc = 0x00000008;		// synchronized
	ATTR_ref = 0x00000010;		// indirect
	ATTR_pub = 0x00000010;		// public
}

struct TypeInfo {
	pointer file;		// declared in file (cstr)
	int32 line;			// declared on line

	pointer name;		// typename (cstr)
	int32 offs;			// offset
	int32 size;			// size

	TypeInfo &base;		// function return type, typename base, variable type
	TypeInfo &args;		// function arguments, typename fields, ?
	TypeInfo &next;		// next type, argument, field

	int8  kind;			// ref(var / fun), type,
	int8  cast;			// casts to ...
	int16 attr;			// attributes

	//~ get typename = bool((this.kind & 0xf) != TYPE_ref);
	//~ get constant = bool(this.kind & ATTR_con);
	//~ get indirect = bool(this.kind & ATTR_ind);
	//~ get function = bool(this.kind & ATTR_fun);
}

//~ class type: TypeInfo {}
//~ class reference: TypeInfo {}

bool instanceof(TypeInfo &ty, var obj) {
	TypeInfo &oty = obj.type;
	while (ty && ty != oty) {
		ty = ty.base;
	}
	return ty;
}

define lookUp(TypeInfo &type, int level, string name) = lookUp(type, level, name, null);

TypeInfo& lookUp(TypeInfo &type, int level, string name, variant args...) {

	bool func = args != null;

	while (type && level > 0 && type.code != TYPE_ref) {

		for (TypeInfo arg : type.args) {

			// skip defines, consts, ...
			if (arg.code != TYPE_ref)
				continue;

			// lookup only variables or functions
			if (arg.call != func)
				continue;

			if (arg.name != name)
				continue;

			if (func) {
				int i = 0;
				for (TypeInfo &param : arg.args) {

					if (i >= args.Length)
						break;

					if (param.load) ...		// by ref
					if (param.call) ...		// argument is a funtion: (byref must be set)

					if (!canAssign(param, args[i]))
						break;

					if (param.type != args[i].type)		// check return types
						break;

					if (!param.Vararg)
						i += 1;
				}

				if (i != args.Length)
					continue;
			}
			return arg;
		}

		// base class has this member ?
		type = type.base;
		level -= 1;
	}
	return null;
}

bool invoke(variant typename, string name, var args...) { ... }
bool getValue(variant typename, string name, var value) { ... }
bool setValue(variant typename, string name, var value) { ... }

struct testcls {
	static int32 c;
	int32 a;
	int32 b;
}

int t1;

setValue(testcls, "c", var(34));
t1 = int(getValue(testcls, "c"));

testcls t2;

setValue(t2, "a", var(34));
t1 = int(getValue(t2, "a"));

bool invoke(TypeInfo &type, string name, var &result, var args...) {

	TypeInfo Method = lookUp(type, -1, name, args);

	if (Method != null && Method.offset > 0) {
		uint8 stop[4096];			// this is on top of stack
		pointer st = pointer(stop);

		memset(st, Method.type.size);	// clear result

		for (int i = 0; i < Method.args.length; i += 1) {
			TypeInfo marg = Method.args[i];

			if (marg.offset > stop.length)
				return false;

			memcpy(st + marg.offset, args[i].data, marg.size);
		}

		emit(call, u32(Method.offset));

		result.type = Method.type;
		result.data = malloc(Method.type.size);
		memcpy(result.data, st, Method.type.size);

		return true;
	}

	return false;
}

assert(true);
static struct assert {
	const Flags {
		abort = 0x0001;
		print = 0x0008;
	}
	flags = Flags.print | Flags.abort;
	static void callback(string file, int line, string message, string stacktrace[]) = function() {
		if (assert.flags & Flags.print) {
			libc(log, file, line, 0, message);
		}
		if (assert.flags & Flags.abort) {
			exit(-1);
		}
	}
	static void trace(string message);
}

//~ */
/* stupid things
/+ swap typedefs
define float float64;
define double float32;
double res = .35;
//~ +/
/+ do nothing
if (1)
	{{{{{;;;};}};;;}{;;;}}
else
	{{;};;{;}}
//~ +/
//~ */
