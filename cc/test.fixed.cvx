// TODO: HACK: 0 alignment disables constructor creation
struct fixed:0 {
	int32 value;
}

// TODO: struct Fixed(int FractBits) { ... }
static struct Fixed {
	// constants
	//~ define FractBits = 24;

	enum: int32 {

		FractBits = 16;

		fxpmask = (1 << FractBits) - 1;
		fxp_one = 1 << FractBits;

		fxp_r2d = 0x394bb834 >> (24 - FractBits);		// 180 / pi : radians to degrees
		fxp_d2r = 0x000477d1 >> (24 - FractBits);		// pi / 180 : degrees to radians

		fxp_ln2 = 0x00b17217 >> (24 - FractBits);		// .6931471805599453 : natural logarithm (2)
		fxp_lg2 = 0x004d104d >> (24 - FractBits);		// .3010299956639812 : decimal logarithm (2)
		fxp_l2e = 0x01715476 >> (24 - FractBits);		// 1.442695040888963 : logarithm base 2  (e)
		fxp_l2t = 0x035269e1 >> (24 - FractBits);		// 3.321928094887362 : logarithm base 2 (10)

		fxp_mpi = 0x3243f6a8 >> (28 - FractBits);
		fxp_2pi = 0x3243f6a8 >> (28 - FractBits - 1);
		fxp_pi2 = 0x3243f6a8 >> (28 - FractBits + 1);

		fxp_nan = 0x80000000;
		fxp_max = 0x7fffffff;
		fxp_min = -fxp_max;
	}

	const define asFixed(const int32 val) = emit(fixed, i32(val));
	const define toFixed(const int32 val) = emit(fixed, i32(val << FractBits));
	const define toFixed(const float64 val) = emit(fixed, int32(val * (1 << FractBits)));

	define mul(int32 lhs, int32 rhs, int __fixp) = int32(int64.Sar(int64(lhs) * rhs, __fixp));
	define div(int32 lhs, int32 rhs, int __fixp) = int32(int64.Shl(int64(lhs), __fixp) / rhs);

	define add(fixed &lhs, fixed &rhs) = asFixed(lhs.value + rhs.value);
	define sub(fixed &lhs, fixed &rhs) = asFixed(lhs.value - rhs.value);
	define mul(fixed &lhs, fixed &rhs) = asFixed(mul(lhs.value, rhs.value, FractBits));
	define mul(fixed &lhs, int32 rhs) = asFixed(lhs.value * rhs);
	define mul(int32 lhs, fixed &rhs) = asFixed(lhs * rhs.value);
	define div(fixed &lhs, fixed &rhs) = asFixed(div(lhs.value, rhs.value, FractBits));
	define div(fixed &lhs, int32 rhs) = asFixed(lhs.value / rhs);
	define mod(fixed &lhs, fixed &rhs) = asFixed(lhs.value % rhs.value);
	define inv(fixed rhs) = div(asFixed(fxp_one), rhs);

	uint32 bsr(uint32 x) {		// scan bit reverse (first bit = 31 (msb))
		if (x == 0) {
			return -1;
		}
		result = 0;
		if ((x & 0xffff0000) != 0) {
			result += 16;
			x >>= 16;
		}
		if ((x & 0x0000ff00) != 0) {
			result += 8;
			x >>= 8;
		}
		if ((x & 0x000000f0) != 0) {
			result += 4;
			x >>= 4;
		}
		if ((x & 0x0000000c) != 0) {
			result += 2;
			x >>= 2;
		}
		if ((x & 0x00000002) != 0) {
			result += 1;
		}
		return result;
	}
	uint32 gettbl(const uint16 tbl[257], int32 x) {
		uint32 idx = (x >> (FractBits -  8)) & 0x00ff;
		uint32 lrp = (x << (24 - FractBits)) & 0xffff;
		result = (tbl[idx] << 16) + lrp * (tbl[idx + 1] - tbl[idx]);
	}

	fixed eval(fixed x, const fixed p[]) {
		result = p[0];
		for (int i = 1; i < p.length; i += 1) {
			result = add(p[i], mul(result, x));
		}
	}
	fixed eval4(fixed x, const fixed p[4]) {
		result.value = p[0].value;
		result.value = p[1].value + mul(result.value, x.value, FractBits);
		result.value = p[2].value + mul(result.value, x.value, FractBits);
		result.value = p[3].value + mul(result.value, x.value, FractBits);
	}

	fixed fxp2xp(fixed x) {
		static const uint16 tbl2xp[] = [		// (2 ** x) - 1, x: [0,1)
			0x0000, 0x00b2, 0x0164, 0x0217, 0x02ca, 0x037d, 0x0431, 0x04e6,
			0x059b, 0x0651, 0x0707, 0x07bd, 0x0874, 0x092c, 0x09e4, 0x0a9c,
			0x0b56, 0x0c0f, 0x0cc9, 0x0d84, 0x0e3f, 0x0efa, 0x0fb6, 0x1073,
			0x1130, 0x11ee, 0x12ac, 0x136b, 0x142a, 0x14e9, 0x15aa, 0x166a,
			0x172c, 0x17ed, 0x18b0, 0x1972, 0x1a36, 0x1afa, 0x1bbe, 0x1c83,
			0x1d48, 0x1e0e, 0x1ed5, 0x1f9c, 0x2064, 0x212c, 0x21f5, 0x22be,
			0x2388, 0x2452, 0x251d, 0x25e8, 0x26b4, 0x2781, 0x284e, 0x291c,
			0x29ea, 0x2ab9, 0x2b88, 0x2c58, 0x2d28, 0x2df9, 0x2ecb, 0x2f9d,
			0x3070, 0x3143, 0x3217, 0x32ec, 0x33c1, 0x3496, 0x356c, 0x3643,
			0x371a, 0x37f2, 0x38cb, 0x39a4, 0x3a7e, 0x3b58, 0x3c33, 0x3d0e,
			0x3dea, 0x3ec7, 0x3fa4, 0x4082, 0x4161, 0x4240, 0x431f, 0x4400,
			0x44e1, 0x45c2, 0x46a4, 0x4787, 0x486a, 0x494e, 0x4a33, 0x4b18,
			0x4bfe, 0x4ce4, 0x4dcb, 0x4eb3, 0x4f9b, 0x5084, 0x516e, 0x5258,
			0x5343, 0x542e, 0x551a, 0x5607, 0x56f4, 0x57e2, 0x58d1, 0x59c1,
			0x5ab0, 0x5ba1, 0x5c92, 0x5d84, 0x5e77, 0x5f6a, 0x605e, 0x6153,
			0x6248, 0x633e, 0x6434, 0x652c, 0x6624, 0x671c, 0x6815, 0x690f,
			0x6a0a, 0x6b05, 0x6c01, 0x6cfe, 0x6dfb, 0x6ef9, 0x6ff8, 0x70f7,
			0x71f7, 0x72f8, 0x73fa, 0x74fc, 0x75ff, 0x7702, 0x7807, 0x790c,
			0x7a11, 0x7b18, 0x7c1f, 0x7d27, 0x7e2f, 0x7f38, 0x8042, 0x814d,
			0x8259, 0x8365, 0x8472, 0x857f, 0x868e, 0x879d, 0x88ac, 0x89bd,
			0x8ace, 0x8be0, 0x8cf3, 0x8e07, 0x8f1b, 0x9030, 0x9146, 0x925c,
			0x9373, 0x948c, 0x95a4, 0x96be, 0x97d8, 0x98f3, 0x9a0f, 0x9b2c,
			0x9c49, 0x9d67, 0x9e86, 0x9fa6, 0xa0c6, 0xa1e8, 0xa30a, 0xa42d,
			0xa550, 0xa675, 0xa79a, 0xa8c0, 0xa9e7, 0xab0e, 0xac37, 0xad60,
			0xae8a, 0xafb5, 0xb0e0, 0xb20d, 0xb33a, 0xb468, 0xb597, 0xb6c7,
			0xb7f7, 0xb929, 0xba5b, 0xbb8e, 0xbcc2, 0xbdf7, 0xbf2c, 0xc063,
			0xc19a, 0xc2d2, 0xc40b, 0xc544, 0xc67f, 0xc7bb, 0xc8f7, 0xca34,
			0xcb72, 0xccb1, 0xcdf1, 0xcf31, 0xd073, 0xd1b5, 0xd2f8, 0xd43d,
			0xd582, 0xd6c7, 0xd80e, 0xd956, 0xda9e, 0xdbe8, 0xdd32, 0xde7d,
			0xdfc9, 0xe116, 0xe264, 0xe3b3, 0xe503, 0xe654, 0xe7a5, 0xe8f8,
			0xea4b, 0xeb9f, 0xecf5, 0xee4b, 0xefa2, 0xf0fa, 0xf253, 0xf3ad,
			0xf507, 0xf663, 0xf7c0, 0xf91e, 0xfa7c, 0xfbdc, 0xfd3c, 0xfe9e,
			0xffff];

		/* Math Logic:
		 * fxp2xp(x) <=> exp2(x) <=> 2 ** x
		 * n = floor(x)
		 * q = fract(x)
		 * => exp2(x) = exp2(n + q) = exp2(n) * exp2(q)
		 * exp2(q) = look up from table tbl2px (>> (32 - FXPOINT) + FXP_ONE)
		 * exp2(n) is a shift operation by n
		 * => exp2(x) = (x >= 0) ? (exp2(q) << n) : (exp2(q) >> -n)
		 * ---------------------------------------------------
		 */
		int32 n = (x.value >> FractBits) + FractBits;
		if (n > 0 && n < 31) {
			result.value = (1 << n) | (gettbl(tbl2xp, x.value) >> (32 - n));
		}
		else if (n > 0) {
			result = asFixed(fxp_max);
		}
		else {
			result = asFixed(0);
		}
	}

	fixed fxplg2(fixed x) {
		static const uint16 tbllg2[] = [		// log2(x) - 1, x: [0,1)
			0x0000, 0x0171, 0x02e0, 0x044e, 0x05ba, 0x0725, 0x088e, 0x09f7,
			0x0b5d, 0x0cc3, 0x0e27, 0x0f8a, 0x10eb, 0x124b, 0x13aa, 0x1508,
			0x1664, 0x17bf, 0x1919, 0x1a71, 0x1bc8, 0x1d1e, 0x1e73, 0x1fc6,
			0x2119, 0x226a, 0x23ba, 0x2508, 0x2656, 0x27a2, 0x28ed, 0x2a37,
			0x2b80, 0x2cc8, 0x2e0f, 0x2f54, 0x3098, 0x31dc, 0x331e, 0x345f,
			0x359f, 0x36de, 0x381b, 0x3958, 0x3a94, 0x3bce, 0x3d08, 0x3e41,
			0x3f78, 0x40af, 0x41e4, 0x4319, 0x444c, 0x457f, 0x46b0, 0x47e1,
			0x4910, 0x4a3f, 0x4b6c, 0x4c99, 0x4dc5, 0x4eef, 0x5019, 0x5142,
			0x526a, 0x5391, 0x54b7, 0x55dc, 0x5700, 0x5824, 0x5946, 0x5a68,
			0x5b89, 0x5ca8, 0x5dc7, 0x5ee5, 0x6003, 0x611f, 0x623a, 0x6355,
			0x646f, 0x6588, 0x66a0, 0x67b7, 0x68ce, 0x69e4, 0x6af8, 0x6c0c,
			0x6d20, 0x6e32, 0x6f44, 0x7055, 0x7165, 0x7274, 0x7383, 0x7490,
			0x759d, 0x76aa, 0x77b5, 0x78c0, 0x79ca, 0x7ad3, 0x7bdb, 0x7ce3,
			0x7dea, 0x7ef0, 0x7ff6, 0x80fb, 0x81ff, 0x8302, 0x8405, 0x8507,
			0x8608, 0x8709, 0x8809, 0x8908, 0x8a06, 0x8b04, 0x8c01, 0x8cfe,
			0x8dfa, 0x8ef5, 0x8fef, 0x90e9, 0x91e2, 0x92db, 0x93d2, 0x94ca,
			0x95c0, 0x96b6, 0x97ab, 0x98a0, 0x9994, 0x9a87, 0x9b7a, 0x9c6c,
			0x9d5e, 0x9e4f, 0x9f3f, 0xa02e, 0xa11e, 0xa20c, 0xa2fa, 0xa3e7,
			0xa4d4, 0xa5c0, 0xa6ab, 0xa796, 0xa881, 0xa96a, 0xaa53, 0xab3c,
			0xac24, 0xad0c, 0xadf2, 0xaed9, 0xafbe, 0xb0a4, 0xb188, 0xb26c,
			0xb350, 0xb433, 0xb515, 0xb5f7, 0xb6d9, 0xb7ba, 0xb89a, 0xb97a,
			0xba59, 0xbb38, 0xbc16, 0xbcf4, 0xbdd1, 0xbead, 0xbf8a, 0xc065,
			0xc140, 0xc21b, 0xc2f5, 0xc3cf, 0xc4a8, 0xc580, 0xc658, 0xc730,
			0xc807, 0xc8de, 0xc9b4, 0xca8a, 0xcb5f, 0xcc34, 0xcd08, 0xcddc,
			0xceaf, 0xcf82, 0xd054, 0xd126, 0xd1f7, 0xd2c8, 0xd399, 0xd469,
			0xd538, 0xd607, 0xd6d6, 0xd7a4, 0xd872, 0xd93f, 0xda0c, 0xdad9,
			0xdba5, 0xdc70, 0xdd3b, 0xde06, 0xded0, 0xdf9a, 0xe063, 0xe12c,
			0xe1f5, 0xe2bd, 0xe385, 0xe44c, 0xe513, 0xe5d9, 0xe69f, 0xe765,
			0xe82a, 0xe8ef, 0xe9b3, 0xea77, 0xeb3b, 0xebfe, 0xecc1, 0xed83,
			0xee45, 0xef06, 0xefc8, 0xf088, 0xf149, 0xf209, 0xf2c8, 0xf387,
			0xf446, 0xf505, 0xf5c3, 0xf680, 0xf73e, 0xf7fb, 0xf8b7, 0xf973,
			0xfa2f, 0xfaea, 0xfba5, 0xfc60, 0xfd1a, 0xfdd4, 0xfe8e, 0xff47,
			0xffff];

		/* Math Logic:
		 * log2(x) logarithm base 2
		 * log2(x) = log2((2 ** n) * (x / 2 ** n)) = 
		 * = log2(2 ** n) + log2(x / 2 ** n) = n + log2(q)
		 * n = first bit in x (ASM : BSR (bit scan reverse))
		 * q = x / 2 ** n = (x > 1) ? (x >> n) : (x << -n)
		 * x > 1 <=> n - FXPOINT > 0
		 * log2(q) = get from table [tbllg2], q in [1, 2)
		 * ---------------------------------------------------
		 */
		if (x.value <= 0) {
			result.value = (x.value != 0) ? fxp_nan : -fxp_max;
		}
		else {
			int32 n = bsr(x.value) - FractBits;
			uint32 q = gettbl(tbllg2, n > 0 ? (x.value >> n) : (x.value << -n));
			result.value = (n << FractBits) + (q >> (32 - FractBits));
		}
	}

	void sincos(fixed x, fixed &s, fixed &c) {
		//~ TODO: const static fixed polysin[4] = {
		const static fixed polysin[] = [		// eps < 0.000124 in [0, 2pi]
			toFixed(-1./5040	+.00001),		// 1/7!
			toFixed(+1./120		+.00000),		// 1/5!
			toFixed(-1./6		-.00006),		// 1/3!
			toFixed(+1./1		+.00000)		// 1/1!
		];
		const static fixed polycos[] = [		// eps < 0.000126 in [0, 2pi]
			toFixed(-1./720		-.00004),		// 1/6!
			toFixed(+1./24		+.00003),		// 1/4!
			toFixed(-1./2		-.00007),		// 1/2!
			toFixed(+1./1		-.00010)		// 1/0!
		];

		int32 ssgn = 1;
		int32 csgn = 1;

		x.value %= fxp_2pi;

		if (x.value < 0) {
			x.value += fxp_2pi;
		}

		// x in [0, 2*pi)
		if (x.value >= fxp_mpi) {
			x.value = fxp_2pi - x.value;
			ssgn = -1;
		}

		// x in [0, pi)
		if (x.value >= fxp_pi2) {
			x.value -= fxp_mpi;
			ssgn = -ssgn;
			csgn = -1;
		}

		// x in [0, pi/2)
		fixed sqr = mul(x, x);
		c = mul(csgn, eval4(sqr, polycos));
		s = mul(ssgn, mul(x, eval4(sqr, polysin)));
	}

	//~ ln(x) := ln2 * l2(x);
	define Ln(fixed x) = mul(fxp_ln2, fxplg2(x));

	//~ ln(x) := lg2 * l2(x);
	define Lg(fixed x) = mul(fxp_lg2, fxplg2(x));

	//~ e ** x = 2 ** (l2e * x)
	define Exp(fixed x) = fxp2xp(mul(fxp_l2e, x));

	//~ 10 ** x = 2 ** (l2t * x)
	//~ define Txp(fixed x) = fxp2xp(mul(fxp_l2t, x));

	fixed Sqrt(fixed x) {
		if (x.value < 0) {
			return asFixed(fxp_nan);
		}

		static if ((FractBits & 1) == 0) {
			// from "Graphics Gems"
			uint32 testDiv;
			uint32 root = 0;			// Clear root
			uint32 remHi = 0;			// Clear high part of partial remainder
			uint32 remLo = x.value;			// Get argument into low part of partial remainder
			uint32 count = 16 + (FractBits >> 1);	// Load loop counter
			for (;count > 0; count -= 1) {
				remHi = (remHi << 2) | (remLo >> 30);		// get 2 bits of arg
				remLo <<= 2;
				root <<= 1;					// Get ready for the next bit in the root
				testDiv = (root << 1) + 1;			// Test radical
				if (remHi >= testDiv) {
					remHi -= testDiv;
					root += 1;
				}
			}
			result = asFixed(int32(root));
		}
		static if ((FractBits & 1) != 0) {
			result = fxp2xp(div(fxplg2(x), 2));
		}
	}

	fixed Rsq(fixed x) {
		result = x.value < 0 ? asFixed(fxp_nan) : fxp2xp(div(fxplg2(x), -2));
	}

	fixed Pow(fixed x, fixed y) {
		if (x.value <= 0) {
			//~ Domain error in fxppow
			result = asFixed(x.value ? fxp_nan : fxp_max);
		}
		else if ((y.value & fxpmask) == 0) {
			fixed sqr = x;
			int32 pow = (y.value < 0 ? -y.value : y.value) >> FractBits;
			fixed res = asFixed(fxp_one);
			for ( ; pow; ) {
				if (pow & 1) {
					res = mul(res, sqr);
				}
				sqr = mul(sqr, sqr);
				pow >>= 1;
			}
			result = y.value < 0 ? inv(res) : res;
		}
		else {
			result = fxp2xp(mul(fxplg2(x), y));
		}
	}

	fixed Sin(fixed x) {
		fixed temp;
		sincos(x, &result, &temp);
	}
	fixed Cos(fixed x) {
		fixed temp;
		sincos(x, &temp, &result);
	}
	fixed Tan(fixed x) {
		fixed sin;
		fixed cos;
		sincos(x, &sin, &cos);
		result = div(sin, cos);
	}
	fixed Asin(fixed x) {
		const static fixed polyasin[] = [			// eps < 0.000106 in [-1, +1]
			toFixed(-0.0187293),
			toFixed(+0.0742610),
			toFixed(-0.2121144),
			toFixed(+1.5707288)
		];

		int32 neg = 0;
		if (x.value < 0) {
			x.value = -x.value;
			neg = 2;
		}
		result = eval4(x, polyasin);
		result = mul(result, Sqrt(asFixed(fxp_one - x.value)));
		result.value -= neg * (result.value - fxp_pi2);
		result.value = fxp_pi2 - result.value;
	}

/* TODO:
long fxpacos(long x) {
	//~ static const fixed polyacos[4] =			// eps < 0.000117 in [-1, +1]
		//~ fixed(-0.0187293),
		//~ fixed(+0.0742610),
		//~ fixed(-0.2121144),
		//~ fixed(+1.5707288);
	long res, neg = 2 * (x < 0);
	x = x < 0 ? -x : x;
	res = fxvevalp(polyacos, x);
	res = fxpmul(res, fxpsqrt(FXP_ONE - x));
	res += neg * (FXP_PI2 - res);
	return res;
}

long fxpatan(long x) {
	return fxpatan2(x, FXP_ONE);
}

long fxpatan2(long x, long y) {
	//~ static const fixed polyatan[4] =			// eps < 0.000195 in [-9, +9] R
		//~ fixed(-0.0410220),
		//~ fixed(+0.1493840),
		//~ fixed(-0.3224560),
		//~ fixed(+0.9993370);

	long mx, my, tmp, res;
	//~ if (!x || !y) return 0;
	mx = (x < 0 ? -x : x);
	my = (y < 0 ? -y : y);
	tmp = fxpdiv(mx < my ? mx : my, mx > my ? mx : my);
	res = fxvevalp(polyatan, fxpmul(tmp, tmp));
	res = fxpmul(res, tmp);
	res = (mx > my) ? FXP_PI2 - res : res;
	res = (y < 0) ? FXP_MPI - res : res;
	res = (x < 0) ? -res : res;
	return res;
}

long fxpsinh(long x) {
	//~ cosh(x) := (exp(x) - exp(-x)) / 2
	return (fxpexp(x) - fxpexp(-x)) >> 1;
}

long fxpcosh(long x) {
	//~ cosh(x) := (exp(x) + exp(-x)) / 2
	return (fxpexp(x) + fxpexp(-x)) >> 1;
}

long fxptanh(long x) {
	//~ tanh(x) := (exp(2*x) - 1) / (exp(2*x) + 1)
	long ans = fxpexp(x << 1);
	if (ans == FXP_INF) return FXP_ONE;
	return fxpdiv((ans - FXP_ONE), (ans + FXP_ONE));
}

long fxpasinh(long x) {
	//~ asinh(x) := logn(sqrt(sqr(x) + 1) + x)
	return fxplgn(fxpsqrt(fxpmul(x, x) + FXP_ONE) + x);
}

long fxpacosh(long x) {
	//~ acosh(x) := logn(sqrt(sqr(x) - 1) + x)
	return fxplgn(fxpsqrt(fxpmul(x, x) - FXP_ONE) + x);
}

long fxpatanh(long x) {
	//~ atanh(x) := -logn((1 - x) / (1 + x)) / 2
	if ((x < 0 ? -x : x) >= FXP_ONE) return FXP_NAN;
	return -fxplgn(fxpdiv(FXP_ONE - x, FXP_ONE + x)) >> 1;
}
// */
}

define fixed(int32 val) = Fixed.toFixed(val);
define fixed(float64 val) = Fixed.toFixed(val);
define int32(fixed &val) = int(val.value >> Fixed.FractBits);
define float64(fixed &val) = double(val.value / double(1 << Fixed.FractBits));

struct assertInfo {
	string  function;
	float64 expected;
	float64 returned;
	fixed   retfixed;	//%
}

int test(const assertInfo info, double eps) {
	// not a number case
	if (info.expected != info.expected) {
		return info.retfixed.value == Fixed.fxp_nan ? 0 : Debug.debug;
	}

	// infinity case
	if (info.expected != 0 && info.expected == 2 * info.expected) {
		int retFixed = info.retfixed.value;
		if (retFixed == Fixed.fxp_nan) {return 0;}
		//~ if (retFixed == Fixed.fxp_max) {return 0;}
		//~ if (retFixed == Fixed.fxp_min) {return 0;}
		return Debug.debug;
	}

	return Math.abs(info.returned - info.expected) < eps ? 0 : Debug.debug;
}

define assert(const assertInfo &info) = debug("test failed", variant(&info), test(info, 1e-4), Debug.notrace);
define assertEquals(string f, float64 a, fixed b) = assert(assertInfo(f, a, float64(b), b));
//~ define assertEquals(string f, float64 a, fixed b) = void(0);

//~ double fixed_test0 = float64(Fixed.add(fixed(2.225), fixed(3)));


double float_value = Math.pi / 3;
double fixed_value = float64(fixed(float_value));
assertEquals("Cmp", float_value, fixed(float_value));

double float_test1 = Math.Sin(float_value);
double fixed_test1 = float64(Fixed.Sin(fixed(float_value)));
assertEquals("Sin", Math.Sin(float_value), Fixed.Sin(fixed(float_value)));

double float_test2 = Math.Cos(float_value);
double fixed_test2 = float64(Fixed.Cos(fixed(float_value)));
assertEquals("Cos", Math.Cos(float_value), Fixed.Cos(fixed(float_value)));

double float_test3 = tan(float_value);
double fixed_test3 = float64(Fixed.Tan(fixed(float_value)));
assertEquals("Tan", Math.Tan(float_value), Fixed.Tan(fixed(float_value)));

double float_test4 = pow(float_value, .5);
double fixed_test4 = float64(Fixed.Sqrt(fixed(float_value)));
assertEquals("Sqrt", pow(float_value, .5), Fixed.Sqrt(fixed(float_value)));

double float_test5 = pow(2, float_value);
double fixed_test5 = float64(Fixed.fxp2xp(fixed(float_value)));
assertEquals("exp2", pow(2, float_value), Fixed.fxp2xp(fixed(float_value)));
