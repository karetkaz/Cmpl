/* BUG: function reference initialization
float64 Sum(float64 data[]) = Math.Sum;
float64 Mean(float64 data[]) = Math.Mean;

float64 data[3] = [1, 2, 3];

float64 sum = Sum(data);
float64 mean = Mean(data);

assert(sum == 6);
assert(mean == 2);
//~ */

//~ /* TEST: invoke functions ...
int method1(int x) {
	static int i = 0;
	result = i += x;
	trace("log", variant(&result));
}
int method1() {
	return method1(1);
}
int method2() {
	return method1(2);
}

void methodCall(int method()) {
	if (method == null) {
		trace("method is null");
		return;
	}
	int n = method();
	trace("log", variant(&n));
}

//~ just invoke it
method1();
method2();

//~ call passed to another fun
methodCall(null);
//~ methodCall(method1);	// compilation error: more than one `method1` declared.
methodCall(method2);
//~ +/

//~ invoke through a reference
int method() = method2;

//~ method = null;

methodCall(method);
if (method != null) {
	method();
}

// +/

//~ */

//~ /* TEST: Closure like constructs ...

struct Closure { int64 call(Closure &c, int64 n); int64 data; int32 invoked; /+...+/ }
define Closure(int64 call(Closure &c, int64 n), int64 data) = Closure(call, data, 0);

int64 Invoke(Closure &c, int64 n) { return c.call(&c, n); }
//TODO: why is `Closure &&c` cached ?: define Invoke(Closure &&c, int64 n) = c.call(&c, n);
// TODO: operator (Closure c)(int64 n) = c.call(c, n);

int64 countdown(Closure &c, int64 n) {
	result = c.data;
	c.data -= n;
	c.invoked += 1;
}

Closure a = Closure(countdown, 90);
Closure b = Closure(countdown, 9);

// cache lvalue to rvalue
variant vari64(int64 value) {
	// allocate as a static variable.
	static int64 memValue;
	int64 &refValue = memValue;

	// allocate on heap; should be deallocated
	//~ int64 &refValue = new(int64);

	refValue = value;
	return variant(refValue);
}

debug("Invoke", vari64(Invoke(&a, 9)));
debug("Invoke", vari64(Invoke(&a, 2)));
debug("Invoke", vari64(Invoke(&b, 10)));
debug("Invoke", vari64(Invoke(&a, 2)));
debug("Invoke", vari64(Invoke(&a, 2)));
debug("Invoke", vari64(Invoke(&b, 1)));

//~ */
