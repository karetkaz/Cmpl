//~ #open src/core.h
//~ #open src/core.c
//~ #open src/tree.c

//~ #open src/code.c			// virtual mashine
//~ #open src/type.c			// type system
//~ #open src/parser.c			// input, lexer, parser
//~ #open src/printer.c			// pretty print, logger
//~ #open src/main.c

/* redefinition does not work ...
static struct Math {
	enum: float64 {
		pi = 3.14159265358979323846264338327950288419716939937510582097494459;		// A000796
		e = 2.71828182845904523536028747135266249775724709369995957496696763;		// A001113
		ln2 = 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
		log2E = 1. / ln2;
		ln10 = 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
		log10E = 1. / ln10;
		phi = 1.61803398874989484820458683436563811772030917980576286213544862;		// A001622
		sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
		sqrtE = 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
		sqrtPi = 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
		sqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339
		nan = 0/0.;//emit(float64, int64(0xfff8000000000000));
		inf = 1/0.;//emit(float64, int64(0xfff8000000000000));
	}
	define isNan(float64 ^x) = bool(x != x);
	define isNan(float32 ^x) = bool(x != x);
}// */

/*TODO: Array assignment
define Array(int32 typesize, int32 ^n) = emit(struct, ref(memmgr(null, typesize * n)), i32(n));

int b[] = Array(4, 1);
//~ b = Array(4, 10);
int c[] = Array(4, 10);
//~ b = c;
/+
int a[][];
a = Array(8, 10);
for (int i = 0; i < a.length; i += 1) {
	a[i] = Array(int, 10);
}// +/
// */

/* const & static members
struct M {
	static const int A = 9;
	static int B = 9;
	const int a;
	int b;

	static const int A_;		// error: uninitialized constant
	static int B_;
	const int a_ = 0;			// error: can not be initialized
	int b_ = 0;					// error: can not be initialized
}

M m = M(6, 9);
m.A = 69;			// error: constant lvalue in asignment
m.a = 69;			// error: constant lvalue in asignment
m.B = 69;			// warn: access wia instance reference
m.b = 69;

//~ int &ref_m_a = m.a;	// hacked: warn if const/nonconst ref assignment.
//~ ref_m_a = 666;

// */

/*DONE: assignment by reference
int64 a = 32;
a = 33;
void setup() {
	static int64 &b = a;
	print("%d\n", int64(b));
}
setup();
//~ */

/* BUG: return: int returned instead of float
double f(int32 idx) {
	return idx;
}
/// 0 is returned.
double f(int32 idx) {
	result = idx;
}
*/

/* Arrays/slices
struct slice_in_struct {
	int slice[];
}
slice_in_struct slice_in_struct1(int a[]) {return slice_in_struct(a);}

int a[4] = 1, 2, 3, 4;

slice_in_struct it1 = slice_in_struct(a);

//FixMe: 
slice_in_struct it2 = slice_in_struct1(a);

print("\n");

//FixMe: 
int xxx = it1.slice[0];

//~ */

/* optimizing stackalloc
	// spc -24
		spc -16
		spc -8

{
	int a[1<<10];
	{
		int a[1<<10];
		{
			int a[1<<10];
			{
				int a[1<<20];
				{
					int a[1<<10];
					{
						int a[1<<10];
						a[0] = 9;
					}
					a[0] = 9;
				}
				a[0] = 9;
			}
			a[0] = 9;
		}
		a[0] = 9;
	}
}*/

/+Optimize
	// remove dup.x1 sp(0) and spc -4
		ldc.ref 5ee1
		dup.x1 sp(0)
		libc: define print( &val)
		spc -4

//~ +/
