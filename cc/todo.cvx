//~ #open src/core.h
//~ #open src/core.c
//~ #open src/tree.c

//~ #open src/code.c			// virtual mashine
//~ #open src/type.c			// type system
//~ #open src/parser.c			// input, lexer, parser
//~ #open src/printer.c			// pretty print, logger
//~ #open src/main.c

//~ bug: static functions are not accessible from a non static struct it there is only static data.
//~ bug: function with empty body does not generate the return instruction.

/* TODO: Array assignment
define Array(int32 typesize, int32 ^n) = emit(struct, ref(memmgr(null, typesize * n)), i32(n));

int b[] = Array(4, 10);
//~ b = Array(4, 10);
//~ int c[] = Array(4, 10);
//~ b = c;
/+
int a[][];
a = Array(8, 10);
for (int i = 0; i < a.length; i += 1) {
	a[i] = Array(int, 10);
}// +/
// */

/* DONE: const & static members
struct M {
	static const int A = 9;
	static int B = 9;
	const int a;
	int b;

	static const int A_;		// error: uninitialized constant
	static int B_;
	const int a_ = 0;			// error: can not be initialized
	int b_ = 0;					// error: can not be initialized
}

M m = M(6, 9);
m.A = 69;			// error: constant lvalue in asignment
m.a = 69;			// error: constant lvalue in asignment
m.B = 69;			// warn: access wia instance reference
m.b = 69;

//~ int &ref_m_a = m.a;	// hacked: warn if const/nonconst ref assignment.
//~ ref_m_a = 666;

// */

/* BUG: Arrays/slices inside structs
struct slice_in_struct {
	int slice[];
}
slice_in_struct slice_in_struct_fn(int a[]) {return slice_in_struct(a);}

int a[4] = {1, 2, 3, 4};

slice_in_struct it1 = slice_in_struct(a);

//~ DONE:
slice_in_struct it2 = slice_in_struct_fn(a);

//~ print("\n");

//FixMe: 
int xxx = it1.slice[0];

//~ */

/+ optimize stack deallocations
{
	int a[1<<10];
	{
		int a[1<<10];
		{
			int a[1<<10];
			{
				int a[1<<20];
				{
					int a[1<<10];
					{
						int a[1<<10];
						a[0] = 9;
					}
					a[0] = 9;
				}
				//~ a[0] = 9;
			}
			a[0] = 9;
		}
		a[0] = 9;
	}
}// +/

/+ Optimize
{
	string a = "a";
	print(a);
}
//! `dup.x1 sp(0)` and `spc -4` can be removed
// todo.cvx:100: [008ea4-008ea9]: string a = 'a'
//| 	1f 96 61 00 00             load.ref 6196
// todo.cvx:101: [008ea9-008eaf]: print(a);
//| 	12 00                      dup.x1 sp(0)
//| 	09 1c 00 00                libc(28): print(string val): void
//| 	10 fc ff ff                spc -4

//~ +/

/* ?Templates?
static(typename Value) {
	Value& select(Value arr[], int pos) {
		assert(unsigned(pos) > arr.lenght);
		return pointer(arr) + pos * Value.size;
	}

	bool insert(Value arr[], int pos, Value value) {
		return false;
	}

	bool update(Value arr[], int pos, Value value) {
		if (unsigned(pos) > arr.lenght)
			return false;
		select(arr, pos) = value;
		return true;
	}

	bool delete(Value arr[], int pos) {
		return false;
	}

	operator (Value arr[]) insert(Value value) = insert(arr, -1, value);
	operator (Value arr[]) insert(int pos, Value value) = insert(arr, pos, value);
	operator (Value arr[]) update(int pos, Value value) = update(arr, pos, value);
	operator (Value arr[]) delete(int pos) = delete(arr, pos);

	operator (Value arr[]) [int pos] = select(arr, pos);
}
static(typename Key, typename Value) {

	struct &Map {
		struct Iterator {
			Map &map;
			int pos;
		}
		struct Item {
			int hash;		// hash code or previos slot
			int next;		// next slot
			Key key;
			Value value;
		}
		int hash;		// hash size, treemap if <= 0
		int used;		// number of used items
		Item data[];
	}

	define iterator(Map map) = Map.Iterator(map, 0);
	bool next(Map.Iterator it) {
		pos += 1;
		// skip not used data.
		while (it.map.data[pos].hash == 0) {
			pos += 1;
		}
		return pos > it.map.used;
	}

	bool insert(Map map, Key key, Value value) {

		if (map.data.length <= map.used) {
			Item data = map.data;
			map.data = new Item[2 * data.length];
			for (int i = 0; i < data.length; i += 1) {
				map.data[i] = data[i];
			}
		}

		if (map.hash > 0) {
			int hash = hash(key) % map.hash;
			int pos = hash;

			Item &item = null;
			for (; pos > 0; ) {

				item = map.data[pos];
				pos = item.next;

				if (key == item.key) {
					// can not insert key more than once
					return false;
				}
			}

			if (pos != hash) {
				// wee have to insert a new item
				item.next = map.used;
				item = data[map.used];
				map.used += 1;
			}

			item.hash = hash;
			item.next = -1;
			item.key = key;
			item.value = value;
		}
		else {
			heap insert
		}
		return true;
	}
	bool update(Map map, Key key, Value value) {
		Item &item = select(map, key);

		if (item == null)
			return false;

		item.value = value;
		return true;
	}
	bool delete(Map map, Key key) {
		Item &item = select(map, key);

		if (item == null)
			return false;

		if (map.hash > 0) {
			while (item.next > 0) {
				Item next = map[item.next];
				item.next = next.next;

				item.key = next.key;
				item.value = next.value;

				item = next;
			}
		}
		else {
			// heap delete
			return false;
		}
		return true;
	}
	Item &select(Map map, Key key) {
		if (map.hash > 0) {
			int hash = hash(key) % map.hash;
			int pos = hash;

			Item &item = null;
			for (; pos > 0; ) {

				item = map.data[pos];
				pos = item.next;

				if (key == item.key) {
					return item;
				}
			}
		}
		else {
			heap search
		}
		return null;
	}
	define value(Map.Item item) = item != null ? item.value : null;

	//~ operator (Value map[Key]).insert(Key key, Value value) = insert(map, key, value);
	//~ operator (Value map[Key]).update(Key key, Value value) = update(map, key, value);
	//~ operator (Value map[Key]).delete(Key key) = delete(map, key);

	operator (Value map[Key])[Key key] = value(select(map, key));

	operator (Value map[Key])[Key key].set(Value value) {
		if (value == null) {
			return delete(map, key);
		}
		if (!update(map, key, value)) {
			return insert(map, key, value);
		}
		return true;
}
//~ */

/+ add to System
enum Arch {
	arm
	?armf
	i386
	x86_64 | amd64
}

enum Os: string {
	Windows("Windows");
	Linux("Linux");
	Mac("Mac");
}

Arch arch = Arch.?
char name[] = "Windows"|"Linux"|"Mac"|"Unknown"

boolean bigEndian = false;

//~ +/

/+ initialization (type and variable)

struct Person {
	LastName: string,
	FirstName: string,
	birthYear: int(1970);
	Jobs: string[] = null,
	next: Person& = null,
	Address: struct {
		type: enum {
			Home, Work, Other
		}
		PostOfficeBox: String;
		StreetAddress: String;
		ZipCode: String;
		City: String;
		State: String;
		Country: String;
	};
	Address2: struct& {
		type: enum {
			Home, Work, Other
		}
		PostOfficeBox: String;
		StreetAddress: String;
		ZipCode: String;
		City: String;
		State: String;
		Country: String;
	} = null;
	Phone: struct[] {
		type: enum {
			Mobile, Home, Work, Fax, Other
		} = Other;
		value: String;
	} = null,
	Mail: struct[] {
		type: enum {
			Home, Work, Other
		} = Other;
		value: String = "";
	} = null,
	Dates: struct[] {
		type: enum {
			Other, BirthDay, Aniversary
		}
		value: String;
	} = [],
	Gender: enum {
		Male, Female, NotDefined
	} = NotDefined;
};

Person person = {
	LastName: "Last";
	FirstName: "First";
	Address: {
		type: Home;
		value: "12345678";
	};
	Phone: [{
		type: Home;
		value: "12345678";
	}, {
		type: Home;
		value: "23456789";
	}];
	Gender: Male;
};

//~ /+
struct Rect {
	int top;
	int right;
	int bottom;
	int left;
}

struct Anchor {
	enum Style {
		Fill;
		FillTop;
		FillRight;
		FillBottom;
		FillLeft;

		Center;
		CenterTop;
		CenterRight;
		CenterBottom;
		CenterLeft;
	};
	int &top;
	int &bottom;
	bool centerHorizontal;	// center / fill

	int &left;
	int &right;
	bool centerVertical;	// center / fill

	Rect margin;

	static Anchor dock(Anchor.Style dock, Rect r, int &pin) {
		result.top = r.top;
		result.bottom = r.bottom;
		result.centerHorizontal = true;

		result.left = r.left;
		result.right = r.right;
		result.centerVertical = true;

		switch (dock) {

			case Fill:
				result.centerHorizontal = false;
				result.centerVertical = false;
			case Center:
				break;

			case FillTop:
				result.centerHorizontal = false;
			case CenterTop:
				result.bottom = pin;
				break;

			case FillRight:
				result.centerVertical = false;
			case CenterRight:
				result.left = pin;
				break;

			case FillBottom:
				result.centerHorizontal = false;
			case CenterBottom:
				result.top = pin;
				break;

			case FillLeft:
				result.centerVertical = false;
			case CenterLeft:
				result.right = pin;
				break;
		}
	}
}

struct Font {...}

struct Component {
	Rect position;	// calc by the layout

	Anchor anchor;
	int width = 20;
	int height = 20;
	
	bool enabled;
	bool focusable;
	Component children[];
}

//~ struct Page: Component {...}
//~ struct List: Component {...}
//~ struct Grid: Component {...}
struct Label: Component {...}
struct Image: Component {...}
struct Check: Component {...}
struct Input: Component {...}	// single line, multi line, html
struct Select: Component {...}	// ComboBox
struct Slider: Component {...}

struct Window: Component {...}
struct Button: Component {
	struct Style {
		Rect margin = {
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
		};
		Rect padding = {
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
		};
		int width = 100;
		int height = 25;
	}

	bool checked = false;
	bool checkable = false;
	//~ property alias pressed: mouseArea.pressed
	//~ property alias text: label.text
	//~ property alias platformMouseAnchors: mouseArea.anchors

	Style style = {
		//~ margin:...
		
	};
	Group &group = null;

	width: defaultStyle.width;
	height: defaultStyle.height;

	//~ property alias font: label.font

	Image image = {
		anchor: dock(CenterLeft, parent);
		source: button.iconSource
		visible: source != ""
	}

	Label label = {
		anchor = dock(CenterRight, parent, image.right);

		elide: Text.ElideRight

		font.family: button.platformStyle.fontFamily
		font.weight: button.platformStyle.fontWeight
		font.pixelSize: button.platformStyle.fontPixelSize
		font.capitalization: button.platformStyle.fontCapitalization
		colors: {
			disabled: Style.disabledTextColor;
			enabled: Style.textColor;
			focused: Style.textColor;
			pressed: pressedTextColor;
			checked: checkedTextColor;
		}
		text: ""
		visible: text != ""
	}

	children: const[image, label];
}// +/

//~ +/

//~ int a1 = int(0);
//~ int a2 = int{0};

typename strty = string;
//~ Complex c1 = Complex(10, 20);
//~ Complex c2 = Complex{re: 10, im:20};

