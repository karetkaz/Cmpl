//~ TODO: cgen: optimize casts
	//~ stdlib.cvx:720:exec:[sp(06)] .02f645: 1b ff ff ff ff             load.c32 -1
	//~ stdlib.cvx:720:exec:[sp(07)] .02f64a: 4c                         i32.2i64

//~ BUG: static functions are not accessible from a non static struct it there is only static data.
//~ BUG: function with empty body does not generate the return instruction.

//~ BUG: arrays in structures
//~ BUG: array of references

//~ TODO: static if else part?
//~ TODO: js like initialization.
//~ TODO: inside a static if false threat errors as warnings?
//~ TODO: separate struct and unoin declaration?
//~ TODO: in case of unions create a constructor?

//~ static int a[10] = 9;
//~ int i = 4;
//~ int b = a[i];

long a = -12374;

/+ TODO: Array allocation and assignment
define new(typename type, int32 ^n) = emit(struct, pointer(memmgr(null, n * type.size)), i32(n));

int b[] = new(int, 10);
//~ b = new(int, 10);
//~ int c[] = new(int, 10);
//~ b = c;

/+
int a[][];
a = new(int[], 10);
for (int i = 0; i < a.length; i += 1) {
	a[i] = new(int, 10);
}
// +/

// +/

/+ DONE: const & static members
struct M {
	static const int A = 9;
	static int B = 9;
	const int a;
	int b;

	static const int A_;		// error: uninitialized constant
	static int B_;
	const int a_ = 0;			// error: can not be initialized
	int b_ = 0;					// error: can not be initialized
}

M m = M(6, 9);
m.A = 69;			// error: constant lvalue in asignment
m.a = 69;			// error: constant lvalue in asignment
m.B = 69;			// warn: access wia instance reference
m.b = 69;

//~ int &ref_m_a = m.a;	// TODO: hacked: warn if const/nonconst ref assignment.
//~ ref_m_a = 666;

// +/

/+ BUG: Arrays/slices inside structs
struct slice_in_struct {
	int slice[];
}
slice_in_struct slice_in_struct_fn(int a[]) {return slice_in_struct(a);}

int a[4] = {1, 2, 3, 4};

slice_in_struct it1 = slice_in_struct(a);

//~ DONE:
slice_in_struct it2 = slice_in_struct_fn(a);

//~ print("\n");

//FixMe: 
int xxx = it1.slice[0];

//~ +/

/+ initialization (type and variable)

//~ int a1 = int(0);
//~ int a2 = int{0};

//~ typename strty = string;
//~ typename complex = Complex;
//~ Complex c1 = Complex(10, 20);
//~ Complex c2 = Complex{re: 10, im:20};

struct Person {
	LastName: string,
	FirstName: string,
	BirthYear: int(1970);
	Jobs: string[] = null,
	next: Person& = null,
	Address: struct {
		Type: enum {Home, Work, Other}
		PostOfficeBox: String;
		StreetAddress: String;
		ZipCode: String;
		City: String;
		State: String;
		Country: String;
	};
	Address2: struct& {
		Type: enum {Home, Work, Other}
		PostOfficeBox: String;
		StreetAddress: String;
		ZipCode: String;
		City: String;
		State: String;
		Country: String;
	} = null;
	Phone: struct[] {
		Type: enum {Mobile, Home, Work, Fax, Other} = Other;
		Value: String;
	} = null,
	Mail: struct[] {
		Type: enum {Home, Work, Other} = Other;
		value: String = "";
	} = null,
	Dates: struct[] {
		type: enum {Other, BirthDay, Aniversary}
		value: String;
	} = [],
	Gender: enum {Male, Female, NotDefined} = NotDefined;
};

Person person = {
	LastName: "Last";
	FirstName: "First";
	Address: {
		Type: Home;
		Value: "12345678";
	};
	Phone: [{
		Type: Mobile;
		Value: "12345678";
	}, {
		Type: Home;
		Value: "23456789";
	}];
	Gender: Male;
};
//~ +/

/+ initialization (type and variable): Ui
struct Rect {
	int top;
	int right;
	int bottom;
	int left;
}
struct Anchor {
	enum Style {
		Fill;
		FillTop;
		FillRight;
		FillBottom;
		FillLeft;

		Center;
		CenterTop;
		CenterRight;
		CenterBottom;
		CenterLeft;
	};
	int &top;
	int &bottom;
	bool centerHorizontal;	// center / fill

	int &left;
	int &right;
	bool centerVertical;	// center / fill

	Rect margin;

	static Anchor dock(Anchor.Style dock, Rect r, int &pin) {
		result.top = r.top;
		result.bottom = r.bottom;
		result.centerHorizontal = true;

		result.left = r.left;
		result.right = r.right;
		result.centerVertical = true;

		switch (dock) {

			case Fill:
				result.centerHorizontal = false;
				result.centerVertical = false;
			case Center:
				break;

			case FillTop:
				result.centerHorizontal = false;
			case CenterTop:
				result.bottom = pin;
				break;

			case FillRight:
				result.centerVertical = false;
			case CenterRight:
				result.left = pin;
				break;

			case FillBottom:
				result.centerHorizontal = false;
			case CenterBottom:
				result.top = pin;
				break;

			case FillLeft:
				result.centerVertical = false;
			case CenterLeft:
				result.right = pin;
				break;
		}
	}
}

struct Font {...}

struct Component {
	Rect position;	// calc by the layout
	Anchor anchor;
	int width = 20;
	int height = 20;

	bool enabled;
	bool focusable;
	Component children[];
}

//~ struct Page: Component {...}
//~ struct List: Component {...}
//~ struct Grid: Component {...}
struct Label: Component {...}
struct Image: Component {...}
struct Check: Component {...}
struct Input: Component {...}	// single line, multi line, html
struct Select: Component {...}	// ComboBox
struct Slider: Component {...}

struct Window: Component {...}
struct Button: Component {
	struct Style {
		Rect margin = {
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
		};
		Rect padding = {
			top: 0;
			right: 0;
			bottom: 0;
			left: 0;
		};
		int width = 100;
		int height = 25;
	}

	bool checked = false;
	bool checkable = false;
	//~ property alias pressed: mouseArea.pressed
	//~ property alias text: label.text
	//~ property alias platformMouseAnchors: mouseArea.anchors

	Style style = {
		//~ margin:...
		
	};
	Group &group = null;

	width: defaultStyle.width;
	height: defaultStyle.height;

	//~ property alias font: label.font

	Image image = {
		anchor: dock(CenterLeft, parent);
		source: button.iconSource
		visible: source != ""
	}

	Label label = {
		anchor = dock(CenterRight, parent, image.right);

		elide: Text.ElideRight

		font.family: button.platformStyle.fontFamily
		font.weight: button.platformStyle.fontWeight
		font.pixelSize: button.platformStyle.fontPixelSize
		font.capitalization: button.platformStyle.fontCapitalization
		colors: {
			disabled: Style.disabledTextColor;
			enabled: Style.textColor;
			focused: Style.textColor;
			pressed: pressedTextColor;
			checked: checkedTextColor;
		}
		text: ""
		visible: text != ""
	}

	children: const[image, label];
}
// +/

/+ inlineing ...
define sqr1(float64 ^x) = x*x;
define sqr2(float64 x) = sqr1(x);
double x = 9;
double y1 = sqr1(x*x+x);		// 
double y2 = sqr2(x*x+x);		// should produce the same code as above
//~ +/

/+ BUG: convert char slice to string 
const char str1[] = "alma a fa alatt nyari piros alma";
const char str2[] = {'a', 'l', 'm', 'a', 0};
string str3 = "alma";
//~ TODO: BUG: string str4 = string(str1);

// makeing slices from strings (substring)
//~ char slice1[] = emit(struct, ref(str2), i32(2));
//~ char slice2[] = emit(struct, i32.add, ref(str2), i32(2), i32(2));
//~ +/

/+ DONE: static casting pointers
pointer x = emit(pointer, ref("erZKJVDlaknjsdvkSDNVlk"));
string str = emit(string, ref(x));
//~ println(emit(string, ref(x)));
//~ +/

/+ DONE: fixed size array for defines
void testArr(double x[]) {
	print("%d\n", int64(x.length));
	x[3] = 8;
}

define TestArr(double x[16]) = testArr(x);

double x[16] = {1};
//~ testArr(x);
//~ TestArr(x);
//~ +/

/+ DONE: return does not cast
double f(int32 v) {result = v;}
double g(int32 v) {return v;}
double h(int32 v) {return result = v;}

int v = 12756;
double v1 = v;
assert(v1 == f(v));
assert(v1 == g(v));
assert(v1 == h(v));

//~ +/

/+ BUG: struct containing references.
struct Refs {
	int &i;
	double &d;
	int f();
}

int a = 6;
double b = 6;
int f() { println("ok"); }

static Refs refs = Refs(&a, &b, f);

void refassign() {
	static int a = 62;
	static double b = 62;
	static int f2() { println("ok62"); }

	refs = Refs(&a, &b, f2);
}

refs.f();
refassign();
refs.f();

//~ BUG: if (refs.f != null) { refs.f(); }

//~ +/

/+ BUG: function returning reference or string type.
//~ define sizeof(typename type) = int(type.size);
//~ define new(typename type) = memmgr(null, type.size);

struct ComplexByVal {double re; double im;}
struct &ComplexByRef {double re; double im;}

//~ void print(ComplexByRef val) { print("%F", val.re); print(", "); print("%F", val.im); print("\n"); }

/+ TODO: 
ComplexByRef ComplexByRef(double re, double im) {
	result = new(ComplexByRef);
	result.re = re;
	result.im = im;
	return result;
}// +/

ComplexByVal v1 = ComplexByVal(3,-2);
ComplexByRef v2 = new(ComplexByRef);
ComplexByRef v3 = emit(ComplexByRef, i32(-1));
//~ ComplexByRef v4 = ComplexByRef(2, -3);

//~ v2.re = v1.re;
//~ v3 = v2;
//~ v2 = null;


//~ TODO: return string.
//~ string alma() {result = "alma";}

// +/

/+ TODO: nice to have
//~ arrays of functions
	int alma(int h)[10];

//~ associative arrays: maps
	int stringMap[string];		stringMap[]

//~ recursively define:
	define fact(int64 n) = (n * fact(n - 1));

//~ void alma(int a) {static int A = a;}

/+ TODO: cast operators
 + define-s are implicit
 + operator-s are explicit
 + 
 + struct float3 { float x; float y; float z; }
 + struct float4 { float x; float y; float z; float w; }
 + 
 + and:
 + define float3(float4 x) = float3(x.x, x.y, x.z);
 + operator float4(float3 x) = float4(x.x, x.y, x.z, 0.);
 +
 + then:
 + float4 a = float4(1., 2., 3., 4.);
 + float3 b = float3(a);
 + float4 c = b;				// this will call `operator float4(float3 x)`
 + float3 d = a;				// Error: undefined operator float3(float4 x)
 + 
 + operator -(int32 rhs) = emit(i32.neg, i32(rhs));
 + operator (int32 lhs) + (int32 rhs) = emit(i32.add, i32(rhs), i32(lhs));
 + 
 + geters only.
 + operator (string lhs) [int32 rhs] = emit(int32, load.i8, u32.mad, i32(1), i32(rhs), ref(lhs));
 +
 + or set enabled indexing.
 + operator (string lhs) [int32 rhs] = emit(char&, i32.mad, i32(1), i32(rhs), ref(lhs));
 + 
 + operator int32(string value) = atoi(value, 10);
 + 
++/
/+ TODO: inout params(&&), destructors
	(in case of defines: symbolic parameter)

void free(pointer &&ref) {
  memmgr(ref, 0);
  ref = null;
}

define void(var &&a) = void(typename.Invoke(a.type, ".dtor", a.data));

define void(int8 &&a)    = void(0);
define void(int16 &&a)   = void(0);
define void(int32 &&a)   = void(0);
define void(int64 &&a)   = void(0);
define void(uint8 &&a)   = void(0);
define void(uint16 &&a)  = void(0);
define void(uint32 &&a)  = void(0);
define void(float32 &&a) = void(0);
define void(float64 &&a) = void(0);
//~ +/

/+ Reflect
enum TypeCode: int32 {
	CAST_any = 0x00000000;		// invalid, error, ...
	CAST_vid = 0x00000001;		// void;
	CAST_bit = 0x00000002;		// bool;
	CAST_i32 = 0x00000003;		// int8, int16, int32
	CAST_u32 = 0x00000004;		// uint8, uint16, uint32
	CAST_i64 = 0x00000005;		// int64
	CAST_u64 = 0x00000006;		// uint64
	CAST_f32 = 0x00000007;		// float32
	CAST_f64 = 0x00000008;		// float64
	CAST_ptr = 0x00000009;		// pointer

	CAST_arr = 0x0000000a;		// slice(size, data)
	CAST_var = 0x0000000b;		// variant(type, data)
	CAST____ = 0x0000000d;		// typename
	CAST____ = 0x0000000e;		// variable
	CAST____ = 0x0000000f;		// function

	TYPE_def = 0x00000000;		// alias (or error)
	TYPE_rec = 0x00000010;		// typename
	TYPE_ref = 0x00000020;		// variable
	TYPE_fun = 0x00000030;		// function (variable and typename too)

	ATTR_sta = 0x00000040;		// static
	ATTR_con = 0x00000080;		// constant

	ATTR_par = 0x00000100;		// parrallel
	ATTR_snc = 0x00000200;		// synchronized
	ATTR_ref = 0x00000400;		// indirect
	ATTR_prv = 0x00000800;		// private
}

struct TypeInfo {
	pointer file;		// declared in file (cstr)
	int32 line;			// declared on line

	pointer name;		// typename (cstr)
	int32 offs;			// offset
	int32 size;			// size

	TypeInfo &base;		// function return type, typename base, variable type
	TypeInfo &args;		// function arguments, typename fields, ?
	TypeInfo &next;		// next type, argument, field

	int8  kind;			// ref(var / fun), type,
	int8  cast;			// casts to ...
	int16 attr;			// attributes

	//~ get typename = bool((this.kind & 0xf) != TYPE_ref);
	//~ get constant = bool(this.kind & ATTR_con);
	//~ get indirect = bool(this.kind & ATTR_ind);
	//~ get function = bool(this.kind & ATTR_fun);
}

//~ class typename: TypeInfo;
//~ class variable: TypeInfo;

bool instanceof(TypeInfo &ty, var obj) {
	TypeInfo &oty = obj.type;
	while (ty && ty != oty) {
		ty = ty.base;
	}
	return ty;
}

define lookUp(TypeInfo &type, int level, string name) = lookUp(type, level, name, null);

TypeInfo& lookUp(TypeInfo &type, int level, string name, variant args...) {

	bool func = args != null;

	while (type && level > 0 && type.code != TYPE_ref) {

		for (TypeInfo arg : type.args) {

			// skip defines, consts, ...
			if (arg.code != TYPE_ref)
				continue;

			// lookup only variables or functions
			if (arg.call != func)
				continue;

			if (arg.name != name)
				continue;

			if (func) {
				int i = 0;
				for (TypeInfo &param : arg.args) {

					if (i >= args.Length)
						break;

					if (param.load) ...		// by ref
					if (param.call) ...		// argument is a funtion: (byref must be set)

					if (!canAssign(param, args[i]))
						break;

					if (param.type != args[i].type)		// check return types
						break;

					if (!param.Vararg)
						i += 1;
				}

				if (i != args.Length)
					continue;
			}
			return arg;
		}

		// base class has this member ?
		type = type.base;
		level -= 1;
	}
	return null;
}

struct cls {
	static int32 c;
	int32 a;
	int32 b;
	static int M1(int a, int b) {return a + b;}
}


var a1 = var(34);
var a2 = var(4);
var t1;
cls obj;

assert(invoke(cls, "c", t1) && t1 == var(cls.c));				// t1 := cls.c;
assert(invoke(cls, "c", null, a1) && t1 == var(cls.c));			// cls.c := a1;
assert(invoke(cls, "c", t1, a1) && t1 == var(cls.c));			// t1 := cls.c = a1;

assert(invoke(cls, "M1", t1, a1, a2) && t1 == var(cls.M1(a1, a2));
assert(invoke(obj, "M1", t1, a1, a2) && t1 == var(obj.M1(a1, a2));

assert(invoke(obj, "a", t1) && t1 == var(obj.a));
assert(invoke(obj, "a", null, a2) && a2 == var(obj.a));			// t1 := obj.a := a2;

bool invoke(var obj, string name, var &&res, var args...) {
	TypeInfo class = obj.type == TypeInfo ? &obj.data : obj.type;
	TypeInfo Method = lookUp(type, -1, name, args);

	if (Method != null && Method.offset > 0) {
		uint8 stop[4096];			// this is on top of stack
		pointer st = pointer(stop);

		memset(st, Method.type.size);	// clear result

		for (int i = 0; i < Method.args.length; i += 1) {
			TypeInfo marg = Method.args[i];

			if (marg.offset > stop.length)
				return false;

			memcpy(st + marg.offset, args[i].data, marg.size);
		}

		emit(call, u32(Method.offset));

		res.type = Method.type;
		res.data = malloc(Method.type.size);
		memcpy(res.data, st, Method.type.size);
		//~ or short: res = variant(Method.type, st);

		return true;
	}
	return false;
}

invoke(t2, "a", t1, var(34));			// t1 = t2.a = 34;
invoke(t2, "a", t1, t2);				// t1 = t2.a;

bool invoke(variant obj, string name, var &&res, var args...) {
	return invoke(obj.type, name, &&res, obj, args);
}

//~ +/
//~ +/
