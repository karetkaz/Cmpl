//~ src/main.c
// test some features
// TODO: split this file

enum Test {
	Emit = ~0x0;
	Type = ~0x0;
//	Lang = ~0x0;
	Call = ~0x0;
	Bits = ~0x0;
	Math = ~0x0;
//	Misc = ~0x0;
}

static if (true) {
struct hex8: int8{};		//%%02x
struct hex16: int16{};		//%%04x
struct hex32: int32{};		//%%08x
struct hex64: int64{};		//%%016X
struct bin32: int32{};		//%%032b

//~ define print(hex32 arg) = print("%08x", int64(arg));
//~ define println(hex32 arg) = print("%08x\n", int64(arg));
//~ define print(hex64 arg) = print("%08X", int64(arg));
//~ define println(hex64 arg) = print("%016X\n", int64(arg));
}

// random seed
System.srand(System.time());

static if (Test.Emit) {
/+ emit is something like watcoms inline assembly:
 +	#pragma aux (parm [edi] [eax] [edx] value [edi] modify exact [xmm0]) __mul_packed_4float =\
 +		"movps	xmm0, [eax]"\
 +		"mulps	xmm0, [edx]"\
 +		"movups	[edi], xmm0"
++/
static if (Test.Emit & 0x01) {		// some basic emit examples
float32 res1 = emit(float32, f32.div, f32(2), f32(Math.pi));
float64 res2 = emit(f64.neg, f64(Math.pi));
float32 res3 = emit(i32, f32(Math.pi));
hex32 res4 = emit(i32, f32(Math.pi));
}
static if (Test.Emit & 0x02) {		// more basic emit examples
define shl(int32 value, int count) = emit(i32.shl, i32(count), i32(value));
define shr(int32 value, int count) = emit(i32.shr, i32(count), i32(value));
define shr(uint32 value, int count) = emit(u32.shr, i32(count), i32(value));

define add(float32 a, float32 b) = emit(f32.add, f32(b), f32(a));
define sub(float32 a, float32 b) = emit(f32.sub, f32(b), f32(a));
define mul(float32 a, float32 b) = emit(f32.mul, f32(b), f32(a));
define div(float32 a, float32 b) = emit(f32.div, f32(b), f32(a));
define mod(float32 a, float32 b) = emit(f32.mod, f32(b), f32(a));

define mad(float32 a, float32 b, float32 c) = emit(f32.add, f32.mul, f32(a), f32(b), f32(c));	// a * b + c
define mad(float64 a, float64 b, float64 c) = emit(f64.add, f64.mul, f64(a), f64(b), f64(c));	// a * b + c
//~ define mad(int32 size, int32 index, int32 offset) = emit(u32.mad, i32(size), i32(index), i32(offset));

hex32 a = -0x8989;
hex32 a1 = shr(uint32(a), 8);
hex32 a2 = shr(int32(a), 8);

float32 X1 = mad(2, 3, 4000);
float32 X2 = mad(float32(2), float32(3), float32(4000));
float32 X3 = mad(2., 3., 4000.);

}
static if (Test.Emit & 0x04) {		// Complex multiplication

define times2exec = -10000000;

Complex Ca = Complex(3., 4.);
Complex Cb = Complex(2., 5.);
Complex Cr = mul(Ca, Cb);

static if (times2exec > 0) {

define mul_sisd(Complex &a, Complex &b) = Complex(a.re * b.re - a.im * b.im, a.re * b.im + a.im * b.re);

define mul_simd(Complex &a, Complex &b) = emit(Complex,
	f64.sub, v2d.mul, f64(b.im), f64(b.re), f64(a.im), f64(a.re),	// re = a.re * b.re - a.im * b.im
	f64.add, v2d.mul, Complex(b), f64(a.im), f64(a.re)	// im = a.re * b.im + a.im * b.re;
);

//~ TODO: compare equality with memcmp(a,b) != 0
//~ assert(Cr == mul_simd(Ca, Cb));
//~ assert(Cr == mul_sisd(Ca, Cb));

int clock_simd = System.clock();
for (int i = 0; i < times2exec; i += 1) {
	Complex c = mul_simd(Ca, Cb);
}
clock_simd = System.clock() - clock_simd;

int clock_sisd = System.clock();
for (int i = 0; i < times2exec; i += 1) {
	Complex c = mul_sisd(Ca, Cb);
}
clock_sisd = System.clock() - clock_sisd;

define clocks2Sec(int ticks) = double(ticks) / CLOCKS_PER_SEC;
double seconds_simd = clocks2Sec(clock_simd);
double seconds_sisd = clocks2Sec(clock_sisd);
}
}
static if (Test.Emit & 0x08) {		// Vector4 swizzle

vec4f v1 = vec4f(11., 12., 13., 14.);
vec4f v2 = vec4f(21., 22., 23., 24.);
debug(variant(&v2));
vec4f v3 = emit(vec4f, swz.xywz, vec4f(v1));
}
}
static if (Test.Type) {
static if (Test.Type & 0x01) {		// lookup test

define int1 = int(1990);
define int1() = int(1995);
define int1(int32 _) = int(2010);
define int1(float64 _) = int(2015);

int32 _int1 = int1;			// 1990
int32 _int2 = int1();		// 1995
int32 _int3 = int1(0);		// 2010
int32 _int4 = int1(0.);		// 2015

assert(int1 == 1990);
assert(int1() == 1995);
assert(int1(0) == 2010);
assert(int1(0.) == 2015);

int &badRef = emit(pointer, int(-1));

}
static if (Test.Type & 0x02) {		// not a number test

float64 NAN = Math.nan;
bool isNan1 = Math.isNan(NAN);
int isNan2 = int(Math.isNan(Math.nan));
}
static if (Test.Type & 0x04) {		// union & packing: int and float
//~ struct and arrays
struct fltint32:0 {int32 i;float32 f;}
struct fltint64:0 {int64 i;float64 f;}

fltint64 fltint_i_20; //TODO: = {i: 20;};
fltint_i_20.i = 20;

fltint64 fltint_f_20; //TODO: = {f: 20;};
fltint_f_20.f = 20;
}
static if (Test.Type & 0x08) {		// union & packing: color
struct bgra:1 {
	uint8 b; 	//%blue(%d)
	uint8 g; 	//%green(%d)
	uint8 r; 	//%red(%d)
	uint8 a; 	//%alpha(%d)
}
struct color:0 {
	int32 val;	//%#%08x
	bgra col;	//%
}

define color(int32 c) = emit(color, i32(c));
define color(int32 a, int32 r, int32 g, int32 b) = color(int32(((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | ((b & 0xff) << 0)));
define color(float64 a, float64 r, float64 g, float64 b) = color(int32(a*255), int32(r*255), int32(g*255), int32(b*255));

define color(int32 r, int32 g, int32 b) = color(int32(255), r, g, b);
define color(float64 r, float64 g, float64 b) = color(float64(1), r, g, b);

color C1 = color(0xcafebabd);
color C2 = color(0xca, 0xfe, 0xba, 0xbc);
color C3 = emit(color, i32(0xcafebabe));
color C4 = color(0.1, .5, .7);
color C5 = color(1, 5, 205);

enum colors: color {
	c5 = color(0.1, .5, 1.);
	transparent = color(-1);
}
color c5 = colors.c5;

}
static if (Test.Type & 0x10) {		// arrays

int maximum(int arr[]) {
	result = arr[0];
	for (int i = 1; i < arr.length; i += 1) {
		if (result < arr[i]) {
			result = arr[i];
		}
	}
}

void sort(int arr[]) {
	for (int i = 0; i < arr.length - 1; i += 1) {
		for (int j = i + 1; j < arr.length; j += 1) {
			if (arr[i] > arr[j]) {
				int tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
			}
		}
	}
}

void qsort(int array[]) {
	static void qsort(int array[], int low, int high) {
		int i := low;
		int j := high;
		int pivot := array[low + (high-low) / 2];
		static if (0) {
			struct Qsort {
				int array[];
				int low;
				int high;
				int pivot;
			}
			Qsort args = Qsort(array, low, high, pivot);
			debug(variant(&args));
			//~ trace("pivot", variant(&pivot));
		}

		for ( ; i <= j; ) {
			for ( ; array[i] < pivot; i += 1) {}
			for ( ; array[j] > pivot; j -= 1) {}

			if (i <= j) {
				int temp := array[i];
				array[i] := array[j];
				array[j] := temp;
				i += 1;
				j -= 1;
			}
		}
		if (low < j) {
			qsort(array, low, j);
		}
		if (i < high) {
			qsort(array, i, high);
		}
	}
	return qsort(array, 0, array.length - 1);
}

int bsearch(int arr[], int elem) {
	int lo = 0;
	int hi = arr.length;

	result = -1;
	for ( ;lo < hi; ) {
		int mid = lo + ((hi - lo) / 2);
		int val = arr[mid];

		if (val == elem) {
			return mid;
		}
		else if (val > elem) {
			hi = mid;
		}
		else {
			lo = mid + 1;
		}
	}
}

void randomize(int arr[], int max) {
	for (int i = 0; i < arr.length; i += 1) {
		arr[i] = System.rand() % max;
	}
}

int arr2[15];			// array
int arr3[] = arr2;		// slice

randomize(arr3, 300);

int test_arr_max = maximum(arr2);

int test_arr_toFind = arr2[arr2.length / 2];

debug("unsorted", variant(arr2));
qsort(arr2);
debug("sorted", variant(arr2));

int test_arr_index = bsearch(arr2, test_arr_toFind);

}
static if (Test.Type & 0x20) {		// enum

//~ ...

}
}
static if (Test.Call) {
static if (Test.Call & 0x01) {		// nested functions
int bar(int a) {
	static int foo(int b) {
		static int abc() { return 1; }
		return b + abc();
	}
	return foo(a);
}
int i = bar(3);
assert(i == 4);
}
static if (Test.Call & 0x02) {		// ???

int getArrayElement(uint32 index, int array[]) {
	if (index < array.length) {
		return array[index];
	}
	return 0;
}

int getArrayElement(uint32 index, int a1, int a2) {
	const int array[] = [a1, a2];
	return getArrayElement(index, array);
}

int getArrayElement(uint32 index, int a1, int a2, int a3) {
	const int array[] = [a1, a2, a3];
	return getArrayElement(index, array);
}

define getArrayElementDef(uint32 index, int a1, int a2, int a3) = getArrayElement(index, a1, a2, a3);
assert(getArrayElementDef(0, 1, 2, 3) == 1);
assert(getArrayElementDef(1, 1, 2, 3) == 2);
assert(getArrayElementDef(2, 1, 2, 3) == 3);
}
}
static if (Test.Bits) {
static if (Test.Bits & 0x01) {		// compute bits

bin32 test_bit1_value = 100;
bin32 test_bit1_bitlo = bitlo(test_bit1_value);
bin32 test_bit1_bithi = bithi(test_bit1_value);
bin32 test_bit1_bswap = bitswp(test_bit1_value);
int32 test_bit1_bitcnt = bitcnt(test_bit1_value);
int32 test_bit1_bitsf = bitsf(test_bit1_value);
int32 test_bit1_bitsr = bitsr(test_bit1_value);
}
static if (Test.Bits & 0x02) {		// compute bits
void bitsget(int bitsize, bool signed, int64 &min, int64 &max) {
	int64 mask = int64.Shr(int64(-1), -bitsize);
	min = int64.Shl(-int64(signed), bitsize - 1);
	max = int64.And(min - 1, mask);
}

int bitsize = 10;   //%%d
hex64 smin;
hex64 smax;
hex64 umin;
hex64 umax;

bitsget(bitsize, true, &smin, &smax);
bitsget(bitsize, false, &umin, &umax);

//~ assert(umin == 0);
//~ assert(umin != min);
//~ assert(umax != max);
}
}
static if (Test.Math) {
static if (Test.Math & 0x01) {		// functions

//~ /* calculate constant e
double math_e = 1.;
{
	double tmp = 1.;
	define eps = 1e-50;
	for (int i = 1; tmp > eps; i += 1) {
		math_e += tmp /= i;
	}
}
// */

//~ /* calculate factorial of a number
define factorial_n = 16;
int64 factorial = 1;
for (int i = 1; i <= factorial_n; i += 1) {
	factorial *= i;
}
// */

//~ /* random floats
float32 frand() {
	uint32 randnum = System.rand() * System.rand();
	float32 tmp = emit(float32, i32((randnum >> 9 ) | 0x3f800000));
	return tmp - 1;
}

float64 drand() {
	uint32 randnum1 = System.rand() * System.rand();
	uint32 randnum2 = System.rand() * System.rand();
	float64 tmp = emit(float64, i32(randnum1), i32((randnum2 >> 12) | 0x3ff00000));
	return tmp - 1;
}

float64 maxrand = -1;
for(int i = 0; i < 30; i += 1) {
	float64 currand = drand();

	if (maxrand < currand) {
		maxrand = currand;
	}

	//~ debug("random value", variant(&currand));
}
debug("random maximum", variant(&maxrand));
// */

}
static if (Test.Math & 0x02) {		// lib functions
	double x = Math.pi / 2;
	double absx = Math.abs(-x);
	double sinx = float64.sin(x);
	double cosx = float64.cos(x);
	double tanx = float64.tan(x);
	double logx = float64.log(x);
	double expx = float64.exp(x);
	double powx = float64.pow(2, 8);
}
static if (Test.Math & 0x04) {		// matrix multiply
// Matrix Multiply

define dim = 7;
struct scalar: float64{};		//%%.1f
scalar m1[dim][dim];
scalar m2[dim][dim];
scalar m3[dim][dim];

//~ /+ Initialize
for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		m1[i][j] = m2[i][j] = (i == j) + 1;
	}
} // +/

//~ /+ Compute: matrix multiply
parallel for (int i = 0; i < dim; i += 1) {
	for (int j = 0; j < dim; j += 1) {
		m3[i][j] = 0;
		for (int k = 0; k < dim; k += 1) {
			m3[i][j] += m1[i][k] * m2[k][j];
		}
	}
} // +/
}
static if (Test.Call & 0x08) {		// 256 bit(8x32bit) integer
struct int32x8 {
	int32 i8;	//%%08x
	int32 i7;	//%%08x
	int32 i6;	//%%08x
	int32 i5;	//%%08x
	int32 i4;	//%%08x
	int32 i3;	//%%08x
	int32 i2;	//%%08x
	int32 i1;	//%%08x
}

define int32x8(int32 i0) = emit(int32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32.shr, i32(31), dupp.x1, i32(i0));
define int32x8(uint32 i0) = emit(int32x8, dupp.x1, dupp.x2, dupp.x2, dupp.x1, i32(0), i32(i0));

//~ define sxt64(int32 a) = int64(int32(a));			// sign extend
define zxt64(int32 a) = int64(uint32(a));			// zero extend

int32x8 cmt(const int32x8 &b) {
	result.i1 = ~b.i1;
	result.i2 = ~b.i2;
	result.i3 = ~b.i3;
	result.i4 = ~b.i4;
	result.i5 = ~b.i5;
	result.i6 = ~b.i6;
	result.i7 = ~b.i7;
	result.i8 = ~b.i8;
}
int32x8 neg(const int32x8 &b) {
	int64 sum;
	int64 ovf = 0;
	int64 carry = 0;

	define opNeg(int b) = int32(sum = ovf - zxt64(b) - carry);
	result.i1 = opNeg(b.i1);
	carry = sum < ovf;
	result.i2 = opNeg(b.i2);
	carry = sum < ovf;
	result.i3 = opNeg(b.i3);
	carry = sum < ovf;
	result.i4 = opNeg(b.i4);
	carry = sum < ovf;
	result.i5 = opNeg(b.i5);
	carry = sum < ovf;
	result.i6 = opNeg(b.i6);
	carry = sum < ovf;
	result.i7 = opNeg(b.i7);
	carry = sum < ovf;
	result.i8 = opNeg(b.i8);
}

int32x8 add(const int32x8 &a, const int32x8 &b, bool &&carryInOut) {
	int64 sum;
	int64 ovf = 0xffffffff;
	int64 carry = carryInOut;

	define opAdd(int a, int b) = int32(sum = zxt64(a) + zxt64(b) + carry);

	result.i1 = opAdd(a.i1, b.i1);
	carry = sum > ovf;
	result.i2 = opAdd(a.i2, b.i2);
	carry = sum > ovf;
	result.i3 = opAdd(a.i3, b.i3);
	carry = sum > ovf;
	result.i4 = opAdd(a.i4, b.i4);
	carry = sum > ovf;
	result.i5 = opAdd(a.i5, b.i5);
	carry = sum > ovf;
	result.i6 = opAdd(a.i6, b.i6);
	carry = sum > ovf;
	result.i7 = opAdd(a.i7, b.i7);
	carry = sum > ovf;
	result.i8 = opAdd(a.i8, b.i8);
	carryInOut = sum > ovf;
}
int32x8 add(const int32x8 &a, const int32x8 &b) {
	result = add(a, b, null);
}
int32x8 add(const int32x8 &a, int32 b) {
	int32x8 bx8 = int32x8(b);
	result = add(a, &bx8, null);
}

int32x8 sub(const int32x8 &a, const int32x8 &b, bool &&carryInOut) {
	int64 sum;
	int64 ovf = 0;
	int64 carry = carryInOut;

	define opSub(int a, int b) = int32(sum = zxt64(a) - zxt64(b) - carry);
	result.i1 = opSub(a.i1, b.i1);
	carry = sum < ovf;
	result.i2 = opSub(a.i2, b.i2);
	carry = sum < ovf;
	result.i3 = opSub(a.i3, b.i3);
	carry = sum < ovf;
	result.i4 = opSub(a.i4, b.i4);
	carry = sum < ovf;
	result.i5 = opSub(a.i5, b.i5);
	carry = sum < ovf;
	result.i6 = opSub(a.i6, b.i6);
	carry = sum < ovf;
	result.i7 = opSub(a.i7, b.i7);
	carry = sum < ovf;
	result.i8 = opSub(a.i8, b.i8);
	carryInOut = sum < ovf;
}
int32x8 sub(const int32x8 &a, const int32x8 &b) {
	bool carry = false;
	result = sub(a, b, &carry);
}
int32x8 sub(const int32x8 &a, int32 b) {
	int32x8 bx8 = int32x8(b);
	result = sub(a, &bx8, null);
}


int32x8 mul(const int32x8 &a, const int32x8 &b, int32x8 &&hi) {
	
}
//~ int32x8 mul(int32x8 &a, int32 b);

//~ i32x8 div(i32x8 &a, i32x8 &b, i32x8 &rem);
//~ i32x8 div(i32x8 &a, i32x8 &b, i32x8 &rem);
//~ i32x8 div(i32x8 &a, int32  b, i32x8 &rem);

//~ i32x8 mod(i32x8 &a, i32x8 &b) {div(a, b, result);}
//~ i32x8 mod(i32x8 &a, int32  b) {div(a, b, result);}

int32x8 i32x8_a = int32x8(-10);
int32x8 i32x8_b = int32x8(1);
//~ BUG: rewrites the next variable.
int32x8 i32x8_c = sub(&i32x8_a, &i32x8_b);

}
}

string multiline = "\
int bar(int a) {
	int foo(int b) {
		int abc() {
			return 1;
		}
		return b + abc();
	}
	return foo(a);
}
int i = bar(3);
assert(i == 4);
";

string escaped = "int bar(int a) {\n\
	int foo(int b) {\n\
		int abc() {\n\
			return 1;\n\
		}\n\
		return b + abc();\n\
	}\n\
	return foo(a);\n\
}\n\
int i = bar(3);\n\
assert(i == 4);\n\
";
