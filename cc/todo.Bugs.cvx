//~ BUG: static functions are not accessible from a non static struct if there is only static data.
//~ BUG: function with empty body does not generate the return instruction.
//~ implemented non static functions should be generated like static functions.

/+~ BUG: it is posible to declare functions with (? different type ?) arguments:
	void setzero(int vec[4]) {...}
	void setzero(int vec[]) {...}
//~ +/
//~ TODO: assign to variants: null, variable
//! TODO: varargs: int min(int first, int rest...) {...}
//! TODO: js like initialization of structs: Complex a = {re: 0, im: 1};

//~ TODO:! inout parameters: `bool next(typename &it, typename &&out)` + iteration over struct members.

//~ TODO:? static if else part
//~ TODO:? threat errors as warnings inside static if false branch
//~ TODO:? separate struct and unoin declaration
//~ TODO:X in case of unions create a constructor (!resolved by js style initialization)

//~ BUG: array of references
//~ BUG: void alma(int a) {static int A = a;}

/+ TODO: Array allocation and assignment
define new(typename type, int32 n) = emit(type, pointer(memmgr(null, n * type.size)), i32(n));

int b[] = new(int, 10);
//~ b = new(int, 10);
//~ int c[] = new(int, 10);
//~ b = c;

/+
int a[][];
a = new(int[], 10);
for (int i = 0; i < a.length; i += 1) {
	a[i] = new(int, 10);
}
// +/

// +/

/+ TODO: any members default initialization.
struct M {
	static const int A = 9;
	//~ static const int _A;		// error: uninitialized constant

	static int B = 9;
	static int _B;

	const int a = 0;			// warn: unimplemented usage
	const int _a;

	int b = 0;					// warn: unimplemented usage
	int _b;

}

M m = M(6, 6, 9, 9);
//~ m.A = 69;			// error: asignment of constant variable
//~ m.a = 69;			// error: asignment of constant variable
m.B = 69;			// warn: access wia instance reference
m._b = 69;

//~ int &ref_m_a = m.a;	// TODO: hacked: warn if const/nonconst ref assignment.
//~ ref_m_a = 666;

// +/

/+ DONE: stack underflow(18): dup.x1 sp(255)
vec4f Screen(vec4f Base, vec4f Blend) {
	result = sub(1, mul(sub(1, Base), sub(1, Blend)));
}
//~ +/

/+ BUG: accessing elements of dynamic size vectors in structures
struct slice_in_struct {
	int slice[];
}
slice_in_struct slice_in_struct_fn(int a[]) {
	return slice_in_struct(a);
}

int a[4] = {1, 2, 3, 4};

slice_in_struct it1 = slice_in_struct(a);

//~ DONE:
slice_in_struct it2 = slice_in_struct_fn(a);

//~ print("\n");

//FixMe: 
int xxx = it1.slice[0];

//~ +/

/+ TODO: inlineing ...
define sqr1(float64 x) = x * x;
define sqr2(float64 x) = sqr1(x);
double x = 9;
double y1 = sqr1(x*x+x);		// 
double y2 = sqr2(x*x+x);		// should produce the same code as above
//~ +/

/+ BUG: convert char slice to string 
const char str1[] = "alma a fa alatt nyari piros alma";
const char str2[] = {'a', 'l', 'm', 'a', 0};
string str3 = "alma";

string str5 = string(str2);		//~ OK
string str4 = string(str1);		//~ BUG

// makeing slices from strings (substring)
//~ char slice1[] = emit(struct, ref(str2), i32(2));
//~ char slice2[] = emit(struct, i32.add, ref(str2), i32(2), i32(2));
//~ +/

/+ DONE: static casting pointers
pointer x = emit(pointer, ref("erZKJVDlaknjsdvkSDNVlk"));
string str = emit(string, ref(x));
//~ println(emit(string, ref(x)));
//~ +/

/+ DONE: fixed size array for defines
void testArr(double x[]) {
	print("%d\n", int64(x.length));
	x[3] = 8;
}

define TestArr(double x[16]) = testArr(x);

double x[16] = {1};
//~ testArr(x);
//~ TestArr(x);
//~ +/

/+ DONE: return does not cast
double f(int32 v) {result = v;}
double g(int32 v) {return v;}
double h(int32 v) {return result = v;}

int v = 12756;
double v1 = v;
assert(v1 == f(v));
assert(v1 == g(v));
assert(v1 == h(v));

//~ +/

/+ BUG: struct containing references.
struct Refs {
	int &i;
	double &d;
	int f();
}

int a = 6;
double b = 6;
int f() { println("ok"); }

static Refs refs = Refs(&a, &b, f);

void refassign() {
	static int a = 62;
	static double b = 62;
	static int f2() { println("ok62"); }

	refs = Refs(&a, &b, f2);
}

refs.f();
refassign();
refs.f();

//~ BUG: if (refs.f != null) { refs.f(); }

//~ +/

/+ BUG: function returning reference or string type.
//~ define sizeof(typename type) = int(type.size);
//~ define new(typename type) = memmgr(null, type.size);

struct ComplexByVal {double re; double im;}
struct &ComplexByRef {double re; double im;}

//~ void print(ComplexByRef val) { print("%F", val.re); print(", "); print("%F", val.im); print("\n"); }

/+ TODO: 
ComplexByRef ComplexByRef(double re, double im) {
	//~ pointer p = memmgr(null, sizeof(ComplexByRef));
	//~ result = ComplexByRef(p);
	result = new(ComplexByRef);
	result.re = re;
	result.im = im;
	return result;
}// +/

ComplexByVal v1 = ComplexByVal(3,-2);
ComplexByRef v2 = new(ComplexByRef);
ComplexByRef v3 = emit(ComplexByRef, i32(-1));
//~ ComplexByRef v4 = ComplexByRef(2, -3);

//~ v2.re = v1.re;
//~ v3 = v2;
//~ v2 = null;


//~ TODO: return string.
//~ string alma() {result = "alma";}

// +/

/* BUG: assignment of local variable to a static one (compiler optimization: allocate global variables on stack [-gd-2].)
int64 a = 32;
a = 33;
void setup() {
	static int64 &b = a;
	print("a: %d\n", a);
	print("b: %d\n", b);
}
setup();
//~ */

/* BUG: realloc / malloc / free
define realloc(pointer ptr, int size) = memmgr(ptr, size);
define malloc(int size) = memmgr(null, size);
define free(pointer ptr) = memmgr(ptr, 0);

void testDeallocation(int test) {
	pointer p1 = malloc(160);
	pointer p2 = malloc(161);
	pointer p3 = malloc(160);

	if (test == 1) {
		p3 = free(p3);
		p2 = free(p2);
		p1 = free(p1);
	}
	else if (test == 2) {
		p1 = free(p1);
		p2 = free(p2);
		p3 = free(p3);
	}
	else if (test == 3) {
		p2 = free(p2);
		p1 = free(p1);
		p3 = free(p3);
	}
	else if (test == 4) {
		p2 = free(p2);
		p3 = free(p3);
		p1 = free(p1);
	}
	memmgr(null, 0);
}

define makeBug = 1;
memmgr(null, makeBug);
testDeallocation(1);
testDeallocation(2);
testDeallocation(3);
testDeallocation(4);
//~ */

/* BUG: realloc test
define realloc(pointer ptr, int size) = memmgr(ptr, size);
define malloc(int size) = memmgr(null, size);
define free(pointer ptr) = memmgr(ptr, 0);

memmgr(null, 0);
pointer p1 = malloc(160);
pointer p2 = malloc(161);
pointer p3 = malloc(160);

pointer p = p2; p2 = null;
memmgr(null, 0);
p = realloc(p, 100);
memmgr(null, 0);
p = free(p);
memmgr(null, 0);

free(p3);
free(p2);
free(p1);
//~ memmgr(null, 0);
//~ */

/* BUG: compilation error ?
static const Biorithm biorithms1[7] = {
	Biorithm(0x7070ff, 23,  0, "Physical"),
	Biorithm(0xff0000, 28,  0, "Emotional"),
	Biorithm(0x00ff00, 33,  0, "Intellectual"),
	Biorithm(0xdadada, 38,  0, "Intuitive"),
	Biorithm(0x6f6f6f, 23, 33, "Mastery"),
	Biorithm(0xfeab00, 23, 28, "Passion"),
	Biorithm(0x9466db, 28, 33, "Wisdom")
};

static const Biorithm biorithms2[] = {
	Biorithm(0x7070ff, 23,  0, "Physical"),
	Biorithm(0xff0000, 28,  0, "Emotional"),
	Biorithm(0x00ff00, 33,  0, "Intellectual"),
	Biorithm(0xdadada, 38,  0, "Intuitive"),
	Biorithm(0x6f6f6f, 23, 33, "Mastery"),
	Biorithm(0xfeab00, 23, 28, "Passion"),
	Biorithm(0x9466db, 28, 33, "Wisdom")
};

//~ void printsize(Biorithm biorithms[]) {print("length: %d\n", biorithms.length);}
//~ printsize(biorithms1);
//~ printsize(biorithms2);
//~ */

/* BUG: should not be able to declare these 2 functions.
void idnMat14x4(float64 mat[]) {
	trace("this");
	float64 diag = 1;
	for (int i = 0; i < mat.length; i += 1) {
		mat[i] = i & 3 ? 0 : diag;
	}
}

void idnMat14x4(float64 mat[16]) {
	trace("this");
	float64 diag = 1;
	for (int i = 0; i < mat.length; i += 1) {
		mat[i] = i & 3 ? 0 : diag;
	}
}

float64 mat1[16];
float64 mat2[] = mat1;

idnMat14x4(mat1);
idnMat14x4(mat2);
//~ idnMat14x4_1(mat1);
//~ idnMat14x4_2(mat1);
//~ idnMat14x4_1(mat2);		// ERROR: this should not compile
//~ idnMat14x4_2(mat2);

// */

/+ TODO: nice to have
//~ arrays of functions
	//~ int alma(int h)[10];

//~ associative arrays: maps
	//~ int stringMap[string];		stringMap[]

//~ recursively define:
	//~ define fact(int64 n) = (n * fact(n - 1));

//~ +/
/+ TODO: nameless struct variable
	struct color: 0 {
		int32 value;
		auto color = struct:1 {
			r: uint8;
			g: uint8;
			b: uint8;
		}
	}
//~ +/

/+ TODO: cast operators
 + define-s are implicit
 + operator-s are explicit
 + 
 + struct float3 { float x; float y; float z; }
 + struct float4 { float x; float y; float z; float w; }
 + 
 + and:
 + define float3(float4 x) = float3(x.x, x.y, x.z);
 + operator float4(float3 x) = float4(x.x, x.y, x.z, 0.);
 +
 + then:
 + float4 a = float4(1., 2., 3., 4.);
 + float3 b = float3(a);
 + float4 c = b;				// this will call `operator float4(float3 x)`
 + float3 d = a;				// Error: undefined operator float3(float4 x)
 + 
 + operator -(int32 rhs) = emit(i32.neg, i32(rhs));
 + operator (int32 lhs) + (int32 rhs) = emit(i32.add, i32(rhs), i32(lhs));
 + 
 + geters only.
 + operator (string lhs) [int32 rhs] = emit(int32, load.i8, u32.mad, i32(1), i32(rhs), ref(lhs));
 +
 + or set enabled indexing.
 + operator (string lhs) [int32 rhs] = emit(char&, i32.mad, i32(1), i32(rhs), ref(lhs));
 + 
 + operator int32(string value) = atoi(value, 10);
 + 
++/
/+ TODO: inout params(&&), destructors
	(in case of defines: symbolic parameter)

void free(pointer &&ref) {
	memmgr(ref, 0);
	ref = null;
}

// invoke in the global namespace, the void function with a as argument
define void(var &&a) = void(assert(typename.invoke(null, null, "void", a)));

define void(int8 &&a)    = void(0);
define void(int16 &&a)   = void(0);
define void(int32 &&a)   = void(0);
define void(int64 &&a)   = void(0);
define void(uint8 &&a)   = void(0);
define void(uint16 &&a)  = void(0);
define void(uint32 &&a)  = void(0);
define void(float32 &&a) = void(0);
define void(float64 &&a) = void(0);
//~ +/

/+ Reflect
enum TypeCode: int32 {
	CAST_any = 0x00000000;		// invalid, error, ...
	CAST_vid = 0x00000001;		// void;
	CAST_bit = 0x00000002;		// bool;
	CAST_i32 = 0x00000003;		// int32, int16, int8
	CAST_u32 = 0x00000004;		// uint32, uint16, uint8
	CAST_i64 = 0x00000005;		// int64
	CAST_u64 = 0x00000006;		// uint64
	CAST_f32 = 0x00000007;		// float32
	CAST_f64 = 0x00000008;		// float64
	CAST_ptr = 0x00000009;		// pointer, reference

	CAST_arr = 0x0000000a;		// slice: struct {size, data}
	CAST_var = 0x0000000b;		// variant: struct {type, data}
	CAST___d = 0x0000000d;		// 
	CAST___e = 0x0000000e;		// 
	CAST___f = 0x0000000f;		// 

	TYPE_def = 0x00000000;		// inline (/ error at runtime)
	TYPE_rec = 0x00000010;		// typename
	TYPE_fun = 0x00000020;		// function
	TYPE_ref = 0x00000030;		// variable: functions and typenames are also variables
	ATTR_sta = 0x00000040;		// static attribute
	ATTR_con = 0x00000080;		// constant attribute

	ATTR_par = 0x00000100;		// ?parrallel
	ATTR_snc = 0x00000200;		// ?synchronized
	ATTR_ref = 0x00000400;		// ?indirect
	ATTR_prv = 0x00000800;		// ?private
}

struct TypeInfo {
	pointer file;		// declared in file (cstr)
	int32 line;			// declared on line
	pointer name;		// typename (cstr)
	int32 offs;			// offset
	int32 size;			// size

	TypeInfo &base;		// function return type, typename base, variable type
	TypeInfo &args;		// function arguments, typename fields, ?
	TypeInfo &next;		// next type, argument, field

	int8  kind;			// ref(var / fun), type,
	int8  cast;			// casts to ...
	int16 attr;			// attributes

	//~ get typename = bool((this.kind & 0xf) != TYPE_ref);
	//~ get constant = bool(this.kind & ATTR_con);
	//~ get indirect = bool(this.kind & ATTR_ind);
	//~ get function = bool(this.kind & ATTR_fun);
}

//~ class typename: TypeInfo;
//~ class variable: TypeInfo;

bool instanceof(TypeInfo &ty, var obj) {
	TypeInfo &oty = obj.type;
	while (ty && ty != oty) {
		ty = ty.base;
	}
	return ty;
}

define lookUp(TypeInfo &type, int level, string name) = lookUp(type, level, name, null);

TypeInfo& lookUp(TypeInfo &type, int level, string name, variant args...) {

	bool func = args != null;

	while (type && level > 0 && type.code != TYPE_ref) {

		for (TypeInfo arg : type.args) {

			// skip defines, consts, ...
			if (arg.code != TYPE_ref)
				continue;

			// lookup only variables or functions
			if (arg.call != func)
				continue;

			if (arg.name != name)
				continue;

			if (func) {
				int i = 0;
				for (TypeInfo &param : arg.args) {

					if (i >= args.Length)
						break;

					if (param.load) ...		// by ref
					if (param.call) ...		// argument is a funtion: (byref must be set)

					if (!canAssign(param, args[i]))
						break;

					if (param.type != args[i].type)		// check return types
						break;

					if (!param.Vararg)
						i += 1;
				}

				if (i != args.Length)
					continue;
			}
			return arg;
		}

		// base class has this member ?
		type = type.base;
		level -= 1;
	}
	return null;
}

bool invoke(var obj, var &&res, string name, var args...) {
	TypeInfo class = obj.type == TypeInfo ? &obj.data : obj.type;
	TypeInfo Method = lookUp(type, -1, name, args);

	if (Method != null && Method.offset > 0) {
		uint8 stop[4096];			// this is on top of stack
		pointer st = pointer(stop);

		memset(st, Method.type.size);	// clear result

		for (int i = 0; i < Method.args.length; i += 1) {
			TypeInfo marg = Method.args[i];

			if (marg.offset > stop.length)
				return false;

			memcpy(st + marg.offset, args[i].data, marg.size);
		}

		emit(call, u32(Method.offset));

		res.type = Method.type;
		res.data = malloc(Method.type.size);
		memcpy(res.data, st, Method.type.size);
		//~ or short: res = variant(Method.type, st);

		return true;
	}
	return false;
}

struct cls {
	static int32 c;
	int32 a;
	int32 b;
	static int M1(int a, int b) {return a + b;}
}

var a1 = var(34);
var a2 = var(4);
var res;
cls obj;

// get and set value of static member
assert(invoke(cls, res, "c") && res == cls.c);							// res := cls.c;
//~ assert(invoke(cls, res, "c", a1) && cls.c == a1 && res == a1);			// res := (cls.c := a1);
// get and set value of object member
assert(invoke(obj, res, "a") && res == obj.a);							// res := cls.a;
//~ assert(invoke(obj, res, "a", a2) && obj.a == a2 && res == a2);			// res := (obj.a := a2);
// invoke function with arguments
assert(invoke(cls, res, "M1", a1, a2) && res == cls.M1(a1, a2));		// res = cls.M1(a1, a2);

//~ +/

/+ BenchMarks
3d-cube
3d-morph
3d-raytrace
access-binary-trees
access-fannkuch
access-nbody
access-nsieve
bitops-3bit-bits-in-byte
bitops-bits-in-byte
bitops-bitwise-and
bitops-nsieve-bits
controlflow-recursive
crypto-aes
crypto-md5
crypto-sha1
date-format-tofte
date-format-xparb
math-cordic
math-partial-sums
math-spectral-norm
regexp-dna
string-base64
string-fasta
string-tagcloud
string-unpack-code
string-validate-input
//~ +/

