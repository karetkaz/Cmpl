// make files iterable :)define iterator(File &file) = (file);// iterating by charsbool next(File &file, char &value) {	int ch = File.Read(file);	result = ch != -1;	if (result) {		value = ch;	}}struct Base64 {	static string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";	static int table[256];	static bool init() {		//~ debug("chars", Debug.debug, Debug.notrace, emit(variant, string(chars), typename(string)));		for (int i = 0; i < table.length; i += 1) {			table[i] = strchr(chars, i);		}	}	static bool init = init();	static void encode(File out, File in, int wrap) {		int bitsEncoded = 0;		int charEncoded = 0;		int charWritten = 0;		for (char chr : in) {			bitsEncoded += 2;			charEncoded <<= 8;			charEncoded |= chr & 0xff;			File.Write(out, chars[(charEncoded >> bitsEncoded) & 0x3f]);			if (wrap && ((charWritten += 1) % wrap == 0)) {				File.Write(out, char('\n'));			}			if (bitsEncoded >= 6) {				bitsEncoded -= 6;				File.Write(out, chars[(charEncoded >> bitsEncoded) & 0x3f]);				if (wrap && ((charWritten += 1) % wrap == 0)) {					File.Write(out, char('\n'));				}			}		}		if (bitsEncoded != 0) {			if (bitsEncoded == 4) {				File.Write(out, chars[(charEncoded >> 2) & 0x3f]);				File.Write(out, char('='));			}			else if (bitsEncoded == 2) {				File.Write(out, chars[(charEncoded >> 4) & 0x3f]);				File.Write(out, char('='));				File.Write(out, char('='));			}			bitsEncoded = 0;		}		//~ assert(bitsEncoded == 0, "unprocessed bits remaining.", emit(variant, ref(bitsEncoded), typename(int)));		debug("unprocessed bits remaining.", bitsEncoded != 0, 25, emit(variant, ref(bitsEncoded), typename(int)));	}	static void decode(File out, File in) {		int bitsDecoded = 0;		int charDecoded = 0;		for (char chr : in) {			bool skipChar = chr == '\n';			if (chr == '\r') {				skipChar = true;			}			else if (chr == '=') {				skipChar = true;				bitsDecoded -= 2;			}			if (!skipChar) {				bitsDecoded += 6;				charDecoded <<= 6;				charDecoded |= table[chr] & 0x3f;				if (bitsDecoded >= 8) {					bitsDecoded -= 8;					File.Write(out, char(charDecoded >> bitsDecoded));				}			}		}		File.Write(out, char('\n'));		assert(bitsDecoded == 0, "unprocessed bits remaining.", emit(variant, ref(bitsDecoded), typename(int)));	}}define testDoEncode = !true;//~ Test Encodestatic if (testDoEncode == true) {define inputFile = "C:/Users/User/Desktop/test.txt";define outputFile = "C:/Users/User/Desktop/test.base64.txt";File fileIn = File.Open(inputFile);File fileOut = File.Create(outputFile);Base64.encode(fileOut, fileIn, 0);File.Close(fileOut);File.Close(fileIn);}//~ Test Decodestatic if (testDoEncode != true) {//~ define inputFile = "C:/Users/User/Desktop/image.jpg.base64";//~ define outputFile = "C:/Users/User/Desktop/image.jpg";define inputFile = "test.base64.in.txt";define outputFile = "test.base64.out.txt";File fileIn = File.Open(inputFile);File fileOut = File.Create(outputFile);Base64.decode(fileOut, fileIn);File.Close(fileOut);File.Close(fileIn);fileIn = File.Open(outputFile);Base64.encode(File.StdOut, fileIn, 80);File.Close(fileIn);}