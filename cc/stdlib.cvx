//~ module std;

//~ /*
// TODO: this should be const math {...} !!!
enum math: float64 {

	define i64_as_f64(int64 x) = emit(float64, int64(x));

	//~ nan = 0. / 0;
	//~ nan = -0. / 0;
	nan = i64_as_f64(0x7FFFFFFFFFFFFFFF);
	snan = i64_as_f64(0xFFF8000000000000);

	//~ inf = 1. / 0;
	inf  = i64_as_f64(0x7FF0000000000000);

	//~ ln2 = 0.693147180559945309417232121458176568075500134360255254120680009;	// A002162
	ln2  = i64_as_f64(0x3FE62E42FEFA39EF);

	//~ log2E = 1. / ln2;
	log2e = i64_as_f64(0x3FF71547652B82FE);

	//~ ln10 = 2.30258509299404568401799145468436420760110148862877297603332790;	// A002392
	//~ log10E = 1. / ln10;

	log2t = i64_as_f64(0x400A934F0979A371);			// lg2(10);
	logt2 = i64_as_f64(0x3FD34413509F79FF);			// lg10(2);


	pi = 3.14159265358979323846264338327950288419716939937510582097494459;	// A000796
	//~ pi   = i64_as_f64(0x400921FB54442D18);

	//~ e = 2.71828182845904523536028747135266249775724709369995957496696763;	// A001113
	e    = i64_as_f64(0x4005BF0A8B145769);

	//~ phi = 1.61803398874989484820458683436563811772030917980576286213544862;	// A001622

	//~ sqrt2	= 1.41421356237309504880168872420969807856967187537694807317667974;	// A002193
	//~ sqrtE	= 1.64872127070012814684865078781416357165377610071014801157507931;	// A019774
	//~ sqrtPi	= 1.77245385090551602729816748334114518279754945612238712821380779;	// A002161
	//~ sqrtPhi	= 1.27201964951406896425242246173749149171560804184009624861664038;	// A139339

	define isNan(float64 a) = emit(not, f64.ceq, dupp.x2, f64(a));// bool(a == a);
	define isNan(float32 a) = emit(not, f32.ceq, dupp.x1, f32(a));// bool(a == a);
	//~ define isNan(float64 a) = bool(a == a);
	//~ define isNan(float32 a) = bool(a == a);
	//~ define isInf(float64 a) = bool(a && a == 2 * a);
}

enum imports: bool {
	vec4f = true;
	vec2d = true;
	print = true;		// print and println
	math2 = true;		// min, max, clamp, lerp, rand
	hexTY = !false;
}

static if (imports.vec4f) {
struct vec4f {
	float32 x;
	float32 y;
	float32 z;
	float32 w;
}
//~ TODO: this should be automatically generated by the compiler.
define vec4f(float32 x, float32 y, float32 z, float32 w) = emit(vec4f, f32(x), f32(y), f32(z), f32(w));

define vec4f(float32 x, float32 y, float32 z) = emit(vec4f, f32(x), f32(y), f32(z), f32(0));
define vec4f(float32 val) = emit(vec4f, dupp.x2, dupp.x1, f32(val));

define vec4f(float64 x, float64 y, float64 z, float64 w) = emit(vec4f, f32(x), f32(y), f32(z), f32(w));
define vec4f(float64 x, float64 y, float64 z) = emit(vec4f, f32(x), f32(y), f32(z), f32(0));
define vec4f(float64 val) = emit(vec4f, dupp.x2, dupp.x1, f32(val));

define neg(vec4f rhs) = emit(vec4f, v4f.neg, val(rhs));
define add(vec4f lhs, vec4f rhs) = emit(vec4f, v4f.add, val(rhs), val(lhs));
define sub(vec4f lhs, vec4f rhs) = emit(vec4f, v4f.sub, val(rhs), val(lhs));
define mul(vec4f lhs, vec4f rhs) = emit(vec4f, v4f.mul, val(rhs), val(lhs));
define div(vec4f lhs, vec4f rhs) = emit(vec4f, v4f.div, val(rhs), val(lhs));

define mad(vec4f a, vec4f b, vec4f c) = emit(vec4f, v4f.add, v4f.mul, val(a), val(b), val(c));	// a * b + c

define dp3(vec4f lhs, vec4f rhs) = emit(v4f.dp3, val(rhs), val(lhs));
define dp4(vec4f lhs, vec4f rhs) = emit(v4f.dp4, val(rhs), val(lhs));
define dph(vec4f lhs, vec4f rhs) = emit(v4f.dph, val(rhs), val(lhs));
define cross(vec4f &a, vec4f &b) = vec4f(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);

define len(vec4f &v) = sqrt(dp3(v, v));
define eval(vec4f &v, float32 &x) = float32((((v.w * x + v.z) * x + v.y) * x) + v.x);
define normalize(vec4f a) = emit(vec4f, v4f.div, dupp.x2, dupp.x1, v4f.dp3, dupp.x4, dupp.x4, val(a));
//~ define normalize(vec4f &a) = div(a, vec4f(dp3(a, a)));

define float32(vec4f &vec) = float32(vec.w);
//~ define bool(vec4f &vec) = bool(vec.x && vec.y && vec.z && vec.w);

//~ operator - (vec4f x) = emit(vec4f, v4f.neg, val(x));
//~ operator (vec4f x) + (vec4f y) = emit(vec4f, v4f.add, val(y), val(x));
//~ operator (vec4f x) - (vec4f y) = emit(vec4f, v4f.sub, val(y), val(x));
//~ operator (vec4f x) * (vec4f y) = emit(vec4f, v4f.mul, val(y), val(x));
//~ operator (vec4f x) / (vec4f y) = emit(vec4f, v4f.div, val(y), val(x));
//~ operator (vec4f x) % (vec4f y) = emit(vec4f, v4f.mod, val(y), val(x));

//~ operators should be implicit ?
//~ operator float32(vec4f vec) = float32(vec.w);
//~ operator bool(vec4f vec) = bool(vec.x && vec.y && vec.z && vec.w);

//~ operator (vec4f v)[int i] = float32(i == 0 ? v.x : i == 1 ? v.y : i == 2 ? v.z : i == 3 ? v.w : math.nan);
//~ operator (vec4f v)[char c] = float32(c == 'x' ? v.x : c == 'y' ? v.y : c == 'z' ? v.z : c == 'w' ? v.w : math.nan);
//~ operator (vec4f v)(float32 x) = eval(v, x);

}
static if (imports.vec2d) {
struct vec2d {
	float64 x;
	float64 y;
}

//~ TODO: this should be automatically generated by the compiler.
define vec2d(float64 x, float64 y) = emit(vec2d, f64(x), f64(y));

define add(vec2d x, vec2d y) = emit(vec2d, v2d.add, val(y), val(x));
define sub(vec2d x, vec2d y) = emit(vec2d, v2d.sub, val(y), val(x));
define mul(vec2d x, vec2d y) = emit(vec2d, v2d.mul, val(y), val(x));
define div(vec2d x, vec2d y) = emit(vec2d, v2d.div, val(y), val(x));

//~ define mod(vec2d x, vec2d y) = emit(vec2d, v2d.rem, val(y), val(x));
define min(vec2d x, vec2d y) = emit(vec2d, v2d.min, val(y), val(x));
define max(vec2d x, vec2d y) = emit(vec2d, v2d.max, val(y), val(x));
define cmp(vec2d x, vec2d y) = emit(v2d.equ, val(y), val(x));

define dot(vec2d &x, vec2d &y) = float64(x.x * y.x + x.y * y.y);
}

static if (imports.print) {

define println() = putchr('\n');

define print(int32 arg)   = puti64(arg);
define print(int64 arg)   = puti64(arg);
define print(float32 arg) = putf64(arg);
define print(float64 arg) = putf64(arg);
define print(string arg)  = putstr(arg);

define println(int32 arg)   = void(putchr('\n'), puti64(arg));
define println(int64 arg)   = void(putchr('\n'), puti64(arg));
define println(float32 arg) = void(putchr('\n'), putf64(arg));
define println(float64 arg) = void(putchr('\n'), putf64(arg));
define println(string arg)  = void(putchr('\n'), putstr(arg));

define print(vec4f &v) = void(putchr(')'), putf64(v.w), void(putstr(", ")), putf64(v.z), void(putstr(", ")), putf64(v.y), void(putstr(", ")), putf64(v.x), void(putstr("vec4f(")));
define print(vec2d &v) = void(putchr(')'), putf64(v.y), void(putstr(", ")), putf64(v.x), void(putstr("vec2d(")));
define println(vec4f &v) = void(putchr('\n'), print(v));
define println(vec2d &v) = void(putchr('\n'), print(v));
}

static if (imports.math2) {
define max(int32 &a, int32 &b) = int32(a > b ? a : b);
define max(int64 &a, int64 &b) = int64(a > b ? a : b);
define max(uint32 &a, uint32 &b) = uint32(a > b ? a : b);
define max(float32 &a, float32 &b) = float32(a > b ? a : b);
define max(float64 &a, float64 &b) = float64(a > b ? a : b);

define min(int32 &a, int32 &b) = int32(a < b ? a : b);
define min(int64 &a, int64 &b) = int64(a < b ? a : b);
define min(uint32 &a, uint32 &b) = uint32(a < b ? a : b);
define min(float32 &a, float32 &b) = float32(a < b ? a : b);
define min(float64 &a, float64 &b) = float64(a < b ? a : b);

define clamp(float x, float _min, float _max) = min(max(x, _min), _max);
define clamp(double x, double _min, double _max) = min(max(x, _min), _max);

define lerp(float t, float &a, float b) = float(a + t * (b - a));
define lerp(double t, double &a, double b) = double(a + t * (b - a));

define smooth(float &x) = float(x * x * (3 - 2 * x));
define smooth(float x, float &a, float b) = smooth(clamp((x - a) / (b - a), float(0), float(1)));

define random(int32 max) = int32(random() % max);
define random(int32 &min, int32 max) = int32(min + random(max - min));

//~ define random(int64 max) = int64((int64(random()) * random()) % max);
//~ define random(int64 &min, int64 max) = int64(min + random(max - min));

define random2FloatValue = 0xffffff;
define random(float64 max) = float64((max * random(random2FloatValue)) / random2FloatValue);
define random(float64 &min, float64 max) = float64(min + random(max - min));
}

static if (imports.hexTY) {
define hex8  int8;		//%hex8(0x%02x)
define hex16 int16;		//%hex16(0x%04x)
define hex32 int32;		//%hex32(0x%08x)
define hex64 int64;		//%hex64(0x%016X)

define print(hex32 arg) = putx64(arg);
define println(hex32 arg) = void(println(), putx64(arg));
define print(hex64 arg) = putx64(arg);
define println(hex64 arg) = void(println(), putx64(arg));
}

/+ pointers

//~ define pointer int32;
define void(pointer p) = void();
define bool(pointer p) = emit(bool, load.b8, ref(p));
define int8(pointer p) = emit(int8, load.b8, ref(p));
define int16(pointer p) = emit(int16, load.b16, ref(p));
define int32(pointer p) = emit(int32, load.b32, ref(p));
define int64(pointer p) = emit(int64, load.b64, ref(p));
define uint8(pointer p) = emit(uint8, load.b8, ref(p));
define uint16(pointer p) = emit(uint16, load.b16, ref(p));
define uint32(pointer p) = emit(uint32, load.b32, ref(p));
define float32(pointer p) = emit(float32, load.b32, ref(p));
define float64(pointer p) = emit(float64, load.b64, ref(p));
// +/
// */
