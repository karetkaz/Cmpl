// tests

/* TODO: caching arguments
float x1 = 9;
static float x2 = 9;
inline inc(float x) = float(x + 1);
inline sqr(float x) = float(x * x);
float inc0 = inc(9.);	// inline: used only once
float inc1 = inc(x1);	// inline: used only once
float inc2 = inc(x2);	// inline: used only once
float sqr0 = sqr(9.);	// cached: used more than once
float sqr1 = sqr(x1);	// inline: local variable
float sqr2 = sqr(x2);	// cached: static variable
//~ */

/* BUG: caching arguments
Complex Ca = Complex(3., 4.);
Complex Cb = Complex(2., 5.);
Complex C1 = mul(Ca, Cb);
Complex C2 = mul(Ca, Complex(2., 5.));
Complex C3 = neg(Complex(2., 5.));

inline Re(Complex &a) = (a.re);
inline Im(Complex &a) = (a.im);
Complex C4 = Complex(Im(Complex(2., 5.)), 0.);
Complex C5 = Complex(3., Im(Complex(2., 5.)));
double d1 = Im(Complex(2., 5.));
double d2 = Re(Complex(2., 5.));
//~ */

//~ /* TODO: function members initialization

int32 f3(int a, int b) {
	/+static int32 f4(int a, int b) {
		return a < b ? a : b;
	}
	return f4(a, b);+/
	return a < b ? a : b;
}
//~ /+
struct Struct {
	//~ int32 &r[1];
	int32 f1(int a, int b) = f3;
	int32 f2(int a, int b) = null;
	int32 f3(int a, int b) {
		return a < b ? a : b;
	}
}

Struct instance;
//~ +/
//~ */

/* TODO: const ref assignment warning
struct m {
	static const int X = 9;
	const int a;
	int b;
	int c;// = 8;
}

m m1 = m(5, 9, 1);
int &ref_m1_a = m1.a;	// hacked: warn if const/nonconst ref assignment.
ref_m1_a = 666;

int x = m1.a;

// */

/* TODO: arrays of references string
string x = "almax a fa alatt";

string ss[3];// = {x,x,x};
ss[0] = x;//"alma1 a fa alatt";
ss[1] = "alma2 a fa alatt";
ss[2] = "alma3 a fa alatt";

string y;
y = ss[1];

//~ int iii[3] = 1, 2, 3;
//~ string sss[3] = x, "alma2 a fa alatt", "alma3 a fa alatt";
//~ string y = sss[0];
//~ sss[0][3] = 'A';

//~ println(y);
//~ print(ss[1]);
// */

/* TODO: array.isNullOrEmpty()
bool isNullOrEmpty(int a[]) {
	if (a == null)
		result = true;
	if (a.length == 0)
		result = true;
}

//TODO: int val_null[] = null;
int val_empty[0];
int val_nonempty[10] = [9];

//TODO: bool res_true1 = isNullOrEmpty(null);
//TODO: bool res_true2 = isNullOrEmpty(val_null);
bool res_true3 = isNullOrEmpty(val_empty);
bool res_false = isNullOrEmpty(val_nonempty);
//TODO: assert(res_true1);
//TODO: assert(res_true2);
assert(res_true3);
assert(!res_false);
//~ */

/* TEST: xrgb
struct xrgb: 1 {
	uint8 b;	//%0x%02x
	uint8 g;	//%0x%02x
	uint8 r;	//%0x%02x
	uint8 x;	//%0x%02x
}
struct xrgbi32: 0 {
	xrgb rgb;
	int32 val;	//%#%08x
}

xrgb a = emit(xrgb, i32(0x801f008f));
xrgb b = emit(xrgb, i32(0x2f3f1f));

//~ int r = a.r + b.r;

xrgbi32 r;
/+ TODO: initializations
xrgbi32 r1 = {val: 0};
xrgbi32 r2 = {
	r: Math.min(a.r + b.r, 255),
	g: Math.min(a.g + b.g, 255),
	b: Math.min(a.b + b.b, 255),
	a: 0,
};
// +/

r.rgb.r = Math.min(int32(a.r + b.r), 255);
r.rgb.g = Math.min(int32(a.g + b.g), 255);
r.rgb.b = Math.min(int32(a.b + b.b), 255);
// */

/+ test: print the content of memory :)
char memory[] = emit(struct, ref(null), i32(65536));
for(int i = 1; i < memory.length; i += 1) {
	if (i % 80 == 0) {
		println();
	}
	print("%c", memory[i]);
}// +/
