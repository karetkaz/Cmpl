// watter demo in 2d & 3d
enum Window {
	draw = RenderMode.drawFill|RenderMode.draw_lit;
	resx = 512;
	resy = 512;
}

enum Options {
	textured = !true;
	do2d = !true;
	do3d = true;
}

// division of mesh and heightmap
define division = 72;

//~ do rain every dorain frame
define dorain = 0;

define pheight = -512;
define density = 16;

int mx = 0;
int my = 0;

gxSurf tmp = gxSurf(division, division);
gxSurf img = gxSurf("media/images/download.jpg");
//~ gxSurf img = gxSurf("media/images/ex1.jpg");
//~ gxSurf img = gxSurf("media/images/nol.bmp");
int imh = height(img);
int imw = width(img);

static if (Options.textured) {
	static if (Options.do3d) {
		mesh.Texture(img);
	}
}

void drawCB() {
	static int page = 0;
	static int hmap[2][division * division] = 0;

	Gui.Repaint();
	static int64 beg = -1;
	int64 now = timeNow();
	//~ /* limit to 20 fps
	if (clocksPerSec(now - beg) <= 1./20) {
		static if (Options.do2d) {
			zoomSurf(offScreen, null, tmp, null, 1);
		}
		return;
	}// */
	beg = now;


	static if (dorain != 0) {
		if (mx == 0 && my == 0) {
			static int count = 0;
			if ((count += 1) > dorain) {
				mx = rand(10, Window.resx - 10);
				my = rand(10, Window.resy - 10);
				count = 0;
			}
		}
	}

	int p = page;
	if (mx > 0 && my > 0) {
		int px = mx * division / Window.resx;
		int py = my * division / Window.resy;
		if (px > 0 && px < division-1 && py > 0 && py < division-1) {
		//~ if (px >= 0 && px < division && py >= 0 && py < division) {
			//~ hmap[p][px + division * py] = hmap[np][px + division * py] = pheight;
			hmap[p][px + division * py] = pheight;
		}
		mx = my = -1;
	}

	// the effect
	int i = division;
	int np = page ^= 1;
	//~ /*
	for (int y = 1; y < division - 1; y += 1) {
		for (int x = 1; x < division; x += 1) {
			//~ int height = ((hmap[p][i-division-1] + hmap[p][i-division] + hmap[p][i-division+1] + hmap[p][i-1] + hmap[p][i+1] + hmap[p][i+division-1] + hmap[p][i+division] + hmap[p][i+division+1]) >> 2) - hmap[np][i];
			int height = ((hmap[p][i-division] + hmap[p][i-1] + hmap[p][i+1] + hmap[p][i+division]) / 3) - hmap[np][i];
			hmap[np][i] = height - (height / density);
			i += 1;
		}
		i += 1;
	}// */

	static if (Options.do3d) {
		static int lerpHeight(double s01, double t01) {
			int fixx = s01 * ((division - 2) << 16);
			int fixy = t01 * ((division - 2) << 16);
			int posx = fixx >> 16;
			int posy = fixy >> 16;
			fixx &= 0xffff;
			fixy &= 0xffff;

			int h00 = hmap[page][int(division * (posy + 0) + posx + 0)];
			int h01 = hmap[page][int(division * (posy + 0) + posx + 1)];
			int h10 = hmap[page][int(division * (posy + 1) + posx + 0)];
			int h11 = hmap[page][int(division * (posy + 1) + posx + 1)];

			h00 += (fixx * (h01 - h00)) >> 16;
			h10 += (fixx * (h11 - h10)) >> 16;

			h00 += (fixy * (h10 - h00)) >> 16;

			result = h00;
		}
		static void hmapfn(double &x, double &y, double &z, double s01, double t01) {
			define H = float64(5);
			x = Math.lerp(1 - s01, -H, H);
			y = Math.lerp(1 - t01, -H, H);

			//~ int posx = Math.lerp(s01, 0., division -1);
			//~ int posy = Math.lerp(t01, 0., division -1);
			//~ z = double(hmap[page][posx + division * posy] * 1) / pheight;

			z = double(lerpHeight(s01, t01)) * 1 / pheight;
		}
		meshGen(division-1, false, division-1, false, hmapfn, .2e-1);

		static vec4f evSurf(double s, double t) {
			double x;
			double y;
			double z;
			hmapfn(x, y, z, s, t);
			z *= 3;
			result.x = z;
			result.y = z;
			result.z = z;
		}
		//~ evalSurf(tmp, null, evSurf);
		//~ zoomSurf(offScreen, null, tmp, null, 0);
	}
	static if (Options.do2d) {
		i = division;
		for (int y = 1; y < division - 1; y += 1) {
			for (int x = 1; x < division - 1; x += 1) {
				static if (Options.textured) {
					int Xoffset = hmap[p][i - 1] - hmap[p][i + 1];
					int Yoffset = hmap[p][i - division] - hmap[p][i + division];

					//~ Xoffset = Xoffset * 32 / pheight;
					//~ Yoffset = Yoffset * 32 / pheight;
					int Shading = Math.clamp(Xoffset, 0, 126);

					int t = getPixel(img, x*imw/division + Xoffset, y*imh/division + Yoffset);
					setPixel(tmp, x, y, rgbClamp(rch(t) + Shading, gch(t) + Shading, bch(t) + Shading));
				}
				static if (!Options.textured) {
					setPixel(tmp, x, y, grayClamp(Math.abs(hmap[p][i])));
				}
				i += 1;
			}
			i += 2;
		}
		zoomSurf(offScreen, null, tmp, null, 1);
	}
}

void mouseHandler(int btn, int x, int y) {
	static int ox;
	static int oy;
	float dx = x - ox;
	float dy = y - oy;
	ox = x;
	oy = y;

	static const define toRadians(double x) = double(x * Math.pi / 180.);
	enum: double {
		moveSpeed = .08;
		//~ rotateSpeed = moveSpeed * Math.pi / 180.;
		rotateSpeed = toRadians(moveSpeed);
		rotateSpeed2 = 10 * rotateSpeed;
	}

	/*if (dblClick(btn, x, y)) {
		dblClick(-1, 0, 0);
		println(camera.Up());
		println(camera.Pos());
		println(camera.Right());
	}*/

	if (btn == 2) {		// move forward / back
		vec4f direction = camera.Forward;
		camera.Move(&direction, dy * moveSpeed);
	}
	if (btn == 4) {		// orbit the camera
		vec4f orbit = vec4f(0., 0., 0., 0.);
		if (dx) {
			vec4f direction = camera.Up;
			camera.Rotate(&direction, &orbit, dx * rotateSpeed2);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera.Rotate(&direction, &orbit, dy * rotateSpeed2);
		}
	}
	if (btn == 4+2) {	// rotate the camera
		// if no orbit is given, orbit will be the camera position.
		//~ static vec4f orbit = camera.Pos();
		if (dx) {
			vec4f direction = camera.Up;
			camera.Rotate(&direction, null, dx * rotateSpeed);
			//~ camera_Rotate(direction, null, dx * rotateSpeed);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera.Rotate(&direction, null, dy * rotateSpeed);
			//~ camera_Rotate(direction, null, dy * rotateSpeed);
		}
	}
	if (btn == 1) {		// set
		mx = x;
		my = y;
		//~ print("mouseHnd(btn = "); print("%08x", btn); print(", x = "); print(x); print(", y = "); print(y); print(")\n");
	}
}

Gui.setDrawCallback(drawCB);
Gui.setMouseHandler(mouseHandler);

camera.LookAt(
	vec4f(0., -12., 4.),	// eye
	vec4f(0., 0., 0.),		// target
	vec4f(0., 1., 0.)		// up
);
//~ Gui.exitLoop();
