// watter demo in 2d & 3d
enum Window {
	draw = RenderMode.drawFill|RenderMode.draw_lit;
	resx = 512;
	resy = 512;
}

enum Options {
	textured = true;
	do2d = !true;
	do3d = true;
}

// division of mesh and heightmap
define division = 64;

//~ do rain every dorain frame
define dorain = 0;

define pheight = -256;
define density = 5;

int mx = 0;
int my = 0;

gxSurf tmp = gxSurf(division, division);
gxSurf img = gxSurf("media/images/download.jpg");
//~ gxSurf img = gxSurf("media/images/nol.bmp");

static if (Options.textured) {
	static if (Options.do3d) {
		mesh.Texture(img);
	}
}

void drawCB() {
	int i;
	static int page = 0;
	static int32 hmap[2][division * division] = 0;
	//~ static int32 hmap[2, division, division] = 0;

	int p = page;

	static if (dorain != 0) {
		if (mx == 0 && my == 0) {
			static int count = 0;
			if ((count += 1) > dorain) {
				mx = rand(10, Window.resx - 10);
				my = rand(10, Window.resy - 10);
				count = 0;
			}
		}
	}

	if (mx > 0 && my > 0) {
		int px = mx * division / Window.resx;
		int py = my * division / Window.resy;
		if (px > 1 && px < division-2 && py > 1 && py < division-2) {
			//~ hmap[p][px][py] = pheight;
			hmap[p][px + division * py] = pheight;
		}
		mx = my = 0;
	}

	static int64 beg = -1;
	int64 now = timeNow();
	if (clocksPerSec(now - beg) > .04)
	{
		beg = now;
		// the effect
		i = division;
		int np = page ^= 1;
		for (int y = 1; y < division - 1; y += 1) {
			for (int x = 1; x < division - 1; x += 1) {
				int height = ((hmap[p][i-division-1] + hmap[p][i-division] + hmap[p][i-division+1] + hmap[p][i-1] + hmap[p][i+1] + hmap[p][i+division-1] + hmap[p][i+division] + hmap[p][i+division+1]) >> 2) - hmap[np][i];
				//~ int height = ((hmap[p][i-division] + hmap[p][i-1] + hmap[p][i+1] + hmap[p][i+division]) >> 1) - hmap[np][i];
				hmap[np][i] = height - (height >> density);
				i += 1;
				//~ int height = ((hmap[p][x-1][y-1] + hmap[p][x][y-1] + hmap[p][x+1][y-1] + hmap[p][x-1][y] + hmap[p][x+1][y] + hmap[p][x-1][y+1] + hmap[p][x][y+1] + hmap[p][x+1][y+1]) >> 2) - hmap[np][x][y];
				//~ hmap[np][x][y] = height - (height >> density);
			}
			i += 2;
		}
	}

	static if (Options.do3d) {
		static int lerpHeight(double s01, double t01) {
			int fixx = s01 * ((division - 2) << 16);
			int fixy = t01 * ((division - 2) << 16);
			int posx = fixx >> 16;
			int posy = fixy >> 16;
			fixx &= 0xffff;
			fixy &= 0xffff;

			int h00 = hmap[page][int(division * (posy + 0) + posx + 0)];
			int h01 = hmap[page][int(division * (posy + 0) + posx + 1)];
			int h10 = hmap[page][int(division * (posy + 1) + posx + 0)];
			int h11 = hmap[page][int(division * (posy + 1) + posx + 1)];

			//~ int h00 = hmap[page][posx + 0][posy + 0];
			//~ int h01 = hmap[page][posx + 0][posy + 1];
			//~ int h10 = hmap[page][posx + 1][posy + 0];
			//~ int h11 = hmap[page][posx + 1][posy + 1];

			h00 += (fixx * (h01 - h00)) >> 16;
			h10 += (fixx * (h11 - h10)) >> 16;
			h00 += (fixy * (h10 - h00)) >> 16;

			result = h00;
		}
		static void hmapfn(double &x, double &y, double &z, double s01, double t01) {
			define H = float64(7);
			x = lerp(1 - s01, -H, H);
			y = lerp(1 - t01, -H, H);

			//~ int posx = lerp(s01, 0, resX - 1);
			//~ int posy = lerp(t01, 0, resY - 1);
			//~ z = double(hmap[page][int(resX * posy + posx)]) / pheight;

			z = double(lerpHeight(s01, t01)) / 255;

		}
		meshGen(division, hmapfn, 1e-2);
	}

	static if (Options.do2d) {
		i = division;
		for (int y = 1; y < division - 1; y += 1) {
			for (int x = 1; x < division - 1; x += 1) {
				static if (Options.textured) {
					int Xoffset = hmap[p][i - 1] - hmap[p][i + 1];
					int Yoffset = hmap[p][i - division] - hmap[p][i + division];

					//~ int Xoffset = hmap[p][x - 1][y] - hmap[p][x + 1][y];
					//~ int Yoffset = hmap[p][x][y - 1] - hmap[p][x][y + 1];

					int Shading = clamp(Xoffset, 0, 126);

					int t = getPixel(img, x + Xoffset, y + Yoffset);

					setPixel(tmp, x, y, rgbClamp(rch(t) + Shading, gch(t) + Shading, bch(t) + Shading));
				}
				static if (!Options.textured) {
					setPixel(tmp, x, y, grayClamp(abs(hmap[p][i])));
					//~ setPixel(tmp, x, y, grayClamp(abs(hmap[p][x][y])));
				}
				i += 1;
			}
			i += 2;
		}
		zoomSurf(offScreen, null, tmp, null, 1);
	}

	Gui.Repaint();
}

void mouseHandler(int btn, int x, int y) {
	static int ox;
	static int oy;
	float dx = x - ox;
	float dy = y - oy;
	ox = x;
	oy = y;

	static const define toRadians(double x) = double(x * Math.pi / 180.);
	enum: double {
		moveSpeed = .08;
		//~ rotateSpeed = moveSpeed * Math.pi / 180.;
		rotateSpeed = toRadians(moveSpeed);
		rotateSpeed2 = 10 * rotateSpeed;
	}

	/*if (dblClick(btn, x, y)) {
		dblClick(-1, 0, 0);
		println(camera.Up());
		println(camera.Pos());
		println(camera.Right());
	}*/

	if (btn == 2) {		// move forward / back
		vec4f direction = camera.Forward;
		camera.Move(&direction, dy * moveSpeed);
	}
	if (btn == 4) {		// orbit the camera
		vec4f orbit = vec4f(0., 0., 0., 0.);
		if (dx) {
			vec4f direction = camera.Up;
			camera.Rotate(&direction, &orbit, dx * rotateSpeed2);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera.Rotate(&direction, &orbit, dy * rotateSpeed2);
		}
	}
	if (btn == 4+2) {	// rotate the camera
		// if no orbit is given, orbit will be the camera position.
		//~ static vec4f orbit = camera.Pos();
		if (dx) {
			vec4f direction = camera.Up;
			camera.Rotate(&direction, null, dx * rotateSpeed);
			//~ camera_Rotate(direction, null, dx * rotateSpeed);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera.Rotate(&direction, null, dy * rotateSpeed);
			//~ camera_Rotate(direction, null, dy * rotateSpeed);
		}
	}
	if (btn == 1) {		// set
		mx = x;
		my = y;
		//~ print("mouseHnd(btn = "); print("%08x", btn); print(", x = "); print(x); print(", y = "); print(y); print(")\n");
	}
}

Gui.setDrawCallback(drawCB);
Gui.setMouseHandler(mouseHandler);

camera.LookAt(
	vec4f(0., -12., 4.),	// eye
	vec4f(0., 0., 0.),		// target
	vec4f(0., 1., 0.)		// up
);
//~ Gui.exitLoop();
