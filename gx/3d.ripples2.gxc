// watter demo in 2d & 3d
enum Window {
	draw = RenderMode.drawFill|RenderMode.draw_lit;
	resx = 512;
	resy = 512;
}

enum Options {
	textured = true;
	do2d = !true;
	do3d = true;
}

// division of mesh and heightmap
define division = 72;

//~ do rain every dorain frame
define dorain = 0;

define pheight = -512;
define density = 16;

int mx = 0;
int my = 0;

gxSurf tmp = gxSurf(division, division);
//~ gxSurf img = gxSurf("media/images/download.jpg");
gxSurf img = gxSurf("media/images/ex1.jpg");
//~ gxSurf img = gxSurf("media/images/nol.bmp");
int imh = height(img);
int imw = width(img);

static if (Options.textured) {
	static if (Options.do3d) {
		mesh.Texture(img);
	}
}

void drawCB() {
	static float32 u[division][division] = 0;
	static float32 v[division][division] = 0;

	Gui.Repaint();
	static int64 beg = -1;
	int64 now = timeNow();
	//~ /* limit speed to 20 fps
	if (clocksPerSec(now - beg) <= 1./25) {
		static if (Options.do2d) {
			zoomSurf(offScreen, null, tmp, null, 1);
		}
		return;
	}// */

	beg = now;
	static if (dorain) {
		if (mx == 0 && my == 0) {
			static int count = 0;
			if ((count += 1) > dorain) {
				mx = rand(10, Window.resx - 10);
				my = rand(10, Window.resy - 10);
				count = 0;
			}
		}
	}

	if (mx > 0 && my > 0) {
		int px = mx * division / Window.resx;
		int py = my * division / Window.resy;
		if (px > 1 && px < division-2 && py > 1 && py < division-2) {
			v[px][py] = pheight;
		}
		mx = my = 0;
	}

	// the effect
	for (int y = 0; y < division; y += 1) {
		for (int x = 0; x < division; x += 1) {
			define cl(int ^c) = (c < 0 ? 0 : c >= division ? division - 1 : c);
			v[x][y] += (u[cl(x - 1)][y] + u[cl(x + 1)][y] + u[x][cl(y - 1)] + u[x][cl(y + 1)]) / 4 - u[x][y];
		}
	}
	for (int y = 0; y < division; y += 1) {
		for (int x = 0; x < division; x += 1) {
			u[x][y] += v[x][y] *= .96;// * 1.9;
		}
	}

	static if (Options.do3d) {
		static int lerpHeight(double s01, double t01) {
			int fixx = s01 * ((division - 2) << 16);
			int fixy = t01 * ((division - 2) << 16);
			int posx = fixx >> 16;
			int posy = fixy >> 16;
			fixx &= 0xffff;
			fixy &= 0xffff;

			int h00 = u[posx + 0][posy + 0];
			int h01 = u[posx + 0][posy + 1];
			int h10 = u[posx + 1][posy + 0];
			int h11 = u[posx + 1][posy + 1];

			h00 += (fixx * (h01 - h00)) >> 16;
			h10 += (fixx * (h11 - h10)) >> 16;
			h00 += (fixy * (h10 - h00)) >> 16;

			result = h00;
		}
		static void hmapfn(double &x, double &y, double &z, double s01, double t01) {
			define H = float64(8);
			x = Math.lerp(1 - s01, -H, H);
			y = Math.lerp(1 - t01, -H, H);

			//~ int posx = Math.lerp(s01, 0., division - 1.);
			//~ int posy = Math.lerp(t01, 0., division - 1.);
			//~ z = double(u[posx][posy]) / -pheight;

			z = double(lerpHeight(s01, t01)) / -pheight;
		}
		meshGen(division, hmapfn, 1.5e-2);
	}
	static if (Options.do2d) {
		for (int y = 1; y < division - 1; y += 1) {
			for (int x = 1; x < division - 1; x += 1) {
				static if (Options.textured) {
					int Xoffset = int(u[x - 1][y] - u[x + 1][y]) / 20;
					int Yoffset = int(u[x][y - 1] - u[x][y + 1]) / 20;
					int Shading = Math.clamp(Xoffset, 0, 126);

					int t = getPixel(img, x*imw/division + Xoffset, y*imh/division + Yoffset);
					setPixel(tmp, x, y, rgbClamp(rch(t) + Shading, gch(t) + Shading, bch(t) + Shading));
				}
				static if (!Options.textured) {
					setPixel(tmp, x, y, grayClamp(Math.abs(u[x][y])));
				}
			}
		}
		zoomSurf(offScreen, null, tmp, null, 1);
	}// */
}

void mouseHandler(int btn, int x, int y) {
	static int ox;
	static int oy;
	float dx = x - ox;
	float dy = y - oy;
	ox = x;
	oy = y;

	static const define toRadians(double x) = double(x * Math.pi / 180.);
	enum: double {
		moveSpeed = .08;
		//~ rotateSpeed = moveSpeed * Math.pi / 180.;
		rotateSpeed = toRadians(moveSpeed);
		rotateSpeed2 = 10 * rotateSpeed;
	}

	/*if (dblClick(btn, x, y)) {
		dblClick(-1, 0, 0);
		println(camera.Up());
		println(camera.Pos());
		println(camera.Right());
	}*/

	if (btn == 2) {		// move forward / back
		vec4f direction = camera.Forward;
		camera.Move(&direction, dy * moveSpeed);
	}
	if (btn == 4) {		// orbit the camera
		vec4f orbit = vec4f(0., 0., 0., 0.);
		if (dx) {
			vec4f direction = camera.Up;
			camera.Rotate(&direction, &orbit, dx * rotateSpeed2);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera.Rotate(&direction, &orbit, dy * rotateSpeed2);
		}
	}
	if (btn == 4+2) {	// rotate the camera
		// if no orbit is given, orbit will be the camera position.
		//~ static vec4f orbit = camera.Pos();
		if (dx) {
			vec4f direction = camera.Up;
			camera.Rotate(&direction, null, dx * rotateSpeed);
			//~ camera_Rotate(direction, null, dx * rotateSpeed);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera.Rotate(&direction, null, dy * rotateSpeed);
			//~ camera_Rotate(direction, null, dy * rotateSpeed);
		}
	}
	if (btn == 1) {		// set
		mx = x;
		my = y;
		//~ print("mouseHnd(btn = "); print("%08x", btn); print(", x = "); print(x); print(", y = "); print(y); print(")\n");
	}
}

Gui.setDrawCallback(drawCB);
Gui.setMouseHandler(mouseHandler);

camera.LookAt(
	vec4f(0., -12., 4.),	// eye
	vec4f(0., 0., 0.),		// target
	vec4f(0., 1., 0.)		// up
);
//~ Gui.exitLoop();
