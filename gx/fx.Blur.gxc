enum Window {
	//~ draw = RenderMode.swap_buff;
	resx = 512;
	resy = resx;
}

string fileName = "media/images/test22.jpg";
//~ string fileName = "media/images/lenaRGB.png";
//~ string fileName = "media/images/download.jpg";
//~ string fileName = "media/images/dino-blue.jpg";
//~ string fileName = "media/images/Earth.jpg";
//~ string fileName = "media/images/nol.bmp";

//~ /*
void fastblur(gxSurf img, int radius) {

	print("fastBlurImage(%d): http://incubator.quasimondo.com/processing/superfastblur.pde\n", radius);

	if (radius < 1)
		return;

	int w = width(img);
	int h = height(img);
	int wm = w - 1;
	int hm = h - 1;

	int wh = w * h;
	int div = 2 * radius + 1;

	int maxwh = w > h ? w : h;

	if (radius > hm)
		radius = hm;

	define new(typename type, int32 ^n) = emit(struct, ref(memmgr(null, type.size * n)), i32(n));
	define free(int v[]) = void(memmgr(emit(pointer, load.b32, ref(v)), 0));

	int r[] = new(int, wh);
	int g[] = new(int, wh);
	int b[] = new(int, wh);
	int vmin[] = new(int, maxwh);
	int vmax[] = new(int, maxwh);
	int dv[] = new(int, 256 * div);

	for (int i = 0; i < 256 * div; i += 1) {
		dv[i] = i / div;
	}

	int yi = 0;

	for (int y = 0; y < h; y += 1) {
		int rsum = 0;
		int gsum = 0;
		int bsum = 0;

		for (int i = -radius; i <= radius; i += 1) {
			int p = getPixel(img, Math.min(wm, Math.max(i, 0)), y);
			rsum += rch(p);
			gsum += gch(p);
			bsum += bch(p);
		}

		for (int x = 0; x < w; x += 1) {
			r[yi] = dv[rsum];
			g[yi] = dv[gsum];
			b[yi] = dv[bsum];

			if (y == 0) {
				vmin[x] = Math.min(x + radius + 1, wm);
				vmax[x] = Math.max(x - radius, 0);
			}

			int p1 = getPixel(img, vmin[x], y);
			int p2 = getPixel(img, vmax[x], y);

			rsum += rch(p1) - rch(p2);
			gsum += gch(p1) - gch(p2);
			bsum += bch(p1) - bch(p2);

			yi += 1;
		}
	}

	for (int x = 0; x < w; x += 1) {
		int rsum = 0;
		int gsum = 0;
		int bsum = 0;
		int yp = -radius * w;

		for (int i = -radius; i <= radius; i += 1) {
			int xy = Math.max(0, yp) + x;
			rsum += r[xy];
			gsum += g[xy];
			bsum += b[xy];
			yp += w;
		}

		for (int y = 0; y < h; y += 1) {
			setPixel(img, x, y, __rgb(dv[rsum], dv[gsum], dv[bsum]));

			if (x == 0) {
				vmin[y] = Math.min(y + radius + 1, hm) * w;
				vmax[y] = Math.max(y - radius, 0) * w;
			}

			int p1 = x + vmin[y];
			int p2 = x + vmax[y];

			rsum += r[p1] - r[p2];
			gsum += g[p1] - g[p2];
			bsum += b[p1] - b[p2];
		}
	}

	free(dv);
	free(vmax);
	free(vmin);
	free(b);
	free(g);
	free(r);
}

gxSurf img = gxSurf(fileName);
int blurradius = -1;

void mouseCB(int btn, int x, int y) {
	if (btn == 1)
		blurradius = y - 1;
}

vec4f grayFp2(vec4f rgbColor) {
	result = vec4f(rgbColor.x * 10);
}

void drawCB() {
	if (blurradius >= 0) {
		int radius = Math.min(blurradius - 3, Window.resy) / 8;
		blurradius = -1;
		zoomSurf(offScreen, null, img, null, 1);
		blurSurf(offScreen, null, radius);
		blurSurf(offScreen, null, radius);
		blurSurf(offScreen, null, radius);
		fillSurf(offScreen, null, grayFp2);

		
		//~ fastblur(offScreen, radius);
		//~ fastblur(offScreen, radius);
		//~ fastblur(offScreen, radius);
		//~ fastblur(offScreen, radius);
		//~ memmgr(null, 0);
		Gui.Repaint();
	}
}

Gui.setMouseHandler(mouseCB);
Gui.setDrawCallback(drawCB);
zoomSurf(offScreen, null, img, null, 1);
