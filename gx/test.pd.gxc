// Procedural drawing
enum Window {
	draw = RenderMode.swap_buff;
	resx = 512/1;
	resy = 512/1;
}

void zoomSurf2(gxSurf dst, gxRect &rect, gxSurf src, gxRect &roi, int mode) {
	gxRect srec = gxRect(0, 0, width(src), height(src));
	gxRect drec = gxRect(0, 0, width(dst), height(dst));

	if (roi != null) {
		if (roi.x > 0) {
			srec.w -= roi.x;
			srec.x = roi.x;
		}
		if (roi.y > 0) {
			srec.h -= roi.y;
			srec.y = roi.y;
		}
		if (roi.w < srec.w)
			srec.w = roi.w;
		if (roi.h < srec.h)
			srec.h = roi.h;
	}

	if (rect != null) {
		drec = rect;
	}

	if (drec.w <= 0 || drec.h <= 0)
		return;

	if (srec.w <= 0 || srec.h <= 0)
		return;

	double x0 = 0;
	double y0 = 0;
	double dx = double(srec.w - 0) / (drec.w - 0);
	double dy = double(srec.h - 0) / (drec.h - 0);
	if (drec.x < 0) {
		x0 = -drec.x;
	}

	if (drec.y < 0) {
		y0 = -drec.y;
	}

	if (clipRect(dst, &drec)) {

		//~ if (dx & 0xfffe0000 || dy & 0xfffe0000) {	// if downsampling use nearest neigbor
		//~ if (abs(dx) > 1 || abs(dy) > 1) {	// downsampling
			//~ mode = 0;
		//~ }

		x0 = x0 * dx + srec.x;
		y0 = y0 * dy + srec.y;

		double sy = y0;
		for (int y = 0; y < drec.h; y += 1) {
			double sx = x0;
			for (int x = 0; x < drec.w; x += 1) {
				//~ setPixel(dst, drec.x + x, drec.y + y, getPixel(src, int(sx), int(sy)));
				setPixel(dst, drec.x + x, drec.y + y, getPixel(src, sx, sy));
				sx += dx;
			}
			sy += dy;
		}
	}
}

define atan2f(float x, float y) = atan2(x, y);
define sqrtf(float x) = sqrt(x);
define sinf(float x) = sin(x);
define fabsf(float x) = abs(x);
define cosf(float x) = cos(x);
define colsca(vec4f &x, float s) = void(x = vec4f(x.x * s, x.y * s, x.z * s));
//~ define collerp(vec4f &res, float t, vec4f ^a, vec4f ^b) = void(res = lerp(t, a, b));
define pi = Math.pi;


void setup(double &timer, vec4f pixelCBr(double x, double y)) {

	define WIDTH = 92;
	define HEIGHT = WIDTH;
	static gxSurf tmpImg = gxSurf(WIDTH, HEIGHT);

	static bool snapshot = false;
	static bool animate = true;

	static double &time = null;
	static vec4f pixelCB(double x, double y) = null;

	static int64 begTime = timeNow();

	// for each frame
	void drawCB() {
		if (snapshot && pixelCB != null) {
			animate = false;
			snapshot = false;
			//~ bmpWrite(tmpImg, "out-0.bmp");
			//~ bmpWrite(offScreen, "out-1.bmp");
			evalSurf(offScreen, null, pixelCB);
			//~ bmpWrite(offScreen, "out-2.bmp");
		}
		if (animate && pixelCB != null) {
			// application time spent in processor
			time = .5 * clocksPerSec(timeNow() - begTime);
			//~ evalSurf((offScreen, null, pixelCB);
			zoomSurf(offScreen, null, evalSurf(tmpImg, null, pixelCB), null, 1);
			// post a redraw for animation
			Gui.Repaint();
		}
	}
	void mouseCB(int btn, int x, int y) {
		static int omb = 0;
		if (omb == 1 && btn == 0) { // onRelase(btn:1)
			snapshot = true;
		}
		if (btn == 2) {
			animate = true;
			Perlin.init();
		}
		omb = btn;
	}


	&time = timer;
	pixelCB = pixelCBr;
	Gui.setDrawCallback(drawCB);
	Gui.setMouseHandler(mouseCB);
}

double aspect = 1.33;
double time;

vec4f blob2d(double x, double y) {

	vec2d p = vec2d(2 * x - 1, 2 * y - 1);

	//~ the centre point for each blob
	vec2d move1 = vec2d(cos(time * 4.5) * 0.4, sin(time * 1.5) * 0.4);
	vec2d move2 = vec2d(cos(time * 2.0) * 0.4, sin(time * 3.0) * 0.4);
	//~ vec2d move3 = vec2d(cos(time * 7.0) * 0.4, sin(time * 2.0) * 0.4);
	//~ vec2d move4 = vec2d(cos(time * 2.0) * 0.4, sin(time * 4.3) * 0.4);

	//~ radius for each blob
	double r1 = dot(sub(p, move1), sub(p, move1)) * 8;
	double r2 = dot(sub(p, move2), sub(p, move2)) * 16;
	//~ double r3 = dot(sub(p, move3), sub(p, move3)) * 32;
	//~ double r4 = dot(sub(p, move4), sub(p, move4)) * 64;

	//~ sum the meatballs
	double metaball = (1.0 / max(r1, 1.)) + (1.0 / max(r2, 1.));
	//~ metaball += 1.0 / max(r3, 1.);
	//~ metaball += 1.0 / max(r4, 1.);

	//~ alter the cut-off power
	//~ set the output color
	result = vec4f(float32(clamp(pow(metaball, 8.0), 0., 1.)));
}

vec4f yinyang(double x, double y) {
	float64 nx = -1 + 2 * x;
	float64 ny = -1 + 2 * y;
	x = (nx*cos(time) - ny*sin(time));
	y = (nx*sin(time) + ny*cos(time));
	float64 h = x*x + y*y;
	if (h < 1) {
		float64 d = abs(y) - h;
		float64 a = d - 0.23;
		float64 b = h - 1.00;
		float64 c = sign(a * b * (y + x + (y - x) * sign(d)));

		c = mix(c, 0.0, smooth(0.98, 1.00, h));
		c = mix(c, 1.0, smooth(1.00, 1.02, h));
		result = vec4f(float32(c));
	}
	else {
		result = vec4f(float32(1));
	}
}

vec4f eye(double x, double y) {
	vec4f interior(float x, float y, float b) {
		// ezt nem tudom mire jo
		define noise2f(float32 x, float32 y, int xx, int yy) = Perlin.Noise(x, y);

		x -= 0.10f; y += 0.05f;
		float rx = 2.0f*(x-0.5f)*aspect;
		float ry = 2.0f*(y-0.5f);
		float a = atan2f(ry, rx);
		float e = rx*rx + ry*ry;
		float r = sqrtf(e);

		vec4f fue = vec4f(1.0f, 1.0f, 1.0f);
		// blood
		float ven = noise2f(24.0f*x, 24.0f*y, 256, 256);
		ven = smoothstep(ven,-.2f,.0f)-smoothstep(ven,.0f,.2f);
		ven += x + x*x*x*x*x*x*7.0f;
		fue.x = fue.x + 0.04f - 0.00f*ven;
		fue.y = fue.y + 0.04f - 0.05f*ven;
		fue.z = fue.z + 0.04f - 0.05f*ven;

		vec4f den = vec4f(0.3f, 0.7f, 0.4f+e);
		float no = 0.8f+0.2f*noise2f(4.0f*r, 32.0f*a/pi,32,32);
		colsca(den, no);

		float f2 = smoothstep(e, 0.025f, 0.035f);
		colsca(den, f2);

		// blend in/out
		result = lerp(smoothstep(e, 0.35f, 0.36f), den, fue);

		// ring
		float ri=smoothstep(e,.31f,.35f)-smoothstep(e,.35f,.39f);
		ri = 1.0f-0.35f*ri;
		colsca(result, ri);

		// reflecion
		float r3 = sqrtf(r*r*r);
		float re = noise2f(2.0f+4.0f*r3*cosf(a), 4.0f*r3*sinf(a), 256, 256);
		re = 0.8f*smoothstep(re, 0.1f, 0.5f);
		result.x += re*(1.0f-result.x);
		result.y += re*(1.0f-result.y);
		result.z += re*(1.0f-result.z);

		// shadow
		colsca(result, 0.85f+0.15f*smoothstep(-b, 0.0f, 0.2f) );

	}

	//~ float rx = 2.0f*(x - 0.5f)*aspect;
	float ry = 2.0f*(y - 0.5f);
	float h = 3.0f*sqrtf(x*x*x)*(1.0f-x);
	float e = fabsf(ry) - h;
	float f = smoothstep( e, 0.0f, 0.01f );
	vec4f cOjo = interior(x, y, 0);
	vec4f cPiel = vec4f(float32(0));//skin(x, y);
	result = lerp(f, cOjo, cPiel);
}

vec4f tunnel0(double x, double y) {

	int rgbscale(int col, double s) {
		define fixp = 16;
		int scale = s * (1 << fixp);
		int r = clamp(rch(col) * scale >> fixp, 0, 255);
		int g = clamp(gch(col) * scale >> fixp, 0, 255);
		int b = clamp(bch(col) * scale >> fixp, 0, 255);
		result = rgb(r, g, b);
	}

	int imgcoord(double val, int resolution) {
		result = val * resolution;

		if ((result %= resolution) < 0)
			result += resolution;
	}

	define tex2d(gxSurf ^src, double x, double y) = getPixel(src, imgcoord(x, width(src)), imgcoord(y, height(src)));
	define tex2d(gxSurf src, double u, double v, double w) = rgbscale(tex2d(src, u, v), w);

	define nz(double x) = nz(x, 1e-200);
	define atan(double x, double y) = atan2(x, y);

	static gxSurf srcImg = gxSurf("media/images/download.jpg");

	x = 1. - x * 2;
	y = 1. - y * 2;

	double a = atan(y, x);
	double r = hypot(x, y);

	double u = .2 * time + .1 / nz(r);
	double v = a / pi;

	result = rgb2vec4f(tex2d(srcImg, u, v, 3 * r));
}

//~ setup(&time, tunnel0);

vec4f perlin2f(double x, double y) {
	define mul = 4;
	result = vec4f(Perlin.Noise(x*mul, y*mul));
}
//~ setup1(&time, Perlin.Noise2f);
setup(&time, eye);
//~ Gui.exitLoop();
