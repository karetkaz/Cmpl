[? help]
key('*') : default object size
key('+') : increase object size
key('-') : decrease object size
key('O') : move camera to (0, 0, 0);

key('w', 'W') : move camera forward
key('s', 'S') : move camera back
key('a', 'A') : move camera left
key('d', 'D') : move camera right
key(' ', 'c') : move camera up / down

key('\t') : next draw mode (none, plot, wire, fill)
key('/', '?') : next/prev cull mode (none/back/front/all)

key('`') : toggle show info
key('L') : toggle show Lights
key('b') : toggle show bounding box
key('n') : toggle show normals

key('t') : toggle use texture
key('l') : toggle use Lights

key('Z') : toggle display Zbuff

key('N') : toggle save mesh normals
key('T') : toggle save mesh texture

key('~') : deselect all
key('0' - '9') : select Light
key('.') : select next vertex
key('>') : select prev vertex

key(Ctrl + 'p') : save image as "mesh.bmp"
key(Ctrl + 's') : save mesh as "mesh.obj"
key(Ctrl + '\n') : reload ini (this file)

[main]
screen.font = media/fonts/antique.fnt
screen.width  = 512
screen.height = 512

#~ frustum.far = 100
#~ frustum.near = .25
#~ frustum.fovy = 2.5
frustum.far = 100
frustum.near = 1
frustum.fovy = 30

# standard library scripts
script.stdlib = ../stdlib.cvx
script.gfxlib = media/scripts/gfxlib.cvx
#~ script.logfile = out/errors.txt
#~ script.dumpfile = out/dump.txt

# if program argument is of extension:
open.jpg = media/scripts/imageView.cvx
open.png = media/scripts/imageView.cvx
open.bmp = media/scripts/imageView.cvx

open.obj = media/scripts/modelView.cvx
open.3ds = media/scripts/modelView.cvx

#~ epsilon = 1e-13

[object]
#~ if no argument is given, this mesh will be loaded/generated
#~ object can be a section containing script code or a file
#~ material is a section name
#~ texture is a file name: bmp, png and jpg are supported.

#~ material = mtl.Metal Red
material = mtl.Dash
texture = media/images/download.jpg

#~ object = media/meshes/ahstray.obj
object = obj.apple
#~ object = obj.3d supershape

light.obj = obj.Sphere
#~ light.dir.obj = obj.lightDir
#~ light.spot.obj = obj.lightSpot

object.size = 1.
normal.size = .2
lights.size = .1
#~ object = media/meshes/ut2k4/scorpion.obj
#~ texture = media/meshes/ut2k4/scorpion.jpg

[? Lights ---------------------------------------------------------------------]
there are a maximum of 32 lights
evry light section turns on a light
a light can have the folowing properties:

	off: light is turned off
	pos = x, y, z: position of the light
	dir = x, y, z: light is directional
	Ka = r, g, b: ambient color
	Kd = r, g, b: diffuse color
	Ks =  r, g, b: specular color
	attn = x, y, z: attenuation where
		x: constant
		y: linear
		z: quadratic
	spot = x, y: a spot light, also direction must be non zero, where
		x: cutoff: cosine of ?
		y: exponent

[light]
#~ off
#~ a gray light
pos = +2, +2, +2
Ka = .4, .4, .4
Kd = .8, .8, .8
Ks = 1., 1., 1.
attn = 1., 0., 0., 0

[light]
off
#~ a red light
pos = +2, -2, +2
Ka = .4, .0, .0
Kd = .8, .0, .0
Ks = 1., 1., 1.
attn = 1., 0., 0., 0

[light]
off
#~ a green light
pos = -2, -2, +2
Ka = .0, .4, .0
Kd = .0, .8, .0
Ks = 1., 1., 1.
attn = 1., 0., 0., 0

[light]
off
#~ a blue light
pos = -2, +2, +2
Ka = .0, .0, .4
Kd = .0, .0, .8
Ks = 1., 1., 1.
attn = 1., 0., 0., 0

[? Materials ------------------------------------------------------------------]
[mtl.Steel]
Ka = 0.725490, 0.725490, 0.725490
Kd = 0.725490, 0.725490, 0.725490
Ks = 0.898039, 0.898039, 0.898039
KS = 16

[mtl.Dash]
Ka = 0.588235, 0.588235, 0.588235
Kd = 0.588235, 0.588235, 0.588235
Ks = 0.898039, 0.898039, 0.898039
KS = 64

[mtl.Metal Red]
Ka = 0.486275, 0.058824, 0.000000
Kd = 0.486275, 0.058824, 0.000000
Ks = 0.898039, 0.898039, 0.898039
KS = 64

[mtl.Red]
Ka = 1, 0, 0
Kd = 1, .3, .3
Ks = 1, .2, .2
KS = 64

[? Parametric functions -------------------------------------------------------]
you can define the folowing constants:
	div: the division of the mesh
	sdiv, tdiv: the division of the mesh. these overrides div.
	smin, tmin: the minimum values of s and t, by default is 0.
	smax, tmax: the maximum values of s and t, by default is 1.

the folowing functions can be used:
	float64 abs(float64 x);
	float64 sin(float64 x);
	float64 cos(float64 x);
	float64 tan(float64 x);
	float64 log(float64 x);
	float64 exp(float64 x);
	float64 sqrt(float64 x);
	float64 atan(float64 x, float64 y);
	float64 pow(float64 x, float64 y);
	void setNrm(float64 x, float64 y, float64 z);	set the normal of the vertex, if not invoked normal will be calculated using 3 points with derivates.

	gets gett and setPos should be not used. they will be removed.
		getsand gett is used to init s and t parametric values,
		setPos is called at the end of the script.
	float64 gets();
	float64 gett();
	void setPos(float64 x, float64 y, float64 z);

the folowing values can be used:
	pi: 3.1415926535...,
	e : 2.7182818284...,
	s, t: parametric function values.

the folowing out values can be setted
	x, y, z: the vertex positions

[obj.Sphere]
define smin = -pi / 2;
define smax = +pi / 2;
define tmax = 2 * pi;
x = cos(s) * cos(t);
y = cos(s) * sin(t);
z = -sin(s);

[obj.Light.Spot]
define c = 0;
define smin = -pi;
define smax = +pi;
define tmin = -pi / 2;
define tmax = +pi / 2;
x = (c - cos(t)) * cos(s);
y = (c - cos(t)) * sin(s);
z = sin(t) + cos(t);

[obj.limpet torus]
#~ define division = 512;
define smax = 2 * pi;
define tmax = 2 * pi;
define sqrt2 = 1.4142135623730950488016887;
x = cos(s) / (sqrt2 + sin(t));
y = sin(s) / (sqrt2 + sin(t));
z = -1. / (sqrt2 + cos(t));

[obj.elliptic torus]
define c = 1.5;
define smin = -pi;
define smax = +pi;
define tmin = -pi;
define tmax = +pi;
x = (-c + cos(t)) * cos(s);
y = (-c + cos(t)) * sin(s);
z = -sin(t) + cos(t);

[obj.tear drop]
#~ define division = 2000;
define smax = pi;
define tmax = 2 * pi;
#~ define sclos
x = .5 * (1 - cos(s)) * sin(s) * cos(t);
y = .5 * (1 - cos(s)) * sin(s) * sin(t);
z = cos(s);

[obj.wave]
#~ define division = 256;
define H = 20.;
define h = 10.;
define smin = -H;
define smax = +H;
define tmin = -H;
define tmax = +H;
double sst = sqrt(s*s + t*t);
x = s / H;
y = t / H;
z = h / H * sin(sst) / sst;

[obj.tours]
define R = 4;
define r = 1;

define smax = 2 * pi;
define tmax = 2 * pi;

x = (R + r * sin(s)) * cos(t);
y = (R + r * sin(s)) * sin(t);
z = r * cos(s);

[obj.3d supershape]
#~ define division = 256;
define m = 5;
define a = 1;
define b = 1;
define n1 = .1;
define n2 = 1.7;
define n3 = 1.7;

define smin = -pi;
define smax = +pi;
define tmin = -pi / 2;
define tmax = +pi / 2;

define r(double ^O) = pow(pow(abs(cos(m * O / 4.) / a), n2) + pow(abs(sin(m * O / 4.) / b), n3), 1. / n1);
double r1 = r(s);
double r2 = r(t);

x = r1 * cos(s) * r2 * cos(t);
y = r1 * sin(s) * r2 * cos(t);
z = r2 * sin(t);

[obj.apple2]
#~ define division = 128;
define tmin = -pi;
define tmax = +pi;
define smax = 2 * pi;

x = cos(s) * (4 + 3.8 * cos(t));
y = sin(s) * (4 + 3.8 * cos(t));
z = (cos(t) + sin(t) - 1) * (1 + sin(t)) * log(1 - pi * t / 10) + 7.5 * sin(t);

#~ 0 <= s <= 2 pi, -pi <= v <= pi

[obj.apple]
define division = 128;
define tmin = -pi;
define tmax = +pi;
define smax = 2 * pi;

define R1 = 4.0;
define R2 = 3.8;

#declare Fx = function(u,v){cos(u)*(R1 + R2*cos(v)) + pow((v/pi),100)}
#declare Fy = function(u,v){sin(u)*(R1 + R2*cos(v)) + 0.25*cos(5*u)}
#declare Fz = function(u,v){-2.3*ln(1 - v*0.3157)  + 6*sin(v) +2*cos(v)}
x = cos(s) * (R1 + R2 * cos(t)) + pow((t / pi), 100);
y = sin(s) * (R1 + R2 * cos(t)) + .25 * cos(5 * s);
z = -2.3 * log(1 - t * 0.3157) + 6 * sin(t) + 2 * cos(t);

[obj.Shell]
define sdiv = 128;
define tdiv = 32;
define N = 5;
define H = 3;
define tmin = -pi;
define tmax = +pi;
define smax = 2 * pi;

double W = s / (2 * pi);
x = W * cos(N * s) * (1 + cos(t));
y = W * sin(N * s) * (1 + cos(t));
z = W * sin(t) + H * (W * W);

[obj.what]
#~ define division = 128;
#~ x = s; y = t;
z = pow(s-t, 2) / 2;

[obj.hearth]
#-pi <= theta <= pi
define tmin = -pi;
define tmax = +pi;

#-0.98 <= z <= 0.98,
#~ define smin = -0.98;
#~ define smax = +0.98;
define smin = -1;
define smax = +1;

double r = 4 * sqrt(1 - s * s) * pow(sin(abs(t)), abs(t));
x = r * sin(t);
y = r * cos(t);
z = s;

