// Image dithering demo.
enum Window {
	draw = RenderMode.swap_buff;
	resx = 512;
	resy = resx;
}

//~ string fileName = "media/images/David.png";
//~ string fileName = "media/images/lenaRGB.png";
//~ string fileName = "media/images/download.jpg";
//~ string fileName = "media/images/dino-blue.jpg";
//~ string fileName = "media/images/Earth.jpg";
string fileName = "media/images/nol.bmp";

enum Dithering: int32 {
	None = '0';
	Bayer = 'B';
	SteinbergFalse = '2';
	Steinberg = '3';
	Stucki = '5';
}
gxSurf dither(gxSurf img, bool grayscale, uint32 colors, int method) {

	if (colors >= 256) {
		//~ dithering = Dithering.None;
		colors = 256;
	}

	int cols[256];

	int levels = colors - 1;

	for (int i = 0; i < colors; i += 1) {
		cols[i] = i * 255 / levels;
	}

	int width = width(img);
	int height = height(img);

	define toRgb(int r, int g, int b) = int(__rgb(r, g, b));
	define toGray(int col) = int(__gray(col));

	if (method == Dithering.None) {
		if (grayscale) {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = lum(getPixel(img, x, y));
					int gray = cols[(col * colors / 256) % colors];
					setPixel(img, x, y, toGray(gray));
				}
			}
		}
		else {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int colr = cols[(rch(col) * colors / 256) % colors];
					int colg = cols[(gch(col) * colors / 256) % colors];
					int colb = cols[(bch(col) * colors / 256) % colors];
					setPixel(img, x, y, toRgb(colr, colg, colb));
				}
			}
		}
		result = img;
	}
	else if (method == Dithering.SteinbergFalse) {
		/** the kernel
		 * 	*   3
		 *	3   2
		 */
		if (grayscale) {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = lum(getPixel(img, x, y));
					int gray = cols[(col * colors / 256) % colors];

					int quant_error = col - gray;
					define rgbError(int ^col, int ^s) = toGray(lum(col) + s * quant_error / 8);

					setPixel(img, x, y, toGray(gray));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 3));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 1, y + 1), 3));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 2));
				}
			}
		}
		else {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int colr = cols[(rch(col) * colors / 256) % colors];
					int colg = cols[(gch(col) * colors / 256) % colors];
					int colb = cols[(bch(col) * colors / 256) % colors];

					int quant_error_r = rch(col) - colr;
					int quant_error_g = gch(col) - colg;
					int quant_error_b = bch(col) - colb;

					define rgbError(int ^col, int ^s) = toRgb(
						rch(col) + s * quant_error_r / 8,
						gch(col) + s * quant_error_g / 8,
						bch(col) + s * quant_error_b / 8
					);

					setPixel(img, x, y, toRgb(colr, colg, colb));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 3));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 3));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 2));
				}
			}
		}
		result = img;
	}
	else if (method == Dithering.Steinberg) {
		/** the kernel
		 * 		*   7
		 *	3   5   1
		 */
		if (grayscale) {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {

					int col = lum(getPixel(img, x, y));
					int gray = cols[(col * colors / 256) % colors];

					int quant_error = col - gray;
					define rgbError(int col, int s) = toGray(lum(col) + s * quant_error / 16);

					setPixel(img, x, y, toGray(gray));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 7));
					setPixel(img, x - 1, y + 1, rgbError(getPixel(img, x - 1, y + 1), 3));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 5));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 1));
				}
			}
		}
		else {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int colr = cols[(rch(col) * colors / 256) % colors];
					int colg = cols[(gch(col) * colors / 256) % colors];
					int colb = cols[(bch(col) * colors / 256) % colors];

					int quant_error_r = rch(col) - colr;
					int quant_error_g = gch(col) - colg;
					int quant_error_b = bch(col) - colb;

					define rgbError(int ^col, int ^s) = toRgb(
						rch(col) + s * quant_error_r / 16,
						gch(col) + s * quant_error_g / 16,
						bch(col) + s * quant_error_b / 16
					);

					setPixel(img, x, y, toRgb(colr, colg, colb));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 7));
					setPixel(img, x - 1, y + 1, rgbError(getPixel(img, x - 1, y + 1), 3));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 5));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 1));
				}
			}
		}
		result = img;
	}
	else if (method == Dithering.Stucki) {
		/** the kernel
		 * 			*   8   4
		 *	2   4   8   4   2
		 *	1   2   4   2   1
		 */
		if (grayscale) {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = lum(getPixel(img, x, y));
					int gray = cols[(col * colors / 256) % colors];

					int quant_error = col - gray;
					define rgbError(int col, int s) = toGray(lum(col) + s * quant_error / 42);

					setPixel(img, x, y, toGray(gray));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 8));
					setPixel(img, x + 2, y + 0, rgbError(getPixel(img, x + 2, y + 0), 4));
					setPixel(img, x - 2, y + 1, rgbError(getPixel(img, x - 2, y + 1), 2));
					setPixel(img, x - 1, y + 1, rgbError(getPixel(img, x - 1, y + 1), 4));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 8));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 4));
					setPixel(img, x + 2, y + 1, rgbError(getPixel(img, x + 2, y + 1), 2));
					setPixel(img, x - 2, y + 2, rgbError(getPixel(img, x - 2, y + 2), 1));
					setPixel(img, x - 1, y + 2, rgbError(getPixel(img, x - 1, y + 2), 2));
					setPixel(img, x + 0, y + 2, rgbError(getPixel(img, x + 0, y + 2), 4));
					setPixel(img, x + 1, y + 2, rgbError(getPixel(img, x + 1, y + 2), 2));
					setPixel(img, x + 2, y + 2, rgbError(getPixel(img, x + 2, y + 2), 1));
				}
			}
		}
		else {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int colr = cols[(rch(col) * colors / 256) % colors];
					int colg = cols[(gch(col) * colors / 256) % colors];
					int colb = cols[(bch(col) * colors / 256) % colors];

					int quant_error_r = rch(col) - colr;
					int quant_error_g = gch(col) - colg;
					int quant_error_b = bch(col) - colb;

					define rgbError(int ^col, int ^s) = toRgb(
						rch(col) + s * quant_error_r / 42,
						gch(col) + s * quant_error_g / 42,
						bch(col) + s * quant_error_b / 42
					);

					setPixel(img, x, y, toRgb(colr, colg, colb));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 8));
					setPixel(img, x + 2, y + 0, rgbError(getPixel(img, x + 2, y + 0), 4));
					setPixel(img, x - 2, y + 1, rgbError(getPixel(img, x - 2, y + 1), 2));
					setPixel(img, x - 1, y + 1, rgbError(getPixel(img, x - 1, y + 1), 4));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 8));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 4));
					setPixel(img, x + 2, y + 1, rgbError(getPixel(img, x + 2, y + 1), 2));
					setPixel(img, x - 2, y + 2, rgbError(getPixel(img, x - 2, y + 2), 1));
					setPixel(img, x - 1, y + 2, rgbError(getPixel(img, x - 1, y + 2), 2));
					setPixel(img, x + 0, y + 2, rgbError(getPixel(img, x + 0, y + 2), 4));
					setPixel(img, x + 1, y + 2, rgbError(getPixel(img, x + 1, y + 2), 2));
					setPixel(img, x + 2, y + 2, rgbError(getPixel(img, x + 2, y + 2), 1));
				}
			}
		}
		result = img;
	}
	else if (method == Dithering.Bayer) {
		static const int8 Pattern[8][8] = {
			 0, 32,  8, 40,  2, 34, 10, 42,
			48, 16, 56, 24, 50, 18, 58, 26,
			12, 44,  4, 36, 14, 46,  6, 38,
			60, 28, 52, 20, 62, 30, 54, 22,
			 3, 35, 11, 43,  1, 33,  9, 41,
			51, 19, 59, 27, 49, 17, 57, 25,
			15, 47,  7, 39, 13, 45,  5, 37,
			63, 31, 55, 23, 61, 29, 53, 21
		};

		static void bayer(int &num2, int &num3, int col, int levels) {
			define d = 64;
			int tmp = col * ((levels * d) + 1) / 256;
			num3 = tmp / d;
			num2 = tmp - num3 * d;
		}

		if (grayscale) {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					define d = 64;
					int col = lum(getPixel(img, x, y));
					int num2;
					int num3;

					bayer(&num2, &num3, col, levels);
					int gray = cols[(num3 + (num2 > Pattern[x & 7][y & 7]))];

					setPixel(img, x, y, toGray(gray));
				}
			}
		}
		else {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int num2;
					int num3;

					bayer(&num2, &num3, rch(col), levels);
					int colr = cols[(num3 + (num2 > Pattern[x & 7][y & 7]))];

					bayer(&num2, &num3, gch(col), levels);
					int colg = cols[(num3 + (num2 > Pattern[x & 7][y & 7]))];

					bayer(&num2, &num3, bch(col), levels);
					int colb = cols[(num3 + (num2 > Pattern[x & 7][y & 7]))];

					setPixel(img, x, y, toRgb(colr, colg, colb));
				}
			}
		}

		result = img;
	}
}

int colors = 5;
int grayscale = !true;
int method = Dithering.Stucki;
method = Dithering.Steinberg;
//~ method = Dithering.Bayer;
//~ method = Dithering.None;

define hex(uint32 c) = int("0123456789abcdef"[c & 0xf]);

int gs = grayscale ? 'g' : 'c';
int h1 = hex(colors >> 4);
int h2 = hex(colors);

uint8 filename[34] = {'o','u','t','/','o','u','t','[',gs,'x',h1, h2,'_',method,']','.','b','m','p',0};

println(string(filename));

gxSurf image = gxSurf(fileName);


dither(image, grayscale, colors, method);
//~ bmpWrite(image, emit(string, ref(filename)));

void setupPicView(gxSurf vImg, bool vFit) {

	static bool reDraw = true;
	static bool clear = false;
	static bool fit = false;

	define inertial_pan = 25.;
	define inertial_speed = 1.01;
	static int64 inertial_time = 0;
	static double inertial_pan_x = 0;
	static double inertial_pan_y = 0;
	static double inertial_pos_x = 0;
	static double inertial_pos_y = 0;

	static gxRect roi;
	static gxSurf img;

	static double clamp(double val, double max, double mod) {
		result = Math.clamp(val, 0., max - mod);
	}

	void DrawScreen() {
		if (reDraw) {
			if (fit) {
				zoomSurf(offScreen, null, img, null, 1);
			}
			else {
				//~ copy background image
				if (clear) {
					fillRect(offScreen, 0, 0, 32768, 32768, 0x000000);
				}
				roi.x = clamp(inertial_pos_x, width(img), roi.w);
				roi.y = clamp(inertial_pos_y, height(img), roi.h);
				copySurf(offScreen, 0, 0, img, &roi);
			}
			reDraw = false;
		}
		static if (inertial_pan) {
			int64 now = millis();
			if (inertial_time < now) {
				inertial_pan_x = Math.clamp(inertial_pan_x, -inertial_pan, inertial_pan) / inertial_speed;
				inertial_pan_y = Math.clamp(inertial_pan_y, -inertial_pan, inertial_pan) / inertial_speed;
				inertial_pos_x += inertial_pan_x / inertial_pan*3;
				inertial_pos_y += inertial_pan_y / inertial_pan*3;
				if ((Math.abs(inertial_pan_x) > 1) || (Math.abs(inertial_pan_y) > 1)) {
					reDraw = true;
				}
				inertial_time = now;
			}
			if ((Math.abs(inertial_pan_x) > 1) || (Math.abs(inertial_pan_y) > 1)) {
				Gui.Repaint();
			}
		}
	}

	void mouseHandler(int btn, int x, int y) {
		static int ox = 0;
		static int oy = 0;
		static int ob = 0;

		if (Mouse.dblClick(btn, x, y)) {
			Mouse.dblClick(-1, 0, 0);		// prevent multi clicks
			fit = !fit;
			reDraw = true;
		}

		if (btn == 1 && !fit) {
			//~ roi.x = clamp(inertial_pos_x = roi.x + ox - x, width(img), roi.w);
			//~ roi.y = clamp(inertial_pos_y = roi.y + oy - y, height(img), roi.h);
			inertial_pos_x = clamp(inertial_pos_x + ox - x, width(img), roi.w);
			inertial_pos_y = clamp(inertial_pos_y + oy - y, height(img), roi.h);
			reDraw = true;
		}
		static if (inertial_pan) {
			static int64 ot = 0;
			static int32 oox = 0;
			static int32 ooy = 0;
			if (btn == 1 && ob == 0) {	// on press
				ot = millis();
				inertial_pan_x = 0;
				inertial_pan_y = 0;
				oox = x;
				ooy = y;
			}
			if (btn == 0 && ob == 1) {	// on relase
				int64 time = millis() - ot;
				if (time < 350) {
					inertial_time = 0;
					inertial_pan_x = (oox - x) / (time / 100.);
					inertial_pan_y = (ooy - y) / (time / 100.);
					oox = x;
					ooy = y;
				}
			}
		}

		ox = x;
		oy = y;
		ob = btn;
	}

	img = vImg;
	fit = inertial_pan ? false : vFit;
	roi = gxRect(0, 0, width(offScreen), height(offScreen));
	clear = roi.w > width(img) || roi.h > height(img);
	Gui.setMouseHandler(mouseHandler);
	Gui.setDrawCallback(DrawScreen);
}

image = tileSurf(gxSurf(4000, 4000), 0, 0, image, null);
setupPicView(image, false);
