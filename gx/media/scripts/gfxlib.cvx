enum RenderMode {

	draw_plot = 0x00000001;		//
	draw_wire = 0x00000002;		//
	draw_fill = 0x00000003;		//
	//~ draw_mesh = draw_plot | draw_wire | draw_fill;		// mask


	// pre 3d rendering
	zero_cbuf = 0x00000004;		// clear color buffer
	zero_zbuf = 0x00000008;		// clear z buffer

	// post 3d rendering
	swap_buff = 0x01000000;		// blit offscreen

	// these should go into mesh
	cull_back = 0x00000010;		// front face
	cull_front= 0x00000020;		// back face
	cull_all  = 0x00000030;		// back & front face
	//~ cull_mode = cull_all|cull_back|cull_front;		// enable culling
	draw_tex  = 0x00000040;		// use texture
	draw_lit  = 0x00000080;		// use lights

	// debug ...
	disp_info = 0x00010000;
	disp_oxyz = 0x00020000;
	disp_norm = 0x00040000;		// normals
	disp_bbox = 0x00080000;		// Bounding Box
	disp_lght = 0x00100000;		// lights
	disp_zbuf = 0x00200000;


	drawPlot = zero_cbuf | zero_zbuf | cull_back | draw_plot | swap_buff;
	drawWire = zero_cbuf | zero_zbuf | cull_back | draw_wire | swap_buff;
	drawFill = zero_cbuf | zero_zbuf | cull_back | draw_fill | swap_buff;
}

enum importgfx: bool {
	rgbUtils = true;
}

static if (importgfx.rgbUtils) {

define __rgb(int r, int g, int b) = int((r << 16) | (g << 8) | b);
define rgbClamp(int r, int g, int b) = __rgb(Math.clamp(r, 0, 255), Math.clamp(g, 0, 255), Math.clamp(b, 0, 255));
define rgbAnd(int r, int g, int b) = __rgb(r & 255, g & 255, b & 255);
define rgb(int r, int g, int b) = rgbAnd(r, g, b);

define __gray(int ^c) = int((c << 16) | (c << 8) | c);
define grayClamp(int c) = __gray(Math.clamp(c, 0, 255));
define grayAnd(int c) = __gray(c & 255);
define gray(int c) = grayAnd(c);

define rgb(double r, double g, double b) = rgb(r * 255, g * 255, b * 255);
define gray(double c) = gray(c * 255);

// get the Red channel of the color
define rch(int col) = int32((col >> 16) & 0xff);
// get the Green channel of the color
define gch(int col) = int32((col >> 8) & 0xff);
// get the Blue channel of the color
define bch(int col) = int32(col & 0xff);
// get the luminosity of the color
define lum(int ^c) = int((rch(c) * 76 + gch(c) * 150 + bch(c) * 29) >> 8);

static if (importstd.vec4f) {
define rgb2vec4f(int32 ^col) = vec4f(rch(col) / 255., gch(col) / 255., bch(col) / 255.);
define rgb(vec4f ^col) = rgb(int(col.x * 255), int(col.y * 255), int(col.z * 255));
}
//~ linear interpolation: assuming t is in [0, 1) * 65535
//~ define lrpfix16(int ^x, int y, int t) = int(((x << 16) + t * (y - x)) >> 16);
define lrpfix16(int ^x, int y, int t) = int(x + (t * (y - x) >> 16));
//~ define lrprgbx16(int ^x, int ^y, int ^t) = rgb(lrpfix16(rch(x), rch(y), t), lrpfix16(gch(x), gch(y), t), lrpfix16(bch(x), bch(y), t));

int lrprgbx16(int c1, int c2, int t) {
	int r = lrpfix16(rch(c1), rch(c2), t);
	int g = lrpfix16(gch(c1), gch(c2), t);
	int b = lrpfix16(bch(c1), bch(c2), t);
	//~ result = r << 16 | g << 8 | b;
	result = __rgb(r, g, b);
}

int rgbOr(int c1, int c2) {
	result = c1 | c2;
}
int rgbXor(int c1, int c2) {
	result = c1 ^ c2;
}
int rgbAnd(int c1, int c2) {
	result = c1 & c2;
}
int rgbAdd(int c1, int c2) {
	int r = Math.min(rch(c1) + rch(c2), 255);
	int g = Math.min(gch(c1) + gch(c2), 255);
	int b = Math.min(bch(c1) + bch(c2), 255);
	result = r << 16 | g << 8 | b;
}
int rgbSub(int c1, int c2) {
	int r = Math.max(rch(c1) - rch(c2), 0);
	int g = Math.max(gch(c1) - gch(c2), 0);
	int b = Math.max(bch(c1) - bch(c2), 0);
	result = r << 16 | g << 8 | b;
}
int rgbMul(int c1, int c2) {
	//~ dst->r * (src->r + 1); dst->r = tmp >> 8;
	int r = (rch(c1) * (rch(c2) + 1)) >> 8;
	int g = (gch(c1) * (gch(c2) + 1)) >> 8;
	int b = (bch(c1) * (bch(c2) + 1)) >> 8;
	result = r << 16 | g << 8 | b;
}
int rgbDiv(int c1, int c2) {
	int r = Math.min(255, (rch(c1) << 8) / (rch(c2) + 1));
	int g = Math.min(255, (gch(c1) << 8) / (gch(c2) + 1));
	int b = Math.min(255, (bch(c1) << 8) / (bch(c2) + 1));
	result = r << 16 | g << 8 | b;
}

vec4f Hsv2Rgb(vec4f hsv) {
	float32 h = hsv.x;
	float32 s = hsv.y;
	float32 v = hsv.z;

	if (s == 0) {
		result = vec4f(v);
	}
	else {
		h *= 360 / 60;

		int i = int(h);		// round
		float32 f = h - i;	// fract
		float32 u = v;
		float32 p = v * (1 - s);
		float32 q = v * (1 - s * f);
		float32 t = v * (1 - s * (1 - f));

		if (i == 0) {
			result = vec4f(u, t, p);
		}
		else if (i == 1) {
			result = vec4f(q, u, p);
		}
		else if (i == 2) {
			result = vec4f(p, u, t);
		}
		else if (i == 3) {
			result = vec4f(p, q, u);
		}
		else if (i == 4) {
			result = vec4f(t, p, u);
		}
		else {
			result = vec4f(u, p, q);
		}
	}
}

}

define gxSurf() = newSurf(0, 0);
define gxSurf(int ^dim) = newSurf(dim, dim);
define gxSurf(int width, int height) = newSurf(width, height);
define gxSurf(gxSurf ^copy) = copySurf(newSurf(width(copy), height(copy)), 0, 0, copy, null);

define fillRect(gxSurf dst, gxRect ^roi, int col) = fillRect(dst, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);
define drawRect(gxSurf dst, gxRect ^roi, int col) = drawRect(dst, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, col);

gxSurf openImg(gxSurf dst, string fileName) {

	int ext = strlen(fileName);
	//~ for (ext = 0; fileName[ext]; ext += 1) ;

	if (ext > 4 && fileName[ext - 4] == '.') {
		int chr = fileName[ext - 3];
		if (chr == 'j' || chr == 'J') {
			chr = fileName[ext - 2];
			if (chr == 'p' || chr == 'P') {
				chr = fileName[ext - 1];
				if (chr == 'g' || chr == 'G') {
					readJpg(dst, fileName);
					ext = 0;
				}
			}
		}
		else if (chr == 'b' || chr == 'B') {
			chr = fileName[ext - 2];
			if (chr == 'm' || chr == 'M') {
				chr = fileName[ext - 1];
				if (chr == 'p' || chr == 'P') {
					readBmp(dst, fileName);
					ext = 0;
				}
			}
		}
		else if (chr == 'p' || chr == 'P') {
			chr = fileName[ext - 2];
			if (chr == 'n' || chr == 'N') {
				chr = fileName[ext - 1];
				if (chr == 'g' || chr == 'G') {
					readPng(dst, fileName);
					ext = 0;
				}
			}
		}
	}
	// assert(ext != 0, "error opening file `", fileName, "`");
	if (ext != 0) {
		print("error opening file `");
		print(fileName);
		print("`\n");
	}
	result = dst;
}
define gxSurf(string fileName) = openImg(newSurf(0, 0), fileName);

bool clipRect2(gxSurf src, gxRect &roi) {
	int minx = 0;
	int miny = 0;
	int maxx = width(src);
	int maxy = height(src);

	roi.w += roi.x;
	roi.h += roi.y;

	if (roi.x < minx)
		roi.x = minx;
	if (roi.y < miny)
		roi.y = miny;
	if (roi.w > maxx)
		roi.w = maxx;
	if (roi.h > maxy)
		roi.h = maxy;

	roi.w -= roi.x;
	roi.h -= roi.y;

	result = roi.w > 0 && roi.h > 0;

}
void evalSurf2(gxSurf dst, gxRect &roi, vec4f eval(double x, double y)) {
	gxRect rect;
	if (roi == null) {
		rect.x = rect.y = 0;
		rect.w = width(dst);
		rect.h = height(dst);
	}
	else {
		rect = roi;
	}
	double dx = 1. / rect.w;
	double dy = 1. / rect.h;

	double y01 = 0;
	for (int y = rect.y; y < rect.y + rect.h; y += 1) {
		double x01 = 0;
		for (int x = rect.x; x < rect.x + rect.w; x += 1) {
			setPixel(dst, x, y, rgb(eval(x01, y01)));
			x01 += dx;
		}
		y01 += dy;
	}
}

void tileSurf(gxSurf dst, int x, int y, gxSurf src, gxRect &roi) {
	gxRect clip = gxRect(0, 0, width(src), height(src));

	if (roi != null) {
		clip = roi;
	}

	if (clipRect(src, &clip)) {
		int dstw = width(dst);
		int dsth = height(dst);
		if (x < 0) x = -(-x % clip.w);
		//~ if (y < 0) y = y % clip.h;
		for (int j = y; j < dsth; j += clip.h) {
			for (int i = x; i < dstw; i += clip.w) {
				copySurf(dst, i, j, src, &clip);
			}
		}
	}
}

//{ lookup table manipulations
/* How it should be implemented ...
void blendLut(int count, gxClut &lut, int ControlColors...) {

	if (count > 256)
		count = 256;

	lut.count = count;
	int dt = (ControlColors.Length - 1 << 16) / count;
	for (int i = 0; i < count; i += 1) {
		int t = i * dt;
		lut.data[i] = lrprgbx16(ControlColors[t >> 16], ControlColors[(t >> 16) + 1], t & 0xffff);
	}
}*/

void blendLut(int count, gxClut &lut, int Colors[]) {

	if (count > 256)
		count = 256;

	lut.count = count;
	int dt = (Colors.length - 1 << 16) / count;
	for (int i = 0; i < count; i += 1) {
		int t = i * dt;
		int c1 = Colors[t >> 16];
		int c2 = Colors[(t >> 16) + 1];
		lut.data[i] = lrprgbx16(c1, c2, t & 0xffff);
	}
}
void blendLut(gxClut &lut, int Colors[]) {
	blendLut(256, lut, Colors);
}

void blendLut(int count, gxClut &lut, int c1, int c2) {
	int Colors[2] = c1, c2;
	blendLut(count, lut, Colors);
}
void blendLut(int count, gxClut &lut, int c1, int c2, int c3) {
	int Colors[3] = c1, c2, c3;
	blendLut(count, lut, Colors);
}
void blendLut(int count, gxClut &lut, int c1, int c2, int c3, int c4) {
	int Colors[4] = c1, c2, c3, c4;
	blendLut(count, lut, Colors);
}

//~ define blendLut(gxClut &lut, int Colors) = blendLut(256, lut, Colors);
define blendLut(gxClut &lut, int c1, int c2) = blendLut(256, &lut, c1, c2);
define blendLut(gxClut &lut, int c1, int c2, int c3) = blendLut(256, &lut, c1, c2, c3);
define blendLut(gxClut &lut, int c1, int c2, int c3, int c4) = blendLut(256, &lut, c1, c2, c3, c4);

void lutBrightnessContractGamma(gxClut &lut, int brg, int cntr, double gamma) {
	double gval = 1. / gamma;
	double cval = (255 + cntr) / 255.;

	//~ bool doR = true;
	//~ bool doG = true;
	//~ bool doB = true;

	lut.count = 256;
	for (int idx = 0; idx < 256; idx += 1) {
		//~ int val = clamp(int(255 * pow(((bval + idx / 255. - .5) * cval) + .5, gval)), 0, 255);
		int val = Math.clamp(brg + int(255 * (cval * (pow(idx / 255., gval) - .5) + .5)), 0, 255);
		//~ lut.data[idx] = (doR ? val : idx) << 16 | (doG ? val : idx) << 8 | (doB ? val : idx);
		lut.data[idx] = val << 16 | val << 8 | val;
	}
}

gxSurf lut2Surf(gxSurf dst, gxClut &lut, int bg) {
	enum {
		k = 0x000000;
		r = 0xff0000;
		g = 0x00ff00;
		b = 0x0000ff;
	}
	result = dst;
	if (width(dst) == 256) {
		int imgheight = height(dst);
		fillRect(result, 0, 0, 32768, 32768, bg);
		for(int j = 0; j < 256; j += 1) {
			//~ gx_vline(result, j, 255-lut->data[j].a, 256, k);
			setPixel(result, j, (imgheight * (255-rch(lut.data[j]))) / 255, r);
			setPixel(result, j, (imgheight * (255-gch(lut.data[j]))) / 255, g);
			setPixel(result, j, (imgheight * (255-bch(lut.data[j]))) / 255, b);
		}
	}
}

/*void saveLut(gxClut &lut, string fileName) {
	gxSurf surf = lutSurf(gxSurf(256, 256), lut, 0);
	bmpWrite(surf, fileName);
	delSurf(surf);
}*/

//}

static struct Mouse {
	struct dblClickState {
		int64 clk;		// old clock
		int32 cnt;		// click count
		int32 btn;		// old button
		int32 x;		// old x coord
		int32 y;		// old y coord
	}
	int dblClick(dblClickState &old, int btn, int x, int y) {
		result = 0;
		if (btn == 1 && old.btn == 0) {	// on click
			int64 now = timeNow();
			if (x == old.x && y == old.y) {
				if (clocksPerSec(now - old.clk) < .5) {
					result = old.cnt += 1;
				}
			}

			if (!result) {
				old.cnt = 0;
				old.x = x;
				old.y = y;
			}

			old.clk = now;
		}

		if (btn == -1) {
			old.cnt = 0;
			old.x = x;
			old.y = y;
		}

		old.btn = btn;
	}
	int dblClick(int btn, int x, int y) {
		static dblClickState old;
		result = dblClick(&old, btn, x, y);
	}

	}
//{ 3d Mesh
/// TODO: closed meshes
void meshGen(int sdiv, bool sclosed, int tdiv, bool tclosed, void pos(double &x, double &y, double &z, double s, double t), double epsilon) {
	int vtx = 0;

	// set vertex and poly count to 0, but do not free memory
	mesh.Init(-1);

	if (pos != null) {
		double tDiv = tdiv - tclosed;
		double sDiv = sdiv - sclosed;
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / tDiv;
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / sDiv;

				define usev3 = true;

				static if (usev3) {		// slower

					struct Vec3{double x; double y; double z;}

					//~ define add(Vec3 &a, Vec3 &b) = Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
					//~ define mul(Vec3 &a, Vec3 &b) = Vec3(a.x * b.x, a.y * b.y, a.z * b.z);
					//~ define div(Vec3 &a, Vec3 &b) = Vec3(a.x / b.x, a.y / b.y, a.z / b.z);

					define sub(Vec3 ^a, Vec3 ^b) = Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
					define div(Vec3 ^a, double ^b) = Vec3(a.x / b, a.y / b, a.z / b);

					define dot(Vec3 ^a, Vec3 ^b) = double(a.x * b.x + a.y * b.y + a.z * b.z);
					define cross(Vec3 ^a, Vec3 ^b) = Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
					//~ define divnz(Vec3 ^a, double ^b) = Vec3(b ? a.x / b : a.x, b ? a.y / b : a.y, b ? a.z / b : a.z);
					define divnz(Vec3 ^a, double ^b) = Vec3(b ? div(a, b) : a);

					Vec3 p;
					Vec3 ds;
					Vec3 dt;
					pos(&p.x, &p.y, &p.z, s, t);
					pos(&ds.x, &ds.y, &ds.z, s + epsilon, t);
					pos(&dt.x, &dt.y, &dt.z, s, t + epsilon);

					ds = div(sub(p, ds), epsilon);
					dt = div(sub(p, dt), epsilon);

					Vec3 n = cross(ds, dt);
					n = divnz(n, sqrt(dot(n, n)));

					mesh.Pos(vtx, p.x, p.y, p.z);
					mesh.Nrm(vtx, n.x, n.y, n.z);
					mesh.Tex(vtx, s, t);
				}
				static if (!usev3) {	// faster
					double p[3];
					double n[3];
					double ds[3];
					double dt[3];

					pos(&p[0], &p[1], &p[2], s, t);
					pos(&ds[0], &ds[1], &ds[2], s + epsilon, t);
					pos(&dt[0], &dt[1], &dt[2], s, t + epsilon);

					ds[0] = (p[0] - ds[0]) / epsilon;
					ds[1] = (p[1] - ds[1]) / epsilon;
					ds[2] = (p[2] - ds[2]) / epsilon;
					dt[0] = (p[0] - dt[0]) / epsilon;
					dt[1] = (p[1] - dt[1]) / epsilon;
					dt[2] = (p[2] - dt[2]) / epsilon;

					n[0] = ds[1] * dt[2] - ds[2] * dt[1];
					n[1] = ds[2] * dt[0] - ds[0] * dt[2];
					n[2] = ds[0] * dt[1] - ds[1] * dt[0];

					define sqr(double ^x) = double(x * x);
					double len = sqrt(sqr(n[0]) + sqr(n[1]) + sqr(n[2]));
					if (len != 0) {
						n[0] /= len;
						n[1] /= len;
						n[2] /= len;
					}

					mesh.Pos(vtx, p[0], p[1], p[2]);
					mesh.Nrm(vtx, n[0], n[1], n[2]);
					mesh.Tex(vtx, s, t);
				}
				vtx += 1;
			}
		}
	}
	else {
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / double(tdiv - 1);
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / double(sdiv - 1);
				mesh.Pos(vtx, s, t, 0);
				mesh.Tex(vtx, s, t);
				vtx += 1;
			}
		}
	}
	for (int j = 0; j < tdiv - 1; j += 1) {
		int l1 = j * sdiv;
		int l2 = l1 + sdiv;
		for (int i = 0; i < sdiv - 1; i += 1) {
			int v1 = l1 + i;		// v1 -- v2
			int v2 = v1 + 1;		//  | \  |
			int v4 = l2 + i;		//  |  \ |
			int v3 = v4 + 1;		// v4 -- v3
			mesh.AddFace(v1, v2, v3, v4);
		}
	}
}

define meshGen(int sdiv, int tdiv, void pos(double &x, double &y, double &z, double s, double t)) = meshGen(sdiv, true, tdiv, true, pos, 1e-10);
//~ define meshGen(int sdiv, int tdiv, void pos(double &x, double &y, double &z, double s, double t), double epsilon) = meshGen(sdiv, true, tdiv, true, pos, epsilon);
define meshGen(int ^div, void pos(double &x, double &y, double &z, double s, double t), double epsilon) = meshGen(div, true, div, true, pos, epsilon);
define meshGen(int ^div, void pos(double &x, double &y, double &z, double s, double t)) = meshGen(div, true, div, true, pos, 1e-10);

//}*/

void setupPicView(gxSurf vImg, bool vFit) {

	static bool reDraw = true;
	static bool clear = false;
	static bool fit = false;

	define inertial_pan = 25.;
	define inertial_speed = 1.09;

	static int64 inertial_time = 0;
	static double inertial_pan_x = 0;
	static double inertial_pan_y = 0;

	static gxRect roi;
	static gxSurf img;

	void DrawScreen() {
		if (reDraw) {
			if (fit) {
				zoomSurf(offScreen, null, img, null, 1);
			}
			else {
				//~ copy background image
				if (clear) {
					fillRect(offScreen, 0, 0, 32768, 32768, 0x000000);
				}
				copySurf(offScreen, 0, 0, img, &roi);
			}
			reDraw = false;
		}
		static if (inertial_pan) {
			int64 now = timeNow();
			if (inertial_time < now) {
				inertial_pan_x = Math.clamp(inertial_pan_x, -inertial_pan, inertial_pan) / inertial_speed;
				inertial_pan_y = Math.clamp(inertial_pan_y, -inertial_pan, inertial_pan) / inertial_speed;

				if ((Math.abs(inertial_pan_x) > .5) || (Math.abs(inertial_pan_y) > .5)) {
					roi.x = Math.clamp(roi.x + inertial_pan_x, 0., float64(width(img) - roi.w));
					roi.y = Math.clamp(roi.y + inertial_pan_y, 0., float64(height(img) - roi.h));
					reDraw = true;
				}
				inertial_time = now + (int64(0x100000000) / 100);
			}
			if ((Math.abs(inertial_pan_x) > .5) || (Math.abs(inertial_pan_y) > .5)) {
				Gui.Repaint();
			}
		}
	}

	void mouseHandler(int btn, int x, int y) {
		static int ox = 0;
		static int oy = 0;
		static int ob = 0;

		if (Mouse.dblClick(btn, x, y)) {
			Mouse.dblClick(-1, 0, 0);		// prevent multi clicks
			fit = !fit;
			reDraw = true;
		}

		if (btn == 1 && !fit) {
			roi.x = Math.clamp(roi.x + ox - x, 0, width(img) - roi.w);
			roi.y = Math.clamp(roi.y + oy - y, 0, height(img) - roi.h);
			reDraw = true;
		}
		static if (inertial_pan) {
			static int64 ot = 0;
			static int32 oox = 0;
			static int32 ooy = 0;
			if (btn == 1 && ob == 0) {	// on press
				ot = timeNow();
				inertial_pan_x = 0;
				inertial_pan_y = 0;
				oox = x;
				ooy = y;
			}
			if (btn == 0 && ob == 1) {	// on relase
				int64 now = timeNow();
				if (clocksPerSec(now - ot) < .5) {
					inertial_time = 0;
					inertial_pan_x = oox - x;
					inertial_pan_y = ooy - y;
					oox = x;
					ooy = y;
				}
			}
		}

		ox = x;
		oy = y;
		ob = btn;
	}

	img = vImg;
	fit = inertial_pan ? false : vFit;
	roi = gxRect(0, 0, width(offScreen), height(offScreen));
	clear = roi.w > width(img) || roi.h > height(img);
	Gui.setMouseHandler(mouseHandler);
	Gui.setDrawCallback(DrawScreen);
}
