enum RenderMode {

	draw_plot = 0x00000001;		//
	draw_wire = 0x00000002;		//
	draw_fill = 0x00000003;		//
	//~ draw_mesh = draw_plot | draw_wire | draw_fill;		// mask


	// pre 3d rendering
	zero_cbuf = 0x00000004;		// clear color buffer
	zero_zbuf = 0x00000008;		// clear z buffer

	// post 3d rendering
	swap_buff = 0x01000000;		// blit offscreen

	// these should go into mesh
	cull_back = 0x00000010;		// front face
	cull_front= 0x00000020;		// back face
	cull_all  = 0x00000030;		// back & front face
	//~ cull_mode = cull_all|cull_back|cull_front;		// enable culling
	draw_tex  = 0x00000040;		// use texture
	draw_lit  = 0x00000080;		// use lights

	// debug ...
	disp_info = 0x00010000;
	disp_oxyz = 0x00020000;
	disp_norm = 0x00040000;		// normals
	disp_bbox = 0x00080000;		// Bounding Box
	disp_lght = 0x00100000;		// lights
	disp_zbuf = 0x00200000;


	drawPlot = zero_cbuf | zero_zbuf | cull_back | draw_plot | swap_buff;
	drawWire = zero_cbuf | zero_zbuf | cull_back | draw_wire | swap_buff;
	drawFill = zero_cbuf | zero_zbuf | cull_back | draw_fill | swap_buff;
}

enum importgfx: bool {

	rgbUtils = true;
}

static if (importgfx.rgbUtils) {

//~ define lerp(double ^a, double b, double t) = double(a + t * (b - a));
define __rgb(int r, int g, int b) = int((r << 16) | (g << 8) | b);
define __gray(int ^c) = int((c << 16) | (c << 8) | c);

// clamp or something else values to 0..255
//~ define cxff(int val) = int(val & 255);
//~ define cxff(double val) = int(clamp(val * 255, 0, 255));

define rgbClamp(int r, int g, int b) = __rgb(clamp(r, 0, 255), clamp(g, 0, 255), clamp(b, 0, 255));
define rgbAnd(int r, int g, int b) = __rgb(r & 255, g & 255, b & 255);
define rgb(int r, int g, int b) = rgbAnd(r, g, b);

//~ define rgb(double r, double g, double b) = int(cxff(r * 255) << 16 | cxff(g * 255) << 8 | cxff(b * 255));
//~ define rgb(double ^c) = int(cxff(c * 255) << 16 | cxff(c * 255) << 8 | cxff(c * 255));
define grayClamp(int c) = __gray(clamp(c, 0, 255));
define grayAnd(int c) = __gray(c & 255);
define gray(int c) = grayAnd(c);

define gray(double c) = grayAnd(c * 255);
define rgb(double r, double g, double b) = rgbAnd(r * 255, g * 255, b * 255);

// get the Red channel of the color
define rch(int col) = int32((col >> 16) & 0xff);
// get the Green channel of the color
define gch(int col) = int32((col >> 8) & 0xff);
// get the Blue channel of the color
define bch(int col) = int32(col & 0xff);
// get the luminosity of the color
define lum(int ^c) = int((rch(c) * 76 + gch(c) * 150 + bch(c) * 29) >> 8);

static if (importstd.vec4f) {
define rgb2vec4f(int32 ^col) = vec4f(rch(col) / 255., gch(col) / 255., bch(col) / 255.);
define rgb(vec4f ^col) = rgb(int(col.x * 255), int(col.y * 255), int(col.z * 255));
}
//~ linear interpolation: assuming t is in [0, 1) * 65535
//~ define lrpfix16(int ^x, int y, int t) = int(((x << 16) + t * (y - x)) >> 16);
define lrpfix16(int ^x, int y, int t) = int(x + (t * (y - x) >> 16));
//~ define lrprgbx16(int ^x, int ^y, int ^t) = rgb(lrpfix16(rch(x), rch(y), t), lrpfix16(gch(x), gch(y), t), lrpfix16(bch(x), bch(y), t));

int lrprgbx16(int c1, int c2, int t) {
	int r = lrpfix16(rch(c1), rch(c2), t);
	int g = lrpfix16(gch(c1), gch(c2), t);
	int b = lrpfix16(bch(c1), bch(c2), t);
	result = r << 16 | g << 8 | b;
}

int rgbOr(int c1, int c2) {
	result = c1 | c2;
}
int rgbXor(int c1, int c2) {
	result = c1 ^ c2;
}
int rgbAnd(int c1, int c2) {
	result = c1 & c2;
}
int rgbAdd(int c1, int c2) {
	int r = min(rch(c1) + rch(c2), 255);
	int g = min(gch(c1) + gch(c2), 255);
	int b = min(bch(c1) + bch(c2), 255);
	result = r << 16 | g << 8 | b;
}
int rgbSub(int c1, int c2) {
	int r = max(rch(c1) - rch(c2), 0);
	int g = max(gch(c1) - gch(c2), 0);
	int b = max(bch(c1) - bch(c2), 0);
	result = r << 16 | g << 8 | b;
}
int rgbMul(int c1, int c2) {
	//~ dst->r * (src->r + 1); dst->r = tmp >> 8;
	int r = (rch(c1) * (rch(c2) + 1)) >> 8;
	int g = (gch(c1) * (gch(c2) + 1)) >> 8;
	int b = (bch(c1) * (bch(c2) + 1)) >> 8;
	result = r << 16 | g << 8 | b;
}
int rgbDiv(int c1, int c2) {
	int r = min(255, (rch(c1) << 8) / (rch(c2) + 1));
	int g = min(255, (gch(c1) << 8) / (gch(c2) + 1));
	int b = min(255, (bch(c1) << 8) / (bch(c2) + 1));
	result = r << 16 | g << 8 | b;
}

vec4f Hsv2Rgb(vec4f hsv) {
	float32 h = hsv.x;
	float32 s = hsv.y;
	float32 v = hsv.z;

	if (s == 0) {
		result = vec4f(v);
	}
	else {

		h *= 360 / 60;

		int i = int(h);		// round
		float32 f = h - i;	// fract
		float32 u = v;
		float32 p = v * (1 - s);
		float32 q = v * (1 - s * f);
		float32 t = v * (1 - s * (1 - f));

		if (i == 0) {
			result = vec4f(u, t, p);
		}
		else if (i == 1) {
			result = vec4f(q, u, p);
		}
		else if (i == 2) {
			result = vec4f(p, u, t);
		}
		else if (i == 3) {
			result = vec4f(p, q, u);
		}
		else if (i == 4) {
			result = vec4f(t, p, u);
		}
		else {
			result = vec4f(u, p, q);
		}
	}
}

}

define gxSurf() = newSurf(0, 0);
define gxSurf(int dim) = newSurf(dim, dim);
define gxSurf(int width, int height) = newSurf(width, height);
define gxSurf(gxSurf ^copy) = copySurf(newSurf(width(copy), height(copy)), 0, 0, copy, null);

gxSurf openImg(gxSurf dst, string fileName) {

	int ext = strlen(fileName);
	//~ for (ext = 0; fileName[ext]; ext += 1) ;

	if (ext > 4 && fileName[ext - 4] == '.') {
		int chr = fileName[ext - 3];
		if (chr == 'j' || chr == 'J') {
			chr = fileName[ext - 2];
			if (chr == 'p' || chr == 'P') {
				chr = fileName[ext - 1];
				if (chr == 'g' || chr == 'G') {
					readJpg(dst, fileName);
					ext = 0;
				}
			}
		}
		else if (chr == 'b' || chr == 'B') {
			chr = fileName[ext - 2];
			if (chr == 'm' || chr == 'M') {
				chr = fileName[ext - 1];
				if (chr == 'p' || chr == 'P') {
					readBmp(dst, fileName);
					ext = 0;
				}
			}
		}
		else if (chr == 'p' || chr == 'P') {
			chr = fileName[ext - 2];
			if (chr == 'n' || chr == 'N') {
				chr = fileName[ext - 1];
				if (chr == 'g' || chr == 'G') {
					readPng(dst, fileName);
					ext = 0;
				}
			}
		}
	}
	// assert(ext != 0, "error opening file `", fileName, "`");
	if (ext != 0) {
		print("error opening file `");
		print(fileName);
		print("`\n");
	}
	result = dst;
}
define gxSurf(string fileName) = openImg(newSurf(0, 0), fileName);

bool clipRect2(gxSurf src, gxRect &roi) {
	int minx = 0;
	int miny = 0;
	int maxx = width(src);
	int maxy = height(src);

	roi.w += roi.x;
	roi.h += roi.y;

	if (roi.x < minx)
		roi.x = minx;
	if (roi.y < miny)
		roi.y = miny;
	if (roi.w > maxx)
		roi.w = maxx;
	if (roi.h > maxy)
		roi.h = maxy;

	roi.w -= roi.x;
	roi.h -= roi.y;

	result = roi.w > 0 && roi.h > 0;

}
void evalSurf2(gxSurf dst, gxRect &roi, vec4f eval(double x, double y)) {
	gxRect rect;
	if (roi == null) {
		rect.x = rect.y = 0;
		rect.w = width(dst);
		rect.h = height(dst);
	}
	else {
		rect = roi;
	}
	double dx = 1. / rect.w;
	double dy = 1. / rect.h;

	double y01 = 0;
	for (int y = rect.y; y < rect.y + rect.h; y += 1) {
		double x01 = 0;
		for (int x = rect.x; x < rect.x + rect.w; x += 1) {
			setPixel(dst, x, y, rgb(eval(x01, y01)));
			x01 += dx;
		}
		y01 += dy;
	}
}

void tileSurf(gxSurf dst, int x, int y, gxSurf src, gxRect &roi) {
	gxRect clip = gxRect(0, 0, width(src), height(src));

	if (roi != null) {
		clip = roi;
	}

	if (clipRect(src, &clip)) {
		int dstw = width(dst);
		int dsth = height(dst);
		if (x < 0) x = -(-x % clip.w);
		//~ if (y < 0) y = y % clip.h;
		for (int j = y; j < dsth; j += clip.h) {
			for (int i = x; i < dstw; i += clip.w) {
				copySurf(dst, i, j, src, &clip);
			}
		}
	}
}

//{ lookup table manipulations
/* How it should be implemented ...
void blendLut(int count, gxClut &lut, int ControlColors...) {

	if (count > 256)
		count = 256;

	lut.count = count;
	int dt = (ControlColors.Length - 1 << 16) / count;
	for (int i = 0; i < count; i += 1) {
		int t = i * dt;
		lut.data[i] = lrprgbx16(ControlColors[t >> 16], ControlColors[(t >> 16) + 1], t & 0xffff);
	}
}*/

void blendLut(int count, gxClut &lut, int Colors[]) {

	if (count > 256)
		count = 256;

	lut.count = count;
	int dt = (Colors.length - 1 << 16) / count;
	for (int i = 0; i < count; i += 1) {
		int t = i * dt;
		int c1 = Colors[t >> 16];
		int c2 = Colors[(t >> 16) + 1];
		lut.data[i] = lrprgbx16(c1, c2, t & 0xffff);
	}
}
void blendLut(gxClut &lut, int Colors[]) {
	blendLut(256, lut, Colors);
}

void blendLut(int count, gxClut &lut, int c1, int c2) {
	int Colors[2] = c1, c2;
	blendLut(count, lut, Colors);
}
void blendLut(int count, gxClut &lut, int c1, int c2, int c3) {
	int Colors[3] = c1, c2, c3;
	blendLut(count, lut, Colors);
}
void blendLut(int count, gxClut &lut, int c1, int c2, int c3, int c4) {
	int Colors[4] = c1, c2, c3, c4;
	blendLut(count, lut, Colors);
}

//~ define blendLut(gxClut &lut, int Colors) = blendLut(256, lut, Colors);
define blendLut(gxClut &lut, int c1, int c2) = blendLut(256, &lut, c1, c2);
define blendLut(gxClut &lut, int c1, int c2, int c3) = blendLut(256, &lut, c1, c2, c3);
define blendLut(gxClut &lut, int c1, int c2, int c3, int c4) = blendLut(256, &lut, c1, c2, c3, c4);

void lutBrightnessContractGamma(gxClut &lut, int brg, int cntr, double gamma) {
	double gval = 1. / gamma;
	double cval = (255 + cntr) / 255.;

	//~ bool doR = true;
	//~ bool doG = true;
	//~ bool doB = true;

	lut.count = 256;
	for (int idx = 0; idx < 256; idx += 1) {
		//~ int val = clamp(int(255 * pow(((bval + idx / 255. - .5) * cval) + .5, gval)), 0, 255);
		int val = clamp(brg + int(255 * (cval * (pow(idx / 255., gval) - .5) + .5)), 0, 255);
		//~ lut.data[idx] = (doR ? val : idx) << 16 | (doG ? val : idx) << 8 | (doB ? val : idx);
		lut.data[idx] = val << 16 | val << 8 | val;
	}
}

gxSurf lut2Surf(gxSurf dst, gxClut &lut, int bg) {
	enum {
		k = 0x000000;
		r = 0xff0000;
		g = 0x00ff00;
		b = 0x0000ff;
	}
	result = dst;
	if (width(dst) == 256) {
		int imgheight = height(dst);
		fillRect(result, 0, 0, 32768, 32768, bg);
		for(int j = 0; j < 256; j += 1) {
			//~ gx_vline(result, j, 255-lut->data[j].a, 256, k);
			setPixel(result, j, (imgheight * (255-rch(lut.data[j]))) / 255, r);
			setPixel(result, j, (imgheight * (255-gch(lut.data[j]))) / 255, g);
			setPixel(result, j, (imgheight * (255-bch(lut.data[j]))) / 255, b);
		}
	}
}

/*void saveLut(gxClut &lut, string fileName) {
	gxSurf surf = lutSurf(gxSurf(256, 256), lut, 0);
	bmpWrite(surf, fileName);
	delSurf(surf);
}*/

//}

struct dblClickState {
	int64 clk;		// old clock
	int32 cnt;		// click count
	int32 btn;		// old button
	int32 x;		// old x coord
	int32 y;		// old y coord
}
int dblClick(dblClickState &old, int btn, int x, int y) {
	result = 0;
	if (btn == 1 && old.btn == 0) {	// on click
		int64 now = timeNow();
		if (x == old.x && y == old.y) {
			if (clocksPerSec(now - old.clk) < .5) {
				result = old.cnt += 1;
			}
		}

		if (!result) {
			old.cnt = 0;
			old.x = x;
			old.y = y;
		}

		old.clk = now;
	}

	if (btn == -1) {
		old.cnt = 0;
		old.x = x;
		old.y = y;
	}

	old.btn = btn;
}
int dblClick(int btn, int x, int y) {
	static dblClickState old;
	result = dblClick(&old, btn, x, y);
}

//{ 3d Mesh
/// TODO: closed meshes
void meshGen(int sdiv, bool sclosed, int tdiv, bool tclosed, void pos(double &x, double &y, double &z, double s, double t), double epsilon) {
	int vtx = 0;
	mesh.Init(-1);
	if (pos != null) {
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / double(tdiv - tclosed);
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / double(sdiv - sclosed);
				double p[3];
				double n[3];
				double ds[3];
				double dt[3];

				pos(&p[0], &p[1], &p[2], s, t);
				pos(&ds[0], &ds[1], &ds[2], s + epsilon, t);
				pos(&dt[0], &dt[1], &dt[2], s, t + epsilon);

				ds[0] = (p[0] - ds[0]) / epsilon;
				ds[1] = (p[1] - ds[1]) / epsilon;
				ds[2] = (p[2] - ds[2]) / epsilon;
				dt[0] = (p[0] - dt[0]) / epsilon;
				dt[1] = (p[1] - dt[1]) / epsilon;
				dt[2] = (p[2] - dt[2]) / epsilon;

				// normal is the cross product
				n[0] = ds[1] * dt[2] - ds[2] * dt[1];
				n[1] = ds[2] * dt[0] - ds[0] * dt[2];
				n[2] = ds[0] * dt[1] - ds[1] * dt[0];

				define sqr(double ^x) = double(x * x);
				double len = sqrt(sqr(n[0]) + sqr(n[1]) + sqr(n[2]));
				if (len != 0) {
					n[0] /= len;
					n[1] /= len;
					n[2] /= len;
				}

				mesh.Pos(vtx, p[0], p[1], p[2]);
				mesh.Nrm(vtx, n[0], n[1], n[2]);
				mesh.Tex(vtx, s, t);
				vtx += 1;
			}
		}
	}
	else {
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / double(tdiv - 1);
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / double(sdiv - 1);
				mesh.Pos(vtx, s, t, 0);
				mesh.Tex(vtx, s, t);
				vtx += 1;
			}
		}
	}
	for (int j = 0; j < tdiv - 1; j += 1) {
		int l1 = j * sdiv;
		int l2 = l1 + sdiv;
		for (int i = 0; i < sdiv - 1; i += 1) {
			int v1 = l1 + i;		// v1 -- v2
			int v2 = v1 + 1;		//  | \  |
			int v4 = l2 + i;		//  |  \ |
			int v3 = v4 + 1;		// v4 -- v3
			mesh.AddFace(v1, v2, v3, v4);
		}
	}
}

define meshGen(int sdiv, int tdiv, void pos(double &x, double &y, double &z, double s, double t)) = meshGen(sdiv, true, tdiv, true, pos, 1e-10);
//~ define meshGen(int sdiv, int tdiv, void pos(double &x, double &y, double &z, double s, double t), double epsilon) = meshGen(sdiv, true, tdiv, true, pos, epsilon);
define meshGen(int ^div, void pos(double &x, double &y, double &z, double s, double t), double epsilon) = meshGen(div, true, div, true, pos, epsilon);
define meshGen(int ^div, void pos(double &x, double &y, double &z, double s, double t)) = meshGen(div, true, div, true, pos, 1e-10);

//}*/
