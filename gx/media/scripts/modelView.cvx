const renderType = RenderMode.drawFill;// & ~RenderMode.zero_cbuf;

//~ args[0] = "this script's filename";
//~ args[1] = "mesh.obj";

/* list arguments
for (int i = 0; i < args.length; i += 1) {
	print("argument[");
	print(i);
	print("] = ");
	println(args[i]);
}// */

string texture = properties.texture;

if (args.length == 3) {
	texture = args[2];
}

mesh.Read(args[1], texture);
//~ mesh.Normalize(0);
mesh.Center(2);

//~ mesh.Info();
//~ mesh.Save("mesh.obj");

void mouseHandler(int btn, int x, int y) {
	static vec4f orbit = vec4f(0., 0., 0., 0.);
	static int ox;
	static int oy;
	float dx = x - ox;
	float dy = y - oy;
	ox = x;
	oy = y;

	const moveSpeed = .08;
	const rotateSpeed = moveSpeed * Math.pi / 180.;
	const rotateSpeed2 = 10 * rotateSpeed;

	if (dblClick(btn, x, y)) {
		dblClick(-1, 0, 0);
		camera.LookAt(
			vec4f(0., 0., 16.),		// eye
			vec4f(0., 0., 0.),		// target
			vec4f(0., 1., 0.)		// up
		);
	}

	if (btn == 1) {	// orbit the camera
		if (dx) {
			vec4f direction = camera.Up;
			camera.Rotate(&direction, &orbit, dx * rotateSpeed2);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera.Rotate(&direction, &orbit, dy * rotateSpeed2);
		}
	}
	if (btn == 2) {	// rotate the camera
		// if no orbit is given, orbit will be the camera position.
		//~ static vec4f orbit = camera.Pos;
		if (selection.object) {
			selection.Rotate(dx * rotateSpeed, dy * rotateSpeed);
		}
		else {
			if (dx) {
				vec4f direction = camera.Up;
				camera.Rotate(&direction, null, dx * rotateSpeed);
			}
			if (dy) {
				vec4f direction = camera.Right;
				camera.Rotate(&direction, null, dy * rotateSpeed);
			}
		}
	}
	if (btn == 3) {	// move forward / back
		if (selection.object) {
			selection.Move(dx * moveSpeed, dy * -moveSpeed);
		}
		else {
			vec4f direction = camera.Forward;
			camera.Move(&direction, dy * moveSpeed);
		}
	}
}
Gui.setMouseHandler(mouseHandler);
//~ Gui.exitLoop();
