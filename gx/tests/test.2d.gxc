// 2d todo demos.
define test = 4;
enum Window {
	draw = RenderMode.swap_buff;

	//~ resx = 1440;
	//~ resy = 900;

	//~ resx = 800;
	//~ resy = 800;

	resx = 512;
	resy = 512;
}

//~ define pi = Math.pi;

define fillRect(gxSurf dst, int col) = fillRect(dst, 0, 0, 65535, 65535, col);

static if (true) {		// mandelbrot

gxClut mandelLut;
double QMin = -1.5;
double QMax = +1.5;
double PMin = -2.25;
double PMax = +0.75;
blendLut(32, &mandelLut, 0xFFFFFF, 0x000000, 0xadadff, 0x000000);
}

int reDraw = 1;
gxRect roi  = gxRect(Window.resx / 2 - Window.resx / 4, Window.resy / 2 - Window.resy / 4, Window.resx / 2, Window.resy / 2);

void mouseMoveSizeRoi(int btn, int x, int y) {
	static int ox = 0;
	static int oy = 0;
	if (btn == 1) {
		reDraw = true;
		roi.x += x - ox;
		roi.y += y - oy;
	}
	if (btn == 2) {
		reDraw = true;
		roi.w = x - roi.x;
		roi.h = y - roi.y;
	}
	ox = x;
	oy = y;
}

static if (test == 0) {		// Quit
Gui.exitLoop();
}
static if (test == 1) {		// mouse
int mbtn = 0;
void mouseCB(int btn, int x, int y) {
	mbtn = btn;
	print("mouseHnd(btn = "); print("%08x", btn); print(", x = "); print(x); print(", y = "); print(y); print(")\n");
}
void drawCB() {
	int color = 0;
	if (mbtn & 1) {
		color |= 0xff0000;
	}
	if (mbtn & 2) {
		color |= 0x00ff00;
	}
	if (mbtn & 4) {
		color |= 0x0000ff;
	}
	fillRect(offScreen, 0, 0, Window.resx, Window.resy, color);
}

Gui.setMouseHandler(mouseCB);
Gui.setDrawCallback(drawCB);

}

static if (test == 2) {		// zoomSurf / tileSurf
gxSurf image = gxSurf("media/images/dino-blue.jpg");
gxSurf bgImg = gxSurf("media/images/nol.bmp");

void mouseCB(int btn, int x, int y) {
	static int ox = 0;
	static int oy = 0;
	if (btn == 1 + 2) {
		roi.x += x - ox;
		roi.y += y - oy;
		roi.w = width(image);
		roi.h = height(image);
		reDraw = true;
	}
	else if (reDraw = btn) {
		roi = gxRect(roi.x, roi.y, x, y);
	}
	ox = x;
	oy = y;
}
void drawCB() {
	define filter = 2;

	if (reDraw == 1) {
		tileSurf(offScreen, 0, 0, bgImg, null);
		zoomSurf(offScreen, &roi, image, null, filter);
	}
	else if (reDraw == 2) {
		zoomSurf(offScreen, null, image, &roi, filter);
	}
	else if (reDraw >= 4) {
		tileSurf(offScreen, 0, 0, image, &roi);
	}
	reDraw = 0;
}

Gui.setMouseHandler(mouseCB);
Gui.setDrawCallback(drawCB);
//~ reDraw = 0;
}
static if (test == -2) {	// zoomSurf / tileSurf
gxSurf image = gxSurf("media/images/dino-blue.jpg");		// xxx
//~ gxSurf image = gxSurf("media/images/download.jpg");
//~ gxSurf image = gxSurf("media/images/David.png");
gxSurf bgImg = gxSurf("media/images/nol.bmp");

void drawCB() {
	define filter = 1;

	//~ reDraw = 67;
	if (reDraw == 1) {
		tileSurf(offScreen, 0, 0, bgImg, null);
		zoomSurf(offScreen, &roi, image, null, filter);
	}
	else if (reDraw == 2) {
		zoomSurf(offScreen, &roi, image, null, filter);
	}
	else if (reDraw >= 4) {
		tileSurf(offScreen, 0, 0, image, &roi);
	}
	//~ reDraw = 1;
	// */
}

Gui.setMouseHandler(mouseMoveSizeRoi);
Gui.setDrawCallback(drawCB);
}

static if (test == 3) {		// fillRect, drawRect, fillOval, drawOval

gxSurf bgImg = gxSurf("media/images/nol.bmp");

void drawOval(gxSurf s, int x0, int y0, int x1, int y1, int width, long color) {
	if (width == 1) {
		drawOval(s, x0, y0, x1, y1, color);
	}
	else if (width < 0) {
		fillOval(s, x0, y0, x1, y1, color);
	}
	else {
		int dx;
		int dy;
		int sx;
		int sy;
		int r;
		if (x0 > x1) {
			int tmp = x0;
			x0 = x1;
			x1 = tmp;
		}
		if (y0 > y1) {
			int tmp = y0;
			y0 = y1;
			y1 = tmp;
		}

		dx = x1 - x0;
		dy = y1 - y0;

		x1 = x0 += dx >> 1;
		x0 += dx & 1;

		dx += dx & 1;
		dy += dy & 1;

		//~ int step = 2;//width / 2;
		sx = dx * dx;
		sy = dy * dy;

		r = sx * dy >> 2;
		dx = 0;
		dy = r << 1;
		int sdiv2 = width / 2;
		int sdivstep = Math.max(1, sdiv2 / 3);
		//~ define pixels(gxSurf s, int &x, int &y, int &sdiv2, int c) = fillRect(s, x-sdiv2, y-sdiv2, x+sdiv2, y+sdiv2, c);

		define pixels(gxSurf s, int &x, int &y, int &sdiv2, int c) = fillOval(s, x-sdiv2, y-sdiv2, x+sdiv2, y+sdiv2, c);
		for (int n = 0; y0 < y1; n += 1) {
			define step = 1;

			if (n % sdivstep == 0) {
				pixels(s, x0, y0, sdiv2, color);
				pixels(s, x0, y1, sdiv2, color);
				pixels(s, x1, y0, sdiv2, color);
				pixels(s, x1, y1, sdiv2, color);
			}

			if (r >= 0) {
				x0 -= step;
				x1 += step;
				r -= dx += sy;
			}

			if (r < 0) {
				y0 += step;
				y1 -= step;
				r += dy -= sx;
			}
		}
		pixels(s, x0, y0, sdiv2, color);
		pixels(s, x0, y1, sdiv2, color);
		pixels(s, x1, y0, sdiv2, color);
		pixels(s, x1, y1, sdiv2, color);
	}
}

void drawLine2(gxSurf s, int x0, int y0, int x1, int y1, long color) {
	drawLine(s, x0, y0, x1, y1, color);
}

void drawCB() {
	define color = 0xff00ff;
	tileSurf(offScreen, 0, 0, bgImg, null);

	//~ drawLine2(offScreen, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
	drawOval(offScreen, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, 60, color);
	//~ fillOval(offScreen, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
	//~ drawOval(offScreen, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
	//~ fillRect(offScreen, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
	//~ drawRect(offScreen, roi.x, roi.y, roi.x + roi.w, roi.y + roi.h, color);
}

Gui.setMouseHandler(mouseMoveSizeRoi);
Gui.setDrawCallback(drawCB);
}

static if (test == 4) {		// copy surface with callback

gxSurf back = gxSurf(Window.resx, Window.resy);
gxSurf mand = gxSurf(Window.resx, Window.resy);

void drawCB() {
	int rgbMax(int dst, int src) {
		define op(int a, int b) = Math.max(a, b);
		int r = op(rch(dst), rch(src));
		int g = op(gch(dst), gch(src));
		int b = op(bch(dst), bch(src));
		result = int(__rgb(r, g, b));
		//~ result = dst & src;
	}
	int rgbOp(int dst, int src) = rgbMax;

	copySurf(offScreen, 0, 0, back, null);
	copySurfrgb(offScreen, roi.x, roi.y, mand, &roi, rgbOp);
	//~ Gui.Repaint();
}

Gui.setMouseHandler(mouseMoveSizeRoi);
Gui.setDrawCallback(drawCB);

evalSurfrgb(back, null, rgbXor);
Mandel(mand, &mandelLut, QMin, QMax, PMin, PMax);
}

static if (test == 5) {
struct point {
	int x;
	int y;
}

void sort(point points[], bool sort_by_y) {
	for(int i = 0; i < points.length - 1; i += 1) {
		for(int j = i + 1; j < points.length; j += 1) {
			if (sort_by_y) {
				if (points[i].y < points[j].y) {
					point tmp = points[i];
					points[i] = points[j];
					points[j] = tmp;
				}
			}
			else {
				if (points[i].x < points[j].x) {
					point tmp = points[i];
					points[i] = points[j];
					points[j] = tmp;
				}
			}
		}
	}
}

int mbtn = 0;
int clicks = 0;
point points[4];

void mouseCB(int btn, int x, int y) {
	if (Mouse.dblClick(btn, x, y)) {
		clicks = 0;
		mbtn = 0;
		return;
	}
	if (btn == 0 && mbtn == 1 && clicks < points.length) {
		points[clicks] = point(x, y);
		clicks += 1;
	}
	mbtn = btn;
}

void keyboardCB(int btn, int ext) {
	if (btn == 27) {
		Gui.exitLoop();
		return;
	}
	if (btn == ' ') {
		clicks = 0;
		mbtn = 0;
		return;
	}
	mbtn = btn;
}

void drawCB() {
	define drawLine(gxSurf dst, point &p1, point &p2, int color) = drawLine(offScreen, p1.x, p1.y, p2.x, p2.y, color);
	define drawOval(gxSurf dst, point &p, int s, int color) = drawOval(offScreen, p.x - s / 2, p.y - s / 2, p.x + s / 2, p.y + s / 2, color);

	enum {
		background = 0xffffff;
		linecolor  = 0x000000;
		rectcolor  = 0xff0000;
	}

	static bool redraw = true;
	if (redraw) {
		fillRect(offScreen, 0, 0, Window.resx, Window.resy, background);
		for (int i = 0; i < clicks; i += 1) {
			drawLine(offScreen, points[i % clicks], points[(i+1) % clicks], linecolor);
			drawOval(offScreen, points[i % clicks], 5, linecolor);
		}

		if (clicks == points.length) {
			point min;
			point max;
			sort(points, false);
			min.x = points[1].x;
			max.x = points[points.length - 2].x;

			sort(points, true);
			min.y = points[1].y;
			max.y = points[points.length - 2].y;
			drawRect(offScreen, min.x, min.y, max.x, max.y, rectcolor);

			redraw = false;
		}
	}
	if (clicks < points.length) {
		redraw = true;
	}
}

Gui.setKeyboardHandler(keyboardCB);
Gui.setMouseHandler(mouseCB);
Gui.setDrawCallback(drawCB);
}

void keyCB(int btn, int ext) {
	if (btn == 27) {
		Gui.exitLoop();
	}
	print("state[%d]: ", ext);
	print("button: `%d`\n", btn);
}

Gui.setKeyboardHandler(keyCB);

//~ define res = 20000;
//~ bmpWrite(Mandel(gxSurf(res, res), mandelLut, QMin, QMax, PMin, PMax), "Mandel.bmp");
//~ Gui.exitLoop();
