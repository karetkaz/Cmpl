// 3d parametric surface demo.
enum Window {
	draw = RenderMode.drawFill|RenderMode.draw_lit;// & ~RenderMode.zero_cbuf;
	resx = 512;
	resy = 512;
}

define pi = Math.pi;

void peak(double &x, double &y, double &z, double s01, double t01) {
	define H = 20.;
	define h = 10.;
	define smin = -H;
	define smax = +H;
	define tmin = -H;
	define tmax = +H;
	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);
	double sst = sqrt(s*s + t*t);
	x = s / H;
	y = t / H;
	z = h / H * sin(sst) / sst;
}
void drop(double &x, double &y, double &z, double s01, double t01) {
	define sdiv = 128;
	define tdiv = 32;
	define N = 5;
	define H = 3;
	define tmin = 0.;
	define tmax = 2 * pi;
	define smin = 0.;
	define smax = pi;

	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);

	x = .5 * (1 - cos(s)) * sin(s) * cos(t);
	y = .5 * (1 - cos(s)) * sin(s) * sin(t);
	z = cos(s);

	//~ double W = s / (2 * pi);
	//~ x = W * cos(N * s) * (1 + cos(t));
	//~ y = W * sin(N * s) * (1 + cos(t));
	//~ z = W * sin(t) + H * (W * W);
}
void shell(double &x, double &y, double &z, double s01, double t01) {
	define sdiv = 128;
	define tdiv = 32;
	define N = 5;
	define H = 3;
	define tmin = -pi;
	define tmax = +pi;
	define smin = 0.;
	define smax = 2. * pi;

	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);

	double W = s / (2 * pi);
	x = W * cos(N * s) * (1 + cos(t));
	y = W * sin(N * s) * (1 + cos(t));
	z = W * sin(t) + H * (W * W);
}
void ellipse(double &x, double &y, double &z, double s01, double t01) {
	define X = 1;
	define Y = 1;
	define Z = 1;
	define smin = 0.;
	define smax = 2 * pi;
	define tmin = -pi / 2;
	define tmax = +pi / 2;

	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);

	x = X * cos(t) * cos(s);
	y = Y * cos(t) * sin(s);
	z = Z * sin(t);
}
void cilinder(double &x, double &y, double &z, double s01, double t01) {
	define X = 1;
	define Y = 1;
	define Z = 1;
	define smin = 0.;
	define smax = 2.;
	define tmin = 0.;
	define tmax = 2*pi;

	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);

	x = cos(t);
	y = sin(t);
	z = -s;
}
void OPXor(double &x, double &y, double &z, double s01, double t01) {
	define H = float64(10);
	x = Math.lerp(1 - s01, -H, H);
	y = Math.lerp(1 - t01, -H, H);
	z = double(int(255 * s01) ^ int(255 * t01)) / (256 / (2*H));
}

void OPPerlin(double &x, double &y, double &z, double s01, double t01) {
	define H = float64(10);
	define M = float64(10);
	x = Math.lerp(1 - s01, -H, H);
	y = Math.lerp(1 - t01, -H, H);
	z = Perlin.Noise(Math.lerp(s01, 0., M), Math.lerp(t01, 0., M));
}

define divisionM = 2;
define divisionS = divisionM * 64;
define divisionT = divisionM * 64;

//~ meshGen(divisionM*8, divisionM, shell);
mesh.Texture(gxSurf("media/images/download.jpg"));
meshGen(divisionS, true, divisionT, true, peak, 1e-10);
//~ meshGen(divisionS, true, divisionT, true, drop, 1e-10); 

void kbdHandler(int key, int ext) {
	if (key == 27) {
		Gui.exitLoop();
	}
	else if (key == ' ') {
		Perlin.start = true;
		meshGen(divisionS, true, divisionT, true, OPPerlin, 1e-10);
		mesh.Center(2);
		mesh.Normalize(0);
		Gui.Repaint(false);
	}
	else if (key == 't') {
		mesh.Info();
	}
}

Gui.setKeyboardHandler(kbdHandler);
mesh.Center(2);
mesh.Normalize(0);
//~ mesh.Normalize(1e-10);

mesh.Info();
