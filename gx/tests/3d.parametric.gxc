// 3d parametric surface demo.
enum Window {
	draw = RenderMode.drawFill|RenderMode.draw_lit;// & ~RenderMode.zero_cbuf;
	resx = 512;
	resy = 512;
}

inline pi = Math.pi;

void peak(double &x, double &y, double &z, double s01, double t01) {
	inline H = 20.;
	inline h = 10.;
	inline smin = -H;
	inline smax = +H;
	inline tmin = -H;
	inline tmax = +H;
	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);
	double sst = float64.sqrt(s*s + t*t);
	x = s / H;
	y = t / H;
	z = h / H * float64.sin(sst) / sst;
}
void drop(double &x, double &y, double &z, double s01, double t01) {
	inline sdiv = 128;
	inline tdiv = 32;
	inline N = 5;
	inline H = 3;
	inline tmin = 0.;
	inline tmax = 2 * pi;
	inline smin = 0.;
	inline smax = pi;

	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);

	x = .5 * (1 - float64.cos(s)) * float64.sin(s) * float64.cos(t);
	y = .5 * (1 - float64.cos(s)) * float64.sin(s) * float64.sin(t);
	z = float64.cos(s);

	//~ double W = s / (2 * pi);
	//~ x = W * cos(N * s) * (1 + cos(t));
	//~ y = W * sin(N * s) * (1 + cos(t));
	//~ z = W * sin(t) + H * (W * W);
}
void shell(double &x, double &y, double &z, double s01, double t01) {
	inline sdiv = 128;
	inline tdiv = 32;
	inline N = 5;
	inline H = 3;
	inline tmin = -pi;
	inline tmax = +pi;
	inline smin = 0.;
	inline smax = 2. * pi;

	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);

	double W = s / (2 * pi);
	x = W * float64.cos(N * s) * (1 + float64.cos(t));
	y = W * float64.sin(N * s) * (1 + float64.cos(t));
	z = W * float64.sin(t) + H * (W * W);
}
void ellipse(double &x, double &y, double &z, double s01, double t01) {
	inline X = 1;
	inline Y = 1;
	inline Z = 1;
	inline smin = 0.;
	inline smax = 2 * pi;
	inline tmin = -pi / 2;
	inline tmax = +pi / 2;

	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);

	x = X * float64.cos(t) * float64.cos(s);
	y = Y * float64.cos(t) * float64.sin(s);
	z = Z * float64.sin(t);
}
void cilinder(double &x, double &y, double &z, double s01, double t01) {
	inline X = 1;
	inline Y = 1;
	inline Z = 1;
	inline smin = 0.;
	inline smax = 2.;
	inline tmin = 0.;
	inline tmax = 2*pi;

	double s = Math.lerp(s01, smin, smax);
	double t = Math.lerp(t01, tmin, tmax);

	x = float64.cos(t);
	y = float64.sin(t);
	z = -s;
}
void OPXor(double &x, double &y, double &z, double s01, double t01) {
	inline H = float64(10);
	x = Math.lerp(1 - s01, -H, H);
	y = Math.lerp(1 - t01, -H, H);
	z = double(int(255 * s01) ^ int(255 * t01)) / (256 / (2*H));
}

void OPPerlin(double &x, double &y, double &z, double s01, double t01) {
	inline H = float64(10);
	inline M = float64(10);
	x = Math.lerp(1 - s01, -H, H);
	y = Math.lerp(1 - t01, -H, H);
	z = Perlin.Noise(Math.lerp(s01, 0., M), Math.lerp(t01, 0., M));
}

inline divisionM = 2;
inline divisionS = divisionM * 64;
inline divisionT = divisionM * 64;

//~ meshGen(divisionM*8, divisionM, shell);
mesh.Texture(gxSurf("media/images/download.jpg"));
meshGen(divisionS, true, divisionT, true, peak, 1e-10);
//~ meshGen(divisionS, true, divisionT, true, drop, 1e-10); 

void kbdHandler(int key, int ext) {
	if (key == 27) {
		Gui.exitLoop();
	}
	else if (key == ' ') {
		Perlin.start = true;
		meshGen(divisionS, true, divisionT, true, OPPerlin, 1e-10);
		mesh.Center(2);
		mesh.Normalize(0);
		Gui.Repaint(false);
	}
	else if (key == 't') {
		mesh.Info();
	}
}

Gui.setKeyboardHandler(kbdHandler);
mesh.Center(2);
mesh.Normalize(0);
//~ mesh.Normalize(1e-10);

mesh.Info();
