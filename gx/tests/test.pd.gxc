// Procedural drawing demos.
enum Window {
	draw = RenderMode.swap_buff;
	resx = 512;
	resy = 512;
}

define pi = Math.pi;

void setup(float &time, vec4f pixelCB(float x, float y)) {
	define WIDTH = 128;
	define HEIGHT = WIDTH;
	static gxSurf tmpImg = gxSurf(WIDTH, HEIGHT);

	static bool snapshot = false;
	static bool animate = true;

	struct Internals {
		float &time;
		vec4f pixelCB(float x, float y);
	}

	static Internals internals;

	static int32 begTime = System.millis();

	// for each frame
	static void drawCB() {
		if (snapshot) {
			animate = false;
			snapshot = false;
			int64 start = System.millis();
			evalSurf(offScreen, null, internals.pixelCB);
			float time = float(System.millis() - start) / 1000;
			debug("evaluation time in seconds", variant(&time));
			//~ bmpWrite(offScreen, "out-2.bmp");
		}
		if (animate) {
			// application time spent in processor
			internals.time = .0005 * float(System.millis() - begTime);

			//~ evalSurf(offScreen, null, internals.pixelCB);
			zoomSurf(offScreen, null, evalSurf(tmpImg, null, internals.pixelCB), null, 1);

			// post a redraw for animation
			Gui.Repaint();
		}
	}
	static void mouseCB(int btn, int x, int y) {
		static int omb = 0;
		if (omb == 1 && btn == 0) { // onRelase(btn:1)
			snapshot = true;
		}
		if (btn == 2) {
			animate = true;
			Perlin.init();
		}
		omb = btn;
	}

	internals = Internals(time, pixelCB);
	Gui.setDrawCallback(drawCB);
	Gui.setMouseHandler(mouseCB);
}

const float aspect = 1;//.33;
float time;

vec4f blob2d(float x, float y) {

	vec2d p = vec2d(2 * x - 1, 2 * y - 1);

	//~ the centre point for each blob
	vec2d move1 = vec2d(float.cos(time * 4.5) * 0.4, float.sin(time * 1.5) * 0.4);
	vec2d move2 = vec2d(float.cos(time * 2.0) * 0.4, float.sin(time * 3.0) * 0.4);
	vec2d move3 = vec2d(float.cos(time * 7.0) * 0.4, float.sin(time * 2.0) * 0.4);
	//~ vec2d move4 = vec2d(float.cos(time * 2.0) * 0.4, float.sin(time * 4.3) * 0.4);

	//~ radius for each blob
	float r1 = dot(sub(p, move1), sub(p, move1)) * 22;
	float r2 = dot(sub(p, move2), sub(p, move2)) * 26;
	float r3 = dot(sub(p, move3), sub(p, move3)) * 32;
	//~ float r4 = dot(sub(p, move4), sub(p, move4)) * 64;

	//~ sum the meatballs
	float metaball = (1.0 / Math.max(r1, 1.)) + (1.0 / Math.max(r2, 1.));
	metaball += 1.0 / Math.max(r3, 1.);
	//~ metaball += 1.0 / Math.max(r4, 1.);

	//~ alter the cut-off power
	//~ set the output color
	result = vec4f(float(Math.clamp(float.pow(metaball, 8.0), float(0), float(1))));
}

vec4f yinyang(float x, float y) {
	float nx = -1 + 2 * x;
	float ny = -1 + 2 * y;
	x = (nx * float.cos(time) - ny * float.sin(time));
	y = (nx * float.sin(time) + ny * float.cos(time));
	float h = x*x + y*y;
	if (h < 1.) {
		float d = Math.abs(y) - h;
		float a = d - 0.23;
		float b = h - 1.00;
		float c = Math.sign(a * b * (y + x + (y - x) * Math.sign(d)));

		c = Math.lerp(Math.smooth(0.98, 1.00, h), c, 0.0);
		c = Math.lerp(Math.smooth(1.00, 1.02, h), c, 1.0);
		result = vec4f(float(c));
	}
	else {
		result = vec4f(float(1));
	}
}
define smoothstep(float t, float a, float b) = Math.smooth(t, a, b);

vec4f eye(float x, float y) {
	static void colscale(vec4f &x, float s) {
		x = vec4f(x.x * s, x.y * s, x.z * s);
	}

	static vec4f interior(float x, float y, float b) {
		// ezt nem tudom mire jo
		define noise2f(float x, float y, int xx, int yy) = Perlin.Noise(x, y);

		x -= 0.10f; y += 0.05f;
		float rx = 2.0f*(x-0.5f)*aspect;
		float ry = 2.0f*(y-0.5f);
		float a = float.atan2(ry, rx);
		float e = rx*rx + ry*ry;
		float r = float.sqrt(e);

		vec4f fue = vec4f(1.0f, 1.0f, 1.0f);
		// blood
		float ven = noise2f(24.0f*x, 24.0f*y, 256, 256);
		ven = smoothstep(ven,-.2f,.0f)-smoothstep(ven,.0f,.2f);
		ven += x + x*x*x*x*x*x*7.0f;
		fue.x = fue.x + 0.04f - 0.00f*ven;
		fue.y = fue.y + 0.04f - 0.05f*ven;
		fue.z = fue.z + 0.04f - 0.05f*ven;

		vec4f den = vec4f(0.3f, 0.7f, 0.4f+e);
		float no = 0.8f+0.2f*noise2f(4.0f*r, 32.0f*a/pi,32,32);
		colscale(&den, no);

		float f2 = smoothstep(e, 0.025f, 0.035f);
		colscale(&den, f2);

		// blend in/out
		result = lerp(smoothstep(e, 0.35f, 0.36f), den, fue);

		// ring
		float ri=smoothstep(e,.31f,.35f)-smoothstep(e,.35f,.39f);
		ri = 1.0f-0.35f*ri;
		colscale(&result, ri);

		// reflecion
		float r3 = float.sqrt(r*r*r);
		float re = noise2f(2.0f+4.0f*r3*float.cos(a), 4.0f*r3*float.sin(a), 256, 256);
		re = 0.8f*smoothstep(re, 0.1f, 0.5f);
		result.x += re*(1.0f-result.x);
		result.y += re*(1.0f-result.y);
		result.z += re*(1.0f-result.z);

		// shadow
		colscale(&result, 0.85f+0.15f*smoothstep(-b, 0.0f, 0.2f) );

	}

	//~ float rx = 2.0f*(x - 0.5f)*aspect;
	float ry = 2.0f*(y - 0.5f);
	float h = 3.0f*float.sqrt(x*x*x)*(1.0f-x);
	float e = Math.abs(ry) - h;
	float f = smoothstep( e, 0.0f, 0.01f);
	vec4f cOjo = interior(x, y, 0);
	vec4f cPiel = vec4f(float(0));//skin(x, y);
	result = lerp(f, cOjo, cPiel);
}

setup(&time, eye);
//~ setup(&time, blob2d);
//~ setup(&time, yinyang);

//~ setup(&time, Perlin.Noise2f);
//~ Gui.exitLoop();
