// Procedural drawing demos.
enum Window {
	draw = RenderMode.swap_buff;
	resx = 512;
	resy = 512;
	//~ resx = 512*2;
	//~ resy = 512*2;
}

void zoomSurf2(gxSurf dst, gxRect &rect, gxSurf src, gxRect &roi, int mode) {
	gxRect srec = gxRect(0, 0, width(src), height(src));
	gxRect drec = gxRect(0, 0, width(dst), height(dst));

	if (roi != null) {
		if (roi.x > 0) {
			srec.w -= roi.x;
			srec.x = roi.x;
		}
		if (roi.y > 0) {
			srec.h -= roi.y;
			srec.y = roi.y;
		}
		if (roi.w < srec.w)
			srec.w = roi.w;
		if (roi.h < srec.h)
			srec.h = roi.h;
	}

	if (rect != null) {
		drec = rect;
	}

	if (drec.w <= 0 || drec.h <= 0)
		return;

	if (srec.w <= 0 || srec.h <= 0)
		return;

	double x0 = 0;
	double y0 = 0;
	double dx = double(srec.w - 0) / (drec.w - 0);
	double dy = double(srec.h - 0) / (drec.h - 0);
	if (drec.x < 0) {
		x0 = -drec.x;
	}

	if (drec.y < 0) {
		y0 = -drec.y;
	}

	if (clipRect(dst, &drec)) {

		//~ if (dx & 0xfffe0000 || dy & 0xfffe0000) {	// if downsampling use nearest neigbor
		//~ if (abs(dx) > 1 || abs(dy) > 1) {	// downsampling
			//~ mode = 0;
		//~ }

		x0 = x0 * dx + srec.x;
		y0 = y0 * dy + srec.y;

		double sy = y0;
		for (int y = 0; y < drec.h; y += 1) {
			double sx = x0;
			for (int x = 0; x < drec.w; x += 1) {
				//~ setPixel(dst, drec.x + x, drec.y + y, getPixel(src, int(sx), int(sy)));
				setPixel(dst, drec.x + x, drec.y + y, getPixel(src, sx, sy));
				sx += dx;
			}
			sy += dy;
		}
	}
}

define atan2f(float x, float y) = atan2(x, y);
define sqrtf(float x) = sqrt(x);
define sinf(float x) = sin(x);
define fabsf(float x) = Math.abs(x);
define cosf(float x) = cos(x);
define pi = Math.pi;

void setup(double &time, vec4f pixelCB(double x, double y)) {
	define WIDTH = 256/3;
	define HEIGHT = WIDTH;
	static gxSurf tmpImg = gxSurf(WIDTH, HEIGHT);

	static bool snapshot = false;
	static bool animate = true;

	struct Internals {
		double &time;
		vec4f pixelCB(double x, double y);
	}

	static Internals internals;

	static int32 begTime = clock();

	// for each frame
	void drawCB() {
		if (snapshot) {
			animate = false;
			snapshot = false;
			int64 start = millis();
			evalSurf(offScreen, null, internals.pixelCB);
			float64 time = (millis() - start) / 1000.;
			debug("evaluation time in seconds", variant(&time));
			//~ bmpWrite(offScreen, "out-2.bmp");
		}
		if (animate) {
			// application time spent in processor
			internals.time = .5 * clocks2Sec(clock() - begTime);

			//~ evalSurf(offScreen, null, internals.pixelCB);
			zoomSurf(offScreen, null, evalSurf(tmpImg, null, internals.pixelCB), null, 1);

			// post a redraw for animation
			Gui.Repaint();
		}
	}
	void mouseCB(int btn, int x, int y) {
		static int omb = 0;
		if (omb == 1 && btn == 0) { // onRelase(btn:1)
			snapshot = true;
		}
		if (btn == 2) {
			animate = true;
			Perlin.init();
		}
		omb = btn;
	}

	internals = Internals(time, pixelCB);
	Gui.setDrawCallback(drawCB);
	Gui.setMouseHandler(mouseCB);
}

double aspect = 1.33;
double time;

vec4f blob2d(double x, double y) {

	vec2d p = vec2d(2 * x - 1, 2 * y - 1);

	//~ the centre point for each blob
	vec2d move1 = vec2d(cos(time * 4.5) * 0.4, sin(time * 1.5) * 0.4);
	vec2d move2 = vec2d(cos(time * 2.0) * 0.4, sin(time * 3.0) * 0.4);
	//~ vec2d move3 = vec2d(cos(time * 7.0) * 0.4, sin(time * 2.0) * 0.4);
	//~ vec2d move4 = vec2d(cos(time * 2.0) * 0.4, sin(time * 4.3) * 0.4);

	//~ radius for each blob
	double r1 = dot(sub(p, move1), sub(p, move1)) * 8;
	double r2 = dot(sub(p, move2), sub(p, move2)) * 16;
	//~ double r3 = dot(sub(p, move3), sub(p, move3)) * 32;
	//~ double r4 = dot(sub(p, move4), sub(p, move4)) * 64;

	//~ sum the meatballs
	double metaball = (1.0 / Math.max(r1, 1.)) + (1.0 / Math.max(r2, 1.));
	//~ metaball += 1.0 / max(r3, 1.);
	//~ metaball += 1.0 / max(r4, 1.);

	//~ alter the cut-off power
	//~ set the output color
	result = vec4f(float32(Math.clamp(pow(metaball, 8.0), 0., 1.)));
}

vec4f yinyang(double x, double y) {
	float64 nx = -1 + 2 * x;
	float64 ny = -1 + 2 * y;
	x = (nx*cos(time) - ny*sin(time));
	y = (nx*sin(time) + ny*cos(time));
	float64 h = x*x + y*y;
	if (h < 1.) {
		float64 d = Math.abs(y) - h;
		float64 a = d - 0.23;
		float64 b = h - 1.00;
		float64 c = Math.sign(a * b * (y + x + (y - x) * Math.sign(d)));

		c = Math.lerp(Math.smooth(0.98, 1.00, h), c, 0.0);
		c = Math.lerp(Math.smooth(1.00, 1.02, h), c, 1.0);
		result = vec4f(float32(c));
	}
	else {
		result = vec4f(float32(1));
	}
}
define smoothstep(float t, float a, float b) = Math.smooth(t, a, b);

vec4f eye(double x, double y) {
	static void colscale(vec4f &x, float s) {
		x = vec4f(x.x * s, x.y * s, x.z * s);
	}

	static vec4f interior(float x, float y, float b) {
		// ezt nem tudom mire jo
		define noise2f(float32 x, float32 y, int xx, int yy) = Perlin.Noise(x, y);

		x -= 0.10f; y += 0.05f;
		float rx = 2.0f*(x-0.5f)*aspect;
		float ry = 2.0f*(y-0.5f);
		float a = atan2f(ry, rx);
		float e = rx*rx + ry*ry;
		float r = sqrtf(e);

		vec4f fue = vec4f(1.0f, 1.0f, 1.0f);
		// blood
		float ven = noise2f(24.0f*x, 24.0f*y, 256, 256);
		ven = smoothstep(ven,-.2f,.0f)-smoothstep(ven,.0f,.2f);
		ven += x + x*x*x*x*x*x*7.0f;
		fue.x = fue.x + 0.04f - 0.00f*ven;
		fue.y = fue.y + 0.04f - 0.05f*ven;
		fue.z = fue.z + 0.04f - 0.05f*ven;

		vec4f den = vec4f(0.3f, 0.7f, 0.4f+e);
		float no = 0.8f+0.2f*noise2f(4.0f*r, 32.0f*a/pi,32,32);
		colscale(&den, no);

		float f2 = smoothstep(e, 0.025f, 0.035f);
		colscale(&den, f2);

		// blend in/out
		result = lerp(smoothstep(e, 0.35f, 0.36f), den, fue);

		// ring
		float ri=smoothstep(e,.31f,.35f)-smoothstep(e,.35f,.39f);
		ri = 1.0f-0.35f*ri;
		colscale(&result, ri);

		// reflecion
		float r3 = sqrtf(r*r*r);
		float re = noise2f(2.0f+4.0f*r3*cosf(a), 4.0f*r3*sinf(a), 256, 256);
		re = 0.8f*smoothstep(re, 0.1f, 0.5f);
		result.x += re*(1.0f-result.x);
		result.y += re*(1.0f-result.y);
		result.z += re*(1.0f-result.z);

		// shadow
		colscale(&result, 0.85f+0.15f*smoothstep(-b, 0.0f, 0.2f) );

	}

	//~ float rx = 2.0f*(x - 0.5f)*aspect;
	float ry = 2.0f*(y - 0.5f);
	float h = 3.0f*sqrtf(x*x*x)*(1.0f-x);
	float e = fabsf(ry) - h;
	float f = smoothstep( e, 0.0f, 0.01f);
	vec4f cOjo = interior(x, y, 0);
	vec4f cPiel = vec4f(float32(0));//skin(x, y);
	result = lerp(f, cOjo, cPiel);
}

vec4f tunnel0(double x, double y) {

	static int rgbscale(int col, double s) {
		define fixp = 16;
		int scale = s * (1 << fixp);
		int r = Math.clamp(rch(col) * scale >> fixp, 0, 255);
		int g = Math.clamp(gch(col) * scale >> fixp, 0, 255);
		int b = Math.clamp(bch(col) * scale >> fixp, 0, 255);
		result = int(rgb(r, g, b));
	}

	static double imgcoord(double val, int resolution) {
		result = val * resolution;
		if ((result %= resolution) < 0) {
			result += resolution;
		}
	}

	static define tex2d(gxSurf src, double x, double y) = getPixel(src, imgcoord(x, width(src)), imgcoord(y, height(src)));
	static define tex2d(gxSurf src, double u, double v, double w) = rgbscale(tex2d(src, u, v), w);
	//~ static define tex2d(gxSurf src, double u, double v, double w) = tex2d(src, u, v);

	static define nz(double x) = Math.nz(x, 1e-200);

	const static gxSurf srcImg = gxSurf("media/images/download.jpg");

	x = 1. - x * 2;
	y = 1. - y * 2;

	double a = atan2(y, x);
	double r = Math.hypot(x, y);

	double u = .2 * time + .1 / nz(r);
	double v = a / pi;

	result = rgb2vec4f(tex2d(srcImg, u, v, 2 * r));
}

setup(&time, tunnel0);
//~ setup(&time, yinyang);
//~ setup(&time, Perlin.Noise2f);
//~ Gui.exitLoop();
