enum Window {
	draw = RenderMode.swap_buff;
	resx = 512;
	resy = 512;
}

struct point {
	int x;
	int y;
}

void sort(point points[], bool sort_by_y) {
	for(int i = 0; i < points.length - 1; i += 1) {
		for(int j = i + 1; j < points.length; j += 1) {
			if (sort_by_y) {
				if (points[i].y < points[j].y) {
					point tmp = points[i];
					points[i] = points[j];
					points[j] = tmp;
				}
			}
			else {
				if (points[i].x < points[j].x) {
					point tmp = points[i];
					points[i] = points[j];
					points[j] = tmp;
				}
			}
		}
	}
}

int mbtn = 0;
int clicks = 0;
point points[4];

void mouseCB(int btn, int x, int y) {
	if (Mouse.dblClick(btn, x, y)) {
		clicks = 0;
		mbtn = 0;
		return;
	}
	if (btn == 0 && mbtn == 1 && clicks < points.length) {
		points[clicks] = point(x, y);
		clicks += 1;
	}
	mbtn = btn;
}

void drawCB() {
	define drawLine(gxSurf dst, point ^p1, point ^p2, int color) = drawLine(offScreen, p1.x, p1.y, p2.x, p2.y, color);
	define drawOval(gxSurf dst, point ^p, int s, int color) = drawOval(offScreen, p.x - s / 2, p.y - s / 2, p.x + s / 2, p.y + s / 2, color);

	enum {
		background = 0xffffff;
		linecolor  = 0x000000;
		rectcolor  = 0xff0000;
	}

	static bool redraw = true;
	if (redraw) {
		fillRect(offScreen, 0, 0, Window.resx, Window.resy, background);
		for (int i = 0; i < clicks; i += 1) {
			drawLine(offScreen, points[i % clicks], points[(i+1) % clicks], linecolor);
			drawOval(offScreen, points[i % clicks], 5, linecolor);
		}

		if (clicks == points.length) {
			point min;
			point max;
			sort(points, false);
			min.x = points[1].x;
			max.x = points[points.length - 2].x;

			sort(points, true);
			min.y = points[1].y;
			max.y = points[points.length - 2].y;
			drawRect(offScreen, min.x, min.y, max.x, max.y, rectcolor);

			redraw = false;
		}
	}
	if (clicks < points.length) {
		redraw = true;
	}
}

Gui.setMouseHandler(mouseCB);
Gui.setDrawCallback(drawCB);
