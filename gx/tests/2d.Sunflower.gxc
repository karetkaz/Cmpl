// Brightness, contrast, gamma demo.
enum Window {
	draw = RenderMode.swap_buff;
	resx = 512;
	resy = resx;
}

int values[2] = {1};

bool reDraw = true;

void mouseCB(int btn, int x, int y) {
	static int ox;
	static int oy;
	if (Mouse.dblClick(btn, x, y)) {
		Mouse.dblClick(-1, 0, 0);			// disable multi clicks
		reDraw = true;
		for (int i = 0; i < values.length; i += 1) {
			values[i] = 0;
		}
	}
	if (btn < values.length) {
		values[btn] += oy - y;
		reDraw = true;
	}
	ox = x;
	oy = y;
}

void drawCB() {

	static const double PHI = (float64.sqrt(5) + 1) / 2;
	static const double TAU = Math.pi * 2;
	static const int SEED_COLOR = 0xff9900;
	static const int SEED_RADIUS = 6;
	static const int SCALE_FACTOR = SEED_RADIUS - SEED_RADIUS / 4;
	static const int centerX = Window.resx / 2;
	static const int centerY = Window.resy / 2;

	if (reDraw) {
		int seeds = 1 * values[1];
		fillRect(offScreen, 0, 0, Window.resx, Window.resy, 0);
		static void drawSeed(double x, double y) {
			fillOval(offScreen, x-SEED_RADIUS, y-SEED_RADIUS, x+SEED_RADIUS, y+SEED_RADIUS, SEED_COLOR);
		}
		for (int i = 0; i < seeds; i+=1) {
			double theta = i * TAU / PHI;
			double r = float64.sqrt(i) * SCALE_FACTOR;
			double x = centerX + r * float64.cos(theta);
			double y = centerY - r * float64.sin(theta);
			fillOval(offScreen, x, y, x+SEED_RADIUS, y+SEED_RADIUS, SEED_COLOR);
		}
		//~ int centerX = Window.resx / 2 - seeds / 2;
		//~ int centerY = Window.resy / 2 - seeds / 2;
		//~ fillOval(offScreen, centerX, centerX, centerX + seeds, centerY + seeds, SEED_COLOR);

		static if (true) {
			int y = 0;
			define dy = 12;
			uint8 txt[1024];

			format(txt, "seeds: %d", seeds);
			drawText(offScreen, 0, y, string(txt), -1);
			y += dy;

			format(txt, "seed radius: %d", SEED_RADIUS);
			drawText(offScreen, 0, y, string(txt), -1);
			y += dy;
		}
		reDraw = false;
	}
}

Gui.setMouseHandler(mouseCB);
Gui.setDrawCallback(drawCB);
