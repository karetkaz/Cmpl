// complex plane domain coloring demo.
enum Window {
	draw = RenderMode.swap_buff;
	resx = 512;
	resy = 512;
}

define PI = Math.pi;

define toCartesian(Complex ^x) = Complex(x.re * cos(x.im), x.re * sin(x.im));
define toPolar(Complex ^x) = Complex(abs(x), arg(x));

define AbsMod(const double ^val, double ^mod) = ((val < 0 ? val + mod : val) % mod);

vec4f Domain(Complex z, double mod) {
	result.x = AbsMod(arg(z)/(PI*2) + PI/4, mod);
	result.y = (AbsMod(abs(z), 1) * (1 - AbsMod(abs(z), 1))) * 4;
	result.z = 1;//AbsMod(Math.abs(im(z)), 1);
	return Hsv2Rgb(result);
}

vec4f rgbOp(double x, double y) {
	define N = PI / 1;
	x = Math.lerp(x, -N, N);
	y = Math.lerp(y, -N, N);

	Complex z = Complex(x, y);
	//~ z = toCartesian(pow(toPolar(sin(z)), -2));

	//~ z = sin(toPolar(z));
	//~ z = sin(sin(toPolar(z)));
	//~ z = toCartesian(sin(toPolar(z)));
	//~ z = sin(toCartesian(sin(toPolar(z))));
	//~ z = sin(toCartesian(sin(toCartesian(sin(z)))));
	//~ z = sin(sin(sin(toCartesian(z))));

	//~ z = pow(z, Complex(1.4));

	z = sin(z);
	//~ z = add(z, div(pow(z, 4), sub(sin(pow(z, 3)), 1)));
	return Domain(z, 1);
}

evalSurf(offScreen, null, rgbOp);
