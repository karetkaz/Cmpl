enum Window {
	draw = RenderMode.swap_buff;
	resx = 512;
	resy = 512;
}

define PI = Math.pi;

define toCartesian(Complex ^x) = Complex(x.re * cos(x.im), x.re * sin(x.im));
define toPolar(Complex ^x) = Complex(hypot(x.re, x.im), atan2(x.im, x.re));
//~ define toPolar(Complex ^x) = Complex(abs(x), arg(x));

define AbsMod(const double ^val, double mod) = ((val < 0 ? val+mod : val) % mod);

vec4f Domain(Complex z, double mod) {
	result.x = AbsMod(arg(z)/(PI*2) + PI/4, mod);
	//~ result.y = AbsMod(abs(z)*(PI/2), mod);
	result.y = (AbsMod(abs(z), 1) * (1-AbsMod(abs(z), 1))) * 4;
	result.z = 1;//AbsMod(abs(im(z)), 1);
	result = Hsv2Rgb(result);
}
//~ define Domain(Complex ^z, double ^mod) = Hsv2Rgb(vec4f(AbsMod(im(z)/(PI/1), mod), 1, 1.));
//~ define Domain(Complex ^z, double ^mod) = Hsv2Rgb(vec4f(AbsMod(abs(z), mod), AbsMod(arg(z), mod), 1.));

vec4f rgbOp(double x, double y) {
	define N = PI / 1;
	x = lerp(x, -N, N);
	y = lerp(y, -N, N);
	//~ x = lerp(x, -PI, 2*PI);
	//~ y = lerp(y, -1.5*PI, 1.5*PI);
	Complex z = Complex(x, y);
	//~ z = div(Complex(1), z);
	z = sin(z);
	//~ z = pow(z, Complex(4.));
	//~ z = sin(pow(z, Complex(4., 0)));

	//~ z = add(z, div(pow(z, Complex(4)), sub(sin(pow(z, Complex(4, 0))), 1)));
	//~ z = toPolar(z);
	//~ result = Domain(z, 1);
	//~ result = vec4f(AbsMod(abs(im(z)), 1));
	result = Hsv2Rgb(vec4f(abs(abs(z)) % 1, 1, 1));
}

evalSurf(offScreen, null, rgbOp);
