// Oil paint effect demo.
enum Window {
	draw = RenderMode.swap_buff;
	//~ resx = 512;
	//~ resy = resx;
	resx = 1022;
	resy = 760;
}

//~ string fileName = "media/images/David.png";
string fileName = "media/images/forest.jpg";
//~ string fileName = "media/images/lenaRGB.png";
//~ string fileName = "media/images/download.jpg";
//~ string fileName = "/media/Data/Pictures/Canon/2006/2006_04_17 - Banya/IMG_0086.JPG";
//~ string fileName = "media/images/dino-blue.jpg";
//~ string fileName = "media/images/Earth.jpg";
//~ string fileName = "media/images/nol.bmp";

define resize(gxSurf src, int width, int height) = zoomSurf(gxSurf(width, height), null, src, null, 1);

gxSurf image = resize(gxSurf(fileName), 320, 240);

define radius = 3;
define intensityLevels = 24;

static if (!true) {
	const int w = width(image);
	const int h = height(image);
	gxSurf dest = gxSurf(w, h);

	int intensity_count[intensityLevels];
	int sumR[intensityLevels];
	int sumG[intensityLevels];
	int sumB[intensityLevels];

	for(int col = radius; col < (h - radius); col += 1) {
		debug("processing line", variant(&col));
		for(int row = radius; row < (w - radius); row += 1) {
			memset(pointer(&intensity_count), 0, intensity_count.length * sizeof(int));
			memset(pointer(&sumR), 0, sumR.length * sizeof(int));
			memset(pointer(&sumG), 0, sumG.length * sizeof(int));
			memset(pointer(&sumB), 0, sumB.length * sizeof(int));

			/* Calculate the highest intensity Neighbouring Pixels. */
			for(int y = col - radius; y < col + radius; y += 1) {
				for(int x = row - radius; x < row + radius; x += 1) {

					int rgb = getPixel(image, x, y);
					int r = rch(rgb);
					int g = gch(rgb);
					int b = bch(rgb);
					int current_intensity = ((r + g + b) * intensityLevels / 3) / 255;
					intensity_count[current_intensity] += 1;
					sumR[current_intensity] += r;
					sumG[current_intensity] += g;
					sumB[current_intensity] += b;
				}
			}

			/* The highest intensity neighbouring pixels are averaged out to get the exact color. */
			int maxIndex = 0;
			int curMax = intensity_count[0];
			for (int i = 1; i < intensityLevels; i += 1) {
				if (curMax < intensity_count[i]) {
					curMax = intensity_count[i];
					maxIndex = i;
				}
			}

			if (curMax > 0) {
				int rgb = int(rgbClamp(sumR[maxIndex] / curMax, sumG[maxIndex] / curMax, sumB[maxIndex] / curMax));
				setPixel(dest, row, col, rgb);
			}
		}
	}
	copySurf(image, 0, 0, dest, null);
	delSurf(dest);
}
static if (true) {
	const int w = width(image);
	const int h = height(image);
	gxSurf dest = gxSurf(w, h);

	bool inRange(int cx, int cy, int i, int j) {
		static int sqrt(int a) {
			int rem = 0;
			int root = 0;
			for (int i = 0; i < 16; i += 1) {
				root <<= 1;
				rem <<= 2;
				rem += a >> 30;
				a <<= 2;
				if (root < rem) {
					root += 1;
					rem -= root;
					root += 1;
				}
			}
			return root >> 1;
		}
		static int32 sqrt2(int32 x) {
			int32 testDiv;
			int32 root = 0;			// Clear root
			int32 remHi = 0;		// Clear high part of partial remainder
			int32 remLo = x;		// Get argument into low part of partial remainder
			int32 count = 16;		// Load loop counter

			for (; count; count -= 1) {
				remHi = (remHi << 2) | (remLo >> 30);		// get 2 bits of arg
				remLo <<= 2;
				root <<= 1;							// Get ready for the next bit in the root
				testDiv = (root << 1) + 1;			// Test radical
				if (remHi >= testDiv) {
					remHi -= testDiv;
					root += 1;
				}
			}
			return root;
		}
		cx -= i;
		cy -= j;
		double d = double.sqrt(cx * cx + cy * cy);
		return d < radius;
		//~ return sqrt(cx * cx + cy * cy) < radius;
	}
	int averageR[intensityLevels];
	int averageG[intensityLevels];
	int averageB[intensityLevels];
	int intensityCount[intensityLevels];

	for (int y = 0; y < h; y += 1) {
		int top = Math.max(0, y - radius);
		int bottom = Math.min(y + radius, h - 1);

		//~ debug("processing line", variant(&y));

		for (int x = 0; x < w; x += 1) {
			int left = Math.max(0, x - radius);
			int right = Math.min(x + radius, w - 1);

			for (int i = 0; i < intensityLevels; i += 1) {
				averageR[i] = 0;
				averageG[i] = 0;
				averageB[i] = 0;
				intensityCount[i] = 0;
			}

			for (int j = top; j <= bottom; j += 1) {
				for (int i = left; i <= right; i += 1) {
					//~ if (!inRange(x, y, i, j))
						//~ continue;

					int rgb = getPixel(image, i, j);

					int r = rch(rgb);
					int g = gch(rgb);
					int b = bch(rgb);
					int intensityIndex = (r + g + b) * intensityLevels / 765;

					intensityCount[intensityIndex] += 1;
					averageR[intensityIndex] += r;
					averageG[intensityIndex] += g;
					averageB[intensityIndex] += b;

				}
			}

			int maxIndex = 0;
			int curMax = intensityCount[maxIndex];
			for (int i = 1; i < intensityLevels; i += 1) {
				if (curMax < intensityCount[i]) {
					curMax = intensityCount[i];
					maxIndex = i;
				}
			}

			if (curMax > 0) {
				//~ int rgb = int(rgbClamp(sumR[maxIndex] / curMax, sumG[maxIndex] / curMax, sumB[maxIndex] / curMax));
				//~ setPixel(dest, row, col, rgb);
				int r = averageR[maxIndex] / curMax;
				int g = averageG[maxIndex] / curMax;
				int b = averageB[maxIndex] / curMax;

				setPixel(dest, x, y, __rgb(r, g, b));
			}
		}
	}
	copySurf(image, 0, 0, dest, null);
	delSurf(dest);
}

//~ oilPaintSurf(image, null, radius, intensityLevels);
//~ fillSurf(image, null, effectFp);
setupPicView(image, true);
