// biorithm calculator
enum Window {
	draw = RenderMode.swap_buff;
	resx = 800;
	resy = 560;
	padding = 5;
	lineHeight = 20;
}

struct Biorithm {
	int color;
	int period;
	int period2;
	string label;
}

const Biorithm biorithms[] = {
	Biorithm(0x5050ff, 23,  0, "Physical - Fizikai %d%%"),
	Biorithm(0xff0000, 28,  0, "Emotional - Erzelmi %d%%"),
	Biorithm(0x00ff00, 33,  0, "Intellectual - Szellemi %d%%"),
	Biorithm(0xdadada, 38,  0, "Intuitive - Megerzes %d%%"),
	Biorithm(0x6f6f6f, 23, 33, "Mastery - Iranyitas %d%%"),
	Biorithm(0xfeab00, 23, 28, "Passion - Szenvedely %d%%"),
	Biorithm(0x9466db, 28, 33, "Wisdom - Bolcsesseg %d%%"),
};

void drawBiorithm(gxSurf dst, int daysToShow, double now, Date birth, Biorithm biorithms[]) {

	static void drawGraph(gxSurf dst, Biorithm &br, int daysToShow, double now, Date birth, int labelposY) {
		double lx;
		double ly;
		double days = now - birth.days;
		double precent = 0;

		define precision = 3;
		if (br.period2) {
			double p1 = br.period;
			double p2 = br.period2;
			for (int i = 0; i <= 2. * precision * daysToShow; i += 1) {
				double t = days + (double(i) / precision) - daysToShow;
				double x = Window.resx * (i / (2. * precision * daysToShow));
				double y1 = Window.resy * (1 - float64.sin(t % p1 / p1 * 2 * Math.pi)) / 2;
				double y2 = Window.resy * (1 - float64.sin(t % p2 / p2 * 2 * Math.pi)) / 2;
				double y = (y1 + y2) / 2;

				if (i > 0) {
					drawLine(dst, lx, ly, x, y, br.color);
					if (i == precision * daysToShow) {
						precent = 100 - y * 200. / Window.resy;
					}
				}
				lx = x;
				ly = y;
			}
		}
		else {
			double p1 = br.period;
			for (int i = 0; i <= 2. * precision * daysToShow; i += 1) {
				double t = days + (double(i) / precision) - daysToShow;
				double x = Window.resx * (i / (2. * precision * daysToShow));
				double y = Window.resy * (1 - float64.sin(2 * Math.pi * t / p1)) / 2;
				if (i > 0) {
					drawLine(dst, lx, ly, x, y, br.color);
					if (i == precision * daysToShow) {
						precent = 100 - y * 200. / Window.resy;
					}
				}
				lx = x;
				ly = y;
			}
		}
		if (labelposY >= 0) {
			char text[256] = [0];
			format(text, br.label, precent);
			drawText(dst, Window.padding, labelposY, string(text), br.color);
		}
	}

	int textPosition = Window.resy - Window.padding - Window.lineHeight * (biorithms.length + 1);

	// clear screen
	fillRect(dst, 0, 0, 32768, 32768, 0x000000);

	// day grid lines
	for (int i = 1; i <= 2 * daysToShow; i += 1) {
		double time = Window.resx * (i / (2. * daysToShow)) - (now % 1 * (double(Window.resx) / daysToShow / 2));
		drawLine(dst, time, 0, time, Window.resy, 0x282828);
	}

	// draw graphs & labels
	for (int i = 0; i < biorithms.length; i += 1) {
		if (biorithms[i].color == 0)
			continue;
		textPosition += Window.lineHeight;
		drawGraph(dst, biorithms[i], daysToShow, now, birth, textPosition);
	}

	// coordinate
	drawLine(dst, 0, Window.resy / 2, Window.resx, Window.resy / 2, 0x989898);
	drawLine(dst, Window.resx / 2, 0, Window.resx / 2, Window.resy, 0x989898);

	char text[128];
	format(text, "Date: %Y.%m.%d", Date(int64(now)));
	drawText(dst, Window.padding, Window.padding, string(text), -1);

	format(text, "Birth: %Y.%m.%d", birth);
	drawText(dst, Window.padding, Window.padding + Window.lineHeight, string(text), -1);
}

void setupBiorithm(int _daysToShow, Date _now, Date _birth) {
	static int64 pos;
	static Date now;
	static Date birth;
	static int daysToShow;
	static bool reDraw = true;

	define inertial_pan = 30.;
	define inertial_speed = 1.01;
	static int64 inertial_time = 0;
	static double inertial_pan_x = 0;

	static void onDrawScreen() {
		if (reDraw) {
			double nowPos = now.days + double(pos * daysToShow) / (Window.resx / 2);
			drawBiorithm(offScreen, daysToShow, nowPos, birth, biorithms);
			reDraw = false;
		}
		static if (inertial_pan > 0) {
			int64 now = System.millis();
			if (inertial_time < now) {
				inertial_pan_x = Math.clamp(inertial_pan_x, -inertial_pan, inertial_pan) / inertial_speed;

				if (Math.abs(inertial_pan_x) > 0) {
					pos += inertial_pan_x / 4.;
					reDraw = true;
				}
				inertial_time = now;
			}
			if (Math.abs(inertial_pan_x) > .05) {
				//~ debug("Gui.Repaint", variant(&inertial_time));
				Gui.Repaint();
			}
		}
	}

	static void onMouseAction(int btn, int x, int y) {
		static int ox = 0;
		static int oy = 0;
		static int ob = 0;

		if (Mouse.dblClick(btn, x, y)) {
			Mouse.dblClick(-1, 0, 0);		// prevent multi clicks
			reDraw = true;
			pos = 0;
		}

		if (btn == 1) {
			pos += ox - x;
			reDraw = true;
		}
		static if (inertial_pan) {
			static int64 ot = 0;
			static int32 oox = 0;
			static int32 ooy = 0;
			if (btn == 1 && ob == 0) {	// on press
				ot = System.millis();
				inertial_pan_x = 0;
				oox = x;
				ooy = y;
			}
			if (btn == 0 && ob == 1) {	// on relase
				int64 now = System.millis();
				if (now - ot < 500) {
					inertial_time = 0;
					inertial_pan_x = oox - x;
					oox = x;
					ooy = y;
				}
			}
		}

		ox = x;
		oy = y;
		ob = btn;
	}

	static void onKey(int32 btn, int32 ext) {
		if (btn == 27) {
			Gui.exitLoop();
		}
		if (btn == '[') {
			pos -= Window.resx / 2;
			reDraw = true;
		}
		if (btn == ']') {
			pos += Window.resx / 2;
			reDraw = true;
		}
	}
	// set callbacks and initialize static variables
	Gui.setDrawCallback(onDrawScreen);
	Gui.setMouseHandler(onMouseAction);
	Gui.setKeyboardHandler(onKey);
	daysToShow = _daysToShow;
	birth = _birth;
	now = _now;
	pos = 0;
}

define daysToShow = 15;
Date Now = DateFromTime(System.time());

//~ setupBiorithm(daysToShow, Now, Date(1984, 8, 30));
setupBiorithm(daysToShow, Now, Date(1983, 5,  2));
//~ setupBiorithm(daysToShow, Now, Date(1991, 11, 10));
