// Image dithering demo.
enum Window {
	draw = RenderMode.swap_buff;
	resx = 512 * 1;
	resy = resx;
}

//~ string fileName = "media/images/David.png";
//~ string fileName = "media/images/lenaRGB.png";
string fileName = "media/images/download.jpg";
//~ string fileName = "media/images/dino-blue.jpg";
//~ string fileName = "media/images/Earth.jpg";
//~ string fileName = "media/images/nol.bmp";

enum Dithering: int32 {
	Threshold = '0';
	Bayer = 'B';
	SteinbergFalse = '2';
	Steinberg = '3';
	Stucki = '5';
}
gxSurf dither(gxSurf img, bool grayscale, uint32 levels, Dithering method) {

	if (levels >= 256) {
		//~ dithering = Dithering.None;
		levels = 256;
	}
	int cols[256];

	int colors = levels - 1;
	for (int i = 0; i < cols.length; i += 1) {
		cols[i] = (i * (colors+1) / cols.length) * (cols.length / colors);
	}

	int width = width(img);
	int height = height(img);

	define toRgb(int r, int g, int b) = int(rgbClamp(r, g, b));
	define toGray(int col) = int(grayClamp(col));

	if (method == Dithering.Threshold) {
		if (grayscale) {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int gray = cols[lum(col)];
					setPixel(img, x, y, toGray(gray));
				}
			}
		}
		else {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int colr = cols[rch(col)];
					int colg = cols[gch(col)];
					int colb = cols[bch(col)];
					setPixel(img, x, y, toRgb(colr, colg, colb));
				}
			}
		}
		result = img;
	}
	else if (method == Dithering.SteinbergFalse) {
		/** the kernel
		 * 	*   3
		 *	3   2
		 */
		if (grayscale) {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = lum(getPixel(img, x, y));
					int gray = cols[col];

					int quant_error = col - gray;
					define rgbError(int col, int s) = toGray(lum(col) + s * quant_error / 8);

					setPixel(img, x, y, toGray(gray));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 3));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 1, y + 1), 3));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 2));
				}
			}
		}
		else {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int colr = cols[rch(col)];
					int colg = cols[gch(col)];
					int colb = cols[bch(col)];

					int quant_error_r = rch(col) - colr;
					int quant_error_g = gch(col) - colg;
					int quant_error_b = bch(col) - colb;

					define rgbError(int col, int s) = toRgb(
						rch(col) + s * quant_error_r / 8,
						gch(col) + s * quant_error_g / 8,
						bch(col) + s * quant_error_b / 8
					);

					setPixel(img, x, y, toRgb(colr, colg, colb));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 3));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 3));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 2));
				}
			}
		}
		result = img;
	}
	else if (method == Dithering.Steinberg) {
		/** the kernel
		 * 		*   7
		 *	3   5   1
		 */
		if (grayscale) {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {

					int col = lum(getPixel(img, x, y));
					int gray = cols[col];

					int quant_error = col - gray;
					define rgbError(int col, int s) = toGray(lum(col) + s * quant_error / 16);

					setPixel(img, x, y, toGray(gray));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 7));
					setPixel(img, x - 1, y + 1, rgbError(getPixel(img, x - 1, y + 1), 3));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 5));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 1));

					/*if (x + 1 < width) {
						setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 7));
					}
					if (y + 1 < height) {
						if (x - 1 > 0) {
							setPixel(img, x - 1, y + 1, rgbError(getPixel(img, x - 1, y + 1), 3));
						}
						setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 5));
						if (x + 1 < width) {
							setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 1));
						}
					}*/
				}
			}
		}
		else {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int colr = cols[rch(col)];
					int colg = cols[gch(col)];
					int colb = cols[bch(col)];

					int quant_error_r = rch(col) - colr;
					int quant_error_g = gch(col) - colg;
					int quant_error_b = bch(col) - colb;

					define rgbError(int col, int s) = toRgb(
						rch(col) + s * quant_error_r / 16,
						gch(col) + s * quant_error_g / 16,
						bch(col) + s * quant_error_b / 16
					);

					setPixel(img, x, y, toRgb(colr, colg, colb));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 7));
					setPixel(img, x - 1, y + 1, rgbError(getPixel(img, x - 1, y + 1), 3));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 5));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 1));
				}
			}
		}
		result = img;
	}
	else if (method == Dithering.Stucki) {
		/** the kernel
		 * 			*   8   4
		 *	2   4   8   4   2
		 *	1   2   4   2   1
		 */
		if (grayscale) {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = lum(getPixel(img, x, y));
					int gray = cols[col];

					int quant_error = col - gray;
					define rgbError(int col, int s) = toGray(lum(col) + s * quant_error / 42);

					setPixel(img, x, y, toGray(gray));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 8));
					setPixel(img, x + 2, y + 0, rgbError(getPixel(img, x + 2, y + 0), 4));
					setPixel(img, x - 2, y + 1, rgbError(getPixel(img, x - 2, y + 1), 2));
					setPixel(img, x - 1, y + 1, rgbError(getPixel(img, x - 1, y + 1), 4));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 8));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 4));
					setPixel(img, x + 2, y + 1, rgbError(getPixel(img, x + 2, y + 1), 2));
					setPixel(img, x - 2, y + 2, rgbError(getPixel(img, x - 2, y + 2), 1));
					setPixel(img, x - 1, y + 2, rgbError(getPixel(img, x - 1, y + 2), 2));
					setPixel(img, x + 0, y + 2, rgbError(getPixel(img, x + 0, y + 2), 4));
					setPixel(img, x + 1, y + 2, rgbError(getPixel(img, x + 1, y + 2), 2));
					setPixel(img, x + 2, y + 2, rgbError(getPixel(img, x + 2, y + 2), 1));
				}
			}
		}
		else {
			for(int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int colr = cols[rch(col)];
					int colg = cols[gch(col)];
					int colb = cols[bch(col)];

					int quant_error_r = rch(col) - colr;
					int quant_error_g = gch(col) - colg;
					int quant_error_b = bch(col) - colb;

					define rgbError(int col, int s) = toRgb(
						rch(col) + s * quant_error_r / 42,
						gch(col) + s * quant_error_g / 42,
						bch(col) + s * quant_error_b / 42
					);

					setPixel(img, x, y, toRgb(colr, colg, colb));
					setPixel(img, x + 1, y + 0, rgbError(getPixel(img, x + 1, y + 0), 8));
					setPixel(img, x + 2, y + 0, rgbError(getPixel(img, x + 2, y + 0), 4));
					setPixel(img, x - 2, y + 1, rgbError(getPixel(img, x - 2, y + 1), 2));
					setPixel(img, x - 1, y + 1, rgbError(getPixel(img, x - 1, y + 1), 4));
					setPixel(img, x + 0, y + 1, rgbError(getPixel(img, x + 0, y + 1), 8));
					setPixel(img, x + 1, y + 1, rgbError(getPixel(img, x + 1, y + 1), 4));
					setPixel(img, x + 2, y + 1, rgbError(getPixel(img, x + 2, y + 1), 2));
					setPixel(img, x - 2, y + 2, rgbError(getPixel(img, x - 2, y + 2), 1));
					setPixel(img, x - 1, y + 2, rgbError(getPixel(img, x - 1, y + 2), 2));
					setPixel(img, x + 0, y + 2, rgbError(getPixel(img, x + 0, y + 2), 4));
					setPixel(img, x + 1, y + 2, rgbError(getPixel(img, x + 1, y + 2), 2));
					setPixel(img, x + 2, y + 2, rgbError(getPixel(img, x + 2, y + 2), 1));

				}
			}
		}
		result = img;
	}
	else if (method == Dithering.Bayer) {
		static const int8 Pattern[8][8] = [
			 0, 32,  8, 40,  2, 34, 10, 42,
			48, 16, 56, 24, 50, 18, 58, 26,
			12, 44,  4, 36, 14, 46,  6, 38,
			60, 28, 52, 20, 62, 30, 54, 22,
			 3, 35, 11, 43,  1, 33,  9, 41,
			51, 19, 59, 27, 49, 17, 57, 25,
			15, 47,  7, 39, 13, 45,  5, 37,
			63, 31, 55, 23, 61, 29, 53, 21
		];

		// TODO: simplify
		for (int i = 0; i < levels; i += 1) {
			cols[i] = i * 255 / colors;
		}

		static void bayer(int &num2, int &num3, int col, int levels) {
			define d = 64;
			int tmp = col * ((levels * d) + 1) / 256;
			num3 = tmp / d;
			num2 = tmp - num3 * d;
		}

		if (grayscale) {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = lum(getPixel(img, x, y));
					int num2;
					int num3;

					bayer(&num2, &num3, col, colors);
					int gray = cols[(num3 + (num2 > Pattern[x & 7][y & 7]))];

					setPixel(img, x, y, toGray(gray));
				}
			}
		}
		else {
			for (int y = 0; y < height; y += 1) {
				for (int x = 0; x < width; x += 1) {
					int col = getPixel(img, x, y);
					int num2;
					int num3;

					bayer(&num2, &num3, rch(col), colors);
					int colr = cols[(num3 + (num2 > Pattern[x & 7][y & 7]))];

					bayer(&num2, &num3, gch(col), colors);
					int colg = cols[(num3 + (num2 > Pattern[x & 7][y & 7]))];

					bayer(&num2, &num3, bch(col), colors);
					int colb = cols[(num3 + (num2 > Pattern[x & 7][y & 7]))];

					setPixel(img, x, y, toRgb(colr, colg, colb));
				}
			}
		}

		result = img;
	}
}

int maxcolors = 8;
int grayscale = true;
Dithering method = Dithering.Stucki;
method = Dithering.Steinberg;
method = Dithering.SteinbergFalse;
//~ method = Dithering.Bayer;
//~ method = Dithering.Threshold;

define workOnOffscreen = true;

static if(workOnOffscreen) {
vec4f makegray(float32 x, float32 y) {return vec4f(float32.sqrt(x * y));}
evalSurf(offScreen, null, makegray);

bmpWrite(offScreen, "out/image.bmp");
dither(offScreen, grayscale, maxcolors, method);
bmpWrite(offScreen, "out/dithered.bmp");

}
static if(!workOnOffscreen) {
define hex(uint32 c) = int("0123456789abcdef"[c & 0xf]);

int gs = grayscale ? 'g' : 'c';
int h1 = hex(maxcolors >> 4);
int h2 = hex(maxcolors);


gxSurf image = gxSurf(fileName);
dither(image, grayscale, maxcolors, method);

uint8 filename[34] = ['o','u','t','/','o','u','t','[',gs,'x',h1, h2,'_',emit(char, (method)),']','.','b','m','p',0];
bmpWrite(image, string(filename));
debug("Image saved", variant(string(filename)));

//~ image = tileSurf(gxSurf(4000, 4000), 0, 0, image, null);
setupPicView(image, false);
}
