// simple raytracer
define zoom = 1;
enum Window {
	draw = RenderMode.swap_buff;

	//~ draw = (RenderMode.drawFill) &(~RenderMode.cull_all);
	resx = zoom * 512;
	resy = zoom * 512;
}

struct SceneObject {
	const vec4f position;   // x, y, z, radius
	const vec4f color;      // r, g, b
	const vec4f material;   // ambient, diffuse, specular, reflectivity
}

const vec4f lightPos = vec4f(0.0, 2.0, -4.0);
const float viewPlaneDistance = 2;
const float SPECULAR_EXPONENT = 50.0;
define MAX_RAY_SHOTS = 2;

define spheres = 35;
SceneObject things[spheres] = {
	SceneObject(
		vec4f(0.0, 2.0, -10.0,   2),
		vec4f(.8, .8, .8),
		vec4f(.05, .1, 1., 1.)
	),
	SceneObject(
		vec4f(0.0, -1003, -8, 1000),
		vec4f(.6, .6, .6),
		vec4f(.10, .8, .5, .5)
	)
};

// fires a ray from origin, toward dir, returns first intersection
bool shootRay(vec4f origin, vec4f dir, vec4f &pos, float &t, int &sphereNum) {
	t = 99999.0;
	result = false;
	// cycle through all spheres and find the smallest t>0 that we hit
	for (int i = 0; i < things.length; i += 1) {
		vec4f spherePos = things[i].position;
		float sphereRadius = things[i].position.w;

		vec4f sphereToOrigin = sub(origin, spherePos);
		float B = dp3(sphereToOrigin, dir);
		float C = dp3(sphereToOrigin, sphereToOrigin) - sphereRadius * sphereRadius;

		float disc = B*B-C;
		if (disc > 0) {
			float curT = -B-float32.sqrt(disc);
			if(curT > 0 && curT < t) {
				sphereNum = i;
				t = curT;
				result = true;
			}
		}
	}

	pos = add(origin, mul(dir, t));
}

vec4f evaluatePixel(float x, float y) {
	result = vec4f(0, 0, 0);

	vec4f origin = vec4f(0, 0, 0);

	// calculate direction vector for this pixel
	vec4f dir = vec4f(2 * x - 1, -2 * y + 1, -viewPlaneDistance);

	vec4f colorScale = vec4f(1.0, 1.0, 1.0);

	for(int rayShots = MAX_RAY_SHOTS; rayShots > 0; ) {
		// let's make sure dir is properly normalized
		dir = normalize(dir);

		// INTERSECTION TEST
		// find the first sphere we intersect with

		float t;
		int sphereNum;
		vec4f hitPoint;

		bool hit = shootRay(origin, dir, &hitPoint, &t, &sphereNum);
		if (hit != 0) {
			// grab the parameters for the sphere we hit
			vec4f spherePos      = things[sphereNum].position;
			float sphereRadius   = things[sphereNum].position.w;
			vec4f sphereColor    = things[sphereNum].color;
			vec4f sphereMaterial = things[sphereNum].material;

			vec4f sphereHit = sub(hitPoint, spherePos);
			vec4f n = div(sphereHit, sphereRadius);                      // normal at the point we hit
			vec4f lightVector = sub(lightPos, hitPoint);                 // hit point to light
			float lightVectorLen = len(lightVector);
			vec4f l = div(lightVector, lightVectorLen);

			// SHADOW TEST
			// fire a ray from our hit position towards the light
			int temp2;
			vec4f temp;
			bool shadowTest = shootRay(hitPoint, l, &temp, &t, &temp2);

			if (shadowTest == 0) {                 // if we didn't hit anything, we can see the light
				shadowTest = 1;
			}
			else if (t < lightVectorLen) {         // if we hit something before the light, we are in shadow
				shadowTest = 0;
			}

			float diffuse = dp3(l, n);

			vec4f lReflect = sub(l, mul(2.0*diffuse, n));      // reflect the light vector
			float specular = dp3(dir, lReflect);

			diffuse = Math.max(diffuse, float(0));
			specular = float32.pow( Math.max(specular, float(0)), SPECULAR_EXPONENT );

			// ground checkboard texture
			if(sphereNum == 1) {
				float phi = Math.Acos( -dp3(vec4f(1.0, 0.0, 0.0), n) );
				vec4f uv = vec4f(
					Math.Acos(dp3( vec4f(0.0, 0.0, 1.0), n) /float32.sin(phi) )/(2.0*Math.pi),
					phi/Math.pi, 0, 0
				);

				define step = 2000;
				// we could do sampleLinear here to do some actual texturing. :)
				bool white = (int(step * uv.x) + int(step * uv.y)) % 2 == 0;
				sphereColor.x *= white ? 0.5 : 1.0;
				sphereColor.y *= white ? 0.5 : 1.0;
				sphereColor.z *= white ? 0.5 : 1.0;
				// TODO: main.c:1051: Segmentation fault (core dumped)
				//~ sphereColor = mul(sphereColor, float32(white ? 0.5 : 1.0));
			}

			// finally, blend our color into this pixel

			float lightVal = (sphereMaterial.x + float(shadowTest)*(diffuse*sphereMaterial.y + specular*sphereMaterial.z));
			vec4f t21 = mul(colorScale, lightVal);
			result = add(result, mul(t21, sphereColor));
			// TODO: cgen.c:1071: Segmentation fault (core dumped)
			//~ result = add(result, mul(mul(colorScale, lightVal), sphereColor));

			// reflection
			if(sphereMaterial.w > 0) {
				vec4f dirReflect = sub(dir, mul(2.0 * dp3(dir, n), n)); // reflect our view vector
				dirReflect = normalize(dirReflect);
				// originate at our hit position, fire at reflected angle
				origin = hitPoint;
				dir = dirReflect;
				rayShots -= 1;

				// blend according to reflectivity
				colorScale = mul(colorScale, mul(sphereMaterial.w, sphereColor));
			}
			else {
				rayShots = 0;
			}
		}
		else {
			rayShots = 0;
		}
	}
}

// let's make a bunch of fakely random spheres
for (int i = 2; i < things.length; i += 1) {
	define sin(float32 x) = float32.sin(x);
	define cos(float32 x) = float32.cos(x);
	define pow(float32 x, float32 y) = float32.pow(x, y);

	float fi = i*11;
	things[i].position.x = sin(fi/5.0)*6.0;
	things[i].position.y = sin(fi/4.1)*2.5;
	things[i].position.z = -18.0 - sin(fi/3.1+1.2)*10.0;
	things[i].position.w = pow(sin(fi/1.34+65.3)*0.5+0.5, 3.0)*1.0 + 0.2;

	things[i].color.x = cos(fi/2.1+1.3)*0.5+0.5;
	things[i].color.y = cos(fi/0.1+1.3)*0.5+0.5;
	things[i].color.z = cos(fi/5.1+6.3)*0.5+0.5;

	things[i].material.x = 0.1;
	things[i].material.y = 0.7;
	things[i].material.z = 1.0;
	things[i].material.w = pow(sin(fi/2.1 + 1.243)*0.5 + 0.5, 5.0);
}

evalSurf(offScreen, null, evaluatePixel);
