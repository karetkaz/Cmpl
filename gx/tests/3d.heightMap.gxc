// 3d height map demo.
enum Window {
	draw = RenderMode.drawFill|RenderMode.draw_lit;// & ~RenderMode.zero_cbuf;
	resx = 1200;
	resy = 800;
}

define pi = Math.pi;

void meshGen(gxSurf heihgtMap) {
	assert(depth(heihgtMap) == 32, "Error");
	int vtx = 0;
	int tdiv = width(heihgtMap);
	int sdiv = height(heihgtMap);

	for (int i = 0; i < tdiv; i += 1) {
		double t = i / double(tdiv - 1);
		for (int j = 0; j < sdiv; j += 1) {
			double s = j / double(sdiv - 1);
			mesh.Pos(vtx, s, t, lum(getPixel(heihgtMap, sdiv - j, tdiv - i)) / (255. * 6));
			mesh.Nrm(vtx, 0., 0., 1.);
			mesh.Tex(vtx, 1-s, 1-t);
			vtx += 1;
		}
	}
	for (int j = 0; j < tdiv - 1; j += 1) {
		int l1 = j * sdiv;
		int l2 = l1 + sdiv;
		for (int i = 0; i < sdiv - 1; i += 1) {
			int v1 = l1 + i;		// v1 -- v2
			int v2 = v1 + 1;		//  | \  |
			int v4 = l2 + i;		//  |  \ |
			int v3 = v4 + 1;		// v4 -- v3
			mesh.AddFace(v1, v2, v3, v4);
		}
	}
}

define division = 512/2;
string img = "media/images/hm.jpg";
//~ string img = "C:/Users/User/Desktop/disp.jpg";
//~ string tex = "C:/Users/User/Desktop/disp.jpg";
define resize(gxSurf src, int width, int height) = zoomSurf(gxSurf(width, height), null, src, null, 1);

meshGen(resize(gxSurf(img), division, division));
//~ mesh.Texture(gxSurf(tex));

mesh.Center(2);
mesh.Normalize(0);
//~ mesh.Normalize(1e-10);
/*
void drawCB() {
	Gui.Repaint();
}
Gui.setDrawCallback(drawCB);

static if (true) {			// use custom mouseHandler

mat4f matrix_Rotation(vec4f &dir, float ang) {
	float sin_t = sin(ang);
	float cos_t = cos(ang);
	float one_c = 1. - cos_t;
	vec4f tmp = mul(dir, sin_t);

	float xx = dir.x * dir.x;
	float yy = dir.y * dir.y;
	float zz = dir.z * dir.z;
	float xy = dir.x * dir.y;
	float xz = dir.x * dir.z;
	float yz = dir.y * dir.z;

	result.x.x = one_c * xx + cos_t;
	result.x.y = one_c * xy - tmp.z;
	result.x.z = one_c * xz + tmp.y;
	result.x.w = 0;

	result.y.x = one_c * xy + tmp.z;
	result.y.y = one_c * yy + cos_t;
	result.y.z = one_c * yz - tmp.x;
	result.y.w = 0;

	result.z.x = one_c * xz - tmp.y;
	result.z.y = one_c * yz + tmp.x;
	result.z.z = one_c * zz + cos_t;
	result.z.w = 0;

	result.w = vec4f(0., 0., 0., 1.);
}
mat4f matrix_Translation(vec4f &dir, float cnt) {
	vec4f tmp = mul(dir, vec4f(cnt));

	result.x.x = 1;
	result.x.y = 0;
	result.x.z = 0;
	result.x.w = tmp.x;

	result.y.x = 0;
	result.y.y = 1;
	result.y.z = 0;
	result.y.w = tmp.y;

	result.z.x = 0;
	result.z.y = 0;
	result.z.z = 1;
	result.z.w = tmp.z;

	result.w.x = 0;
	result.w.y = 0;
	result.w.z = 0;
	result.w.w = tmp.w;
}

void camera_Rotate(vec4f &dir, vec4f &orbit, float ang) {

	if (ang != 0) {

		mat4f tmp = matrix_Rotation(dir, ang);

		camera.Forward(normalize(dp3(tmp, camera.Forward)));
		camera.Right(normalize(dp3(tmp, camera.Right)));
		camera.Up(cross(camera.Forward, camera.Right));

		if (orbit != null) {
			define lookAtOrbit = !true;
			vec4f dir2 = sub(orbit, camera.Pos);
			float dist = sqrt(dp3(dir2, dir2));

			static if (!lookAtOrbit) {	// camera will just rotate arund orbit
				vec4f x = normalize(dph(tmp, dir2));
				tmp = matrix_Translation(&x, -dist);
			}

			static if (lookAtOrbit) {	// camera will rotate and look at orbit
				vec4f x = camera.Forward;
				tmp = matrix_Translation(&x, -dist);
			}

			camera.Pos(dph(tmp, orbit));
		}// +/
	}// * /
}
void camera_Move(vec4f &dir, float step) {
	camera.Pos(add(camera.Pos, mul(dir, step)));
}

void mouseHandler(int btn, int x, int y) {
	static int ox;
	static int oy;
	float dx = x - ox;
	float dy = y - oy;
	ox = x;
	oy = y;

	//~ define toRadians(double x) = double(x * pi / 180.);
	define moveSlow = .08;
	define rotateSlow = moveSlow * pi / 180.;
	define rotateFast = 10 * rotateSlow;

	if (Mouse.dblClick(btn, x, y)) {
		Mouse.dblClick(-1, 0, 0);
		camera.LookAt(
			vec4f(0., 0., 16.),		// eye
			vec4f(0., 0., 0.),		// target
			vec4f(0., 1., 0.)		// up
		);
	}

	if (btn == 1) {	// orbit the camera
		vec4f orbit = vec4f(0., 0., 0., 0.);
		if (dx) {
			vec4f direction = camera.Up;
			camera.Rotate(&direction, &orbit, dx * rotateFast);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera.Rotate(&direction, &orbit, dy * rotateFast);
		}
	}
	if (btn == 2) {	// rotate the camera
		// if no orbit is given, orbit will be the camera position.
		//~ static vec4f orbit = camera.Pos();
		if (dx) {
			vec4f direction = camera.Up;
			camera.Rotate(&direction, null, dx * rotateSlow);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera.Rotate(&direction, null, dy * rotateSlow);
		}
	}
	if (btn == 1+2) {	// move forward / back
		vec4f direction = camera.Forward;
		camera.Move(&direction, dy * moveSlow);
	}
}

Gui.setMouseHandler(mouseHandler);
}

mesh.Info();
//~ mesh.Save("mesh.obj");
//~ Gui.exitLoop();
*/
