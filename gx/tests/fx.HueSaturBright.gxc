// Hue saturation brightness demo.
enum Window {
	draw = RenderMode.swap_buff;
	resx = 512;
	resy = resx;
}

//~ string fileName = "media/images/David.png";
//~ string fileName = "media/images/lenaRGB.png";
//~ string fileName = "media/images/download.jpg";
//~ string fileName = "media/images/dino-blue.jpg";
//~ string fileName = "media/images/Earth.jpg";
string fileName = "media/images/nol.bmp";

define useNativeImpl = true;
gxSurf img = gxSurf(fileName);

int brightness = 0;
int saturation = 0;
int hue = 0;
mat4f mat;

bool reDraw = true;

void mouseCB(int btn, int x, int y) {
	static int ox;
	static int oy;
	int d = oy - y;
	if (Mouse.dblClick(btn, x, y)) {
		Mouse.dblClick(-1, 0, 0);			// disable multi clicks
		reDraw = true;
		brightness = 0;
		saturation = 0;
		hue = 0;
	}
	if (btn == 1) {
		reDraw = true;
		brightness += d;
	}
	if (btn == 2) {
		reDraw = true;
		saturation += d;
	}
	if (btn == 3) {		// left + right
		reDraw = true;
		hue += d;
	}
	ox = x;
	oy = y;
}

mat4f matLuminosity(float val) {
	result.x = vec4f(1., 0., 0., val);
	result.y = vec4f(0., 1., 0., val);
	result.z = vec4f(0., 0., 1., val);
	result.w = vec4f(0., 0., 0.,  1.);
}
mat4f matSaturation(float val) {
	//~ val between 0, 3
	const float inv = 1 - val;
	const float R = .213f * inv;
	const float G = .715f * inv;
	const float B = .072f * inv;
	//~ const float R = .3086 * inv;
	//~ const float G = .6094 * inv;
	//~ const float B = .0820 * inv;

	result.x = vec4f(R + val, G, B, 0.);
	result.y = vec4f(R, G + val, B, 0.);
	result.z = vec4f(R, G, B + val, 0.);
	result.w = vec4f(0., 0., 0., 1.);
}
mat4f matHue(float val) {
	//~ assert(val >= 0 && val <= 2 * Math.pi);
	define lR = 0.213;
	define lG = 0.715;
	define lB = 0.072;
	float cV = float64.cos(val);
	float sV = float64.sin(val);
	result.x = vec4f(lR+cV*(1-lR)+sV*(   -lR), lG+cV*(   -lG)+sV*( -lG), lB+cV*( -lB)+sV*(1 - lB),0.);
	result.y = vec4f(lR+cV*(0-lR)+sV*(0.1430), lG+cV*(1 - lG)+sV*(0.14), lB+cV*( -lB)+sV*(-0.283),0.);
	result.z = vec4f(lR+cV*(0-lR)+sV*(lR - 1), lG+cV*(   -lG)+sV*(  lG), lB+cV*(1-lB)+sV*(    lB),0.);
	result.w = vec4f(0., 0., 0., 1.);
}

mat4f cmatHSL(float hue, float sat, float lum) {

	result = mat4f(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	);

	mat4f tmp;

	tmp = matLuminosity(lum);
	result = mul(&result, &tmp);

	tmp = matSaturation(sat);
	result = mul(&result, &tmp);

	tmp = matHue(hue);
	result = mul(&result, &tmp);
}

void drawCB() {
	if (reDraw) {
		zoomSurf(offScreen, null, img, null, 1);

		brightness = Math.clamp(brightness, -100, 100);
		saturation = Math.clamp(saturation, -100, 200);
		hue = Math.clamp(hue, 0, 360);

		mat = cmatHSL(Math.deg2rad(hue), saturation / 100. + 1, brightness / 100.);

		static if (useNativeImpl) {
			cmatSurf(offScreen, null, &mat);
		}
		static if (!useNativeImpl) {
			vec4f pixelCB(vec4f col) {
				result = dph(mat, col);
			}
			fillSurf(offScreen, null, pixelCB);
			/*fillSurf(offScreen, null, inline vec4f(vec4f col) {
				result = dph(mat, col);
			});*/
		}

		static if (true) {
			int y = 0;
			define dy = 12;
			char txt[1024];
			string str = emit(string, ref(txt));

			format(txt, "brightness: %d", brightness);
			drawText(offScreen, 0, y, str, -1);
			y += dy;

			format(txt, "saturation: %d", saturation);
			drawText(offScreen, 0, y, str, -1);
			y += dy;

			format(txt, "hue: %d", hue);
			drawText(offScreen, 0, y, str, -1);
			y += dy;
		}
		reDraw = false;
	}
}

Gui.setMouseHandler(mouseCB);
Gui.setDrawCallback(drawCB);
