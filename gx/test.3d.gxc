define test = 3;
enum Window {
	draw = RenderMode.drawFill|RenderMode.draw_lit;// & ~RenderMode.zero_cbuf;
	resx = 512;
	resy = 512;
}

define pi = Math.pi;

void meshGen(bool sclosed, bool tclosed, gxSurf heihgtMap) {
	//~ assert(depth(heihgtMap) == 32, "FixMe");
	int vtx = 0;
	int tdiv = width(heihgtMap);
	int sdiv = height(heihgtMap);

	for (int i = 0; i < tdiv; i += 1) {
		double t = i / double(tdiv - 1);
		for (int j = 0; j < sdiv; j += 1) {
			double s = j / double(sdiv - 1);
			mesh.Pos(vtx, s, t, lum(getPixel(heihgtMap, i, j)) / (255. * 6));
			mesh.Nrm(vtx, 0., 0., 1.);
			mesh.Tex(vtx, s, t);
			vtx += 1;
		}
	}
	for (int j = 0; j < tdiv - 1; j += 1) {
		int l1 = j * sdiv;
		int l2 = l1 + sdiv;
		for (int i = 0; i < sdiv - 1; i += 1) {
			int v1 = l1 + i;		// v1 -- v2
			int v2 = v1 + 1;		//  | \  |
			int v4 = l2 + i;		//  |  \ |
			int v3 = v4 + 1;		// v4 -- v3
			mesh.AddFace(v1, v2, v3, v4);
		}
	}
}

void meshGen2(int sdiv, bool sclosed, int tdiv, bool tclosed, void pos(double &x, double &y, double &z, double s, double t), double epsilon) {
	int vtx = 0;

	// set vertex and poly count to 0, but do not free memory
	mesh.Init(-1);

	if (pos != null) {
		double tDiv = tdiv - tclosed;
		double sDiv = sdiv - sclosed;
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / tDiv;
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / sDiv;

				define usev3 = true;

				static if (usev3) {

					struct Vec3{double x; double y; double z;}

					//~ define add(Vec3 &a, Vec3 &b) = Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
					//~ define mul(Vec3 &a, Vec3 &b) = Vec3(a.x * b.x, a.y * b.y, a.z * b.z);
					//~ define div(Vec3 &a, Vec3 &b) = Vec3(a.x / b.x, a.y / b.y, a.z / b.z);

					define sub(Vec3 ^a, Vec3 ^b) = Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
					define div(Vec3 ^a, double ^b) = Vec3(a.x / b, a.y / b, a.z / b);

					define dot(Vec3 ^a, Vec3 ^b) = double(a.x * b.x + a.y * b.y + a.z * b.z);
					define cross(Vec3 ^a, Vec3 ^b) = Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
					//~ define divnz(Vec3 ^a, double ^b) = Vec3(b ? a.x / b : a.x, b ? a.y / b : a.y, b ? a.z / b : a.z);
					define divnz(Vec3 ^a, double ^b) = Vec3(b ? div(a, b) : a);

					Vec3 p;
					Vec3 ds;
					Vec3 dt;
					pos(&p.x, &p.y, &p.z, s, t);
					pos(&ds.x, &ds.y, &ds.z, s + epsilon, t);
					pos(&dt.x, &dt.y, &dt.z, s, t + epsilon);

					ds = div(sub(p, ds), epsilon);
					dt = div(sub(p, dt), epsilon);

					Vec3 n = cross(ds, dt);
					n = divnz(n, sqrt(dot(n, n)));

					mesh.Pos(vtx, p.x, p.y, p.z);
					mesh.Nrm(vtx, n.x, n.y, n.z);
					mesh.Tex(vtx, s, t);
				}

				static if (!usev3) {
					double p[3];
					double n[3];
					double ds[3];
					double dt[3];

					pos(&p[0], &p[1], &p[2], s, t);
					pos(&ds[0], &ds[1], &ds[2], s + epsilon, t);
					pos(&dt[0], &dt[1], &dt[2], s, t + epsilon);

					ds[0] = (p[0] - ds[0]) / epsilon;
					ds[1] = (p[1] - ds[1]) / epsilon;
					ds[2] = (p[2] - ds[2]) / epsilon;
					dt[0] = (p[0] - dt[0]) / epsilon;
					dt[1] = (p[1] - dt[1]) / epsilon;
					dt[2] = (p[2] - dt[2]) / epsilon;

					n[0] = ds[1] * dt[2] - ds[2] * dt[1];
					n[1] = ds[2] * dt[0] - ds[0] * dt[2];
					n[2] = ds[0] * dt[1] - ds[1] * dt[0];

					define sqr(double ^x) = double(x * x);
					double len = sqrt(sqr(n[0]) + sqr(n[1]) + sqr(n[2]));
					if (len != 0) {
						n[0] /= len;
						n[1] /= len;
						n[2] /= len;
					}

					mesh.Pos(vtx, p[0], p[1], p[2]);
					mesh.Nrm(vtx, n[0], n[1], n[2]);
					mesh.Tex(vtx, s, t);

				}

				vtx += 1;
			}
		}
	}
	else {
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / double(tdiv - 1);
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / double(sdiv - 1);
				mesh.Pos(vtx, s, t, 0);
				mesh.Tex(vtx, s, t);
				vtx += 1;
			}
		}
	}
	for (int j = 0; j < tdiv - 1; j += 1) {
		int l1 = j * sdiv;
		int l2 = l1 + sdiv;
		for (int i = 0; i < sdiv - 1; i += 1) {
			int v1 = l1 + i;		// v1 -- v2
			int v2 = v1 + 1;		//  | \  |
			int v4 = l2 + i;		//  |  \ |
			int v3 = v4 + 1;		// v4 -- v3
			mesh.AddFace(v1, v2, v3, v4);
		}
	}
}

/*void meshGen3(int sdiv, bool sclosed, int tdiv, bool tclosed, void pos(double pos[3], double s, double t), double epsilon) {
	int vtx = 0;
	mesh.Init(-1);

	if (pos != null) {
		double tDiv = tdiv - tclosed;
		double sDiv = sdiv - sclosed;
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / tDiv;
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / sDiv;

				define usev3 = true;

				static if (usev3) {

					struct Vec3{double x; double y; double z;}

					//~ define add(Vec3 &a, Vec3 &b) = Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
					//~ define mul(Vec3 &a, Vec3 &b) = Vec3(a.x * b.x, a.y * b.y, a.z * b.z);
					//~ define div(Vec3 &a, Vec3 &b) = Vec3(a.x / b.x, a.y / b.y, a.z / b.z);

					define sub(Vec3 ^a, Vec3 ^b) = Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
					define div(Vec3 ^a, double ^b) = Vec3(a.x / b, a.y / b, a.z / b);

					define dot(Vec3 ^a, Vec3 ^b) = double(a.x * b.x + a.y * b.y + a.z * b.z);
					define cross(Vec3 ^a, Vec3 ^b) = Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
					//~ define divnz(Vec3 ^a, double ^b) = Vec3(b ? a.x / b : a.x, b ? a.y / b : a.y, b ? a.z / b : a.z);
					define divnz(Vec3 ^a, double ^b) = Vec3(b ? div(a, b) : a);

					Vec3 p;
					Vec3 ds;
					Vec3 dt;
					pos(&p, s, t);
					pos(&ds s + epsilon, t);
					pos(&dt, s, t + epsilon);

					ds = div(sub(p, ds), epsilon);
					dt = div(sub(p, dt), epsilon);

					Vec3 n = cross(ds, dt);
					n = divnz(n, sqrt(dot(n, n)));

					mesh.Pos(vtx, p.x, p.y, p.z);
					mesh.Nrm(vtx, n.x, n.y, n.z);
					mesh.Tex(vtx, s, t);
				}

				static if (!usev3) {
					double p[3];
					double n[3];
					double ds[3];
					double dt[3];

					pos(&p[0], &p[1], &p[2], s, t);
					pos(&ds[0], &ds[1], &ds[2], s + epsilon, t);
					pos(&dt[0], &dt[1], &dt[2], s, t + epsilon);

					ds[0] = (p[0] - ds[0]) / epsilon;
					ds[1] = (p[1] - ds[1]) / epsilon;
					ds[2] = (p[2] - ds[2]) / epsilon;
					dt[0] = (p[0] - dt[0]) / epsilon;
					dt[1] = (p[1] - dt[1]) / epsilon;
					dt[2] = (p[2] - dt[2]) / epsilon;

					n[0] = ds[1] * dt[2] - ds[2] * dt[1];
					n[1] = ds[2] * dt[0] - ds[0] * dt[2];
					n[2] = ds[0] * dt[1] - ds[1] * dt[0];

					define sqr(double ^x) = double(x * x);
					double len = sqrt(sqr(n[0]) + sqr(n[1]) + sqr(n[2]));
					if (len != 0) {
						n[0] /= len;
						n[1] /= len;
						n[2] /= len;
					}

					mesh.Pos(vtx, p[0], p[1], p[2]);
					mesh.Nrm(vtx, n[0], n[1], n[2]);
					mesh.Tex(vtx, s, t);

				}

				vtx += 1;
			}
		}
	}
	else {
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / double(tdiv - 1);
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / double(sdiv - 1);
				mesh.Pos(vtx, s, t, 0);
				mesh.Tex(vtx, s, t);
				vtx += 1;
			}
		}
	}
	for (int j = 0; j < tdiv - 1; j += 1) {
		int l1 = j * sdiv;
		int l2 = l1 + sdiv;
		for (int i = 0; i < sdiv - 1; i += 1) {
			int v1 = l1 + i;		// v1 -- v2
			int v2 = v1 + 1;		//  | \  |
			int v4 = l2 + i;		//  |  \ |
			int v3 = v4 + 1;		// v4 -- v3
			mesh.AddFace(v1, v2, v3, v4);
		}
	}
}// */

static if (test == 1) {		// load mesh with texture
mesh.Read("media/meshes/ut2k4/FlackCannon.obj", "media/meshes/ut2k4/FlackCannon.png");
}
static if (test == 2) {		// generate mesh
define resize(gxSurf src, int width, int height) = zoomSurf(gxSurf(width, height), null, src, null, 1);

meshGen(false, false, resize(gxSurf("media/images/hm.jpg"), 256, 256));
}
static if (test == 3) {		// generate mesh

void peak(double &x, double &y, double &z, double s01, double t01) {
	define H = 20.;
	define h = 10.;
	define smin = -H;
	define smax = +H;
	define tmin = -H;
	define tmax = +H;
	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);
	//~ double sst = nz(sqrt(s*s + t*t), 1e-323);
	double sst = sqrt(s*s + t*t);
	x = s / H;
	y = t / H;
	z = h / H * sin(sst) / sst;
}
void drop(double &x, double &y, double &z, double s01, double t01) {
	define sdiv = 128;
	define tdiv = 32;
	define N = 5;
	define H = 3;
	define tmin = 0.;
	define tmax = 2 * pi;
	define smin = 0.;
	define smax = pi;

	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);

	x = .5 * (1 - cos(s)) * sin(s) * cos(t);
	y = .5 * (1 - cos(s)) * sin(s) * sin(t);
	z = cos(s);

	//~ double W = s / (2 * pi);
	//~ x = W * cos(N * s) * (1 + cos(t));
	//~ y = W * sin(N * s) * (1 + cos(t));
	//~ z = W * sin(t) + H * (W * W);
}
void shell(double &x, double &y, double &z, double s01, double t01) {
	define sdiv = 128;
	define tdiv = 32;
	define N = 5;
	define H = 3;
	define tmin = -pi;
	define tmax = +pi;
	define smin = 0.;
	define smax = 2. * pi;

	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);

	double W = s / (2 * pi);
	x = W * cos(N * s) * (1 + cos(t));
	y = W * sin(N * s) * (1 + cos(t));
	z = W * sin(t) + H * (W * W);
}
void ellipse(double &x, double &y, double &z, double s01, double t01) {
	define X = 1;
	define Y = 1;
	define Z = 1;
	define smin = 0.;
	define smax = 2 * pi;
	define tmin = -pi / 2;
	define tmax = +pi / 2;

	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);

	x = X * cos(t) * cos(s);
	y = Y * cos(t) * sin(s);
	z = Z * sin(t);
}
void cilinder(double &x, double &y, double &z, double s01, double t01) {
	define X = 1;
	define Y = 1;
	define Z = 1;
	define smin = 0.;
	define smax = 2.;
	define tmin = 0.;
	define tmax = 2*pi;

	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);

	x = cos(t);
	y = sin(t);
	z = s;
}
void OPXor(double &x, double &y, double &z, double s01, double t01) {
	define H = float64(10);
	x = lerp(1 - s01, -H, H);
	y = lerp(1 - t01, -H, H);
	z = double(int(255 * s01) ^ int(255 * t01)) / (256 / (2*H));
}

void OPPerlin(double &x, double &y, double &z, double s01, double t01) {
	define H = float64(10);
	define M = float64(10);
	x = lerp(1 - s01, -H, H);
	y = lerp(1 - t01, -H, H);
	z = Perlin.Noise(lerp(s01, 0., M), lerp(t01, 0., M));
}

define divisionM = 2;
define divisionS = divisionM * 64;
define divisionT = divisionM * 64;

//~ meshGen(divisionM*8, divisionM, shell);
//~ meshGen(divisionS, true, divisionT, true, OPPerlin, 1e-10);
mesh.Texture(gxSurf("media/images/download.jpg"));
meshGen2(divisionS, true, divisionT, true, shell, 1e-10); 

/*void drawCB() {
	if (start == true) {
		meshGen(divisionS, true, divisionT, true, OPPerlin, 1e-10);
	}
}
Gui.setDrawCallback(drawCB);*/

//~ mesh.Normalize(0);
//~ mesh.Center(2);
}
mesh.Center(2);
//~ mesh.Normalize(1e-10);

static if (true) {			// use custom mouseHandler

mat4f matrix_Rotation(vec4f &dir, float ang) {
	float sin_t = sin(ang);
	float cos_t = cos(ang);
	float one_c = 1. - cos_t;
	vec4f tmp = mul(dir, sin_t);

	float xx = dir.x * dir.x;
	float yy = dir.y * dir.y;
	float zz = dir.z * dir.z;
	float xy = dir.x * dir.y;
	float xz = dir.x * dir.z;
	float yz = dir.y * dir.z;

	result.x.x = one_c * xx + cos_t;
	result.x.y = one_c * xy - tmp.z;
	result.x.z = one_c * xz + tmp.y;
	result.x.w = 0;

	result.y.x = one_c * xy + tmp.z;
	result.y.y = one_c * yy + cos_t;
	result.y.z = one_c * yz - tmp.x;
	result.y.w = 0;

	result.z.x = one_c * xz - tmp.y;
	result.z.y = one_c * yz + tmp.x;
	result.z.z = one_c * zz + cos_t;
	result.z.w = 0;

	result.w = vec4f(0., 0., 0., 1.);
}
mat4f matrix_Translation(vec4f &dir, float cnt) {
	vec4f tmp = mul(dir, vec4f(cnt));

	result.x.x = 1;
	result.x.y = 0;
	result.x.z = 0;
	result.x.w = tmp.x;

	result.y.x = 0;
	result.y.y = 1;
	result.y.z = 0;
	result.y.w = tmp.y;

	result.z.x = 0;
	result.z.y = 0;
	result.z.z = 1;
	result.z.w = tmp.z;

	result.w.x = 0;
	result.w.y = 0;
	result.w.z = 0;
	result.w.w = tmp.w;
}

void camera_Rotate(vec4f &dir, vec4f &orbit, float ang) {

	if (ang != 0) {

		mat4f tmp = matrix_Rotation(dir, ang);

		camera.Forward(normalize(dp3(tmp, camera.Forward)));
		camera.Right(normalize(dp3(tmp, camera.Right)));
		camera.Up(cross(camera.Forward, camera.Right));

		if (orbit != null) {
			define lookAtOrbit = !true;
			vec4f dir2 = sub(orbit, camera.Pos);
			float dist = sqrt(dp3(dir2, dir2));

			static if (!lookAtOrbit) {	// camera will just rotate arund orbit
				vec4f x = normalize(dph(tmp, dir2));
				tmp = matrix_Translation(&x, -dist);
			}

			static if (lookAtOrbit) {	// camera will rotate and look at orbit
				vec4f x = camera.Forward;
				tmp = matrix_Translation(&x, -dist);
			}

			camera.Pos(dph(tmp, orbit));
		}// +/
	}// */
}
void camera_Move(vec4f &dir, float step) {
	camera.Pos(add(camera.Pos, mul(dir, step)));
}

void mouseHandler(int btn, int x, int y) {
	static int ox;
	static int oy;
	float dx = x - ox;
	float dy = y - oy;
	ox = x;
	oy = y;

	//~ define toRadians(double x) = double(x * pi / 180.);
	define moveSlow = .08;
	define rotateSlow = moveSlow * pi / 180.;
	define rotateFast = 10 * rotateSlow;

	if (dblClick(btn, x, y)) {
		dblClick(-1, 0, 0);
		camera.LookAt(
			vec4f(0., 0., 16.),		// eye
			vec4f(0., 0., 0.),		// target
			vec4f(0., 1., 0.)		// up
		);
	}

	if (btn == 1) {	// orbit the camera
		vec4f orbit = vec4f(0., 0., 0., 0.);
		if (dx) {
			vec4f direction = camera.Up;
			camera_Rotate(&direction, &orbit, dx * rotateFast);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera_Rotate(&direction, &orbit, dy * rotateFast);
		}
	}
	if (btn == 2) {	// rotate the camera
		// if no orbit is given, orbit will be the camera position.
		//~ static vec4f orbit = camera.Pos();
		if (dx) {
			vec4f direction = camera.Up;
			camera_Rotate(&direction, null, dx * rotateSlow);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera_Rotate(&direction, null, dy * rotateSlow);
		}
	}
	if (btn == 1+2) {	// move forward / back
		vec4f direction = camera.Forward;
		camera_Move(&direction, dy * moveSlow);
	}
}

Gui.setMouseHandler(mouseHandler);
}

mesh.Info();
//~ mesh.Save("mesh.obj");
//~ Gui.exitLoop();
