const test = 2;
const Window {
	draw = RenderMode.drawFill|RenderMode.draw_lit;// & ~RenderMode.zero_cbuf;
	resx = 512/2;
	resy = 512/2;
}

const pi = Math.pi;

static if (true) {		// perlin noise

const B = 0x100;
const BM = 0xff;
const N = 0x1000;
const NP = 12;   /* 2^N */
const NM = 0xfff;

int p[B + B + 2];
float g3[B + B + 2][3];
float g2[B + B + 2][2];
float g1[B + B + 2];

bool start = true;

static void init(void) {
	int i;
	define sqr(float ^x) = float(x * x);
	for (i = 0 ; i < B ; i+=1) {
		p[i] = i;

		g1[i] = float((rand() % (B + B)) - B) / B;

		for (int j = 0 ; j < 2 ; j+=1)
			g2[i][j] = float((rand() % (B + B)) - B) / B;

		//~ normalize2(g2[i]);
		float n2 = sqrt(sqr(g2[i][0]) + sqr(g2[i][1]));
		if (n2 != 0) {
			g2[i][0] /= n2;
			g2[i][1] /= n2;
		}

		for (int j = 0 ; j < 3 ; j+=1)
			g3[i][j] = float((rand() % (B + B)) - B) / B;

		//~ normalize3(g3[i]);
		float n3 = sqrt(sqr(g3[i][0]) + sqr(g3[i][1]) + sqr(g3[i][1]));
		if (n3 != 0) {
			g3[i][0] /= n3;
			g3[i][1] /= n3;
			g3[i][2] /= n3;
		}
	}

	for (;i -= 1;) {
		int k = p[i];
		int j = rand() % B;
		p[i] = p[j];
		p[j] = k;
	}

	for (i = 0 ; i < B + 2 ; i+=1) {
		p[B + i] = p[i];
		g1[B + i] = g1[i];
		for (int j = 0 ; j < 2 ; j+=1)
			g2[B + i][j] = g2[i][j];
		for (int j = 0 ; j < 3 ; j+=1)
			g3[B + i][j] = g3[i][j];
	}
}

static void setup(float vec_i, int &b0, int &b1, float &r0,float &r1) {
	float t = vec_i + N;
	b0 = int(t) & BM;
	b1 = (b0+1) & BM;
	r0 = t - int(t);
	r1 = r0 - 1.;
}

define s_curve(double t) = smooth(t);
//~ define s_curve(double ^t) = double( t * t * (3. - 2. * t) );

float noise(float x) {
	int bx0;
	int bx1;
	float rx0;
	float rx1;
	float sx;
	float u;
	float v;

	if (start) {
		start = false;
		init();
	}

	setup(x, &bx0, &bx1, &rx0, &rx1);

	sx = s_curve(rx0);

	u = rx0 * g1[ p[ bx0 ] ];
	v = rx1 * g1[ p[ bx1 ] ];

	result = lerp(sx, u, v);
}
float noise(float x, float y) {
	int bx0;
	int bx1;
	int by0;
	int by1;
	float rx0;
	float rx1;
	float ry0;
	float ry1;

	if (start) {
		start = false;
		init();
	}

	setup(x, &bx0, &bx1, &rx0, &rx1);
	setup(y, &by0, &by1, &ry0, &ry1);

	int i = p[ bx0 ];
	int j = p[ bx1 ];

	int b00 = p[ i + by0 ];
	int b10 = p[ j + by0 ];
	int b01 = p[ i + by1 ];
	int b11 = p[ j + by1 ];

	float sx = s_curve(rx0);
	float sy = s_curve(ry0);

	define at2(float rx, float ry, int i) = float( rx * g2[i][0] + ry * g2[i][1] );

	float a = lerp(sx, at2(rx0,ry0, b00), at2(rx1,ry0, b10));
	float b = lerp(sx, at2(rx0,ry1, b01), at2(rx1,ry1, b11));

	result = lerp(sy, a, b);
}
float noise(float x, float y, float z) {

	int bx0;
	int bx1;
	int by0;
	int by1;
	int bz0;
	int bz1;
	float rx0;
	float rx1;
	float ry0;
	float ry1;
	float rz0;
	float rz1;

	if (start) {
		start = false;
		init();
	}

	setup(x, &bx0, &bx1, &rx0, &rx1);
	setup(y, &by0, &by1, &ry0, &ry1);
	setup(z, &bz0, &bz1, &rz0, &rz1);

	int i = p[ bx0 ];
	int j = p[ bx1 ];

	int b00 = p[ i + by0 ];
	int b10 = p[ j + by0 ];
	int b01 = p[ i + by1 ];
	int b11 = p[ j + by1 ];

	float sx = s_curve(rx0);
	float sy = s_curve(ry0);
	float sz = s_curve(rz0);

	define at3(float rx, float ry, float rz, int i) = float( rx * g3[i][0] + ry * g3[i][1] + rz * g3[i][2] );

	float a;
	float b;
	float c;
	float d;
	float u;
	float v;

	u = at3(rx0,ry0,rz0, b00 + bz0);
	v = at3(rx1,ry0,rz0, b10 + bz0);
	a = lerp(sx, u, v);

	u = at3(rx0,ry1,rz0, b01 + bz0);
	v = at3(rx1,ry1,rz0, b11 + bz0);
	b = lerp(sx, u, v);

	c = lerp(sy, a, b);

	u = at3(rx0,ry0,rz1, b00 + bz1);
	v = at3(rx1,ry0,rz1, b10 + bz1);
	a = lerp(sx, u, v);

	u = at3(rx0,ry1,rz1, b01 + bz1);
	v = at3(rx1,ry1,rz1, b11 + bz1);
	b = lerp(sx, u, v);

	d = lerp(sy, a, b);

	result = lerp(sz, c, d);
}
}

void meshGen2(int sdiv, bool sclosed, int tdiv, bool tclosed, void pos(double &x, double &y, double &z, double s, double t), double epsilon) {
	int vtx = 0;
	mesh.Init(-1);

	if (pos != null) {
		double tDiv = tdiv - tclosed;
		double sDiv = sdiv - sclosed;
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / tDiv;
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / sDiv;

				const usev3 = true;

				static if (usev3) {

					struct Vec3{double x; double y; double z;}

					//~ define add(Vec3 &a, Vec3 &b) = Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
					//~ define mul(Vec3 &a, Vec3 &b) = Vec3(a.x * b.x, a.y * b.y, a.z * b.z);
					//~ define div(Vec3 &a, Vec3 &b) = Vec3(a.x / b.x, a.y / b.y, a.z / b.z);

					define sub(Vec3 ^a, Vec3 ^b) = Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
					define div(Vec3 ^a, double ^b) = Vec3(a.x / b, a.y / b, a.z / b);

					define dot(Vec3 ^a, Vec3 ^b) = double(a.x * b.x + a.y * b.y + a.z * b.z);
					define cross(Vec3 ^a, Vec3 ^b) = Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
					//~ define divnz(Vec3 ^a, double ^b) = Vec3(b ? a.x / b : a.x, b ? a.y / b : a.y, b ? a.z / b : a.z);
					define divnz(Vec3 ^a, double ^b) = Vec3(b ? div(a, b) : a);

					Vec3 p;
					Vec3 ds;
					Vec3 dt;
					pos(&p.x, &p.y, &p.z, s, t);
					pos(&ds.x, &ds.y, &ds.z, s + epsilon, t);
					pos(&dt.x, &dt.y, &dt.z, s, t + epsilon);

					ds = div(sub(p, ds), epsilon);
					dt = div(sub(p, dt), epsilon);

					Vec3 n = cross(ds, dt);
					n = divnz(n, sqrt(dot(n, n)));

					mesh.Pos(vtx, p.x, p.y, p.z);
					mesh.Nrm(vtx, n.x, n.y, n.z);
					mesh.Tex(vtx, s, t);
				}

				static if (!usev3) {
					double p[3];
					double n[3];
					double ds[3];
					double dt[3];

					pos(&p[0], &p[1], &p[2], s, t);
					pos(&ds[0], &ds[1], &ds[2], s + epsilon, t);
					pos(&dt[0], &dt[1], &dt[2], s, t + epsilon);

					ds[0] = (p[0] - ds[0]) / epsilon;
					ds[1] = (p[1] - ds[1]) / epsilon;
					ds[2] = (p[2] - ds[2]) / epsilon;
					dt[0] = (p[0] - dt[0]) / epsilon;
					dt[1] = (p[1] - dt[1]) / epsilon;
					dt[2] = (p[2] - dt[2]) / epsilon;

					n[0] = ds[1] * dt[2] - ds[2] * dt[1];
					n[1] = ds[2] * dt[0] - ds[0] * dt[2];
					n[2] = ds[0] * dt[1] - ds[1] * dt[0];

					define sqr(double ^x) = double(x * x);
					double len = sqrt(sqr(n[0]) + sqr(n[1]) + sqr(n[2]));
					if (len != 0) {
						n[0] /= len;
						n[1] /= len;
						n[2] /= len;
					}

					mesh.Pos(vtx, p[0], p[1], p[2]);
					mesh.Nrm(vtx, n[0], n[1], n[2]);
					mesh.Tex(vtx, s, t);

				}

				vtx += 1;
			}
		}
	}
	else {
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / double(tdiv - 1);
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / double(sdiv - 1);
				mesh.Pos(vtx, s, t, 0);
				mesh.Tex(vtx, s, t);
				vtx += 1;
			}
		}
	}
	for (int j = 0; j < tdiv - 1; j += 1) {
		int l1 = j * sdiv;
		int l2 = l1 + sdiv;
		for (int i = 0; i < sdiv - 1; i += 1) {
			int v1 = l1 + i;		// v1 -- v2
			int v2 = v1 + 1;		//  | \  |
			int v4 = l2 + i;		//  |  \ |
			int v3 = v4 + 1;		// v4 -- v3
			mesh.AddFace(v1, v2, v3, v4);
		}
	}
}

/*void meshGen3(int sdiv, bool sclosed, int tdiv, bool tclosed, void pos(double pos[3], double s, double t), double epsilon) {
	int vtx = 0;
	mesh.Init(-1);

	if (pos != null) {
		double tDiv = tdiv - tclosed;
		double sDiv = sdiv - sclosed;
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / tDiv;
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / sDiv;

				const usev3 = true;

				static if (usev3) {

					struct Vec3{double x; double y; double z;}

					//~ define add(Vec3 &a, Vec3 &b) = Vec3(a.x + b.x, a.y + b.y, a.z + b.z);
					//~ define mul(Vec3 &a, Vec3 &b) = Vec3(a.x * b.x, a.y * b.y, a.z * b.z);
					//~ define div(Vec3 &a, Vec3 &b) = Vec3(a.x / b.x, a.y / b.y, a.z / b.z);

					define sub(Vec3 ^a, Vec3 ^b) = Vec3(a.x - b.x, a.y - b.y, a.z - b.z);
					define div(Vec3 ^a, double ^b) = Vec3(a.x / b, a.y / b, a.z / b);

					define dot(Vec3 ^a, Vec3 ^b) = double(a.x * b.x + a.y * b.y + a.z * b.z);
					define cross(Vec3 ^a, Vec3 ^b) = Vec3(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
					//~ define divnz(Vec3 ^a, double ^b) = Vec3(b ? a.x / b : a.x, b ? a.y / b : a.y, b ? a.z / b : a.z);
					define divnz(Vec3 ^a, double ^b) = Vec3(b ? div(a, b) : a);

					Vec3 p;
					Vec3 ds;
					Vec3 dt;
					pos(&p, s, t);
					pos(&ds s + epsilon, t);
					pos(&dt, s, t + epsilon);

					ds = div(sub(p, ds), epsilon);
					dt = div(sub(p, dt), epsilon);

					Vec3 n = cross(ds, dt);
					n = divnz(n, sqrt(dot(n, n)));

					mesh.Pos(vtx, p.x, p.y, p.z);
					mesh.Nrm(vtx, n.x, n.y, n.z);
					mesh.Tex(vtx, s, t);
				}

				static if (!usev3) {
					double p[3];
					double n[3];
					double ds[3];
					double dt[3];

					pos(&p[0], &p[1], &p[2], s, t);
					pos(&ds[0], &ds[1], &ds[2], s + epsilon, t);
					pos(&dt[0], &dt[1], &dt[2], s, t + epsilon);

					ds[0] = (p[0] - ds[0]) / epsilon;
					ds[1] = (p[1] - ds[1]) / epsilon;
					ds[2] = (p[2] - ds[2]) / epsilon;
					dt[0] = (p[0] - dt[0]) / epsilon;
					dt[1] = (p[1] - dt[1]) / epsilon;
					dt[2] = (p[2] - dt[2]) / epsilon;

					n[0] = ds[1] * dt[2] - ds[2] * dt[1];
					n[1] = ds[2] * dt[0] - ds[0] * dt[2];
					n[2] = ds[0] * dt[1] - ds[1] * dt[0];

					define sqr(double ^x) = double(x * x);
					double len = sqrt(sqr(n[0]) + sqr(n[1]) + sqr(n[2]));
					if (len != 0) {
						n[0] /= len;
						n[1] /= len;
						n[2] /= len;
					}

					mesh.Pos(vtx, p[0], p[1], p[2]);
					mesh.Nrm(vtx, n[0], n[1], n[2]);
					mesh.Tex(vtx, s, t);

				}

				vtx += 1;
			}
		}
	}
	else {
		for (int i = 0; i < tdiv; i += 1) {
			double t = i / double(tdiv - 1);
			for (int j = 0; j < sdiv; j += 1) {
				double s = j / double(sdiv - 1);
				mesh.Pos(vtx, s, t, 0);
				mesh.Tex(vtx, s, t);
				vtx += 1;
			}
		}
	}
	for (int j = 0; j < tdiv - 1; j += 1) {
		int l1 = j * sdiv;
		int l2 = l1 + sdiv;
		for (int i = 0; i < sdiv - 1; i += 1) {
			int v1 = l1 + i;		// v1 -- v2
			int v2 = v1 + 1;		//  | \  |
			int v4 = l2 + i;		//  |  \ |
			int v3 = v4 + 1;		// v4 -- v3
			mesh.AddFace(v1, v2, v3, v4);
		}
	}
}// */

static if (test == 1) {		// load mesh with texture
mesh.Read("media/meshes/ut2k4/FlackCannon.obj", "media/meshes/ut2k4/FlackCannon.png");
mesh.Center(2);
}
static if (test == 2) {		// generate mesh

void peak(double &x, double &y, double &z, double s01, double t01) {
	define H = 20.;
	define h = 10.;
	define smin = -H;
	define smax = +H;
	define tmin = -H;
	define tmax = +H;
	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);
	//~ double sst = nz(sqrt(s*s + t*t), 1e-323);
	double sst = sqrt(s*s + t*t);
	x = s / H;
	y = t / H;
	z = h / H * sin(sst) / sst;
}
void drop(double &x, double &y, double &z, double s01, double t01) {
	define sdiv = 128;
	define tdiv = 32;
	define N = 5;
	define H = 3;
	define tmin = 0.;
	define tmax = 2 * pi;
	define smin = 0.;
	define smax = pi;

	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);

	x = .5 * (1 - cos(s)) * sin(s) * cos(t);
	y = .5 * (1 - cos(s)) * sin(s) * sin(t);
	z = cos(s);

	//~ double W = s / (2 * pi);
	//~ x = W * cos(N * s) * (1 + cos(t));
	//~ y = W * sin(N * s) * (1 + cos(t));
	//~ z = W * sin(t) + H * (W * W);
}
void shell(double &x, double &y, double &z, double s01, double t01) {
	define sdiv = 128;
	define tdiv = 32;
	define N = 5;
	define H = 3;
	define tmin = -pi;
	define tmax = +pi;
	define smin = 0.;
	define smax = 2. * pi;

	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);

	double W = s / (2 * pi);
	x = W * cos(N * s) * (1 + cos(t));
	y = W * sin(N * s) * (1 + cos(t));
	z = W * sin(t) + H * (W * W);
}
void ellipse(double &x, double &y, double &z, double s01, double t01) {
	define X = 1;
	define Y = 1;
	define Z = 1;
	define smin = 0.;
	define smax = 2 * pi;
	define tmin = -pi / 2;
	define tmax = +pi / 2;

	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);

	x = X * cos(t) * cos(s);
	y = Y * cos(t) * sin(s);
	z = Z * sin(t);
}
void cilinder(double &x, double &y, double &z, double s01, double t01) {
	define X = 1;
	define Y = 1;
	define Z = 1;
	define smin = 0.;
	define smax = 2.;
	define tmin = 0.;
	define tmax = 2*pi;

	double s = lerp(s01, smin, smax);
	double t = lerp(t01, tmin, tmax);

	x = cos(t);
	y = sin(t);
	z = s;
}
void OPXor(double &x, double &y, double &z, double s01, double t01) {
	const H = float64(10);
	x = lerp(1 - s01, -H, H);
	y = lerp(1 - t01, -H, H);
	z = double(int(255 * s01) ^ int(255 * t01)) / (256 / (2*H));
}

void OPPerlin(double &x, double &y, double &z, double s01, double t01) {
	const H = float64(10);
	const M = float64(10);
	x = lerp(1 - s01, -H, H);
	y = lerp(1 - t01, -H, H);
	z = noise(lerp(s01, 0., M), lerp(t01, 0., M));
}

const divisionM = 2;
const divisionS = divisionM * 64;
const divisionT = divisionM * 64;

//~ meshGen(divisionM*8, divisionM, shell);
//~ meshGen(divisionS, true, divisionT, true, OPPerlin, 1e-10);
mesh.Texture(gxSurf("media/images/download.jpg"));
meshGen(divisionS, true, divisionT, true, OPPerlin, 1e-10); 

/*void drawCB() {
	if (start == true) {
		meshGen(divisionS, true, divisionT, true, OPPerlin, 1e-10);
	}
}
Gui.setDrawCallback(drawCB);*/

//~ mesh.Normalize(0);
//~ mesh.Center(2);
}
mesh.Center(2);

static if (true) {			// use custom mouseHandler

mat4f matrix_Rotation(vec4f &dir, float ang) {
	float sin_t = sin(ang);
	float cos_t = cos(ang);
	float one_c = 1. - cos_t;
	vec4f tmp = mul(dir, sin_t);

	float xx = dir.x * dir.x;
	float yy = dir.y * dir.y;
	float zz = dir.z * dir.z;
	float xy = dir.x * dir.y;
	float xz = dir.x * dir.z;
	float yz = dir.y * dir.z;

	result.x.x = one_c * xx + cos_t;
	result.x.y = one_c * xy - tmp.z;
	result.x.z = one_c * xz + tmp.y;
	result.x.w = 0;

	result.y.x = one_c * xy + tmp.z;
	result.y.y = one_c * yy + cos_t;
	result.y.z = one_c * yz - tmp.x;
	result.y.w = 0;

	result.z.x = one_c * xz - tmp.y;
	result.z.y = one_c * yz + tmp.x;
	result.z.z = one_c * zz + cos_t;
	result.z.w = 0;

	result.w = vec4f(0., 0., 0., 1.);
}
mat4f matrix_Translation(vec4f &dir, float cnt) {
	vec4f tmp = mul(dir, vec4f(cnt));

	result.x.x = 1;
	result.x.y = 0;
	result.x.z = 0;
	result.x.w = tmp.x;

	result.y.x = 0;
	result.y.y = 1;
	result.y.z = 0;
	result.y.w = tmp.y;

	result.z.x = 0;
	result.z.y = 0;
	result.z.z = 1;
	result.z.w = tmp.z;

	result.w.x = 0;
	result.w.y = 0;
	result.w.z = 0;
	result.w.w = tmp.w;
}

void camera_Rotate(vec4f &dir, vec4f &orbit, float ang) {

	if (ang != 0) {

		mat4f tmp = matrix_Rotation(dir, ang);

		camera.Forward(normalize(dp3(tmp, camera.Forward)));
		camera.Right(normalize(dp3(tmp, camera.Right)));
		camera.Up(cross(camera.Forward, camera.Right));

		if (orbit != null) {
			const lookAtOrbit = !true;
			vec4f dir2 = sub(orbit, camera.Pos);
			float dist = sqrt(dp3(dir2, dir2));

			static if (!lookAtOrbit) {	// camera will just rotate arund orbit
				vec4f x = normalize(dph(tmp, dir2));
				tmp = matrix_Translation(&x, -dist);
			}

			static if (lookAtOrbit) {	// camera will rotate and look at orbit
				vec4f x = camera.Forward;
				tmp = matrix_Translation(&x, -dist);
			}

			camera.Pos(dph(tmp, orbit));
		}// +/
	}// */
}
void camera_Move(vec4f &dir, float step) {
	camera.Pos(add(camera.Pos, mul(dir, step)));
}

void mouseHandler(int btn, int x, int y) {
	static int ox;
	static int oy;
	float dx = x - ox;
	float dy = y - oy;
	ox = x;
	oy = y;

	//~ define toRadians(double x) = double(x * pi / 180.);
	const moveSlow = .08;
	const rotateSlow = moveSlow * pi / 180.;
	const rotateFast = 10 * rotateSlow;

	if (dblClick(btn, x, y)) {
		dblClick(-1, 0, 0);
		camera.LookAt(
			vec4f(0., 0., 16.),		// eye
			vec4f(0., 0., 0.),		// target
			vec4f(0., 1., 0.)		// up
		);
	}

	if (btn == 1) {	// orbit the camera
		vec4f orbit = vec4f(0., 0., 0., 0.);
		if (dx) {
			vec4f direction = camera.Up;
			camera_Rotate(&direction, &orbit, dx * rotateFast);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera_Rotate(&direction, &orbit, dy * rotateFast);
		}
	}
	if (btn == 2) {	// rotate the camera
		// if no orbit is given, orbit will be the camera position.
		//~ static vec4f orbit = camera.Pos();
		if (dx) {
			vec4f direction = camera.Up;
			camera_Rotate(&direction, null, dx * rotateSlow);
		}
		if (dy) {
			vec4f direction = camera.Right;
			camera_Rotate(&direction, null, dy * rotateSlow);
		}
	}
	if (btn == 1+2) {	// move forward / back
		vec4f direction = camera.Forward;
		camera_Move(&direction, dy * moveSlow);
	}
}

Gui.setMouseHandler(mouseHandler);
}

mesh.Info();
//~ mesh.Save("mesh.obj");
//~ Gui.exitLoop();
